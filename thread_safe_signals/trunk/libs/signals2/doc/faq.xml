<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<section last-revision="$Date: 2007-06-12 14:01:23 -0400 (Tue, 12 Jun 2007) $">
  <title>Frequently Asked Questions</title>

  <using-namespace name="boost"/>
  <using-namespace name="boost::signals2"/>

  <qandaset>
    <qandaentry>
      <question>
        <para>Don't noncopyable signal semantics mean that a class
        with a signal member will be noncopyable as well?</para>
      </question>
      <answer>
        <para>No. The compiler will not be able to generate a copy
        constructor or copy assignment operator for your class if it
        has a signal as a member, but you are free to write your own
        copy constructor and/or copy assignment operator. Just don't
        try to copy the signal.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
        <para>Is Boost.Signals2 thread-safe?</para>
      </question>
      <answer>
        <para>
          Yes, as long as the Mutex template parameter is not set to
          a fake mutex type like <classname>boost::signals2::dummy_mutex</classname>.
          Also, if your slots depend on objects which may be destroyed concurrently
          with signal invocation, you will need to use automatic connection management.
          That is, the objects will need to be owned by
          <classname>shared_ptr</classname> and passed to the slot's
          <methodname alt="slotN::track">track</methodname>() method before the slot is connected.
        </para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question><para>How has the API changed from the original Boost.Signals?</para></question>
      <answer>
        <para>In summary, the following changes have been made to the signals API:</para>
        <itemizedlist>
          <listitem>
            <para>
              Automatic connection management is achieved through the use of <classname>shared_ptr</classname>/<classname>weak_ptr</classname>
              and <methodname alt="slotN::track">slot::track</methodname>(), as opposed to the old <code>boost::trackable</code>
              base class.
            </para>
          </listitem>
          <listitem>
            <para>
              The <classname>slot</classname> class takes a new <code>Signature</code> template parameter,
              is useable as a function object, and is generally more featureful.
            </para>
          </listitem>
          <listitem>
            <para>
              The <classname>optional_last_value</classname> has replaced <classname>last_value</classname>
              as the default combiner for signals.
            </para>
            <para>
              The <classname>last_value</classname> combiner is still provided, and it
              throws an exception instead of requiring at least one slot to be connected
              on signal invocation (except for its void specialization which does not require any
              slots to be connected).
            </para>
          </listitem>
          <listitem>
            <para>
              The <classname>signal</classname> class has an additional template parameter for specifying
              the mutex type used internally by the signal.
            </para>
            <para>The <code>signal::combiner()</code> method, which formerly returned a reference to the
              signal's combiner has been replaced by <methodname alt="signalN::combiner">signal::combiner</methodname>
              (which now returns the combiner by value) and <methodname alt="signalN::set_combiner">signal::set_combiner</methodname>.
            </para>
          </listitem>
          <listitem>
            <para><code>boost::visit_each</code>, which was used to find <code>boost::trackable</code> objects,
              is gone.
            </para>
          </listitem>
          <listitem>
            <para>Connections no longer have <code>block()</code> and <code>unblock()</code> methods.  Blocking
              of connections is now accomplished by creating <classname>shared_connection_block</classname> objects.
            </para>
          </listitem>
          <listitem>
            <para>Support for postconstructors (and predestructors) on objects managed by <classname>shared_ptr</classname>
              has been added with
              <functionname>deconstruct_ptr</functionname>, <classname>postconstructible</classname>,
              and <classname>predestructible</classname>.  This was motivated by the importance of
              <code>shared_ptr</code> for the new connection tracking scheme, and the
              inability to obtain a <code>shared_ptr</code> to an object in its constructor.
            </para>
          </listitem>
          <listitem>
            <para>The namespace <code>boost::signals</code> has been replaced by <code>boost::signals2</code>
              to avoid conflict with the original Signals implementation, and the Qt "signals" macro.
              Also, some classes and headers
              have been moved to comply with Boost's guidelines.  For example, the signal class is now
              in the boost::signals2 namespace instead of the boost namespace,
              and it's header file is now at boost/signals2/signal.hpp instead of boost/signal.hpp.
            </para>
          </listitem>
        </itemizedlist>
      </answer>
    </qandaentry>
  </qandaset>
</section>
