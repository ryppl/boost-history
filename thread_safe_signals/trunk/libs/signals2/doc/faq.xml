<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<section last-revision="$Date: 2007-06-12 14:01:23 -0400 (Tue, 12 Jun 2007) $">
  <title>Frequently Asked Questions</title>

  <using-namespace name="boost"/>
  <using-namespace name="boost::signalslib"/>

  <qandaset>
    <qandaentry>
      <question>
        <para>Don't noncopyable signal semantics mean that a class
        with a signal member will be noncopyable as well?</para>
      </question>
      <answer>
        <para>No. The compiler will not be able to generate a copy
        constructor or copy assignment operator for your class if it
        has a signal as a member, but you are free to write your own
        copy constructor and/or copy assignment operator. Just don't
        try to copy the signal.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
        <para>Is Boost.Signals thread-safe?</para>
      </question>
      <answer>
        <para>Yes, if the ThreadingModel template parameter of the signal is set to
        <code>boost::signalslib::multi_threaded</code>, or if it is set to
        <code>boost::signalslib::auto_threaded</code> and boost has detected thread support
        in the compiler's current translation mode.  If you use <code>boost::signalslib::multi_threaded</code>,
        you will also have to link to libboost_thread.</para>
      </answer>
    </qandaentry>
    <qandaentry>
      <question>
        <para>How do I get Boost.Signals to work with Qt?</para>
      </question>
      <answer>
        <para>When building with Qt, the Moc keywords
        <code>signals</code> and <code>slots</code> are defined using
        preprocessor macros, causing a conflict with the <code>boost::signals</code>
        namespace.  For thread_safe_signals, <code>boost::signals</code> is actually
        just a namespace alias to <code>boost::signalslib</code>.  So by always using the
        namespace <code>boost::signalslib</code> instead of
        <code>boost::signals</code> in your
        code, you can avoid any conflict with the Qt <code>signals</code> macro.
        </para>

        <para>Alternatively, for <emphasis>Qt 4.1 and later</emphasis>
        the <code>signals</code> and <code>slots</code> macros
        can be turned off in Qt on a per-project or per-file basis
        with the <code>no_keywords</code> option.  This works with
        out-of-the-box builds of Boost and Qt. You do not need to
        re-configure, re-build, or duplicate existing libraries. For a
        project where you want to use both Boost.Signals and Qt
        Signals and Slots, the relevant part of your .pro file might
        look like this:</para>

        <programlisting>CONFIG      += no_keywords # so Qt won't #define any non-all-caps `keywords'
INCLUDEPATH += . /usr/local/include/thread_safe_signals /usr/local/include/boost-1_33_1/ # ...your exact paths may vary
</programlisting>

        <para>Now you can mix Boost.Signals and Qt Signals and Slots
        in the same files, and even within the same class or function.
        You will have to use the upper-case versions of Qt macros in
        your own code.  See the article <ulink
        url="http://scottcollins.net/articles/a-deeper-look-at-signals-and-slots.html">A
        Deeper Look at Signals and Slots</ulink> [off-site] for more
        complete examples and a survey of the strengths of the two
        systems.</para>

      </answer>
    </qandaentry>
    <qandaentry>
      <question><para>How has the API changed from the original Boost.Signals?</para></question>
      <answer>
        <para>In summary, the following changes have been made to the signals API:</para>
        <itemizedlist>
          <listitem>
            <para>
              Automatic connection management is achieved through the use of <classname>shared_ptr</classname>/<classname>weak_ptr</classname>
              and <methodname alt="slotN::track">slot::track</methodname>(), as opposed to the old <code>boost::trackable</code>
              base class.
            </para>
          </listitem>
          <listitem>
            <para>
              The <classname>slot</classname> class takes a new <code>Signature</code> template parameter,
              is useable as a function object, and is generally more featureful.
            </para>
          </listitem>
          <listitem>
            <para>
              The <classname>last_value</classname> combiner throws an exception instead of producing undefined
              behavior when used with no slots connected (except for its specializations which do not require any
              slots to be connected).  An additional specialization
              last_value&lt;<classname>optional</classname>&lt;T&gt;&nbsp;&gt; (which does not throw) has been added.
            </para>
          </listitem>
          <listitem>
            <para>
              The <classname>signal</classname> class has an additional template parameter for specifying
              the threading model.
            </para>
            <para>The <code>signal::combiner()</code> method, which formerly returned a reference to the
              signal's combiner has been replaced by <methodname alt="signalN::combiner">signal::combiner</methodname>
              (which now returns the combiner by value) and <methodname alt="signalN::set_combiner">signal::set_combiner</methodname>.
            </para>
          </listitem>
          <listitem>
            <para>User-defined combiners are now expected to handle the possibility of a slot throwing an
              <classname>expired_slot</classname> exception due to automatic disconnection.
            </para>
          </listitem>
          <listitem>
            <para><code>boost::visit_each</code>, which was used to find <code>boost::trackable</code> objects,
              is gone.
            </para>
          </listitem>
          <listitem>
            <para>Connections no longer have <code>block()</code> and <code>unblock()</code> methods.  Blocking
              of connections is now accomplished by creating <classname>shared_connection_block</classname> objects.
            </para>
          </listitem>
          <listitem>
            <para>Support for postconstructors (and predestructors) on objects managed by <classname>shared_ptr</classname>
              has been added with
              <functionname>deconstruct_ptr</functionname>, <classname>postconstructible</classname>,
              and <classname>predestructible</classname>.  This was motivated by the importance of
              <code>shared_ptr</code> for the new connection tracking scheme, and the
              inability to obtain a <code>shared_ptr</code> to an object in its constructor.
            </para>
          </listitem>
          <listitem>
            <para>The namespace <code>boost::signals</code> has been renamed <code>boost::signalslib</code>
              to avoid conflict with Qt's signal macro.  For backward compatibility, a <code>boost::signals</code>
              namespace alias is provided.
            </para>
          </listitem>
        </itemizedlist>
      </answer>
    </qandaentry>
  </qandaset>
</section>
