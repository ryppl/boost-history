<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TODO</title>
<link rel="stylesheet" href="../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="Contract++ 0.3.490">
<link rel="up" href="../index.html" title="Contract++ 0.3.490">
<link rel="prev" href="release_history.html" title="Release History">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="release_history.html"><img src=".././doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src=".././doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src=".././doc/html/images/home.png" alt="Home"></a>
</div>
<hr>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="contract__.todo"></a><a class="link" href="todo.html" title="TODO">TODO</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="todo.html#contract__.todo.improve_contract_macros__sequence__error_detection_and_reporting">Improve
      contract macros <code class="computeroutput"><span class="identifier">sequence</span></code> error
      detection and reporting</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.can_block_invariants_and_loop_variants_be_made_constant_correct_">Can
      block invariants and loop variants be made constant-correct?</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.improve_compile_time_performances">Improve
      compile-time performances</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.analyze_run_time_performances">Analyze
      run-time performances</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.always_check_contract_assertion_syntax">Always
      check contract assertion syntax</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.support_concurrency">Support concurrency</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.can_constructor_member_initialization_list_limitation_be_removed_">Can
      constructor member initialization list limitation be removed?</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.should_preconditions_be_checked_before_constructor_member_initialization_list_">Should
      preconditions be checked before constructor member initialization list?</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.can_syntax_of_contract_macros_be_unified_with_other_boost_libraries_">Can
      syntax of contract macros be unified with other Boost libraries?</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.consider_allowing_optional_contract_checking_based_on_assertion_importance_and_or_class_name">Consider
      allowing optional contract checking based on assertion importance and/or class
      name</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.consider_adding_contracts_to_all_stl_classes_and_functions_in__contract__std___">Consider
      adding contracts to all STL classes and functions in <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span></code></a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.should_i_provide__contract_xyz_decl____macros_">Should
      I provide <code class="computeroutput"><span class="identifier">CONTRACT_XYZ_DECL</span><span class="special">()</span></code> macros?</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.shall_i_remove_the__assert____macros_">Shall
      I remove the <code class="computeroutput"><span class="identifier">ASSERT</span><span class="special">()</span></code>
      macros?</a></span></dt>
<dt><span class="section"><a href="todo.html#contract__.todo.fusing_contracts__concepts__named_parameters__etc_">Fusing
      contracts, concepts, named parameters, etc.</a></span></dt>
</dl></div>
<p>
      This section lists open items under consideration for future development of
      this library. It is mainly intended as a memorandum for the library authors.
    </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.improve_contract_macros__sequence__error_detection_and_reporting"></a><a class="link" href="todo.html#contract__.todo.improve_contract_macros__sequence__error_detection_and_reporting" title="Improve contract macros sequence error detection and reporting">Improve
      contract macros <code class="computeroutput"><span class="identifier">sequence</span></code> error
      detection and reporting</a>
</h3></div></div></div>
<p>
        The current implementation for syntax error detection and reporting for the
        <code class="computeroutput"><span class="identifier">sequence</span></code> parameter of the
        contract macros should be improved.
      </p>
<p>
        For example, if I forget the sequence element for the result type <code class="computeroutput"><span class="special">(</span><span class="identifier">result</span><span class="special">-</span><span class="identifier">type</span><span class="special">)</span></code>,
        the preprocessor gives a ton of errors most of which are about Boost.Preprocessor
        internal macros and make no sense to the user. While using the C++ preprocessor
        imposes some fundamental limitations on the amount of syntax checking I can
        implement for the <code class="computeroutput"><span class="identifier">sequence</span></code>
        macro parameter, I should be able to improve the current library implementation.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.can_block_invariants_and_loop_variants_be_made_constant_correct_"></a><a class="link" href="todo.html#contract__.todo.can_block_invariants_and_loop_variants_be_made_constant_correct_" title="Can block invariants and loop variants be made constant-correct?">Can
      block invariants and loop variants be made constant-correct?</a>
</h3></div></div></div>
<p>
        Currently block invariants and loop variants are <span class="emphasis"><em>not</em></span>
        constant-correct. Class invariants, preconditions, and postconditions instead
        are constant-correct so to ensure that the state of the system is not changed
        while checking the contract.
      </p>
<p>
        Can block invariants and loop variants be made constant-correct also?
      </p>
<p>
        This seems difficult because C++ does not allow to specify "constant-block":
      </p>
<pre class="programlisting"><span class="special">{</span> <span class="comment">// Some existing block.
</span>    <span class="keyword">const</span> <span class="special">{</span> <span class="comment">// A constant block -- BUT NOT SUPPORTED!!
</span>        <span class="comment">// Assert here block invariants and loop variants ensuring
</span>        <span class="comment">// const correctness.
</span>        <span class="special">...</span>
    <span class="special">}</span>
    <span class="special">...</span>
<span class="special">}</span>
</pre>
<p>
        Therefore, the code asserting block invariants and loop variants has the
        same constant constraints (possibly none!) on object, function arguments,
        result, etc as the enclosing code block... Is there a way around this? If
        not, shall I still provide block invariants and loop variants (documenting
        this limitation) or not?
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.improve_compile_time_performances"></a><a class="link" href="todo.html#contract__.todo.improve_compile_time_performances" title="Improve compile-time performances">Improve
      compile-time performances</a>
</h3></div></div></div>
<p>
        The library significantly increases compile-time (and compiler memory usage)
        when compiling the code with contracts turned on, compared with compilation
        with contracts off. Investigate what is stressing compiler performances and
        see if the library implementation can be optimized to improve compile-time
        performances.
      </p>
<p>
        The baseline should be compilation with all contracts turned off. There might
        be different reasons for the increased compilation-time/memory:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Contract assertions are programmed in header files so they are recompiled
          for each translation unit. I can test the effect of this by disabling pre/postcondition
          compilation (so the library contract templates will still be compiled by
          the user contracts will compile much less code in the header files because
          there will be no pre/postcondition).
        </li>
<li>
          The preprocessing time needed for the contract macros expansion and to
          parse the <code class="computeroutput"><span class="identifier">sequence</span></code> macro
          parameter. I can check this by stopping compilation after preprocessing
          (<code class="computeroutput"><span class="special">-</span><span class="identifier">E</span></code>
          compiler option) and measure how long preprocessing takes compared with
          compilation.
        </li>
<li>
          The library uses quite a bit of template metaprogramming (metafunctions,
          etc). See how the compile-time effects of template metaprogramming were
          analyzed for the Boost.MSM library and performance a similar analysis for
          this library. Also study carefully the chapter on compile-time performances
          of the Boost.MPL book.
        </li>
<li>
          The library is intentionally making all the contract classes always templates
          (using the artificial <code class="computeroutput"><span class="identifier">ZERO</span></code>
          template argument so the library can internally use <code class="computeroutput"><span class="keyword">template</span><span class="special">/</span><span class="keyword">typename</span></code>
          keywords regardless of the template context). What is the compile-time
          effect of these extra contract template classes compared with the effect
          if they have not been made templates using <code class="computeroutput"><span class="identifier">ZERO</span></code>?
          <code class="computeroutput"><span class="identifier">ZERO</span></code> can be removed and
          contract classes (for non-template functions) can be made non-template
          but this comes at the cost of having the user specify <code class="computeroutput"><span class="special">(</span><span class="keyword">template</span><span class="special">)</span></code>
          instead of <code class="computeroutput"><span class="special">(</span><span class="keyword">class</span><span class="special">)</span></code> for template classes (this complicates
          the <code class="computeroutput"><span class="identifier">sequence</span></code> syntax) --
          so the <code class="computeroutput"><span class="identifier">ZERO</span></code> workaround
          should be removed only if there is evidence that it will help compile-time.
        </li>
<li>
          More?
        </li>
</ol></div>
<p>
        Ultimately, this analysis should be added to the documentation.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.analyze_run_time_performances"></a><a class="link" href="todo.html#contract__.todo.analyze_run_time_performances" title="Analyze run-time performances">Analyze
      run-time performances</a>
</h3></div></div></div>
<p>
        Provide some data to show run-time performances of contract checking -- the
        baseline should be run-time performance with all contracts turned off.
      </p>
<p>
        The library current implementation should be optimized to minimize run-time
        overhead of contract checking. Preliminary data shows that the library run-time
        performance impact (execution time, CPU usage, and memory usage) is acceptable.
        However, data should be systematically collected and analyzed to verify this
        (and then added to the documentation).
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.always_check_contract_assertion_syntax"></a><a class="link" href="todo.html#contract__.todo.always_check_contract_assertion_syntax" title="Always check contract assertion syntax">Always
      check contract assertion syntax</a>
</h3></div></div></div>
<p>
        If the precondition, postcondition, and invariant (dynamic and static) functions
        are always left in the code, they are compiled and their assertions are check
        for syntax errors. If they are not called, they add no run-time and/or object-size
        overhead -- see the "test/check" analysis. The contract class should
        be removed form the code instead when there is no contract and it should
        only have pre/post when these are checked.
      </p>
<p>
        A configuration macro <code class="computeroutput"><span class="identifier">CONTRACT_CONFIG_ALWAYS_CHECK_ASSERTION_SYNTAX</span></code>,
        with default value 1, can be provided for programmers to disable assertion
        syntax checking in order to reduce compilation time.
      </p>
<p>
        How can I do this for <code class="computeroutput"><span class="identifier">CONTRACT_ASSERT_BLOCK_INVARIANT</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">CONTRACT_ASSERT_LOOP_VARIANT</span><span class="special">()</span></code>?
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.support_concurrency"></a><a class="link" href="todo.html#contract__.todo.support_concurrency" title="Support concurrency">Support concurrency</a>
</h3></div></div></div>
<p>
        Understand what needs to be done to support concurrency.
      </p>
<p>
        <a class="link" href="bibliography.html" title="Bibliography">[Meyer1997]</a> discusses issues
        associated with Contract Programming and concurrency when, for example, a
        precondition is first checked true but then the sate of the object is changed
        asynchronously after the precondition check and before body execution so
        at the time the body executes the checked precondition is no longer true.
        Eiffel addresses this issue using the SCOOP concurrency model and implementing
        waiting contract conditions.
      </p>
<p>
        In general, it seems inappropriate for this library to force <span class="emphasis"><em>one</em></span>
        concurrency model for Contract Programming in C++ (SCOOP, or any other).
        Synchronization, including the one of contracts, might be best left up to
        programmers as usual in C++. However, currently it is not possible to lock
        a mutex at function entry and release it at function exit when using the
        contract macros. This is because programmers can only program the body so
        they can lock at body scope but not at the scope of the contracted function.
      </p>
<p>
        More in general, the library could provide a mechanism to:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          Acquire resources (including a locks) at function entry.
        </li>
<li>
          Check invariants/preconditions, execute body, check invariants/postconditions
          via calling contract's <code class="computeroutput"><span class="identifier">call</span><span class="special">()</span></code>.
        </li>
<li>
          Release the acquired resources at function exit.
        </li>
</ol></div>
<p>
        For example:
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
<span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">f</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span>
<span class="bold"><strong>(scoped)</strong></span> <span class="special">(</span> <span class="comment">// In general, no `{` parenthesis here.
</span>    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">::</span><span class="identifier">scoped_lock</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mutex</span><span class="special">);</span>
    <span class="special">...</span> <span class="comment">// Eventually more here.
</span><span class="special">)</span>
<span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
    <span class="special">...</span>
<span class="special">})</span>
<span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
    <span class="special">...</span>
<span class="special">})</span>
<span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
    <span class="special">...</span>
<span class="special">})</span> <span class="special">)</span>

<span class="comment">// If contracts compilation on, expands to something like this:
</span><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">::</span><span class="identifier">scoped_lock</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mutex</span><span class="special">);</span> <span class="comment">// Scoped resources.
</span>    <span class="identifier">contract_f_</span><span class="special">().</span><span class="identifier">call</span><span class="special">();</span> <span class="comment">// Contract call.
</span><span class="special">}</span> <span class="comment">// Releases scoped resources via their destructors.
</span><span class="special">...</span>

<span class="comment">// If contracts compilation off, expands to something like this:
</span><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">::</span><span class="identifier">scoped_lock</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mutex</span><span class="special">);</span> <span class="comment">// Scoped resources.
</span>    <span class="special">...</span> <span class="comment">// Body code
</span><span class="special">}</span> <span class="comment">// Releases scoped resources via their destructors.
</span><span class="special">...</span>
</pre>
<p>
        Note:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Even when contract compilation is turned off, the scoped code should be
          part of the contract macro expansion together with the body code block.
        </li>
<li>
          In general, the scoped code is <span class="emphasis"><em>not</em></span> a code block <code class="computeroutput"><span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>
          (otherwise the acquired resources will be released at scope exit of the
          code block before calling <code class="computeroutput"><span class="identifier">call</span><span class="special">()</span></code>) but multiple instructions can still
          be specified.
        </li>
<li>
          Should this scoped code be enforced constant-correct? Maybe not, it should
          be contract-correct only if the contracted function is a <code class="computeroutput"><span class="keyword">const</span></code> member (same as for the body)... but
          think more about this.
        </li>
</ul></div>
<p>
        In addition:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          The library uses a global variable to "globally disable assertion
          checking within assertion checking". This boolean variable should
          be synchronized by the library in a concurrent context. However, this will
          require a global lock... Can I implement "global disabling of assertion
          checking within assertion checking" without a global state?
        </li>
<li>
          The library uses the object member variable <code class="computeroutput"><span class="identifier">contract_state_</span></code>
          to disable assertions within nested function calls for a given object.
          This boolean member variable should be synchronized by the library in a
          concurrent context. This synchronization is between object member functions,
          it is not global, so it might be OK...
        </li>
<li>
          If implemented, both global and object synchronizations should be enabled
          only if a macro symbol <code class="computeroutput"><span class="identifier">CONTRACT_THREADING</span></code>
          is #defined (#undef by default).
        </li>
<li>
          Can I allow the user to configure how to synchronize global/object state?
          For example, I could use a configuration macro that by default uses <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">::</span><span class="identifier">lock</span><span class="special">()</span></code>
          but it can be #redefined by the user...
        </li>
</ol></div>
<p>
        Most of these are open issues that need to be analysed in greater detail.
      </p>
<p>
        <span class="bold"><strong>Or</strong></span>, probably a better approach is to add
        a Concurrency subsection to the Contract Programming annex. This section
        can be inspired by <a class="link" href="bibliography.html" title="Bibliography">[Meyer1997]</a>
        and explain the issues of concurrency with respect to pre/post conditions
        and inv checking. The section can then present the ideas of sync every function
        call so to make sure that contract checking remains consistent with the body
        execution during the entire function call. Also waiting conditions can be
        explained here. Then this section can show how to implement this in C++ at
        a level higher than the contracts (e.g., manually wrapping the contracted
        function call):
      </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">c</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Just a wrap around f() that takes care of synchronization.
</span>    <span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">::</span><span class="identifier">scoped_lock</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mutex</span><span class="special">);</span>
        <span class="identifier">f_sync</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
    <span class="special">}</span>
    
<span class="keyword">protected</span><span class="special">:</span>
    <span class="comment">// Actual f() with its contract.
</span>    <span class="keyword">void</span> <span class="identifier">f_sync</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span> <span class="special">...</span> <span class="special">)</span>
<span class="special">};</span>
</pre>
<p>
        And maybe also suggest how to implement waiting conditions using a try-catch
        statement (after contract are changed to throw instead of terminate). Then
        it should be explained that while Eiffel supports sync and waiting conditions
        by default using SCOOP, it is not appropriate for this library to enforce
        one single concurrency schema (SCCOP, or any other) so concurrency is left
        up to programmers handle outside the library.
      </p>
<p>
        But what about the object state variable and the global assertion checking
        variable? Are those also sync'ed by the muted above? Maybe the object state
        is but the global assertion checking variable is probably not sync'ed...
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.can_constructor_member_initialization_list_limitation_be_removed_"></a><a class="link" href="todo.html#contract__.todo.can_constructor_member_initialization_list_limitation_be_removed_" title="Can constructor member initialization list limitation be removed?">Can
      constructor member initialization list limitation be removed?</a>
</h3></div></div></div>
<p>
        Can the contract macros overcome the constructor member initialization list
        limitation when separating constructor definition from declaration? See current
        workaround for this as documented in <code class="computeroutput"><span class="identifier">CONTRACT_CONSTRUCTOR_BODY</span><span class="special">()</span></code>.
      </p>
<p>
        However, this would have to work for all combinations of the followings
      </p>
<div class="orderedlist"><ol type="1">
<li>
          With and without contracts.
        </li>
<li>
          Definition together and separated from declaration.
        </li>
<li>
          With and without member initialization list.
        </li>
</ol></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.should_preconditions_be_checked_before_constructor_member_initialization_list_"></a><a class="link" href="todo.html#contract__.todo.should_preconditions_be_checked_before_constructor_member_initialization_list_" title="Should preconditions be checked before constructor member initialization list?">Should
      preconditions be checked before constructor member initialization list?</a>
</h3></div></div></div>
<p>
        The library checks constructor preconditions after executing the member initialization
        list: {Default AND Pre}Body{Post AND Inv} (Default is the member initialization
        list).
      </p>
<p>
        This is essentially what Eiffel does but constructors (and member initialization
        lists) are different in C++ than Eiffel. Is this what C++ should do or {Pre
        AND Default} is a better approach for C++? Why does Eiffel do {Default AND
        Pre}? Does any of the Contract Programming proposals for C++ mention this
        issue explicitly? Implementing {Pre AND Default} for this library might present
        similar challenges to separating constructor definition when member initialization
        list is specified (so it might not be possible given the lack of delegating
        constructors in C++...).
      </p>
<p>
        If {Pre AND Default} is a better approach, {Default AND Pre} should be documented
        as a library limitation. If {Default and Pre} is a better approach, I should
        document why.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.can_syntax_of_contract_macros_be_unified_with_other_boost_libraries_"></a><a class="link" href="todo.html#contract__.todo.can_syntax_of_contract_macros_be_unified_with_other_boost_libraries_" title="Can syntax of contract macros be unified with other Boost libraries?">Can
      syntax of contract macros be unified with other Boost libraries?</a>
</h3></div></div></div>
<p>
        Look if the contract macro <code class="computeroutput"><span class="identifier">sequence</span></code>
        syntax can be unified with the one of other Boost libraries.
      </p>
<p>
        Specifically, is this possible with respect to Boost.ConceptCheck and how
        concept checking interacts with this Contract Programming library? Same questions
        respect to Boost.Parameter. Any other Boost library I should study with respect
        to this issue?
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.consider_allowing_optional_contract_checking_based_on_assertion_importance_and_or_class_name"></a><a class="link" href="todo.html#contract__.todo.consider_allowing_optional_contract_checking_based_on_assertion_importance_and_or_class_name" title="Consider allowing optional contract checking based on assertion importance and/or class name">Consider
      allowing optional contract checking based on assertion importance and/or class
      name</a>
</h3></div></div></div>
<p>
        Let's assume I have a template library that is well tested so I want to disable
        postcondition checking for it. However, this is a template library so it
        cannot be precompiled separately with postconditions off. I must compile
        it together with the rest of the code. Therefore, if the rest of the code
        needs to check postconditions, I must check postconditions for the well tested
        template library as well... The extra contract checking for the template
        library introduces both compile-time and run-time overhead.
      </p>
<div class="itemizedlist"><ul type="disc"><li>
          I could address this if the library allowed to disable contract checking
          (at least at run-time) based on class and function name.
        </li></ul></div>
<p>
        Moreover, there might be contract conditions which are very inefficient to
        test so I might want to turn off checking <span class="emphasis"><em>only</em></span> for the
        inefficient conditions. With respect to this issue, <a class="link" href="bibliography.html" title="Bibliography">[Mitchell2002]</a>
        recommends to only program preconditions in Eiffel that can be checked efficiently
        (as preconditions are usually left also in production code) and leave inefficient
        preconditions documented as code comments.
      </p>
<div class="itemizedlist"><ul type="disc"><li>
          I could address this by disabling contract checking (at least at run-time)
          based on some assertion <span class="emphasis"><em>importance ordering</em></span> (assertion
          importance ordering was removed from <a class="link" href="bibliography.html" title="Bibliography">[Crowl2006]</a>
          but is was present in [Crowl2005]).
        </li></ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.consider_adding_contracts_to_all_stl_classes_and_functions_in__contract__std___"></a><a class="link" href="todo.html#contract__.todo.consider_adding_contracts_to_all_stl_classes_and_functions_in__contract__std___" title="Consider adding contracts to all STL classes and functions in contract::std::">Consider
      adding contracts to all STL classes and functions in <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span></code></a>
</h3></div></div></div>
<p>
        All <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span></code>
        classes and functions could be wrapped by classes and functions in a namespace
        <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span></code> declaring
        contracts for all the STL classes and functions. The <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span></code>
        namespace should have the <span class="emphasis"><em>exact</em></span> same structure as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span></code> (so
        it is easy to use for C++ programmers familiar with STL).
      </p>
<p>
        For example a <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
        class can wrap <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code> providing the exact same API but
        adding contracts to it (similar to the STL Vector <a class="link" href="examples.html" title="Examples">Example</a>
        but int the <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">std</span><span class="special">::</span></code> namespace).
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          The contracts could assert all the STL standard guarantees.
        </li>
<li>
          Postcondition and invariant checking might not add much value given that
          STL implementations are usually well tested, documented, and work well.
        </li>
<li>
          Precondition checking might instead be valuable as they will check that
          the STL is not misused by the callers.
        </li>
</ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.should_i_provide__contract_xyz_decl____macros_"></a><a class="link" href="todo.html#contract__.todo.should_i_provide__contract_xyz_decl____macros_" title="Should I provide CONTRACT_XYZ_DECL() macros?">Should
      I provide <code class="computeroutput"><span class="identifier">CONTRACT_XYZ_DECL</span><span class="special">()</span></code> macros?</a>
</h3></div></div></div>
<p>
        Two family of macros could be provided:
      </p>
<div class="orderedlist"><ol type="1">
<li>
<code class="computeroutput"><span class="identifier">CONTRACT_CLASS</span><span class="special">()</span></code>
          and <code class="computeroutput"><span class="identifier">CONTRACT_FUNCTION</span><span class="special">()</span></code>
          which follow the relative class and function declarations as coded by the
          programmers.
        </li>
<li>
<code class="computeroutput"><span class="identifier">CONTRACT_CLASS_DECL</span><span class="special">()</span></code>
          and <code class="computeroutput"><span class="identifier">CONTRACT_FUNCTION_DECL</span><span class="special">()</span></code> which also automatically program the
          class and function declarations so programmers do not have to code the
          declarations manually outside the contracts.
        </li>
</ol></div>
<p>
        The <code class="computeroutput"><span class="identifier">CONTRACT_XYZ_DECL</span><span class="special">()</span></code>
        macros have the following pro (+) and cons (-) compared to the <code class="computeroutput"><span class="identifier">CONTRACT_XYZ</span><span class="special">()</span></code>
        macros:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          (+) There is no code duplication when using <code class="computeroutput"><span class="identifier">CONTRACT_XYZ_DECL</span><span class="special">()</span></code> (because the signature tokens only appear
          within the macro and not also before the macro).
        </li>
<li>
          (+) When using <code class="computeroutput"><span class="identifier">CONTRACT_XYZ_DECL</span><span class="special">()</span></code>, the declarations tokens will always
          match the ones in the contract because they are not duplicated. When using
          the <code class="computeroutput"><span class="identifier">CONTRACT_XYZ</span><span class="special">()</span></code>
          macros instead, a mismatch between the declaration and the contract signature
          tokens will generate a compiler error in most, but not all, cases.
        </li>
<li>
          (-) The code using <code class="computeroutput"><span class="identifier">CONTRACT_XYZ_DECL</span><span class="special">()</span></code> is more difficult to read to whom does
          not know the library syntax because all usual C++ syntax is gone.
        </li>
<li>
          (-) All compiler errors for the class will appear with the same line number
          because the <code class="computeroutput"><span class="identifier">CONTRACT_CLASS_DECL</span><span class="special">()</span></code> macro will expand on a single line. I
          think this is a major defect of the <code class="computeroutput"><span class="identifier">CONTRACT_XYZ_DECL</span><span class="special">()</span></code> macros because it will make C++ compiler
          error even harder to track than they currently are.
        </li>
<li>
          (~) The <code class="computeroutput"><span class="identifier">CONTRACT_XYZ_DECL</span><span class="special">()</span></code> macros will need to accept additional
          information like inheritance access level, default parameter values, exception
          specifications, etc. However, the <code class="computeroutput"><span class="identifier">CONTRACT_XYZ</span><span class="special">()</span></code> macros already contain most of the syntactic
          token of class and function declarations so this is not much of a complication
          of the macro signature syntax.
        </li>
</ol></div>
<div class="table">
<a name="id2674416"></a><p class="title"><b>Table 2. Example with and without the macros.</b></p>
<div class="table-contents"><table class="table" summary="Example with and without the macros.">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
            <p>
              <code class="computeroutput"><span class="identifier">CONTRACT_XYZ</span><span class="special">()</span></code>
              Macros
            </p>
            </th>
<th>
            <p>
              <code class="computeroutput"><span class="identifier">CONTRACT_XYZ_DECL</span><span class="special">()</span></code>
              Macros
            </p>
            </th>
</tr></thead>
<tbody><tr>
<td>
            <p>
              
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">myvector</span><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">pushable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">{</span>

    <span class="identifier">CONTRACT_CLASS</span><span class="special">(</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span> <span class="special">(</span><span class="keyword">public</span><span class="special">)(</span><span class="identifier">pushable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;)</span>
    <span class="special">(</span><span class="identifier">invariant</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">empty</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">element</span><span class="special">)</span>
    <span class="identifier">CONTRACT_FUNCTION</span><span class="special">(</span>
            <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">push_back</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">max_size</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)-&gt;</span><span class="identifier">size</span><span class="special">()</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">element</span><span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>

    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">size_type</span> <span class="identifier">size_type</span><span class="special">;</span>
    <span class="identifier">size_type</span> <span class="identifier">size</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">}</span>
    <span class="identifier">size_type</span> <span class="identifier">max_size</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">max_size</span><span class="special">();</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">empty</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">empty</span><span class="special">();</span> <span class="special">}</span>
    <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">back</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">back</span><span class="special">();</span> <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            </p>
            </td>
<td>
            <p>
              
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">CONTRACT_CLASS_DECL</span><span class="special">(</span> <span class="special">(</span><span class="identifier">myvector</span><span class="special">)</span> <span class="special">(</span><span class="keyword">public</span><span class="special">)(</span><span class="identifier">pushable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;)</span>

    <span class="special">(</span><span class="identifier">invariant</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">empty</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    
<span class="special">(</span> <span class="comment">// No class `{};` parenthesis.
</span>
    <span class="identifier">CONTRACT_FUNCTION_DECL</span><span class="special">(</span>
    <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">push_back</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;)(</span><span class="identifier">element</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">max_size</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">CONTRACT_ASSERT</span><span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)-&gt;</span><span class="identifier">size</span><span class="special">()</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">({</span>
        <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">element</span><span class="special">);</span>
    <span class="special">})</span> <span class="special">)</span>

    <span class="comment">// Usual C++ class-scope code still works.
</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">size_type</span> <span class="identifier">size_type</span><span class="special">;</span>
    <span class="identifier">size_type</span> <span class="identifier">size</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">}</span>
    <span class="identifier">size_type</span> <span class="identifier">max_size</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">max_size</span><span class="special">();</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">empty</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">empty</span><span class="special">();</span> <span class="special">}</span>
    <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">back</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">back</span><span class="special">();</span> <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>
<span class="special">)</span> <span class="special">)</span>
</pre>
<p>
            </p>
            </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
        The syntax of <code class="computeroutput"><span class="identifier">CONTRACT_XYZ_DECL</span><span class="special">()</span></code>, and consequently <code class="computeroutput"><span class="identifier">CONTRACT_XYZ</span><span class="special">()</span></code>, needs to be extended to include <span class="emphasis"><em>all</em></span>
        class and function signature tokens:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="comment">// class z: public x, protected y
</span><span class="identifier">CONTRACT_CLASS_DECL</span><span class="special">(</span> <span class="special">(</span><span class="identifier">z</span><span class="special">)</span> <span class="special">(</span><span class="keyword">public</span><span class="special">)(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">(</span><span class="keyword">public</span><span class="special">)(</span><span class="identifier">y</span><span class="special">)</span>

    <span class="special">(</span><span class="keyword">static</span><span class="special">)</span> <span class="special">(</span><span class="identifier">invariant</span><span class="special">)</span> <span class="special">({</span>
        <span class="special">...</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">invariant</span><span class="special">)</span> <span class="special">({</span>
        <span class="special">...</span>
    <span class="special">})</span>

<span class="special">(</span>
    <span class="keyword">class</span> <span class="identifier">X</span> <span class="special">{};</span> <span class="keyword">class</span> <span class="identifier">Y</span><span class="special">{};</span>

    <span class="comment">// void f(register int i = 0, auto double d = 0.0) throw(X, Y)
</span>    <span class="identifier">CONTRACT_FUNCTION_DECL</span><span class="special">(</span>
    <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">f</span><span class="special">)(</span>
                <span class="special">(</span><span class="keyword">register</span><span class="special">)(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">(</span><span class="keyword">default</span><span class="special">)(</span><span class="number">0</span><span class="special">)</span>
                <span class="special">(</span><span class="keyword">auto</span><span class="special">)(</span><span class="keyword">double</span><span class="special">)</span> <span class="special">(</span><span class="identifier">d</span><span class="special">)</span> <span class="special">(</span><span class="keyword">default</span><span class="special">)(</span><span class="number">0.0</span><span class="special">)</span>
            <span class="special">)</span> <span class="special">(</span><span class="keyword">throw</span><span class="special">)(</span> <span class="special">(</span><span class="identifier">X</span><span class="special">)</span> <span class="special">(</span><span class="identifier">Y</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="special">...</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">({</span>
        <span class="special">...</span>
    <span class="special">})</span>
    <span class="special">(</span><span class="identifier">body</span><span class="special">)</span> <span class="special">(</span>
        <span class="special">...</span>
    <span class="special">)</span> <span class="special">)</span>
    
    <span class="special">...</span>
<span class="special">)</span> <span class="special">)</span>
</pre>
<div class="itemizedlist"><ul type="disc">
<li>
          Default function parameters indicated using <code class="computeroutput"><span class="keyword">default</span></code>
          (<code class="computeroutput"><span class="special">=</span></code> symbol cannot be used because
          it cannot be parsed by the preprocessor). Default is already a keyword
          (for <code class="computeroutput"><span class="keyword">switch</span><span class="special">()</span></code>)
          so it works nicely as it already know by programmers (even if in a different
          context), it will be highlighted by most editors, etc.
        </li>
<li>
          Exceptions specifications are supported using a preprocessor sequence (instead
          of the usual comma-separated syntax). This is the same syntax already used
          for both function arguments and template parameters.
        </li>
<li>
          Auto and register qualifier are added to the the function argument list
          (before the type).
        </li>
<li>
          The <code class="computeroutput"><span class="keyword">friend</span></code> keyword still does
          not need to be supported because contracts must appear with the class/function
          declaration. Therefore, friend is used to forward declare the class/function
          and then contracts are specified where the class/function is actually defined.
          This approach still maintain the friend functionality with the only limitation
          that friend functions cannot be defined where they are declared friends
          (C++ already enforces this constraint but only for classes).
        </li>
<li>
          The <code class="computeroutput"><span class="keyword">union</span></code> keyword is still
          not supported for <code class="computeroutput"><span class="identifier">CONTRACT_CLASS</span><span class="special">()</span><span class="identifier">_DECL</span></code>
          because contracts are not supported for unions (only for classes and structs).
        </li>
<li>
          All other C++ keywords are already included in the class/function signatures
          even if not shown in the example above.
        </li>
</ul></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.shall_i_remove_the__assert____macros_"></a><a class="link" href="todo.html#contract__.todo.shall_i_remove_the__assert____macros_" title="Shall I remove the ASSERT() macros?">Shall
      I remove the <code class="computeroutput"><span class="identifier">ASSERT</span><span class="special">()</span></code>
      macros?</a>
</h3></div></div></div>
<p>
        I am not sure if this would make the syntax better or worst...
      </p>
<p>
        Would removing the <code class="computeroutput"><span class="identifier">CONTRACT_ASSERT</span><span class="special">()</span></code> "simplify" the syntax making
        it more inline with [Crowl2006]? It might not because the code would look
        more like [Crowl2006] but it might look less like C++ and be harder to understand...
      </p>
<p>
        Removing the macros will enforce the constraint that contract code is kept
        simple and to just a list of assertions (with eventual if-guards). However,
        this constraint makes 100% sense for CP language support but a library might
        be better off leaving this up to the programmer as a good practice.
      </p>
<p>
        Furthermore, the assertion if-guard imposes the limit that all assertion
        must start with a word (no symbol). For istance <code class="computeroutput"><span class="special">(</span><span class="identifier">x</span> <span class="special">==</span> <span class="number">3</span><span class="special">)</span> <span class="special">&amp;&amp;</span> <span class="special">(</span><span class="identifier">y</span> <span class="special">==</span>
        <span class="number">4</span><span class="special">)</span></code>
        is not a valid assertion (it will not pass the preprocessor). However, these
        assertions could be wrapped by <code class="computeroutput"><span class="identifier">contract</span><span class="special">::</span><span class="identifier">identity</span><span class="special">((</span><span class="identifier">x</span> <span class="special">==</span>
        <span class="number">3</span><span class="special">)</span> <span class="special">&amp;&amp;</span> <span class="special">(</span><span class="identifier">y</span> <span class="special">==</span> <span class="number">4</span><span class="special">))</span></code> as a workaround... would this acceptable?
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">contract</span> <span class="special">{</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">identity</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">condition</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">condition</span><span class="special">;</span> <span class="special">}</span>
<span class="special">}</span> <span class="comment">// namespace
</span>
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Alloc</span> <span class="special">=</span> <span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="identifier">CONTRACT_CLASS_DECL</span><span class="special">(</span> <span class="special">(</span><span class="identifier">vector</span><span class="special">)</span>

    <span class="special">(</span><span class="identifier">invariant</span><span class="special">)</span> <span class="special">(</span>
        <span class="special">(</span> <span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="special">==</span> <span class="identifier">empty</span><span class="special">()</span> <span class="special">)</span>
    <span class="special">)</span> 

<span class="special">(</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">iterator</span><span class="special">;</span>

    <span class="identifier">CONTRACT_FUNCTION_DECL</span><span class="special">(</span>
    <span class="special">(</span><span class="keyword">public</span><span class="special">)</span> <span class="special">(</span><span class="identifier">iterator</span><span class="special">)</span> <span class="special">(</span><span class="identifier">erase</span><span class="special">)(</span>
            <span class="special">(</span><span class="identifier">iterator</span><span class="special">)(</span><span class="identifier">first</span><span class="special">)</span> <span class="special">(</span><span class="identifier">iterator</span><span class="special">)(</span><span class="identifier">last</span><span class="special">)</span> <span class="special">)</span> <span class="special">(</span><span class="identifier">copyable</span><span class="special">)</span>
        <span class="special">(</span><span class="identifier">precondition</span><span class="special">)</span> <span class="special">(</span>
            <span class="comment">// No code block `({ ... })`. Assertions are just a sequence
</span>            <span class="comment">// of booleanable expressions.
</span>            <span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">&gt;=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">distance</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">)</span> <span class="special">)</span>
        <span class="special">)</span>
        <span class="special">(</span><span class="identifier">postcondition</span><span class="special">)</span> <span class="special">(</span><span class="identifier">result</span><span class="special">)</span> <span class="special">(</span>
            <span class="special">(</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">CONTRACT_OLDOF</span><span class="special">(</span><span class="keyword">this</span><span class="special">)-&gt;</span><span class="identifier">size</span><span class="special">()</span> <span class="special">-</span>
                    <span class="identifier">std</span><span class="special">::</span><span class="identifier">distance</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">)</span> <span class="special">)</span>
            <span class="special">(</span> <span class="keyword">if</span> <span class="special">(</span><span class="identifier">empty</span><span class="special">())</span> <span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="identifier">end</span><span class="special">())</span> <span class="special">)</span> <span class="comment">// Assertion with if-guard.
</span>        <span class="special">)</span>
    <span class="special">(</span>
        <span class="keyword">return</span> <span class="identifier">vector_</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">last</span><span class="special">);</span>
    <span class="special">)</span> <span class="special">)</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">vector_</span><span class="special">;</span>
<span class="special">)</span> <span class="special">)</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="contract__.todo.fusing_contracts__concepts__named_parameters__etc_"></a><a class="link" href="todo.html#contract__.todo.fusing_contracts__concepts__named_parameters__etc_" title="Fusing contracts, concepts, named parameters, etc.">Fusing
      contracts, concepts, named parameters, etc.</a>
</h3></div></div></div>
<p>
        Consider the following C++0x-like example (inspired from ConceptC++ http://www.generic-programming.org/languages/conceptcpp<span class="emphasis"><em>tutorial</em></span>
        and C++ Contract Programming proposal [Crowl2006]):
      </p>
<pre class="programlisting"><span class="comment">// Example strangely uses pointers instead of iterators just to have preconditions.
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">CopyConstructible</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="identifier">requires</span> <span class="identifier">Addable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span> <span class="identifier">Assignable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="comment">// Concepts.
</span><span class="identifier">T</span> <span class="identifier">sum</span><span class="special">(</span><span class="identifier">T</span><span class="special">*</span> <span class="identifier">first</span><span class="special">,</span> <span class="identifier">T</span><span class="special">*</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">result</span><span class="special">)</span>
    <span class="identifier">preconditions</span> <span class="special">{</span> <span class="identifier">first</span><span class="special">;</span> <span class="identifier">last</span><span class="special">;</span> <span class="special">}</span> <span class="comment">// Pointer not null.
</span>    <span class="identifier">postconditions</span> <span class="special">(</span><span class="identifier">total</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">total</span> <span class="special">==</span> <span class="identifier">result</span><span class="special">;</span> <span class="special">}</span> <span class="comment">// Returning result.
</span><span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(;</span> <span class="identifier">first</span> <span class="special">!=</span> <span class="identifier">last</span><span class="special">;</span> <span class="special">++</span><span class="identifier">first</span><span class="special">)</span>
        <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">result</span> <span class="special">+</span> <span class="special">*</span><span class="identifier">first</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">result</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        "What do you think of the following macro that implements this in ISO
        standard C++ by wrapping the above C++0x-like syntax within a preprocessor
        sequence?" I have asked this question to Boosters.
      </p>
<pre class="programlisting"><span class="identifier">CPP0X_FUNCTION</span><span class="special">(</span>
<span class="special">(</span><span class="keyword">template</span><span class="special">)(</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">CopyConstructible</span><span class="special">)(</span><span class="identifier">T</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">requires</span><span class="special">)(</span> <span class="special">(</span><span class="identifier">Addable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;)</span> <span class="special">(</span><span class="identifier">Assignable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;)</span> <span class="special">)</span>
<span class="special">(</span><span class="identifier">T</span><span class="special">)</span> <span class="special">(</span><span class="identifier">sum</span><span class="special">)(</span> <span class="special">(</span><span class="identifier">T</span><span class="special">*)(</span><span class="identifier">first</span><span class="special">)</span> <span class="special">(</span><span class="identifier">T</span><span class="special">*)(</span><span class="identifier">last</span><span class="special">)</span> <span class="special">(</span><span class="identifier">T</span><span class="special">)(</span><span class="identifier">result</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">preconditions</span><span class="special">)(</span> <span class="special">(</span><span class="identifier">first</span><span class="special">)</span> <span class="special">(</span><span class="identifier">last</span><span class="special">)</span> <span class="special">)</span>
    <span class="special">(</span><span class="identifier">postconditions</span><span class="special">)(</span><span class="identifier">total</span><span class="special">)(</span> <span class="special">(</span><span class="identifier">total</span> <span class="special">==</span> <span class="identifier">result</span><span class="special">)</span> <span class="special">)</span>
<span class="special">({</span>
    <span class="keyword">for</span> <span class="special">(;</span> <span class="identifier">first</span> <span class="special">!=</span> <span class="identifier">last</span><span class="special">;</span> <span class="special">++</span><span class="identifier">first</span><span class="special">)</span>
        <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">result</span> <span class="special">+</span> <span class="special">*</span><span class="identifier">first</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">result</span><span class="special">;</span>
<span class="special">})</span> <span class="special">)</span>
</pre>
<p>
        The idea is that using the preprocessor I can parse the signature-sequence
        so I have all the tokens needed to declare/define the C++ function plus its
        concepts (Boost.Concept), contracts (Boost.Contract), named parameters (Boost.Parameter),
        etc. Furthermore, the syntax of signature-sequence can be any valid preprocessor
        sequence that uses words (not symbols) for keywords (e.g., (requires) and
        (preconditions) are OK but (=) is not). So I can define the signature-sequence
        syntax to closely match the syntax of C++0x and of other C++ standard proposals
        (like [Crowl2006]).
      </p>
<p>
        This syntax is not worst than the current Contract++ one. Therefore, it would
        seem that at least the Contract++ macros should be extended to support concepts
        (interfacing with Boost.Concept) and possibly also named parameters (interfacing
        with Boost.Parameter).
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2009 -2010 Lorenzo Caminiti<p>
        Distributed under the Contract++ Software License, Version 1.0 (see accompanying
        file LICENSE_1_0.txt)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="release_history.html"><img src=".././doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src=".././doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src=".././doc/html/images/home.png" alt="Home"></a>
</div>
</body>
</html>
