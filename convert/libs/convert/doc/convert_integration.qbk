[section:convert_integration Integration of User-Defined Types]

The mechanism for integrating a user-defined type into the /Boost.Convert/ framework is the same as for /boost::lexical_cast/. That is, the class needs to be /InputStreamable/ and /OutputStreamable/ with the following operators defined (see the /lexical_cast/ documentation for more information):

 std::istream& operator>>(std::istream& stream, Type&);
 std::ostream& operator<<(std::ostream& stream, Type const&);

For example,

 struct direction
 {
     enum value_type { up, dn };

     direction(value_type value) : value_(value) {}
     bool operator==(direction const& that) cont 
     { return value_ == that.value_; }

     friend std::istream& operator>>(std::istream&, direction&)
     friend std::ostream& operator<<(std::ostream&, direction const&);
    
     private: value_type value_;
 };


 std::istream& operator>>(std::istream& stream, direction& dir)
 {
     string str;
     stream >> str;
     /**/ if (str == "up") dir.value_ = up;
     else if (str == "dn") dir.value_ = dn;
     else stream.setstate(std::ios_base::failbit);

     return stream;
 }
 std::ostream& operator<<(std::ostream& stream, direction const& dir)
 {
     return stream << (dir.value_ == up ? "up" : "dn");
 }

That allows handling conversions of user-defined types uniformly via /boost::convert/ interface:

 int i = convert<int>::from(str, -1);
 direction d = convert<direction>::from(str, direction::up);

[endsect]
