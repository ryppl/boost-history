<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.IndexedSet Documentation - Index implementation guide</title>
<link rel="stylesheet" href="style.css" type="text/css">
</head>

<body>
<h1><img src="../../../c++boost.gif" alt="c++boost.gif (8819 bytes)" align=
"middle" width="277" height="86">Boost.IndexedSet Index implementation guide</h1>

<p>
Boost.IndexedSet is designed so as to accept new index types without changes
to the base code. From this perspective, the library can be regarded as a
generic framework for the composition of node-based indices into a unified data
structure. The following documentation is intended for those people interested
in the internal structure of the library and the procedure to augment it with new
index types: the reader is advise to acquire a good working knowledge of the
library before studying this section.
</p>

<h2>Contents</h2>

<ul>
  <li><a href="#intro">Introduction</a></li>
  <li><a href="#internal_structure">Internal structure</a>
    <ul>
	  <li><a href="#node_hierarchy">Node hierarchy</a>
        <ul>
          <li><a href="#header_node">Header node</a></li>
        </ul>
      </li>
	  <li><a href="#index_hierarchy">Index hierarchy</a>
        <ul>
          <li><a href="#index_hierarchy">Backbone functions</a></li>
          <li><a href="#index_base"><code>index_base</code></a></li>
        </ul>
      </li>
	  <li><a href="#index_specifiers">Index specifiers</a></li>
    </ul>
  </li>
  <li><a href="#impl_guide">Index implementation guide</a>
  </li>
</ul>

<h2><a name="intro">Introduction</a></h2>

<p>
<code>indexed_set</code> enjoys a certain toolkit nature in that many
different data structures can be instantiated out of the combination of
an arbitrary number of indices. In order to take the best advantage of
this possibility, Boost.IndexedSet is designed in such a way that the
<code>indexed_set</code> class template is not tightly coupled with the
types of indices currently provided, but rather it accepts whatever
index implementation meeting certain generic conditions. This approach
is reminiscent of the generic style adopted by STL algorithms, which
operate on any type modeling the aproptiate iterator concepts.
</p>

<p>
Boost.IndexedSet also provides a number of utility classes that make it
easier to implement new index types. These utilities are primarily devoted
to the addition of quality of implementation facilities, as safe mode
checking.
</p>

<p>
In order to be able to write a custom index, it is first necessary to
gain some insight into the internal structure of Boost.IndexedSet. WRITE
SOMETHING MORE USEFUL HERE.
</p>

<h2><a name="internal_structure">Internal structure</a></h2>

<p>
In order to better understand the internal structure of an
<code>indexed_set</code> container, it might be useful to think of it
as a layered component, each layer being the implementation of
an index specified in the <code>index_list</code>. This conceptual
view can be modelled in C++ as a <i>linear hierarchy of
types</i>: such a hierarchy is a sequence of classes
<code>C<sub>1</sub></code>,...,<code>C<sub>N</sub></code> such
that <code>C<sub>i</sub></code> is derived from
<code>C<sub>i+1</sub></code>. Boost.IndexedSet extensively
uses linear hierarchies in its implementation. A particular
instantation of <code>indexed_set</code> results in the construction of
two related linear hierarchies:
<ul>
  <li>An index hierarchy,</li>
  <li>a node hierarchy.
</ul>
The first corresponds to the <code>indexed_set</code> instantiation proper,
while the second describes the internal nodes use to hold and manage
the elements of the <code>indexed_set</code>. For example, consider the
following type definitions:
</p>

<blockquote><pre>
<span class=keyword>typedef</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span>
  <span class=identifier>employee</span><span class=special>,</span>
  <span class=identifier>index_list</span><span class=special>&lt;</span>
    <span class=identifier>unique</span><span class=special>&lt;</span><span class=identifier>identity</span><span class=special>&lt;</span><span class=identifier>employee</span><span class=special>&gt;</span> <span class=special>&gt;,</span>                              
    <span class=identifier>non_unique</span><span class=special>&lt;</span><span class=identifier>member</span><span class=special>&lt;</span><span class=identifier>employee</span><span class=special>,</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>,&amp;</span><span class=identifier>employee</span><span class=special>::</span><span class=identifier>name</span><span class=special>&gt;</span> <span class=special>&gt;</span>
  <span class=special>&gt;</span> 
<span class=special>&gt;</span> <span class=identifier>employee_set</span><span class=special>;</span>

<span class=keyword>typedef</span> <span class=identifier>employee_set</span><span class=special>::</span><span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=number>0</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>index_0</span><span class=special>;</span>
<span class=keyword>typedef</span> <span class=identifier>employee_set</span><span class=special>::</span><span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=number>1</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>index_1</span><span class=special>;</span>
</pre></blockquote>

<p>
The linear hierarchies associated with <code>employee_set</code> are
depicted in UML notation in the figure. The node hierarchy is not exposed to
the user of the library.
</p>

<p align="center">
<img src="linear_hierarchies.png" alt="linear hierarchies associated with employee_set"
width="400" height="475"><br>
<b>Fig. 1: Linear hierarchies associated with <code>employee_set</code>.</b>
</p>

<p>
It can be seen that <code>indexed_set</code> is actually a linear hierarchy of the
different index implementations. So, the operation <code>get&lt;n&gt;</code> just
upcasts the given <code>employee</code> object to the corresponding index
implementation class. (Note that the user cannot perform this upcast directly as
derivations are protected, except that from <code>index_0</code> to
<code>employee_set</code>.)
</p>

<p>
The associated node hierarchy is synchronized with the index hierarchy in
such a way that each index implementation class uses its own node type
in the hierarchy. It is important to observe than, globally, <code>indexed_set</code>
allocates and manages objects of the final, most-derived node class.
</p>

<p>
Both hierarchies are topped by special internal classes provided by
Boost.IndexedSet, whose roles we will see later.
</p>

<h3><a name="node_hierarchy">Node hierarchy</a></h3>

<p>
Most data structures are constructed as more or less complex collections
of nodes. Typically, a node consists of two types of information:
<ul>
  <li>The element contained, sometimes called the <i>payload</i>,</li>
  <li>additional data, such as pointers, used to arrange the global
    structure.
  </li>
</ul>
For instance, a doubly linked list is usually constructed of nodes
containing the values of the elements plus a pair of pointers directing
to the previous and next element in the list. Given a particular instantiation
of <code>indexed_set</code>, its associated node hierarchy describes
the different types of nodes corresponding to each index involved.
</p>

<p>
As the most derived node containes all of the other types in the hierarchy,
only  node objects of this most derived type will be used by every index
implementation for each to maintain its own data structure. This has
several important implications:
<ul>
  <li>Nodes are not allocated by the index implementation class, but
    by the <code>indexed_set</code> final class. Index implementation classes
    are passed these nodes, of which they must use only the payload
    and the dedicated additional data section.
  </li>
  <li>
    The mechanism of node handling rules out the possibility
	of having a vector-like index.
  </li>
  <li>All indices of a given <code>indexed_set</code> have the same number
	of elements.
  </li>
  <li>
    Only one copy of the value of an element is kept, regardless of the
	number of indices. This value is stored in the <code>value</code>
	field of <code>indexed_sets::index_node_base&lt;Value&gt;</code>, which
	is the topping element of the node hierarchy.
  </li>
</ul>
The way the node hierarchy works effectively minimizes the amount of
space needed to store an element, in contrast with data structures
obtained from the manual compositions of isolated containers. Memory
fragmentation is also reduced.
</p>

<p>
Figure 2 shows a possible layout of the <code>employee_set</code> node
hierarchy, in which both indices' data structures are implemented as
red-black trees. Please note that this is not necessarily the real
implementation obtained in Boost.IndexedSet.
</p>

<p align="center">
<img src="node_hierarchy.png" alt="node hierarchy of employee_set"
width="600" height="135"><br>
<b>Fig. 2: Node hierarchy of <code>employee_set</code>.</b>
</p>

<h4><a name="header_node">Header node</a></h4>

<p>
In the implementation of many data structures like red-black trees, lists,
etc., it is very common to maintain a dummy node from which the rest
of the structure is built. For instance, doubly linked lists usually
resort to such a header node for the simplification it brings to
the implementation code in border cases.
</p>

<p align="center">
<img src="linked_list.png" alt="example of doubly linked list using a header node"
width="400" height="115"><br>
<b>Fig. 3: Example of doubly linked list using a header node.</b>
</p>

<p>
In order to cover this common situation, <code>indexed_set</code>
preallocates a header node for those indices that need such
a facility. Otherwise, each index implementation would have to
construct its own header node without sharing it with the
other indices. Thus in general an <code>indexed_set</code>
container with <code>n</code> elements allocates
<code>n+1</code> nodes. The element value held by this header
is never constructed and should not be read in any manner:
it is only the additional data space that is meant to be
used by indices.
</p>

<h3><a name="index_hierarchy">Index hierarchy</a></h3>

<p>
We have seen that node hierarchies are "passive" in the sense that
little coupling exists between the diferent layers. By contrast,
linear hierarchies are not a mere juxtaposition of index class
implementations: a good deal of cooperation is needed between them
to maintain the different data structures synchronized. For instance,
an insertion operation like
</p>

<blockquote><pre>
<span class=identifier>employee_set</span> <span class=identifier>es</span><span class=special>;</span>
<span class=identifier>es</span><span class=special>.</span><span class=identifier>insert</span><span class=special>(</span><span class=identifier>employee</span><span class=special>(</span><span class=number>0</span><span class=special>,</span><span class=string>&quot;Joe&quot;</span><span class=special>,</span><span class=number>31</span><span class=special>));</span>
</pre></blockquote>

involves the updating of the corresponding data structures for each
index in <code>employee_set</code>. Moreover, the outcome of the operation
is dependent on each index, as unique indices may ban the insertion
of a given element:

<blockquote><pre>
<span class=identifier>employee_set</span> <span class=identifier>es</span><span class=special>;</span>
<span class=identifier>es</span><span class=special>.</span><span class=identifier>insert</span><span class=special>(</span><span class=identifier>employee</span><span class=special>(</span><span class=number>0</span><span class=special>,</span><span class=string>&quot;Joe&quot;</span><span class=special>,</span><span class=number>31</span><span class=special>));</span>           <span class=comment>// inserts Joe through index #0</span>
<span class=identifier>es</span><span class=special>.</span><span class=identifier>get</span><span class=special>&lt;</span><span class=number>1</span><span class=special>&gt;().</span><span class=identifier>insert</span><span class=special>(</span><span class=identifier>employee</span><span class=special>(</span><span class=number>0</span><span class=special>,</span><span class=string>&quot;Anna&quot;</span><span class=special>,</span><span class=number>27</span><span class=special>));</span> <span class=comment>// fails!</span>
</pre></blockquote>

<p>
In this example, the second insertion is performed through index #1, but
does not succeed as index #0 bans it (Joe has the same ID.) Thus, some
sort of communication between indices is carried out behind the scenes.
Boost.IndexedSet specifies a mechanism to achieve this effect.
</p>

<h4><a name="index_hierarchy">Backbone functions</a></h4>

<p>
Let us examine in detail the different interfaces provided by an index
implementation class, considering for instance <code>index_0</code> as
defined previously.
</p>

<p align="center">
IMAGE MISSING
</p>

<p>
The public interface features the common member functions of a regular
index, like <code>begin</code>, <code>end</code>, <code>insert</code>, etc.
The protected part of <code>index_0</code> provides a number of <i>backbone
member functions</i>, which by convention are suffixed with <code>_</code>.
The signature and behavior of such backbone functions are specified by
Boost.IndexedSet so that operations that affect globally to all indices
can be performed in an orchestrated manner between them. Consider the
insertion operation
</p>

<blockquote><pre>
<span class=identifier>employee_set</span> <span class=identifier>es</span><span class=special>;</span>
<span class=identifier>es</span><span class=special>.</span><span class=identifier>insert</span><span class=special>(</span><span class=identifier>employee</span><span class=special>(</span><span class=number>0</span><span class=special>,</span><span class=string>&quot;Joe&quot;</span><span class=special>,</span><span class=number>31</span><span class=special>));</span>
</pre></blockquote>

<p>
This operation resolves in a predetermined flow of inter-index calls
as depicted in figure 5:
</p>

<p align="center">
<img src="backbone_operation.png" alt="control flow of an insertion operation"
width="500" height="482"><br>
<b>Fig. 5: Control flow of an insertion operation.</b>
</p>

<p>
The invocation of <code>insert</code> is issued to <code>index_0</code>,
which forwards this operation to the final class <code>employee_set</code>
through an indirect call to <code>index_base&lt;...&gt;::final_insert_</code>.
(This indirection is required as <code>index_0</code> is not granted
access to backbone functions of <code>employee_set</code>.)
<code>employee_set::insert_</code> does some job, like allocating
a new node for the element to be inserted, and then initiates a cascading
function call traversing the corresponding <code>insert_</code> backbone
functions of each index. The cascading invocation is terminated by
<code>index_base&lt;...&gt;</code>. So, <code>employee_set::insert_</code>
performs the global insertion giving each index the opportunity
to carry out the local actions required for this operation: node linking,
banning (if a collision is detected), etc.
</p>

<p>
Boost.IndexedSet specifies backbone member functions for insertion,
hinted insertion, deletion, updating and swapping. This specification
is explained in detail in SECTION TO BE WRITTEN.
</p>

<h4><a name="index_base"><code>index_base</code></a></h4>

<p>
The root of the index hierarchy is a particular instantiation of a
class template named <code>index_base</code>. It is not necessary
to know the template arguments with which <code>index_base</code>
is instantiated in each case, so we refer to this class simply
as <code>index_base&lt;...&gt;</code>. <code>index_base&lt;...&gt;</code>
provides several utilities to its descendant index implementation
classes, among them the following:
<ul>
  <li>Member functions for access to the backbone functions of
    the final <code>indexed_set</code> class: for instance,
    <code>final_insert</code> forwards to
    <code>indexed_set::insert_</code>. Note that these final
    backbone functions are not directly accessible from an index,
    as they are protected (protected derivation grants access
    from the derived class to the base, but not the other way
    around.)
  </li>
  <li>Cascading calls of the backbone member functions are
    terminated in <code>index_base&lt;...&gt;</code>. Some of these
    terminators are do-nothing functions, e.g. <code>erase_</code>,
    while others, like <code>insert_</code>, perform some task.
  </li>
  <li>Some internal nested types present in index implementation
    classes are defined recursively as typelists or tuples:
    <code>index_base&lt;...&gt;</code> provides the initial values
    for these types.
  </li>
</ul>
</p>

<p>
SECTION TO BE WRITTEN gives a detailed description of all facilities
offered by <code>index_base&lt;...&gt;</code> to the index implementation
classes.
</p>

<h3><a name="index_specifiers">Index specifiers</a></h3>

<p>
Consider again the type definitions of <code>employee_set</code>
that we are using throughout this section:
</p>

<blockquote><pre>
<span class=keyword>typedef</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span>
  <span class=identifier>employee</span><span class=special>,</span>
  <span class=identifier>index_list</span><span class=special>&lt;</span>
    <span class=identifier>unique</span><span class=special>&lt;</span><span class=identifier>identity</span><span class=special>&lt;</span><span class=identifier>employee</span><span class=special>&gt;</span> <span class=special>&gt;,</span>                              
    <span class=identifier>non_unique</span><span class=special>&lt;</span><span class=identifier>member</span><span class=special>&lt;</span><span class=identifier>employee</span><span class=special>,</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>,&amp;</span><span class=identifier>employee</span><span class=special>::</span><span class=identifier>name</span><span class=special>&gt;</span> <span class=special>&gt;</span>
  <span class=special>&gt;</span> 
<span class=special>&gt;</span> <span class=identifier>employee_set</span><span class=special>;</span>

<span class=keyword>typedef</span> <span class=identifier>employee_set</span><span class=special>::</span><span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=number>0</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>index_0</span><span class=special>;</span>
<span class=keyword>typedef</span> <span class=identifier>employee_set</span><span class=special>::</span><span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=number>1</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>index_1</span><span class=special>;</span>
</pre></blockquote>

<p>
It is clear that <code>index_0</code> is directly related to
<code>unique&lt;identity&lt;employee&gt; &gt</code>. At first sight, one
might think that <code>unique&lt;identity&lt;employee&gt; &gt</code> <i>is</i>
<code>index_0</code>, but this is not the case. Actually,
<code>unique&lt;...></code> is a so called <i>index specifier</i>, a special
class providing the information from which Boost.IndexedSet will derive
both the index implementation class and its associated node type. This additional
level of indirection is necessary as the actual instantiation of the
index implementation class depends on contextual information which is
not part of the arguments passed to <code>unique&lt;...&gt;</code> (for example,
the allocator class used or the parent in the index hierarchy.)
</p>

<p>
We have already reviewed the main concepts involved in the construction of
<code>indexed_set</code> containers out of the specification of several
indices. To summarize, an index consists of the following components:
<ul>
  <li>A node class template which Boost.IndexedSet instantiates for every
    particular node hierarchy being built,
  </li>
  <li>an index implementation class template, providing the public and
    internal functionality associated to the index,
  </li>
  <li>an index specifier which provides the necessary internal information
    for Boost.IndexedSet to construct the container. Usually, the index
	specifier is a class template whose arguments give the user the opportunity
	to 	configure some aspects of the final index implementation class: for
	instance, <code>unique&lt;...&gt;</code> expects the user to provide
	an appropriate key extractor and a comparison predicate.
  </li>
</ul>
The index specifier is the only type name directly exposed to the user
of Boost.IndexedSet. Usually, all other components of a given index (index
implementation class, node type) are privately defined in a <code>detail</code>
namespace.
</p>

<h2><a name="impl_guide">Index implementation guide</a></h2>

<p>
The process of implementing a new index for use with Boost.IndexedSet
will be illustrated with <code>listed</code>, a very simple index that
maintains a doubly linked list of elements and provides a minimal part
of the interface of <code>std::list</code>. <code>listed</code> is
actually a simplified version of <code>indexed_sets::sequenced</code>,
and lack important features necessary in a production-quality
implementation. Most design decisions related to <code>listed</code>
will be taken during the course of the tutorial.
</p>

<p>
WRITE MORE STUFF
</p>

<!--
<h3><a name="preliminaries">Preliminaries</a></h3>

<p>
As has been previously explained, an index is implemented as three related
components:
<ul>
  <li>A node implementation class,</li>
  <li>an index implementation class,</li>
  <li>an index specifier.</li>
</ul>
We will go through these components in this order.
</p>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost_indexed_set_ext</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>detail</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;...&gt;</span>
<span class=keyword>struct</span> <span class=identifier>listed_index_node</span>
<span class=special>{</span>
  <span class=special>...</span>
<span class=special>};</span>

<span class=keyword>template</span><span class=special>&lt;...&gt;</span>
<span class=keyword>class</span> <span class=identifier>listed_index</span>
<span class=special>{</span> 
  <span class=special>...</span>
<span class=special>};</span>

<span class=special>}</span> <span class=comment>// namespace boost_indexed_set_ext::detail</span>

<span class=keyword>template</span> <span class=special>&lt;...&gt;</span>
<span class=keyword>struct</span> <span class=identifier>listed</span>
<span class=special>{</span>
  <span class=special>...</span>
<span class=special>};</span>

<span class=special>}</span> <span class=comment>//</span>
</pre></blockquote>

<h3><a name="node_impl">Node implementation</a></h3>

<p>
Doubly linked lists are usually implemented with nodes having two pointers,
directing to the prior and next element in the list, respectively. This is
the approach we will take for <code>listed</code>.
</p>

<p>
The structure of Boost.IndexedSet <a href="#node_hierarchy">node
hierarchies</a> mandates that node classes be included into a chain
of derivations: this naturally implies that we have to provide a class
template accepting the type of the node where ours is to derived from.
</p>

<blockquote>
<b>Requirement:</b> A node class template must be of the form<br>
<pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Super</span><span class=special>&gt;</span>
<span class=keyword>class</span> <span class=identifier><i>node_name</i></span><span class=special>:</span> <span class=keyword>public</span> <span class=identifier>Super</span>
<span class=special>{</span>
  <span class=special>...</span>
<span class=special>};</span>
</pre>
When instantiated, Super will take the type of the ascending node
class in the node hierarchy.<br>
<b>Guarantees:</b>
<ul>
  <li>A node class need not be default constructible
    nor copyable.
  </li>
  <li>When instantiated, <code>node_class&lt;Super&gt;::value_type</code>
    is defined and equals the type of the elements of the
	<code>indexed_set</code>.
  </li>
  <li>When instantiated, <code>node_class&lt;Super&gt;::value</code> is
    an accessible non-static member of type
    <code>node_class&lt;Super&gt;::value_type</code>; this member holds
    the value of the element contained in the node.
  </li>
</ul>
</blockquote>

<p>
So, <code>listed_index_node</code> must not reserve any space for
the values of the elements contained.
</p>
-->
<hr>

<p>Revised January 21th 2004</p>

<p>Copyright &copy; 2003-2004 Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz.
Use, modification, and distribution are subject to the Boost Software 
License, Version 1.0. (See accompanying file <a href="../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
www.boost.org/LICENSE_1_0.txt</a>)
</p>

</body>
</html>
