<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.IndexedSet Documentation - Index reference</title>
<link rel="stylesheet" href="../style.css" type="text/css">
</head>

<body>
<h1><img src="../../../../c++boost.gif" alt="c++boost.gif (8819 bytes)" align=
"middle" width="277" height="86">Boost.IndexedSet Index reference</h1>

<h2>Contents</h2>

<ul>
  <li><a href="#index_concepts">Index concepts</a></li>
  <li><a href="#complexity_signature">Complexity signature</a></li>
  <li><a href="#index_specification">Index specification</a></li>
  <li><a href="#index_list_synopsis">Header
    <code>"boost/indexed_set/index_list.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#index_list">Template class <code>index_list</code></a></li>
      <li><a href="#mpl_index_list">Template class <code>mpl_index_list</code></a></li>
    </ul>
  </li>
  <li><a href="#tags">Tags</a></li>
  <li><a href="#tag_synopsis">Header
    <code>"boost/indexed_set/tag.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#tag">Template class <code>tag</code></a></li>
    </ul>
  </li>
  <li><a href="#index_catalog">Indices provided by Boost.IndexedSet</a>
    <ul>
      <li><a href="#key_based_indices">Key-based indices</li>
      <li><a href="#other_indices">Other types</li>
    </ul>
  </li>
</ul>

<h2><a name="index_concepts">Index concepts</a></h2>

<p>
<code>indexed_set</code> instantiations comprise one or more indices
specified at compile time. Each index allows read/write access to the elements
contained in a definite manner. For instance,
<a href="reg_indices.html">regular indices</a>
provide a set-like interface to the elements, whereas
<a href="seq_indices.html">sequenced indices</a> mimic the functionality
of <code>std::list</code>.
</p>

<p>
Indices are not isolated objects, and so cannot be constructed on their
own. Rather they are embedded into an <code>indexed_set</code> as specified by
means of an <a href="#index_specification">index specifier</a>. The name of
the index class implementation proper is never directly exposed to the user, who
has only access to the associated index specifier.
</p>

<p>
Insertion and erasing of elements are always performed through the
appropriate interface of some index of the <code>indexed_set</code>;
these operations, however, do have an impact on all other indices as
well: for instance, insertion through a given index may fail because
there exists another index which bans the operation in order to preserve
its invariant (like uniqueness of elements.) This circumstance, rather
than an obstacle, yields much of the power of Boost.IndexedSet:
equivalent constructions based on manual composition of standard
containers would have to add a fair amount of code in order to
globally preserve the invariants of each container while guaranteeing
that all of them are synchronized. The global operations performed
in a joint manner among the various indices can be reduced to
six primitives:
<ul>
  <li>Copying,</li>
  <li>insertion of an element,</li>
  <li>hinted insertion, where a preexisting element is suggested in
    order to improve the efficiency of the operation,</li>
  <li>deletion of an element,</li>
  <li>updating of an element, i.e. replacing of the value of an element,
    which may trigger the rearrangement of this element in one or
    more indices, or the banning of the update,</li>
  <li>modification of an element, and its subsequent
    rearrangement/banning by the various indices.
</ul>
The last two primitives deserve some further explanation: in order to
guarantee the invariants associated to each index (e.g. some definite
ordering,) elements of an <code>indexed_set</code> are not mutable.
To overcome this restriction, indices expose member functions
for updating and modifying, which allow for the mutation of elements
in a controlled fasion. Immutability of elements does not significantly
impact the interface of regular indices, as it is based upon  that of
<code>std::set</code> and <code>std:multiset</code>, and these containers
also have non-mutable elements; but it may come as a surprise when dealing
with sequenced indices, which are designed upon the functionality provided
by <code>std::list</code>. 
</p>

<p>
These global operations are not directly exposed to the user, but rather
they are wrapped as appropriate by each index (for instance, regular indices
provide a set-like suite of insertion member functions, whereas sequenced
indices do have <code>push_back</code> and <code>push_front</code>
operations.) Boost.IndexedSet poses no particular conditions on
the interface of indices, save that they must model
<a href="http://www.sgi.com/tech/stl/Container.html">
<code>Container</code></a> (without the requirement of being
<a href="http://www.sgi.com/tech/stl/Assignable.html">
<code>Assignable</code></a>.)
</p>

<h2><a name="complexity_signature">Complexity signature</a></h2>

<p>
Some member functions of an index interface are implemented by
global primitives from the list above. Complexity of these operations
thus depends on all indices of a given <code>indexed_set</code>, not just
the currently used index.
</p>

<p>
In order to establish complexity estimates, an index is characterized
by its <i>complexity signature</i>, consisting of the following
associated functions on the number of elements:
<ul>
  <li><code>c(n)</code>: copying,
  <li><code>i(n)</code>: insertion,
  <li><code>h(n)</code>: hinted insertion,
  <li><code>d(n)</code>: deletion,
  <li><code>u(n)</code>: updating,
  <li><code>m(n)</code>: modifying.
</ul>

</p>
Each function yields the complexity estimate of the contribution of the index
to the corresponding global primitive. Let us consider
an instantiation of <code>indexed_set</code>
with <code>N</code> indices labelled <code>0</code>,...,<code>N-1</code>
whose complexity signatures are
(<code>c<sub>i</sub></code>,<code>i<sub>i</sub></code>,<code>h<sub>i</sub></code>,<code>d<sub>i</sub></code>,<code>u<sub>i</sub></code>,<code>m<sub>i</sub></code>);
the insertion of an element in such a set is then of complexity
<code>O(I<sub>0</sub>(n)+иии+I<sub>N-1</sub>(n))</code> where <code>n</code>
is the number of elements. To abbreviate notation, we adopt the
following definitions:
<ul>
  <li><code>C(n)=c<sub>0</sub>(n)+иии+c<sub>N-1</sub>(n)</code>,</li>
  <li><code>I(n)=i<sub>0</sub>(n)+иии+i<sub>N-1</sub>(n)</code>,</li>
  <li><code>H(n)=h<sub>0</sub>(n)+иии+h<sub>N-1</sub>(n)</code>,</li>
  <li><code>D(n)=d<sub>0</sub>(n)+иии+d<sub>N-1</sub>(n)</code>,</li>
  <li><code>U(n)=u<sub>0</sub>(n)+иии+u<sub>N-1</sub>(n)</code>,</li>
  <li><code>M(n)=m<sub>0</sub>(n)+иии+m<sub>N-1</sub>(n)</code>.</li>
</ul>
For instance, consider an <code>indexed_set</code> with two regular indices,
for which <code>i(n)=log(n)</code>, and a sequenced index with <code>i(n)=1</code>
(constant time insertion). Insertion of an element into this <code>indexed_set</code>
is then of complexity
<blockquote>
<code>O(I(n))=O(2*log(n)+1)=O(log(n))</code>.
</blockquote>
</p>

<h2><a name="index_specification">Index specification</a></h2>

<p>
Index specifiers are passed as arguments of <a href="#index_list">
<code>index_list</code></a> and provide <code>indexed_set</code> with
the information needed to incorporate the corresponding index.
Future releases of Boost.IndexedSet may allow for specification of user-defined
indices. Meanwhile, the requirements for an index specifier remain
implementation defined. Currently, Boost.IndexedSet provides the index specifiers
<a href="reg_indices.html#unique_non_unique"><code>unique</code> and
<code>non_unique</code></a> for
<a href="reg_indices.html">regular indices</a> and
<a href="seq_indices.html#sequenced"><code>sequenced</code></a> for
<a href="seq_indices.html">sequenced indices</a>.
</p>

<h2>
<a name="index_list_synopsis">Header
<a href="../../../../boost/indexed_set/index_list.hpp">
<code>"boost/indexed_set/index_list.hpp"</code></a> synopsis</a></h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>typename</span> <span class=identifier>T0</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>T1</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=special>...</span>
  <span class=keyword>typename</span> <span class=identifier>Tn</span><span class=special>=</span><b>implementation defined default</b><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>index_list</span><span class=special>;</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>MplFwdSequence</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>mpl_index_list</span><span class=special>;</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="index_list">Template class <code>index_list</code></a></h3>

<p>
<code>index_list</code> is a typelist construct used to specify a compile-time
sequence of indices as the <code>IndexSpecifierList</code> of
<code>indexed_set</code>.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>typename</span> <span class=identifier>T0</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>T1</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=special>...</span>
  <span class=keyword>typename</span> <span class=identifier>Tn</span><span class=special>=</span><b>implementation defined default</b><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>index_list</span><span class=special>;</span>
</pre></blockquote>

<p>
Each element of <code>indexed_list</code> must be an index specifier.
The maximum number of elements of an <code>index_list</code> is
implementation defined.
</p>

<h3><a name="mpl_index_list">Template class <code>mpl_index_list</code></a></h3>

<p>
The class template <code>mpl_index_list</code> takes as argument an
<a href="../../../../libs/mpl/doc/ref/Forward_Sequence.html">
<code>MPL Forward Sequence</code></a>, each of its elements being
an index specifier.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>MplFwdSequence</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>mpl_index_list</span><span class=special>;</span>
</pre></blockquote>

<p>
<code>mpl_index_list</code> is a convenient replacement of the more
usual <code>index_list</code> for metaprogramming purposes.
</p>

<h2><a name="tags">Tags</a></h2>

<p>
Tags are just conventional types used as mnemonics for indices of an
<code>indexed_set</code>, as for instance in member function <code>get</code>.
Each index can have none, one or more tags associated. The way tags are assigned
to a given index is dependent on the particular index specifier. However,
for convenience all indices of Boost.IndexedSet support tagging through the
class template <a href="#tag"><code>tag</code></a>.
</p>

<h2>
<a name="tag_synopsis">Header
<a href="../../../../boost/indexed_set/tag.hpp">
<code>"boost/indexed_set/tag.hpp"</code></a> synopsis</a></h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>typename</span> <span class=identifier>T0</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>T1</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=special>...</span>
  <span class=keyword>typename</span> <span class=identifier>Tn</span><span class=special>=</span><b>implementation defined default</b><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>tag</span><span class=special>;</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="tag">Template class <code>tag</code></a></h3>

<p>
<code>tag</code> is a typelist construct used to specify a compile-time
sequence of tags to be assigned to an index in instantiation time.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>typename</span> <span class=identifier>T0</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>T1</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=special>...</span>
  <span class=keyword>typename</span> <span class=identifier>Tn</span><span class=special>=</span><b>implementation defined default</b><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>tag</span><span class=special>;</span>
</pre></blockquote>

<p>
Elements of <code>tag</code> can be any type, though the user is expected
to provide classes with mnemonic names. The maximum number of elements of a
<code>tag</code> instantiation is implementation defined.
</p>

<h2><a name="index_catalog">Indices provided by Boost.IndexedSet</a></h2>


<h3><a name="key_based_indices">Key-based indices</h3>

<p>
Indices of this type are organized around <i>keys</i> obtained from the
elements, as described in the <a href="key_extraction.html">key extraction
reference</a>.
<ul>
  <li><a href="reg_indices.html">Regular indices</a> sort the elements
    on the key and provide fast lookup capabilites.</li>
  <li>Hashed indices (<b>not currently implemented</b>) offer high
    efficiency access through hashing techniques.</li>
</ul>
</p>

<h3><a name="other_indices">Other types</h3>

<p>
<ul>
  <li><a href="seq_indices.html">Sequenced indices</a> allow to arrange
    elements as in a bidirectional list.  </li>
</ul>
</p>


<hr>

<p>Revised March 17th 2004</p>

<p>Copyright &copy; 2003-2004 Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz.
Use, modification, and distribution are subject to the Boost Software 
License, Version 1.0. (See accompanying file <a href="../../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
www.boost.org/LICENSE_1_0.txt</a>)
</p>

</body>
</html>
