<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.IndexedSet Documentation - Key extraction reference</title>
<link rel="stylesheet" href="../style.css" type="text/css">
</head>

<body>
<h1><img src="../../../../c++boost.gif" alt="c++boost.gif (8819 bytes)" align=
"middle" width="277" height="86">Boost.IndexedSet Key extraction reference</h1>

<h2>Contents</h2>

<ul>
  <li><a href="#key_extractors">Key Extractors</a>
    <ul>
      <li><a href="#far_pointers">Far pointers</a></li>
    </ul>
  </li>
  <li><a href="#identity_synopsis">Header
    <code>"boost/indexed_set/identity.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#identity">Template class <code>identity</code></a></li>
    </ul>
  </li>
  <li><a href="#member_synopsis">Header
    <code>"boost/indexed_set/member.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#member">Template class <code>member</code></a></li>
      <li><a href="#member_offset">Template class <code>member_offset</code></a></li>
      <li><a href="#boost_indexed_set_member">Macro <code>BOOST_INDEXED_SET_MEMBER</code></a></li>
    </ul>
  </li>
  <li><a href="#mem_fun_synopsis">Header
    <code>"boost/indexed_set/mem_fun.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#const_mem_fun">Template class <code>const_mem_fun</code></a></li>
      <li><a href="#mem_fun">Template class <code>mem_fun</code></a></li>
      <li><a href="#const_mem_fun_explicit">Template class <code>const_mem_fun_explicit</code></a></li>
      <li><a href="#mem_fun_explicit">Template class <code>mem_fun_explicit</code></a></li>
      <li><a href="#boost_indexed_set_const_mem_fun">Macro <code>BOOST_INDEXED_SET_CONST_MEM_FUN</code></a></li>
      <li><a href="#boost_indexed_set_mem_fun">Macro <code>BOOST_INDEXED_SET_MEM_FUN</code></a></li>
    </ul>
  </li>
</ul>

<h2><a name="key_extractors">Key Extractors</a></h2>

<p>
Key extraction classes are used by <a href="reg_indices.html">regular indices</a> to
obtain the sorting keys from the elements of an <code>indexed_set</code>.
An <a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>
class <code>KeyFromValue</code> is said to be a key extractor from a
type <code>T</code> if
<ol>
  <li>the type <code>KeyFromValue::result_type</code> is defined,</li>
  <li><code>k1(ca)</code> is defined and returns a value convertible
    to <code>const KeyFromValue::result_type&</code>,</li>
  <li>if <code>k2</code> is a copy of <code>k1</code>, <code>k1(ca)</code> is the
    same value as <code>k2(ca)</code>,</li>
</ol>
for every <code>k1</code>, <code>k2</code> of type <code>const KeyFromValue</code>,
and <code>ca</code> of type <code>const Type&</code>.
</p>

<p>
Additionally, <code>KeyFromValue</code> is a <i>read/write</i> key extractor
if the following extra conditions are met:
<ol>
  <li><code>k1(a)</code> is defined and returns a value convertible
    to <code>KeyFromValue::result_type&</code>,</li>
  <li><code>const_cast&lt;const KeyFromValue::result_type&>(k1(a))</code>
    is the same  value as
    <code>k1(const_cast&lt;const Type&>(a))</code>,</li>
</ol>
for every <code>k1</code> of type <code>const KeyFromValue</code> and
<code>a</code> of type <code>Type&</code>.
</p>

<p>
Boost.IndexedSet provides four general-purpose key extractors:
<ul>
  <li><a href="#identity"><code>identity</code></a>,</li>
  <li><a href="#member"><code>member</code></a>,</li>
  <li><a href="#const_mem_fun"><code>const_mem_fun</code></a> and</li>
  <li><a href="#mem_fun"><code>mem_fun</code></a>,</li>
</ul>
plus replacements for some of them:
<ul>
  <li><a href="#member_offset"><code>member_offset</code></a>,</li>
  <li><a href="#const_mem_fun_explicit"><code>const_mem_fun_explicit</code></a> and</li>
  <li><a href="#mem_fun_explicit"><code>mem_fun_explicit</code></a>,</li>
</ul>
that workaround some deficiencies in the support for non-type template parameters
by certain compilers.
</p>

<h3><a name="far_pointers">Far pointers</a></h3>

<p>
The key extractors provided by Boost.IndexedSet are templatized according
to the type <code>Type</code> and serve to extract keys not only from objects
of type <code>Type</code>, but also from reference wrappers provided by
<a href="../../../../doc/html/ref.html">Boost.Ref</a> and from <i>far pointers</i>
to <code>Type</code> (or to reference wrappers of <code>Type</code>): a far pointer
is any type <code>P</code> such that, for an object <code>p</code> of type
<code>const P</code>
<ul>
  <li><code>*x</code> yields an object of type <code>Type&</code> or
    <code>boost::reference_wrapper&lt;Type></code>, OR</li>
  <li><code>*x</code> yields a far pointer to <code>Type&</code></li>,
</ul>
that is, far pointers are arbitrary compositions of pointer-like objects
ultimately dereferencing to values of <code>Type&</code> or
<code>boost::reference_wrapper&lt;Type></code>.
<p>

<h2>
<a name="identity_synopsis">Header
<a href="../../../../boost/indexed_set/identity.hpp">
<code>"boost/indexed_set/identity.hpp"</code></a> synopsis</a></h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>T</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>identity</span><span class=special>;</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="identity">Template class <code>identity</code></a></h3>

<p>
<code>identity</code> is a <a href="#key_extractors"><code>Key Extractor</code></a>
that acts as a do-nothing identity functor.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>identity</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=identifier>Type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>FarPtr</span><span class=special>&gt;</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>FarPtr</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> 
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=identifier>Type</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> <span class=comment>// only provided if Type is non-const

  // only provided if Type is non-const</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> 

  <span class=comment>// only provided if Type is const</span>
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>remove_const</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> 

  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
<code>identity&lt;Type></code> is a model of:
<ul>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>Type</code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;const Type></code>,</li>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;Type></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from any <a href="#far_pointers">far pointer</a> to
    <code>const Type</code></code>.</li>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from any <a href="#far_pointers">far pointer</a>
    to <code>Type</code></code>.</li>
</ul>
</p>

<h4><code>identity</code> members</h4>

<code>template&lt;typename FarPtr> Type& operator()(const FarPtr& x)const;</code>

<blockquote>
<b>Requires:</b> <code>FarPtr</code> is a <a href="#far_pointers">far pointer</a>
type to <code>Type</code>.<br>
<b>Returns:</b> a reference to the object far-pointed to by <code>x</code>.
</blockquote>

<code>const Type& operator()(const Type&x)const;</code>

<blockquote>
<b>Returns:</b> <code>x</code>.
</blockquote>

<code>Type& operator()(Type &x)const;</code>

<blockquote>
<b>Returns:</b> <code>x</code>.
</blockquote>

<code>const Type& operator()(const reference_wrapper&lt;const Type>& x)const;</code>
<blockquote>
<b>Returns:</b> <code>x.get()</code>.
</blockquote>

<code>Type& operator()(const reference_wrapper&lt;typename remove_const&lt;Type>::type>& x)const;</code>
<blockquote>
<b>Returns:</b> <code>x.get()</code>.
</blockquote>

<code>Type& operator()(const reference_wrapper&lt;Type>& x)const;</code>
<blockquote>
<b>Returns:</b> <code>x.get()</code>.
</blockquote>


<h2>
<a name="member_synopsis">Header
<a href="../../../../boost/indexed_set/member.hpp">
<code>"boost/indexed_set/member.hpp"</code></a> synopsis</a></h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMember</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>member</span><span class=special>;</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>size_t</span> <span class=identifier>OffsetOfMember</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>member_offset</span><span class=special>;</span>

<span class=preprocessor>#define</span> <span class=identifier>BOOST_INDEXED_SET_MEMBER</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberName</span><span class=special>)</span> <b>implementation defined</b>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="member">Template class <code>member</code></a></h3>

<p>
<code>member</code> is a <a href="#key_extractors"><code>Key Extractor</code></a>
aimed at accessing a given member of a class.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMember</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>member</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=identifier>Type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>FarPtr</span><span class=special>&gt;</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>FarPtr</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> <span class=comment>// only provided if Type is non-const</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
The <code>PtrToMember</code> template argument specifies the particular
<code>Type Class::*</code> pointer to the member to be extracted.
<code>member&lt;Class,Type,PtrToMember></code> is a model of:
<ul>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>Class</code> if <code>Type</code> is non-<code>const</code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;const Class></code>,</li>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;Class></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from any <a href="#far_pointers">far pointer</a>
    to <code>const Class</code></code>,</li>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from any <a href="#far_pointers">far pointer</a>
    to <code>Class</code></code>.</li>
</ul>
</p>

<h4><code>member</code> members</h4>

<code>template&lt;typename FarPtr> Type& operator()(const FarPtr& x)const;</code>
  
<blockquote>
<b>Requires:</b> <code>FarPtr</code> is a <a href="#far_pointers">far pointer</a>
type to <code>Type</code>.<br>
<b>Returns:</b> a reference to the object far-pointed to by <code>x</code>.
</blockquote>

<code>const Type& operator()(const Class&x)const;</code>

<blockquote>
<b>Returns:</b> <code>x.*PtrToMember</code>.
</blockquote>

<code>Type& operator()(const Class&x);</code>

<blockquote>
<b>Returns:</b> <code>x.*PtrToMember</code>.
</blockquote>

<code>const Type& operator()(const reference_wrapper&lt;const Class>& x)const;</code>

<blockquote>
<b>Returns:</b> <code>x.get().*PtrToMember</code>.
</blockquote>

<code>Type& operator()(const reference_wrapper&lt;Class>& x)const;</code>

<blockquote>
<b>Returns:</b> <code>x.get().*PtrToMember</code>.
</blockquote>

<h3><a name="member_offset">Template class <code>member_offset</code></a></h3>

<p>
Some compilers do not properly support pointers to members as non-type
template arguments. The following have been confirmed to have bugs in
this respect:
<ul>
  <li>MSVC++ 6.0 (see 
    <a href="http://support.microsoft.com/default.aspx?scid=kb;EN-US;249045">Microsoft
    Knowledge Base article #249045</a></li>),
  <li>Intel C++ 7.0/7.1 for Windows (support issue #207321.)
</ul>
In this situation, <code>member_offset</code> provides an
alternative to <a href="#member"><code>member</code></a> accepting offsets
instead of pointers to members. Please note that the use of
<code>offsetof</code> on non-POD types is forbidden by the standard;
luckily enough, most compilers accept it nevertheless, so
<code>member_offset</code> serves as a workaround for most practical purposes.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMember</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>member_offset</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=identifier>Type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>FarPtr</span><span class=special>&gt;</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>FarPtr</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> 
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> <span class=comment>// only provided if Type is non-const</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>As an example of use, given the class</p>

<blockquote><pre>
<span class=keyword>class</span> <span class=identifier>A</span>
<span class=special>{</span>
  <span class=keyword>int</span> <span class=identifier>x</span><span class=special>;</span>
<span class=special>}</span>
</pre></blockquote>

<p>
the instantiation <code>member&lt;A,int,&A::x></code> can be simulated then
as <code>member_offset&lt;A,int,offsetof(A,x)></code>.
</p>

<h3><a name="boost_indexed_set_member">Macro <code>BOOST_INDEXED_SET_MEMBER</code></a></h3>

<blockquote><pre>
<span class=identifier>BOOST_INDEXED_SET_MEMBER</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberName</span><span class=special>)</span>
</pre></blockquote>

<p>
This macro is provided as an aid for using <code>member</code> and
<code>member_offset</code> when writing cross-platform code. In the usual cases,
it expands to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>member</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,&amp;</span><span class=identifier>Class</span><span class=special>::</span><span class=identifier>MemberName</span><span class=special>&gt;</span>
</pre></blockquote>

<p>
but it resolves to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>member_offset</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>offsetof</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>MemberName</span><span class=special>)&gt;</span>
</pre></blockquote>

<p>
for the following compilers:
<ul>
  <li>MSVC++ 6.0 or lower,
  <li>Intel C++ 7.1 or lower for Windows,
</ul>
and/or if the macro <code>BOOST_NO_POINTER_TO_MEMBER_TEMPLATE_PARAMETERS</code>
is defined.
</p>

<h2>
<a name="mem_fun_synopsis">Header
<a href="../../../../boost/indexed_set/mem_fun.hpp">
<code>"boost/indexed_set/mem_fun.hpp"</code></a> synopsis</a></h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMemberFunction</span><span class=special>)()</span><span class=keyword>const</span><span class=special>&gt;</span>
  <span class=keyword>struct</span> <span class=identifier>const_mem_fun</span><span class=special>;</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMemberFunction</span><span class=special>)()&gt;</span>
  <span class=keyword>struct</span> <span class=identifier>mem_fun</span><span class=special>;</span>

<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>PtrToMemberFunctionType</span><span class=special>,</span><span class=identifier>PtrToMemberFunctionType</span> <span class=identifier>PtrToMemberFunction</span>
<span class=special>&gt;</span>
  <span class=keyword>struct</span> <span class=identifier>const_mem_fun_explicit</span><span class=special>;</span>

<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>PtrToMemberFunctionType</span><span class=special>,</span><span class=identifier>PtrToMemberFunctionType</span> <span class=identifier>PtrToMemberFunction</span>
<span class=special>&gt;</span>
  <span class=keyword>struct</span> <span class=identifier>mem_fun_explicit</span><span class=special>;</span>

<span class=preprocessor>#define</span> <span class=identifier>BOOST_INDEXED_SET_CONST_MEM_FUN</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberFunName</span><span class=special>)</span> <b>implementation defined</b>
<span class=preprocessor>#define</span> <span class=identifier>BOOST_INDEXED_SET_MEM_FUN</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberFunName</span><span class=special>)</span> <b>implementation defined</b>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="const_mem_fun">Template class <code>const_mem_fun</code></a></h3>

<p>
<code>const_mem_fun</code> is a <a href="#key_extractors"><code>Key Extractor</code></a>
returning as key the result of invoking a given constant member function of a class.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMemberFunction</span><span class=special>)()</span><span class=keyword>const</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>const_mem_fun</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>remove_reference</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>FarPtr</span><span class=special>&gt;</span> <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>FarPtr</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
The <code>PtrToMemberFunction</code> template argument specifies the particular
<code>Type (Class::*PtrToMemberFunction)()const</code> pointer to the the constant
member function used in the extraction.
<code>const_mem_fun&lt;Class,Type,PtrToMemberFunction></code> is a model of:
<ul>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>Class</code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;const Class></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;Class></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from any <a href="#far_pointers">far pointer</a>
    to <code>const Class</code></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from any <a href="#far_pointers">far pointer</a>
    to <code>Class</code></code>.</li>
</ul>
</p>

<h4><code>const_mem_fun</code> members</h4>

<code>template&lt;typename FarPtr> Type operator()(const FarPtr& x)const;</code>

<blockquote>
<b>Requires:</b> <code>FarPtr</code> is a <a href="#far_pointers">far pointer</a>
type to <code>Type</code>.<br>
<b>Returns:</b> <code>(x.*PtrToMemberFunction)()</code>, where <code>x</code> is the
object far-pointed to by <code>x</code>.
</blockquote>

<code>Type operator()(const Class& x)const;</code>

<blockquote>
<b>Returns:</b> <code>(x.*PtrToMemberFunction)()</code>.
</blockquote>

<code>Type operator()(const reference_wrapper&lt;const Class>& x)const;</code>

<blockquote>
<b>Returns:</b> <code>(x.get().*PtrToMemberFunction)()</code>.
</blockquote>

<code>Type operator()(const reference_wrapper&lt;Class>& x)const;</code>

<blockquote>
<b>Returns:</b> <code>(x.get().*PtrToMemberFunction)()</code>.
</blockquote>

<h3><a name="mem_fun">Template class <code>mem_fun</code></a></h3>

<p>
<code>mem_fun</code> is a <a href="#key_extractors"><code>Key Extractor</code></a>
returning as key the result of invoking a given member function of a class.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMemberFunction</span><span class=special>)()&gt;</span>
<span class=keyword>struct</span> <span class=identifier>mem_fun</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>remove_reference</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>FarPtr</span><span class=special>&gt;</span> <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>FarPtr</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
The <code>PtrToMemberFunction</code> template argument specifies the particular
<code>Type (Class::*PtrToMemberFunction)()</code> pointer to the the member
function used in the extraction.
<code>mem_fun&lt;Class,Type,PtrToMemberFunction></code> is a model of:
<ul>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;Class></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from any <a href="#far_pointers">far pointer</a>
    to <code>Class</code></code>.</li>
</ul>
</p>

<h4><code>mem_fun</code> members</h4>

<code>template&lt;typename FarPtr> Type operator()(const FarPtr& x)const;</code>

<blockquote>
<b>Requires:</b> <code>FarPtr</code> is a <a href="#far_pointers">far pointer</a>
type to <code>Type</code>.<br>
<b>Returns:</b> <code>(x.*PtrToMemberFunction)()</code>, where <code>x</code> is the
object far-pointed to by <code>x</code>.
</blockquote>

<code>Type operator()(Class& x)const;</code>

<blockquote>
<b>Returns:</b> <code>(x.*PtrToMemberFunction)()</code>.
</blockquote>

<code>Type operator()(const reference_wrapper&lt;Class>& x)const;</code>

<blockquote>
<b>Returns:</b> <code>(x.get().*PtrToMemberFunction)()</code>.
</blockquote>

<h3><a name="const_mem_fun_explicit">Template class <code>const_mem_fun_explicit</code></a></h3>

<p>
MSVC++ 6.0 do not properly support pointers to constant member functions as non-type
template parameters, thus <a href="#const_mem_fun"><code>const_mem_fun</code></a> cannot be
used in this compiler. A simple workaround consists in specifying the <i>type</i> of
these pointers as an additional template parameter.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>PtrToMemberFunctionType</span><span class=special>,</span><span class=identifier>PtrToMemberFunctionType</span> <span class=identifier>PtrToMemberFunction</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>const_mem_fun_explicit</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>remove_reference</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>FarPtr</span><span class=special>&gt;</span> <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>FarPtr</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
<code>const_mem_fun_explicit</code> provides the very same functionality as
its <code>const_mem_fun</code> analogous instantiation. For example, given the type
</p>

<blockquote><pre>
<span class=keyword>struct</span> <span class=identifier>A</span>
<span class=special>{</span>
  <span class=keyword>int</span> <span class=identifier>f</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
the extractor <code>const_mem_fun&lt;A,int,&A::f></code> can be replaced by
<code>const_mem_fun_explicit&lt;A,int,int (A::*)()const,&A::f></code>.
</p>

<h3><a name="mem_fun_explicit">Template class <code>mem_fun_explicit</code></a></h3>

<p>
For analogy with <a href="#const_mem_fun_explicit"><code>const_mem_fun_explicit</code></a>,
a variation of <a href="#mem_fun"><code>mem_fun</code></a> is provided accepting
an additional parameter with the type of the pointer to non-constant member function
used for extraction.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>PtrToMemberFunctionType</span><span class=special>,</span><span class=identifier>PtrToMemberFunctionType</span> <span class=identifier>PtrToMemberFunction</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>mem_fun_explicit</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>remove_reference</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>FarPtr</span><span class=special>&gt;</span> <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>FarPtr</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<h3><a name="boost_indexed_set_const_mem_fun">Macro
<code>BOOST_INDEXED_SET_CONST_MEM_FUN</code></a></h3>

<blockquote><pre>
<span class=identifier>BOOST_INDEXED_SET_CONST_MEM_FUN</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberFunName</span><span class=special>)</span>
</pre></blockquote>

<p>
Use this macro when writing cross-platform code selectively using
<code>const_mem_fun_explicit</code> in place of <code>const_mem_fun</code> for
compilers not supporting the latter. In the usual cases, the macro expands to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>const_mem_fun</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,&amp;</span><span class=identifier>Class</span><span class=special>::</span><span class=identifier>MemberFunName</span><span class=special>&gt;</span>
</pre></blockquote>

<p>
but it resolves to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>const_mem_fun_explicit</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*)()</span><span class=keyword>const</span><span class=special>,&amp;</span><span class=identifier>Class</span><span class=special>::</span><span class=identifier>MemberFunName</span><span class=special>&gt;</span>
</pre></blockquote>

<p>
for MSVC++ 6.0 or lower.
</p>


<h3><a name="boost_indexed_set_mem_fun">Macro
<code>BOOST_INDEXED_SET_MEM_FUN</code></a></h3>

<blockquote><pre>
<span class=identifier>BOOST_INDEXED_SET_MEM_FUN</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberFunName</span><span class=special>)</span>
</pre></blockquote>

<p>
By default, the macro expands to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>mem_fun</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,&amp;</span><span class=identifier>Class</span><span class=special>::</span><span class=identifier>MemberFunName</span><span class=special>&gt;</span>
</pre></blockquote>

<p>
but it resolves to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>mem_fun_explicit</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*)()</span><span class=special>,&amp;</span><span class=identifier>Class</span><span class=special>::</span><span class=identifier>MemberFunName</span><span class=special>&gt;</span>
</pre></blockquote>

<p>
for MSVC++ 6.0 or lower.
</p>

<hr>

<p>Revised February 12th 2004</p>

<p>Copyright &copy; 2003-2004 Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz.
Use, modification, and distribution are subject to the Boost Software 
License, Version 1.0. (See accompanying file <a href="../../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
www.boost.org/LICENSE_1_0.txt</a>)
</p>

</body>
</html>
