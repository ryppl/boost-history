<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.IndexedSet Documentation - Reference</title>
<link rel="stylesheet" href="style.css" type="text/css">
</head>

<body>
<h1><img src="../../../c++boost.gif" alt="c++boost.gif (8819 bytes)" align=
"middle" width="277" height="86">Boost.IndexedSet Reference</h1>

<h2>Contents</h2>

<ul>
  <li><a href="#header_dependencies">Header dependencies</a></li>
  <li><a href="#indexed_set_fwd_synopsis">Header
    <code>"boost/indexed_set_fwd.hpp"</code> synopsis</a></li>
  <li><a href="#indexed_set_synopsis">Header
    <code>"boost/indexed_set.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#indexed_set">Template class <code>indexed_set</code></a>
        <ul>
          <li><a href="#indexed_set_notation">Notation</a></li>
          <li><a href="#indexed_set_instantiation_types"><code>indexed_set</code>
            instantiation types</a></li>
          <li><a href="#indexed_set_types"><code>indexed_set</code> types</a></li>
          <li><a href="#indexed_set_nested_templates"><code>indexed_set</code>
            nested class templates</a></li>
          <li><a href="#indexed_set_constructors"><code>indexed_set</code>
            constructors, copy and assignment</a></li>
          <li><a href="#indexed_set_index_retrieval"><code>indexed_set</code>
            index retrieval operations</a></li>
          <li><a href="#indexed_set_projection"><code>indexed_set</code>
            projection operations</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#index_fwd_synopsis">Header
    <code>"boost/indexed_set/index_fwd.hpp"</code> synopsis</a></li>
  <li><a href="#index_synopsis">Header
    <code>"boost/indexed_set/index.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#unique_non_unique">
        Index specifiers <code>unique</code> and <code>non_unique</code>
        </a></li>
      <li><a href="#indices">Indices</a>
        <ul>
          <li><a href="#index_notation">Notation</a></li>
          <li><a href="#index_instantiation_types">Index instantiation types</a></li>
          <li><a href="#index_constructors">Index constructors</a></li>
          <li><a href="#index_modifiers">Index modifiers</a></li>
          <li><a href="#index_observers">Index observers</a></li>
          <li><a href="#index_set_operations">Index set operations</a></li>
          <li><a href="#index_range_operations">Index range operations</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#index_list_synopsis">Header
    <code>"boost/indexed_set/index_list.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#index_specification">Index specification</a></li>
      <li><a href="#index_list">Template class <code>index_list</code></a></li>
    </ul>
  </li>
  <li><a href="#tag_synopsis">Header
    <code>"boost/indexed_set/tag.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#tags">Tags</a></li>
      <li><a href="#tag">Template class <code>tag</code></a></li>
    </ul>
  </li>
  <li><a href="#key_extractors">Key Extractors</a></li>
  <li><a href="#identity_synopsis">Header
    <code>"boost/indexed_set/identity.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#identity">Template class <code>identity</code></a></li>
    </ul>
  </li>
  <li><a href="#member_synopsis">Header
    <code>"boost/indexed_set/member.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#member">Template class <code>member</code></a></li>
      <li><a href="#member_offset">Template class <code>member_offset</code></a></li>
      <li><a href="#boost_indexed_set_member">Macro <code>BOOST_INDEXED_SET_MEMBER</code></a></li>
    </ul>
  </li>
  <li><a href="#mem_fun_synopsis">Header
    <code>"boost/indexed_set/mem_fun.hpp"</code> synopsis</a>
    <ul>
      <li><a href="#const_mem_fun">Template class <code>const_mem_fun</code></a></li>
      <li><a href="#mem_fun">Template class <code>mem_fun</code></a></li>
      <li><a href="#const_mem_fun_explicit">Template class <code>const_mem_fun_explicit</code></a></li>
      <li><a href="#mem_fun_explicit">Template class <code>mem_fun_explicit</code></a></li>
      <li><a href="#boost_indexed_set_const_mem_fun">Macro <code>BOOST_INDEXED_SET_CONST_MEM_FUN</code></a></li>
      <li><a href="#boost_indexed_set_mem_fun">Macro <code>BOOST_INDEXED_SET_MEM_FUN</code></a></li>
    </ul>
  </li>
</ul>

<h2><a name="header_dependencies">Header dependencies</a></h2>

<p>
The following dependencies among headers of Boost.IndexedSet hold:
<ul>
  <li><a href="#indexed_set_fwd_synopsis"><code>"boost/indexed_set_fwd.hpp"</code></a>
    includes
    <ul>
      <li><a href="#index_list_synopsis">
	    <code>"boost/indexed_set/index_list.hpp"</code></a>,</li>
      <li><a href="#tag_synopsis"><code>"boost/indexed_set/tag.hpp"</code></a> and</li>
      <li><a href="#identity_synopsis">
	    <code>"boost/indexed_set/identity.hpp"</code></a>,</li>
    </ul>
  </li>
  <li><a href="#indexed_set_synopsis"><code>"boost/indexed_set.hpp"</code></a>
    includes
    <ul>
      <li><a href="#index_synopsis"><code>"boost/indexed_set/index.hpp"</code></a>,</li>
      <li><a href="#index_list_synopsis">
	    <code>"boost/indexed_set/index_list.hpp"</code></a>,</li>
      <li><a href="#tag_synopsis"><code>"boost/indexed_set/tag.hpp"</code></a>,</li>
      <li><a href="#identity_synopsis">
	    <code>"boost/indexed_set/identity.hpp"</code></a> and</li>
      <li><a href="#member_synopsis"><code>"boost/indexed_set/member.hpp"</code></a> and</li>
	  <li><a href="#mem_fun_synopsis"><code>"boost/indexed_set/mem_fun.hpp"</code></a>.</li>
    </ul>
  </li>
  <li><a href="#index_fwd_synopsis">
    <code>"boost/indexed_set/index_fwd.hpp"</code></a> includes
    <ul>
      <li><a href="#tag_synopsis"><code>"boost/indexed_set/tag.hpp"</code></a> and</li>
      <li><a href="#identity_synopsis"><code>"boost/indexed_set/identity.hpp"</code></a>,</li>
    </ul>
  </li>
  <li><a href="#index_synopsis"><code>"boost/indexed_set/index.hpp"</code></a> includes
    <ul>
      <li><a href="#tag_synopsis"><code>"boost/indexed_set/tag.hpp"</code></a> and</li>
      <li><a href="#identity_synopsis"><code>"boost/indexed_set/identity.hpp"</code></a>.</li>
    </ul>
  </li>
</ul>
So, <a href="#indexed_set_synopsis"><code>"boost/indexed_set.hpp"</code></a>
brings in every part of Boost.IndexedSet.
</p>

<p>
Boost.IndexedSet is a header-only library, requiring no linking with additional
object modules.
</p>

<h2>
<a name="indexed_set_fwd_synopsis">Header
<a href="../../../boost/indexed_set_fwd.hpp"><code>"boost/indexed_set_fwd.hpp"</code></a>
synopsis</a>
</h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>=</span><span class=identifier>index_list</span><span class=special>&lt;</span><span class=identifier>unique</span><span class=special>&lt;</span><span class=identifier>identity</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>&gt;</span> <span class=special>&gt;</span> <span class=special>&gt;,</span>
  <span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>=</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>allocator</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>&gt;</span> <span class=special>&gt;</span>
<span class=keyword>class</span> <span class=identifier>indexed_set</span><span class=special>;</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=keyword>using</span> <span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>indexed_set</span><span class=special>;</span>

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<p>
<code>indexed_set_fwd.hpp</code> forward declares the class template
<a href="#indexed_set"><code>indexed_set</code></a> and specifies its default parameters.
</p>

<h2>
<a name="indexed_set_synopsis">Header
<a href="../../../boost/indexed_set.hpp"><code>"boost/indexed_set.hpp"</code></a>
synopsis</a>
</h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span> <span class=keyword>class</span> <span class=identifier>indexed_set</span><span class=special>;</span>

<span class=comment>// indexed_set associated global class templates:</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>nth_index_type</span><span class=special>;</span>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>index_type</span><span class=special>;</span>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>nth_iterator_type</span><span class=special>;</span>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>nth_const_iterator_type</span><span class=special>;</span>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>iterator_type</span><span class=special>;</span>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>const_iterator_type</span><span class=special>;</span>

<span class=comment>// indexed_set global functions for index retrieval:</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
  <span class=keyword>typename</span> <span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span>
  <span class=identifier>get</span><span class=special>(</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>);</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
  <span class=keyword>const</span> <span class=keyword>typename</span> <span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span>
  <span class=identifier>get</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>);</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
  <span class=keyword>typename</span> <span class=identifier>index_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span>
  <span class=identifier>get</span><span class=special>(</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>);</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
  <span class=keyword>const</span> <span class=keyword>typename</span> <span class=identifier>index_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span>
  <span class=identifier>get</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>);</span>

<span class=comment>// indexed_set global functions for projection of iterators:</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
<span class=keyword>typename</span> <span class=identifier>nth_iterator_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span>
  <span class=identifier>project</span><span class=special>(</span>
    <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>,</span>
    <span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>);</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
<span class=keyword>typename</span> <span class=identifier>nth_const_iterator_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span>
  <span class=identifier>project</span><span class=special>(</span>
    <span class=keyword>const</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>,</span>
    <span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>);</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
<span class=keyword>typename</span> <span class=identifier>iterator_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span>
  <span class=identifier>project</span><span class=special>(</span>
    <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>,</span>
    <span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>);</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
<span class=keyword>typename</span> <span class=identifier>const_iterator_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span>
  <span class=identifier>project</span><span class=special>(</span>
    <span class=keyword>const</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>,</span>
    <span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>);</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=keyword>using</span> <span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>indexed_set</span><span class=special>;</span>
<span class=keyword>using</span> <span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>get</span><span class=special>;</span>
<span class=keyword>using</span> <span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>project</span><span class=special>;</span>

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="indexed_set">
Template class <code>indexed_set</code>
</a></h3>

<p>
This is the main component of Boost.IndexedSet. An <code>indexed_set</code>
is a container template class holding a compile-time user-defined list of
<a href="#indices">indices</a>. These indices provide different interfaces
for the management of the elements of the <code>indexed_set</code>. By itself,
<code>indexed_set</code> only provides basic functionality for construction
and for access to the indices held.
</p>

<p>
An <code>indexed_set</code> type is instantiated with the type of the
elements contained and an <a href="#index_list"><code>index_list</code></a>
specifying which indices conform the class.
</p>

<p>
For convenience of use, all public methods and types of the first index
specified are inherited by <code>indexed_set</code>. This also includes global
operators and functions associated with the index (vg. comparison and
<code>swap</code>.)
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>=</span><span class=identifier>index_list</span><span class=special>&lt;</span><span class=identifier>unique</span><span class=special>&lt;</span><span class=identifier>identity</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>&gt;</span> <span class=special>&gt;</span> <span class=special>&gt;,</span>
  <span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>=</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>allocator</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>&gt;</span> <span class=special>&gt;</span>
<span class=keyword>class</span> <span class=identifier>indexed_set</span>
<span class=special>{</span>
<span class=keyword>public</span><span class=special>:</span>

  <span class=comment>// types:</span>

  <span class=keyword>typedef</span> <b>implementation defined</b>   <span class=identifier>ctor_args_list</span><span class=special>;</span>
  <span class=keyword>typedef</span> <b>implementation defined</b>   <span class=identifier>index_type_list</span><span class=special>;</span>
  <span class=keyword>typedef</span> <b>implementation defined</b>   <span class=identifier>iterator_type_list</span><span class=special>;</span>
  <span class=keyword>typedef</span> <b>implementation defined</b>   <span class=identifier>const_iterator_type_list</span><span class=special>;</span>
  <span class=keyword>typedef</span> <span class=identifier>Allocator</span>                <span class=identifier>allocator_type</span><span class=special>;</span>

  <span class=comment>// nested class templates:</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>nth_index_type</span>             <span class=special>{</span><span class=keyword>typedef</span> <b>implementation defined</b> <span class=identifier>type</span><span class=special>;};</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>index_type</span>          <span class=special>{</span><span class=keyword>typedef</span> <b>implementation defined</b> <span class=identifier>type</span><span class=special>;};</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>nth_iterator_type</span>          <span class=special>{</span><span class=keyword>typedef</span> <b>implementation defined</b> <span class=identifier>type</span><span class=special>;};</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>nth_const_iterator_type</span>    <span class=special>{</span><span class=keyword>typedef</span> <b>implementation defined</b> <span class=identifier>type</span><span class=special>;};</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>iterator_type</span>       <span class=special>{</span><span class=keyword>typedef</span> <b>implementation defined</b> <span class=identifier>type</span><span class=special>;};</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>const_iterator_type</span> <span class=special>{</span><span class=keyword>typedef</span> <b>implementation defined</b> <span class=identifier>type</span><span class=special>;};</span>

  <span class=comment>// construct/copy/destroy:</span>

  <span class=keyword>explicit</span> <span class=identifier>indexed_set</span><span class=special>(
    </span><span class=keyword>const</span> <span class=identifier>ctor_args_list</span><span class=special>&amp;</span> <span class=identifier>args_list</span><span class=special>=</span><span class=identifier>ctor_args_list</span><span class=special>(),
    </span><span class=keyword>const</span> <span class=identifier>allocator_type</span><span class=special>&amp;</span> <span class=identifier>al</span><span class=special>=</span><span class=identifier>allocator_type</span><span class=special>());</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>InputIterator</span><span class=special>&gt;</span>
    <span class=identifier>indexed_set</span><span class=special>(</span>
      <span class=identifier>InputIterator</span> <span class=identifier>first</span><span class=special>,</span><span class=identifier>InputIterator</span> <span class=identifier>last</span><span class=special>,</span>
      <span class=keyword>const</span> <span class=identifier>ctor_args_list</span><span class=special>&amp;</span> <span class=identifier>args_list</span><span class=special>=</span><span class=identifier>ctor_args_list</span><span class=special>(),
      </span><span class=keyword>const</span> <span class=identifier>allocator_type</span><span class=special>&amp;</span> <span class=identifier>al</span><span class=special>=</span><span class=identifier>allocator_type</span><span class=special>());</span>
  <span class=identifier>indexed_set</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>);</span>

  <span class=special>~</span><span class=identifier>indexed_set</span><span class=special>();</span>

  <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=keyword>operator</span><span class=special>=(</span>
    <span class=keyword>const</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>);</span>

  <span class=identifier>allocator_type</span> <span class=identifier>get_allocator</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>

  <span class=comment>// retrieval of indices</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>typename</span> <span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span> <span class=identifier>get</span><span class=special>();</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>const</span> <span class=keyword>typename</span> <span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span> <span class=identifier>get</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>typename</span> <span class=identifier>index_type</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span> <span class=identifier>get</span><span class=special>()</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>const</span> <span class=keyword>typename</span> <span class=identifier>index_type</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span> <span class=identifier>get</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>

  <span class=comment>// projection of iterators</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>&gt;</span>
    <span class=keyword>typename</span> <span class=identifier>nth_iterator_type</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>project</span><span class=special>(</span><span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>);</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>&gt;</span>
    <span class=keyword>typename</span> <span class=identifier>nth_const_iterator_type</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>project</span><span class=special>(</span><span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>&gt;</span>
    <span class=keyword>typename</span> <span class=identifier>iterator_type</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>project</span><span class=special>(</span><span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>);</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>&gt;</span>
    <span class=keyword>typename</span> <span class=identifier>const_iterator_type</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>project</span><span class=special>(</span><span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>

<span class=comment>// indexed_set associated global class templates:</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>nth_index_type</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>::</span><span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>type</span><span class=special>;</span>
<span class=special>};</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>index_type</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>::</span><span class=identifier>index_type</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>type</span><span class=special>;</span>
<span class=special>};</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>nth_iterator_type</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>::</span><span class=identifier>nth_iterator_type</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>type</span><span class=special>;</span>
<span class=special>};</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>nth_const_iterator_type</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>::</span><span class=identifier>nth_const_iterator_type</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>type</span><span class=special>;</span>
<span class=special>};</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>iterator_type</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>::</span><span class=identifier>iterator_type</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>type</span><span class=special>;</span>
<span class=special>};</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>const_iterator_type</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>IndexedSet</span><span class=special>::</span><span class=identifier>const_iterator_type</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>type</span><span class=special>;</span>
<span class=special>};</span>

<span class=comment>// indexed_set global functions for index retrieval:</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
  <span class=keyword>typename</span> <span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span>
  <span class=identifier>get</span><span class=special>(</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>)</span>
  <span class=special>{</span>
    <span class=keyword>return</span> <span class=identifier>m</span><span class=special>.</span><span class=identifier>get</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;();</span>
  <span class=special>}</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
  <span class=keyword>const</span> <span class=keyword>typename</span> <span class=identifier>nth_index_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span>
  <span class=identifier>get</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>)</span>
  <span class=special>{</span>
    <span class=keyword>return</span> <span class=identifier>m</span><span class=special>.</span><span class=identifier>get</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;();</span>
  <span class=special>}</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
  <span class=keyword>typename</span> <span class=identifier>index_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span>
  <span class=identifier>get</span><span class=special>(</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>)</span>
  <span class=special>{</span>
    <span class=keyword>return</span> <span class=identifier>m</span><span class=special>.</span><span class=identifier>get</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;();</span>
  <span class=special>}</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
  <span class=keyword>const</span> <span class=keyword>typename</span> <span class=identifier>index_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&amp;</span>
  <span class=identifier>get</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>)</span>
  <span class=special>{</span>
    <span class=keyword>return</span> <span class=identifier>m</span><span class=special>.</span><span class=identifier>get</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;();</span>
  <span class=special>}</span>

<span class=comment>// indexed_set global functions for projection of iterators:</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
<span class=keyword>typename</span> <span class=identifier>nth_iterator_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span>
  <span class=identifier>project</span><span class=special>(</span>
    <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>,</span>
    <span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>)</span>
  <span class=special>{</span>
    <span class=keyword>return</span> <span class=identifier>m</span><span class=special>.</span><span class=identifier>project</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;(</span><span class=identifier>it</span><span class=special>);</span>
  <span class=special>}</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>int</span> <span class=identifier>N</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
<span class=keyword>typename</span> <span class=identifier>nth_const_iterator_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>N</span><span class=special>&gt;::</span><span class=identifier>type</span>
  <span class=identifier>project</span><span class=special>(</span>
    <span class=keyword>const</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>,</span>
    <span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>)</span>
  <span class=special>{</span>
    <span class=keyword>return</span> <span class=identifier>m</span><span class=special>.</span><span class=identifier>project</span><span class=special>&lt;</span><span class=identifier>N</span><span class=special>&gt;(</span><span class=identifier>it</span><span class=special>);</span>
  <span class=special>}</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
<span class=keyword>typename</span> <span class=identifier>iterator_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span>
  <span class=identifier>project</span><span class=special>(</span>
    <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>,</span>
    <span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>)</span>
  <span class=special>{</span>
    <span class=keyword>return</span> <span class=identifier>m</span><span class=special>.</span><span class=identifier>project</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;(</span><span class=identifier>it</span><span class=special>);</span>
  <span class=special>}</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Tag</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IteratorType</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Value</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>&gt;</span>
<span class=keyword>typename</span> <span class=identifier>const_iterator_type</span><span class=special>&lt;</span><span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;,</span><span class=identifier>Tag</span><span class=special>&gt;::</span><span class=identifier>type</span>
  <span class=identifier>project</span><span class=special>(</span>
    <span class=keyword>const</span> <span class=identifier>indexed_set</span><span class=special>&lt;</span><span class=identifier>Value</span><span class=special>,</span><span class=identifier>IndexSpecifierList</span><span class=special>,</span><span class=identifier>Allocator</span><span class=special>&gt;&amp;</span> <span class=identifier>m</span><span class=special>,</span>
    <span class=identifier>IteratorType</span> <span class=identifier>it</span><span class=special>)</span>
  <span class=special>{</span>
    <span class=keyword>return</span> <span class=identifier>m</span><span class=special>.</span><span class=identifier>project</span><span class=special>&lt;</span><span class=identifier>Tag</span><span class=special>&gt;(</span><span class=identifier>it</span><span class=special>);</span>
  <span class=special>}</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h4><a name="indexed_set_notation">Notation</a></h4>

<p>
In the description of the operations of <code>indexed_set</code>, we
adopt the following notation:
<ul>
  <li><code>I</code> is the number of indices held by the
    <code>indexed_set</code>,
  <li><code>n</code> is the number of its elements.
</ul>
</p>

<h4><a name="indexed_set_instantiation_types"><code>indexed_set</code>
instantiation types</a></h4>

<p>
<code>indexed_set</code> is instantiated with the following types:
<ol>
  <li><code>Value</code> is the
    <a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>
    type of the elements contained.</li>
  <li><code>IndexSpecifierList</code> specifies the indices that the
    <code>indexed_set</code> is composed of. It must be an instantiation
    of <a href="#index_list"><code>index_list</code></a>.</li>
  <li><code>Allocator</code> must comply with the C++ requirements for
    allocators <b>[lib.allocator.requirements]</b>.
</ol>
</p>

<h4><a name="indexed_set_types"><code>indexed_set</code>
types</a></h4>

<code>ctor_args_list</code>

<blockquote>
Although the exact definition of <code>ctor_args_list</code> is
implementation defined, from the user point of view this type can be
treated as equivalent to
<code>::boost::tuple&lt;C<sub>0</sub>,...,C<sub>I-1</sub>></code>,
where <code>C<sub>i</sub></code> is the <code>ctor_args</code> type of the
<code>i</code>-th index held by the <code>indexed_set</code>, in the
same order as they were specified. Strictly speaking, there is an
implicit conversion from
<code>const ::boost::tuple&lt;C<sub>0</sub>,...,C<sub>I-1</sub>>&</code>
to <code>const ctor_args_list&</code>. This type is used for
providing the construction arguments of the indices of the
<code>indexed_set</code>. <code>ctor_args_list</code> is 
<a href="http://www.sgi.com/tech/stl/DefaultConstructible.html"><code>Default 
Constructible</code></a>, provided that all <code>ctor_args</code> types
involved are default constructible.
</blockquote>

<code>index_type_list</code>

<blockquote>
<a href="../../../libs/mpl/doc/ref/Forward_Sequence.html">
<code>MPL Forward Sequence</code></a> containing the types of the indices held by
the <code>indexed_set</code>, in the same order as they were specified.
</blockquote>

<code>iterator_type_list</code>

<blockquote>
<a href="../../../libs/mpl/doc/ref/Forward_Sequence.html">
<code>MPL Forward Sequence</code></a> containing the types of the iterators of
the indices held by the <code>indexed_set</code>, in the same order as they were
specified.
</blockquote>

<code>const_iterator_type_list</code>

<blockquote>
<a href="../../../libs/mpl/doc/ref/Forward_Sequence.html">
<code>MPL Forward Sequence</code></a> containing the types of the constant
iterators of the indices held by the <code>indexed_set</code>, in the same order
as they were specified.
</blockquote>

<h4><a name="indexed_set_nested_templates"><code>indexed_set</code>
nested class templates</a></h4>

<code>template&lt;int N> struct nth_index_type</code>

<blockquote>
<code>nth_index_type&lt;N>::type</code> yields the type of the
<code>N</code>-th (0-based) index held by the <code>indexed_set</code>, in
the same order as they were specified.<br>
<b>Requires:</b> <code>0 &lt;= N &lt; I</code>.
</blockquote>

<code>template&lt;typename Tag> struct index_type</code>

<blockquote>
<code>index_type&lt;Tag>::type</code> yields the type of the index which
has <code>Tag</code> as an associated <a href="#tags">tag type</a>. If more
than one index exist meeting this condition, the first one is selected (with
respect to the order in which they were specified.)</br>
<b>Requires:</b> Some index of the <code>indexed_set</code> has <code>Tag</code>
as an associated tag type.
</blockquote>

<code>template&lt;int N> struct nth_iterator_type</code>

<blockquote>
<code>nth_iterator_type&lt;N>::type</code> is equivalent to
<code>nth_index_type&lt;N>::type::iterator</code>.<br>
</blockquote>

<code>template&lt;int N> struct nth_const_iterator_type</code>

<blockquote>
<code>nth_const_iterator_type&lt;N>::type</code> is equivalent to
<code>nth_index_type&lt;N>::type::const_iterator</code>.<br>
</blockquote>

<code>template&lt;typename Tag> struct iterator_type</code>

<blockquote>
<code>iterator_type&lt;Tag>::type</code> is equivalent to
<code>index_type&lt;Tag>::type::iterator</code>.<br>
</blockquote>

<code>template&lt;typename Tag> struct const_iterator_type</code>

<blockquote>
<code>const_iterator_type&lt;Tag>::type</code> is equivalent to
<code>index_type&lt;Tag>::type::const_iterator</code>.<br>
</blockquote>

<h4><a name="indexed_set_constructors"><code>indexed_set</code>
constructors, copy and assignment</a></h4>

<code>explicit indexed_set(<br>
&nbsp;&nbsp;const ctor_args_list& comp=ctor_args_list(),const allocator_type& al=allocator_type());</code>

<blockquote>
<b>Effects:</b> Constructs an empty <code>indexed_set</code> using the
specified argument list and allocator.<br>
<b>Complexity:</b> <code>O(I)</code>.
</blockquote>

<code>template&lt;typename InputIterator><br>
&nbsp;&nbsp;indexed_set(<br>
&nbsp;&nbsp;&nbsp;&nbsp;InputIterator first,InputIterator last,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const ctor_args_list& comp=ctor_args_list(),const allocator_type& al=allocator_type());</code>

<blockquote>
<b>Requires:</b> <code>InputIterator</code> is a model of
<a href="http://www.sgi.com/tech/stl/InputIterator.html">
<code>Input Iterator</code></a> over elements of type
<code>Value</code> or a type convertible to <code>Value</code>.
<code>last</code> is reachable from <code>first</code>.</br> 
<b>Effects:</b> Constructs and empty <code>indexed_set</code> using the
specified argument list and allocator and fills it with
the elements in the range [<code>first</code>,<code>last</code>).
Insertion of each element may or may not succeed depending
on the acceptance by all the indices of the <code>indexed_set</code>.<br>
<b>Complexity:</b> <code>O(I*log(n) + D*M + D*(I-M)*log(n+D))</code>, where
<code>D</code> is the distance from <code>first</code> to <code>last</code> and
<code>M</code> is the number of indices for which [<code>first</code>,
<code>last</code>) is ordered (with respect to the corresponding
<code>key_compare</code>.)<br>
</blockquote>

<code>indexed_set(const indexed_set&lt;Value,IndexSpecifierList,Allocator>& x);</code>

<blockquote>
<b>Effects:</b> Constructs a copy of <code>x</code>, copying its
elements as well as its internal objects (key extractors, comparison objects,
allocator.)<br>
<b>Postconditions:</b> <code>*this==x</code>.<br>
<b>Complexity:</b> <code>O(I*n)</code>.
</blockquote>

<code>~indexed_set()</code>
<blockquote>
<b>Effects:</b> Destroys the <code>indexed_set</code> and all the elements
contained. The order in which the elements are destroyed is not specified.<br>
<b>Complexity:</b> <code>O(I*n)</code>.
</blockquote>

<code>indexed_set&lt;Value,IndexSpecifierList,Allocator>& operator=(<br>
&nbsp;&nbsp;const indexed_set&lt;Value,IndexSpecifierList,Allocator>& x);</code>

<blockquote>
Replaces the elements and comparison objects of the <code>indexed_set</code>
with copies from <code>x</code>.<br>
<b>Postconditions:</b> <code>*this==x</code>.<br>
<b>Returns:</b> <code>*this</code>.<br>
<b>Complexity:</b> <code>O(I*(n+m))</code>, where <code>m</code> is the
number of elements of <code>x</code>.<br>
<b>Exception safety:</b> Strong, provided the copy and assignment operations
of the types of <code>ctor_args_list</code> do not throw.
</blockquote>

<code>allocator_type get_allocator()const;</code>

<blockquote>
Returns a copy of the <code>allocator_type</code> object used to construct
the <code>indexed_set</code>.<br>
<b>Complexity:</b> Constant.
</blockquote>

<h4><a name="indexed_set_index_retrieval"><code>indexed_set</code>
index retrieval operations</a></h4>

<code>template&lt;int N> typename nth_index_type&lt;N>::type& get();</code>

<blockquote>
<b>Requires:</b> <code>0 &lt;= N &lt; I</code>.<br>
<b>Effects:</b> Returns a reference to the
<code>nth_index_type&lt;N>::type</code> index held by <code>*this</code>.<br>
<b>Complexity:</b> Constant.<br>
<b>Exception safety:</b> <code>nothrow</code>.
</blockquote>

<code>template&lt;int N> const typename nth_index_type&lt;N>::type& get()const;</code>

<blockquote>
<b>Requires:</b> <code>0 &lt;= N &lt; I</code>.<br>
<b>Effects:</b> Returns a <code>const</code> reference to the
<code>nth_index_type&lt;N>::type</code> index held by <code>*this</code>.<br>
<b>Complexity:</b> Constant.<br>
<b>Exception safety:</b> <code>nothrow</code>.
</blockquote>

<code>template&lt;typename Tag> typename index_type&lt;Tag>::type& get()</code>

<blockquote>
<b>Requires:</b> <code>Tag</code> is such that <code>index_type&lt;Tag>::type</code>
is valid.<br>
<b>Effects:</b> Returns a reference to the
<code>index_type&lt;Tag>::type</code> index held by
<code>*this</code>.<br>
<b>Complexity:</b> Constant.<br>
<b>Exception safety:</b> <code>nothrow</code>.
</blockquote>

<code>template&lt;typename Tag> const typename index_type&lt;Tag>::type& get()const;</code>

<blockquote>
<b>Requires:</b> <code>Tag</code> is such that <code>index_type&lt;Tag>::type</code>
is valid.<br>
<b>Effects:</b> Returns a <code>const</code> reference to the 
<code>index_type&lt;Tag>::type</code> index held by
<code>*this</code>.<br>
<b>Complexity:</b> Constant.<br>
<b>Exception safety:</b> <code>nothrow</code>.
</blockquote>

<h4><a name="indexed_set_projection"><code>indexed_set</code>
projection operations</a></h4>

<p>
Given an <code>indexed_set</code> with indices <code>i1</code>
and <code>i2</code>, we say than an <code>i1</code>-iterator
<code>it1</code> and an <code>i2</code>-iterator <code>it2</code>
are <i>equivalent</i> if:
<ul>
  <li> <code>it1==i1.end()</code> AND <code>it2==i2.end()</code>,</li>
  <li> OR <code>it1</code> and <code>it2</code> point to the
    same element.</li>
</ul>
</p>

<code>template&lt;int N,typename IteratorType><br>
&nbsp;&nbsp;typename nth_iterator_type&lt;N>::type project(IteratorType it);</code>

<blockquote>
<b>Requires:</b> <code>0 &lt;= N &lt; I</code>. <code>IteratorType</code>
belongs to <code>iterator_type_list</code>. <code>it</code> is a valid
iterator of some index of <code>*this</code> (i.e. does not refer to some
other <code>indexed_set</code>.)<br>
<b>Effects:</b> Returns an <code>nth_iterator_type&ltN>::type</code> iterator
equivalent to <code>it</code>.<br>
<b>Complexity:</b> Constant.<br>
<b>Exception safety:</b> <code>nothrow</code>.
</blockquote>

<code>template&lt;int N,typename IteratorType><br>
&nbsp;&nbsp;typename nth_const_iterator_type&lt;N>::type project(IteratorType it)const;</code>

<blockquote>
<b>Requires:</b> <code>0 &lt;= N &lt; I</code>. <code>IteratorType</code>
belongs to <code>const_iterator_type_list</code> or
<code>iterator_type_list</code>. <code>it</code> is a
valid (constant or non-constant) iterator of some index of <code>*this</code>
(i.e. does not refer to some other <code>indexed_set</code>.)<br>
<b>Effects:</b> Returns an <code>nth_const_iterator_type&ltN>::type</code>
iterator equivalent to <code>it</code>.<br>
<b>Complexity:</b> Constant.<br>
<b>Exception safety:</b> <code>nothrow</code>.
</blockquote>

<code>template&lt;typename Tag,typename IteratorType><br>
&nbsp;&nbsp;typename iterator_type&lt;Tag>::type project(IteratorType it);</code>

<blockquote>
<b>Requires:</b> <code>Tag</code> is such that
<code>iterator_type&lt;Tag>::type</code> is valid. <code>IteratorType</code>
belongs to <code>iterator_type_list</code>. <code>it</code> is a valid
iterator of some index of <code>*this</code> (i.e. does not refer to some
other <code>indexed_set</code>.)<br>
<b>Effects:</b> Returns an <code>iterator_type&lt;Tag>::type</code> iterator
equivalent to <code>it</code>.<br>
<b>Complexity:</b> Constant.<br>
<b>Exception safety:</b> <code>nothrow</code>.
</blockquote>

<code>template&lt;typename Tag,typename IteratorType><br>
&nbsp;&nbsp;typename const_iterator_type&lt;Tag>::type project(IteratorType it)const;</code>

<blockquote>
<b>Requires:</b> <code>Tag</code> is such that
<code>const_iterator_type&lt;Tag>::type</code> is valid. <code>IteratorType</code>
belongs to <code>const_iterator_type_list</code> or
<code>iterator_type_list</code>. <code>it</code> is a valid
(constant or non-constant) iterator of some index of <code>*this</code>
(i.e. does not refer to some other <code>indexed_set</code>.)<br>
<b>Effects:</b> Returns an <code>const_iterator_type&lt;Tag>::type</code>
iterator equivalent to <code>it</code>.<br>
<b>Complexity:</b> Constant.<br>
<b>Exception safety:</b> <code>nothrow</code>.
</blockquote>

<h2>
<a name="index_fwd_synopsis">Header
<a href="../../../boost/indexed_set/index_fwd.hpp"><code>"boost/indexed_set/index_fwd.hpp"</code></a>
synopsis</a>
</h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=comment>// index specifiers unique and non_unique</span>

<span class=keyword>template</span><span class=special>&lt;</span><b>consult unique reference for arguments</b><span class=special>&gt;</span>     <span class=keyword>struct</span> <span class=identifier>unique</span><span class=special>;</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>consult non_unique reference for arguments</b><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>non_unique</span><span class=special>;</span>

<span class=comment>// indices</span>

<span class=keyword>namespace</span> <span class=identifier>detail</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>class</span> <b>index name is implementation defined</b><span class=special>;</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets::detail</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<p>
<code>index_fwd.hpp</code> provides forward declarations for index specifiers 
<a href="#unique_non_unique"><code>unique</code> and <code>non_unique</code></a> and
their associated <a href="#indices">regular indices</a> classes.
</p>

<h2>
<a name="index_synopsis">Header
<a href="../../../boost/indexed_set/index.hpp"><code>"boost/indexed_set/index.hpp"</code></a>
synopsis</a>
</h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=comment>// index specifiers unique and non_unique</span>

<span class=keyword>template</span><span class=special>&lt;</span><b>consult unique reference for arguments</b><span class=special>&gt;</span>     <span class=keyword>struct</span> <span class=identifier>unique</span><span class=special>;</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>consult non_unique reference for arguments</b><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>non_unique</span><span class=special>;</span>

<span class=comment>// indices</span>

<span class=keyword>namespace</span> <span class=identifier>detail</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>class</span> <span class=identifier>index</span> <span class=identifier>name</span> <span class=identifier>is</span> <b>implementation defined</b><span class=special>;</span>

<span class=comment>// index comparison:</span>

<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>==(</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>y</span><span class=special>);</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>&lt;(</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>y</span><span class=special>);</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>!=(</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>y</span><span class=special>);</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>&gt;(</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>y</span><span class=special>);</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>&gt;=(</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>y</span><span class=special>);</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>&lt;=(</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>y</span><span class=special>);</span>

<span class=comment>// index specialized algorithms:</span>

<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>void</span> <span class=identifier>swap</span><span class=special>(</span><span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=identifier>index</span> <span class=keyword>class</span> <span class=identifier>name</span><span class=special>&amp;</span> <span class=identifier>y</span><span class=special>);</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets::detail</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="unique_non_unique">
Index specifiers <code>unique</code> and <code>non_unique</code>
</a></h3>

<p>
These <a href="#index_specification">index specifiers</a> allow for insertion of
<a href="#indices">regular indices</a> without and with allowance of duplicate
elements, respectively. The syntax of <code>unique</code> and
<code>non_unique</code> coincide, thus we describe them in a grouped manner.
[<code>non_</code>]<code>unique</code> can be instantiated in two different
forms, according to whether a tag list for the index is provided or not:
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>KeyFromValue</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Compare</span><span class=special>=</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>less</span><span class=special>&lt;</span><span class=identifier>KeyFromValue</span><span class=special>::</span><span class=identifier>result_type</span><span class=special>&gt;</span>
  <span class=keyword>struct</span> [<span class=identifier>non_</span>]<span class=identifier>unique</span><span class=special>;</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>TagList</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>KeyFromValue</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Compare</span><span class=special>=</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>less</span><span class=special>&lt;</span><span class=identifier>KeyFromValue</span><span class=special>::</span><span class=identifier>result_type</span><span class=special>&gt;</span> <span class=special>&gt;</span>
  <span class=keyword>struct</span> [<span class=identifier>non_</span>]<span class=identifier>unique</span><span class=special>;</span>
</pre></blockquote>

<p>
If provided, <code>TagList</code> must be an instantiation of the class template
<a href="#tag"><code>tag</code></a>.
The template arguments are used by the corresponding index implementation,
refer to the <a href="#indices">regular indices</a> reference section for further
explanations on their acceptable type values.
</p>

<h3><a name="indices">Indices</a></h3>

<p>
Although <code>indexed_set</code> is planned for future inclusion of
several types of index implementations, currently Boost.IndexedSet only
supports so-called regular indices which mimic the functionality of
<code>std::set</code> and <code>std::multiset</code>, so our discussion
will be strictly focused on these.
</p>

<p>
An index provides a set-like interface to the underlying heap of
elements contained in an <code>indexed_set</code>. An index is
particularized according to a key, a given
<a href="#key_extractors"><code>Key Extractor</code></a> that retrieves
keys from elements of <code>indexed_set</code> and a comparison
predicate.
</p>

<p>
Indices cannot be constructed as isolated objects. They are always
embedded into an <code>indexed_set</code> as specified by the template
class <a href="#index_list"><code>index_list</code></a>.
</p>

<p>
Insertions in a given index affect all other indices of the
<code>indexed_set</code> as well. This has implications on whether an
insertion is successful (it can fail due to collisions in other index) as
well as on the complexity of the operation, which naturally depends
on the number of indices an <code>indexed_set</code> is composed of.
Similarly, the complexity of deletion operations is proportional to
the number of indices of the <code>indexed_set</code>.
</p>

<p>
There are two variants of regular indices: <i>unique</i>, which do
not allow duplicate elements (with respect to its associated comparison
predicate) and <i>non-unique</i>, which accept those duplicates.
The interface of these two variants is the same, so they are documented
together, with minor differences explicitly stated when they exist.
</p>

<p>
Except where noted, indices (both unique and non-unique) are models of
<a href="http://www.sgi.com/tech/stl/SortedAssociativeContainer.html">
<code>Sorted Associative Container</code></a> and
<a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">
<code>Unique Associative Container</code></a>, much as <code>std::set</code>s
are. Accordingly, validity of iterators and references to elements is
preserved. We only provide descriptions of those types and operations that are
either not present in the concepts modelled or do not exactly conform to the
requirements for these types of containers.
</p>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>namespace</span><span class=special>{</span> <b>implementation defined </b><span class=identifier>unbounded</span><span class=special>;</span> <span class=special>}</span> <span class=comment>// see range()</span>

<span class=keyword>namespace</span> <span class=identifier>detail</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined: dependent on types Value, Allocator,
  TagList, KeyFromValue, Compare</b><span class=special>&gt;</span>
<span class=keyword>class</span> <b>name is implementation defined</b>
<span class=special>{</span> 
<span class=keyword>public</span><span class=special>:</span>
  <span class=comment>// types:</span>

  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>KeyFromValue</span><span class=special>::</span><span class=identifier>result_type</span>         <span class=identifier>key_type</span><span class=special>;</span>
  <span class=keyword>typedef</span> <span class=identifier>Value</span>                                      <span class=identifier>value_type</span><span class=special>;</span>
  <span class=keyword>typedef</span> <span class=identifier>KeyFromValue</span>                               <span class=identifier>key_from_value</span><span class=special>;</span>
  <span class=keyword>typedef</span> <span class=identifier>Compare</span>                                    <span class=identifier>key_compare</span><span class=special>;</span>
  <span class=keyword>typedef</span> <b>implementation defined                     </b><span class=identifier>value_compare</span><span class=special>;</span>
  <span class=keyword>typedef</span> <span class=identifier>tuple</span><span class=special>&lt;</span><span class=identifier>key_from_value</span><span class=special>,</span><span class=identifier>key_compare</span><span class=special>&gt;</span>          <span class=identifier>ctor_args</span><span class=special>;</span>
  <span class=keyword>typedef</span> <span class=identifier>Allocator</span>                                  <span class=identifier>allocator_type</span><span class=special>;</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>::</span><span class=identifier>reference</span>              <span class=identifier>reference</span><span class=special>;</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>::</span><span class=identifier>const_reference</span>        <span class=identifier>const_reference</span><span class=special>;</span>
  <span class=keyword>typedef</span> <b>implementation defined                     </b><span class=identifier>iterator</span><span class=special>;</span>
  <span class=keyword>typedef</span> <b>implementation defined                     </b><span class=identifier>const_iterator</span><span class=special>;</span>
  <span class=keyword>typedef</span> <b>implementation defined                     </b><span class=identifier>size_type</span><span class=special>;</span>      
  <span class=keyword>typedef</span> <b>implementation defined                     </b><span class=identifier>difference_type</span><span class=special>;</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>::</span><span class=identifier>pointer</span>                <span class=identifier>pointer</span><span class=special>;</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>Allocator</span><span class=special>::</span><span class=identifier>const_pointer</span>          <span class=identifier>const_pointer</span><span class=special>;</span>
  <span class=keyword>typedef</span> <b>equivalent to
    std::reverse_iterator&lt;iterator&gt;</b></span>                  <span class=identifier>reverse_iterator</span><span class=special>;</span>
  <span class=keyword>typedef</span> <b>equivalent to
    std::reverse_iterator&lt;const_iterator&gt;</b></span>            <span class=identifier>const_reverse_iterator</span><span class=special>;</span>

  <span class=comment>// construct/copy/destroy:</span>

  <b>index class name</b>&amp;</span> <span class=keyword>operator</span><span class=special>=(</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>x</span><span class=special>);</span>

  <span class=identifier>allocator_type</span> <span class=identifier>get_allocator</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>

  <span class=comment>// iterators:</span>

  <span class=identifier>iterator</span>               <span class=identifier>begin</span><span class=special>();</span>
  <span class=identifier>const_iterator</span>         <span class=identifier>begin</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>iterator</span>               <span class=identifier>end</span><span class=special>();</span>
  <span class=identifier>const_iterator</span>         <span class=identifier>end</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>reverse_iterator</span>       <span class=identifier>rbegin</span><span class=special>();</span>
  <span class=identifier>const_reverse_iterator</span> <span class=identifier>rbegin</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>reverse_iterator</span>       <span class=identifier>rend</span><span class=special>();</span>
  <span class=identifier>const_reverse_iterator</span> <span class=identifier>rend</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
 
  <span class=comment>// capacity:</span>

  <span class=keyword>bool</span>      <span class=identifier>empty</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>size_type</span> <span class=identifier>size</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>size_type</span> <span class=identifier>max_size</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>

  <span class=comment>// modifiers:</span>

  <span class=identifier>std</span><span class=special>::</span><span class=identifier>pair</span><span class=special>&lt;</span><span class=identifier>iterator</span><span class=special>,</span><span class=keyword>bool</span><span class=special>&gt;</span> <span class=identifier>insert</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>value_type</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>);</span>
  <span class=identifier>iterator</span> <span class=identifier>insert</span><span class=special>(</span><span class=identifier>iterator</span> <span class=identifier>position</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>value_type</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>);</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>InputIterator</span><span class=special>&gt;</span> <span class=keyword>void</span> <span class=identifier>insert</span><span class=special>(</span><span class=identifier>InputIterator</span> <span class=identifier>first</span><span class=special>,</span><span class=identifier>InputIterator</span> <span class=identifier>last</span><span class=special>);</span>

  <span class=keyword>void</span> <span class=identifier>erase</span><span class=special>(</span><span class=identifier>iterator</span> <span class=identifier>position</span><span class=special>);</span>
  <span class=identifier>size_type</span> <span class=identifier>erase</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>key_type</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>);</span>
  <span class=keyword>void</span> <span class=identifier>erase</span><span class=special>(</span><span class=identifier>iterator</span> <span class=identifier>first</span><span class=special>,</span><span class=identifier>iterator</span> <span class=identifier>last</span><span class=special>);</span>

  <span class=keyword>bool</span> <span class=identifier>update</span><span class=special>(</span><span class=identifier>iterator</span> <span class=identifier>position</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>value_type</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>);</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Modifier</span><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=identifier>modify</span><span class=special>(</span><span class=identifier>iterator</span> <span class=identifier>position</span><span class=special>,</span><span class=identifier>Modifier</span> <span class=identifier>mod</span><span class=special>);</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Modifier</span><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=identifier>modify_key</span><span class=special>(</span><span class=identifier>iterator</span> <span class=identifier>position</span><span class=special>,</span><span class=identifier>Modifier</span> <span class=identifier>mod</span><span class=special>);</span>
  
  <span class=keyword>void</span> <span class=identifier>swap</span><span class=special>(</span><b>index class name</b>&amp;</span> <span class=identifier>x</span><span class=special>);</span>
  <span class=keyword>void</span> <span class=identifier>clear</span><span class=special>();</span>

  <span class=comment>// observers:</span>

  <span class=identifier>key_from_value</span> <span class=identifier>key_extractor</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>key_compare</span>    <span class=identifier>key_comp</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>value_compare</span>  <span class=identifier>value_comp</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>

  <span class=comment>// set operations:</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>CompatibleKey</span><span class=special>&gt;</span>
    <span class=identifier>const_iterator</span> <span class=identifier>find</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>CompatibleKey</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>CompatibleKey</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>CompatibleCompare</span><span class=special>&gt;</span>
    <span class=identifier>const_iterator</span> <span class=identifier>find</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>CompatibleKey</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>CompatibleCompare</span><span class=special>&amp;</span> <span class=identifier>comp</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>CompatibleKey</span><span class=special>&gt;</span>
    <span class=identifier>size_type</span> <span class=identifier>count</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>CompatibleKey</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>CompatibleKey</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>CompatibleCompare</span><span class=special>&gt;</span>
    <span class=identifier>size_type</span> <span class=identifier>count</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>CompatibleKey</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>CompatibleCompare</span><span class=special>&amp;</span> <span class=identifier>comp</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>CompatibleKey</span><span class=special>&gt;</span>
    <span class=identifier>const_iterator</span> <span class=identifier>lower_bound</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>CompatibleKey</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>CompatibleKey</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>CompatibleCompare</span><span class=special>&gt;</span>
    <span class=identifier>const_iterator</span> <span class=identifier>lower_bound</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>CompatibleKey</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>CompatibleCompare</span><span class=special>&amp;</span> <span class=identifier>comp</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>CompatibleKey</span><span class=special>&gt;</span>
    <span class=identifier>const_iterator</span> <span class=identifier>upper_bound</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>CompatibleKey</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>CompatibleKey</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>CompatibleCompare</span><span class=special>&gt;</span>
    <span class=identifier>const_iterator</span> <span class=identifier>upper_bound</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>CompatibleKey</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>CompatibleCompare</span><span class=special>&amp;</span> <span class=identifier>comp</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>CompatibleKey</span><span class=special>&gt;</span>
    <span class=identifier>std</span><span class=special>::</span><span class=identifier>pair</span><span class=special>&lt;</span><span class=identifier>const_iterator</span><span class=special>,</span><span class=identifier>const_iterator</span><span class=special>&gt;</span> <span class=identifier>equal_range</span><span class=special>(</span><span class=keyword>const</span> <span class=identifier>CompatibleKey</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>CompatibleKey</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>CompatibleCompare</span><span class=special>&gt;</span>
    <span class=identifier>std</span><span class=special>::</span><span class=identifier>pair</span><span class=special>&lt;</span><span class=identifier>const_iterator</span><span class=special>,</span><span class=identifier>const_iterator</span><span class=special>&gt;</span> <span class=identifier>equal_range</span><span class=special>(</span>
      <span class=keyword>const</span> <span class=identifier>CompatibleKey</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <span class=identifier>CompatibleCompare</span><span class=special>&amp;</span> <span class=identifier>comp</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>

  <span class=comment>// range:</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>LowerBounder</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>UpperBounder</span><span class=special>&gt;</span>
    <span class=identifier>std</span><span class=special>::</span><span class=identifier>pair</span><span class=special>&lt;</span><span class=identifier>const_iterator</span><span class=special>,</span><span class=identifier>const_iterator</span><span class=special>&gt;</span> <span class=identifier>range</span><span class=special>(</span><span class=identifier>LowerBounder</span> <span class=identifier>lower</span><span class=special>,</span><span class=identifier>UpperBounder</span> <span class=identifier>upper</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>

<span class=comment>// index comparison:</span>

<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>==(</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>y</span><span class=special>);</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>&lt;(</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>y</span><span class=special>);</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>!=(</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>y</span><span class=special>);</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>&gt;(</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>y</span><span class=special>);</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>&gt;=(</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>y</span><span class=special>);</span>
<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>&lt;=(</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>x</span><span class=special>,</span><span class=keyword>const</span> <b>index class name</b>&amp;</span> <span class=identifier>y</span><span class=special>);</span>

<span class=comment>// index specialized algorithms:</span>

<span class=keyword>template</span><span class=special>&lt;</span><b>implementation defined</b><span class=special>&gt;</span> <span class=keyword>void</span> <span class=identifier>swap</span><span class=special>(</span><b>index class name</b>&amp;</span> <span class=identifier>x</span><span class=special>,</span><b>index class name</b>&amp;</span> <span class=identifier>y</span><span class=special>);</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets::detail</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h4><a name="index_notation">Notation</a></h4>

<p>
In the description of the operations of indices, we
adopt the following notation:
<ul>
  <li><code>I</code> is the number of indices held by the
    <code>indexed_set</code> to which the index belongs,
  <li><code>n</code> is the number of its elements.
</ul>
</p>

<h4><a name="index_instantiation_types">Index instantiation types</a></h4>

<p>Indices are instantiated internally to <code>indexed_set</code> and
specified by means of <a href="#index_list"><code>index_list</code></a>
with <a href="#unique_non_unique"> index specifiers <code>unique</code>
and <code>non_unique</code></a>. Instantiations are dependent on the
following types:
<ul>
  <li><code>Value</code> from <code>indexed_set</code>,</li>
  <li><code>Allocator</code> from <code>indexed_set</code>,</li>
  <li><code>Taglist</code> from the index specifier (if provided),</li>
  <li><code>KeyFromValue</code> from the index specifier,</li>
  <li><code>Compare</code> from the index specifier.</li>
</ul>
<code>TagList</code> must be an instantiation of
<a href="#tag"><code>tag</code></a>. The type <code>KeyFromValue</code>,
which determines the mechanism for extracting a key from <code>Value</code>,
must be a model of <a href="#key_extractors"><code>Key Extractor</code></a>
from <code>Value</code>. <code>Compare</code> is a
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">
<code>Strict Weak Ordering</code></a> on elements of
<code>KeyFromValue::result_type</code>.
</p>

<h4><a name="index_constructors">Index constructors, copy and assignment</a></h4>

<p>
Indices cannot be constructed as isolated objects. It is the responsibility
of the enclosing <code>indexed_set</code> to internally construct the
indices as needed. No public constructors are provided. This violates
the requirements for a
<a href="http://www.sgi.com/tech/stl/SortedAssociativeContainer.html">
<code>Sorted Associative Container</code></a> and a 
<a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">
<code>Unique Associative Container</code></a>. Assignment, on the other
hand, is provided.
</p>

<h4><a name="index_modifiers">Index modifiers</a></h4>

<code>std::pair&lt;iterator,bool> insert(const value_type& x);</code>

<blockquote>
<b>Effects:</b> Inserts <code>x</code> into the <code>indexed_set</code> to which
the index belongs if
<ul>
  <li>the index is non-unique OR no other element exists with
    equivalent key,</li>
  <li>AND insertion is allowed by all other indices of the
    <code>indexed_set</code>.</li>
</ul>
<b>Returns:</b> The return value is a pair <code>p</code>. <code>p.second</code>
is <code>true</code> if and only if insertion took place. On successful insertion,
<code>p.first</code> points to the element inserted; otherwise, <code>p.first</code>
points to an element that caused the insertion to be banned. Note that more than
one element can be causing insertion not to be allowed.<br>
<b>Complexity:</b> <code>O(I*log(n))</code>.<br>
<b>Exception safety:</b> Strong.<br>
<b>Note:</b> The semantics of this member function do not conform to
the requirements of a
<a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">
<code>Unique Associative Container</code></a> .
</blockquote>

<code>iterator insert(iterator position,const value_type& x);</code>

<blockquote>
<b>Requires:</b> <code>position</code> is a valid iterator of the index.</br>
<b>Effects:</b> Inserts <code>x</code> into the <code>indexed_set</code> to which
the index belongs if
<ul>
  <li>the index is non-unique OR no other element exists with
    equivalent key,</li>
  <li>AND insertion is allowed by all other indices of the
    <code>indexed_set</code>.</li>
</ul>
<b>Returns:</b> On successful insertion, an iterator to the newly inserted
element. Otherwise, an iterator to an element that caused the insertion to be
banned. Note that more than one element can be causing insertion not to be
allowed.<br>
<b>Complexity:</b> <code>O(M + (I-M)*log(n))</code>, where
<code>M</code> is the number of indices for which insertion takes place right
after the element pointed to by <code>position</code> (with respect to the
corresponding <code>key_compare</code>.)<br>
<b>Exception safety:</b> Strong.<br>
<b>Note:</b> The semantics and complexity of this member function do not conform to
the requirements of a
<a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">
<code>Unique Associative Container</code></a>.
</blockquote>

<code>template&lt;typename InputIterator> void insert(InputIterator first,InputIterator last);</code>

<blockquote>
<b>Requires:</b> <code>InputIterator</code> is a model of
<a href="http://www.sgi.com/tech/stl/InputIterator.html">
<code>Input Iterator</code></a> over elements of type
<code>value_type</code> or a type convertible to <code>value_type</code>.
<code>first</code> and <code>last</code> are not iterators into any
index of the <code>indexed_set</code> to which this index belongs.
<code>last</code> is reachable from <code>first</code>.</br>
<b>Effects:</b>
<blockquote><pre>
<span class=keyword>while</span><span class=special>(</span><span class=identifier>first</span><span class=special>!=</span><span class=identifier>last</span><span class=special>){</span>
  <span class=identifier>insert</span><span class=special>(*</span><span class=identifier>first</span><span class=special>);</span>
  <span class=special>++</span><span class=identifier>first</span><span class=special>;</span>
<span class=special>}</span>
</pre></blockquote>
<b>Complexity:</b> <code>O(I*log(n) + D*M + D*(I-M)*log(n+D))</code>, where
<code>D</code> is the distance from <code>first</code> to <code>last</code> and
<code>M</code> is the number of indices for which [<code>first</code>,
<code>last</code>) is ordered (with respect to the corresponding
<code>key_compare</code>.)<br>
<b>Exception safety:</b> Basic.<br>
<b>Note:</b> The semantics and complexity of this member function do not conform to
the requirements of a
<a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">
<code>Unique Associative Container</code></a>.
</blockquote>

<a name="update"><code>bool update(iterator position,const value_type& x);</code></a>

<blockquote>
<b>Requires:</b> <code>position</code> is a valid dereferenceable  iterator
of the index.</br>
<b>Effects:</b> Assigns the value <code>x</code> to the element pointed
to by <code>position</code> into the <code>indexed_set</code> to which
the index belongs if, for the value <code>x</code>
<ul>
  <li>the index is non-unique OR no other element exists
    (except possibly <code>*position</code>) with equivalent key,</li>
  <li>AND replacing is allowed by all other indices of the
    <code>indexed_set</code>.</li>
</ul>
<b>Postconditions:</b> Validity of <code>position</code> is preserved
in all cases.<br>
<b>Returns:</b> <code>true</code> if the replacement took place,
<code>false</code> otherwise.<br>
<b>Complexity:</b> <code>O(M + (I-M)*log(n))</code>, where
<code>M</code> is the number of indices for which <code>x</code> is equivalent
to <code>*position</code> (with respect to the corresponding
<code>key_compare</code>.)<br>
<b>Exception safety:</b> Strong. If an exception is thrown by some
user-provided operation the <code>indexed_set</code> to which the index
belongs remains in its original state.
</blockquote>
  
<a name="modify">
<code>template&lt;typename Modifier> bool modify(iterator position,Modifier mod);</code></a>

<blockquote>
<b>Requires:</b> <code>Modifier</code> is a model of
<a href="http://www.sgi.com/tech/stl/UnaryFunction.html">
<code>Unary Function</code></a> accepting arguments of type
<code>value_type&</code>. <code>position</code> is a valid dereferenceable
iterator of the index.</br>
<b>Effects:</b> Calls <code>mod(e)</code> where <code>e</code> is the element
pointed to by <code>position</code> and rearranges <code>*position</code> into
all the indices of the <code>indexed_set</code>. Rearrangement is successful if
<ul>
  <li>the index is non-unique OR no other element exists
    with  equivalent key,</li>
  <li>AND rearrangement is allowed by all other indices of the
    <code>indexed_set</code>.</li>
</ul>
If the rearrangement fails, the element is erased.<br>
<b>Postconditions:</b> Validity of <code>position</code> is preserved if the
operation succeeds.<br>
<b>Returns:</b> <code>true</code> if the operation succeeded, <code>false</code>
otherwise.<br>
<b>Complexity:</b> <code>O(M + (I-M)*log(n))</code>, where
<code>M</code> is the number of indices for which <code>*position</code> remains
in its original position.<br>
<b>Exception safety:</b> Basic. If an exception is thrown by some
user-provided operation (except possibly <code>mod</code>), then
the element pointed to by <code>position</code> is erased.
</blockquote>

<a name="modify_key">    
<code>template&lt;typename Modifier> bool modify_key(iterator position,Modifier mod);</code></a>

<blockquote>
<b>Requires:</b> <code>key_from_value</code> is a read/write
<a href="#key_extractors"><code>Key Extractor</code></a> from
<code>value_type</code>. <code>Modifier</code> is a model of
<a href="http://www.sgi.com/tech/stl/UnaryFunction.html">
<code>Unary Function</code></a> accepting arguments of type
<code>key_type&</code>. <code>position</code> is a valid dereferenceable
iterator of the index.</br>
<b>Effects:</b> Calls <code>mod(k)</code> where <code>k</code> is the key
obtained by the internal <code>KeyFromValue</code> object of the index from
the element pointed to by <code>position</code>, and rearranges
<code>*position</code> into all the indices of the <code>indexed_set</code>.
Rearrangement is successful if
<ul>
  <li>the index is non-unique OR no other element exists
    with  equivalent key,</li>
  <li>AND rearrangement is allowed by all other indices of the
    <code>indexed_set</code>.</li>
</ul>
If the rearrangement fails, the element is erased.<br>
<b>Postconditions:</b>Validity of <code>position</code> is preserved if
the operation succeeds.<br>
<b>Returns:</b> <code>true</code> if the operation succeeded, <code>false</code>
otherwise.<br>
<b>Complexity:</b> <code>O(M + (I-M)*log(n))</code>, where
<code>M</code> is the number of indices for which <code>*position</code> remains
in its original position.<br>
<b>Exception safety:</b> Basic. If an exception is thrown by some
user-provided operation (except possibly <code>mod</code>), then
the element pointed to by <code>position</code> is erased.
</blockquote>

<h4><a name="index_observers">Index observers</a></h4>

<p>Apart from standard <code>key_comp</code> and <code>value_comp</code>,
indices have a member function for retrieving the internal key extractor
used.
</p>

<code>key_from_value key_extractor()const;</code>

<blockquote>
Returns a copy of the <code>key_from_value</code> object used to construct
the index.<br>
<b>Complexity:</b> Constant.
</blockquote>

<h4><a name="index_set_operations">Index set operations</a></h4>

<p>
Indices provide the full lookup functionality required by
<a href="http://www.sgi.com/tech/stl/SortedAssociativeContainer.html">
<code>Sorted Associative Containers</code></a> and
<a href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">
<code>Unique Associative Containers</code></a>, namely <code>find</code>,
<code>count</code>, <code>lower_bound</code>, <code>upper_bound</code>
and <code>equal_range</code>. Additionally, these member functions are
templatized to allow for non-standard arguments, so extending
the types of search operations allowed. The kind of arguments permissible
when invoking the lookup member functions is defined by the following
concept.
</p>

<p>
Consider a
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">
<code>Strict Weak Ordering</code></a> <code>Compare</code> over values
of type <code>Key</code>. A pair of types (<code>CompatibleKey</code>, 
<code>CompatibleCompare</code>) is said to be a <i>compatible extension</i>
of <code>Compare</code> if
<ol>
  <li><code>CompatibleCompare</code> is a
    <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
    <code>Binary Predicate</code></a> over (<code>Key</code>,
    <code>CompatibleKey</code>),</li>
  <li><code>CompatibleCompare</code> is a
    <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">
    <code>Binary Predicate</code></a> over (<code>CompatibleKey</code>,
    <code>Key</code>),</li>
  <li>if <code>c_comp(ck,k1)</code> then <code>!c_comp(k1,ck)</code>,</li>
  <li>if <code>!c_comp(ck,k1)</code> and <code>!comp(k1,k2)</code> then
    <code>!c_comp(ck,k2)</code>,</li>
  <li>if <code>!c_comp(k1,ck)</code> and <code>!comp(k2,k1)</code> then
    <code>!c_comp(k2,ck)</code>,</li>
</ol>
for every <code>c_comp</code> of type <code>CompatibleCompare</code>,
<code>comp</code> of type <code>Compare</code>, <code>ck</code> of type
<code>CompatibleKey</code> and <code>k1</code>, <code>k2</code> of type
<code>Key</code>.
</p>



<p>Additionally, a type <code>CompatibleKey</code> is said to be a
<i>compatible key</i> of <code>Compare</code> if (<code>CompatibleKey</code>,
<code>Compare</code>) is a compatible extension of <code>Compare</code>.
This implies that <code>Compare</code>, as well as being a strict
weak ordering, accepts arguments of type <code>CompatibleKey</code>,
which usually means it has several overloads of <code>operator()</code>.
</p>

<p>
In the context of a compatible extension or a compatible key, the expressions
"equivalent", "less than" and "greater than" take on their obvious
interpretations.
</p>

<code>template&lt;typename CompatibleKey> const_iterator find(const CompatibleKey& x)const;
</code>

<blockquote>
<b>Requires:</b> <code>CompatibleKey</code> is a compatible key of
<code>key_compare</code>.</br>
<b>Effects:</b> Returns a pointer to an element whose key is equivalent to
<code>x</code>, or <code>end()</code> if such an element does not exist.<br>
<b>Complexity:</b> <code>O(log(n))</code>.<br>
</blockquote>

<code>template&lt;typename CompatibleKey,typename CompatibleCompare><br>
&nbsp;&nbsp;const_iterator find(const CompatibleKey& x,const CompatibleCompare& comp)const;
</code>

<blockquote>
<b>Requires:</b> (<code>CompatibleKey</code>, <code>CompatibleCompare</code>)
is a compatible extension of <code>key_compare</code>.</br>
<b>Effects:</b> Returns a pointer to an element whose key is equivalent to
<code>x</code>, or <code>end()</code> if such an element does not exist.<br>
<b>Complexity:</b> <code>O(log(n))</code>.<br>
</blockquote>

<code>template&lt;typename CompatibleKey> size_type count(const CompatibleKey& x)const;
</code>

<blockquote>
<b>Requires:</b> <code>CompatibleKey</code> is a compatible key of
<code>key_compare</code>.</br>
<b>Effects:</b> Returns the number of elements with key equivalent to <code>x</code>.<br>
<b>Complexity:</b> <code>O(log(n) + count(x))</code>.<br>
</blockquote>

<code>template&lt;typename CompatibleKey,typename CompatibleCompare><br>
&nbsp;&nbsp;size_type count(const CompatibleKey& x,const CompatibleCompare& comp)const;
</code>

<blockquote>
<b>Requires:</b> (<code>CompatibleKey</code>, <code>CompatibleCompare</code>)
is a compatible extension of <code>key_compare</code>.</br>
<b>Effects:</b> Returns the number of elements with key equivalent to <code>x</code>.<br>
<b>Complexity:</b> <code>O(log(n) + count(x,comp))</code>.<br>
</blockquote>

<code>template&lt;typename CompatibleKey> const_iterator lower_bound(const CompatibleKey& x)const;
</code>

<blockquote>
<b>Requires:</b> <code>CompatibleKey</code> is a compatible key of
<code>key_compare</code>.</br>
<b>Effects:</b> Returns an iterator pointing to the first element with
key not less than <code>x</code>, or <code>end()</code> if such an element does
not exist.<br>
<b>Complexity:</b> <code>O(log(n))</code>.<br>
</blockquote>

<code>template&lt;typename CompatibleKey,typename CompatibleCompare><br>
&nbsp;&nbsp;const_iterator lower_bound(const CompatibleKey& x,const CompatibleCompare& comp)const;
</code>

<blockquote>
<b>Requires:</b> (<code>CompatibleKey</code>, <code>CompatibleCompare</code>)
is a compatible extension of <code>key_compare</code>.</br>
<b>Effects:</b> Returns an iterator pointing to the first element with
key not less than <code>x</code>, or <code>end()</code> if such an element does
not exist.<br>
<b>Complexity:</b> <code>O(log(n))</code>.<br>
</blockquote>

<code>template&lt;typename CompatibleKey> const_iterator upper_bound(const CompatibleKey& x)const;
</code>

<blockquote>
<b>Requires:</b> <code>CompatibleKey</code> is a compatible key of
<code>key_compare</code>.</br>
<b>Effects:</b> Returns an iterator pointing to the first element with
key greater than <code>x</code>, or <code>end()</code> if such an element does
not exist.<br>
<b>Complexity:</b> <code>O(log(n))</code>.<br>
</blockquote>

<code>template&lt;typename CompatibleKey,typename CompatibleCompare><br>
&nbsp;&nbsp;const_iterator upper_bound(const CompatibleKey& x,const CompatibleCompare& comp)const;
</code>

<blockquote>
<b>Requires:</b> (<code>CompatibleKey</code>, <code>CompatibleCompare</code>)
is a compatible extension of <code>key_compare</code>.</br>
<b>Effects:</b> Returns an iterator pointing to the first element with
key greater than <code>x</code>, or <code>end()</code> if such an element does
not exist.<br>
<b>Complexity:</b> <code>O(log(n))</code>.<br>
</blockquote>

<code>template&lt;typename CompatibleKey><br>
&nbsp;&nbsp;std::pair&lt;const_iterator,const_iterator> equal_range(const CompatibleKey& x)const;
</code>

<blockquote>
<b>Requires:</b> <code>CompatibleKey</code> is a compatible key of
<code>key_compare</code>.</br>
<b>Effects:</b> Equivalent to <code>make_pair(lower_bound(x),upper_bound(x))</code>.<br>
<b>Complexity:</b> <code>O(log(n))</code>.<br>
</blockquote>

<code>template&lt;typename CompatibleKey,typename CompatibleCompare><br>
&nbsp;&nbsp;std::pair&lt;const_iterator,const_iterator> equal_range(</br>
&nbsp;&nbsp;&nbsp;&nbsp;const CompatibleKey& x,const CompatibleCompare& comp)const;
</code>

<blockquote>
<b>Requires:</b> (<code>CompatibleKey</code>, <code>CompatibleCompare</code>)
is a compatible extension of <code>key_compare</code>.</br>
<b>Effects:</b> Equivalent to
<code>make_pair(lower_bound(x,comp),upper_bound(x,comp))</code>.<br>
<b>Complexity:</b> <code>O(log(n))</code>.<br>
</blockquote>


<h4><a name="index_range_operations">Index range operations</a></h4>

<p>
The member function <code>range</code> is not defined for sorted associative
containers, but Boost.Indexed set provides it as a convenient utility. A range
or interval is defined by two conditions for the lower and upper bounds, which
are modelled after the following concepts.
</p>

<p>
Consider a
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">
<code>Strict Weak Ordering</code></a> <code>Compare</code> over values
of type <code>Key</code>. A type <code>LowerBounder</code> is said to be
a <i>lower bounder</i> of <code>Compare</code> if
<ol>
  <li><code>LowerBounder</code> is a
    <a href="http://www.sgi.com/tech/stl/Predicate.html">
    <code>Predicate</code></a> over <code>Key</code>,</li>
  <li>if <code>lower(k1)</code> and <code>!comp(k2,k1)</code> then
    <code>lower(k2)</code>,</li>
</ol>
for every <code>lower</code> of type <code>LowerBounder</code>,
<code>comp</code> of type <code>Compare</code>, and <code>k1</code>,
<code>k2</code> of type <code>Key</code>. Similarly, an <i>upper bounder</i>
is a type <code>UpperBounder</code> such that
<ol>
  <li><code>UpperBounder</code> is a
    <a href="http://www.sgi.com/tech/stl/Predicate.html">
    <code>Predicate</code></a> over <code>Key</code>,</li>
  <li>if <code>upper(k1)</code> and <code>!comp(k1,k2)</code> then
    <code>upper(k2)</code>,</li>
</ol>
for every <code>upper</code> of type <code>UpperBounder</code>,
<code>comp</code> of type <code>Compare</code>, and <code>k1</code>,
<code>k2</code> of type <code>Key</code>.
</p>

<code>template&lt;typename LowerBounder,typename UpperBounder><br>
&nbsp;&nbsp;std::pair&lt;const_iterator,const_iterator> range(LowerBounder lower,UpperBounder upper)const;
</code>

<blockquote>
<b>Requires:</b> <code>LowerBounder</code> and <code>UpperBounder</code> are
a lower and upper bounder of <code>key_compare</code>, respectively.</br>
<b>Effects:</b> Returns a pair of iterators pointing to the beginning and one
past the end of the subsequence of elements satisfying <code>lower</code> and
<code>upper</code> simultaneously. If no such elements exist, the iterators
both point to the first element satisfying <code>lower</code>, or else
are equal to <code>end()</code> if this latter element does not exist.<br>
<b>Complexity:</b> <code>O(log(n))</code>.<br>
<b>Variants:</b> In place of <code>lower</code> or <code>upper</code> (or both),
the singular value <code>boost::indexed_sets::unbounded</code> can be
provided. This acts as a predicate which all values of type <code>key_type</code>
satisfy.<br>
</blockquote>
<h2>
<a name="index_list_synopsis">Header
<a href="../../../boost/indexed_set/index_list.hpp"><code>"boost/indexed_set/index_list.hpp"</code></a>
synopsis</a>
</h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>typename</span> <span class=identifier>T0</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>T1</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=special>...</span>
  <span class=keyword>typename</span> <span class=identifier>Tn</span><span class=special>=</span><b>implementation defined default</b><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>index_list</span><span class=special>;</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="index_specification">Index specification</a></h3>

<p>
An index specifier provides the information needed by <code>indexed_set</code>
in order to incorporate a given index instantiation as part of its index list.
Future releases of Boost.IndexedSet may allow for specification of user-defined
indices. Meanwhile, the requirements for an index specifier remain
implementation defined. Currently, Boost.IndexedSet provides the index specifiers
<a href="#unique_non_unique"><code>unique</code> and <code>non_unique</code></a>.
</p>

<h3><a name="index_list">Template class <code>index_list</code></a></h3>

<p>
<code>index_list</code> is a typelist construct used to specify a compile-time
sequence of indices as the <code>IndexSpecifierList</code> of
<code>indexed_set</code>.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>typename</span> <span class=identifier>T0</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>T1</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=special>...</span>
  <span class=keyword>typename</span> <span class=identifier>Tn</span><span class=special>=</span><b>implementation defined default</b><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>index_list</span><span class=special>;</span>
</pre></blockquote>

<p>
Each element of <code>indexed_list</code> must be an index specifier.
The maximum number of elements of an <code>index_list</code> is
implementation defined.
</p>

<h2>
<a name="tag_synopsis">Header
<a href="../../../boost/indexed_set/tag.hpp"><code>"boost/indexed_set/tag.hpp"</code></a>
synopsis</a>
</h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>typename</span> <span class=identifier>T0</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>T1</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=special>...</span>
  <span class=keyword>typename</span> <span class=identifier>Tn</span><span class=special>=</span><b>implementation defined default</b><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>tag</span><span class=special>;</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="tags">Tags</a></h3>

<p>
Tags are just conventional types used as mnemonics for indices of an
<code>indexed_set</code>, as for instance in member function <code>get</code>.
Each index can have none, one or more tags associated. The way tags are assigned
to a given index is dependent on the particular index specifier. Currently,
<a href="#indices">regular indices</a> (which are the only provided) use the template
class <code>tag</code> for the assignment of tags.
</p>

<h3><a name="tag">Template class <code>tag</code></a></h3>

<p>
<code>tag</code> is a typelist construct used to specify a compile-time
sequence of tags to be assigned to an index in instantiation time.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>typename</span> <span class=identifier>T0</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>T1</span><span class=special>=</span><b>implementation defined default</b><span class=special>,</span>
  <span class=special>...</span>
  <span class=keyword>typename</span> <span class=identifier>Tn</span><span class=special>=</span><b>implementation defined default</b><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>tag</span><span class=special>;</span>
</pre></blockquote>

<p>
Elements of <code>tag</code> can be any type, though the user is expected
to provide classes with mnemonic names. The maximum number of elements of a
<code>tag</code> instantiation is implementation defined.
</p>

<h2><a name="key_extractors">Key Extractors</a></h2>

<p>
Key extractors are used by <a href="#indices">regular indices</a> to
obtain the sorting keys from the elements of an <code>indexed_set</code>.
An <a href="http://www.sgi.com/tech/stl/Assignable.html"><code>Assignable</code></a>
class <code>KeyFromValue</code> is said to be a key extractor from a
type <code>T</code> if
<ol>
  <li>the type <code>KeyFromValue::result_type</code> is defined,</li>
  <li><code>k1(ca)</code> is defined and returns a value convertible
    to <code>const KeyFromValue::result_type&</code>,</li>
  <li>if <code>k2</code> is a copy of <code>k1</code>, <code>k1(ca)</code> is the
    same value as <code>k2(ca)</code>,</li>
</ol>
for every <code>k1</code>, <code>k2</code> of type <code>const KeyFromValue</code>,
and <code>ca</code> of type <code>const Type&</code>.
</p>

<p>
Additionally, <code>KeyFromValue</code> is a <i>read/write</i> key extractor
if the following extra conditions are met:
<ol>
  <li><code>k1(a)</code> is defined and returns a value convertible
    to <code>KeyFromValue::result_type&</code>,</li>
  <li><code>static_const&lt;const KeyFromValue::result_type&>(k1(a))</code>
    is the same  value as
    <code>k1(static_const&lt;const Type&>(a))</code>,</li>
</ol>
for every <code>k1</code> of type <code>const KeyFromValue</code> and
<code>a</code> of type <code>Type&</code>.
</p>

<p>
Boost.IndexedSet provides four general-purpose key extractors:
<ul>
  <li><a href="#identity"><code>identity</code></a>,</li>
  <li><a href="#member"><code>member</code></a>,</li>
  <li><a href="#const_mem_fun"><code>const_mem_fun</code></a> and</li>
  <li><a href="#mem_fun"><code>mem_fun</code></a>,</li>
</ul>
plus replacements for some of them:
<ul>
  <li><a href="#member_offset"><code>member_offset</code></a>,</li>
  <li><a href="#const_mem_fun_explicit"><code>const_mem_fun_explicit</code></a> and</li>
  <li><a href="#mem_fun_explicit"><code>mem_fun_explicit</code></a>,</li>
</ul>
that workaround some deficiencies in the support for non-type template parameters
by certain compilers.
</p>

<p>
The key extractors provided by Boost.IndexedSet are templatized according
to the type <code>Type</code> and serve to extract keys not only from objects
of type <code>Type</code>, but also from reference wrappers provided by
<a href="../../../doc/html/ref.html">Boost.Ref</a> and from <i>far pointers</i>
to <code>Type</code> (or to reference wrappers of <code>Type</code>): a far pointer
is any type <code>P</code> such that, for an object <code>p</code> of type
<code>const P</code>
<ul>
  <li><code>*x</code> yields an object of type <code>Type&</code> or
    <code>boost::reference_wrapper&lt;Type></code>, OR</li>
  <li><code>*x</code> yields a far pointer to <code>Type&</code></li>,
</ul>
that is, far pointers are arbitrary compositions of pointer-like objects
ultimately dereferencing to values of <code>Type&</code> or
<code>boost::reference_wrapper&lt;Type></code>.
<p>

<h2>
<a name="identity_synopsis">Header
<a href="../../../boost/indexed_set/identity.hpp"><code>"boost/indexed_set/identity.hpp"</code></a>
synopsis</a>
</h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>T</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>identity</span><span class=special>;</span>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="identity">Template class <code>identity</code></a></h3>

<p>
<code>identity</code> is a <a href="#key_extractors"><code>Key Extractor</code></a>
that acts as a do-nothing identity functor.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>identity</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=identifier>Type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>PtrType</span><span class=special>&gt;</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>PtrType</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> 
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=identifier>Type</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> <span class=comment>// only provided if Type is non-const

  // only provided if Type is non-const</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> 

  <span class=comment>// only provided if Type is const</span>
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>remove_const</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;::</span><span class=identifier>type</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> 

  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
<code>identity&lt;Type></code> is a model of:
<ul>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>Type</code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;const Type></code>,</li>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;Type></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from any far pointer to <code>const Type</code></code>.</li>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from any far pointer to <code>Type</code></code>.</li>
</ul>
</p>

<h4><code>identity</code> members</h4>

<code>template&lt;typename PtrType> Type& operator()(const PtrType& x)const;</code>

<blockquote>
<b>Requires:</b> <code>PtrType</code> is a far pointer type to <code>Type</code>.<br>
<b>Returns:</b> a reference to the object far-pointed to by <code>x</code>.
</blockquote>

<code>const Type& operator()(const Type&x)const;</code>

<blockquote>
<b>Returns:</b> <code>x</code>.
</blockquote>

<code>Type& operator()(Type &x)const;</code>

<blockquote>
<b>Returns:</b> <code>x</code>.
</blockquote>

<code>const Type& operator()(const reference_wrapper&lt;const Type>& x)const;</code>
<blockquote>
<b>Returns:</b> <code>x.get()</code>.
</blockquote>

<code>Type& operator()(const reference_wrapper&lt;typename remove_const&lt;Type>::type>& x)const;</code>
<blockquote>
<b>Returns:</b> <code>x.get()</code>.
</blockquote>

<code>Type& operator()(const reference_wrapper&lt;Type>& x)const;</code>
<blockquote>
<b>Returns:</b> <code>x.get()</code>.
</blockquote>


<h2>
<a name="member_synopsis">Header
<a href="../../../boost/indexed_set/member.hpp"><code>"boost/indexed_set/member.hpp"</code></a>
synopsis</a>
</h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMember</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>member</span><span class=special>;</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>size_t</span> <span class=identifier>OffsetOfMember</span><span class=special>&gt;</span> <span class=keyword>struct</span> <span class=identifier>member_offset</span><span class=special>;</span>

<span class=preprocessor>#define</span> <span class=identifier>BOOST_INDEXED_SET_MEMBER</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberName</span><span class=special>)</span> <b>implementation defined</b>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="member">Template class <code>member</code></a></h3>

<p>
<code>member</code> is a <a href="#key_extractors"><code>Key Extractor</code></a>
aimed at accessing a given member of a class.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMember</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>member</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=identifier>Type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>PtrType</span><span class=special>&gt;</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>PtrType</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> <span class=comment>// only provided if Type is non-const</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
The <code>PtrToMember</code> template argument specifies the particular
<code>Type Class::*</code> pointer to the member to be extracted.
<code>member&lt;Class,Type,PtrToMember></code> is a model of:
<ul>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>Class</code> if <code>Type</code> is non-<code>const</code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;const Class></code>,</li>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;Class></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from any far pointer to <code>const Class</code></code>,</li>
  <li>read/write <a href="#key_extractors"><code>Key Extractor</code></a>
    from any far pointer to <code>Class</code></code>.</li>
</ul>
</p>

<h4><code>member</code> members</h4>

<code>template&lt;typename PtrType> Type& operator()(const PtrType& x)const;</code>
  
<blockquote>
<b>Requires:</b> <code>PtrType</code> is a far pointer type to <code>Type</code>.<br>
<b>Returns:</b> a reference to the object far-pointed to by <code>x</code>.
</blockquote>

<code>const Type& operator()(const Class&x)const;</code>

<blockquote>
<b>Returns:</b> <code>x.*PtrToMember</code>.
</blockquote>

<code>Type& operator()(const Class&x);</code>

<blockquote>
<b>Returns:</b> <code>x.*PtrToMember</code>.
</blockquote>

<code>const Type& operator()(const reference_wrapper&lt;const Class>& x)const;</code>

<blockquote>
<b>Returns:</b> <code>x.get().*PtrToMember</code>.
</blockquote>

<code>Type& operator()(const reference_wrapper&lt;Class>& x)const;</code>

<blockquote>
<b>Returns:</b> <code>x.get().*PtrToMember</code>.
</blockquote>

<h3><a name="member_offset">Template class <code>member_offset</code></a></h3>

<p>
Some compilers do not properly support pointers to members as non-type
template arguments. The following have been confirmed to have bugs in
this respect:
<ul>
  <li>MSVC++ 6.0 (see 
    <a href="http://support.microsoft.com/default.aspx?scid=kb;EN-US;249045">Microsoft
    Knowledge Base article #249045</a></li>),
  <li>Intel C++ 7.0/7.1 for Windows (support issue #207321.)
</ul>
In this situation, <code>member_offset</code> provides an
alternative to <a href="#member"><code>member</code></a> accepting offsets
instead of pointers to members. Please note that the use of
<code>offsetof</code> on non-POD types is forbidden by the standard;
luckily enough, most compilers accept it nevertheless, so
<code>member_offset</code> serves as a workaround for most practical purposes.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMember</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>member_offset</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=identifier>Type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>PtrType</span><span class=special>&gt;</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>PtrType</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> 
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span> <span class=comment>// only provided if Type is non-const</span>
  <span class=keyword>const</span> <span class=identifier>Type</span><span class=special>&amp;</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span><span class=special>&amp;</span>       <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>As an example of use, given the class</p>

<blockquote><pre>
<span class=keyword>class</span> <span class=identifier>A</span>
<span class=special>{</span>
  <span class=keyword>int</span> <span class=identifier>x</span><span class=special>;</span>
<span class=special>}</span>
</pre></blockquote>

<p>
the instantiation <code>member&lt;A,int,&A::x></code> can be simulated then
as <code>member_offset&lt;A,int,offsetof(A,x)></code>.
</p>

<h3><a name="boost_indexed_set_member">Macro <code>BOOST_INDEXED_SET_MEMBER</code></a></h3>

<blockquote><pre>
<span class=identifier>BOOST_INDEXED_SET_MEMBER</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberName</span><span class=special>)</span>
</pre></blockquote>

<p>
This macro is provided as an aid for using <code>member</code> and
<code>member_offset</code> when writing cross-platform code. In the usual cases,
it expands to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>member</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,&amp;</span><span class=identifier>Class</span><span class=special>::</span><span class=identifier>MemberName</span><span class=special>&gt;</span>
</pre></blockquote>

<p>
but it resolves to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>member_offset</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>offsetof</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>MemberName</span><span class=special>)&gt;</span>
</pre></blockquote>

<p>
for the following compilers:
<ul>
  <li>MSVC++ 6.0 or lower,
  <li>Intel C++ 7.1 or lower for Windows,
</ul>
and/or if the macro <code>BOOST_NO_POINTER_TO_MEMBER_TEMPLATE_PARAMETERS</code>
is defined.
</p>

<h2>
<a name="mem_fun_synopsis">Header
<a href="../../../boost/indexed_set/mem_fun.hpp"><code>"boost/indexed_set/mem_fun.hpp"</code></a>
synopsis</a>
</h2>

<blockquote><pre>
<span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>{</span>

<span class=keyword>namespace</span> <span class=identifier>indexed_sets</span><span class=special>{</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMemberFunction</span><span class=special>)()</span><span class=keyword>const</span><span class=special>&gt;</span>
  <span class=keyword>struct</span> <span class=identifier>const_mem_fun</span><span class=special>;</span>

<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMemberFunction</span><span class=special>)()&gt;</span>
  <span class=keyword>struct</span> <span class=identifier>mem_fun</span><span class=special>;</span>

<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>PtrToMemberFunctionType</span><span class=special>,</span><span class=identifier>PtrToMemberFunctionType</span> <span class=identifier>PtrToMemberFunction</span>
<span class=special>&gt;</span>
  <span class=keyword>struct</span> <span class=identifier>const_mem_fun_explicit</span><span class=special>;</span>

<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>PtrToMemberFunctionType</span><span class=special>,</span><span class=identifier>PtrToMemberFunctionType</span> <span class=identifier>PtrToMemberFunction</span>
<span class=special>&gt;</span>
  <span class=keyword>struct</span> <span class=identifier>mem_fun_explicit</span><span class=special>;</span>

<span class=preprocessor>#define</span> <span class=identifier>BOOST_INDEXED_SET_CONST_MEM_FUN</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberFunName</span><span class=special>)</span> <b>implementation defined</b>
<span class=preprocessor>#define</span> <span class=identifier>BOOST_INDEXED_SET_MEM_FUN</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberFunName</span><span class=special>)</span> <b>implementation defined</b>

<span class=special>}</span> <span class=comment>// namespace boost::indexed_sets</span> 

<span class=special>}</span> <span class=comment>// namespace boost</span>
</pre></blockquote>

<h3><a name="const_mem_fun">Template class <code>const_mem_fun</code></a></h3>

<p>
<code>const_mem_fun</code> is a <a href="#key_extractors"><code>Key Extractor</code></a>
returning as key the result of invoking a given constant member function of a class.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMemberFunction</span><span class=special>)()</span><span class=keyword>const</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>const_mem_fun</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>remove_reference</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>PtrType</span><span class=special>&gt;</span> <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>PtrType</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
The <code>PtrToMemberFunction</code> template argument specifies the particular
<code>Type (Class::*PtrToMemberFunction)()const</code> pointer to the the constant
member function used in the extraction.
<code>const_mem_fun&lt;Class,Type,PtrToMemberFunction></code> is a model of:
<ul>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>Class</code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;const Class></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;Class></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from any far pointer to <code>const Class</code></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from any far pointer to <code>Class</code></code>.</li>
</ul>
</p>

<h4><code>const_mem_fun</code> members</h4>

<code>template&lt;typename PtrType> Type operator()(const PtrType& x)const;</code>

<blockquote>
<b>Requires:</b> <code>PtrType</code> is a far pointer type to <code>Type</code>.<br>
<b>Returns:</b> <code>(x.*PtrToMemberFunction)()</code>, where <code>x</code> is the
object far-pointed to by <code>x</code>.
</blockquote>

<code>Type operator()(const Class& x)const;</code>

<blockquote>
<b>Returns:</b> <code>(x.*PtrToMemberFunction)()</code>.
</blockquote>

<code>Type operator()(const reference_wrapper&lt;const Class>& x)const;</code>

<blockquote>
<b>Returns:</b> <code>(x.get().*PtrToMemberFunction)()</code>.
</blockquote>

<code>Type operator()(const reference_wrapper&lt;Class>& x)const;</code>

<blockquote>
<b>Returns:</b> <code>(x.get().*PtrToMemberFunction)()</code>.
</blockquote>

<h3><a name="mem_fun">Template class <code>mem_fun</code></a></h3>

<p>
<code>mem_fun</code> is a <a href="#key_extractors"><code>Key Extractor</code></a>
returning as key the result of invoking a given member function of a class.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*</span><span class=identifier>PtrToMemberFunction</span><span class=special>)()&gt;</span>
<span class=keyword>struct</span> <span class=identifier>mem_fun</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>remove_reference</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>PtrType</span><span class=special>&gt;</span> <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>PtrType</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
The <code>PtrToMemberFunction</code> template argument specifies the particular
<code>Type (Class::*PtrToMemberFunction)()</code> pointer to the the member
function used in the extraction.
<code>mem_fun&lt;Class,Type,PtrToMemberFunction></code> is a model of:
<ul>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from <code>reference_wrapper&lt;Class></code>,</li>
  <li><a href="#key_extractors"><code>Key Extractor</code></a>
    from any far pointer to <code>Class</code></code>.</li>
</ul>
</p>

<h4><code>mem_fun</code> members</h4>

<code>template&lt;typename PtrType> Type operator()(const PtrType& x)const;</code>

<blockquote>
<b>Requires:</b> <code>PtrType</code> is a far pointer type to <code>Type</code>.<br>
<b>Returns:</b> <code>(x.*PtrToMemberFunction)()</code>, where <code>x</code> is the
object far-pointed to by <code>x</code>.
</blockquote>

<code>Type operator()(Class& x)const;</code>

<blockquote>
<b>Returns:</b> <code>(x.*PtrToMemberFunction)()</code>.
</blockquote>

<code>Type operator()(const reference_wrapper&lt;Class>& x)const;</code>

<blockquote>
<b>Returns:</b> <code>(x.get().*PtrToMemberFunction)()</code>.
</blockquote>

<h3><a name="const_mem_fun_explicit">Template class <code>const_mem_fun_explicit</code></a></h3>

<p>
MSVC++ 6.0 do not properly support pointers to constant member functions as non-type
template parameters, thus <a href="#const_mem_fun"><code>const_mem_fun</code></a> cannot be
used in this compiler. A simple workaround consists in specifying the <i>type</i> of
these pointers as an additional template parameter.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>PtrToMemberFunctionType</span><span class=special>,</span><span class=identifier>PtrToMemberFunctionType</span> <span class=identifier>PtrToMemberFunction</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>const_mem_fun_explicit</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>remove_reference</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>PtrType</span><span class=special>&gt;</span> <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>PtrType</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=keyword>const</span> <span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
<code>const_mem_fun_explicit</code> provides the very same functionality as
its <code>const_mem_fun</code> analogous instantiation. For example, given the type
</p>

<blockquote><pre>
<span class=keyword>struct</span> <span class=identifier>A</span>
<span class=special>{</span>
  <span class=keyword>int</span> <span class=identifier>f</span><span class=special>()</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<p>
the extractor <code>const_mem_fun&lt;A,int,&A::f></code> can be replaced by
<code>const_mem_fun_explicit&lt;A,int,int (A::*)()const,&A::f></code>.
</p>

<h3><a name="mem_fun_explicit">Template class <code>mem_fun_explicit</code></a></h3>

<p>
For analogy with <a href="#const_mem_fun_explicit"><code>const_mem_fun_explicit</code></a>,
a variation of <a href="#mem_fun"><code>mem_fun</code></a> is provided accepting
an additional parameter with the type of the pointer to non-constant member function
used for extraction.
</p>

<blockquote><pre>
<span class=keyword>template</span><span class=special>&lt;</span>
  <span class=keyword>class</span> <span class=identifier>Class</span><span class=special>,</span><span class=keyword>typename</span> <span class=identifier>Type</span><span class=special>,</span>
  <span class=keyword>typename</span> <span class=identifier>PtrToMemberFunctionType</span><span class=special>,</span><span class=identifier>PtrToMemberFunctionType</span> <span class=identifier>PtrToMemberFunction</span><span class=special>&gt;</span>
<span class=keyword>struct</span> <span class=identifier>mem_fun_explicit</span>
<span class=special>{</span>
  <span class=keyword>typedef</span> <span class=keyword>typename</span> <span class=identifier>remove_reference</span><span class=special>&lt;</span><span class=identifier>Type</span><span class=special>&gt;::</span><span class=identifier>type</span> <span class=identifier>result_type</span><span class=special>;</span>

  <span class=keyword>template</span><span class=special>&lt;</span><span class=keyword>typename</span> <span class=identifier>PtrType</span><span class=special>&gt;</span> <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>PtrType</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=identifier>Class</span><span class=special>&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
  <span class=identifier>Type</span> <span class=keyword>operator</span><span class=special>()(</span><span class=keyword>const</span> <span class=identifier>reference_wrapper</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>&gt;&amp;</span> <span class=identifier>x</span><span class=special>)</span><span class=keyword>const</span><span class=special>;</span>
<span class=special>};</span>
</pre></blockquote>

<h3><a name="boost_indexed_set_const_mem_fun">Macro
<code>BOOST_INDEXED_SET_CONST_MEM_FUN</code></a></h3>

<blockquote><pre>
<span class=identifier>BOOST_INDEXED_SET_CONST_MEM_FUN</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberFunName</span><span class=special>)</span>
</pre></blockquote>

<p>
Use this macro when writing cross-platform code selectively using
<code>const_mem_fun_explicit</code> in place of <code>const_mem_fun</code> for
compilers not supporting the latter. In the usual cases, the macro expands to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>const_mem_fun</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,&amp;</span><span class=identifier>Class</span><span class=special>::</span><span class=identifier>MemberFunName</span><span class=special>&gt;</span>
</pre></blockquote>

<p>
but it resolves to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>const_mem_fun_explicit</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*)()</span><span class=keyword>const</span><span class=special>,&amp;</span><span class=identifier>Class</span><span class=special>::</span><span class=identifier>MemberFunName</span><span class=special>&gt;</span>
</pre></blockquote>

<p>
for MSVC++ 6.0 or lower.
</p>


<h3><a name="boost_indexed_set_mem_fun">Macro
<code>BOOST_INDEXED_SET_MEM_FUN</code></a></h3>

<blockquote><pre>
<span class=identifier>BOOST_INDEXED_SET_MEM_FUN</span><span class=special>(</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>MemberFunName</span><span class=special>)</span>
</pre></blockquote>

<p>
By default, the macro expands to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>mem_fun</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,&amp;</span><span class=identifier>Class</span><span class=special>::</span><span class=identifier>MemberFunName</span><span class=special>&gt;</span>
</pre></blockquote>

<p>
but it resolves to
</p>

<blockquote><pre>
<span class=special>::</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>indexed_sets</span><span class=special>::</span><span class=identifier>mem_fun_explicit</span><span class=special>&lt;</span><span class=identifier>Class</span><span class=special>,</span><span class=identifier>Type</span><span class=special>,</span><span class=identifier>Type</span> <span class=special>(</span><span class=identifier>Class</span><span class=special>::*)()</span><span class=special>,&amp;</span><span class=identifier>Class</span><span class=special>::</span><span class=identifier>MemberFunName</span><span class=special>&gt;</span>
</pre></blockquote>

<p>
for MSVC++ 6.0 or lower.
</p>

<hr>

<p>Revised February 12th 2004</p>

<p>Copyright &copy; 2003-2004 Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz.
Use, modification, and distribution are subject to the Boost Software 
License, Version 1.0. (See accompanying file <a href="../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
www.boost.org/LICENSE_1_0.txt</a>)
</p>

</body>
</html>
