[library Intrusive
    [quickbook 1.3]
    [version 2006-12-09]
    [authors [Krzikalla, Olaf], [Gazta&ntilde;aga, Ion]]
    [copyright 2005 Olaf Krzikalla, 2006 Ion Gazta&ntilde;aga]
    [purpose Intrusive containers]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[section:overview Overview]

[blurb [*DISCLAIMER:] Intrusive is [*not] an official Boost library and the boost::intrusive
   namespace is not reserved for this library. This library is being developed under Boost
   guidelines and a review will requested when the library is mature enough to be presented
   as a candidate for Boost libraries]

[section:overview_introduction Introduction]

[*Boost.Intrusive] is a library presenting some intrusive containers to
the world of C++. While intrusive containers were and are widely used in C, they
became more and more forgotten in the C++-world due to the presence of the standard
containers, which don't support intrusive techniques. [*Boost.Intrusive] not only
reintroduces this technique to C++, but also encapsulates the implementation in
STL-like interfaces. Hence anyone familiar with standard containers can use intrusive
containers with ease. Like their STL-counterparts intrusive containers use template
parameters to control the stored data types and some special aspects of intrusive
containers. 

[endsect]

[section:overview_intrusive_vs_nontrusive Intrusive and nonintrusive containers]

The main difference between intrusive containers and non-intrusive containers is
that in C++ non-intrusive containers store [*copies] of values passed by the user.
Container use the `Allocator` template parameter to allocate the stored values:

[c++]

   #include <list>
   #include <assert.h>

   int main()
   {
      std::list<MyClass> myclass_list;

      MyClass myclass(...);
      myclass_list.push_back(myclass);

      //The stored object is different from the original object
      assert(&myclass != &myclass_list.front());
      return 0;
   }


To store the newly allocated copy of `myclass`, the container needs usually additional
data. For example, `std::list` usually allocates nodes that contain pointers to the
next and previous node and the value itself. Something similar to:

[c++]

   //A possible implementation of a std::list<MyClass> node
   class list_node
   {
      list_node *next;
      list_node *previous;
      MyClass    value; 
   };


On the other hand, an intrusive container does not store copies of passed objects,
but it stores the objects themselves. The additional data needed to insert the object
in the container must be provided by the object itself. For example, to insert `MyClass`
in an intrusive container that implements a linked list, `MyClass` must contain the
needed ['next] and ['previous] pointers:

[c++]

   class MyClass
   {
      MyClass *next;
      MyClass *previous;

      //Other members
      //...
      //...
      //...
   };

   int main()
   {
      acme_intrusive_list<MyClass> list;
      MyClass myclass;
   
      list.push_back(myclass);

      assert(&myclass == &list.front());
      return 0;
   }

As we can see, knowing which additional data the class should contain is not
an easy task. [*Boost.Intrusive] offers several intrusive containers and an easy
way to make user classes compatible with those containers.

The non-intrusive approach is limited in its own ways:

*  Only one sequence of objects can be stored. If you have more than 
   one sequence (e.g. a set of vertices forming a polygon and a second lexicographical
   sorted sequence of that vertices), you either have to store multiple copies or you
   need a `std::list<Vertex*>`.

*  The use of dynamic allocation to create copies of passed values can be a performance
   and size bottleneck in some applications.

*  Only copies of objects are stored in non-intrusive containers. Hence copy
   or move constructors and copy or move assignment operators are required. Non-copyable
   and non-movable objects can't be stored in non-intrusive containers.

*  It's not possible to store a derived object in a STL-container while
   retaining its original type.

[endsect]

[section:overview_properties Properties of intrusive containers]

Semantically spoken, an intrusive container in the sense of Boost.Intrusive is similiar to
an STL-container holding non-owning pointers to objects. That is, if you have an
`boost::intrusive::ilist<T, ...>`(1), than `std::list<T*>` would allow you to do quite the
same things - maintaining and navigating a set of objects of type T and types derived from
it, but no implicit memory management with regard to T. However, intrusive containers have
some important advantages: 

*  Operating with intrusive containers doesn't invoke any memory management at all.

*  Intrusive containers don't throw(2).

*  The computation of an iterator to an element from a pointer or reference to that element
   is a constant time operation (computing the position of T* in a `std::list<T*>` has
   linear complexity). 

[/*  Whenever an element stored in an intrusive container gets deleted or goes out of scope,
   the destructor automatically removes the element from the container. ]

Intrusive containers have also downsides:

*  Each type stored in an intrusive container need some data members holding the 
   maintenance informations needed by the container. Hence, whenever a certain type shall
   be stored in an intrusive container you have to change the definition of that type
   appropriately. Even, if with [*Boost.Intrusive] this task is easy, touching the 
   definition of a type is sometimes a crucial issue.

*  In intrusive containers you don't store a copy of an object, but rather the original 
   object itself. Objects don't need copy-constructors or assignment operators to be 
   stored in intrusive containers. But you have to take care of possible side effects, 
   whenever you change the content of an object (this is esp. important for associative
   containers).

*  The user has to manage the lifetime of inserted objects independently from the
   containers.

*  In addition, each object currently
   stored in an intrusive container has identity semantics. That means, that you can't move
   the memory location of the object (e.g. implicitly, if the object is also stored in a
   `std::vector`) as long as it is stored in any intrusive container. 

[/*  Whenever an object
   stored in an intrusive container gets destructed, it removes itself from that container.
   Iterators to that object become invalid. ]

*  Again you have to be [*careful]: in contrast to STL-containers it's easy to render an
   iterator invalid without touching the intrusive container directly, because the object
   can be destroyed before erasing it from the container.

[endsect]

[section:overview_footnotes Footnotes]

(1) Actually the template parameter is a little bit different. The notion used here just 
simplifies the readability. 

(2) There is an exotic case where an exception can be thrown, but it is practically irrelevant.

[endsect]
 
[endsect]

[section:concepts Concepts]

[section:concepts_explained Concepts explained]

This section will try to explain the basic concepts used in the design of
[*Boost.Intrusive].

*  [*Sequence Algorithms]: A set of static functions that implement basic sequence
   operations: initialize a node, link a node, unlink a node... [*Sequence Algorithms]
   don't depend on any node implementation. Algorithms just require a NodeTraits
   template parameter and they can work with any NodeTraits class that fulfills
   the needed interface. As an example, here is a class that
   implements algorithms for a circular singly linked list:

[c++]

   template<class NodeTraits>
   struct slist_algorithms
   {
      typedef typename NodeTraits::node *node_ptr;
      typedef typename NodeTraits::node *const_node_ptr;

      //Get previous node
      static node_ptr get_prev_node(node_ptr this_node)
      {
         node_ptr p = this_node;
         while (this_node != NodeTraits::get_next(p))
            p = NodeTraits::get_next(p);
         return p;
      }

      //init a node:
      static void init(node_ptr this_node)  
      {  NodeTraits::set_next(this_node, this_node);  }  

      // true, if this is not in a sequence:
      static bool unique(const_node_ptr this_node)  
      {  return NodeTraits::get_next(this_node) == this_node; }

      // number of elements in the sequence containing this:
      static std::size_t count(const_node_ptr this_node) 
      {
         std::size_t result = 0;
         const_node_ptr p = this_node;
         do{
            p = NodeTraits::get_next(p);
            ++result;
         } while (p != this_node);
         return result;
      }

      // More functions
      // ...
      // ...
      // ...
      // ...
   };

*  [*Node Traits]: A class that capsulates the needed information and basic
   operations about a node of an intrusive sequence:
   the type of a node, a function to obtain the pointer to the next node... 
   Node traits are the configuration information [*Sequence Algorithms]
   need. Each type of [*Sequence Algorithms] define the interface that compatible 
   node traits must implement.
   As an example this is the definition of a [*Node Traits] class that
   is compatible with `slist_algorithms`:

[c++]

   struct slist_node_traits
   {
      struct node;
      typedef void* void_pointer;

      struct node
      {
         node *next_;
      };

      static node_ptr get_next(const node *n)
      {  return n->next_;  }  

      static void set_next(node *n, node *next)
      {  n->next_ = next;  }  
   };


*  [*Hook]: A class that the user must add as a base class or as a member to its own
   class to make that class insertable in an intrusive sequence. For example, the
   following class is a [*Hook] that the user can add as a base class,
   to make the user class compatible with a singly linked list:

[c++]

   class slist_base_hook
      : private slist_node_traits::node node_
   {
      typedef slist_node_traits::node        node;
      typedef slist_node_traits::node        *node_ptr;
      typedef const slist_node_traits::node  *const_node_ptr;

      //Converts a generic node to the hook
      static slist_base_hook *to_hook(node_ptr p)
      {  return static_cast<slist_base_hook*>(p); }

      //Converts a generic node to the hook (const version)
      static const slist_base_hook *to_hook(const_node_ptr p)
      {  return static_cast<const slist_base_hook*>(p); }

      //Returns the generic node stored by this hook
      node_ptr to_node_ptr()
      { return static_cast<node *const>(this); }

      //Returns the generic node stored by this hook (const version)
      const_node_ptr to_node_ptr() const
      { return static_cast<const node *const>(this); }
   };

   //Now let's MyClass compatible with an intrusive singly linked list

   class MyClass
      :  public slist_base_hook
   {
      void set(int value);
      int get() const;

      private:
      int value_;
   };


*  [*Intrusive Container]: A container that offers an STL-like interface to store
   user objects. An intrusive container should be compatible with different user
   classes and even with different hooks. For example, an [classref boost::intrusive::islist islist] container 
   (intrusive singly linked list) should
   be able to hold `MyClass` objects that might have decided to store the hook
   as a base class or as a member. The container will use [*Sequence Algorithms] to
   implement its operations, and since these require generic nodes, the container
   needs a way to obtain the generic node from the user value. This information is
   stored in a [*ValueTraits] template parameter. For example, this a possible 
   [classref boost::intrusive::islist islist] implementation:

[c++]

   template<class ValueTraits, ...>
   class islist
   {
      public:
      typedef typename ValueTraits::value_type value_type;

      //More typedefs and functions
      // ...
      // ...
      // ...
      // ...

      //Insert the value as the first element of the list
      void push_front (value_type& v) 
      {
         node_ptr to_insert(ValueTraits::to_node_ptr(v));
         list_algorithms::link_after(to_insert, get_root_node()); 
      }

      //More operations
      // ...
      // ...
   };


*  [*Value Traits]: As we can see, to make our classes intrusive-friendly we add
   a generic simple hook as a member or base class. [*Sequence Algorithms] just work
   with nodes and don't know anything about user classes. On the other
   hand an intrusive container needs to know how to obtain a node from a user class.
   So we can define [*ValueTraits] as the glue between user classes and sequence nodes.
   Let's see a possible implementation of a value traits class that glues MyClass
   and the its hook (stored as a base class):

[c++]

   struct slist_derivation_value_traits
   {
      public:
      typedef slist_node_traits  node_traits;
      typedef MyClass            value_type;

      //Converts user's value to a generic node
      static node_traits::node *to_node_ptr(value_type& v)
      { return static_cast<slist_base_hook &>(v).to_node_ptr(); }

      //Converts user's value to a generic node (const version)
      static const node_traits::node *to_node_ptr(const value_type& v)
      { return static_cast<const slist_base_hook &>(v).to_node_ptr(); }

      //Converts a generic node into user's value
      static value_type *to_value_ptr(node_traits::node *n) 
      { static_cast<value_type*>(slist_base_hook::to_hook(n)); }

      //Converts a generic node into user's value (const version)
      static const value_type *to_value_ptr(const node_traits::node *n)
      { static_cast<const value_type*>(slist_base_hook::to_hook(n)); }
   };

[endsect]
[section:concepts_summary Concept summary]

Here is a small summary of the presented concepts:

[variablelist Brief Concepts Summary
[[Sequence Algorithms][A class containing typedefs and static functions that manage a sequence of nodes. It's independent from the node definition, so it takes a NodeTraits template parameter as configuration information.]]
[[Node Traits][A class that stores basic information and operations about a node of a sequence.]]
[[Hook][A class that a user must add as a base class or as a member to make the user class compatible with intrusive containers.]]
[[Intrusive Container][A class that stores user classes that have the needed hooks. It takes a ValueTraits template parameter as configuration information.]]
[[Value Traits][A class containing typedefs and operations to obtain the node to be used by Sequence Algorithms from the user class and the inverse.]]
]

[endsect]
[endsect]

[section:presenting_containers Presenting Boost.Intrusive containers]

[blurb [*DISCLAIMER:] Intrusive is [*not] an official Boost library and the boost::intrusive
   namespace is not reserved for this library. This library is being developed under Boost
   guidelines and a review will requested when the library is mature enough to be presented
   as a candidate for Boost libraries]

[*Boost.Intrusive] offers a wide range of intrusive containers:

*  [*islist]: An intrusive circular singly linked list. The size overhead is very small
   for user's classes (usually the size of one pointer) but many operations have linear
   time complexity, so the user must be careful if he wants to avoid performance problems.

*  [*ilist]: A `std::list` like circular intrusive linked list. The size overhead is quite
   small for user's classes (usually the size of two pointers). Many operations have
   constant time complexity.

*  [*iset]: A `std::set` like intrusive linked tree container. The size overhead is 
   moderate for user's classes (usually the size of three pointers). Many operations
   have logarithmic time complexity.

*  [*imultiset]: A `std::multiset` like intrusive linked tree container. The size
   overhead is moderate for user's classes (usually the size of three pointers). Many
   operations have logarithmic time complexity.

Each of these intrusive containers can be configured with constant or linear time
size:

*  [*Linear time size]: The intrusive container doesn't hold a size member that it's
updated with every insertion/erasure. This implies that the `size()` function has not constant
time complexity. On the other hand, the container is smaller, and some operations, like
`splice` in linked lists have constant time complexity instead of linear complexity.

*  [*Constant time size]: The intrusive container holds a size member that it's updated
with every insertion/erasure. This implies that the `size()` function has constant time
complexity. On the other hand, the size of the container in a word, and some operations,
like `splice` in linked lists have linear time complexity.

To make user classes compatible with these intrusive containers [*Boost.Intrusive]
offers two type of hooks for each container type:

*  [*Base hook]: The user's class stores the hook as a public base class.

*  [*Member hook]: The user's class stores the hook as a public member.

Apart from that, [*Boost.Intrusive] offers two additional features:

*  [*Safe mode hooks]: Hook's constructor initializes the internal data to a well-known
   safe state and intrusive containers check that state before inserting a value in the
   container. When erasing an element from the container, the container puts the hook
   in the safe state again. This allows a safer use mode and it can be used to detect
   programming errors. It implies an slight performance overhead in some operations
   and can convert some constant time operations in linear time operations.

*  [*Non-raw pointers]: If the wants to use smart pointers instead of raw pointers, 
   [*Boost.Intrusive] hooks can
   be configured to use any type of pointers. This configuration information is also
   known by the containers, so all stored pointers will be smart pointers. As an example,
   `boost::interprocess::offset_ptr<>` can be used to achieve shared memory intrusive
   containers.

[endsect]

[section:usage Usage]


[blurb [*DISCLAIMER:] Intrusive is [*not] an official Boost library and the boost::intrusive
   namespace is not reserved for this library. This library is being developed under Boost
   guidelines and a review will requested when the library is mature enough to be presented
   as a candidate for Boost libraries]

[section:usage_new_code How to use Boost.Intrusive]

If you plan to use a class in an intrusive container, you have to make some decisions 
influencing the class definition itself. Each class, that will be used in an intrusive 
container, needs some appropriate data members storing the informations needed by the 
container. For an ilist, you need a list node and for an imultiset a tree node. 
Boost.Intrusive lets you choose, how you include these nodes in your class. 

For [classref boost::intrusive::ilist ilist], you can public derive from [classref boost::intrusive::ilist_base_hook ilist_base_hook]. This class takes the same
three template arguments:

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void *>
   class ilist_base_hook;


*  The first integer template argument serves as a tag, so you can derive from more than one
[classref boost::intrusive::ilist_base_hook ilist_base_hook] and hence put objects in multiple intrusive lists at once. 

*  The second boolean template argument controls the safe mode. If this argument is set to true,
(the default value) the hook's constructor will initialize the hook to a well known safe state.
When inserting the class in an intrusive container, the container will check if the hook is in
the safe state. If that's not the case, it will assert. When erasing the an object from the list
the container will put the hook in the safe state again. This way, the class can know if it's
actually inserted in the list.

*  The third template argument is the pointer type. The default value is `void *`, which means
that raw pointers will be used in the hook. For example, the user can specify
`boost::interprocess::offset_ptr<void>` to use offset pointers.

Once we derive our class from `ilist_base_hook<...>` we have to obtain the value_traits to
configure the intrusive list. To obtain the value traits, just use the sub type [classref boost::intrusive::ilist_base_hook ilist_base_hook]
defines passing the user class type as an argument.

[c++]

   typedef ilist_base_hook<0, true>::value_traits<Foo> value_traits;

After that, we can define the intrusive list. The intrusive list has the following
template parameters:

[c++]

   template<class ValueTraits, bool ConstantTimeSize = false, class SizeType = std::size_t>
   class ilist;

*  The first template is the value_traits class. contains information about the value to be inserted:
   the type, the type of hook, the type of the pointers to be used, wheter the safe mode is being
   used... 

*  The second boolean template argument specifies if a constant time `size()` function is
   demanded. This will tell the intrusive container to insert an additional member
   in the intrusive container that offers this information.

*  The third template argument specifies the type that will hold the size of the container.
   This type will be the type returned by `ilist.size()` and the type stored in the intrusive
   container if `ConstantTimeSize` is requested.

Let's see an small example:

[c++]

   #include <boost/intrusive/ilist.hpp>

   //Define the user class.
   class Foo 
         //All the hooks will use the safe-mode
      :  public ilist_base_hook<0, true>    //derive publicly!
      ,  public ilist_base_hook<1, true>    //Foo will be used in two different lists
   {
      //...
   };

   //Obtain the first value_traits class from the first hook
   typedef ilist_base_hook<0, true>::value_traits<Foo> value_traits_0;

   //Obtain the second value_traits class from the second hook
   typedef ilist_base_hook<1, true>::value_traits<Foo> value_traits_1;

   //Define the first intrusive list.
   //This list will use the hook tagged with 0: 
   typedef ilist< value_traits_0 > list0;   

   //Define the first intrusive list.
   //This list will use the hook tagged with 1: 
   typedef ilist< value_traits_1 > list1;

   class Bar
      : public ilist_base_hook <0, false> 
   {} //you can use the same tags in other classes

   //for Bar the name value_traits
   //(inherited from ilist_base_hook <0, false> )
   //is unique: 
   typedef ilist< Bar::value_traits<Bar> > list_bar;

   int main()
   {
      //Insert the user object in the two lists
      list0 l0;
      list0 l1;
      Foo foo;

      l0.insert(foo);
      l1.insert(foo);

      return 0;
   }


If you don't want to derive from a list node, you can add a public data member
`ilist_member_hook<...>` to your class instead. This class takes three template parameters:

[c++]

   template<class T, bool SafeMode = true, class VoidPointer = void *>
   class ilist_member_hook;


Example:

[c++]

   class Foo 
   {
      public:
      ilist_member_hook<Foo, true> node_;  
      //...
   };

To obtain the `value_traits` information to configure the
list, use the internal templatized `value_traits` type and pass a pointer to member pointing
to the hook as the template parameter.

[c++]

   //obtain value_traits to configure the list
   typedef ilist_member_hook<Foo, true>::value_traits<&Foo::node_> value_traits;

   //this list will use the data member node_:
   typedef ilist<value_traits> list;

If you use member hooks the program can run slightly slower, because conversions from the 
hook to the user class requires pointer adjustements. In constrast, with only one base hook,
there is no pointer adjustment. On the other hand, someone might not want the 'is-a' relationship between list nodes and 
his own classes. In this case, using the hook as a data member instead of 'disturbing' 
the hierarchy might be the right way.

For an intrusive set and multiset containers, only the names are slightly different. The usage
is the same. Example:

[c++]

   class Foo : public iset_base_hook<0, true>	//derive public!
   {
      public:
      iset_member_hook<Foo, true>	node_;  
      //...
   };

   typedef imultiset< iset_base_hook<0, false>::value_traits<Foo> > set0;   
   typedef imultiset< iset_member_hook<Foo, true>::value_traits<&Foo::node> > set1;


Even if the interfaces of [classref boost::intrusive::ilist ilist] and [classref boost::intrusive::imultiset imultiset] are very familiar, using them is very
different to their respective STL-counterparts. You always have to keep in mind, that 
you store the objects themself in intrusive containers, no copies. The lifetime of a 
stored object is not bound to or managed by the container. When the container gets 
destroyed before the object, nothing special happens to the object.

[endsect]

[section:safe_mode More about the safe mode]

Some hooks have a flag to enable the safe-mode. The safe mode is activated
by default:

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void *>
   class ilist_base_hook;

Thanks to the safe-mode the user can detect without any external reference, if the object
is actually inserted in any sequence. Let's review the basic features of the safe-mode:

*  Hooks' constructors put the hook in a well-known default state.

*  Hooks' destructors checks if the hook in the well-known default state. If not,
   an assertion is raised in debug mode.

*  Every time an object is being inserted in the intrusive container, the container
   checks if the hook is the well-known default state. If not,
   an assertion is raised in debug mode.

*  Every time an object is being erased from the intrusive container, the container
   puts the erased object in the well-known default state.

With these features, without any external reference the user can know if the object
has been inserted in any container. If the object is not actually inserted 
in a container, the hook is the default state and if it's inserted in a container, the
hook is not in the default state.

[endsect]

[endsect]

[section:usage_when When to use?]

Intrusive containers can be used for highly optimized algorithms, where speed is a crucial
issue and...

*  additional memory management should be avoided.
*  exception safety, especially the no-throw guarantee, is needed.
*  the computation of an iterator to an element from a pointer or reference.
   to that element should be a constant time operation.
*  it's important to achieve a well-known worst-time system response.
*  localization of data (e.g. for cache hit optimization) leads to measureable effects.

The last point is important, if you have a lot of sequences over a set of elements. E.g. if 
you have a `std::vector<vertex>` forming a polygon and a set of all concave vertices over this 
vector stored in a `std::list<vertex*>`, then dereferencing an `std::list<vertex*>::iterator` 
walks through the memory in two steps: from the iterator (usually on the stack) to the list 
node storing the `vertex*` and finally to the vertex.

While the vertices themselves are tightly packed in the memory and form something like a
data block, the list nodes don't. Furthermore, 
list nodes may be stored independently from the vertex data block anywhere else in the address
space. Hence depending on your system you'll get a lot of cache misses. The same doesn't hold
for ilist. Indeed, dereferencing an `ilist::iterator` is performed in the same two steps as
described above. But the list node is already embedded in the vertex, so the memory is
directly tracked from the iterator to the vertex data block. 

It's also possible to use intrusive containers, when the objects to be stored have different
or unknown storage classes as shown in the following example: 

[c++]

   //An abstract class that can be
   //inserted in an intrusive list
   class Window
      :  public ilist_base_hook<0, true>
   {
      public:

      Window();

      virtual ~Window() = 0;

      virtual void Paint() = 0;
   };
   
   //The intrusive list definition
   typedef ilist< Window::value_traits<Window> > win_list;

   //A global intrusive list
   win_list all_windows;


   //Constructor. Includes this window in the list
   Window::Window()
   {
      all_windows.push_back(*this);
   }

   //Destructor. Removes this node from the list
   Window::~Window()
   {
      all_windows.erase(win_list::current(*this));
   }

   //A function that prints all windows stored
   //in the intrusive list
   void paint_all_windows()
   {
      for( win_list::iterator i = all_windows.begin()
                            , e = all_windows.end()
         ; i != e
         ; ++i)
         i->Paint();
   }

   //...

   //A class derived from Window
   class MainWindow
      :  public Window
   {
      FrameWindow   frame_;  //these are derived from Window too
      EditWindow    edit_;
      CanvasWindow  canvas_;
      //...
   };


   //Main function
   int main()
   {
      //When each Window class is created, is
      //automatically registered in the global list
      MainWindow window;

      //Paint all the windows, sub-windows and so on
      paint_all(); 

      //All the windows are automatically unregistered
      //in their destructors.
      return 0;
   }

Due to certain properties of intrusive containers (dependent class definition, identity
semantics) they are often more difficult to use than their STL-counterparts. That's why you
better avoid them in public interfaces of libraries. Classes stored in intrusive
containers need some public members needed by these containers and hence changing the
underlying implementation could change the public interface of the class definition.
In addtion, the identity semantic of stored objects must be handled very carefully. And
if you don't know, who is going to use your (library) interface, then maybe you better
try to stick with STL containers.

There is a borderline case, where it's rather unclear, if it's a good application for
intrusive lists: let the list 'own' the stored elements. Nothing hinders you to write code
like this: 

[c++]

   //A class that can be inserted in an intrusive list
   class entity
      :  public ilist_base_hook<0, true>
   {
      public:
      ~entity();
      //...
   };
   
   //Definition of the intrusive list
   typedef ilist< entity::value_traits<entity> > ent_list;

   //A global list
   ent_list l;

   //The destructor removes itself from the list
   entity::~entity()
   {
      l.erase(ent_list::current(*this));
   }

   //Function to insert a new entity in the list
   void insert_some_ent()
   {
      l.push_back (*new some_ent (/*...*/)); //some_ent is derived from entity
   } 

   //Funtion to clear an entity from the intrusive list
   void clear_list ()
   {
      while (!l.empty()){
         delete &l.front();	// the element removes itself from l implicitly
      }
   }

With `std::list<entity>` in-place construction isn't possible and you can't store derived
objects. Apart from that, using `std::list<boost::shared_ptr<entity>>` introduces a level
of indirection - something you won't want sometimes. Of course, you have to be very careful,
since [classref boost::intrusive::ilist ilist] doesn't do any ownership managment at its own.

[endsect]

[section:auto_unlink_hooks Auto-unlink hooks]

[section:auto_unlink_hooks_what What's an auto-unlink hook?]

[*Boost.Interprocess] offers additional hooks with unique features:

*  When the destructor of the hook is called, the hook removes itself from the container.
*  The hook has a member function called `unlink_self()` that can be used to unlink the
   node from the container at any moment, without having any reference to the container,
   if the user want to do so.

These hooks have exactly the same size overhead as their non auto-unlinking hooks, but
they have a restriction: they can only be used with non-constant time containers.
There is a reason for this: 
Non-constant time containers allow removing the object from the container without using
any reference to the container and this way, the auto-unlink hooks have the same size as
their non auto-unlink counterparts. This auto-unlink feature must be used [*very carefuly]:

* If several threads are using the same container, removing the object can be
  thread-unsafe.

* Container contents change silently without touching the container directly.
  This can lead to surprising effects.

These auto-unlink hooks have also safe-mode properties:

*  Hooks' constructors put the hook in a well-known default state.

*  Every time an object is being inserted in the intrusive container, the container
   checks if the hook is the well-known default state. If not,
   an assertion is raised in debug mode.

*  Every time an object is being erased from the intrusive container, the container
   puts the erased object in the well-known default state.

[endsect]

[section:auto_unlink_hooks_example Auto-unlink hook example]

Let's see an example of an auto-unlink hook:

[/doc_auto_unlink.cpp]

[c++]

   #include <boost/intrusive/ilist.hpp>
   #include <cassert>

   using namespace boost::intrusive;

   class MyClass
      //This hook removes the node automatically
      //in the destructor
      :  public ilist_auto_base_hook<0>
   {
      int int_;

      public:

      MyClass(int i = 0)
         :  int_(i)
      {}

      void unlink_self()
      {  ilist_auto_base_hook<0>::unlink_self();  }

      bool linked()
      {  return ilist_auto_base_hook<0>::linked();  }

      int get() const
      {  return int_;  }
   };

   //Define an ilist that will store MyClass
   //using the public base hook
   //The list can't have constant-time size!
   typedef ilist< ilist_auto_base_hook<0>::
                     value_traits<MyClass> >
      List;

   int main()
   {
      //Let's test how the MyClass destructor works:

      //Create the list
      List list;

      {
         //Create myclass and check it's linked
         MyClass myclass;
         assert(myclass.linked() == false);

         //Insert the object
         list.push_back(myclass);

         //Check that we have inserted the object
         assert(list.empty() == false);
         assert(&list.front() == &myclass);
         assert(myclass.linked() == true);

         //Now myclass' destructor will unlink it
         //automatically
      }

      //Check auto-unlink has been executed
      assert(list.empty() == true);

      {
         //Now test the unlink_self() function

         //Create myclass and check it's linked
         MyClass myclass;
         assert(myclass.linked() == false);

         //Insert the object
         list.push_back(myclass);

         //Check that we have inserted the object
         assert(list.empty() == false);
         assert(&list.front() == &myclass);
         assert(myclass.linked() == true);

         //Now unlink the node
         myclass.unlink_self();

         //Check auto-unlink has been executed
         assert(list.empty() == true);
      }
      return 0;
   }

[endsect]

[section:auto_unlink_and_constant_time Auto-unlink hooks and constant-time containers]

As explained, [*Boost.Intrusive] auto-unlink hooks are incompatible with
constant-time hooks, so if you try to define a constant-time container with an
auto-unlink hook's value_traits, you will get an static assertion:

[c++]

   class MyClass
      :  public boost::intrusive::ilist_auto_base_hook<0>
   {
   };

   boost::intrusive::ilist
      <boost::intrusive::ilist_auto_base_hook<0>::value_traits<MyClass>, true>
   bad_list;

   int main()
   {
      bad_list list;
      return 0;
   }

leads to an error similar to:

[pre
  error : use of undefined type 'boost::STATIC_ASSERTION_FAILURE<false>'
]


Pointing to a code like this:

[c++]

   //Constant-time size is incompatible with auto-unlink hooks!
 ->BOOST_STATIC_ASSERT(!(ConstantTimeSize &&  ValueTraits::auto_unlink));

This way, there is no way to compile a program if you try to use auto-unlink hooks
and constant-time size containers.

[endsect]

[endsect]

[section:islist Intrusive singly linked list: islist]

[classref boost::intrusive::islist islist] is the simplest intrusive container of [*Boost.Intrusive]: a
circular singly linked list. The memory overhead
that imposes is 1 pointer per node. An empty non constant-time size [classref boost::intrusive::islist islist]
has also the size of 1 pointer. This
lightweight memory overhead comes with its drawbacks, though: many operations have
linear time complexity, even some that usually are constant time, like `swap`.
`slist` does not provide bidirectional iterators and thus, it provides forward iterators.

For the most cases, a doubly linked list is preferrable, but for some applications, for
example, when constructing more elaborated containers, singly linked lists are essential.

[section:islist_hooks islist hooks]

Like the rest of [*Boost.Intrusive] containers, [classref boost::intrusive::islist islist] has several hook types:

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void*>
   class islist_base_hook;

*  [classref boost::intrusive::islist_base_hook islist_base_hook]: the user class derives publicly from [classref boost::intrusive::islist_base_hook islist_base_hook] to make
   it slist-compatible.

[c++]

   template<class T, bool SafeMode = true, class VoidPointer = void*>
   class islist_member_hook;

*  [classref boost::intrusive::islist_member_hook islist_member_hook]: the user class contains a public [classref boost::intrusive::islist_member_hook islist_member_hook] to make
   it slist-compatible.

[c++]

   template<int Tag, class VoidPointer = void*>
   class islist_auto_base_hook;

*  [classref boost::intrusive::islist_auto_base_hook islist_auto_base_hook]: the user class derives publicly from [classref boost::intrusive::islist_auto_base_hook islist_auto_base_hook]
   to make it slist-compatible. This hook is an auto-unlink hook.

[c++]

   template<class T, class VoidPointer = void*>
   class islist_auto_member_hook;

*  [classref boost::intrusive::islist_auto_member_hook islist_auto_member_hook]: the user class contains a public [classref boost::intrusive::islist_auto_member_hook islist_auto_member_hook]
   to make it slist-compatible.  This hook is an auto-unlink hook.

[endsect]

[section:islist_example Example]

Now let's see an small example using the first two hooks:

[c++]

   #include <boost/intrusive/islist.hpp>
   #include <vector>

   using namespace boost::intrusive;

   class MyClass
      :  public islist_base_hook<0>
   {
      int int_;

      public:
      islist_member_hook<MyClass> member_hook_;

      MyClass(int i)
         :  int_(i)
      {}

      int get() const
      {  return int_;  }
   };

   //Define an islist that will store MyClass
   //using the public base hook
   typedef islist< islist_base_hook<0>::
                     value_traits<MyClass> >
      BaseList;

   //Define an islist that will store MyClass
   //using the public member hook
   typedef islist< islist_member_hook<MyClass>::
                     value_traits<&MyClass::member_hook_> >
      MemberList;

   int main()
   {
      typedef std::vector<MyClass> Vect;
      typedef Vect::iterator VectIt;
      typedef Vect::reverse_iterator VectRit;

      //Create several MyClass objects, each one
      //with a different internal number
      Vect myclassvector;
      for(int i = 0; i < 100; ++i)
         myclassvector.push_back(MyClass(i));

      BaseList baselist;
      MemberList memberlist;

      //Now insert them in the reverse order
      //in the base hook intrusive list
      for(VectIt it(myclassvector.begin()), itend(myclassvector.end())
         ; it != itend
         ; ++it){
         baselist.push_front(*it);
      }

      //Now insert them in the same order as in vector in the
      //member hook intrusive list
      for(BaseList::iterator it(baselist.begin()), itend(baselist.end())
         ; it != itend
         ; ++it){
         memberlist.push_front(*it);
      }

      //Now test lists
      {
         BaseList::iterator bit(baselist.begin()), bitend(baselist.end());
         MemberList::iterator mit(memberlist.begin()), mitend(memberlist.end());
         VectRit rit(myclassvector.rbegin()), ritend(myclassvector.rend());
         VectIt  it(myclassvector.begin()), itend(myclassvector.end());

         //Test the objects inserted in the base hook list
         for(; rit != ritend; ++rit, ++bit){
            if(&*bit != &*rit)
               return 1;
         }

         //Test the objects inserted in the member hook list
         for(; it != itend; ++it, ++mit){
            if(&*mit != &*it)
               return 1;
         }
      }

      return 0;
   }

[endsect]

[endsect]

[section:ilist Intrusive doubly linked list: ilist]

[classref boost::intrusive::ilist ilist] is the preferred intrusive list container of [*Boost.Intrusive]: a
circular doubly linked list. The memory overhead
that imposes is 2 pointers per node. An empty non constant-time size [classref boost::intrusive::ilist ilist]
has also the size of 2 pointers. [classref boost::intrusive::ilist ilist] has many more constant-time operations
than [classref boost::intrusive::islist islist] and it's the intrusive equivalent of the standard `std::list` container.

[section:ilist_hooks ilist hooks]

Like the rest of [*Boost.Intrusive] containers, [classref boost::intrusive::ilist ilist] has several hook types:

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void*>
   class ilist_base_hook;

*  [classref boost::intrusive::ilist_base_hook ilist_base_hook]: the user class derives publicly from [classref boost::intrusive::ilist_base_hook ilist_base_hook] to make
   it list-compatible.

[c++]

   template<class T, bool SafeMode = true, class VoidPointer = void*>
   class ilist_member_hook;

*  [classref boost::intrusive::ilist_member_hook ilist_member_hook]: the user class contains a public [classref boost::intrusive::ilist_member_hook ilist_member_hook] to make
   it list-compatible.

[c++]

   template<int Tag, class VoidPointer = void*>
   class ilist_auto_base_hook;

*  [classref boost::intrusive::ilist_auto_base_hook ilist_auto_base_hook]: the user class derives publicly from [classref boost::intrusive::ilist_auto_base_hook ilist_auto_base_hook]
   to make it list-compatible. This hook is an auto-unlink hook.

[c++]

   template<class T, class VoidPointer = void*>
   class ilist_auto_member_hook;

*  [classref boost::intrusive::ilist_auto_member_hook ilist_auto_member_hook]: the user class contains a public [classref boost::intrusive::ilist_auto_member_hook ilist_auto_member_hook]
   to make it slist-compatible.  This hook is an auto-unlink hook.

[endsect]

[section:ilist_example Example]

Now let's see an small example using the first two hooks:

[c++]

   #include <boost/intrusive/ilist.hpp>
   #include <vector>

   using namespace boost::intrusive;

   class MyClass
      :  public ilist_base_hook<0>
   {
      int int_;

      public:
      ilist_member_hook<MyClass> member_hook_;

      MyClass(int i)
         :  int_(i)
      {}

      int get() const
      {  return int_;  }
   };

   //Define an ilist that will store MyClass
   //using the public base hook
   typedef ilist< ilist_base_hook<0>::
                     value_traits<MyClass> >
      BaseList;

   //Define an ilist that will store MyClass
   //using the public member hook
   typedef ilist< ilist_member_hook<MyClass>::
                     value_traits<&MyClass::member_hook_> >
      MemberList;

   int main()
   {
      typedef std::vector<MyClass> Vect;
      typedef Vect::iterator VectIt;
      typedef Vect::reverse_iterator VectRit;

      //Create several MyClass objects, each one
      //with a different internal number
      Vect myclassvector;
      for(int i = 0; i < 100; ++i)
         myclassvector.push_back(MyClass(i));

      BaseList baselist;
      MemberList memberlist;

      //Now insert them in the reverse order
      //in the base hook intrusive list
      for(VectIt it(myclassvector.begin()), itend(myclassvector.end())
         ; it != itend
         ; ++it){
         baselist.push_front(*it);
      }

      //Now insert them in the same order as in vector in the
      //member hook intrusive list
      for(VectIt it(myclassvector.begin()), itend(myclassvector.end())
         ; it != itend
         ; ++it){
         memberlist.push_back(*it);
      }

      //Now test lists
      {
         BaseList::reverse_iterator rbit(baselist.rbegin()), rbitend(baselist.rend());
         MemberList::iterator mit(memberlist.begin()), mitend(memberlist.end());
         VectIt  it(myclassvector.begin()), itend(myclassvector.end());

         //Test the objects inserted in the base hook list
         for(; it != itend; ++it, ++rbit){
            if(&*rbit != &*it)
               return 1;
         }

         //Test the objects inserted in the member hook list
         for(it = myclassvector.begin(); it != itend; ++it, ++mit){
            if(&*mit != &*it)
               return 1;
         }
      }

      return 0;
   }

[endsect]

[endsect]

[section:iset_imultiset Intrusive associative containers: iset, imultiset]

[*Boost.Intrusive] also offers associative containers that can be very useful
when creating more complex associative containers, like multi-index containers.
The memory overhead of these containers is usually 3 pointers and an integer. If
pointers have 2 byte alignment (which is usually true in most systems),
[*Boost.Intrusive] optimizes this overhead to 3 pointers.

An empty non constant-time size [classref boost::intrusive::iset iset] or [classref boost::intrusive::imultiset imultiset]
has also the size of 3 pointers and an integer (3 pointers when optimized).
[classref boost::intrusive::iset iset] and [classref boost::intrusive::imultiset imultiset] have logarithmic complexity in many operations like
searches, insertions, erasures, etc... [classref boost::intrusive::iset iset] and [classref boost::intrusive::imultiset imultiset] are the
intrusive equivalents of standard `std::set` and `std::multiset` containers.

[section:iset_imultiset_hooks iset and imultiset hooks]

[classref boost::intrusive::iset iset] and [classref boost::intrusive::imultiset imultiset] share the same hooks. This is an advantage, because the same
user type can be inserted first in a [classref boost::intrusive::imultiset imultiset] and after that in [classref boost::intrusive::iset iset] without
changing the definition of the user class.

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void*>
   class iset_base_hook;

*  [classref boost::intrusive::iset_base_hook iset_base_hook]: the user class derives publicly from [classref boost::intrusive::iset_base_hook iset_base_hook] to make
   it list-compatible.

[c++]

   template<class T, bool SafeMode = true, class VoidPointer = void*>
   class iset_member_hook;

*  [classref boost::intrusive::iset_member_hook iset_member_hook]: the user class contains a public [classref boost::intrusive::iset_member_hook iset_member_hook] to make
   it iset/imultiset compatible.

[c++]

   template<int Tag, class VoidPointer = void*>
   class iset_auto_base_hook;

*  [classref boost::intrusive::iset_auto_base_hook iset_auto_base_hook]: the user class derives publicly from [classref boost::intrusive::iset_auto_base_hook iset_auto_base_hook]
   to make it iset/imultiset compatible. This hook is an auto-unlink hook.

[c++]

   template<class T, class VoidPointer = void*>
   class iset_auto_member_hook;

*  [classref boost::intrusive::iset_auto_member_hook iset_auto_member_hook]: the user class contains a public [classref boost::intrusive::iset_auto_member_hook iset_auto_member_hook]
   to make it iset/imultiset compatible.  This hook is an auto-unlink hook.

[endsect]

[section:iset_imultiset_example Example]

Now let's see an small example using the first two hooks and both containers:

[c++]

   #include <boost/intrusive/iset.hpp>
   #include <vector>
   #include <algorithm>

   using namespace boost::intrusive;

   class MyClass
      :  public iset_base_hook<0>
   {
      int int_;

      public:
      iset_member_hook<MyClass> member_hook_;

      MyClass(int i)
         :  int_(i)
      {}

      int get() const
      {  return int_;  }

      friend bool operator< (const MyClass &a, const MyClass &b)
      {  return a.get() < b.get();  }

      friend bool operator> (const MyClass &a, const MyClass &b)
      {  return a.get() > b.get();  }
   };

   //Define an iset that will store MyClass
   //in reverse order using the public base hook
   typedef iset< iset_base_hook<0>::
                  value_traits<MyClass>
               , std::greater<MyClass> >
      BaseSet;

   //Define an imultiset that will store MyClass
   //using the public member hook
   typedef imultiset< iset_member_hook<MyClass>::
                        value_traits<&MyClass::member_hook_>
                  , std::less<MyClass> >
      MemberIMultiset;

   int main()
   {
      typedef std::vector<MyClass> Vect;
      typedef Vect::iterator VectIt;
      typedef Vect::reverse_iterator VectRit;

      //Create several MyClass objects, each one
      //with a different internal number
      Vect myclassvector;
      for(int i = 0; i < 100; ++i)
         myclassvector.push_back(MyClass(i));

      BaseSet baseset;
      MemberIMultiset membermultiset;

      //Now insert them in the reverse order
      //in the base hook intrusive set
      for(VectIt it(myclassvector.begin()), itend(myclassvector.end())
         ; it != itend
         ; ++it){
         baseset.insert(*it);
      }

      //Now insert them in the same order as in vector in the
      //member hook intrusive set
      for(VectIt it(myclassvector.begin()), itend(myclassvector.end())
         ; it != itend
         ; ++it){
         membermultiset.insert(*it);
      }

      //Now test sets
      {
         BaseSet::reverse_iterator rbit(baseset.rbegin()), rbitend(baseset.rend());
         MemberIMultiset::iterator mit(membermultiset.begin()), mitend(membermultiset.end());
         VectIt it(myclassvector.begin()), itend(myclassvector.end());

         //Test the objects inserted in the base hook set
         for(; it != itend; ++it, ++rbit){
            if(&*rbit != &*it)
               return 1;
         }

         //Test the objects inserted in the member hook set
         for(it = myclassvector.begin(); it != itend; ++it, ++mit){
            if(&*mit != &*it)
               return 1;
         }
      }
      return 0;
   }

[endsect]

[section:iset_imultiset_advanced_lookups_insertions iset and imultiset advanced
   lookups and insertions]

[*Boost.Intrusive] offers the same interface as `std::set` and `std::multiset` for
[classref boost::intrusive::iset iset] and [classref boost::intrusive::imultiset imultiset] but also offers some enhancements. It's known that there is a
performance penalty in the STL interface when doing lookups in `std::set` and `std::multiset`
and the contained type is expensive to construct. For example:

[c++]

   #include <boost/intrusive/iset.hpp>
   #include <string>

   class ExpensiveClass
      :  public boost::intrusive::iset_base_hook<0>
   {
      std::string key_;
      //Other members
      // ...
      
      public:
      ExpensiveClass(const char *key)
         :  key_(key)
      {
         //other expensive initializations
      }

      const std::string & get_key() const
      {  return key_;   }

      friend bool operator < (const ExpensiveClass &a, const ExpensiveClass &b)
      {  return a.key_ < b.key_;  }

      //Other functions
   };

   typedef boost::intrusive::iset
      < boost::intrusive::iset_base_hook<0>::value_traits<ExpensiveClass> >
         ExpensiveClassSet;
   
   /*
      ...
      ...
      ...
   */

   ExpensiveClass *get_object(const char* key, ExpensiveClassSet &expensive_class_set)
   {
      ExpensiveClass find_this(key);

      ExpensiveClassSet::iterator it = expensive_class_set.find(find_this);
      
      if( it == expensive_class_set.end() ){
         return 0;
      }
      return &*it;
   }

`ExpensiveClass` is an expensive object to construct. Maybe "key" c-string is quite long
and `ExpensiveClass` has to construct a long `std::string` to contain the key inside. Like
`ExpensiveClass`, many times the only member taking part in ordering issues is just
a small part of the class, for example, with `ExpensiveClass`, only the internal
`std::string` is needed to compare the object.

If we call `get_object` in a loop, we might get a performance penalty, because we are forced
to create a whole `ExpensiveClass` object to be able to find an equivalent one. To solve this,
[*Boost.Intrusive] containers offers an alternative lookup function, which takes any type
comparable with the value and a comparison functor that should be compatible with the
ordering function of the associative container:

[c++]

   //Same as before
   // ...
   // ...

   struct CStrExpensiveClassCompare
   {
      bool operator()(const char *str, const ExpensiveClass &c) const
      {  return std::strcmp(str, c.get_key().c_str()) == 0;  }

      bool operator()(const ExpensiveClass &c, const char *str) const
      {  return std::strcmp(c.get_key().c_str(), str) == 0;  }
   };
   
   ExpensiveClass *get_object(const char* key, ExpensiveClassSet &expensive_class_set)
   {
      //Now find the value using just the key!
      ExpensiveClassSet::iterator it = 
         expensive_class_set.find(key, CStrExpensiveClassCompare());
      
      if( it == expensive_class_set.end() ){
         return 0;
      }
      return &*it;
   }

This new arbitrary key overload is also available for other functions: `equal_range`,
`lower_bound`, `upper_bound`, `count`... Check [classref boost::intrusive::iset] and
[classref boost::intrusive::imultiset] references to know more about those functions.

[classref boost::intrusive::iset iset] also has two new insertion functions to be able to check efficiently, without
constructing the value, if a value is present and insert it inmediatelly without any
further lookup. Using the same `ExpensiveClass` class, this function can be inefficient:

[c++]

   //Same as before

   bool insert_unique_object(const char* key, ExpensiveClassSet &expensive_class_set)
   {
      //Construct an expensive object
      ExpensiveClass *pobject = new ExpensiveClass(key);

      std::pair<ExpensiveClassSet::iterator, bool> ret = 
         expensive_class_set.insert(*pobject);
      
      if(!ret.second){
         delete pobject;
      }
      return ret.second;
   }

If the object is already present, we are constructing an `ExpensiveClass` that
will be discarded, and this is a waste of resources. Instead of that, let's use
`insert_check` and `insert_commit` functions:

[c++]

   struct CStrExpensiveClassCompare
   {
      bool operator()(const char *str, const ExpensiveClass &c) const
      {  return std::strcmp(str, c.get_key().c_str()) == 0;  }

      bool operator()(const ExpensiveClass &c, const char *str) const
      {  return std::strcmp(c.get_key().c_str(), str) == 0;  }
   };

   bool insert_unique_object(const char* key, ExpensiveClassSet &expensive_class_set)
   {
      ExpensiveClassSet::insert_commit_data insert_data;

      std::pair<ExpensiveClassSet::iterator, bool> ret = 
         expensive_class_set.insert_check(key, CStrExpensiveClassCompare(), insert_data);
      
      if(ret.second){
         //Construct an expensive object
         ExpensiveClass *pobject = new ExpensiveClass(key);
         expensive_class_set.insert_commit(*pobject, insert_data);
      }
      return ret.second;
   }

`insert_check` is similar to a normal `insert` but it can use arbitrary keys and if the
insertion is possible (there are no equivalent values) collects all the needed information
in a `insert_commit_data` structure, so that `insert_commit` does not execute further comparisons 
and can be executed with constant-time complexity. These functions must be used with care, since
no other insertion or erasure must be executed between an `insert_check` and an `insert_commit`
pair. Otherwise, the results are undefined. 

`insert_check` and `insert_commit` will come handy
for developers programming non-intrusive associative containers (multi-index containers, for
example) that want to obtain maximum performance. See [classref boost::intrusive::iset]
reference for more information on `insert_check` and `insert_commit`.

[endsect]

[endsect]

[section:sequence_algorithms Sequence algorithms with custom NodeTraits]

As explained in the [link intrusive.concepts Concepts] section, [*Boost.Intrusive]
containers are implemented using sequence algorithms that work on generic nodes.

Instead of using [*Boost.Intrusive] containers, a user might want to develop its own containers,
for example, using nodes that are optimized for an specific application or that are compatible
with a a legacy ABI. A user might want
to have only two additional pointers in his class and insert the class in a doubly linked
list sometimes and in a singly linked list in other situations. You can't achieve this using
[*Boost.Intrusive] hooks.

[*Boost.Intrusive] can also be used for these tasks, since sequence algorithms are
available to be used with custom node types. All sequence algorithm classes are
templatized by a `NodeTraits` class. This class capsulates the needed internal
type declarations and operations to make the user code. Each sequence type has its
own requirements:

[section:islist_algorithms Intrusive singly linked list algorithms]

These algorithms are static
members of the [classref boost::intrusive::slist_algorithms slist_algorithms] class:

[c++]

   template<class NodeTraits>
   struct slist_algorithms;

An empty sequence is formed by a node whose pointer to the next node point
to itself. [classref boost::intrusive::slist_algorithms slist_algorithms]
is configured with a NodeTraits class, which capsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:

[*Typedefs]:

*  `node`: The type of the node that forms the circular list

*  `void_pointer`: The type of pointer of the node (usually void*)

[*Static functions]:

*  `static node_ptr get_next(const_node_ptr n);`:
   Returns a pointer to the next node stored in "n".

*  `static void set_next(node_ptr n, node_ptr next);`:
   Sets the pointer to the next node stored in "n" to "next".

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:

[c++]

   #include <boost/intrusive/slist_algorithms.hpp>
   #include <cassert>

   struct my_node
   {
      my_node *next_;
      //other members
   };

   //Define our own slist_node_traits
   struct my_slist_node_traits
   {
      typedef my_node node;
      typedef void * void_pointer;

      static node *get_next(const node *n)
      {  return n->next_;  }  

      static void set_next(node *n, node *next)
      {  n->next_ = next;  }  
   };

   int main()
   {
      typedef boost::intrusive::slist_algorithms<my_slist_node_traits> algo;

      my_node one;
      my_node two;
      my_node three;

      //Create an empty singly linked list sequence:
      //"one" will be the first node of the circular sequence
      algo::init(&one);
      assert(algo::count(&one) == 1);

      //Now add a new node
      algo::link_after(&two, &one);
      assert(algo::count(&one) == 2);

      //Now add a new node after "one"
      algo::link_after(&three, &one);
      assert(algo::count(&one) == 3);

      //Now unlink the node after one
      algo::unlink_after(&one);
      assert(algo::count(&one) == 2);

      //Now unlink two
      algo::unlink(&two);
      assert(algo::count(&one) == 1);

      return 0;
   }

For a complete list of functions see
[classref boost::intrusive::slist_algorithms slist_algorithms reference].

[endsect]

[section:ilist_algorithms Intrusive doubly linked list algorithms]

These algorithms are static
members of the [classref boost::intrusive::list_algorithms list_algorithms] class:

[c++]

   template<class NodeTraits>
   struct list_algorithms;

An empty sequence is formed by a node whose pointer to the next node point
to itself. [classref boost::intrusive::list_algorithms list_algorithms]
is configured with a NodeTraits class, which capsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:

[*Typedefs]:

*  `node`: The type of the node that forms the circular list

*  `void_pointer`: The type of pointer of the node (usually void*)

[*Static functions]:

*  `static node_ptr get_next(const_node_ptr n);`:
   Returns a pointer to the next node stored in "n".

*  `static void set_next(node_ptr n, node_ptr next);`:
   Sets the pointer to the next node stored in "n" to "next".

*  `static node_ptr get_previous(const_node_ptr n);`:
   Returns a pointer to the previous node stored in "n".

*  `static void set_previous(node_ptr n, node_ptr prev);`:
   Sets the pointer to the previous node stored in "n" to "prev".

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:

[c++]

   #include <boost/intrusive/list_algorithms.hpp>
   #include <cassert>

   struct my_node
   {
      my_node *next_;
      my_node *prev_;
      //other members
   };

   //Define our own list_node_traits
   struct my_list_node_traits
   {
      typedef my_node node;
      typedef void * void_pointer;

      static node *get_next(const node *n)
      {  return n->next_;  }  

      static void set_next(node *n, node *next)
      {  n->next_ = next;  }  

      static node *get_previous(const node *n)
      {  return n->prev_;  }  

      static void set_previous(node *n, node *prev)
      {  n->prev_ = prev;  }  
   };

   int main()
   {
      typedef boost::intrusive::list_algorithms<my_list_node_traits> algo;

      my_node one;
      my_node two;
      my_node three;

      //Create an empty singly linked list sequence:
      //"one" will be the first node of the circular sequence
      algo::init(&one);
      assert(algo::count(&one) == 1);

      //Now add a new node before "one"
      algo::link_before(&two, &one);
      assert(algo::count(&one) == 2);

      //Now add a new node after "two"
      algo::link_after(&three, &two);
      assert(algo::count(&one) == 3);

      //Now unlink the node after one
      algo::unlink(&three);
      assert(algo::count(&one) == 2);

      //Now unlink two
      algo::unlink(&two);
      assert(algo::count(&one) == 1);

      //Now unlink one
      algo::unlink(&one);
      assert(algo::count(&one) == 1);

      return 0;
   }

For a complete list of functions see
[classref boost::intrusive::list_algorithms list_algorithms reference].

[endsect]

[section:rbtree_algorithms Intrusive red-black tree algorithms]

These algorithms are static
members of the [classref boost::intrusive::rbtree_algorithms rbtree_algorithms] class:

[c++]

   template<class NodeTraits>
   struct rbtree_algorithms;

An empty sequence is formed by a node whose pointer to the next node point
to itself. [classref boost::intrusive::rbtree_algorithms rbtree_algorithms]
 is configured with a NodeTraits class, which capsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:

[*Typedefs]:

*  `node`: The type of the node that forms the circular rbtree

*  `void_pointer`: The type of pointer of the node (usually void*)

*  `color`: The type that can store the color of a node

[*Static functions]:

*  `static node_ptr get_parent(const_node_ptr n);`:
   Returns a pointer to the parent node stored in "n".

*  `static void set_parent(node_ptr n, node_ptr p);`:
   Sets the pointer to the parent node stored in "n" to "p".

*  `static node_ptr get_left(const_node_ptr n);`:
   Returns a pointer to the left node stored in "n".

*  `static void set_left(node_ptr n, node_ptr l);`:
   Sets the pointer to the left node stored in "n" to "l".

*  `static node_ptr get_right(const_node_ptr n);`:
   Returns a pointer to the right node stored in "n".

*  `static void set_right(node_ptr n, node_ptr r);`:
   Sets the pointer to the right node stored in "n" to "r".

*  `static color get_color(const_node_ptr n);`:
   Returns the color stored in "n".

*  `static void set_color(node_ptr n, color c);`:
   Sets the color stored in "n" to "c".

*  `static color black();`:
   Returns a value representing the black color of node.

*  `static color red();`:
   Returns a value representing the red color of node.

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:

[c++]

   #include <boost/intrusive/rbtree_algorithms.hpp>
   #include <cassert>

   struct my_node
   {
      my_node(int i = 0)
         :  int_(i)
      {}
      my_node *parent_;
      my_node *left_;
      my_node *right_;
      int      color_;
      //other members
      int      int_;
   };

   //Define our own rbtree_node_traits
   struct my_rbtree_node_traits
   {
      typedef my_node node;
      typedef void * void_pointer;
      typedef int color;

      static node *get_parent(const node *n)
      {  return n->parent_;  }  

      static void set_parent(node *n, node *parent)
      {  n->parent_ = parent;  }  

      static node *get_left(const node *n)
      {  return n->left_;  }  

      static void set_left(node *n, node *left)
      {  n->left_ = left;  }  

      static node *get_right(const node *n)
      {  return n->right_;  }  

      static void set_right(node *n, node *right)
      {  n->right_ = right;  }  

      static color get_color(const node *n)
      {  return n->color_;  }  

      static void set_color(node *n, color c)
      {  n->color_ = c;  }

      static color black()
      {  return color(0);  }  

      static color red()
      {  return color(1);  }  
   };

   struct node_ptr_compare
   {
      bool operator()(my_node *a, my_node *b)
      {  return a->int_ < b->int_;  }
   };

   int main()
   {
      typedef boost::intrusive::rbtree_algorithms<my_rbtree_node_traits> algo;

      my_node header;
      my_node two(2);
      my_node three(3);

      //Create an empty rbtree sequence:
      //"header" will be the header node of the tree
      algo::init_header(&header);

      //Now insert node two tree using the sorting functor
      algo::insert_equal_upper_bound(&header, &two, node_ptr_compare());

      //Now insert node two tree using the sorting functor
      algo::insert_equal_lower_bound(&header, &three, node_ptr_compare());

      //Now take the first node (the left node of the header)
      my_node *n = header.left_;
      assert(n == &two);

      //Now go to the next node
      n = algo::next_node(n);
      assert(n == &three);      

      //Erase a node just using a pointer to it
      algo::unlink_and_rebalance(n);

      //Erase a node using also the header (faster)
      algo::erase(&header, n);
      return 0;
   }

For a complete rbtree of functions see
[classref boost::intrusive::rbtree_algorithms rbtree_algorithms reference].

[endsect]

[endsect]

[section:value_traits Containers with custom ValueTraits]

As explained in the [link intrusive.concepts Concepts] section, [*Boost.Intrusive]
containers are templatized using a `ValueTraits` template parameter that contains
all the information to glue the user class and the node to be used in sequence algorithms.

[section:value_traits_interface ValueTraits interface]

Each [*Boost.Intrusive] container needs a different `ValueTraits` configuration class, but
all `ValueTraits` have the same interface:

[c++]

   struct my_value_traits
   {
      typedef implementation_defined node_traits;

      typedef implementation_defined value_type;

      enum {   type = some_value_traits_type   };

      static node_traits::node * to_node_ptr (value_type& v);

      static const node_traits::node * to_node_ptr (const value_type& v);

      static value_type * to_value_ptr(node_traits::node *n);

      static const value_type * to_value_ptr(const node_traits::node *n);
   };

Let's explain each type and function:

*  ['node_traits]: The node configuration that it's needed by sequence algorithms. These are
   described in the previous chapter: [link intrusive.sequence_algorithms Sequence Algorithms].

   *  If my_value_traits is meant to be used with islist, the `node_traits` should follow
      the interface needed by [classref boost::intrusive::slist_algorithms slist_algorithms].

   *  If my_value_traits is meant to be used with ilist, the `node_traits` should follow
      the interface needed by [classref boost::intrusive::list_algorithms list_algorithms].

   *  If my_value_traits is meant to be used with iset/imultiset, the `node_traits` should follow
      the interface needed by [classref boost::intrusive::rbtree_algorithms rbtree_algorithms].

*  ['value_type]: The type that the user wants to insert in the container. This type can be
   the same as `node_traits::node` but it can be different (for example, `node_traits::node`
   can be a member type of `value_type`). If `value_type` and `node_traits::node` are the
   same type, the `to_node_ptr` and `to_value_ptr` functions are trivial.

*  ['type]: Indicates that `value_traits` needs some additional work or checks from the
   container. The types are enumerations defined in the `value_traits_type.hpp` header.
   These are the possible types:

   *  `normal_value_traits`: This value_traits does not need any treatment in containers
   *  `safe_mode_value_traits`: This value_traits needs the container to check if the
      nodes are default initialized by the user before inserting them, and tells the 
      container to default initialize the nodes after erasing them from the container.
   *  `auto_unlink_value_traits`: Same as "safe_mode_value_traits" but the user type 
      is an auto-unlink type, so it's not compatible with non constant-time size containers,
      and the container might be modified without using its public interface.

*  ['static node_traits::node * to_node_ptr (value_type& v)] and
   ['static const node_traits::node * to_node_ptr (const value_type& v)]:
   These function take a reference to a value_type and return a pointer to the node
   to be used with sequence algorithms.

*  ['static value_type * to_value_ptr (node_traits::node *n)] and
   ['static const value_type * to_value_ptr (const node_traits::node *n)]:
   These function take a pointer to a node and return a pointer to the value
   that contains the node.

[endsect]

[section:value_traits_example Custom ValueTraits example]

Let's define our own `value_traits` class to be able to use [*Boost.Intrusive]
containers with our custom types. We will create a doubly linked list
value_traits:

[c++]

   #include <boost/intrusive/value_traits_type.hpp>
   #include <boost/intrusive/ilist.hpp>
   #include <vector>
   #include <cassert>

   //This node contains the needed data
   //for a custom doubly linked list
   struct my_node
   {
      my_node *next_;
      my_node *prev_;
   };

   //This is the type to be inserted in the
   //intrusive ilist container
   struct my_value
      :  public my_node
   {
      my_value(int i = 0)
         :  int_(i)
      {}

      int int_;
   };

   //Define our own list_node_traits that
   //contains information about my_node node
   struct my_list_node_traits
   {
      typedef my_node node;
      typedef void * void_pointer;

      static node *get_next(const node *n)
      {  return n->next_;  }  

      static void set_next(node *n, node *next)
      {  n->next_ = next;  }  

      static node *get_previous(const node *n)
      {  return n->prev_;  }  

      static void set_previous(node *n, node *prev)
      {  n->prev_ = prev;  }  
   };

   //This type will tell ilist container how to
   //transform our my_value to my_node
   struct my_value_traits
   {
      typedef my_list_node_traits   node_traits;

      typedef my_value              value_type;

      enum {   type = boost::intrusive::normal_value_traits   };

      static node_traits::node * to_node_ptr (value_type& v)
      {  return static_cast<node_traits::node *>(&v); }

      static const node_traits::node * to_node_ptr (const value_type& v)
      {  return static_cast<const node_traits::node *>(&v); }

      static value_type * to_value_ptr(node_traits::node *n)
      {  return static_cast<value_type*>(n); }

      static const value_type * to_value_ptr(const node_traits::node *n)
      {  return static_cast<const value_type*>(n); }
   };

   //Now define an intrusive list that will store my_value objects
   typedef boost::intrusive::ilist<my_value_traits> MyIntrusiveList;

   int main()
   {
      typedef std::vector<my_value> Vect;
      typedef Vect::iterator VectIt;
      typedef Vect::reverse_iterator VectRit;

      //Create several my_value objects, each one
      //with a different internal number
      Vect myclassvector;
      for(int i = 0; i < 100; ++i)
         myclassvector.push_back(my_value(i));

      MyIntrusiveList mylist;

      //Now insert them in the reverse order
      //in the our intrusive list
      for(VectIt it(myclassvector.begin()), itend(myclassvector.end())
         ; it != itend
         ; ++it){
         mylist.push_front(*it);
      }

      {
         //Now test the list
         MyIntrusiveList::reverse_iterator rbit(mylist.rbegin()), rbitend(mylist.rend());
         VectIt  it(myclassvector.begin()), itend(myclassvector.end());

         //Test the objects inserted in our list
         for(; it != itend; ++it, ++rbit){
            if(&*rbit != &*it)
               return 1;
         }
      }

      return 0;
   }

As seen, several key elements of [*Boost.Intrusive], can be reused with custom user types,
if the user does not want to use provided [*Boost.Intrusive] facilities.

[endsect]

[endsect]

[section:acknowledgments Acknowledgments]

[blurb [*DISCLAIMER:] Intrusive is [*not] an official Boost library and the boost::intrusive
   namespace is not reserved for this library. This library is being developed under Boost
   guidelines and a review will requested when the library is mature enough to be presented
   as a candidate for Boost libraries]

[*Olaf Krzikalla] would like to thank:

*  [*Markus Schaaf] for pointing out the possibility and the advantages of the derivation 
approach. 

*  [*Udo Steinbach] for encouragements to present this work for boost, a lot of fixes and
helpful discussions. 

*  [*Jaap Suter] for the initial hint, which eventually leads to the member value_traits.

[*Ion Gaztanaga] would like to thank [*Olaf Krzikalla] for the permission to
continue his great work.

[endsect]

[xinclude intrusive_doxygen.boostbook]

[section:license_notices License notices]

The internal implementation of red-black trees is based on that of SGI STL stl_tree.h file:

Copyright (c) 1996,1997 Silicon Graphics Computer Systems, Inc. 
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. Silicon Graphics makes no representations about the suitability of this software for any purpose. It is provided "as is" without express or implied warranty. 

Copyright (c) 1994 Hewlett-Packard Company 
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. Hewlett-Packard Company makes no representations about the suitability of this software for any purpose. It is provided "as is" without express or implied warranty. 

[endsect]


