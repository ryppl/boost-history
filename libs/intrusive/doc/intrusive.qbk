[library Intrusive
    [quickbook 1.3]
    [version 2007-01-06]
    [authors [Krzikalla, Olaf], [Gazta&ntilde;aga, Ion]]
    [copyright 2005 Olaf Krzikalla, 2006-2007 Ion Gazta&ntilde;aga]
    [purpose Intrusive containers]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[section:overview Overview]

[blurb [*DISCLAIMER:] Intrusive is [*not] an official Boost library and the boost::intrusive
   namespace is not reserved for this library. This library is being developed under Boost
   guidelines and a review will requested when the library is mature enough to be presented
   as a candidate for Boost libraries]

[section:overview_introduction Introduction]

[*Boost.Intrusive] is a library presenting some intrusive containers to
the world of C++. While intrusive containers were and are widely used in C, they
became more and more forgotten in the C++-world due to the presence of the standard
containers, which don't support intrusive techniques. [*Boost.Intrusive] not only
reintroduces this technique to C++, but also encapsulates the implementation in
STL-like interfaces. Hence anyone familiar with standard containers can use intrusive
containers with ease. Like their STL-counterparts intrusive containers use template
parameters to control the stored data types and some special aspects of intrusive
containers. 

[endsect]

[section:overview_intrusive_vs_nontrusive Intrusive and nonintrusive containers]

The main difference between intrusive containers and non-intrusive containers is
that in C++ non-intrusive containers store [*copies] of values passed by the user.
Container use the `Allocator` template parameter to allocate the stored values:

[c++]

   #include <list>
   #include <assert.h>

   int main()
   {
      std::list<MyClass> myclass_list;

      MyClass myclass(...);
      myclass_list.push_back(myclass);

      //The stored object is different from the original object
      assert(&myclass != &myclass_list.front());
      return 0;
   }


To store the newly allocated copy of `myclass`, the container needs usually additional
data. For example, `std::list` usually allocates nodes that contain pointers to the
next and previous node and the value itself. Something similar to:

[c++]

   //A possible implementation of a std::list<MyClass> node
   class list_node
   {
      list_node *next;
      list_node *previous;
      MyClass    value; 
   };


On the other hand, an intrusive container does not store copies of passed objects,
but it stores the objects themselves. The additional data needed to insert the object
in the container must be provided by the object itself. For example, to insert `MyClass`
in an intrusive container that implements a linked list, `MyClass` must contain the
needed ['next] and ['previous] pointers:

[c++]

   class MyClass
   {
      MyClass *next;
      MyClass *previous;

      //Other members
      //...
      //...
      //...
   };

   int main()
   {
      acme_intrusive_list<MyClass> list;
      MyClass myclass;
   
      list.push_back(myclass);

      assert(&myclass == &list.front());
      return 0;
   }

As we can see, knowing which additional data the class should contain is not
an easy task. [*Boost.Intrusive] offers several intrusive containers and an easy
way to make user classes compatible with those containers.

The non-intrusive approach is limited in its own ways:

*  Only one sequence of objects can be stored. If you have more than 
   one sequence (e.g. a set of vertices forming a polygon and a second
   sorted sequence of those vertices), you either have to store multiple copies of those
   vertices or you need to use containers of pointers: `std::list<Vertex*>`.

*  The use of dynamic allocation to create copies of passed values can be a performance
   and size bottleneck in some applications.

*  Only copies of objects are stored in non-intrusive containers. Hence copy
   or move constructors and copy or move assignment operators are required. Non-copyable
   and non-movable objects can't be stored in non-intrusive containers.

*  It's not possible to store a derived object in a STL-container while
   retaining its original type.

[endsect]

[section:overview_properties Properties of intrusive containers]

Semantically spoken, an intrusive container in the sense of Boost.Intrusive is similiar to
an STL-container holding non-owning pointers to objects. That is, if you have an
`boost::intrusive::ilist<T, ...>`(1), than `std::list<T*>` would allow you to do quite the
same things - maintaining and navigating a set of objects of type T and types derived from
it, but no implicit memory management with regard to T. However, intrusive containers have
some important advantages: 

*  Operating with intrusive containers doesn't invoke any memory management at all.

*  Intrusive containers don't throw(2).

*  The computation of an iterator to an element from a pointer or reference to that element
   is a constant time operation (computing the position of T* in a `std::list<T*>` has
   linear complexity). 

[/*  Whenever an element stored in an intrusive container gets deleted or goes out of scope,
   the destructor automatically removes the element from the container. ]

Intrusive containers have also downsides:

*  Each type stored in an intrusive container needs some data members holding the 
   maintenance informations needed by the container. Hence, whenever a certain type shall
   be stored in an intrusive container [*you have to change the definition of that type]
   appropriately. Although this task is easy with [*Boost.Intrusive], touching the 
   definition of a type is sometimes a crucial issue.

*  In intrusive containers you don't store a copy of an object, [*but rather the original 
   object itself]. Objects don't need copy-constructors or assignment operators to be 
   stored in intrusive containers. But you have to take care of possible side effects, 
   whenever you change the content of an object (this is especially important for 
   associative containers).

*  The user [*has to manage the lifetime of inserted objects] independently from the
   containers.

*  In addition, [*each object currently stored in an intrusive container
   has identity semantics]. That means, that you can't move the memory location of
   the object (e.g. implicitly, if the object is also stored in a
   `std::vector`) as long as it is stored in any intrusive container. 

*  Again you have to be [*careful]: in contrast to STL containers [*it's easy to render an
   iterator invalid] without touching the intrusive container directly, because the object
   can be destroyed before erasing it from the container.

*  [*Boost.Intrusive] containers are [*non-copyable and non-assignable]. Since intrusive
   containers don't have allocation capabilities, these operations have no sense. However
   swapping can be used to implement move-capabilities.

[endsect]

[section:overview_footnotes Footnotes]

(1) Actually the template parameter is a little bit different. The notion used here just 
simplifies the readability. 

(2) There is an exotic case where an exception can be thrown, but it is practically irrelevant.

[endsect]
 
[endsect]

[section:concepts Concepts]

[section:concepts_explained Concepts explained]

This section will try to explain the basic concepts used in the design of
[*Boost.Intrusive].

*  [*Sequence Algorithms]: A set of static functions that implement basic operations
   on a sequence of nodes: initialize a sequence, link a node to a sequence,
   unlink a node from a sequence... For example, a circular
   singly linked list is a sequence of nodes, where each node has a pointer to the
   next node. [*Sequence Algorithms]
   don't depend on any node definition. [*Sequence Algorithms] just require a [*NodeTraits]
   template parameter and they can work with any [*NodeTraits] class that fulfills
   the needed interface. As an example, here is a class that implements algorithms
   to manage a sequence forming a circular singly linked list:

[c++]

   template<class NodeTraits>
   struct my_slist_algorithms
   {
      typedef typename NodeTraits::node *node_ptr;
      typedef typename const NodeTraits::node *const_node_ptr;

      //Get the previous node of "this_node"
      static node_ptr get_prev_node(node_ptr this_node)
      {
         node_ptr p = this_node;
         while (this_node != NodeTraits::get_next(p))
            p = NodeTraits::get_next(p);
         return p;
      }

      // number of elements in the sequence containing "this_node"
      static std::size_t count(const_node_ptr this_node) 
      {
         std::size_t result = 0;
         const_node_ptr p = this_node;
         do{
            p = NodeTraits::get_next(p);
            ++result;
         } while (p != this_node);
         return result;
      }

      // More operations
      // ...
   };

*  [*Node Traits]: A class that capsulates the needed information and basic
   operations about a node that forms a sequence:
   the type of the node, a function to obtain the pointer to the next node... 
   [*Node Traits] are the configuration information [*Sequence Algorithms]
   need. Each type of [*Sequence Algorithms] defines the interface that compatible
   [*Node Traits] must implement.
   As an example, this is the definition of a [*Node Traits] class that
   is compatible with the previously presented `my_slist_algorithms`:

[c++]

   struct my_slist_node_traits
   {
      struct node;
      typedef void* void_pointer;

      //The type of the node
      struct node
      {
         node *next_;
      };

      //A function to obtain a pointer to the next node
      static node_ptr get_next(const node *n)
      {  return n->next_;  }  

      //A function to set the pointer to the next node
      static void set_next(node *n, node *next)
      {  n->next_ = next;  }  
   };


*  [*Hook]: A class that the user must add as a base class or as a member to its own
   class to make that class insertable in an intrusive container. Usually the hook
   contains a node object, that will be used to form the sequence of nodes:
   For example, the following class is a [*Hook] that the user can add as a base class,
   to make the user class compatible with a singly linked list container:

[c++]

   class my_slist_base_hook
         //This hook contains a node, that will be used
         //to link the user object in the sequence of nodes
      : private my_slist_node_traits::node node_
   {
      typedef my_slist_node_traits::node        node;
      typedef my_slist_node_traits::node       *node_ptr;

      //Converts a generic node to the hook
      static my_slist_base_hook *to_hook(node_ptr p)
      {  return static_cast<my_slist_base_hook*>(p); }

      //Returns the generic node stored by this hook
      node_ptr to_node_ptr()
      { return static_cast<node *const>(this); }

      // More operations
      // ...
   };

   //To make MyClass compatible with an intrusive singly linked list
   //derive our class from the hook.
   class MyClass
      :  public my_slist_base_hook
   {
      void set(int value);
      int get() const;

      private:
      int value_;
   };

*  [*Intrusive Container]: A container that offers an STL-like interface to store
   user objects. An intrusive container should be compatible with different user
   classes and even with different hooks. An intrusive container is also more elaborated
   than a sequence of nodes: it can store the size of the sequence to achieve constant-time
   size information, it can offer debugging facilities...
   For example, an [classref boost::intrusive::islist islist] container 
   (intrusive singly linked list) should
   be able to hold `MyClass` objects that might have decided to store the hook
   as a base class or as a member. Internally, the container will use [*Sequence Algorithms]
   to implement its operations, and since these require generic nodes, the container
   needs a way to obtain the generic node from the user value. This information is
   stored in a [*ValueTraits] template parameter. For example, this a possible 
   [classref boost::intrusive::islist islist] implementation:

[c++]

   template<class ValueTraits, ...>
   class islist
   {
      public:
      typedef typename ValueTraits::value_type value_type;

      //More typedefs and functions
      // ...

      //Insert the value as the first element of the list
      void push_front (value_type& v) 
      {
         node_ptr to_insert(ValueTraits::to_node_ptr(v));
         list_algorithms::link_after(to_insert, get_root_node()); 
      }

      // More operations
      // ...
   };


*  [*Value Traits]: As we can see, to make our classes intrusive-friendly we add
   a simple hook as a member or base class. The hook contains a generic node
   that will be inserted in a sequence of nodes. So [*Sequence Algorithms] just work
   with nodes and don't know anything about user classes. On the other
   hand, an intrusive container needs to know how to obtain a node from a user class,
   and also the inverse operation.   
   So we can define [*ValueTraits] as the glue between user classes and sequence nodes.
   Let's see a possible implementation of a value traits class that glues MyClass
   and the its hook (stored as a base class of the user class):

[c++]

   struct my_slist_derivation_value_traits
   {
      public:
      typedef slist_node_traits  node_traits;
      typedef MyClass            value_type;

      //Converts user's value to a generic node
      static node_traits::node *to_node_ptr(value_type& v)
      { return static_cast<slist_base_hook &>(v).to_node_ptr(); }

      //Converts a generic node into user's value
      static value_type *to_value_ptr(node_traits::node *n) 
      { static_cast<value_type*>(slist_base_hook::to_hook(n)); }

      // More operations
      // ...
   };

*  [*Pseudo-Intrusive Container]: A pseudo-intrusive container is similar to an
   intrusive container, but apart from using hooks that in the types to be inserted
   in the container, the pseudo-intrusive container needs additional
   memory (for example, auxiliary arrays or indexes).

[endsect]
[section:concepts_summary Concept summary]

Here is a small summary of the presented concepts:

[variablelist Brief Concepts Summary
[[Sequence Algorithms][A class containing typedefs and static functions that manage a sequence of nodes. It's independent from the node definition, so it takes a NodeTraits template parameter as configuration information.]]
[[Node Traits][A class that stores basic information and operations about a node of a sequence.]]
[[Hook][A class that a user must add as a base class or as a member to make the user class compatible with intrusive containers.]]
[[Intrusive Container][A class that stores user classes that have the needed hooks. It takes a ValueTraits template parameter as configuration information.]]
[[Value Traits][A class containing typedefs and operations to obtain the node to be used by Sequence Algorithms from the user class and the inverse.]]
[[Pseudo-Intrusive Containers][Similar to intrusive containers but pseudo-intrusive containers need additional memory (apart from hooks) to work.]]
]

[endsect]
[endsect]

[section:presenting_containers Presenting Boost.Intrusive containers]

[*Boost.Intrusive] offers a wide range of intrusive containers:

*  [*islist]: An intrusive circular singly linked list. The size overhead is very small
   for user's classes (usually the size of one pointer) but many operations have linear
   time complexity, so the user must be careful if he wants to avoid performance problems.

*  [*ilist]: A `std::list` like circular intrusive linked list. The size overhead is quite
   small for user's classes (usually the size of two pointers). Many operations have
   constant time complexity.

*  [*iset]: A `std::set` like intrusive linked tree container. The size overhead is 
   moderate for user's classes (usually the size of three pointers). Many operations
   have logarithmic time complexity.

*  [*imultiset]: A `std::multiset` like intrusive linked tree container. The size
   overhead is moderate for user's classes (usually the size of three pointers). Many
   operations have logarithmic time complexity.

[*Boost.Intrusive] also offers pseudo-intrusive containers:

*  [*ihashset]: A `std::tr1::unordered_set` like intrusive hash table container.
   The size overhead is moderate for user's classes (an average of two pointers per element).
   Many operations have an amortized constant time complexity.

*  [*ihashmultiset]: A `std::tr1::unordered_multiset` intrusive hash table container.
   The size overhead is moderate for user's classes (an average of two pointers per element).
   Many operations have an amortized constant time complexity.

Each of these intrusive containers can be configured with constant or linear time
size:

*  [*Linear time size]: The intrusive container doesn't hold a size member that it's
updated with every insertion/erasure. This implies that the `size()` function has not constant
time complexity. On the other hand, the container is smaller, and some operations, like
`splice()` taking a range of iterators in linked lists have constant time complexity
instead of linear complexity.

*  [*Constant time size]: The intrusive container holds a size member that it's updated
with every insertion/erasure. This implies that the `size()` function has constant time
complexity. On the other hand, the size of the container in a word, and some operations,
like `splice()` taking a range of iterators in linked lists have linear time complexity.

To make user classes compatible with these intrusive containers [*Boost.Intrusive]
offers two type of hooks for each container type:

*  [*Base hook]: The user's class stores the hook as a public base class.

*  [*Member hook]: The user's class stores the hook as a public member.

Apart from that, [*Boost.Intrusive] offers two additional features:

*  [*Safe mode hooks]: Hook's constructor initializes the internal data to a well-known
   safe state and intrusive containers check that state before inserting a value in the
   container. When erasing an element from the container, the container puts the hook
   in the safe state again. This allows a safer use mode and it can be used to detect
   programming errors. It implies an slight performance overhead in some operations
   and can convert some constant time operations in linear time operations.

*  [*Non-raw pointers]: If the wants to use smart pointers instead of raw pointers, 
   [*Boost.Intrusive] hooks can
   be configured to use any type of pointers. This configuration information is also
   known by the containers, so all stored pointers will be smart pointers. As an example,
   `boost::interprocess::offset_ptr<>` can be used to achieve shared memory intrusive
   containers.

[endsect]

[section:usage Usage]

[section:usage_new_code How to use Boost.Intrusive]

If you plan to use a class in an intrusive container, you have to make some decisions 
influencing the class definition itself. Each class, that will be used in an intrusive 
container, needs some appropriate data members storing the informations needed by the 
container. We will take a simple intrusive container, like an intrusive list
([classref boost::intrusive::ilist boost::intrusive::ilist]) for the following
examples, but all [*Boost.Intrusive] containers are very similar.

Every class to be inserted in an intrusive container, needs to contain a hook that
will offer the necessary data and resources to be insertable in the container.
With [*Boost.Intrusive] you just choose the hook to be a public base class or
a public member of the class to be inserted.

For [classref boost::intrusive::ilist ilist], you can publicly derive from 
[classref boost::intrusive::ilist_base_hook ilist_base_hook]. This class takes
three template arguments:

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void *>
   class ilist_base_hook;


*  The first integer template argument serves as a tag, so you can derive from more than one
   [classref boost::intrusive::ilist_base_hook ilist_base_hook] and hence put objects in
   multiple intrusive lists at once. 

*  The second boolean template argument controls the safe mode. If this argument is set to true,
   (the default value) the hook's constructor will initialize the hook to a well known safe state.
   When inserting the class in an intrusive container, the container will check if the hook is in
   the safe state. If that's not the case, it will assert. When erasing the an object from the list
   the container will put the hook in the safe state again. This way, the class can know if it's
   actually inserted in the list.

*  The third template argument is the pointer type. The default value is `void *`, which means
   that raw pointers will be used in the hook. For example, the user can specify
   `boost::interprocess::offset_ptr<void>` to use offset pointers and make its class
   compatible with shared memory intrusive containers.

Once we derive our class from `ilist_base_hook<...>` we have to obtain the `value_traits`
information to configure the intrusive list. Value traits tell the container
the needed information to insert the object in the container (if the hook is
a base or member object, whether is an auto-unlink hook...
To obtain the needed value traits, just use the `value_traits` subtype
[classref boost::intrusive::ilist_base_hook ilist_base_hook]
defines passing the type of the user class an argument:

[c++]

   typedef ilist_base_hook<0, true>::value_traits<Foo> value_traits;

After that, we can define the intrusive list. The intrusive list has the following
template parameters:

[c++]

   template<class ValueTraits, bool ConstantTimeSize = false, class SizeType = std::size_t>
   class ilist;

*  The first template is the value_traits class. Contains information about the value
   to be inserted: the type, the type of hook, the type of the pointers to be used,
   whether the safe mode is being used... 

*  The second boolean template argument specifies if a constant time `size()`
   function is demanded. This will tell the intrusive container to insert an
   additional member in the intrusive container that offers this information.

*  The third template argument specifies the type that will hold
   the size of the container. This type will be the type returned by `ilist.size()`
   and the type stored in the intrusive container if `ConstantTimeSize` is requested.

Let's see an small example:

[import code/doc_how_to_use.cpp]
[doc_how_to_use_code]

If you don't want to derive from a list node, you can add a public data member
`ilist_member_hook<...>` to your class instead.
This class also takes three template parameters:

[c++]

   template<class T, bool SafeMode = true, class VoidPointer = void *>
   class ilist_member_hook;


Example:

[c++]

   class Foo 
   {
      public:
      ilist_member_hook<Foo, true> node_;  
      //...
   };

To obtain the `value_traits` information to configure the list, use the internal
templatized `value_traits` type and pass a pointer to member pointing
to the hook as the template parameter.

[c++]

   //obtain value_traits to configure the list
   typedef ilist_member_hook<Foo, true>::value_traits<&Foo::node_> value_traits;

   //this list will use the data member node_:
   typedef ilist<value_traits> list;

If you use member hooks the program can run slightly slower, because conversions
from the hook to the user class requires pointer adjustements. In constrast, with
only one base hook, there is no pointer adjustment. On the other hand, someone
might not want the 'is-a' relationship between list nodes and 
his own classes. In this case, using the hook as a data member instead of 'disturbing' 
the hierarchy might be the right way.

For intrusive `iset` and `imultiset` containers, only the names are slightly different.
The usage is the same. Example:

[c++]

   class Foo : public iset_base_hook<0, true>	//derive public!
   {
      public:
      iset_member_hook<Foo, true>	node_;  
      //...
   };

   typedef imultiset< iset_base_hook<0, false>::value_traits<Foo> > set0;   
   typedef imultiset< iset_member_hook<Foo, true>::value_traits<&Foo::node> > set1;


Even if the interfaces of [classref boost::intrusive::ilist ilist] and
[classref boost::intrusive::imultiset imultiset] are very familiar, using them is very
different to their respective STL-counterparts. You always have to keep in mind, that 
you store the objects themself in intrusive containers, not copies. The lifetime of a 
stored object is not bound to or managed by the container. When the container gets 
destroyed before the object, nothing special happens to the object.

[endsect]

[section:safe_mode More about the safe mode]

Some hooks have a flag to enable the safe-mode. The safe mode is activated
by default:

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void *>
   class ilist_base_hook;

Thanks to the safe-mode the user can detect without any external reference, if the object
is actually inserted in any sequence. Let's review the basic features of the safe-mode:

*  Hooks' constructors put the hook in a well-known default state.

*  Hooks' destructors checks if the hook in the well-known default state. If not,
   an assertion is raised.

*  Every time an object is being inserted in the intrusive container, the container
   checks if the hook is the well-known default state. If not,
   an assertion is raised.

*  Every time an object is being erased from the intrusive container, the container
   puts the erased object in the well-known default state.

With these features, without any external reference the user can know if the object
has been inserted in any container. If the object is not actually inserted 
in a container, the hook is the default state and if it's inserted in a container, the
hook is not in the default state.

[endsect]

[endsect]

[section:usage_when When to use?]

Intrusive containers can be used for highly optimized algorithms, where speed is a crucial
issue and...

*  additional memory management should be avoided.
*  exception safety, especially the no-throw guarantee, is needed.
*  the computation of an iterator to an element from a pointer or reference.
   to that element should be a constant time operation.
*  it's important to achieve a well-known worst-time system response.
*  localization of data (e.g. for cache hit optimization) leads to measureable effects.

The last point is important, if you have a lot of sequences over a set of elements. E.g. if 
you have a `std::vector<vertex>` forming a polygon and a set of all concave vertices over this 
vector stored in a `std::list<vertex*>`, then dereferencing an `std::list<vertex*>::iterator` 
walks through the memory in two steps: from the iterator (usually on the stack) to the list 
node storing the `vertex*` and finally to the vertex.

While the vertices themselves are tightly packed in the memory and form something like a
data block, the list nodes don't. Furthermore, 
list nodes may be stored independently from the vertex data block anywhere else in the address
space. Hence depending on your system you'll get a lot of cache misses. The same doesn't hold
for an intrusive list. Indeed, dereferencing an an iterator from an intrusive list is performed in
the same two steps as described above. But the list node is already embedded in the vertex, so
the memory is directly tracked from the iterator to the vertex data block. 

It's also possible to use intrusive containers, when the objects to be stored have different
or unknown storage classes as shown in the following example: 

[import code/doc_window.cpp]
[doc_window_code]

Due to certain properties of intrusive containers (dependent class definition, identity
semantics) they are often more difficult to use than their STL-counterparts. That's why you
better avoid them in public interfaces of libraries. Classes stored in intrusive
containers need some public members needed by these containers and hence changing the
underlying implementation could change the public interface of the class definition.
In addtion, the identity semantic of stored objects must be handled very carefully. And
if you don't know, who is going to use your (library) interface, then maybe you better
try to stick with STL containers.

There is a borderline case, where it's rather unclear, if it's a good application for
intrusive lists: let the list 'own' the stored elements. Nothing hinders you to write code
like this: 

[import code/doc_entity.cpp]
[doc_entity_code]

With `std::list<entity>` in-place construction isn't possible and you can't store derived
objects. Apart from that, using `std::list<boost::shared_ptr<entity>>` introduces a level
of indirection - something you won't want sometimes. Of course, you have to be very careful,
since [classref boost::intrusive::ilist ilist] doesn't do any ownership management at its own.

[endsect]

[section:auto_unlink_hooks Auto-unlink hooks]

[section:auto_unlink_hooks_what What's an auto-unlink hook?]

[*Boost.Intrusive] offers additional hooks with unique features:

*  When the destructor of the hook is called, the hook removes itself from the container.
*  The hook has a member function called `unlink_self()` that can be used to unlink the
   node from the container at any moment, without having any reference to the container,
   if the user want to do so.

These hooks have exactly the same size overhead as their non auto-unlinking hooks, but
they have a restriction: they can only be used with non-constant time containers.
There is a reason for this: 
Non constant-time containers don't need to update the internal size member and 
allow removing the object from the container without using
any reference to the container This way, the auto-unlink hooks have the same size as
their non auto-unlink counterparts. Ths auto-unlink feature is useful in certain applications
but must be used [*very carefuly]:

* If several threads are using the same container, removing the object is
  thread-unsafe.

* Container contents change silently without touching the container directly.
  This can lead to surprising effects.

These auto-unlink hooks have also safe-mode properties:

*  Hooks' constructors put the hook in a well-known default state.

*  Every time an object is being inserted in the intrusive container, the container
   checks if the hook is the well-known default state. If not,
   an assertion is raised.

*  Every time an object is being erased from the intrusive container, the container
   puts the erased object in the well-known default state.

[endsect]

[section:auto_unlink_hooks_example Auto-unlink hook example]

Let's see an example of an auto-unlink hook:

[import code/doc_auto_unlink.cpp]
[doc_auto_unlink_code]

[endsect]

[section:auto_unlink_and_constant_time Auto-unlink hooks and constant-time containers]

As explained, [*Boost.Intrusive] auto-unlink hooks are incompatible with
constant-time hooks, so if you try to define a constant-time container with an
auto-unlink hook's value_traits, you will get an static assertion:

[c++]
   
   #include <boost/intrusive/ilist.hpp>

   class MyClass
      :  public boost::intrusive::ilist_auto_base_hook<0>
   {/**/};

   boost::intrusive::ilist <MyClass::value_traits<MyClass>, true> bad_list;

   int main()
   {
      bad_list list;
      return 0;
   }

leads to an error similar to:

[pre
  error : use of undefined type 'boost::STATIC_ASSERTION_FAILURE<false>'
]


Pointing to code like this:

[c++]

   //Constant-time size is incompatible with auto-unlink hooks!
   BOOST_STATIC_ASSERT(!(ConstantTimeSize && ((int)ValueTraits::type == (int)auto_unlink_value_traits)));

This way, there is no way to compile a program if you try to use auto-unlink hooks
in constant-time size containers.

[endsect]

[endsect]

[section:islist Intrusive singly linked list: islist]

[classref boost::intrusive::islist islist] is the simplest intrusive container of
[*Boost.Intrusive]: a circular singly linked list. The memory overhead
that imposes is 1 pointer per node. The size of an empty, non constant-time size 
[classref boost::intrusive::islist islist], is the size of 1 pointer. This
lightweight memory overhead comes with its drawbacks, though: many operations have
linear time complexity, even some that usually are constant time, like
[classref boost::intrusive::islist::swap swap]. 

[classref boost::intrusive::islist islist]
does not provide bidirectional iterators and thus, it provides only forward iterators.

For the most cases, a doubly linked list is preferrable, but for some applications, for
example, when constructing more elaborated containers, singly linked lists are essential
because of their low size overhead.

[section:islist_hooks islist hooks]

Like the rest of [*Boost.Intrusive] containers, [classref boost::intrusive::islist islist] has several hook types:

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void*>
   class islist_base_hook;

*  [classref boost::intrusive::islist_base_hook islist_base_hook]:
   the user class derives publicly from
   [classref boost::intrusive::islist_base_hook islist_base_hook] to make
   it [classref boost::intrusive::islist islist]-compatible.

[c++]

   template<class T, bool SafeMode = true, class VoidPointer = void*>
   class islist_member_hook;

*  [classref boost::intrusive::islist_member_hook islist_member_hook]:
   the user class contains a public 
   [classref boost::intrusive::islist_member_hook islist_member_hook] to make
   it [classref boost::intrusive::islist islist]-compatible.

[c++]

   template<int Tag, class VoidPointer = void*>
   class islist_auto_base_hook;

*  [classref boost::intrusive::islist_auto_base_hook islist_auto_base_hook]:
   the user class derives publicly from
   [classref boost::intrusive::islist_auto_base_hook islist_auto_base_hook]
   to make it [classref boost::intrusive::islist islist]-compatible.
   This hook is an auto-unlink hook.

[c++]

   template<class T, class VoidPointer = void*>
   class islist_auto_member_hook;

*  [classref boost::intrusive::islist_auto_member_hook islist_auto_member_hook]:
   the user class contains a public
   [classref boost::intrusive::islist_auto_member_hook islist_auto_member_hook]
   to make it [classref boost::intrusive::islist islist]-compatible.
   This hook is an auto-unlink hook.

[endsect]

[section:islist_container islist container]

[classref boost::intrusive::islist islist] receives 3 template parameters:

[c++]

   template<class ValueTraits, bool ConstantTimeSize = false, class SizeType = std::size_t>
   class islist;

*  The first template is the value_traits class. Contains information about the
   value to be inserted: the type, the type of hook, the type of the pointers to
   be used, whether the safe mode is being used... 

*  The second boolean template argument specifies if a constant time `size()`
   function is demanded. This will tell the intrusive container to insert an
   additional member in the intrusive container that offers this information.

*  The third template argument specifies the type that will hold
   the size of the container. This type will be the type returned by `ilist.size()`
   and the type stored in the intrusive container if `ConstantTimeSize` is requested.

[endsect]

[section:islist_example Example]

Now let's see an small example using the first two hooks:

[import code/doc_islist.cpp]
[doc_islist_code]

[endsect]

[endsect]

[section:ilist Intrusive doubly linked list: ilist]

[classref boost::intrusive::ilist ilist] is the preferred intrusive list container of [*Boost.Intrusive]: a
circular doubly linked list. The memory overhead
that imposes is 2 pointers per node. An empty, non constant-time size [classref boost::intrusive::ilist ilist]
has also the size of 2 pointers. [classref boost::intrusive::ilist ilist] has many more constant-time operations
than [classref boost::intrusive::islist islist] and it's the intrusive equivalent of the standard `std::list` container.

[section:ilist_hooks ilist hooks]

Like the rest of [*Boost.Intrusive] containers, [classref boost::intrusive::ilist ilist] has several hook types:

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void*>
   class ilist_base_hook;

*  [classref boost::intrusive::ilist_base_hook ilist_base_hook]: the user class derives publicly from [classref boost::intrusive::ilist_base_hook ilist_base_hook] to make
   it [classref boost::intrusive::ilist ilist]-compatible.

[c++]

   template<class T, bool SafeMode = true, class VoidPointer = void*>
   class ilist_member_hook;

*  [classref boost::intrusive::ilist_member_hook ilist_member_hook]: 
   the user class contains a public 
   [classref boost::intrusive::ilist_member_hook ilist_member_hook] to make
   it [classref boost::intrusive::ilist ilist]-compatible.

[c++]

   template<int Tag, class VoidPointer = void*>
   class ilist_auto_base_hook;

*  [classref boost::intrusive::ilist_auto_base_hook ilist_auto_base_hook]: 
   the user class derives publicly from 
   [classref boost::intrusive::ilist_auto_base_hook ilist_auto_base_hook]
   to make it [classref boost::intrusive::ilist ilist]-compatible.
   This hook is an auto-unlink hook.

[c++]

   template<class T, class VoidPointer = void*>
   class ilist_auto_member_hook;

*  [classref boost::intrusive::ilist_auto_member_hook ilist_auto_member_hook]: the user class contains a public [classref boost::intrusive::ilist_auto_member_hook ilist_auto_member_hook]
   to make it [classref boost::intrusive::ilist ilist]-compatible.
   This hook is an auto-unlink hook.

[endsect]

[section:ilist_container ilist container]

[classref boost::intrusive::ilist ilist] receives 3 template parameters:

[c++]

   template<class ValueTraits, bool ConstantTimeSize = false, class SizeType = std::size_t>
   class ilist;

*  The first template is the value_traits class. Contains information about the
   value to be inserted: the type, the type of hook, the type of the pointers to
   be used, whether the safe mode is being used... 

*  The second boolean template argument specifies if a constant time `size()`
   function is demanded. This will tell the intrusive container to insert an
   additional member in the intrusive container that offers this information.

*  The third template argument specifies the type that will hold
   the size of the container. This type will be the type returned by `ilist.size()`
   and the type stored in the intrusive container if `ConstantTimeSize` is requested.

[endsect]

[section:ilist_example Example]

Now let's see an small example using the first two hooks:

[import code/doc_ilist.cpp]
[doc_ilist_code]

[endsect]

[endsect]

[section:iset_imultiset Intrusive associative containers: iset, imultiset]

[*Boost.Intrusive] also offers associative containers that can be very useful
when creating more complex associative containers, like multi-index containers.
The memory overhead of these containers is usually 3 pointers and an integer. If
pointers have 2 byte alignment (which is usually true in most systems),
[*Boost.Intrusive] optimizes this overhead to 3 pointers.

An empty, non constant-time size [classref boost::intrusive::iset iset] or [classref boost::intrusive::imultiset imultiset]
has also the size of 3 pointers and an integer (3 pointers when optimized).
[classref boost::intrusive::iset iset] and [classref boost::intrusive::imultiset imultiset] have logarithmic complexity in many operations like
searches, insertions, erasures, etc... [classref boost::intrusive::iset iset] and [classref boost::intrusive::imultiset imultiset] are the
intrusive equivalents of standard `std::set` and `std::multiset` containers.

[section:iset_imultiset_hooks iset and imultiset hooks]

[classref boost::intrusive::iset iset] and [classref boost::intrusive::imultiset imultiset] share the same hooks. This is an advantage, because the same
user type can be inserted first in a [classref boost::intrusive::imultiset imultiset] and after that in [classref boost::intrusive::iset iset] without
changing the definition of the user class.

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void*>
   class iset_base_hook;

*  [classref boost::intrusive::iset_base_hook iset_base_hook]: the user class derives publicly from [classref boost::intrusive::iset_base_hook iset_base_hook] to make
   it [classref boost::intrusive::iset iset]/[classref boost::intrusive::imultiset imultiset]-compatible.

[c++]

   template<class T, bool SafeMode = true, class VoidPointer = void*>
   class iset_member_hook;

*  [classref boost::intrusive::iset_member_hook iset_member_hook]: the user class contains a public [classref boost::intrusive::iset_member_hook iset_member_hook] to make
   it [classref boost::intrusive::iset iset]/[classref boost::intrusive::imultiset imultiset]-compatible.

[c++]

   template<int Tag, class VoidPointer = void*>
   class iset_auto_base_hook;

*  [classref boost::intrusive::iset_auto_base_hook iset_auto_base_hook]: the user class derives publicly from [classref boost::intrusive::iset_auto_base_hook iset_auto_base_hook]
   to make it [classref boost::intrusive::iset iset]/[classref boost::intrusive::imultiset imultiset]-compatible.
   This hook is an auto-unlink hook.

[c++]

   template<class T, class VoidPointer = void*>
   class iset_auto_member_hook;

*  [classref boost::intrusive::iset_auto_member_hook iset_auto_member_hook]: the user class contains a public [classref boost::intrusive::iset_auto_member_hook iset_auto_member_hook]
   to make it [classref boost::intrusive::iset iset]/[classref boost::intrusive::imultiset imultiset]-compatible.
   This hook is an auto-unlink hook.

[endsect]

[section:iset_imultiset_containers iset and imultiset containers]

[classref boost::intrusive::iset iset] and
[classref boost::intrusive::imultiset imultiset] receive 4 template parameters:

[c++]

   template < class ValueTraits
            , class Compare          = std::less<typename ValueTraits::value_type>
            , bool  ConstantTimeSize = false
            , class SizeType         = std::size_t >
   class iset;

   template < class ValueTraits
            , class Compare          = std::less<typename ValueTraits::value_type>
            , bool  ConstantTimeSize = false
            , class SizeType         = std::size_t >
   class imultiset;

*  The first template is the value_traits class. Contains information about the
   value to be inserted: the type, the type of hook, the type of the pointers to
   be used, whether the safe mode is being used... 

*  The second template is the ordering function of the associative container.
   By default, the ordering function is `std::less<...>` of the user value. 

*  The third boolean template argument specifies if a constant time `size()`
   function is demanded. This will tell the intrusive container to insert an
   additional member in the intrusive container that offers this information.

*  The fourth template argument specifies the type that will hold
   the size of the container. This type will be the type returned by `ilist.size()`
   and the type stored in the intrusive container if `ConstantTimeSize` is requested.

[endsect]

[section:iset_imultiset_example Example]

Now let's see an small example using the first two hooks and both containers:

[import code/doc_iset.cpp]
[doc_iset_code]

[endsect]

[section:iset_imultiset_advanced_lookups_insertions iset and imultiset advanced
   lookups and insertions]

[*Boost.Intrusive] offers the same interface as `std::set` and `std::multiset` for
[classref boost::intrusive::iset iset] and [classref boost::intrusive::imultiset imultiset] but also offers some enhancements. It's known that there is a
performance penalty in the STL interface when doing lookups in `std::set` and `std::multiset`
and the contained type is expensive to construct. For example:

[import code/doc_iset_optimized_code.cpp]
[doc_iset_optimized_code_normal_find]

`ExpensiveClass` is an expensive object to construct. Maybe "key" c-string is quite long
and `ExpensiveClass` has to construct a long `std::string` to contain the key inside. Like
`ExpensiveClass`, many times the only member taking part in ordering issues is just
a small part of the class. For example, with `ExpensiveClass`, only the internal
`std::string` is needed to compare the object.

If we call `get_object` in a loop, we might get a performance penalty, because we are forced
to create a whole `ExpensiveClass` object to be able to find an equivalent one. To solve this,
[*Boost.Intrusive] containers offers an alternative lookup function, which takes any type
comparable with the value and a comparison functor that should be compatible with the
ordering function of the associative container:

[doc_iset_optimized_code_optimized_find]

This new arbitrary key overload is also available for other functions: `equal_range`,
`lower_bound`, `upper_bound`, `count`... Check [classref boost::intrusive::iset] and
[classref boost::intrusive::imultiset] references to know more about those functions.

[classref boost::intrusive::iset iset] also has two new insertion functions to be able to check efficiently, without
constructing the value, if a value is present and insert it inmediatelly without any
further lookup. Using the same `ExpensiveClass` class, this function can be inefficient:

[doc_iset_optimized_code_normal_insert]

If the object is already present, we are constructing an `ExpensiveClass` that
will be discarded, and this is a waste of resources. Instead of that, let's use
`insert_check` and `insert_commit` functions:

[doc_iset_optimized_code_optimized_insert]

`insert_check` is similar to a normal `insert` but:

*  `insert_check` can be used with arbitrary keys
*  if the insertion is possible (there is no equivalent value) collects all the needed information
in an `insert_commit_data` structure, so that `insert_commit` does not execute further comparisons 
and can be executed with constant-time complexity (and no-throw guarantee).

These functions must be used with care, since
no other insertion or erasure must be executed between an `insert_check` and an `insert_commit`
pair. Otherwise, the results are undefined. 

`insert_check` and `insert_commit` will come handy
for developers programming non-intrusive associative containers (multi-index containers, for
example) that want to obtain maximum performance. See [classref boost::intrusive::iset]
reference for more information about `insert_check` and `insert_commit`.

[endsect]

[endsect]

[section:ihashset_ihashmultiset Pseudo-Intrusive unordered associative containers: ihashset, ihashmultiset]

[*Boost.Intrusive] also offers hashed containers that can be very useful develop
fast-lookup intrusive containers.  These containers
([classref boost::intrusive::ihashset ihashset] and [classref boost::intrusive::ihashmultiset ihashmultiset])
are pseudo-intrusive containers: they need additional memory apart from the hook
that the value_type of the container must add as a base or member. This additional
memory must be passed in the constructor of the container.

Unlike C++ TR1 `unordered_set` family containers (which are also hashed containers),
the contents of this pseudo-intrusive containers are not rehashed to maintain a
load factor: that would require memory management and intrusive containers don't
implement any memory management at all. However, the user can request an explicit
rehashing passing a new bucket array.


[section:ihashset_ihashmultiset_implementation_notes Implementation notes and differences with TR1 unordered containers]

[*Boost.Intrusive] hashed associative containers are implemented like an array
of singly linked lists. When an element is inserted in the container, it's hashed
using the configured hash function. Then the container calculates the bucket
(the singly linked list) where the value should be inserted using the modulo
operation between the hash value and the length of the bucket array:

[c++]

   size_type bucket_number = hash(value) % bucket_len;

Since no automatic rehashing is done by the container, all the iterators to
non-erased elements remain valid after insertions and erasures (the end(),
iterator also remains valid). After rehashing, all iterators might be
invalidated (including the end() iterator).

[*Boost.Intrusive] hashed containers need four arguments to be passed in their
constructors: A pointer to an array of elements whose type is called `bucket_type`,
the length of that array, the hash function to be used with the values and an
equality functor for those values:

[c++]

   template< class ValueTraits
           , class Hash             = boost::hash<typename ValueTraits::value_type>
           , class Equal            = std::equal_to<typename ValueTraits::value_type>
           , bool  ConstantTimeSize = false
           , class SizeType         = std::size_t
           >
   class ihashset
   {
      // ...

      typedef /*implementation defined*/ bucket_type;
      typedef /*implementation defined*/ bucket_ptr;
      typedef /*implementation defined*/ size_type;

      //Constructor
      ihashset ( bucket_ptr   buckets
               , size_type    buckets_len
               , const Hash  &hasher = Hash()
               , const Equal &equal  = Equal()) ;

      // ...
   };

Each hashed container needs [*its own bucket array]. Two hashed containers
[*can't] shared the same bucket_type elements. The bucket array [*must] be
destroyed [*after] the container using it is destroyed, otherwise, the result
is undefined.

[endsect]

[section:ihashset_ihashmultiset_performance ihashset and ihashmultiset performance notes]

The size overhead for a hashed container is moderate: 1 pointer per value plus
the bucket array per container. The size of an element of the bucket array
is usually one pointer. To obtain a good performance hashed container,
the bucket length is usually the same as the number of elements that the
container contains, so well-balanced hashed container (`bucket_count()` is 
equal to `size()` ) will have an equivalent overhead of two pointers per element.

An empty, non constant-time size [classref boost::intrusive::ihashset ihashset] or
[classref boost::intrusive::ihashmultiset ihashmultiset]
has also the size of `bucket_count()` pointers. 

Insertions, erasures, and searches, have amortized constant-time complexity in
hashed containers. However, some worst-case guarantees are linear. See
[classref boost::intrusive::ihashset ihashset] or
[classref boost::intrusive::ihashmultiset ihashmultiset] for complexity guarantees
of each operation.

[*Be careful with non constant-time size hashed containers]: some operations, like
`empty()`, have linear complexity, unlike other [*Boost.Intrusive] containers.

[endsect]

[section:ihashset_ihashmultiset_hooks ihashset and ihashmultiset hooks]

[classref boost::intrusive::ihashset ihashset] and [classref boost::intrusive::ihashmultiset ihashmultiset] share the same hooks. This is an advantage, because the same
user type can be inserted first in a [classref boost::intrusive::ihashmultiset ihashmultiset] and after that in [classref boost::intrusive::ihashset ihashset] without
changing the definition of the user class.

[c++]

   template<int Tag, bool SafeMode = true, class VoidPointer = void*>
   class ihashset_base_hook;

*  [classref boost::intrusive::ihashset_base_hook ihashset_base_hook]: the user class derives publicly from [classref boost::intrusive::ihashset_base_hook ihashset_base_hook] to make
   it [classref boost::intrusive::ihashset ihashset]/[classref boost::intrusive::ihashmultiset ihashmultiset]-compatible.

[c++]

   template<class T, bool SafeMode = true, class VoidPointer = void*>
   class ihashset_member_hook;

*  [classref boost::intrusive::ihashset_member_hook ihashset_member_hook]: the user class contains a public [classref boost::intrusive::ihashset_member_hook ihashset_member_hook] to make
   it [classref boost::intrusive::ihashset ihashset]/[classref boost::intrusive::ihashmultiset ihashmultiset]-compatible.

[c++]

   template<int Tag, class VoidPointer = void*>
   class ihashset_auto_base_hook;

*  [classref boost::intrusive::ihashset_auto_base_hook ihashset_auto_base_hook]: the user class derives publicly from [classref boost::intrusive::ihashset_auto_base_hook ihashset_auto_base_hook]
   to make it [classref boost::intrusive::ihashset ihashset]/[classref boost::intrusive::ihashmultiset ihashmultiset]-compatible.
   This hook is an auto-unlink hook.

[c++]

   template<class T, class VoidPointer = void*>
   class ihashset_auto_member_hook;

*  [classref boost::intrusive::ihashset_auto_member_hook ihashset_auto_member_hook]: the user class contains a public [classref boost::intrusive::ihashset_auto_member_hook ihashset_auto_member_hook]
   to make it [classref boost::intrusive::ihashset ihashset]/[classref boost::intrusive::ihashmultiset ihashmultiset]-compatible.
   This hook is an auto-unlink hook.

[endsect]

[section:ihashset_ihashmultiset_containers ihashset and ihashmultiset containers]

[classref boost::intrusive::ihashset ihashset] and
[classref boost::intrusive::ihashmultiset ihashmultiset] receive 4 template parameters:

[c++]

   template< class ValueTraits
         , class Hash             = boost::hash<typename ValueTraits::value_type>
         , class Equal            = std::equal_to<typename ValueTraits::value_type>
         , bool  ConstantTimeSize = false
         , class SizeType         = std::size_t
         >
   class ihashset;

   template< class ValueTraits
         , class Hash             = boost::hash<typename ValueTraits::value_type>
         , class Equal            = std::equal_to<typename ValueTraits::value_type>
         , bool  ConstantTimeSize = false
         , class SizeType         = std::size_t
         >
   class ihashmultiset;

*  The first template is the value_traits class. Contains information about the
   value to be inserted: the type, the type of hook, the type of the pointers to
   be used, whether the safe mode is being used... 

*  The second template is the hash function of the associative container.
   It takes a value_type argument and returns a std::size_t.
   By default, the hash function is `boost::hash<...>` of the user value. 

*  The third template is the equality function of the associative container.
   By default, the equality function is `std::equal_to<...>` of the user value. 

*  The fourth boolean template argument specifies if a constant time `size()`
   function is demanded. This will tell the intrusive container to insert an
   additional member in the intrusive container that offers this information.
   [*Be careful with non constant-time size() hashed containers] since they
   have a linear complexity (`empty()`) function.

*  The fifth template argument specifies the type that will hold
   the size of the container. This type will be the type returned by `ilist.size()`
   and the type stored in the intrusive container if `ConstantTimeSize` is requested.

[endsect]

[section:ihashset_ihashmultiset_example Example]

Now let's see an small example using the first two hooks and both containers:

[import code/doc_ihashset.cpp]
[doc_ihashset_code]

[endsect]

[section:ihashset_ihashmultiset_advanced_lookups_insertions ihashset and ihashmultiset advanced
   lookups and insertions]

[*Boost.Intrusive] offers the same interface as `std::tr1::unordered_set` and 
`std::tr1::unordered_multiset` for
[classref boost::intrusive::ihashset ihashset] and
[classref boost::intrusive::ihashmultiset ihashmultiset]
but also offers some enhancements. It's known that there is a
performance penalty in the STL interface when doing lookups in
`std::unordered_set` and `std::unordered_multiset`
and the contained type is expensive to construct. For example:

[import code/doc_ihashset_optimized_code.cpp]
[doc_ihashset_optimized_code_normal_find]

`ExpensiveClass` is an expensive object to construct.
Maybe "key" c-string is quite long
and `ExpensiveClass` has to construct a long `std::string` to contain the key inside.
Like `ExpensiveClass`, many times the only member taking part in ordering issues is just
a small part of the class. For example, with `ExpensiveClass`, only the internal
`std::string` is needed to compare the object.

If we call `get_object` in a loop, we might get a performance penalty, because we are forced
to create a whole `ExpensiveClass` object to be able to find an equivalent one. To solve this,
[*Boost.Intrusive] containers offers an alternative lookup function, which takes any type
that can be hashed and tested for equality with the value, and a hash and an equality functor
that should be compatible with the hash and equality functors stored in the
container:

[doc_ihashset_optimized_code_optimized_find]

This new arbitrary key overload is also available for other functions: `equal_range`,
`find`, `erase`, `count`... Check [classref boost::intrusive::ihashset] and
[classref boost::intrusive::ihashmultiset] references to know more about those functions.

Like [classref boost::intrusive::iset iset], 
[classref boost::intrusive::ihashset ihashset] also has two new insertion functions to be able to check efficiently, without
constructing the value, if a value is present and insert it inmediatelly without any
further lookup. Using the same `ExpensiveClass` class, this function can be inefficient:

[doc_ihashset_optimized_code_normal_insert]

If the object is already present, we are constructing an `ExpensiveClass` that
will be discarded, and this is a waste of resources. Instead of that, let's use
`insert_check` and `insert_commit` functions:

[doc_ihashset_optimized_code_optimized_insert]

`insert_check` is similar to a normal `insert` but:

*  `insert_check` can be used with arbitrary keys
*  if the insertion is possible (there is no equivalent value) collects all the needed information
in an `insert_commit_data` structure, so that `insert_commit` does not execute further comparisons 
and can be executed with constant-time complexity (and no-throw guarantee).

These functions must be used with care, since no other insertion or erasure must be
executed between an `insert_check` and an `insert_commit`
pair. Otherwise, the results are undefined. 

`insert_check` and `insert_commit` will come handy
for developers programming non-intrusive containers (multi-index containers, for
example) that want to obtain maximum performance. See [classref boost::intrusive::ihashset]
reference for more information about `insert_check` and `insert_commit`.

[endsect]

[endsect]

[section:sequence_algorithms Sequence algorithms with custom NodeTraits]

As explained in the [link intrusive.concepts Concepts] section, [*Boost.Intrusive]
containers are implemented using sequence algorithms that work on generic nodes.

Instead of using [*Boost.Intrusive] containers, a user might want to develop
customized containers, for example, using nodes that are optimized for an specific application or that are compatible
with a a legacy ABI. A user might want
to have only two additional pointers in his class and insert the class in a doubly linked
list sometimes and in a singly linked list in other situations. You can't achieve this using
[*Boost.Intrusive] hooks.

[*Boost.Intrusive] can also be used for these tasks, since sequence algorithms are
available to be used with custom node types. All sequence algorithm classes are
templatized by a `NodeTraits` class. This class capsulates the needed internal
type declarations and operations to make the user code. Each sequence type has its
own requirements:

[section:islist_algorithms Intrusive singly linked list algorithms]

These algorithms are static
members of the [classref boost::intrusive::slist_algorithms slist_algorithms] class:

[c++]

   template<class NodeTraits>
   struct slist_algorithms;

An empty sequence is formed by a node whose pointer to the next node point
to itself. [classref boost::intrusive::slist_algorithms slist_algorithms]
is configured with a NodeTraits class, which capsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:

[*Typedefs]:

*  `node`: The type of the node that forms the circular list

*  `void_pointer`: The type of pointer of the node (usually void*)

[*Static functions]:

*  `static node_ptr get_next(const_node_ptr n);`:
   Returns a pointer to the next node stored in "n".

*  `static void set_next(node_ptr n, node_ptr next);`:
   Sets the pointer to the next node stored in "n" to "next".

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:

[import code/doc_slist_algorithms.cpp]
[doc_slist_algorithms_code]

For a complete list of functions see
[classref boost::intrusive::slist_algorithms slist_algorithms reference].

[endsect]

[section:ilist_algorithms Intrusive doubly linked list algorithms]

These algorithms are static
members of the [classref boost::intrusive::list_algorithms list_algorithms] class:

[c++]

   template<class NodeTraits>
   struct list_algorithms;

An empty sequence is formed by a node whose pointer to the next node point
to itself. [classref boost::intrusive::list_algorithms list_algorithms]
is configured with a NodeTraits class, which capsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:

[*Typedefs]:

*  `node`: The type of the node that forms the circular list

*  `void_pointer`: The type of pointer of the node (usually void*)

[*Static functions]:

*  `static node_ptr get_next(const_node_ptr n);`:
   Returns a pointer to the next node stored in "n".

*  `static void set_next(node_ptr n, node_ptr next);`:
   Sets the pointer to the next node stored in "n" to "next".

*  `static node_ptr get_previous(const_node_ptr n);`:
   Returns a pointer to the previous node stored in "n".

*  `static void set_previous(node_ptr n, node_ptr prev);`:
   Sets the pointer to the previous node stored in "n" to "prev".

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:

[import code/doc_list_algorithms.cpp]
[doc_list_algorithms_code]

For a complete list of functions see
[classref boost::intrusive::list_algorithms list_algorithms reference].

[endsect]

[section:rbtree_algorithms Intrusive red-black tree algorithms]

These algorithms are static
members of the [classref boost::intrusive::rbtree_algorithms rbtree_algorithms] class:

[c++]

   template<class NodeTraits>
   struct rbtree_algorithms;

An empty sequence is formed by a node whose pointer to the next node point
to itself. [classref boost::intrusive::rbtree_algorithms rbtree_algorithms]
 is configured with a NodeTraits class, which capsulates 
the information about the node to be manipulated. NodeTraits must support the
following interface:

[*Typedefs]:

*  `node`: The type of the node that forms the circular rbtree

*  `void_pointer`: The type of pointer of the node (usually void*)

*  `color`: The type that can store the color of a node

[*Static functions]:

*  `static node_ptr get_parent(const_node_ptr n);`:
   Returns a pointer to the parent node stored in "n".

*  `static void set_parent(node_ptr n, node_ptr p);`:
   Sets the pointer to the parent node stored in "n" to "p".

*  `static node_ptr get_left(const_node_ptr n);`:
   Returns a pointer to the left node stored in "n".

*  `static void set_left(node_ptr n, node_ptr l);`:
   Sets the pointer to the left node stored in "n" to "l".

*  `static node_ptr get_right(const_node_ptr n);`:
   Returns a pointer to the right node stored in "n".

*  `static void set_right(node_ptr n, node_ptr r);`:
   Sets the pointer to the right node stored in "n" to "r".

*  `static color get_color(const_node_ptr n);`:
   Returns the color stored in "n".

*  `static void set_color(node_ptr n, color c);`:
   Sets the color stored in "n" to "c".

*  `static color black();`:
   Returns a value representing the black color of node.

*  `static color red();`:
   Returns a value representing the red color of node.

Once we have a node traits configuration we can use [*Boost.Intrusive] algorithms
with our nodes:

[import code/doc_rbtree_algorithms.cpp]
[doc_rbtree_algorithms_code]


For a complete rbtree of functions see
[classref boost::intrusive::rbtree_algorithms rbtree_algorithms reference].

[endsect]

[endsect]

[section:value_traits Containers with custom ValueTraits]

As explained in the [link intrusive.concepts Concepts] section, [*Boost.Intrusive]
containers are templatized using a `ValueTraits` template parameter that contains
all the information to glue the user class and the node to be used in sequence algorithms.

[section:value_traits_interface ValueTraits interface]

Each [*Boost.Intrusive] container needs a different `ValueTraits` configuration class, but
all `ValueTraits` have the same interface:

[c++]

   struct my_value_traits
   {
      typedef implementation_defined node_traits;

      typedef implementation_defined value_type;

      enum {   type = some_value_traits_type   };

      static node_traits::node * to_node_ptr (value_type& v);

      static const node_traits::node * to_node_ptr (const value_type& v);

      static value_type * to_value_ptr(node_traits::node *n);

      static const value_type * to_value_ptr(const node_traits::node *n);
   };

Let's explain each type and function:

*  ['node_traits]: The node configuration that it's needed by sequence algorithms. These are
   described in the previous chapter: [link intrusive.sequence_algorithms Sequence Algorithms].

   *  If my_value_traits is meant to be used with islist, the `node_traits` should follow
      the interface needed by [classref boost::intrusive::slist_algorithms slist_algorithms].

   *  If my_value_traits is meant to be used with ilist, the `node_traits` should follow
      the interface needed by [classref boost::intrusive::list_algorithms list_algorithms].

   *  If my_value_traits is meant to be used with iset/imultiset, the `node_traits` should follow
      the interface needed by [classref boost::intrusive::rbtree_algorithms rbtree_algorithms].

*  ['value_type]: The type that the user wants to insert in the container. This type can be
   the same as `node_traits::node` but it can be different (for example, `node_traits::node`
   can be a member type of `value_type`). If `value_type` and `node_traits::node` are the
   same type, the `to_node_ptr` and `to_value_ptr` functions are trivial.

*  ['type]: Indicates that `value_traits` needs some additional work or checks from the
   container. The types are enumerations defined in the `value_traits_type.hpp` header.
   These are the possible types:

   *  `normal_value_traits`: This value_traits does not need any treatment in containers
   *  `safe_mode_value_traits`: This value_traits needs the container to check if the
      nodes are default initialized by the user before inserting them, and tells the 
      container to default initialize the nodes after erasing them from the container.
   *  `auto_unlink_value_traits`: Same as "safe_mode_value_traits" but the user type 
      is an auto-unlink type, so it's not compatible with non constant-time size containers,
      and the container might be modified without using its public interface.

*  ['static node_traits::node * to_node_ptr (value_type& v)] and
   ['static const node_traits::node * to_node_ptr (const value_type& v)]:
   These function take a reference to a value_type and return a pointer to the node
   to be used with sequence algorithms.

*  ['static value_type * to_value_ptr (node_traits::node *n)] and
   ['static const value_type * to_value_ptr (const node_traits::node *n)]:
   These function take a pointer to a node and return a pointer to the value
   that contains the node.

[endsect]

[section:value_traits_example Custom ValueTraits example]

Let's define our own `value_traits` class to be able to use [*Boost.Intrusive]
containers with our custom types. We will create a doubly linked list
value_traits:

[import code/doc_value_traits.cpp]
[doc_value_traits_code]


As seen, several key elements of [*Boost.Intrusive], can be reused with custom user types,
if the user does not want to use provided [*Boost.Intrusive] facilities.

[endsect]

[endsect]

[section:design_notes Design Notes]

When designing [*Boost.Intrusive] the following guidelines have been taken in care:

[section: Boost.Intrusive in performance sensitive environments]

[*Boost.Intrusive] should be a valuable tool in performance sensitive environments
and following this guideline, [*Boost.Intrusive] has been designed to offer well
known complexity guarantees. Apart from that, some options, like optional 
constant-time, have been designed to offer faster complexity guarantees in some
functions, like `slist::splice`.

The advanced lookup and insertion functions for associative containers, taking
an arbitrary key type and predicates, were designed to avoid unnecessary object
constructions.

[endsect]

[section: Boost.Intrusive in space constricted environments]

[*Boost.Intrusive] should be useful in space constricted environments
and following this guideline, [*Boost.Intrusive] separates sequence algorithms
and intrusive containers to avoid instantiating sequence algorithms for each
user type. For example, a single class of red-black algorithms will be instantiated
to implement all iset and imultiset containers using raw pointers. This way,
[*Boost.Intrusive] wants to avoid any code size overhead associated with templates.

Apart from that, [*Boost.Intrusive] implements some size improvements: for example,
red-black trees embed the color bit in the parent pointer lower bit, if nodes
are two-byte aligned. The possibility to avoid constant-time size operations can
save some size on containers, and this extra size optimization is noticeable
when the container is empty or contains few values.

[endsect]

[section: Boost.Intrusive as basic building block]

[*Boost.Intrusive] should be a basic building block to build more complex containers
and this guideline has motivated many design decisions. For example, the possibility
to have more than one hook per user type opens the possibility to implement multi-index
containers on top of [*Boost.Intrusive].

[*Boost.Intrusive] also offers advanced
functions taking function objects to ease the inmplementation of non-intrusive
containers on top of intrusive containers without knowing the internals of the
intrusive container.

[endsect]

[section: Expanding Boost.Intrusive]

[*Boost.Intrusive] offers a wide-range of containers but also allows the
construction of custom containers reusing [*Boost.Intrusive] elements.
The programer might want to use sequence algorithms directly or
build its own hooks to take advantage of its application environment.

For example, the programmer might want to save some space creating a hook that
can be used with singly linked list or doubly linked list intrusive containers,
because the programmer might know that the object won't be inserted at the same
time in both containers.

[endsect]

[endsect]

[section:acknowledgments Acknowledgments]

[*Olaf Krzikalla] would like to thank:

*  [*Markus Schaaf] for pointing out the possibility and the advantages of the derivation 
approach. 

*  [*Udo Steinbach] for encouragements to present this work for boost, a lot of fixes and
helpful discussions. 

*  [*Jaap Suter] for the initial hint, which eventually leads to the member value_traits.

[*Ion Gaztanaga] would like to thank [*Olaf Krzikalla] for the permission to
continue his great work.

[endsect]

[xinclude intrusive_doxygen.boostbook]

[section:license_notices License notices]

The internal implementation of red-black trees is based on that of SGI STL stl_tree.h file:

Copyright (c) 1996,1997 Silicon Graphics Computer Systems, Inc. 
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. Silicon Graphics makes no representations about the suitability of this software for any purpose. It is provided "as is" without express or implied warranty. 

Copyright (c) 1994 Hewlett-Packard Company 
Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. Hewlett-Packard Company makes no representations about the suitability of this software for any purpose. It is provided "as is" without express or implied warranty. 

[endsect]


