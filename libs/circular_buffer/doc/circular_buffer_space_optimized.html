<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

    <title>Space Optimized Circular Buffer Container Adaptor</title>
  </head>
  <body bgcolor="#ffffff">
    <h1>Space Optimized Circular Buffer Container Adaptor</h1>
    <table id="title" border="0">
      <tr>
<td>
                    <h1>circular_buffer_space_optimized&lt;T, Alloc&gt;</h1>
                </td>
                <td><a href="../../../"><img height="86" src="../../../c++boost.gif" width="277" border="0" alt="Boost"></a></td>
            </tr>
    </table>
    <h2>Contents</h2>
<a href="#description">Description</a><br>
            <a href="#synopsis">Synopsis</a><br>
            <a href="#rationale">Rationale</a><br>
            <a href="#header">Header files</a><br>
            <a href="#model">Modeled concepts</a><br>
            <a href="#members">Template Parameters, Members and Standalone
                Functions</a><br>
            <a href="#semantics">Semantics</a><br>
            <a href="#see">See also</a><br>
            <a href="#ack">Acknowledgments</a>
    <h2>
      <a name="description">Description</a>
    </h2>
    <p>The <code>circular_buffer_space_optimized</code> container is an adaptor of the <code>
                <a href="circular_buffer.html">circular_buffer</a></code>. The
            functionality of the <code>circular_buffer_space_optimized</code> is similar to
            the base <code>circular_buffer</code> except it does not allocate memory at
            once when created rather it allocates memory as needed. (The predictive memory
            allocation is similar to typical <code>std::vector</code> implementation.)
            Moreover the memory is automatically freed as the size of the container
            decreases.
        </p>
    <table id="figure" border="0">
      <tr>
<td></td>
                <td><img height="350" src="circular_buffer_space_optimized.png" width="700" alt="Space Optimized Circular Buffer"></td>
            </tr>
      <tr>
<td valign="top"><b>Figure:</b></td>
                <td valign="top">The memory allocation process of the space optimized circular
                    buffer. The <code>min_capacity</code> represents the minimal guaranteed amount
                    of allocated memory. The allocated memory will never drop under this value. By
                    default the <code>min_capacity</code> is set to 0.
                </td>
            </tr>
    </table>
    <br>
    <h2>
      <a name="synopsis">Synopsis</a>
    </h2>
    <div id="srcdoc_synopsis">
      <table id="table_synopsis" border="0" cellpadding="10">
        <tr>
          <td>
            <pre>
namespace boost {

template &lt;class <a href="circular_buffer.html#templateparam_T">T</a>, class <a href="circular_buffer.html#templateparam_Alloc">Alloc</a>&gt;
class circular_buffer_space_optimized
{
public:
   typedef Alloc <a href="circular_buffer.html#classboost_1_1circular__buffer_1w0">allocator_type</a>;
   typedef <i>implementation-defined</i> <a href="circular_buffer.html#classboost_1_1circular__buffer_1w1">const_iterator</a>;
   typedef typename Alloc::const_pointer <a href="circular_buffer.html#classboost_1_1circular__buffer_1w2">const_pointer</a>;
   typedef typename Alloc::const_reference <a href="circular_buffer.html#classboost_1_1circular__buffer_1w3">const_reference</a>;
   typedef <i>implementation-defined</i> <a href="circular_buffer.html#classboost_1_1circular__buffer_1w4">const_reverse_iterator</a>;
   typedef typename Alloc::difference_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1w5">difference_type</a>;
   typedef <i>implementation-defined</i> <a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a>;
   typedef typename Alloc::pointer <a href="circular_buffer.html#classboost_1_1circular__buffer_1w8">pointer</a>;
   typedef typename Alloc::reference <a href="circular_buffer.html#classboost_1_1circular__buffer_1w9">reference</a>;
   typedef <i>implementation-defined</i> <a href="circular_buffer.html#classboost_1_1circular__buffer_1w11">reverse_iterator</a>;
   typedef typename Alloc::size_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a>;
   typedef typename Alloc::value_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1w13">value_type</a>;

   template &lt;class InputIterator&gt;
      <a href="#classboost_1_1circular__buffer__space__optimized_1a3">circular_buffer_space_optimized</a>(size_type capacity,
         size_type min_capacity, InputIterator first,
         InputIterator last, const allocator_type&amp; alloc = allocator_type());
   <a href="#classboost_1_1circular__buffer__space__optimized_1a4">circular_buffer_space_optimized</a>(size_type capacity,
      size_type min_capacity, value_type item,
      const allocator_type&amp; alloc = allocator_type());
   explicit <a href="#classboost_1_1circular__buffer__space__optimized_1a5">circular_buffer_space_optimized</a>(size_type capacity,
      size_type min_capacity = 0, const allocator_type&amp; alloc = allocator_type());

   template &lt;class InputIterator&gt;
      void <a href="circular_buffer.html#classboost_1_1circular__buffer_1a0">assign</a>(InputIterator first, InputIterator last);
   void <a href="circular_buffer.html#classboost_1_1circular__buffer_1a1">assign</a>(size_type n, value_type item);
   value_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1a2">at</a>(size_type index) const;
   reference <a href="circular_buffer.html#classboost_1_1circular__buffer_1a3">at</a>(size_type index);
   value_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1a4">back</a>() const;
   reference <a href="circular_buffer.html#classboost_1_1circular__buffer_1a5">back</a>();
   const_iterator <a href="circular_buffer.html#classboost_1_1circular__buffer_1a6">begin</a>() const;
   iterator <a href="circular_buffer.html#classboost_1_1circular__buffer_1a7">begin</a>();
   size_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1a8">capacity</a>() const;
   void <a href="circular_buffer.html#classboost_1_1circular__buffer_1a13">clear</a>();
   pointer <a href="circular_buffer.html#classboost_1_1circular__buffer_1a14">data</a>();
   bool <a href="circular_buffer.html#classboost_1_1circular__buffer_1a15">empty</a>() const;
   const_iterator <a href="circular_buffer.html#classboost_1_1circular__buffer_1a16">end</a>() const;
   iterator <a href="circular_buffer.html#classboost_1_1circular__buffer_1a17">end</a>();
   iterator <a href="#classboost_1_1circular__buffer__space__optimized_1a7">erase</a>(iterator first, iterator last);
   iterator <a href="#classboost_1_1circular__buffer__space__optimized_1a8">erase</a>(iterator pos);
   value_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1a20">front</a>() const;
   reference <a href="circular_buffer.html#classboost_1_1circular__buffer_1a21">front</a>();
   bool <a href="circular_buffer.html#classboost_1_1circular__buffer_1a22">full</a>() const;
   allocator_type&amp; <a href="circular_buffer.html#classboost_1_1circular__buffer_1a23">get_allocator</a>();
   allocator_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1a24">get_allocator</a>() const;
   template &lt;class InputIterator&gt;
      void <a href="#classboost_1_1circular__buffer__space__optimized_1a10">insert</a>(iterator pos, InputIterator first, InputIterator last);
   void <a href="#classboost_1_1circular__buffer__space__optimized_1a11">insert</a>(iterator pos, size_type n, value_type item);
   iterator <a href="#classboost_1_1circular__buffer__space__optimized_1a12">insert</a>(iterator pos);
   iterator <a href="#classboost_1_1circular__buffer__space__optimized_1a13">insert</a>(iterator pos, value_type item);
   size_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1a29">max_size</a>() const;
   size_type <a href="#classboost_1_1circular__buffer__space__optimized_1a15">min_capacity</a>() const;
   circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; <a href="circular_buffer.html#classboost_1_1circular__buffer_1a30">operator=</a>(const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; cb);
   value_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1a31">operator[]</a>(size_type index) const;
   reference <a href="circular_buffer.html#classboost_1_1circular__buffer_1a32">operator[]</a>(size_type index);
   void <a href="#classboost_1_1circular__buffer__space__optimized_1a19">pop_back</a>();
   void <a href="#classboost_1_1circular__buffer__space__optimized_1a20">pop_front</a>();
   void <a href="#classboost_1_1circular__buffer__space__optimized_1a21">push_back</a>();
   void <a href="#classboost_1_1circular__buffer__space__optimized_1a22">push_back</a>(value_type item);
   void <a href="#classboost_1_1circular__buffer__space__optimized_1a23">push_front</a>();
   void <a href="#classboost_1_1circular__buffer__space__optimized_1a24">push_front</a>(value_type item);
   const_reverse_iterator <a href="circular_buffer.html#classboost_1_1circular__buffer_1a39">rbegin</a>() const;
   reverse_iterator <a href="circular_buffer.html#classboost_1_1circular__buffer_1a40">rbegin</a>();
   const_reverse_iterator <a href="circular_buffer.html#classboost_1_1circular__buffer_1a41">rend</a>() const;
   reverse_iterator <a href="circular_buffer.html#classboost_1_1circular__buffer_1a42">rend</a>();
   void <a href="circular_buffer.html#classboost_1_1circular__buffer_1a43">resize</a>(size_type new_size, value_type item = T(), bool remove_front = true);
   template &lt;class InputIterator&gt;
      void <a href="#classboost_1_1circular__buffer__space__optimized_1a26">rinsert</a>(iterator pos, InputIterator first, InputIterator last);
   void <a href="#classboost_1_1circular__buffer__space__optimized_1a27">rinsert</a>(iterator pos, size_type n, value_type item);
   iterator <a href="#classboost_1_1circular__buffer__space__optimized_1a28">rinsert</a>(iterator pos);
   iterator <a href="#classboost_1_1circular__buffer__space__optimized_1a29">rinsert</a>(iterator pos, value_type item);
   void <a href="#classboost_1_1circular__buffer__space__optimized_1a30">set_capacity</a>(size_type new_capacity, bool remove_front = true);
   void <a href="#classboost_1_1circular__buffer__space__optimized_1a31">set_min_capacity</a>(size_type new_min_capacity);
   size_type <a href="circular_buffer.html#classboost_1_1circular__buffer_1a49">size</a>() const;
   void <a href="circular_buffer.html#classboost_1_1circular__buffer_1a50">swap</a>(circular_buffer_space_optimized&amp; cb);
};

template &lt;class T, class Alloc&gt;
   bool <a href="circular_buffer.html#namespaceboost_1a9">operator!=</a>(const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; lhs,
      const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href="circular_buffer.html#namespaceboost_1a8">operator&lt;</a>(const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; lhs,
      const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href="circular_buffer.html#namespaceboost_1a11">operator&lt;=</a>(const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; lhs,
      const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href="circular_buffer.html#namespaceboost_1a7">operator==</a>(const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; lhs,
      const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href="circular_buffer.html#namespaceboost_1a10">operator&gt;</a>(const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; lhs,
      const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   bool <a href="circular_buffer.html#namespaceboost_1a12">operator&gt;=</a>(const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; lhs,
      const circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; rhs);
template &lt;class T, class Alloc&gt;
   void <a href="circular_buffer.html#namespaceboost_1a13">swap</a>(circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; lhs,
      circular_buffer_space_optimized&lt;T,Alloc&gt;&amp; rhs);

} // namespace boost
</pre>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="rationale">Rationale</a>
    </h2>
    <p>The auto-resizing mode of the space optimized circular buffer can be useful in
            situations when the container can possibly store large number of elements but
            most of its lifetime the container stores just few of them. The usage of the <code>circular_buffer_space_optimized</code>
            will result in decreased memory consumption and can improve the CPU cache
            effectiveness.
        </p>
    <h2>
      <a name="header">Header files</a>
    </h2>
    <p>
            The <code>circular_buffer_space_optimized</code> is defined in the file
      <code><a href="../../../boost/circular_buffer.hpp">boost/circular_buffer.hpp</a></code>.
      There is also a forward declaration for the <code>circular_buffer_space_optimized</code> in the header file
      <code><a href="../../../boost/circular_buffer_fwd.hpp">boost/circular_buffer_fwd.hpp</a></code>.
        </p>
    <h2>
      <a name="model">Modeled concepts</a>
    </h2>
    <p><a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random Access
                Container</a>, <a href="http://www.sgi.com/tech/stl/FrontInsertionSequence.html">
                Front Insertion Sequence</a>, <a href="http://www.sgi.com/tech/stl/BackInsertionSequence.html">
                Back Insertion Sequence</a>, <a href="http://www.sgi.com/tech/stl/Assignable.html">
                Assignable</a> (SGI specific), <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">
                Equality Comparable</a>, <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">
                LessThan Comparable</a> (SGI specific)
        </p>
    <h2>
      <a name="members">Template Parameters, Members and Friend Functions</a>
    </h2>
    <p>Template parameters, members and friend functions of the <code>circular_buffer_space_optimized</code>
            are almost the same as for the base <code>circular_buffer</code>. Refer the <code>circular_buffer</code>
            <a href="circular_buffer.html#parameters">documentation</a> and also its <a href="srcdoc/index.html">
                source code documentation</a> for a detailed description.
        </p>
    <p>The specific methods of the <code>circular_buffer_space_optimized</code> are
            listed below.
        </p>
    <h2>
      <a name="constructors">Constructors</a>
    </h2>
    <div id="srcdoc_constructors">
      <table id="table_constructors" border="1">
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a3"></a>
            <code>
              <b>
      template &lt;class InputIterator&gt;<br>   
    circular_buffer_space_optimized(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> capacity, <br>   
         <a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> min_capacity, InputIterator first, <br>   
         InputIterator last, const <a href="circular_buffer.html#classboost_1_1circular__buffer_1w0">allocator_type</a>&amp; alloc = allocator_type());</b>
            </code>
            <br>
            <table id="table_function_desc_id4507775">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4507916"><tr><td>
Create a space optimized circular buffer with a copy of a range.         </td></tr></table>
<table id="table_pre_desc_id4508013"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>capacity &gt;= min_capacity</code> and valid range <code>[first, last)</code>. </td>
</tr></table>
<table id="table_post_desc_id4508026"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<a href="circular_buffer.html#classboost_1_1circular__buffer_1a8">capacity()</a> == capacity</code><br>
 Allocates at least as much memory as specified by the <code>min_capacity</code> parameter.<br>
 If the number of items to copy from the range <code>[first, last)</code> is greater than the specified <code>capacity</code> then only elements from the range <code>[last - capacity, last)</code> will be copied. </td>
</tr></table>
<table id="table_note_desc_id4508109"><tr>
<td valign="top"><b>Note:</b></td>
<td>It is considered as a bug if the precondition is not met (i.e. if <code>capacity &lt; min_capacity</code>) and an assertion will be invoked in the debug mode. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a4"></a>
            <code>
              <b>circular_buffer_space_optimized(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> capacity, <br>   
      <a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> min_capacity, <a href="circular_buffer.html#classboost_1_1circular__buffer__space__optimized_1w12">value_type</a> item, <br>   
      const <a href="circular_buffer.html#classboost_1_1circular__buffer_1w0">allocator_type</a>&amp; alloc = allocator_type());</b>
            </code>
            <br>
            <table id="table_function_desc_id4508178">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4508297"><tr><td>
Create a full space optimized circular buffer filled with copies of <code>item</code>.         </td></tr></table>
<table id="table_pre_desc_id4508380"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>capacity &gt;= min_capacity</code> </td>
</tr></table>
<table id="table_post_desc_id4508390"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<a href="#classboost_1_1circular__buffer_1a49">size()</a> == capacity &amp;&amp; (*this)[0] == (*this)[1] == ... == (*this).<a href="#classboost_1_1circular__buffer_1a5">back()</a> == item</code> </td>
</tr></table>
<table id="table_note_desc_id4508459"><tr>
<td valign="top"><b>Note:</b></td>
<td>It is considered as a bug if the precondition is not met (i.e. if <code>capacity &lt; min_capacity</code>) and an assertion will be invoked in the debug mode. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a5"></a>
            <code>
              <b>explicit circular_buffer_space_optimized(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> capacity, <br>   
      <a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> min_capacity = 0, const <a href="circular_buffer.html#classboost_1_1circular__buffer_1w0">allocator_type</a>&amp; alloc = allocator_type());</b>
            </code>
            <br>
            <table id="table_function_desc_id4508514">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4508620"><tr><td>
Create an empty space optimized circular buffer with a given capacity.         </td></tr></table>
<table id="table_pre_desc_id4508684"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>capacity &gt;= min_capacity</code> </td>
</tr></table>
<table id="table_post_desc_id4508694"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<a href="circular_buffer.html#classboost_1_1circular__buffer_1a8">capacity()</a> == capacity &amp;&amp; (*this).size == 0</code><br>
 Allocates memory specified by the <code>min_capacity</code> parameter. </td>
</tr></table>
<table id="table_note_desc_id4508744"><tr>
<td valign="top"><b>Note:</b></td>
<td>It is considered as a bug if the precondition is not met (i.e. if <code>capacity &lt; min_capacity</code>) and an assertion will be invoked in the debug mode. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="methods">Public Member Functions</a>
    </h2>
    <div id="srcdoc_methods">
      <table id="table_methods" border="1">
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a7"></a>
            <code>
              <b><a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> erase(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> first, <a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> last);</b>
            </code>
            <br>
            <table id="table_function_desc_id4508929">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4509011"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a8"></a>
            <code>
              <b><a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> erase(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> pos);</b>
            </code>
            <br>
            <table id="table_function_desc_id4509098">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4509163"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a10"></a>
            <code>
              <b>
      template &lt;class InputIterator&gt;<br>   
    void insert(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> pos, InputIterator first, InputIterator last);</b>
            </code>
            <br>
            <table id="table_function_desc_id4509381">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4509477"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a11"></a>
            <code>
              <b>void insert(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> pos, <a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> n, <a href="circular_buffer.html#classboost_1_1circular__buffer__space__optimized_1w12">value_type</a> item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4509551">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4509642"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a12"></a>
            <code>
              <b><a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> insert(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> pos);</b>
            </code>
            <br>
            <table id="table_function_desc_id4509730">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4509794"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a13"></a>
            <code>
              <b><a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> insert(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> pos, <a href="circular_buffer.html#classboost_1_1circular__buffer__space__optimized_1w12">value_type</a> item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4509868">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4509950"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a15"></a>
            <code>
              <b><a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> min_capacity() const;</b>
            </code>
            <br>
            <table id="table_function_desc_id4510129">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4510171"><tr><td>
Return the minimal guaranteed amount of allocated memory.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a19"></a>
            <code>
              <b>void pop_back();</b>
            </code>
            <br>
            <table id="table_function_desc_id4510566">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4510607"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a20"></a>
            <code>
              <b>void pop_front();</b>
            </code>
            <br>
            <table id="table_function_desc_id4510681">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4510722"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a21"></a>
            <code>
              <b>void push_back();</b>
            </code>
            <br>
            <table id="table_function_desc_id4510797">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4510838"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a22"></a>
            <code>
              <b>void push_back(<a href="circular_buffer.html#classboost_1_1circular__buffer__space__optimized_1w12">value_type</a> item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4510898">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4510957"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a23"></a>
            <code>
              <b>void push_front();</b>
            </code>
            <br>
            <table id="table_function_desc_id4511030">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4511071"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a24"></a>
            <code>
              <b>void push_front(<a href="circular_buffer.html#classboost_1_1circular__buffer__space__optimized_1w12">value_type</a> item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4511131">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4511190"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a26"></a>
            <code>
              <b>
      template &lt;class InputIterator&gt;<br>   
    void rinsert(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> pos, InputIterator first, InputIterator last);</b>
            </code>
            <br>
            <table id="table_function_desc_id4511485">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4511581"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a27"></a>
            <code>
              <b>void rinsert(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> pos, <a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> n, <a href="circular_buffer.html#classboost_1_1circular__buffer__space__optimized_1w12">value_type</a> item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4511655">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4511746"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a28"></a>
            <code>
              <b><a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> rinsert(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> pos);</b>
            </code>
            <br>
            <table id="table_function_desc_id4511833">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4511898"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a29"></a>
            <code>
              <b><a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> rinsert(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w6">iterator</a> pos, <a href="circular_buffer.html#classboost_1_1circular__buffer__space__optimized_1w12">value_type</a> item);</b>
            </code>
            <br>
            <table id="table_function_desc_id4511972">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4512053"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
The rules for iterator invalidation differ from the original <a href="#classboost_1_1circular__buffer">circular_buffer</a>. See the <a href="../circular_buffer_adaptor.html#invalidation">documentation</a>.         </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a30"></a>
            <code>
              <b>void set_capacity(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> new_capacity, bool remove_front = true);</b>
            </code>
            <br>
            <table id="table_function_desc_id4512154">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4512227"><tr><td>
! See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
<table id="table_pre_desc_id4512246"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>(*this).<a href="#classboost_1_1circular__buffer__space__optimized_1a15">min_capacity()</a> &lt;= new_capacity</code> </td>
</tr></table>
<table id="table_note_desc_id4512264"><tr>
<td valign="top"><b>Note:</b></td>
<td>It is considered as a bug if the precondition is not met (i.e. if <code>new_capacity &gt; (*this).<a href="#classboost_1_1circular__buffer__space__optimized_1a15">min_capacity()</a></code>) and an assertion will be invoked in the debug mode. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a31"></a>
            <code>
              <b>void set_min_capacity(<a href="circular_buffer.html#classboost_1_1circular__buffer_1w12">size_type</a> new_min_capacity);</b>
            </code>
            <br>
            <table id="table_function_desc_id4512343">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4512395"><tr><td>
Change the minimal guaranteed amount of allocated memory.         </td></tr></table>
<table id="table_pre_desc_id4512406"><tr>
<td valign="top"><b>Precondition:</b></td>
<td>
<code>(*this).<a href="circular_buffer.html#classboost_1_1circular__buffer_1a8">capacity()</a> &gt;= new_min_capacity</code> </td>
</tr></table>
<table id="table_post_desc_id4512424"><tr>
<td valign="top"><b>Postcondition:</b></td>
<td>
<code>(*this).<a href="#classboost_1_1circular__buffer__space__optimized_1a15">min_capacity()</a> == new_min_capacity</code> Allocates memory specified by the <code>new_min_capacity</code> parameter. </td>
</tr></table>
<table id="table_note_desc_id4512448"><tr>
<td valign="top"><b>Note:</b></td>
<td>It is considered as a bug if the precondition is not met (i.e. if <code>new_min_capacity &gt; (*this).<a href="circular_buffer.html#classboost_1_1circular__buffer_1a8">capacity()</a></code>) and an assertion will be invoked in the debug mode. </td>
</tr></table>        </td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>
            <a name="classboost_1_1circular__buffer__space__optimized_1a32"></a>
            <code>
              <b>void swap(circular_buffer_space_optimized&amp; cb);</b>
            </code>
            <br>
            <table id="table_function_desc_id4512526">
              <tr>
                <td>   </td>
                <td>
<table id="table_detailed_desc_id4512580"><tr><td>
See the <a href="#classboost_1_1circular__buffer">circular_buffer</a> source documentation.         </td></tr></table>
        </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </div>
    <h2>
      <a name="semantics">Semantics</a>
    </h2>
    <p>The behaviour of memory auto-resizing is as follows:
        </p>
    <ul>
<li>
                Minimal capacity is allocated when an empty <code>circular_buffer_space_optimized</code>
            is created.
            </li>
<li>
                When a non-empty <code>circular_buffer_space_optimized</code>
            container is created the allocated memory reflects the size of the container.
            </li>
<li>
                <code>push_back</code>, <code>push_front</code>, <code>insert</code> and <code>rinsert</code>
                will predictively increase the allocated memory if necessary. (The predictive
                memory allocation is similar to <code>std::vector</code>.)
            </li>
<li>
                <code>set_capacity</code>, <code>resize</code>, <code>assign</code>, <code>insert</code>
                (range or n items), <code>rinsert</code> (range or n items), <code>erase</code>
                (range) and <code>clear</code>
            will accommodate the allocated memory as necessary.
            </li>
<li>
                <code>pop_back</code>, <code>pop_front</code>, <code>erase</code> and <code>clear</code>
                will predictively decrease the allocated memory.
            </li>
        </ul>
    <p>The semantics of the <code>circular_buffer_space_optimized</code> then follows
            the <a href="circular_buffer.html#semantics">semantics</a> of the base <code>circular_buffer</code>
            except the invalidation rules.
        </p>
    <p><a name="invalidation"></a>The rule for iterator invalidation for <code>circular_buffer_space_optimized</code>
            is as follows:
        </p>
    <ul>
<li>
                <code>data</code>, <code>set_capacity</code>, <code>resize</code>, <code>operator=</code>,
                <code>assign</code>, <code>swap</code>, <code>push_back</code>, <code>push_front</code>,
                <code>pop_back</code>, <code>pop_front</code>, <code>insert</code>, <code>rinsert</code>,
                <code>erase</code> and <code>clear</code> invalidate all iterators pointing to
                the <code>circular_buffer_space_optimized</code>.
            </li>
        </ul>
    <h2>
      <a name="see">See also</a>
    </h2>
    <p><code><a href="circular_buffer.html">boost::circular_buffer</a>, <a href="http://www.sgi.com/tech/stl/Vector.html">
                    std::vector</a></code>
        </p>
    <h2>
      <a name="ack">Acknowledgments</a>
    </h2>
    <p>The idea of the space optimized circular buffer has been introduced by Pavel
            Vozenilek.
        </p>
    <hr align="left" size="1">
    <table id="footer" border="0" width="100%">
      <tr>
<td align="left" valign="top"><small>Copyright © 2003-2005 <a href="mailto:jano_gaspar%5Bat%5Dyahoo.com">Jan Gaspar</a></small></td>
        <td align="right" valign="top">
          <a href="http://validator.w3.org/check?url=http://www.boost.org/libs/circular_buffer/doc/circular_buffer_space_optimized.html">
            <img border="0" src="valid-html40.png" alt="Valid HTML 4.0!" height="31" width="88"></a>
        </td>
      </tr>
    </table>
  </body>
</html>
