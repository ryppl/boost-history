<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    
    <title>Templated Circular Buffer Container</title>
  </head>
  <body bgcolor="#ffffff">
    <table id="title" border="0">
      <tr>
<td>
					<h1>Templated Circular Buffer Container</h1>
					<h1>circular_buffer&lt;T, Alloc&gt;</h1>
				</td>
				<td><a href="http://boost.org"><img width="277" height="86" src="../../../c++boost.gif" border="0" alt="Boost"></a></td>
			</tr>
    </table>
    <h3>Contents</h3>
    <dl>
<dd><a href="#description">Description</a></dd>
  		  <dd><a href="#simpleexample">Simple Example</a></dd>
  			<dd><a href="#synopsis">Synopsis</a></dd>
  			<dd><a href="#rationale">Rationale</a></dd>
  			<dd><a href="#header">Header files</a></dd>
  			<dd><a href="#model">Modeled concepts</a></dd>
  			<dd><a href="#parameters">Template Parameters</a></dd>
  			<dd><a href="#types">Public Types</a></dd>
        <dd><a href="#constructors">Constructors / Destructor</a></dd>
        <dd><a href="#methods">Public Member Functions</a></dd>
  			<dd><a href="#functions">Standalone Functions</a></dd>
  			<dd><a href="#semantics">Semantics</a></dd>
  			<dd><a href="#caveats">Caveats</a></dd>
  			<dd><a href="#debug">Debug Support</a></dd>
  			<dd><a href="#example">Example</a></dd>
  			<dd><a href="#notes">Notes</a></dd>
  			<dd><a href="#see">See also</a></dd>
  			<dd><a href="#ack">Acknowledgments</a></dd>
  		</dl>
    <table id="figure" border="0" align="right">
      <tr>
<td><img width="300" height="332" src="circular_buffer.png" alt="Circular Buffer"></td>
  			</tr>
      <tr>
<td width="300">
  					<table id="figure_desc" align="right" border="0" cellpadding="5"><tr>
<td valign="top"><b>Figure:</b></td>
  							<td valign="top">The circular buffer (for someone known as ring or cyclic buffer).</td>
  						</tr></table>
</td>
  			</tr>
    </table>
    <h3>
      <a name="description">Description</a>
    </h3>
    <p>The <code>circular_buffer</code> container provides fixed capacity storage with 
			constant time insertion and removal of elements at each end of a circular 
			buffer. When the capacity of the <code>circular_buffer</code> is exhausted, 
			inserted elements will cause elements at the opposite end to be overwritten (see the Figure).
			The <code>circular_buffer</code> only allocates memory when 
			created, when the capacity is adjusted explicitly, or as necessary to 
			accommodate a resizing or assign operation. (There is also a <code><a href="circular_buffer_space_optimized.html">circular_buffer_space_optimized</a>
			</code>available. It is an adaptor of the <code>circular_buffer</code> 
			which does not allocate memory at once when created rather it allocates memory as needed.)
		</p>
    <h3>
      <a name="simpleexample">Simple Example</a>
    </h3>
    <p>A brief example using the <code>circular_buffer</code>:
		</p>
    <pre>   #include &lt;boost/circular_buffer.hpp&gt;

   int main(int argc, char* argv[]) {

      // Create a circular buffer with capacity for 3 integers.
      boost::circular_buffer&lt;int&gt; cb(3);

      cb.push_back(1);  // Insert the first element.
      cb.push_back(2);  // Insert the second element.
      cb.push_back(3);  // Insert the third element.

      // The buffer is full now, pushing subsequent
      // elements will overwrite the front-most elements.
      
      cb.push_back(4);  // Overwrite 1 with 4.
      cb.push_back(5);  // Overwrite 2 with 5.

      // The buffer now contains 3, 4 and 5.
      int a = cb[0];  // a == 3
      int b = cb[1];  // b == 4
      int c = cb[2];  // c == 5

      // Elements can be popped from either the front or back.

      cb.pop_back();  // 5 is removed.
      cb.pop_front(); // 3 is removed.

      int d = cb[0];  // d == 4

      return 0;
   }
</pre>
    <h3>
      <a name="synopsis">Synopsis</a>
    </h3>
    <div id="srcdoc_synopsis">
      <table border="0" cellpadding="5">
        <tr>
          <td></td>
          <td>
            <pre>
namespace boost {

template &lt;class T, class Alloc&gt;
class circular_buffer
{
public:
   typedef Alloc <a href="#classboost_1_1circular__buffer_1w0">allocator_type</a>;
   typedef <i>implementation-defined</i> <a href="#classboost_1_1circular__buffer_1w1">const_iterator</a>;
   typedef typename Alloc::const_pointer <a href="#classboost_1_1circular__buffer_1w2">const_pointer</a>;
   typedef typename Alloc::const_reference <a href="#classboost_1_1circular__buffer_1w3">const_reference</a>;
   typedef <i>implementation-defined</i> <a href="#classboost_1_1circular__buffer_1w4">const_reverse_iterator</a>;
   typedef typename Alloc::difference_type <a href="#classboost_1_1circular__buffer_1w5">difference_type</a>;
   typedef <i>implementation-defined</i> <a href="#classboost_1_1circular__buffer_1w6">iterator</a>;
   typedef typename Alloc::pointer <a href="#classboost_1_1circular__buffer_1w8">pointer</a>;
   typedef typename Alloc::reference <a href="#classboost_1_1circular__buffer_1w9">reference</a>;
   typedef <i>implementation-defined</i> <a href="#classboost_1_1circular__buffer_1w11">reverse_iterator</a>;
   typedef typename Alloc::size_type <a href="#classboost_1_1circular__buffer_1w12">size_type</a>;
   typedef typename Alloc::value_type <a href="#classboost_1_1circular__buffer_1w13">value_type</a>;

   template &lt;class InputIterator&gt;
      <a href="#classboost_1_1circular__buffer_1a9">circular_buffer</a>(size_type capacity, InputIterator first, 
         InputIterator last, const allocator_type&amp; alloc = allocator_type());
   <a href="#classboost_1_1circular__buffer_1a10">circular_buffer</a>(const circular_buffer&lt; T, Alloc &gt; &amp; cb);
   <a href="#classboost_1_1circular__buffer_1a11">circular_buffer</a>(size_type capacity, param_value_type item, 
      const allocator_type&amp; alloc = allocator_type());
   explicit <a href="#classboost_1_1circular__buffer_1a12">circular_buffer</a>(size_type capacity, const allocator_type&amp; alloc = allocator_type());
   <a href="#classboost_1_1circular__buffer_1a51">~circular_buffer</a>();<br>
   template &lt;class InputIterator&gt;
      void <a href="#classboost_1_1circular__buffer_1a0">assign</a>(InputIterator first, InputIterator last);
   void <a href="#classboost_1_1circular__buffer_1a1">assign</a>(size_type n, param_value_type item);
   return_value_type <a href="#classboost_1_1circular__buffer_1a2">at</a>(size_type index) const;
   reference <a href="#classboost_1_1circular__buffer_1a3">at</a>(size_type index);
   return_value_type <a href="#classboost_1_1circular__buffer_1a4">back</a>() const;
   reference <a href="#classboost_1_1circular__buffer_1a5">back</a>();
   const_iterator <a href="#classboost_1_1circular__buffer_1a6">begin</a>() const;
   iterator <a href="#classboost_1_1circular__buffer_1a7">begin</a>();
   size_type <a href="#classboost_1_1circular__buffer_1a8">capacity</a>() const;
   void <a href="#classboost_1_1circular__buffer_1a13">clear</a>();
   pointer <a href="#classboost_1_1circular__buffer_1a14">data</a>();
   bool <a href="#classboost_1_1circular__buffer_1a15">empty</a>() const;
   const_iterator <a href="#classboost_1_1circular__buffer_1a16">end</a>() const;
   iterator <a href="#classboost_1_1circular__buffer_1a17">end</a>();
   iterator <a href="#classboost_1_1circular__buffer_1a18">erase</a>(iterator first, iterator last);
   iterator <a href="#classboost_1_1circular__buffer_1a19">erase</a>(iterator pos);
   return_value_type <a href="#classboost_1_1circular__buffer_1a20">front</a>() const;
   reference <a href="#classboost_1_1circular__buffer_1a21">front</a>();
   bool <a href="#classboost_1_1circular__buffer_1a22">full</a>() const;
   allocator_type &amp; <a href="#classboost_1_1circular__buffer_1a23">get_allocator</a>();
   allocator_type <a href="#classboost_1_1circular__buffer_1a24">get_allocator</a>() const;
   template &lt;class InputIterator&gt;
      void <a href="#classboost_1_1circular__buffer_1a25">insert</a>(iterator pos, InputIterator first, InputIterator last);
   void <a href="#classboost_1_1circular__buffer_1a26">insert</a>(iterator pos, size_type n, param_value_type item);
   iterator <a href="#classboost_1_1circular__buffer_1a27">insert</a>(iterator pos);
   iterator <a href="#classboost_1_1circular__buffer_1a28">insert</a>(iterator pos, param_value_type item);
   size_type <a href="#classboost_1_1circular__buffer_1a29">max_size</a>() const;
   circular_buffer&lt; T, Alloc &gt; &amp; <a href="#classboost_1_1circular__buffer_1a30">operator=</a>(const circular_buffer&lt; T, Alloc &gt; &amp; cb);
   return_value_type <a href="#classboost_1_1circular__buffer_1a31">operator[]</a>(size_type index) const;
   reference <a href="#classboost_1_1circular__buffer_1a32">operator[]</a>(size_type index);
   void <a href="#classboost_1_1circular__buffer_1a33">pop_back</a>();
   void <a href="#classboost_1_1circular__buffer_1a34">pop_front</a>();
   void <a href="#classboost_1_1circular__buffer_1a35">push_back</a>();
   void <a href="#classboost_1_1circular__buffer_1a36">push_back</a>(param_value_type item);
   void <a href="#classboost_1_1circular__buffer_1a37">push_front</a>();
   void <a href="#classboost_1_1circular__buffer_1a38">push_front</a>(param_value_type item);
   const_reverse_iterator <a href="#classboost_1_1circular__buffer_1a39">rbegin</a>() const;
   reverse_iterator <a href="#classboost_1_1circular__buffer_1a40">rbegin</a>();
   const_reverse_iterator <a href="#classboost_1_1circular__buffer_1a41">rend</a>() const;
   reverse_iterator <a href="#classboost_1_1circular__buffer_1a42">rend</a>();
   void <a href="#classboost_1_1circular__buffer_1a43">resize</a>(size_type new_size, param_value_type item = T(), 
      bool remove_front = true);
   template &lt;class InputIterator&gt;
      void <a href="#classboost_1_1circular__buffer_1a44">rinsert</a>(iterator pos, InputIterator first, InputIterator last);
   void <a href="#classboost_1_1circular__buffer_1a45">rinsert</a>(iterator pos, size_type n, param_value_type item);
   iterator <a href="#classboost_1_1circular__buffer_1a46">rinsert</a>(iterator pos);
   iterator <a href="#classboost_1_1circular__buffer_1a47">rinsert</a>(iterator pos, param_value_type item);
   void <a href="#classboost_1_1circular__buffer_1a48">set_capacity</a>(size_type new_capacity, bool remove_front = true);
   size_type <a href="#classboost_1_1circular__buffer_1a49">size</a>() const;
   void <a href="#classboost_1_1circular__buffer_1a50">swap</a>(circular_buffer&amp; cb);
};

   template &lt;class T, class Alloc&gt;
      bool <a href="#base_8hpp_1a8">operator!=</a>(const circular_buffer&lt; T, Alloc &gt; &amp; lhs, const circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      bool <a href="#namespaceboost_1a9">operator!=</a>(const circular_buffer&lt; T, Alloc &gt; &amp; lhs, const circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      bool <a href="#namespaceboost_1a8">operator&lt;</a>(const circular_buffer&lt; T, Alloc &gt; &amp; lhs, const circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      bool <a href="#base_8hpp_1a10">operator&lt;=</a>(const circular_buffer&lt; T, Alloc &gt; &amp; lhs, const circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      bool <a href="#namespaceboost_1a11">operator&lt;=</a>(const circular_buffer&lt; T, Alloc &gt; &amp; lhs, const circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      bool <a href="#namespaceboost_1a7">operator==</a>(const circular_buffer&lt; T, Alloc &gt; &amp; lhs, const circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      bool <a href="#base_8hpp_1a9">operator&gt;</a>(const circular_buffer&lt; T, Alloc &gt; &amp; lhs, const circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      bool <a href="#namespaceboost_1a10">operator&gt;</a>(const circular_buffer&lt; T, Alloc &gt; &amp; lhs, const circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      bool <a href="#base_8hpp_1a11">operator&gt;=</a>(const circular_buffer&lt; T, Alloc &gt; &amp; lhs, const circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      bool <a href="#namespaceboost_1a12">operator&gt;=</a>(const circular_buffer&lt; T, Alloc &gt; &amp; lhs, const circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      void <a href="#base_8hpp_1a12">swap</a>(circular_buffer&lt; T, Alloc &gt; &amp; lhs, circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   template &lt;class T, class Alloc&gt;
      void <a href="#namespaceboost_1a13">swap</a>(circular_buffer&lt; T, Alloc &gt; &amp; lhs, circular_buffer&lt; T, Alloc &gt; &amp; rhs);
   <a href="#base_8hpp_1a7">xicographical_compare</a>(lhs. begin, lhs. end, rhs. begin, rhs. end);
} // namespace boost
</pre>
          </td>
        </tr>
      </table>
    </div>
    <h3>
      <a name="rationale">Rationale</a>
    </h3>
    <p>A contiguous region of memory utilized as a circular buffer has several unique 
			and useful characteristics:
		</p>
    <ol>
<li>
			Fixed memory use and no implicit or unexpected memory allocation.
			</li>
<li>
			Fast constant-time insertion and removal of elements from the front and back.
			</li>
<li>
			Fast constant-time random access of elements.
			</li>
<li>
				Suitability for real-time and performance critical applications.
			</li>
		</ol>
    <p>The <code>circular_buffer</code> container provides a similar interface to <code>std::vector</code>,
			<code>std::deque</code> and <code>std::list</code> including <code>push</code>, <code>
				pop</code>, <code>insert</code>, <code>erase</code>, iterators and 
			compatibility with <code>std</code> algorithms.
		</p>
    <p>Possible applications of the <code>circular_buffer</code> include:
		</p>
    <ul>
<li>
			Storage of the most recently received samples, overwriting the oldest as new 
			samples arrive.
			</li>
<li>
			Efficient fixed capacity FIFO (First In, First Out) queue.
			</li>
<li>
			Efficient fixed capacity LIFO (Last In, First Out) queue.
			</li>
		</ul>
    <p>The design of the <code>circular_buffer</code> container is guided by the 
			following principles:
		</p>
    <ol>
<li>
				Maximum <em>efficiency</em>
			for envisaged applications.
			</li>
      <li>
				Suitable for <em>general purpose</em>
			use.
			</li>
      <li>
				<em>Interoperable</em> with other <code>std</code>
			containers and algorithms.
			</li>
      <li>
				The behaviour of the buffer as <em>intuitive</em>
			as possible.
			</li>
      <li>
				Suitable for <em>specialization</em> by means of adaptors. (The <code><a href="circular_buffer_space_optimized.html">circular_buffer_space_optimized</a>
			</code> is such an example of the adaptor.)
			</li>
      <li>
				Guarantee of <em>basic exception safety</em>.</li>
    </ol>
    <h3>
      <a name="header">Header files</a>
    </h3>
    <p>
			The <code>circular_buffer</code> is defined in the file
      <code><a href="../../../boost/circular_buffer.hpp">boost/circular_buffer.hpp</a></code>.
      There is also a forward declaration for the <code>circular_buffer</code> in the header file
      <code><a href="../../../boost/circular_buffer_fwd.hpp">boost/circular_buffer_fwd.hpp</a></code>.
		</p>
    <h3>
      <a name="model">Modeled concepts</a>
    </h3>
    <p><a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random Access 
				Container</a>, <a href="http://www.sgi.com/tech/stl/FrontInsertionSequence.html">
				Front Insertion Sequence</a>, <a href="http://www.sgi.com/tech/stl/BackInsertionSequence.html">
				Back Insertion Sequence</a>, <a href="http://www.sgi.com/tech/stl/Assignable.html">
				Assignable</a> (SGI specific), <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">
				Equality Comparable</a>, <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">
				LessThan Comparable</a> (SGI specific)
		</p>
    <h3>
      <a name="parameters">Template Parameters</a>
    </h3>
    <table id="template_params" border="1">
      <tr>
<th>
					Parameter</th>
				<th>
					Description</th>
				<th>
					Default</th>
</tr>
      <tr>
<td><code>T</code></td>
				<td>The type of the elements stored in the circular buffer.</td>
				<td> </td>
			</tr>
      <tr>
<td><code>Alloc</code></td>
				<td>The allocator type used for all internal memory management.</td>
				<td><code>std::allocator&lt;T&gt;</code></td>
			</tr>
    </table>
    <br>
    <h3>
      <a name="types">Public Types</a>
    </h3>
    <h3>
      <a name="constructors">Constructors / Destructor</a>
    </h3>
    <h3>
      <a name="methods">Public Member Functions</a>
    </h3>
    <h3>
      <a name="functions">Standalone Functions</a>
    </h3>
    <h3>
      <a name="semantics">Semantics</a>
    </h3>
    <p>The behaviour of insertion for <code>circular_buffer</code> is as follows:
		</p>
    <ul>
<li>
				The capacity of a <code>circular_buffer</code> remains fixed unless adjusted 
				via <code>set_capacity</code> or <code>resize</code>.
			</li>
<li>
				<code>insert</code>
			will overwrite front elements as necessary.
			</li>
<li>
				<code>rinsert</code> will overwrite back elements as necessary.
			</li>
		</ul>
    <p>The behaviour of resizing a <code>circular_buffer</code> is as follows:
		</p>
    <ul>
<li>
				The capacity will be adjusted to accommodate a <code>resize</code>. (The 
				capacity can be only increased, not decreased.)
			</li>
		</ul>
    <p>The behaviour of assigning to a <code>circular_buffer</code> is as follows:
		</p>
    <ul>
<li>
				The capacity will be adjusted to accommodate an <code>assign</code>. (The 
				capacity can be only increased, not decreased.)
			</li>
		</ul>
    <p><a name="invalidation"></a>The rules for iterator (and result of <code>data()</code>) 
			invalidation for <code>circular_buffer</code> are as follows:
		</p>
    <ul>
<li>
				<code>insert</code> at the end of the <code>circular_buffer</code> (including <code>
					push_back</code>) does not invalidate any iterator except the case the 
			iterator points to the overwritten element.
			</li>
<li>
				<code>rinsert</code> at the beginning of the <code>circular_buffer</code> (including
				<code>push_front</code>) does not invalidate any iterator except the case 
			the iterator points to the overwritten element.
			</li>
<li>
				<code>insert</code> in the middle of the <code>circular_buffer</code>
			invalidates iterators pointing to the elements at the insertion point and 
			behind the insertion point. It also invalidates iterators pointing to the 
			overwritten element(s).
			</li>
<li>
				<code>rinsert</code> in the middle of the <code>circular_buffer</code>
			invalidates iterators pointing to the elements before the insertion point and 
			iterators pointing to the overwritten element(s).
			</li>
<li>
				<code>erase</code> at the end of the <code>circular_buffer</code> (including <code>pop_back</code>) 
			invalidates only iterators pointing to the erased element(s).
			</li>
<li>
				<code>pop_front</code>
			invalidates only iterators pointing to the erased element.
			</li>
<li>
				<code>erase</code> at the beginning or in the middle of the <code>circular_buffer</code>
			invalidates iterators pointing to the erased element(s) and iterators pointing 
			to the elements behind the erase point.
			</li>
<li>
				<code>data</code>, <code>set_capacity</code>, <code>resize</code>, <code>operator=</code>,
				<code>assign</code>, <code>swap</code> and <code>clear</code> invalidate all 
				iterators pointing to the <code>circular_buffer</code>.
			</li>
		</ul>
    <p>In addition to the preceding rules the iterators get also invalidated due to 
			overwritting (e.g. iterator pointing to the front-most element gets invalidated 
			when inserting into the full <code>circular_buffer</code>). They get 
			invalidated in that sense they do not point to the same element as before but 
			they do still point to the same <b>valid</b> place in the memory. If you want 
			to rely on this feature you have to turn of the <a href="#debug">Debug Support</a>
			otherwise an assertion will report an error if such invalidated iterator is used.</p>
    <h3>
      <a name="caveats">Caveats</a>
    </h3>
    <p>The <code>circular_buffer</code> should not be used for storing pointers to 
			dynamically allocated objects. When a <code>circular_buffer</code> becomes 
			full, further insertion will overwrite the stored pointers - resulting in a <b>memory 
				leak</b>. One recommend alternative is the use of smart pointers <a href="#1">[1]</a>. 
			(Any container of <code>std::auto_ptr</code> is considered particularly 
			hazardous. <a href="#2">[2]</a>)
		</p>
    <p>Elements inserted near the front of a full <code>circular_buffer</code> can be 
			lost. According to the <a href="#semantics">semantics</a> of <code>insert</code>, 
			insertion overwrites front-most items as necessary - possibly including 
			elements currently being <b>inserted at the front</b> of the buffer. 
			Conversely, <code>push_front</code> to a full <code>circular_buffer</code> is 
			guaranteed to overwrite the back-most element.
		</p>
    <p>Elements inserted near the back of a full <code>circular_buffer</code> can be 
			lost. According to the <a href="#semantics">semantics</a> of <code>rinsert</code>, 
			insertion overwrites front-most items as necessary - possibly including 
			elements currently being <b>inserted at the back</b> of the buffer. Conversely, <code>
				push_back</code> to a full <code>circular_buffer</code> is guaranteed to 
			overwrite the front-most element.
		</p>
    <p>While internals of a <code>circular_buffer</code> are circular, iterators are <b>not</b>. 
			Iterators of a <code>circular_buffer</code> are only valid for the range <code>[begin(), 
				end()]</code>. E.g. iterators <code>(begin() - 1)</code> and <code>(end() + 1)</code>
			are invalid.
		</p>
    <h3>
      <a name="debug">Debug Support</a>
    </h3>
    <p>In order to help a programmer to avoid and find common bugs, the <code>circular_buffer</code>
			contains a kind of debug support.</p>
    <p>
			The <code>circular_buffer</code> maintains a list of valid iterators. As soon 
			as any element gets destroyed all iterators pointing to this element are 
			removed from this list and explicitly invalidated (an invalidation flag is 
			set). The debug support also consists of many assertions (<a href="http://boost.org/libs/utility/assert.html"><code>BOOST_ASSERT</code></a>
			macros) which ensure the <code>circular_buffer</code> and its iterators are 
			used in the correct manner at runtime. In case an invalid iterator is used the 
			assertion will report an error. The connection of explicit iterator 
			invalidation and assertions makes a very robust debug technique which catches 
			most of the errors.</p>
    <p>Moreover, the uninitialized memory allocated by <code>circular_buffer</code> is 
			filled with the value <code>0xcc</code> in the debug mode. This can help the 
			programmer when debugging the code to recognize the initialized memory from the 
			uninitialized. For details refer the <a href="../../../boost/circular_buffer/base.hpp">
				source code</a>.
		</p>
    <p>The debug support is enabled only in the debug mode (when the <code>NDEBUG</code>
			is not defined). It can also be explicitly disabled by defining <code>BOOST_DISABLE_CB_DEBUG</code>
			macro.</p>
    <h3>
      <a name="example">Example</a>
    </h3>
    <p>The following example includes various usage of the <code>circular_buffer</code>.
		</p>
    <pre>   #include &lt;boost/circular_buffer.hpp&gt;
   #include &lt;numeric&gt;
   #include &lt;assert.h&gt;

   int main(int argc, char* argv[])
   {
      // create a circular buffer of capacity 3
      boost::circular_buffer&lt;int&gt; cb(3); 

      // insert some elements into the circular buffer
      cb.push_back(1);
      cb.push_back(2);

      // assertions
      assert(cb[0] == 1);
      assert(cb[1] == 2);
      assert(!cb.full());
      assert(cb.size() == 2);
      assert(cb.capacity() == 3);

      // insert some other elements
      cb.push_back(3);
      cb.push_back(4);

      // evaluate the sum
      int sum = std::accumulate(cb.begin(), cb.end(), 0);

      // assertions
      assert(cb[0] == 2);
      assert(cb[1] == 3);
      assert(cb[2] == 4);
      assert(sum == 9);
      assert(cb.full());
      assert(cb.size() == 3);
      assert(cb.capacity() == 3);
      
      return 0;
   }
</pre>
    <p>The <code>circular_buffer</code> has a capacity of three <code>int</code>. 
			Therefore, the size of the buffer will not exceed three. The <code><a href="http://www.sgi.com/tech/stl/accumulate.html">
					accumulate</a></code> algorithm evaluates the sum of the stored 
			elements. The semantics of the <code>circular_buffer</code> can be inferred from 
			the assertions.
		</p>
    <h3>
      <a name="notes">Notes</a>
    </h3>
    <p><a name="1">[1]</a> A good implementation of smart pointers is included in <a href="http://boost.org/libs/smart_ptr">
				Boost</a>.
		</p>
    <p><a name="2">[2]</a> Never create a circular buffer of <code>std::auto_ptr</code>. 
			Refer to <a href="http://www.aristeia.com">Scott Meyers</a>' excellent book <em>Effective 
				STL</em> for a detailed discussion. (Meyers S., <i>Effective STL: 50 Specific 
				Ways to Improve Your Use of the Standard Template Library</i>. 
			Addison-Wesley, 2001.)
		</p>
    <h3>
      <a name="see">See also</a>
    </h3>
    <p><code><a href="circular_buffer_space_optimized.html">boost::circular_buffer_space_optimized</a>,
				<a href="http://www.sgi.com/tech/stl/Vector.html">std::vector</a>, <a href="http://www.sgi.com/tech/stl/List.html">
					std::list</a>, <a href="http://www.sgi.com/tech/stl/Deque.html">std::deque</a></code>
		</p>
    <h3>
      <a name="ack">Acknowledgments</a>
    </h3>
    <p>I would like to thank the Boost community for help when developing the <code>circular_buffer</code>.</p>
    <p>The <code>circular_buffer</code> has a short history. Its first version was a <code>std::deque</code>
			adaptor. This container was not very effective because of many reallocations 
			when inserting/removing an element. Thomas Wenish did a review of this version 
			and motivated me to create a circular buffer which allocates memory at once 
			when created.</p>
    <p>The second version adapted <code>std::vector</code> but it has been abandoned 
			soon because of limited control over iterator invalidation.</p>
    <p>The current version is a full-fledged STL compliant container. Pavel Vozenilek 
			did a thorough review of this version and came with many good ideas and 
			improvements. Also, I would like to thank Howard Hinnant and Nigel Stewart for 
			valuable comments and ideas. And once again I want to thank Nigel Stewart for 
			this document revision.
		</p>
    <hr align="left" size="1">
    <table id="footer" border="0" width="100%">
      <tr>
<td align="left" valign="top"><small>Copyright © 2003-2005 <a href="mailto:jano_gaspar%5Bat%5Dyahoo.com">Jan Gaspar</a></small></td>
        <td align="right" valign="top">
          <a href="http://validator.w3.org/check?url=http://www.boost.org/circular_buffer/libs/circular_buffer/doc/circular_buffer.html">
            <img border="0" src="valid-html40.bmp" alt="Valid HTML 4.0!" height="31" width="88"></a>
        </td>
      </tr>
    </table>
  </body>
</html>
