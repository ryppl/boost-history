This container is intended to provide the same functionality as std::map and
std::multimap, with a few extra features thrown in.  As you can see, it
provides the same interface as std::map, but to get std::multimap, you have
to specify a special policy.  In fact, this container is heavily policy-based.
Here is the template specification:

template <typename Key, typename Value,
          template <class> class KeyType = UniqueKey,
          class KeyOfValue = StdKeyOfValue<Key, Value>,
          template <typename> class NodeType = NonIndexedNode,
          class Compare = std::less<Key>,
          class Alloc = std::allocator<Value> >
class map;

Understandably, a class with seven template parameters, two of which are
template template parameters is probably going to scare a lot of people at
first glance, and violates the "six parameter rule" of template design (more
than six parameters, and you will scare off most users).  However, a closer
inspection will show that this isn't a very scary template at all.  First,
you have our familiar old friends Key and Value.  These are the only required
parameters, and if you specify nothing but these, you will get a map that
*should* behave just like a std::map with the same parameters.

Next, we have the KeyType parameter.  This just controls whether you get a
map with unique keys, or a multimap.  For multimap behaviour, just specify
the boost::NonUniqueKey policy class, and you essentially have a std::multimap.
Of course, it's unfortunate that if you use any of the later template
parameters, you'll have to specify this one explicitly, even if you want the
default behaviour.

The KeyOfValue parameter is one that appears in many tree implementations on
which std::map is based, but never gets exposed directly by the std::map
interface.  Well, I like it a lot, so I exposed it. ;)  It became a lot more
complicated than I originally intended, but the basic idea is that it allows
you to store a type in which the key is a *part* of the values.  So suppose you
have a class like this:

class Employee
{
    int         ID_;
    std::string Name_;
    std::string SSN_;
    std::string Department_;
public:
    int         ID(void) const { return ID_; }
};

Suppose further that you would like to store several Employees in a map, and be
able to look them up via their ID (which seems reasonable enough).  With a
std::map, you might do something like this:

std::map<int, Employee> Employees;

Unfortunately, this requires you to double-store all the IDs, since you get one
copy in the Employee data structure, and one in the map.  For a map with
thousands of Employees, this can get quite expensive.  The KeyOfValue parameter
allows you to write a functor that uses the ID_ field *inside Employee* as the
map key, thereby making the best use of memory:

struct EmployeeID : boost::CustomKeyOfValue<int, Employee>
{
    int     operator()(Employee const& e) { return e.ID(); }
};

boost::map<int, Employee, boost::UniqueKey, EmployeeID> Employees;

Now, you don't need to double-store the ID_.  Suppose you decided to be clever
and use std::set with a custom Compare functor instead of using map with
KeyOfValue.  You might do something like this:

struct EmployeeCompare : std::binary_function<Employee, Employee, bool>
{
    bool    operator()(Employee const& lhs, Employee const& rhs)
    {
        return lhs.ID() < rhs.ID();
    }
};

std::set<Employee, EmployeeCompare> Employees;

This allows you to store Employees without double-storing the ID, but now you
have a problem when you want to look up an Employee: your find() function
expects a reference to an *Employee*, not an int.  So you have to provide a
bogus Employee instance with just the ID filled in so that you can conduct a
search.  Inconvenient, to say the least.  KeyOfValue gives you the proper
find() semantics.

Now, "What," you might be thinking, "is the NodeType parameter all about?"
Suppose you're displaying Employee records on the company intranet, and a user
clicks on the 30th employee.  Suppose that your UI control only tells you that
it's the 30th row of the data displayed, and nothing more.  Now, you can start
with a begin() iterator, and iterate your way to the 30th item, but that's a
little awkward.  What if you only wish to display 50 records at a time, and
your company has 5,000 employees.  The user clicks on page 20, and you are
obliged to return records 1,000-1,050.  Again, it would be nice if you had
random access indexing.  With std::map, you have no such luck.  By specifying
boost::IndexedNodes, you get two more functions: at() and pos().  The at()
function works a lot like std::vector::at(i): it returns an iterator to the
ith object in sequence, and does bounds checking as well.  It returns an
iterator instead of a value reference because at() returns both the key and the
value, so I decided that it was more like find() than operator[].  Similarly,
pos(key) returns the inorder index of the (first) element matching key.

The original motivation for NodeType was the Win32 virtual listview control.
This control allows you to display an arbitrarily large set of data stored by
the user (instead of the control, as is typical).  However, the listview might
ask for data at any part of your dataset, and may generate a large number of
requests in a short time (such as when the user is scrolling through the data
quickly), demanding a fast indexed lookup (inorder index, not key index).  This
particular application also involved a lot of inserts and deletes, for which
O(n) insert (such as with an associative vector) was not appropriate.  Since
the complexity of at() and pos() is O(log n) (along with insert(), erase(),
and find()), this map provided the best balance of performance for this
application.

Finally, this container is completely independent.  While it was derived heavily
from the HP/SGI/STLport implementation of std::map, it has been fully excised
from STLport.  It should compile on any conforming set of compilers and standard
libraries.  It has been lightly tested on bcc 5.5 and gcc 3.0.  I would
appreciate assistance in testing it more fully and on other platforms not
available to me.

Dave

12/2/2001

