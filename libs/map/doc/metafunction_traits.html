<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<STYLE>
		.code { font-family:monospace; font-size: 10pt }
        H1, H2, H3 { font-family:Verdana, Tahoma, sans-serif; font-weight:0 }
        H1 { font-size: 20pt }
        H2 { font-size: 16pt }
		P { color: black }
		TH { text-align:left }
		A { text-decoration:none }
        A:visited { color: #005E20 }
        A.contact { color: black; text-decoration:none }
		.code { font-family:monospace; font-size: 10pt }
		.headingCode { font-family:monospace; font-size: 12pt }
		.concept { font-weight: bold }
	</STYLE>
</HEAD>
<BODY>

<TABLE BORDER='0' WIDTH='100%'>
<TR>
    <TD WIDTH="*" STYLE='text-align:left'><H1>Metafunction Traits</H1></TD>
    <TD ALIGN=right>
        <TABLE>
            <TR>
                <TD STYLE='text-align:center'><A HREF='../../../index.html'><IMG BORDER=0 SRC='../../../kangaroo.gif'></A></TD>
            </TR>
            <TR>
                <TD ALIGN='center'>
                    <A STYLE='text-align:center;color: black;font: bold italic 12pt/17pt Verdana, sans-serif; text-decoration:none' HREF='../../../index.html'>Metaprogramming<BR>Utilities</A>
                </TD>
            </TR>
        </TABLE>
    </TD>
</TR>
</TABLE>

<H2>Contents</H2>

<DL STYLE='margin-left:1em'>
	<DT>1. <A HREF='#overview'>Overview</A>
	<DT>2. <A HREF='#synopsis'>Synopsis</A>
	<DT>3. <A HREF='#description'>Description</A>
	<DT>4. <A HREF='#example'>Example</A>
	<DT>5. <A HREF='#implementation'>Implementation</A>
	<DT>5. <A HREF='#discussion'>Discussion</A>
	<DT>6. <A HREF='#dependencies'>Dependencies</A>
	<DT>7. <A HREF='#portability'>Portability</A>
	<DT>8. <A HREF='#feedback'>Feedback</A>
</DL>

<A NAME='overview'></A>
<H2>Overview</H2>

<P>
	Metafunction Traits provides three unary boolean-valued MPL <A HREF='http://www.boost.org/libs/mpl/doc/ref/Metafunction.html'>Metafunctions</A> for determining whether an arbitrary type is an MPL <A HREF='http://www.boost.org/libs/mpl/doc/paper/mpl_paper.html#lambda'>lambda expression</A> or model of the concept <A HREF='http://www.boost.org/libs/mpl/doc/ref/Metafunction.html'>Metafunction Class</A>. This allows metafunction classes and lambda expressions to be used polymorphically with non-metaprogramming types. The main application is to reduce the number of lambda expressions required in end-user code. (<I>See</I> <A HREF='#example'>Example</A>.)
</P>

<A NAME='synopsis'></A>
<H2>Synopsis</H2>

From header <A HREF='../../../boost/mpl/is_lambda_expression.hpp'><SPAN CLASS='code'>&lt;boost/mpl/is_lambda_expression.hpp&gt</SPAN></A><B>:</B>

<PRE>    namespace boost {  
      namespace mpl {

        template&lt;typename T&gt;
        struct <B>is_lambda_expression</B> {
            static const bool value = <I>unspecified</I>;
            typedef bool_&lt;value&gt; type;
        };

      } 
    }</PRE>

From header <A HREF='../../../boost/mpl/is_metafunction_class.hpp'><SPAN CLASS='code'>&lt;boost/mpl/is_metafunction_class.hpp&gt</SPAN></A><B>:</B>

<PRE>    namespace boost {  
      namespace mpl {

        template&lt;typename T&gt;
        struct <B>is_metafunction_class</B> {
            static const bool value = <I>unspecified</I>;
            typedef bool_&lt;value&gt; type;
        };

      } 
    }</PRE>

From header <A HREF='../../../boost/mpl/is_metafunction_or_lambda.hpp'><SPAN CLASS='code'>&lt;boost/mpl/is_metafunction_or_lambda.hpp&gt</SPAN></A><B>:</B>

<PRE>    namespace boost {  
      namespace mpl {

        template&lt;typename T&gt;
        struct <B>is_metafunction_or_lambda</B>
            : or_&lt; 
                  is_lambda_expression&lt;T&gt,
                  is_metafunction_class&lt;T&gt
              &gt;
            { };

      } 
    }</PRE>

From header <A HREF='../../../boost/mpl/aux_/has_template_xxx.hpp'><SPAN CLASS='code'>&lt;boost/mpl/aux_/has_template_xxx.hpp&gt</SPAN></A><B>:</B>

<PRE>    #define <B>BOOST_HAS_TEMPLATE_XXX_TRAIT_NAMED_DEF</B> \
        (trait, name, max_arity) <I>unspecified</I>       \
        /**/
    </PRE>


<A NAME='description'></A>
<H2>Description</H2>

<H3><CODE>is_lambda_expression</CODE></H3>
<P>
    The unary metafunction <SPAN CLASS='code'>is_lambda_expression</SPAN> returns <SPAN CLASS='code'>true</SPAN> for types which are either 
    MPL placeholders <SPAN CLASS='code'>_, _1, _2, ... </SPAN> or specialzations of metafunctions other than <A HREF='http://www.boost.org/boost/mpl/protect.hpp'><SPAN CLASS='code'>mpl::protect</SPAN></A> at least one of whose template arguments satisfies <SPAN CLASS='code'>is_lambda_expression</SPAN>. With compilers that don't support template template parameters and partial specialization, <SPAN CLASS='code'>is_lambda_expression</SPAN> always returns false.
</P>

<H3><CODE>is_metafunction_class</CODE></H3>
<P>
    The unary metafunction <SPAN CLASS='code'>is_metafunction_class</SPAN> returns <SPAN CLASS='code'>true</SPAN> for types which are not lambda expressions and which have either a member type named <SPAN CLASS='code'>type</SPAN> or a member class template named <SPAN CLASS='code'>apply</SPAN> with type parameters. With compilers that don't support template template parameters, partial specialization and SFINAE, <SPAN CLASS='code'>is_metafunction_class</SPAN> always returns false.
</P>

<H3><CODE>is_metafunction_or_lambda</CODE></H3>
<P>
    The unary metafunction <SPAN CLASS='code'>is_metafunction_or_lambda</SPAN> is the logical OR of the two preceding metafunctions.<A NAME='#note_1_ref' HREF='#note_1'><SUP>[1]</SUP></A>
</P>

<H3><CODE>BOOST_HAS_TEMPLATE_XXX_TRAIT_NAMED_DEF</CODE></H3>
<P>
    Invoking this macro as follows
<PRE>    BOOST_HAS_TEMPLATE_XXX_TRAIT_NAMED_DEF(trait, name, n) </PRE>
    defines a unary metafunction named <SPAN CLASS='code'>trait</SPAN> returning true for class types having 
    a nested class template named <SPAN CLASS='code'>name</SPAN> with arity less than or equal to 
    <SPAN CLASS='code'>n</SPAN> all of whose parameters are types. This macro is used to implement <A HREF='../../../boost/mpl/is_metafunction_class.hpp'><SPAN CLASS='code'>is_metafunction_class</SPAN></A>.
</P>

<A NAME='#example'></A>
<H2>Example</H2>

<P>
    Suppose we want to define regular expressions for classifying MPL sequences.<A NAME='note_2_ref' HREF='#note_2'><SUP>[2]</SUP></A> Informally, a regular expression matching a sequence containing <SPAN CLASS='code'>int</SPAN> followed by <SPAN CLASS='code'>char</SPAN> could be written 
    <PRE>       int char </PRE>
    Formally, we could encode this as 
    <PRE><B>(A)</B>    juxt&lt;int, char&gt;</PRE>
    A regular expression matching a sequence which contains either <SPAN CLASS='code'>std::string</SPAN> or <SPAN CLASS='code'>int</SPAN> followed by <SPAN CLASS='code'>char</SPAN> could be written
    <PRE>       std::string | (int char) </PRE>
    Formally, we could write this as 
    <PRE>       alt&lt; std::string, juxt&lt;int, char&gt; &gt;</PRE>
    The regular expression <SPAN CLASS='code'>(std::string | (int char))*</SPAN> could be written
    <PRE>       star&lt; alt&lt; std::string, juxt&lt;int, char&gt; &gt; &gt;<A NAME='note_3_ref' HREF='#note_3'><SUP>[3]</SUP></A></PRE>
</P>
<P STYLE='margin:2em'></P>
<P>
    Now suppose we want to define a regular expression which matches a sequence containing an <SPAN CLASS='code'>int</SPAN> followed by a pointer. To represent the property of being a pointer, it's natural to use MPL lambda expressions or metafunction classes. Informally, we can write the expression as follows:
    <PRE>       int is_pointer&lt;_&gt; </PRE>
    Formally, we might be tempted to write
    <PRE>       juxt&lt; int, is_pointer&lt;_&gt; &gt;</PRE>
    Unfortunately, according to the conventions we adopted above&#8211;&#8211;that types represent literals matching themselves&#8211;&#8211;this expression matches a sequence only if it contains <SPAN CLASS='code'>int</SPAN> followed by the lambda expression <SPAN CLASS='code'>is_pointer&lt;_&gt;</SPAN>.
</P>
<P STYLE='margin:2em'></P>
<P>
    We could correct the situation by requiring that all literals be lambda expressions or metafunction classes. But then <SPAN CLASS='code'>juxt&lt;int, char&gt;</SPAN> would become
    <PRE>       juxt&lt; same_as&lt;int&gt;, same_as&lt;char&gt; &gt;</PRE>
    Alternatively, we could provide a means to signal that a type is to be regarded as a literal, <I>e.g.</I>, by using introduing a template <SPAN CLASS='code'>lit</SPAN>. Then we would have
    <PRE>       juxt&lt; lit&lt;int&gt;, lit&lt;char&gt; &gt;</PRE>
    Compare these formulations to <SPAN CLASS='code'>(A)</SPAN>, above: both make complex expressions significantly less readable, especially if namespace qualification is used.
</P>
<P STYLE='margin:2em'></P>
<P>
    Metafunction Traits provides a simple solution. Using <SPAN CLASS='code'>is_metafunction_or_lambda</SPAN>, our regular expression engine can determine that <SPAN CLASS='code'>is_pointer&lt;_&gt;</SPAN> is a lambda expression but <SPAN CLASS='code'>int</SPAN> is not, and so treat them differently. Therefore, we can just write 
    <PRE>   juxt&lt; int, is_pointer&lt;_&gt; &gt;</PRE>
    and have it mean exactly what we want it to. For full generality, we should also provide a means to indicate that a type should be treated as a literal&#8211;&#8211;in case we wish to examine sequences of types which might themselves be metafunction classes or lambda expressions. Then we can write, <I>e.g.</I>, 
    <PRE>   juxt&lt; int, lit&lt; is_pointer&lt;_&gt; &gt; &gt;</PRE>
    to match a sequence which contains <SPAN CLASS='code'>int</SPAN> followed by the lambda expression <SPAN CLASS='code'>is_pointer&lt;_&gt;</SPAN>. Fortunately, this explicit disambiguation should be required infrequently.
</P>                   

<A NAME='implementation'></A>
<H2>Implementation</H2>

<H3><CODE>is_lambda_expression</CODE></H3>
<P>
    The implementation of <SPAN CLASS='code'>is_lambda_expression</SPAN> is straightforward.<A NAME='note_4_ref' HREF='#note_4'><SUP>[4]</SUP></A> First, using template template parameters and partial specialization, we define a unary metafunction
    <SPAN CLASS='code'>aux::template_arguments</SPAN> which when invoked on a specialization of a class template with type template parameters returns its sequence of template arguments, and when invoked on any other type returns <SPAN CLASS='code'>mpl::list0<></SPAN>.<A NAME='note_5_ref' HREF='#note_5'><SUP>[5]</SUP></A> Next, we use <A HREF='http://www.boost.org/boost/mpl/iter_fold_if.hpp'><SPAN CLASS='code'>mpl::iter_fold_if</SPAN></A> to search recursively through the template argument lists of a given type looking for MPL placeholder symbols. If a placeholder symbol is encountered&#8211;&#8211;with no intervening occurence of <A HREF='http://www.boost.org/boost/mpl/protect.hpp'><SPAN CLASS='code'>mpl::protect</SPAN></A>&#8211;&#8211;the type is classifed as a lambda expression; otherwise, it is not.
</P>


<H3><CODE>is_metafunction_class</CODE></H3>
<P>
    The implementation of <SPAN CLASS='code'>is_metafunction_class</SPAN> uses the macro <A HREF='../../../boost/mpl/aux_/has_template_xxx.hpp'><SPAN CLASS='code'>BOOST_HAS_TEMPLATE_XXX_TRAIT_NAMED_DEF</SPAN></A> to define
    a unary metafunction <SPAN CLASS='code'>aux::is_non_nullary_metafunction</SPAN> which returns true for class types having a nested class template named <SPAN CLASS='code'>apply</SPAN> with arity less than or equal to <A HREF='http://www.boost.org/boost/mpl/limits/arity.hpp'><SPAN CLASS='code'>BOOST_MPL_METAFUNCTION_MAX_ARITY</SPAN></A>. <SPAN CLASS='code'>is_metafunction_class</SPAN> is then defined to return true for all types which are not lambda expressions and which satisfy one of the metafunctions <A HREF='http://www.boost.org/boost/mpl/aux_/has_type.hpp'><SPAN CLASS='code'>aux::has_type</SPAN></A> or <SPAN CLASS='code'>aux::is_non_nullary_metafunction</SPAN>. 
</P>

<H3><CODE>BOOST_HAS_TEMPLATE_XXX_TRAIT_NAMED_DEF</CODE></H3>
<P>
   The macro <SPAN CLASS='code'>BOOST_HAS_TEMPLATE_XXX_TRAIT_NAMED_DEF</SPAN> uses the SFINAE principle to detect member templates.<A NAME='note_6_ref' HREF='#note_65'><SUP>[6]</SUP></A> Two separate techniques are used: one for EDG-based compilers, and one for all other compilers. The following is a simplfied example of how one can test for the presence of a member template named <SPAN CLASS='code'>apply</SPAN>, of arity two, using a non-EDG-based compiler:<A NAME='note_7_ref' HREF='#note_7'><SUP>[7]</SUP></A>
<PRE>    template&lt;template&lt;typename, typename&gt; class T&gt;
    struct <B>binary</B> { typedef int type; };

    template&lt;typename T&gt;
    type_traits::yes_type <B>helper</B>(typename binary&lt; T::template apply &gt;::type* = 0);

    template&lt;typename T&gt;
    type_traits::no_type <B>helper</B>(...);

    template&lt;typename T&gt;
    struct <B>has_binary_apply</B> {
        static const bool value = 
            sizeof(helper&lt;T&gt;(0)) == sizeof(type_traits::yes_type);
    };</PRE>
</P>
   On an EDG-based compiler, the technique is a bit different:<A NAME='note_7_ref' HREF='#note_7'><SUP>[7]</SUP></A>
<PRE>    template&lt;typename T&gt;
    type_traits::yes_type 
    <B>helper</B>(typename identity&lt; typename T::template apply&lt;int, int&gt; &gt;::type* = 0);

    template&lt;typename T&gt;
    type_traits::no_type <B>helper</B>(...);

    template&lt;typename T&gt;
    struct <B>has_binary_apply</B> {
        static const bool value = 
            sizeof(helper&lt;T&gt;(0)) == sizeof(type_traits::yes_type);
    };</PRE>
</P>

<A NAME='discussion'></A>
<H2>Discussion</H2>

<P>
    <B>Standard conformance.</B> [To be added.]
</P>

<P>
    <B>Structural conformance.</B> [To be added.]
</P>

<P>
    <B>Efficiency.</B> [To be added.]
</P>


<A NAME='dependencies'></A>
<H2>Dependencies</H2>

Metafunction Traits depends on <A HREF='http://www.boost.org/libs/config/config.htm'>Boost.Config</A>, the <A HREF='http://www.boost.org/libs/preprocessor/doc/index.html'>Boost Preprocessor Library</A>, the <A HREF='http://www.boost.org/libs/type_traits/'>Boost Type Traits Library</A> and the <A HREF='http://www.boost.org/libs/mpl/doc/index.html'>Boost Metaprogramming Library</A>.

<A NAME='portability'></A>
<H2>Portability</H2>

<P>
	The program <A HREF='../test/metafunction_traits.cpp'><SPAN CLASS='code'>&lt;libs/mpl/test/metafunction_traits.cpp&gt;</SPAN></A> has been tested successfully with the following compilers:
	<UL type='square'>
		<LI STYLE='list-style-type: square'>Microsoft Visual C++ 7.1</LI>
		<LI STYLE='list-style-type: square'>Metrowerks CodeWarrior 9.2</LI>
		<LI STYLE='list-style-type: square'>GCC 3.2 (MinGW)</LI>
		<LI STYLE='list-style-type: square'>GCC 3.3.1 (cygming special)</LI>
		<LI STYLE='list-style-type: square'>Intel C++ Compiler for Windows 7.1 and 8.0</LI>
		<LI STYLE='list-style-type: square'>Comeau C/C++ 4.3.3</LI>
		<LI STYLE='list-style-type: square'>Borland C++ 6.0 (preview)<A NAME='note_8_ref' HREF='#note_8'><SUP>[8]</SUP></A></LI>
	</UL>

    <P>All tests were conducted with compiler options requesting strict ISO compliance.</P>
    <P>Metafunction Traits will probably work without change on any sufficiently recent EDG-based compiler. It may work on other compilers with good support for template template parameters, partial specialization and SFINAE, but will likely require some fine-tuning.</P>
</P>

<A NAME='feedback'></A>
<H2>Feedback</H2>

The author, Jonathan Turkanis, can be contacted at <A CLASS='contact' HREF='mailto:turkanis@kangaroologic.com'>turkanis@kangaroologic.com</A>

<HR STYLE='margin:20,0,0'>

<H3>Notes</H3>

<P>
<A NAME='note_1' HREF='#note_1_ref'><SUP>[1]</SUP></A>The less verbose names <SPAN CLASS='code'>is_metafunction</SPAN>, <SPAN CLASS='code'>is_metatype</SPAN> and <SPAN CLASS='code'>is_meta</SPAN> were rejected as unclear. Even so, <SPAN CLASS='code'>is_metafunction_or_lambda</SPAN> would not be the traits template with the longest name; it is one character shorter than <SPAN CLASS='code'>is_member_function_pointer</SPAN>.
</P>

<P>
<A NAME='note_2' HREF='#note_2_ref'><SUP>[2]</SUP></A>The author has implemented such a facility, together with several other formal languages for classifying MPL sequences. Right now it works only on a limited number of compilers, and is undocumented.
</P>

<P>
<A NAME='note_3' HREF='#note_3_ref'><SUP>[3]</SUP></A>It's tempting to suggest <SPAN CLASS='code'>alt&lt; std::string, juxt&lt;int, char&gt; &gt;*</SPAN>, but this syntax leads to ambiguity.
</P>

<P>
<A NAME='note_4' HREF='#note_4_ref'><SUP>[4]</SUP></A>The following implementation, based on existing MPL internals, 
almost works:
<PRE>    template&lt;typename T&gt;
    struct <B>is_lambda_expression</B> {
        typedef typename lambda&lt;T&gt;::is_le type;
        static const bool value = type::value;
    };</PRE>
Unfortunately on all supported compilers but GCC it fails to compile when instantiated on certain metafunction classes.  <I>E.g.</I>:
<PRE>    typedef is_lambda_expression&lt; always&lt;int&gt; &gt;::type type;</PRE>
Clearly, an implementation such as this would be preferable to the one described in the main text, if it could be made to work.
</P>

<P>
<A NAME='note_5' HREF='#note_5_ref'><SUP>[5]</SUP></A>GCC requires some workarounds, because of its 'extended template parameter matching.' Fortunately, these are already provided by <A HREF='http://www.boost.org/boost/mpl/aux_/template_arity.hpp'><SPAN CLASS='code'>&lt;boost/mpl/aux_/template_arity.hpp&gt;</SPAN></A>. For a discussion, see <A HREF='http://std.dkuug.dk/jtc1/sc22/wg21/docs/cwg_closed.html#150'> C++ Standard Core Language Closed Issues, Revision 28, Item 150</A> and <A HREF='http://lists.boost.org/MailArchives/boost-users/msg04509.php'>http://lists.boost.org/MailArchives/boost-users/msg04509.php</A>. (If 'extended' matching is allowed in a future standard, template arity detection could become significantly less efficient.)
</P>

<P>
<A NAME='note_6' HREF='#note_6_ref'><SUP>[6]</SUP></A>See "C++ Templates: The Complete Guide", by David Vandevoorde and Nicolai M. Josuttis, Addison Wesley, 2003, p. 106.
</P>

<P>
<A NAME='note_7' HREF='#note_7_ref'><SUP>[7]</SUP></A>See <A HREF='#discussion'>Discussion</A> for a discussion of whether the following code is standard-conforming.
</P>

<P>
<A NAME='note_8' HREF='#note_8_ref'><SUP>[8]</SUP></A>To compile Metafunction Traits with the Borland preview compiler, BOOST_STRICT_CONFIG must be defined, and additional <SPAN CLASS='code'>__BORLANDC__</SPAN> tests are required in several places in the MPL source. Aleksey Gurtovoy has said that he intends to make these changes soon.
</P>


<HR STYLE='margin:20,0,0'>

<P STYLE='font-size:8pt'>
	&copy; Copyright Jonathan Turkanis 2004.
	Permission to copy, use, modify, sell and distribute this document
	is granted provided this copyright notice appears in all copies. This
	document is provided "as is" without express or implied warranty, and
	with no claim as to its suitability for any purpose.
</P>

</BODY>