<!DOCTYPE html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <link rel="stylesheet" type="text/css" href="boost.css">
  <title>Interval Rounding</title>
</head>

<body>
<h1>Rounding policies</h1>
In order to be as general as possible, the library uses a class to compute
all the necessary functions rounded upward or downward. This class is the
second parameter of <code>interval_traits</code>.

<p>By default, it is <code>boost::interval_lib::rounded_math&lt;T&gt;</code>.
The class <code>boost::interval_lib::rounded_math</code> is already
specialized for the standard floating types (<code>float</code> ,
<code>double</code> and <code>long double</code>). So if the base type of
your intervals is not one of these, a good solution would probably be to
provide a specialization of this class. But if the default specialization of
<code>rounded_math&lt;T&gt;</code> for <code>float</code>,
<code>double</code>, or <code>long double</code>  is not what you seek, or
you do not want to specialize
<code>boost::interval_lib::rounded_math&lt;T&gt;</code> (say because you
prefer to work in your own namespace) you can also define your own rounding
policy and pass it directly to <code>interval_traits</code>.</p>

<h2>Requirements</h2>

<p>Here comes what the class is supposed to provide. The domains are written
next to their respective functions (as you can see, the functions do not have
to worry about invalid values, but they have to handle infinite
arguments).</p>
<pre>/* Rounding requirements */
struct rounding {
  // defaut constructor, destructor
  rounding();
  ~rounding();
  // mathematical operations
  T add_down(T, T); // [-&infin;;+&infin;][-&infin;;+&infin;]
  T add_up  (T, T); // [-&infin;;+&infin;][-&infin;;+&infin;]
  T sub_down(T, T); // [-&infin;;+&infin;][-&infin;;+&infin;]
  T sub_up  (T, T); // [-&infin;;+&infin;][-&infin;;+&infin;]
  T mul_down(T, T); // [-&infin;;+&infin;][-&infin;;+&infin;]
  T mul_up  (T, T); // [-&infin;;+&infin;][-&infin;;+&infin;]
  T div_down(T, T); // [-&infin;;+&infin;]([-&infin;;+&infin;]-{0})
  T div_up  (T, T); // [-&infin;;+&infin;]([-&infin;;+&infin;]-{0})
  T sqrt_down(T);   // ]0;+&infin;]
  T sqrt_up  (T);   // ]0;+&infin;]
  T exp_down(T);    // [-&infin;;+&infin;]
  T exp_up  (T);    // [-&infin;;+&infin;]
  T log_down(T);    // ]0;+&infin;]
  T log_up  (T);    // ]0;+&infin;]
  T cos_down(T);    // [0;2&pi;]
  T cos_up  (T);    // [0;2&pi;]
  T tan_down(T);    // ]-&pi;/2;&pi;/2[
  T tan_up  (T);    // ]-&pi;/2;&pi;/2[
  T asin_down(T);   // [-1;1]
  T asin_up  (T);   // [-1;1]
  T acos_down(T);   // [-1;1]
  T acos_up  (T);   // [-1;1]
  T atan_down(T);   // [-&infin;;+&infin;]
  T atan_up  (T);   // [-&infin;;+&infin;]
  T sinh_down(T);   // [-&infin;;+&infin;]
  T sinh_up  (T);   // [-&infin;;+&infin;]
  T cosh_down(T);   // [-&infin;;+&infin;]
  T cosh_up  (T);   // [-&infin;;+&infin;]
  T tanh_down(T);   // [-&infin;;+&infin;]
  T tanh_up  (T);   // [-&infin;;+&infin;]
  T asinh_down(T);  // [-&infin;;+&infin;]
  T asinh_up  (T);  // [-&infin;;+&infin;]
  T acosh_down(T);  // [1;+&infin;]
  T acosh_up  (T);  // [1;+&infin;]
  T atanh_down(T);  // [-1;1]
  T atanh_up  (T);  // [-1;1] 
  T median(T, T);   // [-&infin;;+&infin;][-&infin;;+&infin;]
  T int_down(T);    // [-&infin;;+&infin;]
  T int_up  (T);    // [-&infin;;+&infin;]
  // trigonometric constants
  static T pi_down();
  static T pi_up  ();
  static T pi_half_down();
  static T pi_half_up  ();
  static T pi_twice_down();
  static T pi_twice_up  ();
  // unprotected rounding class
  typedef ... unprotected_rounding;
};</pre>

<p>The constructor and destructor of the rounding class have a very important
semantic requirement: they are responsible for setting and resetting the
rounding modes of the computation on T. For instance, if T is a standard
floating point type and floating point computation is performed according to
the Standard IEEE 754, the constructor can save the current rounding state,
each <code>_up</code> (resp. <code>_down</code>) function will round up
(resp. down), and the destructor will restore the saved rounding state.
Indeed this is the behavior of the default rounding policy.</p>

<p>The meaning of all the mathematical functions up until
<code>atanh_up</code> is clear: each function returns number representable in
the type <code>T</code> which is a lower bound (for<code> _down</code>) or
upper bound (for <code>_up</code>) on the true mathematical result of the
corresponding function. The function <code>median</code> computes the average
of its two arguments rounded to its nearest representable number. The
functions <code>int_down</code> and <code>int_up</code> compute the nearest
integer smaller or bigger than their argument.</p>

<p>The <code>pi_...</code> functions return lower and upper bounds on some
mathematical constants. <code>pi</code> clearly stands for the mathematical
constant &pi;. <code>pi_half</code> stands for &pi;/2 and
<code>pi_twice</code> stands for 2&pi;.</p>

<p>The type <code>unprotected_rounding</code> is another rounding class that
enables to work when nested inside rounding. For example, the first three
lines below should all produce the same result (because the first operation
is the rounding constructor, and the last is its destructor, which take care
of setting the rounding modes); and the last line is allowed to have an
undefined behavior (since no rounding constructor or destructor is ever
called).</p>
<pre>T c; { rounding rnd; c = rnd.add_down(a, b); }
T c; { rounding rnd1; { rounding rnd2; c = rnd2.add_down(a, b); } }
T c; { rounding rnd1; { rounding::unprotected_rounding rnd2; c = rnd2.add_down(a, b); } }
T d; { rounding::unprotected_rounding rnd; d = rnd.add_down(a, b); }</pre>
Naturally <code>rounding::unprotected_rounding</code> may simply be
<code>rounding</code> itself. But it can improve performance if it is a
simplified version with empty constructor and destructor. In order to avoid
undefined behaviors, in the library, an object of type
<code>rounding::unprotected_rounding</code> is guaranteed to be created only
when an object of type <code>rounding</code> is already alive. See the <a
href="#perf">performance notes</a> for some additional details.

<h2>Overview of the provided classes</h2>
A lot of classes are provided. The classes are organized by level. At the
bottom is the class <code>rounding_control</code>. At the next level come
<code>rounded_arith_exact</code>, <code>rounded_arith_std</code> and
<code>rounded_arith_opp</code>. Then there are
<code>rounded_transc_dummy</code>, <code>rounded_transc_exact</code>,
<code>rounded_transc_std</code> and <code>rounded_transc_opp</code>. And
finally are <code>save_state</code> and <code>save_state_nothing</code>. Each
of these classes provide a set of members that are required by the classes of
the next level. For example, a <code>rounded_transc_...</code> class needs
the members of a <code>rounded_arith_...</code> class.

<p>When they exist in two versions <code>_std</code> and <code>_opp</code>,
the first one does switch the rounding mode each time, and the second one
tries to keep it oriented toward plus infinity. The main purpose of the
<code>_opp</code> version is to speed up the computations through the use of
the "opposite trick" (see the <a href="#perf">performance notes</a>). This
version requires the rounding mode to be upward before entering any
computation functions of the class. It guarantees that the rounding mode will
still be upward at the exit of the functions.</p>

<p>Please note that it is really a very bad idea to mix the <code>_opp</code>
version with the <code>_std</code> since they do not have compatible
properties.</p>

<p>There is a third version named <code>_exact</code> which computes the
functions without changing the rounding mode. It is an "exact" version
because it is intended for a base type that produces exact results.</p>

<p>The last version is the <code>_dummy</code> version. It does not do any
computations but still produces compatible results.</p>

<p>Please note that it is possible to use the "exact" version for an inexact
base type, e.g. <code>float</code> or <code>double</code>. In that case, the
inclusion property is no longer guaranteed, but this can be useful to speed
up the computation when the inclusion property is not desired strictly. For
instance, in computer graphics, a small error due to floating-point roundoff
is acceptable as long as an approximate version of the inclusion property
holds.</p>

<p>Here comes what each class defines. Later, when they will be described
more thoroughly, these members will not be repeated. Please come back here in
order to see them. Inheritance is also used to avoid repetitions.</p>
<pre>template &lt;class T&gt;
struct rounding_control
{
  typedef ... rounding_mode;
  void set_rounding_mode(rounding_mode);
  void get_rounding_mode(rounding_mode&amp;);
  void downward ();
  void upward   ();
  void to_nearest();
  T to_int(T);
  T force_rounding(T);
  static T pi_down();
  static T pi_up  ();
  static T pi_half_down();
  static T pi_half_up  ();
  static T pi_twice_down();
  static T pi_twice_up  ();
};

template &lt;class T, class Rounding&gt;
struct rounded_arith_... : Rounding
{
  void init();
  T add_down(T, T);
  T add_up  (T, T);
  T sub_down(T, T);
  T sub_up  (T, T);
  T mul_down(T, T);
  T mul_up  (T, T);
  T div_down(T, T);
  T div_up  (T, T);
  T sqrt_down(T);
  T sqrt_up  (T);
  T median(T, T);
  T int_down(T);
  T int_up  (T);
};

template &lt;class T, class Rounding&gt;
struct rounded_transc_... : Rounding
{
  T exp_down(T);
  T exp_up  (T);
  T log_down(T);
  T log_up  (T);
  T cos_down(T);
  T cos_up  (T);
  T tan_down(T);
  T tan_up  (T);
  T asin_down(T);
  T asin_up  (T);
  T acos_down(T);
  T acos_up  (T);
  T atan_down(T);
  T atan_up  (T);
  T sinh_down(T);
  T sinh_up  (T);
  T cosh_down(T);
  T cosh_up  (T);
  T tanh_down(T);
  T tanh_up  (T);
  T asinh_down(T);
  T asinh_up  (T);
  T acosh_down(T);
  T acosh_up  (T);
  T atanh_down(T);
  T atanh_up  (T);
};

template &lt;class Rounding&gt;
struct save_state_... : Rounding
{
  typedef ... unprotected_rounding;
};</pre>

<h2>Synopsis.</h2>
<pre>namespace boost {
  namespace interval_lib {

    /* basic rounding control */
    template &lt;class T&gt;  struct rounding_control;

    /* arithmetic functions rounding */
    template &lt;class T, class Rounding = rounding_control&lt;T&gt; &gt; struct rounded_arith_exact;
    template &lt;class T, class Rounding = rounding_control&lt;T&gt; &gt; struct rounded_arith_std;
    template &lt;class T, class Rounding = rounding_control&lt;T&gt; &gt; struct rounded_arith_opp;

    /* transcendental functions rounding */
    template &lt;class T, class Rounding&gt; struct rounded_transc_dummy;
    template &lt;class T, class Rounding = rounded_arith_exact&lt;T&gt; &gt; struct rounded_transc_exact;
    template &lt;class T, class Rounding = rounded_arith_std&lt;T&gt; &gt; struct rounded_transc_std;
    template &lt;class T, class Rounding = rounded_arith_opp&lt;T&gt; &gt; struct rounded_transc_opp;

    /* rounding-state-saving classes */
    template &lt;class Rounding&gt; struct save_state;
    template &lt;class Rounding&gt; struct save_state_nothing;

    /* default policy for type T */
    template &lt;class T&gt;  struct rounded_math;
    template &lt;&gt;  struct rounded_math&lt;float&gt;;
    template &lt;&gt;  struct rounded_math&lt;double&gt;;

  } // namespace interval_lib
} // namespace boost</pre>

<h2>Description of the provided classes</h2>
We now describe each class in the order they appear in the definition of a
rounding policy (this outermost-to-innermost order is the reverse order from
the synopsis).

<h3>State saving</h3>
First comes <code>save_state</code>. This class is responsible for saving the
current rounding mode and calling init in its constructor, and for restoring
the saved rounding mode in its destructor. This class also correctly defines
the unprotected variation.

<p>If the rounding mode does not require any state-saving or initialization,
<code>save_state_nothing</code> can be used instead of
<code>save_state</code>.</p>

<h3>Transcendental functions</h3>
The classes <code>rounded_transc_exact</code>,
<code>rounded_transc_std</code> and <code>rounded_transc_opp</code> expect
the std namespace to provide the functions exp log cos tan acos asin atan
cosh sinh tanh acosh asinh atanh. For the <code>_std</code> and
<code>_opp</code> versions, all these functions should respect the current
rounding mode fixed by a call to downward or upward.

<p><strong>Please note:</strong> Unfortunately, the latter is rarely the
case. It is the reason why a class <code>rounded_transc_dummy</code>  is
provided which does not depend on the functions from the std namespace. It is
also the reason why <code>rounded_transc_dummy</code> is the default class,
rather than <code>rounded_transc_opp</code>. There is no magic, however. The
functions of <code>rounded_transc_dummy</code> do not compute anything. They
only return valid values. For example, <code>cos_down</code> always returns
-1. In this way, we do verify the inclusion property for the default
implementation, even if this has strictly no value for the user. In order to
have useful values, another policy should be used explicitely, which will
most likely lead to a violation of the inclusion property. In this way, we
ensure that the violation is clearly pointed out to the user who then knows
what he stands against.</p>

<h3>Basic arithmetic functions</h3>
The classes <code>rounded_arith_std</code> and <code>rounded_arith_opp</code>
expect the operators + - * / and the function <code>std::sqrt</code> to
respect the current rounding mode.

<p><em>The class </em><code><em>rounded_arith_opp</em></code><em> also
requires </em><code><em>std::sqrt</em></code><em> to produce a square root
rounded upward no more than 1 ulp away from the exact value (in order for
</em><code><em>sqrt_down</em></code><em> to use
</em><code><em>std::sqrt</em></code><em> without switching the rounding
mode). <strong>ISN'T THIS SENTENCE OBSOLETE? -H</strong></em></p>

<p>The class <code>rounded_arith_exact</code> requires
<code>std::floor</code> and <code>std::ceil</code> to be defined since it can
not rely on <code>to_int</code>.</p>

<h3>Rounding control</h3>
The functions defined by each of the previous classes did not need any
explanation. For example, the behavior of <code>add_down</code> is to compute
the sum of two numbers rounded downward. For <code>rounding_control</code>,
the situation is a bit more complex.

<p>The basic function is <code>force_rounding</code> which returns its
argument correctly rounded accordingly to the current rounding mode if it was
not already the case. This function is necessary to handle delayed rounding.
On standard-compliant platform, it ensures that its argument is evaluated
with the proper rounding mode because it is copied into a volatile temporary
variable. <b>CAN THIS BE ELABORATED ON? NEED TO ELUCIDATE THE MECHANISM!
THANKS. -H</b></p>

<p>The function <code>get_rounding_mode</code> returns the current rounding
mode, <code>set_rounding_mode</code> sets the rounding mode back to a
previous value returned by <code>get_rounding_mode</code>. downward, upward
and to_nearest sets the rounding mode in one of the three directions. This
rounding mode should be global to all the functions that use the type T. For
example, after a call to downward, <code>force_rounding(x+y)</code> is
expected to return the sum rounded downward.</p>

<p>The function <code>to_int</code> computes the nearest integer accordingly
to the current rounding mode.</p>

<p>The non-specialized version of <code>rounding_control</code> does not do
anything. The functions for the rounding mode are empty, and
<code>to_int</code> and <code>force_rounding</code> are identity functions.
The <code>pi_</code> constant functions return suitable integers (for
example, <code>pi_up</code> returns T(4)).</p>

<p>The class template <code>rounding_control</code> is specialized for
<code>float</code>, <code>double</code> and <code>long double</code> in order
to best use the floating point unit of the computer.</p>

<h2>Template class <tt>rounded_math</tt></h2>

<p>The default policy (aka <tt>rounded_math&lt;T&gt;</tt>) is simply defined
as:</p>
<pre>template &lt;class T&gt; struct rounded_math&lt;T&gt; : save_state_nothing&lt;rounded_transc_dummy&lt;T, rounded_arith_exact&lt;T&gt; &gt; &gt; {};</pre>

<p>and the specializations for <code>float</code> and <code>double</code> use
<code>rounded_arith_opp</code>, as in:</p>
<pre>template &lt;&gt;  struct rounded_math&lt;float&gt;       : save_state&lt;rounded_transc_dummy&lt;float, rounded_arith_opp&lt;float&gt; &gt; &gt; {};
template &lt;&gt;  struct rounded_math&lt;double&gt;      : save_state&lt;rounded_transc_dummy&lt;double, rounded_arith_opp&lt;double&gt; &gt; &gt; {};
template &lt;&gt;  struct rounded_math&lt;long double&gt; : save_state&lt;rounded_transc_dummy&lt;long double, rounded_arith_opp&lt;long double&gt; &gt; &gt; {};</pre>

<h2>Some Examples</h2>

<p>Here come several cases:</p>
<ul>
  <li>if you need precise computations with the <code>float</code> or
    <code>double</code> types, use the default
    <code>rounded_math&lt;T&gt;</code>;</li>
  <li>for fast wide intervals without any rounding nor precision, use
    <code>save_state_nothing&lt;rounded_transc_exact&lt;T&gt;
  &gt;</code>;</li>
  <li>for an exact type (like int or rational with a little help for infinite
    and NaN values) without support for transcendental functions, the
    solution could be <code>save_state_nothing&lt;rounded_transc_dummy&lt;T,
    rounded_arith_exact&lt;T&gt; &gt; &gt;</code>;</li>
  <li>if it is a more complex case than the previous ones, the best thing is
    probably to directly define your own policy.</li>
</ul>
</body>
</html>
