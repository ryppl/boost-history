<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <link rel="stylesheet" type="text/css" href="../../../boost.css">
  <title>Interval-comparisons.htm</title>
</head>

<body>
<h1>Comparison policies</h1>

<h2 id="compare">Comparisons</h2>

<p>As was said before, the definition of the comparison operators induces a
slight problem. If their return type is restricted to bool, there are many
ways to define them. It is the reason why the class interval is influenced by
a comparison policy. So the class <code>interval_traits</code> requires an
argument describing a class that provides the following functions:</p>
<pre>struct interval_compare {
  static bool less_than(T x_low, T x_up, T y_low, T y_up);
  static bool equal_to(T x_low, T x_up, T y_low, T y_up);
};</pre>

<p>The functions <code>less_than</code> and <code>equal_to</code> compare two
intervals given their bounds. Thanks to this comparison class, the class
interval can now define the following operators:<code> &lt;, &gt;, &lt;=,
&gt;=, ==, !=</code>. All these operators are defined for two interval
parameters, or for one interval and a number.</p>

<h2>Synopsis</h2>

<blockquote>
  <pre>namespace boost {
  namespace interval_lib {

template&lt;class T&gt; struct compare_certainly;
template&lt;class T&gt; struct compare_possibly;
template&lt;class T, class Function&gt; struct compare_full;
template&lt;class T&gt; struct compare_data;

  } // namespace interval_lib
} // namespace boost</pre>
</blockquote>

<h2>Provided classes</h2>
Four classes are pre-defined for the comparison policy.
<code>compare_certainly</code> implements the "certain" comparison (it is the
comparison policy by default). <code>compare_possibly</code> implements the
"possible" comparison. And <code>compare_full</code> allows the user to
specify a behavior in case of a non-boolean result (an exception for example).

<p>The last class, <code>compare_data</code>, does not have any mathematical
fundation. The equality is the physical equality, and the less operator is
the lexicographic order.</p>

<p>As you have probably guessed, the Function parameter of compare_full is
the type of a function object called in case of a non-boolean result. So it
must have an operator of signature <tt>bool Function::operator()()</tt>. Here
is a little example of the behavior of the comparison operators when
compare_full is the choosen policy:</p>
<ul>
  <li>[<tt>1,2] &lt;  [2,3]</tt> will return <tt>Function()()</tt>,</li>
  <li><tt>[1,2] &lt;= [2,3</tt>] will return <tt>true</tt>,</li>
  <li><tt>[1,2] &gt;  [2,3]</tt> will return <tt>false</tt>, and</li>
  <li><tt>[1,2] &gt;= [2,3]</tt> will return <tt>!Function()()</tt>.</li>
</ul>
As a side note, if Function is the constant function object <tt>false</tt>,
<tt>compare_full&lt;T, Function&gt;</tt> is the same as
<tt>compare_certainly</tt>. Similarly, if <tt>Function</tt> always returns
true, <tt>compare_full&lt;T, Function&gt;</tt> is the same as
<tt>compare_possibly</tt>. But it is better to use either
<tt>compare_certainly</tt> or <tt>compare_possibly</tt>, since
<tt>compare_full</tt> is twice as slow and there is nothing that the compiler
can do about it.

<h2>Explicit comparison functions</h2>
The comparison operators are not really handy. For example, if less_than is a
"certain" comparison, then &lt; and &gt; are also "certain" comparisons, but
&lt;= and &gt;= are only "possible" comparisons. The reason of this
discordance is: it is impossible to have &lt; and &lt;= both "possible", and
to have (x&lt;=y) == !(y&lt;x) at the same time (and the "certain" comparison
has the same problem). However, if you do not consider overlapping intervals,
these two types of comparisons are equivalent.

<p>To avoid these problems, it is probably better to use some explicit
comparison functions. Their names are composed by cer (for "certain") or pos
(for "possible") followed by lt, le, gt, ge, eq or ne. Each of these
functions takes two parameters and returns a boolean. For example, to use the
"certainly less than" comparison :</p>

<blockquote>
  <pre>template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);

template&lt;class T, class Traits&gt;
bool cerlt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);</pre>
</blockquote>
</body>
</html>
