<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <link rel="stylesheet" type="text/css" href="../../../boost.css">
  <title>Boost Interval Arithmetic Library</title>
</head>

<body>
<h1><img src="../../../c++boost.gif" alt="c++boost.gif (8819 bytes)"
align="middle"> Header &lt;<a
href="../../../boost/interval.hpp">boost/interval.hpp</a>&gt;</h1>  

<center>
<table cols="2" width="80%">
  <tbody>
    <tr align=TOP>
      <td align=TOP><p><b>Contents of this page:</b><br>
        <a href="#intro">Introduction</a><br>
        <a href="#synopsis">Synopsis</a><br>
        <a href="#interval_traits">Template class
        <code>interval_traits</code></a><br>
        <a href="#interval">Template class <code>interval</code></a><br>
        <a href="#opers">Operations and functions</a><br>
        <a href="#interval_lib">Interval support library</a><br>
        <a href="#perfs">Compilation and Performance notes</a><br>
        <a href="#dangers">Common pitfalls and dangers</a><br>
        <a href="#test">Test and example programs</a><br>
        <a href="#rationale">Rationale</a><br>
        <a href="#acks">History and Acknowledgments</a></p>
      </td>
      <td align=TOP><b>Other pages associated with this page:</b><br>
        <a href="rounding.htm">Rounding policies</a><br>
        <a href="checking.htm">Checking policies</a><br>
        <a href="comparisons.htm">Comparison policies</a><br>
        <a href="numbers.htm">Base number type requirements</a><br>
        <a href="guide.htm">Choosing your own interval type</a></td>
    </tr>
  </tbody>
</table>
</center>

<h2 id="intro">Introduction and Overview</h2>

<p>As implied by its name, this library is intended to help
manipulating mathematical intervals. It consists of a single header
&lt;<a href="../../../boost/interval.hpp">boost/interval.hpp</a>&gt;
and principally a type which can be used as
<code>interval&lt;T&gt;</code>. In fact, this interval template is
declared as <code>interval&lt;T,Traits&gt;</code> where
<code>Traits</code> is a policy class that controls the various
behaviours of the interval class; <code>interval&lt;T&gt;</code> just
happens to pick the default policies for the type <code>T</code>.</p>

<h3>Interval Arithmetic</h3>

<p>An interval is a pair of numbers which represents all the numbers
between these two. (Intervals are considered close so the bounds are
included.) The purpose of this library is to extend the usual
arithmetic functions to intervals. These intervals will be written
[<i>a</i>,<i>b</i>] to represent all the numbers between <i>a</i> and
<i>b</i> (included). <i>a</i> and <i>b</i> can be infinite (but they
can not be the same infinite) and <i>a</i> &le; <i>b</i>.</p>

<p>The fundamental property of interval arithmetic is the
<em><strong>inclusion property</strong></em>:</p>
<dl>
    <dd>``if <i>f</i> is a function on a set of numbers, <i>f</i> can be
      extended to a new function defined on intervals. This new function
      <i>f</i> takes one interval argument and returns an interval result
      such as: &forall; <i>x</i> &isin; [<i>a</i>,<i>b</i>],
      <i>f</i>(<i>x</i>) &isin; <i>f</i>([<i>a</i>,<i>b</i>]).''</dd>
</dl>

<p>Such a property is not limited to functions with only one argument.
Whenever possible, the interval result should be the smallest one able
to satisfy the property (it is not really useful if the new functions
always answer [-&infin;,+&infin;]).</p>

<p>There are at least two reasons a user would like to use this
library. The obvious one is when the user has to compute with
intervals. One example is when input data have some builtin
imprecision: instead of a number, an input variable can be passed as
an interval. Another example application is to solve equations, by
bisecting an interval until the interval width is small enough. A
third example application is in computer graphics, where computations
with boxes, segments or rays can be reduced to computations with
points via intervals.</p>

<p>Another common reason to use interval arithmetic is when the
computer doesn't produce exact results: by using intervals, it is
possible to quantify the propagation of rounding errors. This approach
is used often in numerical computation. For example, let's assume the
computer stores numbers with ten decimal significant digits. To the
question 1 + 1E-100 - 1, the computer will answer 0 although the
correct answer would be 1E-100. With the help of interval arithmetic,
the computer will answer [0,1E-9]. This is quite a huge interval for
such a little result, but the precision is now known, without having
to compute error propagation.</p>

<h3>Numbers, rounding, and exceptional behavior</h3>

<p>The <em><strong>base number type</strong></em> is the type that
holds the bounds of the interval. In order to successfully use
interval arithmetic, the base number type must present some <a
href="rounding.htm">characteristics</a>. Firstly, due to the
definition of an interval, the base numbers have to be totally ordered
so, for instance, <code>complex&lt;T&gt;</code> is not usable as base
number type for intervals.  The mathematical functions for the base
number type should also be compatible with the total order (for
instance if x&gt;y and z&gt;t, then it should also hold that x+y &gt;
y+t), so modulo types are not usable either.</p>

<p>Secondly, the computations must be exact or provide some rounding
methods (for instance, toward minus or plus infinity) if we want to
guarantee the inclusion property. Note that we also may explicitely
specify no rounding, for instance if the base number type is exact,
i.e. the result of a mathematic operation is always computed and
represented without loss of precision. If the number type is not
exact, we may still explicitely specify no rounding, with the obvious
consequence that the inclusion property is no longuer guaranteed.</p>

<p>Finally, because heavy loss of precision is always possible, some
numbers have to represent infinities or an exceptional behavior must
be defined. The same situation also occurs for NaN (<i>Not a
Number</i>).</p>

<p>Given all this, one may want to limit the template argument T of
the class template <code>interval</code> to the floating point types
<code>float</code>, <code>double</code>, and <code>long double</code>,
as defined by the IEEE-754 Standard. Indeed, if the interval
arithmetic is intended to replace the arithmetic provided by the
floating point unit of a processor, these types are the best
choice. Unlike <code>std::complex</code>, however, we don't want to
limit <code>T</code> to these types. This is why we allow the rounding
and exceptional behaviors to be given by the two policies (rounding
and checking). We do nevertheless provide highly optimized rounding
and checking class specializations for the above-mentioned floating
point types.</p>

<h3>Operations and functions</h3>

<p>It is straightforward to define the elementary arithmetic
operations on intervals, being guided by the inclusion property. For
instance, if [a,b] and [c,d] are intervals, [a,b]+[c,d] can be
computed by taking the smallest interval that contains all the numbers
x+y for x in [a,b] and y in [c,d]; in this case, rounding a+b down and
c+d up will suffice. Other operators and functions are similarly
defined (see their definitions below).</p>

<h3>Comparisons</h3>

<p>It is also possible to define some comparison operators. Given two
intervals, the result is a tri-state boolean type
{<i>false</i>,<i>true,indeterminate</i>}. The answers <i>false</i> and
<i>true</i> are easy to manipulate since they can directly be mapped
on the boolean <i>true</i> and <i>false</i>. But it is not the case
for the answer <em>indeterminate</em> since comparison operators are
supposed to be boolean functions. So, what to do in order to obtain
boolean answers?</p>

<p>One solution consists of deciding to adopt an exceptional behavior,
such as a failed assertion or raising an exception. In this case, the
exceptional behavior will be triggered when the result is
indeterminate.</p>

<p>Another solution is to  map <em>indeterminate</em> always to <i>false,</i>
or always to <i>true</i>. If <i>false</i> is chosen, the comparison will be
called "<i>certain</i>;" indeed, the result of [<i>a</i>,<i>b</i>] &lt;
[<i>c</i>,<i>d</i>] will be <i>true</i> if and only if: &forall; <i>x</i>
&isin; [<i>a</i>,<i>b</i>] &forall; <i>y</i> &isin; [<i>c</i>,<i>d</i>],
<i>x</i> &lt; <i>y</i>. If <i>true</i> is chosen, the comparison will be
called "<i>possible</i>;" indeed, the result of [<i>a</i>,<i>b</i>] &lt;
[<i>c</i>,<i>d</i>] will be <i>true</i> if and only if: &exist; <i>x</i>
&isin; [<i>a</i>,<i>b</i>] &exist; <i>y</i> &isin; [<i>c</i>,<i>d</i>],
<i>x</i> &lt; <i>y</i>.</p>

<p>Since any of these solution has a clearly defined semantics, it is
not clear that we should enforce either of them. For this reason, the
traits class defines which behavior will be followed, and different
behavior can be followed by tailoring the traits class. See <a
href="comparisons.htm">comparison policies</a> pages for further
details.</p>

<h3>Overview of the library, and usage</h3>

<p>This library provides two quite distinct levels of usage. One is to
use the basic class template <code>interval&lt;T&gt;</code> without
specifying the policy. This only requires to know and understand the
concepts developed above and the content of the namespace boost. In
addition to the class <code>interval&lt;T&gt;</code>, this level of
usage provides arithmetic operators (<code>+</code>, <code>-</code>,
<code>*</code>, <code>/</code>), algebraic and piecewise-algebraic
functions (<code>abs</code>, <code>square</code>, <code>sqrt</code>),
transcendental and trigonometric functions (<code>exp</code>,
<code>log</code>, <code>sin</code>, <code>cos</code>, <code>tan,
asin</code>, <code>acos</code>, <code>atan</code>, <code>sinh</code>,
<code>cosh</code>, <code>tanh</code>, <code>asinh</code>,
<code>acosh</code>, <code>atanh</code>), and the standard comparison
operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>,
<code>&gt;=</code>, <code>==</code>, <code>!=</code>), as well as
several interval-specific functions (<code>min</code>,
<code>max</code>, which have a different meaning than
<code>std::min</code> and <code>std::max</code>; <code>lower</code>,
<code>upper</code>, <code>width</code>, <code>median</code>,
<code>empty</code>, <code>singleton, equal</code>, <code>in</code>,
<code>in_zero</code>, <code>subset</code>, <code>proper_subset</code>,
<code>overlap</code>, <code>intersection, hull</code>,
<code>bisect</code>).</p>

<p>For some functions which take several parameters of type
<code>interval&lt;T&gt;</code>, all combinations of argument types
<code>T</code> and <code>interval&lt;T&gt;</code> which contain at
least one <code>interval&lt;T&gt;</code>, are considered in order to
avoid a conversion from the arguments of type <code>T</code> to a
singleton of type <code>interval&lt;T&gt;</code>. This is done for
efficiency reasons (the fact that an argument is a singleton sometimes
renders some tests unnecessary).</p>

<p>A somewhat more advanced usage of this library is to hand-pick the
policies <code>Rounding</code>, <code>Compare</code>, and
<code>Checking</code> and pass them to
<code>interval&lt;T,Traits&gt;</code> through the use of
<code>Traits := boost::interval_traits&lt;T,Compare,Rounding,Checking&gt;</code>. Appropriate policies can be fabricated by using the various classes
provided in the namespace <code>boost::interval_lib</code> as detailed
in section<a href="#interval_lib"> Interval Support Library</a>.</p>

<h2><a name="synopsis"></a>Synopsis</h2>
<pre>namespace boost {

  namespace interval_lib {

    /* these declarations necessary for the declaration of interval_traits */
    template &lt;class T&gt; struct compare_certainly;
    template &lt;class T&gt; struct rounded_math;
    template &lt;class T&gt; struct checking_strict;

    /* ... ; the full synopsis of namespace interval_lib can be found <a href="#interval_lib">here</a> */
  
  } // namespace interval_lib

  /* template interval_traits; class definition can be found <a href="#interval_traits">here</a> */
  template &lt;class T,
            class Compare  = interval_lib::compare_certainly&lt;T&gt;,
            class Rounding = interval_lib::rounded_arithmetic&lt;T&gt;,
            class Checking = interval_lib::checking_strict&lt;T&gt; &gt;
  class interval_traits;

  /* template class interval; class definition can be found <a href="#interval">here</a> */
  template &lt;class T, class Traits = interval_traits&lt;T&gt; &gt;
  class interval;

  /* arithmetic operators involving intervals */
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x);

  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator+(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator-(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator*(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator*(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator*(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator/(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator/(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; operator/(const T&amp; r, const interval&lt;T, Traits&gt;&amp; x);

  /* algebraic functions: sqrt, abs, square, pow */
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; abs(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; sqrt(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; square(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; pow(const interval&lt;T, Traits&gt;&amp; x, int y);

  /* transcendental functions: exp, log */
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; exp(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; log(const interval&lt;T, Traits&gt;&amp; x);

  /* fmod, for trigonometric function argument reduction (see below) */
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; fmod(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; fmod(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; fmod(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  /* trigonometric functions */
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; sin(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; cos(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; tan(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; asin(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; acos(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; atan(const interval&lt;T, Traits&gt;&amp; x);

  /* hyperbolic trigonometric functions */
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; sinh(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; cosh(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; tanh(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; asinh(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; acosh(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; atanh(const interval&lt;T, Traits&gt;&amp; x);

  /* min, max external functions (NOT std::min/max, see below) */
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; max(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; max(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; max(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; min(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; min(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; min(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  /* bounds-related interval functions */
  template &lt;class T, class Traits&gt;  T lower(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  T upper(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  T width(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  T median(const interval&lt;T, Traits&gt;&amp; x);

  /* bounds-related interval functions */
  template &lt;class T, class Traits&gt;  bool empty(const interval&lt;T, Traits&gt;&amp; b);
  template &lt;class T, class Traits&gt;  bool singleton(const interval&lt;T, Traits&gt;&amp; x);
  template &lt;class T, class Traits&gt;  bool equal(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  bool in(const T&amp; r, const interval&lt;T, Traits&gt;&amp; b);
  template &lt;class T, class Traits&gt;  bool in_zero(const interval&lt;T, Traits&gt;&amp; b);
  template &lt;class T, class Traits&gt;  bool subset(const interval&lt;T, Traits&gt;&amp; a, const interval&lt;T, Traits&gt;&amp; b);
  template &lt;class T, class Traits&gt;  bool proper_subset(const interval&lt;T, Traits&gt;&amp; a, const interval&lt;T, Traits&gt;&amp; b);
  template &lt;class T, class Traits&gt;  bool overlap(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  /* set manipulation interval functions */
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; intersection(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; hull(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; hull(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; hull(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template &lt;class T, class Traits&gt;  interval&lt;T, Traits&gt; hull(const T&amp; x, const T&amp; y);
  template &lt;class T, class Traits&gt;  std::pair&lt;interval&lt;T, Traits&gt;, interval&lt;T, Traits&gt; &gt; bisect(const interval&lt;T, Traits&gt;&amp; x);

  /* interval comparison operators */
  template&lt;class T, class Traits&gt;  bool operator&lt;(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template&lt;class T, class Traits&gt;  bool operator&lt;(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template&lt;class T, class Traits&gt;  bool operator&lt;(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  template&lt;class T, class Traits&gt;  bool operator&lt;=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template&lt;class T, class Traits&gt;  bool operator&lt;=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template&lt;class T, class Traits&gt;  bool operator&lt;=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  template&lt;class T, class Traits&gt;  bool operator&gt;(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template&lt;class T, class Traits&gt;  bool operator&gt;(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template&lt;class T, class Traits&gt;  bool operator&gt;(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  template&lt;class T, class Traits&gt;  bool operator&gt;=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template&lt;class T, class Traits&gt;  bool operator&gt;=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template&lt;class T, class Traits&gt;  bool operator&gt;=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);</pre>
<pre>  template&lt;class T, class Traits&gt;  bool operator==(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template&lt;class T, class Traits&gt;  bool operator==(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template&lt;class T, class Traits&gt;  bool operator==(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  template&lt;class T, class Traits&gt;  bool operator!=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
  template&lt;class T, class Traits&gt;  bool operator!=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
  template&lt;class T, class Traits&gt;  bool operator!=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

 } // namespace boost</pre>

<h2 id="interval_traits">Template class
<code>interval_traits</code></h2>

<p>The <code>interval</code> class requires two template parameters,
the first one is the type of the bounds. And the second one is a class
defining three policies. This second parameter should look like:</p>

<pre>  struct traits {
    typedef ... compare;
    typedef ... rounding;
    typedef ... checking;
  };</pre>

<p>The requirements of these three types are detailed in their
respective pages: <a href="#compare">comparison policies</a>, <a
href="#rounding">rounding policies</a>, and <a
href="#checking">checking policies</a>. In order to allow an easier
definition of this parameter, the class <code>interval_traits</code>
is defined as follows:</p>

<pre>namespace boost {

  template &lt;class T,
            class Compare = interval_lib::compare_certainly&lt;T&gt;,
            class Rounding = interval_lib::rounded_arithmetic&lt;T&gt;,
            class Checking = interval_lib::checking_strict&lt;T&gt; &gt;
  struct interval_traits
  {
    typedef T base_type;
    typedef Compare compare;
    typedef Rounding rounding;
    typedef Checking checking;
  };

} // namespace boost</pre>

<h2><a name="interval"></a>Template class <code>interval</code></h2>
The public interface of the template class interval itself is kept at a
simplest minimum:
<pre>template &lt;class T, class Traits = interval_traits&lt;T&gt; &gt;
class interval
{
  public:
    typedef T      base_type;
    typedef Traits traits_type;

    interval(const T&amp; v = T()): low(v), up(v) {}
    interval(const T&amp; l, const T&amp; u);

    template&lt;class Traits2&gt;
    interval(const interval&lt;T,Traits2&gt;&amp; r): low(r.lower()), up(r.upper()) {}

    // compiler-generated copy constructor and assignment operator are fine

    interval&amp; operator=(const T&amp; x);
    void assign(const T&amp; l, const T&amp; u);

    const T&amp; lower() const { return low; }
    const T&amp; upper() const { return up;  }

    static interval empty();
    static interval whole();
    static interval hull(const T&amp; x, const T&amp; y);

    interval&amp; operator+= (const T&amp; r);
    interval&amp; operator+= (const interval&amp; r);
    interval&amp; operator-= (const T&amp; r);
    interval&amp; operator-= (const interval&amp; r);
    interval&amp; operator*= (const T&amp; r);
    interval&amp; operator*= (const interval&amp; r);
    interval&amp; operator/= (const T&amp; r);
    interval&amp; operator/= (const interval&amp; r);
 };</pre>

<p>The two main constructors accept one and two arguments of type
T. The first one produces a singleton interval [v,v]; and the second
one an interval [l,u]. The second one will use the checking policy if
u&lt;l. If you are not sure whether the bounds are inverted or not, it
is better to use the function call <code>hull(l,u)</code>. This will
not create a problem if u&lt;l.</p>

<p>There is a template constructor in order to change the traits
parameter of an interval. But there is no constructor that changes the
base type of an interval (it could lead to violating the inclusion
property if the old base type is not contained in the new one).</p>

<p>There is an assign function in order to directly change the bounds
of an interval. It behaves like the second constructor if the bounds
are inverted.  There is no assign function that directly takes an
interval or only one number as a parameter; just use the assignment
operator in that case.</p>

<p>Assignment operator, copy constructor and destructor are the ones
the compiler automatically generates. There is also an assignment
operator for the type T.</p>

<p>The static functions <code>empty</code> and <code>whole</code>
produces the corresponding intervals. They are static member functions
rather than global functions because they cannot guess their return
types. Likewise for <code>hull</code>.</p>

<h2><a name="opers"></a>Operations and Functions</h2>

<p>Some of the following functions expect <code>min</code> and
<code>max</code> to be defined for the base type. Those are the only
requirements for the <code>interval</code> class (but the policies can
have other requirements).</p>

<h4>Operators <code>+</code> <code>-</code> <code>*</code>
<code>/</code> <code>+=</code> <code>-=</code> <code>*=</code>
<code>/=</code></h4>

<p>The basic operations are the unary minus and the binary
<code>+</code> <code>-</code> <code>*</code> <code>/</code>. The unary
minus takes an interval and returns an interval. The binary operations
take two intervals, or one interval and a number, and return an
interval. If an argument is a number instead of an interval, you can
expect the result to be the same as if the number was first converted
to an interval. This property will be true for all the following
functions and operators.</p>

<p>There are also some assignment operators <code>+=</code>
<code>-=</code> <code>*=</code> <code>/=</code>. There is not much to
say: <code>x op= y</code> is equivalent to <code>x = x op y</code>. If
an exception is thrown during the computations, the l-value is not
modified (but it may be corrupt if an exception is thrown by the base
type during an assignment).</p>

<p>The operators <code>/</code> and <code>/=</code> will try to
produce an empty interval if the denominator is exactly zero and a
whole interval if it only contains zero.</p>

<h4><code>lower</code> <code>upper</code> <code>median</code></h4>

<p><code>lower</code>, <code>upper</code>, <code>median</code>
respectively compute the lower bound, the upper bound, and the median
number of an interval (<code>(lower+upper)/2</code> rounded to
nearest). <code>width</code> computes the width of an interval
(<code>upper-lower</code> rounded toward plus infinity).</p>

<h4><code>min</code> <code>max</code> <code>abs</code>
<code>square</code> <code>pow</code></h4>

<p>The functions <code>min</code>, <code>max</code> and
<code>abs</code> are also defined. Please do not mistake them for the
functions defined in the standard library (aka
<code>a&lt;b?a:b</code>, <code>a&gt;b?a:b</code>,
<code>a&lt;0?-a:a</code>). These functions are compatible with the
elementary property of interval arithmetic. For example,
max([<i>a</i>,<i>b</i>], [<i>c</i>,<i>d</i>]) =
{max(<i>x</i>,<i>y</i>) such that <i>x</i> in [<i>a</i>,<i>b</i>] and
<i>y</i> in [<i>c</i>,<i>d</i>]}. They are not defined in the std
namespace but in the boost namespace in order to avoid conflict with
the other definitions.</p>

<p>The <code>square</code> function is quite particular. As you can
expect from its name, it computes the square of its argument. The
reason this function is provided is: <code>square(x)</code> is not
<code>x*x</code> but only a subset when <code>x</code> contains
zero. For example, [-2,2]*[-2,2] = [-4,4] but [-2,2]&sup2; = [0,4];
the result is a smaller interval.  Consequently,
<code>square(x)</code> should be used instead of <code>x*x</code>
because of its better accuracy and a small performance
improvement.</p>

<p>As for <code>square</code>, <code>pow</code> provides an efficient
and more accurate way to compute the integer power of an
interval. Please note: when the power is 0 and the interval is not
empty, the result is 1, even if the input interval contains 0.</p>

<h4><code>intersect</code> <code>hull</code> <code>overlap</code>
<code>in</code> <code>in_zero</code> <code>subset</code>
<code>proper_subset</code> <code>empty</code> <code>singleton</code>
<code>equal</code></h4>

<p><code>intersect</code> computes the set intersection of two closed
sets, <code>hull</code> computes the smallest interval which contains
the two parameters; those parameters can be numbers or intervals. If
one of the arguments is an invalid number or an empty interval, the
function will only use the other argument to compute the resulting
interval (if allowed by the checking policy).</p>

<p>There is no union function since the union of two intervals is not an
interval if they do not overlap. If they overlap, the <code>hull</code>
function computes the union.</p>

<p>The function <code>overlap</code> tests if two intervals have some
common subset. <code>in</code> tests if a number is in an interval;
<code>in_zero</code> is a variant which tests if zero is in the
interval. <code>subset</code> tests if the first interval is a subset
of the second; and <code>proper_subset</code> tests if it is a proper
subset. <code>empty</code> and <code>singleton</code> test if an
interval is empty or is a singleton. Finally, <code>equal</code> tests
if two intervals are equal.</p>

<h4><code>sqrt</code> <code>log</code> <code>exp</code>
<code>sin</code> <code>cos</code> <code>tan</code> <code>asin</code>
<code>acos</code> <code>atan</code> <code>sinh</code>
<code>cosh</code> <code>tanh</code> <code>asinh</code>
<code>acosh</code> <code>atanh</code> <code>fmod</code></h4>

<p>The functions <code>sqrt</code>, <code>log</code>,
<code>exp</code>, <code>sin</code>, <code>cos</code>,
<code>tan</code>, <code>asin</code>, <code>acos</code>,
<code>atan</code>, <code>sinh</code>, <code>cosh</code>,
<code>tanh</code>, <code>asinh</code>, <code>acosh</code>,
<code>atanh</code> are also defined. There is not much to say; these
functions extend the traditional functions to the intervals and
respect the basic property of interval arithmetic. They use the <a
href="#checking">checking</a> policy to produce empty intervals when
the input interval is strictly outside of the domain of the
function.</p>

<p>The function <code>fmod(interval x, interval y)</code> expects the
lower bound of <code>y</code> to be strictly positive and returns an
interval <code>z</code> such as <code>0 &lt;= z.lower() &lt;
y.upper()</code> and such as <code>z</code> is a superset of
<code>x-n*y</code> (with <code>n</code> being an integer). So, if the
two arguments are positive singletons, this function
<code>fmod(interval, interval)</code> will behave like the traditional
function <code>fmod(double, double)</code>.</p>

<p>Please note that <code>fmod</code> does not respect the inclusion
property of arithmetic interval. For example, the result of
<code>fmod</code>([13,17],[7,8]) should be [0,8] (since it must
contain [0,3] and [5,8]). But this answer is not really useful when
the purpose is to restrict an interval in order to compute a periodic
function. It is the reason why <code>fmod</code> will answer
[5,10].</p>

<h3>Constants</h3>

<p>Some constants are hidden in the <code>boost::interval_lib</code>
namespace. They need to be explicitely templated by the interval
type. The functions are <code>pi&lt;I&gt;()</code>,
<code>pi_half&lt;I&gt;()</code> and <code>pi_twice&lt;I&gt;()</code>,
and they return an object of interval type <code>I</code>. Their
respective values are &pi;, &pi;/2 and 2&pi;.</p>

<h3>Exception throwing</h3>

<p>The interval class and all the functions defined around this class
never throw any exceptions by themselves. However, it does not mean
that an operation will never throw an exception. For example, let's
consider the copy constructor. As explained before, it is the default
copy constructor generated by the compiler. So it will not throw an
exception if the copy constructor of the base type does not throw an
exception.</p>

<p>The same situation applies to all the functions: exceptions will
only be thrown if the base type or one of the three policies throws an
exception.</p>

<h2 id="compare"><a name="interval_lib"></a>Interval Support Library</h2>

<p>The interval support library consists of a collection of classes
that can be used and combined to fabricate almost various
commonly-needed interval traits, via the <code>interval_traits</code>
class template. In contrast to the basic classes and functions which
are used in conjunction with <code>interval&lt;T&gt;</code> (and the
default traits as the implicit second template parameter in this
type), which belong simply to the namespace boost, these components
belong to the namespace <code>boost::interval_lib</code>.</p>

<p>We merely give the synopsis here and defer each section to a
separate web page since it is only intended for the advanced
user. This allows to expand on each topic with examples, without
unduly stretching the limits of this document.</p>

<h4>Synopsis</h4>
<pre>namespace boost {
  namespace interval_lib {

<font color="#ff0000">    /* built-in comparison policies */
</font>    template &lt;class T&gt;  struct compare_certainly;
    template &lt;class T&gt;  struct compare_possibly;
    template &lt;class T&gt;  struct compare_data;
    template &lt;class T, class Function&gt;  struct compare_full;

<font color="#ff0000">    /* built-in rounding policy and its specializations */
</font>    template &lt;class T&gt;  struct rounded_math;
    template &lt;&gt;         struct rounded_math&lt;float&gt;;
    template &lt;&gt;         struct rounded_math&lt;double&gt;;
    template &lt;&gt;         struct rounded_math&lt;long double&gt;;

    <span style="color: #FF0000">/* built-in rounding construction blocks */</span>
    template &lt;class T&gt;  struct rounding_control;

    template &lt;class T, class Rounding = rounding_control&lt;T&gt; &gt;  struct rounded_arith_exact;
    template &lt;class T, class Rounding = rounding_control&lt;T&gt; &gt;  struct rounded_arith_std;
    template &lt;class T, class Rounding = rounding_control&lt;T&gt; &gt;  struct rounded_arith_opp;

    template &lt;class T, class Rounding&gt;  struct rounded_transc_dummy;
    template &lt;class T, class Rounding = rounded_arith_exact&lt;T&gt; &gt;  struct rounded_transc_exact;
    template &lt;class T, class Rounding = rounded_arith_std&lt;T&gt; &gt;  struct rounded_transc_std;
    template &lt;class T, class Rounding = rounded_arith_opp&lt;T&gt; &gt;  struct rounded_transc_opp;

    template &lt;class Rounding&gt; struct save_state;
    template &lt;class Rounding&gt; struct save_state_nothing;

<font color="#ff0000">    /* built-in checking policies */
</font>    template &lt;class T&gt; struct checking_nothing;
    template &lt;class T&gt; struct checking_lax;
    template &lt;class T&gt; struct checking_strict;

    <span style="color: #FF0000">/* some metaprogramming to convert a protected to unprotected rounding */</span>
    template &lt;class Rounding&gt; struct unprotect_rounding;
    template &lt;class Traits&gt; struct unprotect_traits;
    template &lt;class I&gt; struct unprotect;

    <span style="color: #FF0000">/* constants, need to be explicitly templated */
</span>    template&lt;class I&gt; I pi();
    template&lt;class I&gt; I pi_half();
    template&lt;class I&gt; I pi_twice();

    <span style="color: #FF0000">/* interval explicit comparison functions</span><span style="color: #FF0000">:
     * the mode can be cer=certainly or pos=possibly,
     * the function lt=less_than, gt=greater_than, le=less_than_or_equal_to, ge=greater_than_or_equal_to
     *   eq=equal_to, ne= not_equal_to
     */</span>
    template &lt;class T, class Traits&gt;  bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool cerlt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

    template &lt;class T, class Traits&gt;  bool cerle(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool cerle(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool cerle(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

    template &lt;class T, class Traits&gt;  bool cergt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool cergt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool cergt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

    template &lt;class T, class Traits&gt;  bool cerge(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool cerge(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool cerge(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

    template &lt;class T, class Traits&gt;  bool cereq(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool cereq(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool cereq(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

    template &lt;class T, class Traits&gt;  bool cerne(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool cerne(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool cerne(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

    template &lt;class T, class Traits&gt;  bool poslt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool poslt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool poslt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

    template &lt;class T, class Traits&gt;  bool posle(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool posle(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool posle(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

    template &lt;class T, class Traits&gt;  bool posgt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool posgt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool posgt(const T&amp; x, const interval&lt;T, Traits&gt; &amp; y);

    template &lt;class T, class Traits&gt;  bool posge(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool posge(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool posge(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

    template &lt;class T, class Traits&gt;  bool poseq(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool poseq(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool poseq(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

    template &lt;class T, class Traits&gt;  bool posne(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
    template &lt;class T, class Traits&gt;  bool posne(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
    template &lt;class T, class Traits&gt;  bool posne(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

  } // namespace interval_lib
} // namespace boost</pre>

<p>Each component of the interval support library is detailed in its own
page.</p>
<ul>
  <li><h4><a href="comparisons.htm">Comparisons</a></h4>
  </li>
  <li><h4><a href="rounding.htm">Rounding</a></h4>
  </li>
  <li><h4><a href="checking.htm">Checking</a></h4>
  </li>
</ul>

<h2 id="dangers">Common Pitfalls and Dangers</h2>

<h4>Comparisons</h4>

<p>One of the biggest problems is problably the correct use of the
comparison functions and operators. First, functions and operators do
not try to know if two intervals are the same mathematical object. So,
if the comparison policy is <code>compare_certainly</code>, then
<code>x != x</code> is always true unless <code>x</code> is a
singleton interval; and the same problem arises with
<code>cereq</code> and <code>cerne</code>.</p>

<p>Another misleading interpretation of the comparison is: (still with
the example of <code>compare_certainly</code>) [a,b] &lt; [c,d] is
true if and only if it is true for each pair of element in [a,b] and
[c,d]. But [a,b] &lt;= [c,d] is true if and only if it is true for at
least one pair.</p>

<p>So the best way to handle comparisons is probably to never use
operators and only call explicit functions like
<code>cerlt</code>. And if you need to compare intervals, not as
mathematical objects but as computer data, <code>compare_data</code>
is a good candidate since it defines a physical equality and a strict
ordering. This is suitable for indexing intervals in a
<code>std::map</code>, for instance.</p>

<h4>Interval values and references</h4>

<p>This problem is a corollary of the previous problem with
<code>x != x</code>. All the functions of the library only consider
the value of an interval and not the reference of an interval. In
particular, you should not expect (unless <code>x</code> is a
singleton) the following values to be equal: <code>x/x</code> and 1,
<code>x*x</code> and <code>square(x)</code>, <code>x-x</code> and 0,
etc.</p>


<h4>Unprotected rounding</h4>

<p>As explained in <a href="rounding.htm#perf">this section</a>, a
good way to speed up computations when the base type is a basic
floating-point type is to unprotect the intervals at the hot spots of
the algorithm. This method is safe and really an improvement for
interval computations. But please remember that any basic
floating-point operation executed inside the unprotection blocks will
probably have an undefined behavior (but only for the current
thread). And do not forget to create a rounding object as explained in
the <a href="rounding.htm#perfexp">example</a>.</p>

<h2 id="test">Test and Example Programs</h2>

<p>Some examples are supplied with the library. They illustrate a few
uses of intervals. For a general description and considerations on
using this library, and some potential domains of application, please
read this <a href="guide.htm">mini-guide</a>.</p>

<p>Some test programs are also distributed with the library. Their
intent is to ensure that the code is in accordance with this
documentation, and to help you find the right compilation options for
your platforms. See the above section <a href="#perfs">Compilation
options</a> for some starting points. They are a good place to try
and use the library first.</p>

<p>The test programs are as follows. Please note that they require the
use of the Boost.test library (except for interval_test.cpp).</p>

<p><b>add.cpp</b> tests if the additive and substractive operators and
the respective _std and _opp rounding functions are correctly
implemented. It is done by using symbolic expressions as a base
type.</p>

<p><b>cmp.cpp</b> tests if the operators <code>&lt;</code>
<code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code>
<code>==</code> <code>!=</code> (for the three pre-defined
comparisons) and the functions cer.. and pos.. behave correctly with
some simple intervals ([1,2] and [3,4], [1,3] and [2,4], [1,2] and
[2,3], etc).</p>

<p><b>det.cpp</b> tests if the <code>_std</code> and <code>_opp</code>
versions in protected and unprotected mode produce the same result
when Gauss scheme is used on an unstable matrix (in order to exercise
rounding). The tests are done for <code>interval&lt;float&gt;</code>
and <code>interval&lt;double&gt;</code>.</p>

<p><b>fmod.cpp</b> defines a minimalistic version of
<code>interval&lt;int&gt;</code> and uses it in order to test
<code>fmod</code> on some specific interval values.</p>

<p><b>pi.cpp</b> tests if the interval value of &pi; (for
<code>int</code>, <code>float</code> and <code>double</code> base
types) contains the number &pi; (defined with 21 decimal digits) and
if it is a subset of [&pi;±1ulp] (in order to ensure some
precision).</p>

<p><b>interval_test.cpp</b> tests if the interval library respects the
inclusion property of interval arithmetic by computing some functions
and operations for both <code>double</code> and
<cod>interval&lt;double&gt;</code>.</p>

<h2 id="rationale">Rationale</h2>

<p>The purpose of this library is to provide an efficient and
generalized way to deal with interval arithmetic through the use of a
templatized class <code>boost::interval</code>. The big contention for
which we provide a rationale is the format of this class template.</p>

<p>It would have been easier to provide a class interval whose base
type is double. Or to follow <code>std::complex</code> and allow only
specializations for <code>float</code>, <code>double</code>, and
<code>long double</code>. We decided not to do this to allow intervals
on custom types, e.g. fixed-precision bigfloat library types (MPFR,
etc.)</p>

<p><strong>Policy design.</strong> Although it was tempting to make it
a class template with only one template argument, the diversity of
uses for an interval arithmetic practically forced us to use policies.
The behavior of this class can be fixed by three policies. These
policies are packaged into a single traits class, rather than making
interval with four template parameters. This is both for ease of use
(the traits class can be picked by default) and for readability.</p>

<p>The first policy specifies the way comparison operators are
defined. The second one provides all the mathematical functions on the
base type needed to define the functions on the interval type. The
last one sets the way exceptional cases encountered during
computations are handled.</p>

<p>We could foresee situations where any combination of these policies
would be appropriate. Moreover, we wanted to enable the user of the
library to reuse the interval class template while at the same time
choosing his own behavior. See the page <a href="guide.htm">Choosing
your own interval type</a></td> for some examples.</p>

<p><strong>Rounding policy.</strong> The library provides specialized
implementations of the second policy for the primitive types float and
double. In order for these implementations to be correct and fast, the
library needs to work a lot with rounding modes. Some processors are
directly dealt with and some mecanisms are provided in order to speed
up the computations. It seems to be heavy and hazardous optimizations
for a gain of only a few computer cycles; but in reality, the speed-up
factor can easily go past 2 or 3 depending on the computer.  Moreover,
these optimizations do not impact the interface in any major way (with
the design we have chosen, everything can be added by specialization
or by passing different template parameters).</p>

<p><strong>Pred/succ.</strong> In a previous version, two functions
pred and succ, with various corollaries like widen, were supplied. The
intent was to enlarge the interval by one ulp (as little as possible),
e.g. to ensure the inclusion property. Since making interval a
template of T, we could not define <i>ulp</i> for a random parameter.
In turn, rounding policies let us eliminate entirely the use of ulp
while making the intervals tighter (if a result is a representable
singleton, there is no use to widen the interval). We decided to drop
those functions.</p>

<p><strong>Specialization of <code>std::less</code>.</strong> There is
no need to specialize <code>std::less</code> for intervals. Depending
on the result wanted, the comparison policy can be changed using the
template constructor, which has the effect of redefining the
<code>operator &lt;</code>. Hence, use the policy
<code>compare_data</code> to insert intervals in
<code>std::map</code>.</p>

<p><strong>Input/output.</strong> The basic header
<code>boost/interval.hpp</code> does not include the I/O operators for
the class interval. Somewhat default operators can be had by including
<code>boost/interval/io.hpp</code>, and they make very few effort to
guarantee the inclusion property (they do so for <code>float</code>,
<code>double</code>, and <code>long double</code>). But they cannot
guarantee it for any base number type, especially since it is not know
how the type will be displayed (for example, there could be trouble if
the type is a symbolic type that uses the character `[` or `]').  For
this, we would need an extra i/o policy. It was not felt worth the
trouble. For one thing, it's always possible to display the
bounds. For another, intervals are used somewhat internally and there
is seldom need to display them. But if this should be needed, the
header is there.</p>

<p><strong>Conversion from <code>interval&lt;T1&gt;</code> to
<code>interval&lt;T&gt;</code>.</strong> There is no such conversion
in the library. Specifically, there is no way to change the base
number type without explicitly casting both the lower and upper bounds
from <code>T1</code> to <code>T2</code> and using a constructor. We
did not want to provide this conversion because there is no easy way
to make sure the inclusion property is guaranteed: a simple casting
with loss of precision can lead to invalid or empty
intervals. Moreover it is not clear who should be responsible for the
conversion: <code>T2</code> is not required to know about all the
possible types <code>T1</code>. We also do not want to throw an
exception is there is a loss of precision (as is done for instance in
<code>numeric_cast</code>); instead, the result should be correctly
rounded to ensure the inclusion property. So we decided not to provide
the conversion and leave it up to the user to do it himself or
herself.</p>

<h2><a name="acks">History and Acknowledgments</a></h2>

<p>This library was mostly inspired by previous work from Jens Maurer. Some
discussions about his work are reproduced <a
href="http://www.mscs.mu.edu/%7Egeorgec/IFAQ/maurer1.html">here</a> and the
work itself can be found <a
href="http://www.rhein-main.de/people/jmaurer/interval.tar.gz">here</a>.
Jeremy Siek and Maarten Keijzer provided some rounding control for MSVC
and Sparc platforms.</p>

<p>Guillaume Melquiond, Hervé Brönnimann and Sylvain Pion started from
the library left by Jens and added the policy design. Guillaume and
Sylvain worked hard on the code, especially the porting and mostly
tuning of the rounding modes to the different architectures. Guillaume
mostly did most of the coding, while Sylvain and Hervé have provided
some useful comments in order for this library to be written. Hervé
reorganized and wrote chapters of the documentation based on Guillaume's
great starting point.</p>

<hr>

<p>Revised: 2002-08-30<br>
Copyright (c) Guillaume Melquiond, Sylvain Pion, Hervé Brönnimann, 2002.<br>
Polytechnic University, 2002.</p>
</body>
</html>
