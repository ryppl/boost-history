<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<title>Boost Interval Arithmetic Library</title>
</head>

<body>

<h1>
<img src="../../c++boost.gif" alt="c++boost.gif (8819 bytes)"
align="center" WIDTH="277" HEIGHT="86">
Header &lt;<a href="../../boost/interval.hpp">boost/interval.hpp</a>&gt;</h1>

<h2>Introduction</h2>

<h3>Interval Arithmetic</h3>

<p>As implied by its name, this library is intended to help
manipulating mathematical intervals. An interval is a pair of numbers
which represents all the numbers between these two. The purpose of
this library is to extend the usual arithmetic functions to
intervals. And it is underlied by this property: if <i>f</i> is a
function on a set of numbers, <b>for each</b> <i>x</i> <b>in</b> the
interval [<i>a</i>,<i>b</i>], <i>f</i>(<i>x</i>) is <b>in</b>
<i>f</i>([<i>a</i>,<i>b</i>]).</p>

<p>There are two reasons a user would like to use this library. The
obvious one is when the user has to compute intervals. The other one
appears when the computer doesn't produce exact results anymore. By
using intervals, it is possible to quantify the propagation of
rounding errors.</p>

<p>For example, let's suppose the computer stores numbers with ten
decimal significant digits. To the question 1 + 1E-100 - 1, the
computer will answer 0 although the correct answer would be
1E-100. With the help of interval arithmetic, the computer will answer
[0,1E-9]. This is quite a huge interval for such a little result, but
the precision is now known, without having to compute the error
propagation.</p>

<h3>Numbers</h3>

<p>In order to successfully use the interval arithmetic, the bounds of
the interval must present some characteristics. First of all, due to
the definition of an interval, the numbers have to be strongly
ordered. Secondly, the arithmetic must be exact or provide some
rounding methods (toward minus or plus infinity) in order to always
ensure large enough intervals. Finally, because heavy loss of
precision are always possible, some numbers have to represent
infinities or an exceptional behavior must be defined. The same
situation occurs also for NaN (<i>Not a Number</i>).</p>

<p>Knowing all of this, a good candidate can be the set of the
floating point numbers defined by the standard IEEE-754. Indeed, if
the interval arithmetic is intended to replace some arithmetic using
the floating point unit of a processor, they are the best
choice.</p>

<h3>Comparisons</h3>

<p>It is straightforward to define the elementary arithmetic
operations on intervals. It is also possible to define some comparison
operators. Given two intervals, the returned value is a subset of
{<i>false</i>,<i>true</i>}. The answers {<i>false</i>} and
{<i>true</i>} are easy to manipulate. But it is not the case for the
answer {<i>false</i>,<i>true</i>} since comparison operators are
supposed to be boolean functions.</p>

<p>So, what to do in order to obtain boolean answers? Nobody will be
shocked if {<i>false</i>} is transformed in <i>false</i> and
{<i>true</i>} in <i>true</i>. And {<i>false</i>,<i>true</i>}? First
solution, an exceptional behavior can be adopted. It will happen when
the two compared intervals overlap on more than a single point. Second
solution, {<i>false</i>,<i>true</i>} can be transformed in
<i>false</i> or <i>true</i>.</p>

<p>If <i>false</i> is chosen, the comparison will be called
"certain". Indeed, the result of [<i>a</i>,<i>b</i>] &lt;
[<i>c</i>,<i>d</i>] will be <i>true</i> if and only if <b>for each</b>
<i>x</i> <b>in</b> [<i>a</i>,<i>b</i>] and <i>y</i> <b>in</b>
[<i>c</i>,<i>d</i>], <i>x</i> &lt; <i>y</i>.</p>

<p>If <i>true</i> is chosen, the comparison will be called
"possible". Indeed, the result of [<i>a</i>,<i>b</i>] &lt;
[<i>c</i>,<i>d</i>] will be <i>true</i> if and only if it
<b>exists</b> <i>x</i> <b>in</b> [<i>a</i>,<i>b</i>] and <i>y</i>
<b>in</b> [<i>c</i>,<i>d</i>] such as <i>x</i> &lt; <i>y</i>.</p>

<h2><code>interval</code> Class</h2>

<p>This class is templated by a base type and a traits type. Here is
the synopsis of the class :</p>

<pre>
namespace boost {

template&lt;class T, class Traits = interval_traits&lt;T&gt; &gt;
class interval
{
public:
  typedef T base_type;
  typedef std::numeric_limits&lt;base_type&gt; base_limits;
  typedef Traits traits_type;

  interval(const T&amp; value = 0);
  interval(const T&amp; l, const T&amp; u);

  template&lt;class Traits2&gt;
  interval(const interval&lt;T, Traits2&gt;&amp; r);

  // compiler-generated copy constructor and assignment operator are fine
  interval&amp; operator=(const T&amp; x);
  void assign(const T&amp; l, const T&amp; u);

  // constructor-like functions
  static interval empty();
  static interval entire();

  interval&amp; operator+= (const T&amp; r);
  interval&amp; operator+= (const interval&amp; r);
  interval&amp; operator-= (const T&amp; r);
  interval&amp; operator-= (const interval&amp; r);
  interval&amp; operator*= (const T&amp; r);
  interval&amp; operator*= (const interval&amp; r);
  interval&amp; operator/= (const T&amp; r);
  interval&amp; operator/= (const interval&amp; r);

  T lower() const;
  T upper() const;
};

} // namespace boost
</pre>

<p>The <code>interval</code> class requires two template parameters,
the first one is the type of the bounds. And the second one is a class
defining three policies. This second parameter should look like:</p>

<pre>
struct traits {
  typedef ... compare;
  typedef ... rounding;
  typedef ... checking;
};
</pre>

<p>The requirements of these three types are detailled below in their
respective sections. In order to allow an easier definition of this
parameter. The <code>interval_traits</code> class is defined by:</p>

<pre>
namespace boost {

template&lt;class T,
	 class Compare = interval_lib::compare_certainly&lt;T&gt;,
	 class Rounding = interval_lib::rounded_arithmetic&lt;T&gt;,
	 class Checking = interval_lib::checking_strict&lt;T&gt; &gt;
struct interval_traits
{
  typedef T base_type;
  typedef Compare compare;
  typedef Rounding rounding;
  typedef Checking checking;
};

} // namespace boost
</pre>

<p>There is also a bunch of operators and functions defined outside
the <code>interval</code> class in the <code>boost</code>
namespace:</p>

<pre>
namespace boost {

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const T&amp; r, const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerle(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerle(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerle(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cergt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cergt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cergt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerge(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerge(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerge(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cereq(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cereq(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cereq(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerne(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerne(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerne(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool poslt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool poslt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool poslt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posle(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posle(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posle(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posgt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posgt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posgt(const T&amp; x, const interval&lt;T, Traits&gt; &amp; y);

template&lt;class T, class Traits&gt;
bool posge(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posge(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posge(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool poseq(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool poseq(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool poseq(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posne(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posne(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posne(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&lt;(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&lt;=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&gt;(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&gt;=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator==(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator==(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator==(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator!=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator!=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator!=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt; T lower(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T upper(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T width(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T median(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; pred(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; succ(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
bool empty(const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool in(const T&amp; r, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool in_zero(const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool subset(const interval&lt;T, Traits&gt;&amp; a, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool proper_subset(const interval&lt;T, Traits&gt;&amp; a, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool overlap(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; intersect(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T&gt;
interval&lt;T&gt; hull(const T&amp; x, const T&amp; y);

template&lt;class T, class Traits&gt;
std::pair&lt;interval&lt;T, Traits&gt;, interval&lt;T, Traits&gt; &gt;
bisect(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
bool singleton(const interval&lt;T, Traits&gt;&amp; x)
template&lt;class T, class Traits&gt;
bool equal(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y)

template&lt;class T, class Traits&gt;
T dist(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
T dist(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
T dist(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; scale(const interval&lt;T, Traits&gt;&amp; x, const T&amp; mirror, const T&amp; factor);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; symmetric_scale(const interval&lt;T, Traits&gt;&amp; x, const T&amp; factor);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; square(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; fmod(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; fmod(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; abs(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sqrt(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; exp(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; log(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sin(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; cos(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; tan(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; asin(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; acos(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; atan(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sinh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; cosh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; tanh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; asinh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; acosh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; atanh(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

} // namespace boost
</pre>

<p>Finally, there is also a specialization of
<code>std::numeric_limits</code> for the <code>interval</code>
class.</p>

<h2>Operations and Functions</h2>

<p>The basic operations are the unary minus and the binary <code>+ - *
/</code>. The unary operations take an interval and returns an
interval. The binary operations take two intervals, or one interval
and a number, and return an interval.</p>

<p>There are also some assignment operators <code>+= -= *=
/=</code>. There is not much to say.</p>

<p><code>lower</code>, <code>upper</code>, <code>median</code>
respectively compute the lower bound, the upper bound, and the median
number of an interval. <code>width</code> computes the width of an
interval (rounded toward plus infinity). <code>pred</code> and
<code>succ</code> respectively compute an interval strictly smaller
(if possible) and an interval strictly wider (also if possible).</p>

<p>The functions <code>min</code>, <code>max</code>, <code>abs</code>
are also defined. Please do not mistake them for the functions defined
in the standard library (aka <code>a&lt;b?a:b</code>,
<code>a&gt;b?a:b</code>, <code>a&lt;0?-a:a</code>). These functions
are compatible with the elementary property of interval
arithmetic. For example, <code>max</code>([<i>a</i>,<i>b</i>],
[<i>c</i>,<i>d</i>]) = {<code>max</code>(<i>x</i>,<i>y</i>) | <i>x</i>
in [<i>a</i>,<i>b</i>] and <i>y</i> in [<i>c</i>,<i>d</i>]}. They are
not defined in the <code>std</code> namespace but in the
<code>boost</code> namespace to avoid conflict with the other
definitions.</p>

<p>There are also some set functions. <code>intersect</code> does what
you think it does. <code>overlap</code> tests if two intervals have
some common subset. <code>hull</code> computes the smallest interval
which contains the two parameters; those parameters can be numbers or
interval. <code>in</code> tests if a number is in an interval;
<code>in_zero</code> is a variant which tests if zero is in an
interval. <code>subset</code> tests if the first interval is a subset
of the second; and <code>proper_subset</code> tests if it is a proper
subset. <code>empty</code> and <code>singleton</code> test if an
interval is empty or is a singleton. Finally, <code>equal</equal>
tests if two intervals are equal.</p>

<p>The functions <code>square sqrt log exp sin cos tan asin acos atan
sinh cosh tanh asinh acosh atanh</code> are also defined.

<h2>Comparisons</h2>

<p>As it was said before, the definition of the comparison operators
induces a slight problem. If their return type is restricted to
<code>bool</code>, there are many ways to define them. It is the
reason why the class <code>interval</code> is influenced by a
comparison policy. So the class <code>interval_traits</code> requires
an argument describing a class providing the following functions:</p>

<pre>
struct interval_compare {
  static bool lessthan(const T&amp; x_low, const T&amp; x_up, const T&amp; y_low, const T&amp; y_up);
  static bool equalto(const T&amp; x_low, const T&amp; x_up, const T&amp; y_low, const T&amp; y_up);
};
</pre>

<p>The functions <code>lessthan</code> and <code>equalto</code>
compare two intervals given their bounds. Thanks to this comparison
class, the class <code>interval</code> can now define the following
operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
<code>&gt;=</code>, <code>==</code>, <code>!=</code>. All these
operators are defined for two interval parameters, or for one interval
and a number.</p>

<p>However, these operators are not really handy. For example, if
<code>lessthan</code> is a "certain" comparison, then
<code>&lt;</code> and <code>&gt;</code> are also "certain" comparisons,
but <code>&lt;=</code> and <code>&gt;=</code> are only "possible"
comparisons. The reason of this discordance is: it is impossible to
have <code>&lt;</code> and <code>&lt;=</code> both "possible" or
"certain", and to have <code>(x&lt;=y) == !(y&lt;x)</code>. However,
if you do not consider overlapping intervals, these two types of
comparisons are equivalent.</p>

<p>To avoid these problems, it is probably better to use some explicit
comparison functions. Their names are composed by <code>cer</code>
(for "certain") or <code>pos</code> (for "possible") followed by
<code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>,
<code>eq</code> or <code>ne</code>. Each of these functions takes two
parameters and returns a boolean. For example:</p>

<pre>
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);
</pre>

<p>However, three classes are pre-defined for the comparison
policy. <code>compare_certainly</code> implements the "certain"
comparison (it is the comparison policy by default).
<code>compare_possibly</code> implements the "possible" comparison.
And <code>compare_full</code> allows the user to specify a behavior in
case of not-boolean result (an exception for example).</p>

<pre>
namespace boost {
  namespace interval_lib {

template&lt;class T&gt; struct compare_certainly;
template&lt;class T&gt; struct compare_possibly;
template&lt;class T, class Function&gt; struct compare_full;

  } // namespace interval_lib
} // namespace boost
</pre>

<p>As you have probably guessed, the <code>Function</code> parameter
of <code>compare_full</code> is the type of a function object called
in case of not-boolean result. So it must have an operator <code>bool
Function::operator()()</code>. Here is a little example of the
behavior of the comparison operators when <code>compare_full</code> is
the choosen policy:</p>

<ul>

<li>[1,2] &lt;= [2,3] will return <code>true</code>;

<li>[1,2] &gt; [2,3] will return <code>false</code>;

<li>[1,2] &lt; [2,3] will return the result of <code>Function()()</code>;

<li>and [1,2] &gt;= [2,3] will return <code>!Function()()</code>.

</ul>

<h2>Rounded Arithmetic</h2>

<p>Here comes the tricky part. In order to be as general as possible,
the library uses a class to compute all the necessary functions
rounded upward or downward. This class is the second parameter of
<code>interval_traits</code>.</p>

<pre>
struct rounding {
  T add_down(const T&amp;, const T&amp;);
  T add_up(const T&amp;, const T&amp;);
  T sub_down(const T&amp;, const T&amp;);
  T sub_up(const T&amp;, const T&amp;);
  T mul_down(const T&amp;, const T&amp;);
  T mul_up(const T&amp;, const T&amp;);
  T div_down(const T&amp;, const T&amp;);
  T div_up(const T&amp;, const T&amp;);
  T sqrt_down(const T&amp;);
  T sqrt_up(const T&amp;);
  T exp_down(const T&amp;);
  T exp_up  (const T&amp;);
  T log_down(const T&amp;);
  T log_up  (const T&amp;);
  T cos_down(const T&amp;);
  T cos_up  (const T&amp;);
  T tan_down(const T&amp;);
  T tan_up  (const T&amp;);
  T asin_down(const T&amp;);
  T asin_up  (const T&amp;);
  T acos_down(const T&amp;);
  T acos_up  (const T&amp;);
  T atan_down(const T&amp;);
  T atan_up  (const T&amp;);
  T sinh_down(const T&amp;);
  T sinh_up  (const T&amp;);
  T cosh_down(const T&amp;);
  T cosh_up  (const T&amp;);
  T tanh_down(const T&amp;);
  T tanh_up  (const T&amp;);
  T asinh_down(const T&amp;);
  T asinh_up  (const T&amp;);
  T acosh_down(const T&amp;);
  T acosh_up  (const T&amp;);
  T atanh_down(const T&amp;);
  T atanh_up  (const T&amp;);
  T int_down(const T&amp;);
  T int_up  (const T&amp;);
  T pi_down();
  T pi_up();
  T pi_1_2_down();
  T pi_1_2_up();
  T pi_2_1_down();
  T pi_2_1_up();
};
</pre>

<p>These functions do not have to worry about invalid
arguments. Moreover, the argument of the <code>cos_</code> functions
is between 0 and 2&pi;; and the argument of the <code>tan_</code>
functions is between -&pi;/2 and &pi;/2.</p>

<p>The functions <code>int_down</code> and <code>int_up</code>
computes the nearest integer smaller or bigger than their
argument. The <code>pi_</code> functions are supposed to return bounds
of some constants. <code>pi</code> clearly stands for the mathematical
constant &pi;. <code>pi_1_2</code> stands for &pi;/2 and
<code>pi_2_1</code> stands for 2&pi;.</p>

<p>The class <code>boost::interval_lib::detail::tonearest</code>
should also be appropriately specialized for this class in order for
the functions <code>median</code>, <code>bisect</code> and
<code>dist</code> to work. The purpose of this class is: the basic
operators <code>+ - * /</code> will be rounded toward the nearest
integer while the object of type
<code>boost::interval_lib::detail::tonearest&lt;rounding&gt;::type</code>
is alive.</p>

<p>A lot of classes are provided. When they exist in two versions
<code>_standard</code> and <code>_opposite_trick</code>, the first one
does switch the rounding mode each time, and the second one tries to
keep it oriented toward plus infinity.</p>

<p>First, there is <code>save_state</code>. This class is responsible
to save the current rounding mode and call <code>init</code> in its
constructor, and to restore the saved rounding mode in its
destructor. If used, this class should be the one given to
<code>interval_traits</code> in order for the unprotect mecanism to
correctly work (if it is not, there will be no problem, just a loss of
performance).</p>

FIXME -------------------------------------- begin

<p>In order to simplify the use of the library, two templates are
provided: <code>rounded_arithmetic_standard</code> and
<code>rounded_arithmetic_opposite_trick</code>. The first one changes
the rounding mode for each operation. The second one uses the trick
described in the paragraph "Note on performance" to avoid switching
when possible.</p>

<pre>
template &lt;class T, class Rounding&gt;
struct rounded_arithmetic_standard;
template &lt;class T, class Rounding&gt;
struct rounded_arithmetic_opposite_trick;
</pre>

<p><code>rounded_arithmetic_standard</code> is not really useful and
is only provided as a test case. It is better to use
<code>rounded_arithmetic_opposite_trick</code> when possible and to
define a new class if not (for example in order to use a
multi-precision type). This two structs take two template
parameters. The first one is the base type. And the second one is a
class able to change the rounding mode. It must provide the following
functions:</p>

<pre>
struct rounding {
  void downward();
  void upward();
  T force_rounding(const T&amp;);
};
</pre>

<p>The last function ensures that the current rounding mode is
effectively applied; it can be used as a workaround for FPUs which
compute with an extended precision. In order to use the
<code>save_state</code> described below, the class must be extended
with:</p>

<pre>
struct rounding {
  ...
  typedef ... rounding_mode;
  void set_rounding_mode(rounding_mode mode);
  rounding_mode get_rounding_mode();
};

template&lt;class Rounding&gt;
struct save_state;
</pre>

<p><code>save_state</code> is a structure used to save and restore the
rounding mode at the time of construction and destruction of the
rounding object. Thanks to this behavior, the operations on intervals
restore the rounding mode at the end of their computations.</p>

<h3>Some Examples</h3>

<p>The default behavior uses <code>rounded_arithmetic_standard</code>.
There is a specialization in order to use the primitive types
<code>float</code> and <code>double</code> with
<code>rounded_arithmetic_opposite_trick</code> and
<code>save_state</code>.</p>

<pre>
template&lt;class T&gt;
struct rounded_arithmetic:
    rounded_arithmetic_standard&lt;T, rounding_control&lt;T&gt; &gt;
{};

template&lt;&gt;
struct rounded_arithmetic&lt;double&gt;:
  rounded_arithmetic_opposite_trick&lt;double,
				    save_state&lt;rounding_control&lt;double&gt; &gt; &gt;
{};
</pre>

<p>If the default behavior is not what you seek, there are many
possibilities:</p>

<ul>
<li>For fast wide intervals without any rounding nor precision, use
<code>rounded_arithmetic_standard&lt;T, no_rounding_control&lt;T&gt;
&gt;</code>.

<li>For computations without rounding mode switch, use
<code>rounded_arithmetic_opposite_trick&lt;T,
no_rounding_control&lt;T&gt; &gt;</code>. The rounding mode must be
set at the beginning toward plus infinity, and it must not change
anymore (or it must be restored before each operation on intervals).

<li>For precise computations which do not restore rounding mode at the
end of the operations, use
<code>rounded_arithmetic_opposite_trick&lt;T,
rounding_control&lt;T&gt; &gt;.</code>

<li>For interval on a multi-precision base type, specialize
<code>rounded_arithmetic</code>.

<li>etc

</ul>


FIXME -------------------------------------- end

<h2>Checking</h2>

<p>The last customizable part of <code>interval_traits</code> deals
with exception handling. For example, when two intervals are divided,
if the second contains zero, the result of the division is
undefined. In this case, the answer will be the biggest interval in
order to try to respect the basic property of the interval
arithmetic. However, this behavior is not necessarily the one the user
expect. And that is here this third parameter of
<code>interval_traits</code> plays a part.</p>

<p>An important fact to understand is: the behavior defined by this
parameter is only invoked if the input intervals of a function are not
fully included in the domain of the function. If the input intervals
are inside this domain but the result are exceptionnal (for example in
case of an overflow during the computations), the members of this
checking class will not be called.</p>

<p>There is another important matter. The checking policy does not
allow to say what the results should be in case of problem. It is only
allowed to point out the problem (through an exception for example).</p>

<p>The checking class should be of the following type:</p>

<pre>
struct checking
{
  static void inverted_bound(const T&amp; l, const T&amp; u);
  static void divide_by_zero(const T&amp; l, const T&amp; u);
  static void sqrt_nan();
  static void logarithmic_nan();
  static void logarithmic_inf();
  static void trigonometric_nan();
  static void trigonometric_inf();
  static void hyperbolic_nan();
  static void hyperbolic_inf();
};
</pre>

<p>The first function, <code>inverted_bound</code>, deals with the
call to a constructor like <code>interval::interval(const T&amp; l,
const T&amp; u)</code> or a function like <code>void
interval::assign(const T&amp; l, const T&amp; u)</code> when
<code>l</code> is not lesser or equal to <code>u</code>. It is
generally a good idea to throw an exception if the function
<code>inverted_bound</code> is called. The parameters of the function
are the faulty bounds of the interval. If the function returns to the
caller, the final result will be the empty interval.</p>

<p><code>divide_by_zero</code> is called each time the second interval
of a division contains zero. If the function returns to the caller,
the final result will be the entire interval. The faulty interval is
given as an argument in order for the user to differentiate between a
loss of precision and a bug in the program.</p>

<p>Indeed if the interval is [0,0], there clearly is a problem
somewhere. It is generally not an error when a floating-point number
is divided by zero, because it can be caused by a loss of precision or
an underflow. However, it is not true anymore for the interval
arithmetic when used to obtain "exact" results. Because the interval
[0,0] means that the result is exactly zero.</p>

<p>This is also the reason why the functions <code>sqrt_nan</code>,
<code>logarithmic_nan</code>, <code>trigonometric_nan</code> and
<code>hyperbolic_nan</code> are defined, since a function should not
be called with an input completely outside of its definition
domain. Like it was for <code>inverted_bound</code> and
<code>divide_by_zero(0, 0)</code>, it usually is a good idea to throw
an exception because the program is defective.</p>

<p>The purpose of the functions <code>logarithmic_inf</code>,
<code>trigonometric_inf</code>, <code>hyperbolic_inf</code> is
different. These functions are called when the input intervals are
partially outside the definition and that will lead to an infinite
result. For example, <code>log</code>([-1,1]) will trigger
<code>logarithmic_inf</code> but <code>exp</code>([0,1e1000]) will not
trigger anything (although the upper bound will be infinity).</p>

<p><code>sqrt_nan</code> is called by <code>sqrt</code>.
<code>logarithmic_inf</code> and <code>logarithmic_nan</code> are
called by <code>log</code>.  <code>trigonometric_nan</code> is called
by <code>asin</code> and <code>acos</code>.
<code>trigonometric_inf</code> is called by <code>tan</code>.
<code>hyperbolic_nan</code> is called by <code>acosh</code> and
<code>atanh</code>. <code>hyperbolic_inf</code> is called by
<code>atanh</code>.</p>

<p>As a side note, because the constant &pi; usually suffers from a
lack of precision, <code>tan</code> is unfortunatelly unable to
trigger <code>trigonometric_nan</code> on an input like [&pi;/2,
&pi;/2].</p>

<p>Some checking policies are already defined.
<code>checking_nothing</code> will not do anything; each function is
empty. <code>checking_lax</code> will only throw an exception when
<code>inverted_bound</code> is called. <code>checking_strict</code>
will throw exceptions when <code>inverted_bound</code>,
<code>divide_by_zero(0,0)</code> and each <code>_nan</code> functions
are called. This last policy is the policy by default.</p>

<pre>
namespace boost {
  namespace interval_lib {

template&lt;class T&gt; struct checking_nothing;
template&lt;class T&gt; struct checking_lax;
template&lt;class T&gt; struct checking_strict;

  } // namespace interval_lib
} // namespace boost
</pre>

<p>The thrown exceptions are <code>std::invalid_argument</code> with
an error message looking like <code>"boost::interval: &lt;something
appropriate&gt;"</code>.</p>

<h2>Performance Notes</h2>

<p>This paragraph deals mostly with the performance of the library
with intervals using the floating point unit (FPU) of the
computer. Let's consider the sum of [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] as an example. The result is
[<code>down</code>(<i>a</i>+<i>c</i>),
<code>up</code>(<i>b</i>+<i>d</i>)]. <code>down</code> and
<code>up</code> indicate the rounding mode needed.</p>

<h3>Rounding Mode Switch</h3>

<p>If the FPU is able to use a different rounding mode for each
operation, there is no problem. For example, it's the case for the
Alpha processor: each floating-point instruction can specify a
different rounding mode. However, the standard does not require such a
behavior. So most of the FPUs only provide some instructions to set
the rounding mode for all subsequent operations. And generally, these
instructions need to flush the pipeline of the FPU.</p>

<p>In this situation, the time needed to sum [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] is far worse than the time needed to calculate
<i>a</i>+<i>b</i> and <i>c</i>+<i>d</i> since the two additions cannot
be parallelized. Consequently, the objective is to diminish the number
of rounding mode switch.</p>

<p>If this library is not used to provide exact computations, but only
for pair arithmetic, the solution is quite simple: do not use
rounding. In that case, doing the sum [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] will be as fast as computing <i>a</i>+<i>b</i> and
<i>c</i>+<i>d</i>. Everything is perfect.</p>

<p>However, if exact computations are required, such a solution is
totally unthinkable. So, are we penniless? No, there is still a trick
available. Indeed, <code>down</code>(<i>a</i>+<i>c</i>) =
-<code>up</code>(-<i>a</i>-<i>c</i>) if the unary minus is an exact
operation. It is now possible to calculate the whole sum with the same
rounding mode. Generally, the cost of the mode switching is worse than
the cost of the sign changes.</p>

<p>Let's recapitulate. Before, when doing an addition, there were
three rounding mode switches (<code>down</code>, <code>up</up> and
restore). Now, with this little trick, there are only two switches
(<code>up</up> and restore). It is better, but still a bottleneck when
many operations are nested. Indeed, the generated code for
[<i>a</i>,<i>b</i>] + [<i>c</i>,<i>d</i>] + [<i>e</i>,<i>f</i>] will
probably look like:</p>

<blockquote>
<pre>
up();
t1 = -(-a - c);
t2 = b + d;
restore();
up();
x = -(-t1 - e);
y = t2 + f;
restore();
</pre>
</blockquote>

<p>If you think it is possible to do much better, you are right. For
example, this is better (and probably optimal):</p>

<blockquote>
<pre>
up();
x = -(-a - c - e);
y = b + d + f;
restore();
</pre>
</blockquote>

<p>Such a code will be generated by a compiler if the computations are
made without initialization and restoration of the rounding
mode. However, it would be far too easy if there was no drawback:
because the rounding mode is not restored in the meantime, operations
on floating point numbers must be prohibited. This method can only be
used if all the operations are operations on interval. Here is an
example of the Horner scheme to compute the value of a polynom.</p>

<pre>
// I is an interval class, the polynom is a simple array
template&lt;class I&gt;
I horner(const I&amp; x, const I p[], int n) {

  // initialize and restore the rounding mode
  typename I::traits_type::rounding rnd;

  // define the unprotected version of the interval type
  typedef typename boost::interval_lib::unprotect&lt;I&gt;::type R;
  
  R a = x;
  R y = p[n - 1];
  for(int i = n - 2; i >= 0; i--) {
    y = y * a + (R)(p[i]);
  }
  return y;
}
</pre>

<p>It was said at the beginning that the Alpha processors can use a
specific rounding mode for each operation. However, due to the
instruction format, the rounding toward plus infinity is not
available. Only the rounding toward minus infinity can be used. So the
trick using the change of sign becomes essential, but there is no need
to save and restore the rounding mode on both sides of an
operation.</p>

<h3>Extended Registers</h3>

<p>There is another problem besides the cost of the rounding mode
switch. Some FPUs use extended registers (for example,
<code>float</code> computations will be done with <code>double</code>
registers, or <code>double</code> computations with <code>long
double</code> registers). Consequently, many problems can arise.</p>

<p>The first one is due to to the extended precision of the
mantissa. The rounding is also done on this extended precision. And
consequently, we still have <code>down</code>(<i>a</i>+<i>b</i>) =
-<code>up</code>(-<i>a</i>-<i>b</i>) in the extended registers. But
back to the standard precision, we now have
<code>down</code>(<i>a</i>+<i>b</i>) &lt;
-<code>up</code>(-<i>a</i>-<i>b</i>) instead of an equality. A
solution could be not to use this method. But there still are other
problems, with the comparisons between numbers for example.</p>

<p>Naturally, there is also a problem with the extended precision of
the exponent. To illustrate this problem, let <i>m</i> be the biggest
number before +<i>inf</i>. If we calculate 2*[<i>m</i>,<i>m</i>], the
answer should be [<i>m</i>,<i>inf</i>]. But due to the extended
registers, the FPU will first store [<i>2m</i>,<i>2m</i>] and then
convert it to [<i>inf</i>,<i>inf</i>] at the end of the calculus (when
the rounding mode is toward +<i>inf</i>). So the answer is no more
accurate.</p>

<p>There is only one solution: to force the FPU to convert the
extended values back to standard precision after each operation. Some
FPUs provide an instruction able to do this conversion (for example
the PowerPC processors). But for the FPUs that do not provide it (the
x86 processors), the only solution is to write the values to memory
and read them back. Such an operation is obviously very expensive.</p>


</body>
</html>
