<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<title>Boost Interval Arithmetic Library</title>
</head>

<body>

<h1>
<img src="../../../c++boost.gif" alt="c++boost.gif (8819 bytes)"
align="center" WIDTH="277" HEIGHT="86"> Header &lt;<a
href="../../../boost/interval.hpp">boost/interval.hpp</a>&gt;</h1>

<h2>Introduction</h2>

<h3>Interval Arithmetic</h3>

<p>As implied by its name, this library is intended to help
manipulating mathematical intervals. An interval is a pair of numbers
which represents all the numbers between these two. The purpose of
this library is to extend the usual arithmetic functions to
intervals. These intervals will be written [<i>a</i>,<i>b</i>] to
represent all the numbers between <i>a</i> and <i>b</i>. <i>a</i> and
<i>b</i> can be infinite (but they can not be the same infinite) and
<i>a</i> &lt;= <i>b</i>.</p>

<p>The fondamental property of interval arithmetic is: if <i>f</i> is
a function on a set of numbers, <i>f</i> can be extended to a new
function defined on intervals. This new function <i>f</i> takes one
interval argument and returns an interval result such as: <b>for
each</b> <i>x</i> <b>in</b> [<i>a</i>,<i>b</i>], <i>f</i>(<i>x</i>) is
<b>in</b> <i>f</i>([<i>a</i>,<i>b</i>]). Such a property is not
limited to functions with only one argument. Whenever possible, the
interval result should be the smallest one able to satisfy the
property (it is not really useful if the new functions always answer
[-<i>inf</i>,+<i>inf</i>]).</p>

<p>There are two reasons a user would like to use this library. The
obvious one is when the user has to compute intervals. The other one
appears when the computer doesn't produce exact results anymore. By
using intervals, it is possible to quantify the propagation of
rounding errors.</p>

<p>For example, let's suppose the computer stores numbers with ten
decimal significant digits. To the question 1 + 1E-100 - 1, the
computer will answer 0 although the correct answer would be
1E-100. With the help of interval arithmetic, the computer will answer
[0,1E-9]. This is quite a huge interval for such a little result, but
the precision is now known, without having to compute the error
propagation.</p>

<h3>Numbers</h3>

<p>In order to successfully use interval arithmetic, the bounds of the
interval must present some characteristics. First of all, due to the
definition of an interval, the numbers have to be strongly ordered (so
complex numbers are not usable as bounds). The mathematical functions
for this type should also have the same monotonicity properties than
for the real numbers (so modulo types are not usable
either). Secondly, the computations must be exact or provide some
rounding methods (toward minus or plus infinity) in order to always
ensure large enough intervals. Finally, because heavy loss of
precision are always possible, some numbers have to represent
infinities or an exceptional behavior must be defined. The same
situation also occurs for NaN (<i>Not a Number</i>).</p>

<p>Knowing all of this, a good candidate can be the set of the
floating-point numbers defined by the standard IEEE-754. Indeed, if
the interval arithmetic is intended to replace some arithmetic using
the floating point unit of a processor, they are the best
choice.</p>

<h3>Comparisons</h3>

<p>It is straightforward to define the elementary arithmetic
operations on intervals. It is also possible to define some comparison
operators. Given two intervals, the result is a subset of
{<i>false</i>,<i>true</i>}. The answers {<i>false</i>} and
{<i>true</i>} are easy to manipulate since they can directly be mapped
on <i>true</i> and <i>false</i>. But it is not the case for the answer
{<i>false</i>,<i>true</i>} since comparison operators are supposed to
be boolean functions.</p>

<p>So, what to do in order to obtain boolean answers? Nobody will be
shocked if {<i>false</i>} is transformed in <i>false</i> and
{<i>true</i>} in <i>true</i>. And {<i>false</i>,<i>true</i>}? First
solution, an exceptional behavior can be adopted. It will happen when
the two compared intervals overlap on more than a single point. Second
solution, {<i>false</i>,<i>true</i>} can be transformed in
<i>false</i> or <i>true</i>.</p>

<p>If <i>false</i> is chosen, the comparison will be called
"certain". Indeed, the result of [<i>a</i>,<i>b</i>] &lt;
[<i>c</i>,<i>d</i>] will be <i>true</i> if and only if <b>for each</b>
<i>x</i> <b>in</b> [<i>a</i>,<i>b</i>] and <i>y</i> <b>in</b>
[<i>c</i>,<i>d</i>], <i>x</i> &lt; <i>y</i>.</p>

<p>If <i>true</i> is chosen, the comparison will be called
"possible". Indeed, the result of [<i>a</i>,<i>b</i>] &lt;
[<i>c</i>,<i>d</i>] will be <i>true</i> if and only if it
<b>exists</b> <i>x</i> <b>in</b> [<i>a</i>,<i>b</i>] and <i>y</i>
<b>in</b> [<i>c</i>,<i>d</i>] such as <i>x</i> &lt; <i>y</i>.</p>

<h2><code>interval</code> Class</h2>

<p>This class is templated by a base type and a traits type. Here is
the synopsis of the class :</p>

<pre>
namespace boost {

template&lt;class T, class Traits = interval_traits&lt;T&gt; &gt;
class interval
{
public:
  typedef T base_type;
  typedef std::numeric_limits&lt;base_type&gt; base_limits;
  typedef Traits traits_type;

  interval(const T&amp; v = 0);
  interval(const T&amp; l, const T&amp; u);

  template&lt;class Traits2&gt;
  interval(const interval&lt;T, Traits2&gt;&amp; r);

  // compiler-generated copy constructor and assignment operator are fine

  interval&amp; operator=(const T&amp; x);
  void assign(const T&amp; l, const T&amp; u);

  static interval empty();
  static interval entire();

  interval&amp; operator+= (const T&amp; r);
  interval&amp; operator+= (const interval&amp; r);
  interval&amp; operator-= (const T&amp; r);
  interval&amp; operator-= (const interval&amp; r);
  interval&amp; operator*= (const T&amp; r);
  interval&amp; operator*= (const interval&amp; r);
  interval&amp; operator/= (const T&amp; r);
  interval&amp; operator/= (const interval&amp; r);

  const T&amp; lower() const;
  const T&amp; upper() const;
};

} // namespace boost
</pre>

<p>The <code>interval</code> class requires two template parameters,
the first one is the type of the bounds. And the second one is a class
defining three policies. This second parameter should look like:</p>

<pre>
struct traits {
  typedef ... compare;
  typedef ... rounding;
  typedef ... checking;
};
</pre>

<p>The requirements of these three types are detailled below in their
respective sections: <a href="#compare">compare</a>, <a
href="#rounding">rounding</a>, <a href="#checking">checking</a>. In
order to allow an easier definition of this parameter, the
<code>interval_traits</code> class is provided:</p>

<pre>
namespace boost {

template&lt;class T,
	 class Compare = interval_lib::compare_certainly&lt;T&gt;,
	 class Rounding = interval_lib::rounded_arithmetic&lt;T&gt;,
	 class Checking = interval_lib::checking_strict&lt;T&gt; &gt;
struct interval_traits
{
  typedef T base_type;
  typedef Compare compare;
  typedef Rounding rounding;
  typedef Checking checking;
};

} // namespace boost
</pre>

<p>There is also a bunch of operators and functions defined outside
the <code>interval</code> class in the <code>boost</code>
namespace:</p>

<pre>
namespace boost {

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const T&amp; r, const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerle(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerle(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerle(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cergt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cergt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cergt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerge(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerge(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerge(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cereq(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cereq(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cereq(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerne(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerne(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerne(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool poslt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool poslt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool poslt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posle(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posle(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posle(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posgt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posgt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posgt(const T&amp; x, const interval&lt;T, Traits&gt; &amp; y);

template&lt;class T, class Traits&gt;
bool posge(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posge(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posge(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool poseq(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool poseq(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool poseq(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posne(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posne(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posne(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&lt;(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&lt;=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&gt;(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&gt;=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator==(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator==(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator==(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator!=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator!=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator!=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt; T lower(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T upper(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T width(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T median(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; pred(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; succ(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
bool empty(const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool in(const T&amp; r, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool in_zero(const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool subset(const interval&lt;T, Traits&gt;&amp; a, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool proper_subset(const interval&lt;T, Traits&gt;&amp; a, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool overlap(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; intersect(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T&gt;
interval&lt;T&gt; hull(const T&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool singleton(const interval&lt;T, Traits&gt;&amp; x)
template&lt;class T, class Traits&gt;
bool equal(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y)


template&lt;class T, class Traits&gt;
std::pair&lt;interval&lt;T, Traits&gt;, interval&lt;T, Traits&gt; &gt; bisect(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; square(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; fmod(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; fmod(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; fmod(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; abs(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sqrt(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; exp(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; log(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sin(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; cos(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; tan(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; asin(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; acos(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; atan(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sinh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; cosh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; tanh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; asinh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; acosh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; atanh(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

} // namespace boost
</pre>

<p>Finally, there is also a specialization of
<code>std::numeric_limits</code> for the <code>interval</code>
class.</p>

<h2>Operations and Functions</h2>

<p>Some of the following functions expect <code>std::min</code> and
<code>std::max</code> to be defined for the base type. They also
expect <code>std::numeric_limits</code> to be correctly specialized
for the base type. Those are the only requirements for the
<code>interval</code> class (but the policies can have other
requirements).</p>

<h4>Operators <code>+ - * / += -= *= /=</code></h4>

<p>The basic operations are the unary minus and the binary <code>+ - *
/</code>. The unary minus takes an interval and returns an
interval. The binary operations take two intervals, or one interval
and a number, and return an interval. If an argument is a number
instead of an interval, you can expect the result to be the same as if
the number was first converted to an interval. This property will be
true for all the following functions and operators.</p>

<p>There are also some assignment operators <code>+= -= *=
/=</code>. There is not much to say: <code>x op= y</code> is
equivalent to <code>x = x op y</code>. If an exception is thrown
during the computations, the l-value is not modified.</p>

<p>The operators <code>/</code> and <code>/=</code> use the <a
href="#checking">checking</a> policy if necessary.</p>

<h4><code>lower upper median pred succ</code></h4>

<p><code>lower</code>, <code>upper</code>, <code>median</code>
respectively compute the lower bound, the upper bound, and the median
number of an interval (<code>(lower+upper)/2</code> rounded to
nearest). <code>width</code> computes the width of an interval
(<code>upper-lower</code> rounded toward plus
infinity).</p>

<p><code>pred</code> and <code>succ</code> respectively compute the
widest interval strictly smaller and the smallest interval strictly
wider. Let's suppose the functions <code>p</code> and <code>s</code>
are able to compute a number respectively strictly smaller and
strictly bigger than their argument (if not possible, they return
their argument unmodified). Then <code>succ(x) == [p(x),s(x)]</p> and
<code>pred(x) == [s(x),p(x)]</code> (or <code>pred(x) == x</code> if
<code>s(x)&gt;p(x)</code>). Consequently, you can not always expect
<code>lower(succ(x))</code> to be stricly smaller than
<code>lower(x)</code> (for example if <code>lower(x)</code> is minus
infinity) and some other similar properties, but it is often true.</p>

<h4><code>min max abs square</code></h4>

<p>The functions <code>min</code>, <code>max</code>, <code>abs</code>
are also defined. Please do not mistake them for the functions defined
in the standard library (aka <code>a&lt;b?a:b</code>,
<code>a&gt;b?a:b</code>, <code>a&lt;0?-a:a</code>). These functions
are compatible with the elementary property of interval
arithmetic. For example, <code>max</code>([<i>a</i>,<i>b</i>],
[<i>c</i>,<i>d</i>]) = {<code>max</code>(<i>x</i>,<i>y</i>) | <i>x</i>
in [<i>a</i>,<i>b</i>] and <i>y</i> in [<i>c</i>,<i>d</i>]}. They are
not defined in the <code>std</code> namespace but in the
<code>boost</code> namespace in order to avoid conflict with the other
definitions.</p>

<p>The <code>square</code> function is quite particular. As you can
expect from its name, it computes the square of its argument. The
reason this function is provided is: <code>square(x)</code> is not
<code>x*x</code> but only a subset when <code>x</code> contains
zero. For example, [-2,2]*[-2,2] = [-4,4] but [-2,2]&sup2; = [0,4];
the result is a smaller interval. Consequently, <code>square(x)</code>
should be used instead of <code>x*x</code> because of its better
accuracy.</p>

<h4><code>intersect hull overlap in in_zero subset proper_subset empty
singleton equal</code></h4>

<p>There are also some set functions. <code>intersect</code> does what
you think it does. <code>hull</code> computes the smallest interval
which contains the two parameters; those parameters can be numbers or
intervals.</p>

<p>There is no <code>union</code> function since the union of two
intervals is not an interval if they do not overlap. If they overlap,
the <code>hull</code> function computes the union.</p>

<p><code>overlap</code> tests if two intervals have some common
subset. <code>in</code> tests if a number is in an interval;
<code>in_zero</code> is a variant which tests if zero is in an
interval. <code>subset</code> tests if the first interval is a subset
of the second; and <code>proper_subset</code> tests if it is a proper
subset. <code>empty</code> and <code>singleton</code> test if an
interval is empty or is a singleton. Finally, <code>equal</equal>
tests if two intervals are equal.</p>

<h4><code>sqrt log exp sin cos tan asin acos atan sinh cosh tanh asinh
acosh atanh fmod</code></h4>

<p>The functions <code>sqrt log exp sin cos tan asin acos atan sinh
cosh tanh asinh acosh atanh</code> are also defined. There is not much
to say; these functions extend the traditional functions to the
intervals and respect the basic property of interval arithmetic. They
use the <a href="#checking">checking</a> policy if needed.</p>

<p>The function <code>fmod(interval x, interval y)</code> expects the
lower bound of <code>y</code> to be strictly positive and returns an
interval <code>z</code> such as <code>0 &lt;= z.lower() &lt;
y.upper()</code> and such as <code>z</code> is a superset of
<code>x-n*y</code> (with <code>n</code> being an integer). So, if the
two arguments are positive singletons, this function
<code>fmod(interval, interval)</code> will behave like the traditional
function <code>fmod(double, double)</code>.</p>

<p>Please note that <code>fmod</code> does not respect the basic
property of arithmetic interval. For example, the result of
<code>fmod([13,17],[7,8])</code> should be <code>[0,8]</code> (since
it must contain <code>[0,3]</code> and <code>[5,8]</code>). But this
answer is not really useful when the purpose is to restrict an
interval in order to compute a periodic function. It is the reason why
<code>fmod</code> will answer <code>[5,10]</code>.</p>

<h3>Constructors and alike</h3>

<p>The two main constructors accept one and two arguments of type
<code>T</code>. The first one produces a singleton interval
<code>[v,v]</code>; and the second one an interval
<code>[l,u]</code>. The second one will use the checking policy if
<code>u&lt;l</code>. If you are not sure the bounds are not inverted,
it is better to use the <code>hull</code> function.</p>

<p>There is also a constructor in order to change the traits parameter
of an interval. But there is no constructor able to change the base
type of an interval (it could lead to precision problems if the old
base type could not be contained in the new one.</p>

<p>There is also an <code>assign</code> function in order to directly
change the bounds of an interval. It will behave like the second
constructor if the bounds are inverted. There is no
<code>assign</code> function that directly takes an interval or only
one number as a parameter; just use the assignment operator in that
case.</p>

<p>Assignment operator, copy constructor and destructor are the ones
the compiler automatically generates. There is also an assignment
operator for the type <code>T</code>.</p>

<p>The static functions <code>empty</code> and <code>entire</code>
produces the corresponding intervals. Please be aware that the default
implementation use NaN numbers for the empty interval and infinite
numbers for the entire interval.</p>

<h3>Constants</h3>

<p>Some constants are hidden in the <code>boost::interval_lib</code>
namespace:</p>

<pre>
namespace boost {
  namespace interval_lib {

template&lt;class I&gt; I pi();
template&lt;class I&gt; I pi_1_2();
template&lt;class I&gt; I pi_2_1();

  } // namespce interval_lib
} // namespace boost
</pre>

<p>Their respective values are &pi;, &pi;/2 and 2&pi;.</p>

<h2 id="compare">Comparisons</h2>

<h3>Synopsis</h3>

<p>As it was said before, the definition of the comparison operators
induces a slight problem. If their return type is restricted to
<code>bool</code>, there are many ways to define them. It is the
reason why the class <code>interval</code> is influenced by a
comparison policy. So the class <code>interval_traits</code> requires
an argument describing a class providing the following functions:</p>

<pre>
struct interval_compare {
  static bool lessthan(T x_low, T x_up, T y_low, T y_up);
  static bool equalto(T x_low, T x_up, T y_low, T y_up);
};
</pre>

<p>The functions <code>lessthan</code> and <code>equalto</code>
compare two intervals given their bounds. Thanks to this comparison
class, the class <code>interval</code> can now define the following
operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
<code>&gt;=</code>, <code>==</code>, <code>!=</code>. All these
operators are defined for two interval parameters, or for one interval
and a number.</p>

<h3>Provided classes</h3>

<p>Three classes are pre-defined for the comparison
policy. <code>compare_certainly</code> implements the "certain"
comparison (it is the comparison policy by default).
<code>compare_possibly</code> implements the "possible" comparison.
And <code>compare_full</code> allows the user to specify a behavior in
case of a non-boolean result (an exception for example).</p>

<pre>
namespace boost {
  namespace interval_lib {

template&lt;class T&gt; struct compare_certainly;
template&lt;class T&gt; struct compare_possibly;
template&lt;class T, class Function&gt; struct compare_full;

  } // namespace interval_lib
} // namespace boost
</pre>

<p>As you have probably guessed, the <code>Function</code> parameter
of <code>compare_full</code> is the type of a function-object called
in case of not-boolean result. So it must have an operator <code>bool
Function::operator()()</code>. Here is a little example of the
behavior of the comparison operators when <code>compare_full</code> is
the choosen policy:</p>

<ul>

<li>[1,2] &gt; [2,3] will return <code>false</code>;

<li>[1,2] &lt;= [2,3] will return <code>true</code>;

<li>[1,2] &lt; [2,3] will return the result of <code>Function()()</code>;

<li>and [1,2] &gt;= [2,3] will return <code>!Function()()</code>.

</ul>

<p>As a side note, if <code>Function</code> is the constant
function-object <code>false</code>, <code>compare_full&lt;T,
Function&gt;</code> is the same as <code>compare_certainly</code>.
Similarly, if <code>Function</code> is <code>true</code>,
<code>compare_full&lt;T, Function&gt;</code> is the same as
<code>compare_possibly</code>. However, <code>compare_full</code> is
twice as slower than <code>compare_certainly</code> and
<code>compare_possibly</code>; and the compiler can not do anything
about that.</p>

<h3>Explicit comparison functions</h3>

<p>The comparison operators are not really handy. For example, if
<code>lessthan</code> is a "certain" comparison, then
<code>&lt;</code> and <code>&gt;</code> are also "certain"
comparisons, but <code>&lt;=</code> and <code>&gt;=</code> are only
"possible" comparisons. The reason of this discordance is: it is
impossible to have <code>&lt;</code> and <code>&lt;=</code> both
"possible", and to have <code>(x&lt;=y) == !(y&lt;x)</code> at the
same time (and the "certain" comparison has the same
problem). However, if you do not consider overlapping intervals, these
two types of comparisons are equivalent.</p>

<p>To avoid these problems, it is probably better to use some explicit
comparison functions. Their names are composed by <code>cer</code>
(for "certain") or <code>pos</code> (for "possible") followed by
<code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>,
<code>eq</code> or <code>ne</code>. Each of these functions takes two
parameters and returns a boolean. For example:</p>

<pre>
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);
</pre>

<h2 id="rounding">Rounded Computations</h2>

<p>Here comes the tricky part. In order to be as general as possible,
the library uses a class to compute all the necessary functions
rounded upward or downward. This class is the second parameter of
<code>interval_traits</code>. By default, it is
<code>boost::interval_lib::rounded_math&lt;T&gt;</code>.</p>

<p>The class <code>boost::interval_lib::rounded_math</code> is
already specialized for <code>float</code> and <code>double</code>. So
if the base type of your intervals is not one of these two, a good
solution would probably be a specialization of this class. But if the
default specialization for <code>float</code> and <code>double</code>
is not what you seek, you will have to directly use
<code>interval_traits</code>.</p>

<h3>Synopsis</h3>

<p>Here comes what the class is supposed to provide:</p>

<pre>
struct rounding {
  T add_down(T, T);
  T add_up  (T, T);
  T sub_down(T, T);
  T sub_up  (T, T);
  T mul_down(T, T);
  T mul_up  (T, T);
  T div_down(T, T);
  T div_up  (T, T);
  T sqrt_down(T);
  T sqrt_up  (T);
  T exp_down(T);
  T exp_up  (T);
  T log_down(T);
  T log_up  (T);
  T cos_down(T);
  T cos_up  (T);
  T tan_down(T);
  T tan_up  (T);
  T asin_down(T);
  T asin_up  (T);
  T acos_down(T);
  T acos_up  (T);
  T atan_down(T);
  T atan_up  (T);
  T sinh_down(T);
  T sinh_up  (T);
  T cosh_down(T);
  T cosh_up  (T);
  T tanh_down(T);
  T tanh_up  (T);
  T asinh_down(T);
  T asinh_up  (T);
  T acosh_down(T);
  T acosh_up  (T);
  T atanh_down(T);
  T atanh_up  (T);
  T int_down(T);
  T int_up  (T);
  static T pi_down();
  static T pi_up  ();
  static T pi_1_2_down();
  static T pi_1_2_up  ();
  static T pi_2_1_down();
  static T pi_2_1_up  ();
  typedef ... tonearest_rounding;
  typedef ... unprotected_rounding;
};
</pre>

<p>These functions do not have to worry about invalid
arguments. Moreover, the argument of the <code>cos_</code> functions
is between 0 and 2&pi;; and the argument of the <code>tan_</code>
functions is between -&pi;/2 and &pi;/2.</p>

<p>The functions <code>int_down</code> and <code>int_up</code>
compute the nearest integer smaller or bigger than their
argument. The <code>pi_</code> functions are supposed to return bounds
of some constants. <code>pi</code> clearly stands for the mathematical
constant &pi;. <code>pi_1_2</code> stands for &pi;/2 and
<code>pi_2_1</code> stands for 2&pi;.</p>

<p>The type <code>unprotected_rounding</code> is another rounding
class able to work if nested inside <code>rounding</code>. Naturally
<code>rounding::unprotected_rounding</code> may simply be
<code>rounding</code> itself. But it can improve performance if it is
a simplified version without constructor and destructor. See the <a
href="#perf">performance notes</a> for an explication.</p>

<p>The type <code>tonearest_rounding</code> also provides another
rounding class. However, it does not have to be as complex as
<code>rounding</code>. No members are required. The only purpose of
this type is: the basic operators <code>+ - * /</code> will be rounded
toward the nearest integer while an object of type
<code>rounding::tonearest_rounding</code> is alive. This type must be
defined in order for the functions <code>dist</code>,
<code>median</code>, <code>bisect</code> and
<code>symmetric_scale</code> to compile.</p>

<h3>Provided classes</h3>

<p>A lot of classes are provided. When they exist in two versions
<code>_std</code> and <code>_opp</code>, the first one does switch the
rounding mode each time, and the second one tries to keep it oriented
toward plus infinity. The main purpose of the <code>_opp</code>
version is to speed up the computations through the use of the
"opposite trick" (see the <a href="#perf">performance notes</a>). This
version requires the rounding mode to be upward before entering any
computation functions of the class. It guarantees the rounding mode
will still be upward at the exit of the functions.</p>

<p>Please note that it is really a very bad idea to mix the
<code>_opp</code> version with the <code>_std</code> since they do not
have compatible properties.</p>

<p>There is a third version named <code>_exact</code> which computes
the functions without changing the rouding mode. It is an "exact"
version because it is intended for a base type that produces exact
results. The last version is the <code>_dummy</code> version. It does
not do any computations but still produces compatible results.</p>

<p>At the bottom is the class <code>rounding_control</code>. Then come
<code>rounded_arith_exact</code>, <code>rounded_arith_std</code> and
<code>rounded_arith_opp</code>. Then there are
<code>rounded_transc_dummy</code>, <code>rounded_transc_exact</code>,
<code>rounded_transc_std</code> and
<code>rounded_transc_opp</code>. And finally are
<code>save_state</code> and <code>save_state_nothing</code>. Each of
these classes provide a set of members that are required by the
classes of the next stage. For example, a
<code>rounded_transc_...</code> class needs the members of a
<code>rounded_arith_...</code> class.</p>

<p>Here comes what each class defines. Later, when they will be
described more thoroughly, the requirements will not be
repeated. Please come back here in order to see them. The inheritances
are also shown to avoid repeating the same things over and over.</p>

<pre>
namespace boost {
  namespace interval_lib {

template&lt;class T&gt;
struct rounding_control
{
  typedef ... rounding_mode;
  void set_rounding_mode(rounding_mode);
  rounding_mode get_rounding_mode();
  void downward ();
  void upward   ();
  void tonearest();
  T to_int(T);
  T force_rounding(T);
  T pi_down();
  T pi_up  ();
  T pi_1_2_down();
  T pi_1_2_up  ();
  T pi_2_1_down();
  T pi_2_1_up  ();
};

template&lt;class T, class Rounding = rounding_control&lt;T&gt; &gt; struct rounded_arith_exact;
template&lt;class T, class Rounding = rounding_control&lt;T&gt; &gt; struct rounded_arith_std;
template&lt;class T, class Rounding = rounding_control&lt;T&gt; &gt; struct rounded_arith_opp;

template&lt;class T, class Rounding&gt;
struct rounded_arith_...: Rounding
{
  void init();
  T add_down(T, T);
  T add_up  (T, T);
  T sub_down(T, T);
  T sub_up  (T, T);
  T mul_down(T, T);
  T mul_up  (T, T);
  T div_down(T, T);
  T div_up  (T, T);
  T sqrt_down(T);
  T sqrt_up  (T);
  T int_down(T);
  T int_up  (T);
};

template&lt;class T, class Rounding&gt; struct rounded_transc_dummy;
template&lt;class T, class Rounding = rounded_arith_exact&lt;T&gt; &gt; struct rounded_transc_exact;
template&lt;class T, class Rounding = rounded_arith_std&lt;T&gt; &gt; struct rounded_transc_std;
template&lt;class T, class Rounding = rounded_arith_opp&lt;T&gt; &gt; struct rounded_transc_opp;

template&lt;class T, class Rounding&gt;
struct rounded_transc_...: Rounding
{
  T exp_down(T);
  T exp_up  (T);
  T log_down(T);
  T log_up  (T);
  T cos_down(T);
  T cos_up  (T);
  T tan_down(T);
  T tan_up  (T);
  T asin_down(T);
  T asin_up  (T);
  T acos_down(T);
  T acos_up  (T);
  T atan_down(T);
  T atan_up  (T);
  T sinh_down(T);
  T sinh_up  (T);
  T cosh_down(T);
  T cosh_up  (T);
  T tanh_down(T);
  T tanh_up  (T);
  T asinh_down(T);
  T asinh_up  (T);
  T acosh_down(T);
  T acosh_up  (T);
  T atanh_down(T);
  T atanh_up  (T);
};

template&lt;class Rounding&gt; struct save_state;
template&lt;class Rounding&gt; struct save_state_nothing;

template&lt;class Rounding&gt;
struct save_state_...: Rounding
{
  typedef ... unprotected_rounding;
  typedef ... tonearest_rounding;
};

  } // namespace interval_lib
} // namespace boost
</pre>

<p>The default policy (aka <code>rounded_math&lt;T&gt;) is:</p>

<pre>
save_state_nothing&lt;rounded_transc_dummy&lt;T, rounded_arith_exact&lt;T&gt; &gt; &gt;
</pre>

<p>and the specializations for <code>float</code> and
<code>double</code> are:</p>

<pre>
save_state&lt;rounded_transc_dummy&lt;T, rounded_arith_opp&lt;T&gt; &gt; &gt;
</pre>

<h4>State saving</h4>

<p>First comes <code>save_state</code>. This class is responsible for
saving the current rounding mode and calling <code>init</code> in its
constructor, and for restoring the saved rounding mode in its
destructor. This class also correctly defines the
<code>tonearest</code> and <code>unprotected</code> variations.</p>

<p>If the rounding mode does not require any save nor initialization,
<code>save_state_nothing</code> can be used instead of
<code>save_state</code>.</p>

<h4>Transcendental functions</h4>

<p>The <code>rounded_transc_exact</code>,
<code>rounded_transc_std</code> and <code>rounded_transc_opp</code>
classes expect the <code>std</code> namespace to provide the functions
<code>exp log cos tan acos asin atan cosh sinh tanh acosh asinh
atanh</code>. For the <code>_std</code> and <code>_opp</code>
versions, all these functions should respect the current rounding mode
fixed by a call to <code>downward</code> or <code>upward</code>.</p>

<p>Unfortunately, it rarely is the case. It is the reason why the
<code>rounded_transc_dummy</code> class is provided. This class does
not depend on the functions from the <code>std</code> namespace. It is
the reason why <code>rounded_transc_dummy</code> is the default class
rather than <code>rounded_transc_opp</code>.</p>

<p>However, there is no magic. The functions of
<code>rounded_transc_dummy</code> do not compute anything. They only
return valid values. For example, <code>cos_down</code> always returns
-1.</p>

<h4>Basic functions</h4>

<p>The <code>rounded_arith_std</code> and
<code>rounded_arith_opp</code> classes expect the operators <code>+ -
* /</code> and the function <code>std::sqrt</code> to respect the
current rounding mode.</p>

<p><code>rounded_arith_opp</code> also requires <code>std::sqrt</code>
to produce a square root rounded upward no more than 1 ulp away from
the exact value (in order for <code>sqrt_down</code> to use
<code>std::sqrt</code> without switching the rounding mode).</p>

<p><code>rounded_arith_exact</code> requires <code>std::floor</code>
and <code>std::ceil</code> to be defined since it can not rest on
<code>to_int</code>.</p>

<h4>Rounding control</h4>

<p>The functions defined by each of the previous classes did not need
any explanation. For example, the behavior of <code>add_down</code> is
to compute the sum of two numbers rounded downward. For
<code>rounding_control</code>, it is a bit more complex.</p>

<p><code>get_rounding_mode</code> returns the current rounding
mode. <code>set_rounding_mode</code> sets the rounding mode back to a
previous value returned by
<code>get_rounding_mode</code>. <code>downward</code>,
<code>upward</code> and <code>tonearest</code> sets the rounding mode
in one of the three directions. This rounding mode should be global to
all the functions that use the type <code>T</code>. For example, after
a call to <code>downward</code>, <code>force_rounding(x+y)</code> is
expected to return the sum rounded downward.</p>

<p><code>to_int</code> computes the nearest integer accordingly to the
current rounding mode. <code>force_rounding</code> returns its
argument correctly rounded according to the current rounding mode if
it was not already the case. This function is necessary to compensate
for the extended precision of some floating-point units.</p>

<p>The non-specialized version of <code>rounding_control</code> does
not do anything. The functions for the rounding mode are
empty. <code>to_int</code> and <code>force_rounding</code> are
identity functions. The <code>pi_</code> constant functions return
some integers (for example, <code>pi_up</code> returns
<code>T(4)</code>).</p>

<p><code>rounding_control</code> is specialized for <code>float</code>
and <code>double</code> in order to use the floating point unit of the
computer.</p>

<h3>Some Examples</h3>

<p>Here come several cases:</p>

<ul>

<li>if you need precise computations with the <code>float</code> or
<code>double</code> types, use the default
<code>rounded_math&lt;T&gt;</code>;

<li>for fast wide intervals without any rounding nor precision, use
<code>save_state_nothing&lt;rounded_transc_exact&lt;T&gt; &gt;</code>;

<li>for an exact type (like <code>int</code> or <code>rational</code>
with a little help for infinite and NaN values) without support for
transcendental functions, the solution could be
<code>save_state_nothing&lt;rounded_transc_dummy&lt;T,
rounded_arith_exact&lt;T&gt; &gt; &gt;</code>;

<li>if it is a more complex case than the previous ones, the best
thing is probably to directly define your own policy.</p>

</ul>

<h2 id="checking">Checking</h2>

<p>The last customizable part of <code>interval_traits</code> deals
with exception handling. For example, when two intervals are divided,
if the second contains zero, the result of the division is
undefined. In this case, the answer will be the biggest interval in
order to respect the basic property of the interval
arithmetic. However, this behavior is not necessarily the one the user
expects. And here does this third parameter of
<code>interval_traits</code> play a part.</p>

<p>An important fact to understand is: the behavior defined by this
parameter is only invoked if the input intervals of a function are not
fully included in the domain of the function. If the input intervals
are inside this domain but the result are exceptionnal (for example in
case of an overflow during the computations), the members of this
checking class will not be called.</p>

<p>There is another important matter. The checking policy does not
allow to say what the results should be in case of problem. It is only
allowed to point out the problem (through an exception for example).</p>

<h3>Synopsis</h3>

<p>The checking class should be of the following type:</p>

<pre>
struct checking
{
  static void inverted_bound(const T&amp; l, const T&amp; u);
  static void divide_by_zero(const T&amp; l, const T&amp; u);
  static void sqrt_nan();
  static void logarithmic_nan();
  static void logarithmic_inf();
  static void trigonometric_nan();
  static void trigonometric_inf();
  static void hyperbolic_nan();
  static void hyperbolic_inf();
};
</pre>

<p>The first function, <code>inverted_bound</code>, deals with the
call to a constructor like <code>interval::interval(T l, T u)</code>
or a function like <code>void interval::assign(T l, T u)</code> when
<code>l</code> is not less or equal to <code>u</code>. It is
generally a good idea to throw an exception if the function
<code>inverted_bound</code> is called. The parameters of the function
are the faulty bounds of the interval. If the function returns to the
caller, the final result will be the empty interval.</p>

<p><code>divide_by_zero</code> is called each time the second interval
of a division contains zero. If the function returns to the caller,
the final result will be the entire interval. The faulty interval is
given as an argument in order for the user to differentiate between a
loss of precision and a bug in the program.</p>

<p>Indeed if the interval is [0,0], there clearly is a problem
somewhere. It is generally not an error when a floating-point number
is divided by zero, because it can be caused by a loss of precision or
an underflow. For example, the computer will compute the same thing
when asked 1/(1 + 1E-100 - 1) and when asked 1/0. However, that is not
true anymore for the interval arithmetic when used to obtain "exact"
results. Because the interval [0,0] means that the result is exactly
zero (in the previous example, the two computations would be
1/[0,1E-9] and 1/[0,0]).</p>

<p>This is also the reason why the functions <code>sqrt_nan</code>,
<code>logarithmic_nan</code>, <code>trigonometric_nan</code> and
<code>hyperbolic_nan</code> are defined, since a function should not
be called with an input completely outside of its definition
domain. Like it was for <code>inverted_bound</code> and
<code>divide_by_zero(0,0)</code>, it usually is a good idea to throw
an exception because the program is defective.</p>

<p>The purpose of the functions <code>logarithmic_inf</code>,
<code>trigonometric_inf</code>, <code>hyperbolic_inf</code> is
different. These functions are called when the input intervals are
partially outside the definition and that will lead to an infinite
result. For example, <code>log</code>([-1,1]) will trigger
<code>logarithmic_inf</code> but <code>exp</code>([0,1e1000]) will not
trigger anything (although the upper bound will be infinite).</p>

<p><code>sqrt_nan</code> is called by <code>sqrt</code>.
<code>logarithmic_inf</code> and <code>logarithmic_nan</code> are
called by <code>log</code>.  <code>trigonometric_nan</code> is called
by <code>asin</code> and <code>acos</code>.
<code>trigonometric_inf</code> is called by <code>tan</code>.
<code>hyperbolic_nan</code> is called by <code>acosh</code> and
<code>atanh</code>. <code>hyperbolic_inf</code> is called by
<code>atanh</code>.</p>

<p>As a side note, because the constant &pi; usually suffers from a
lack of precision, <code>tan</code> is unfortunately unable to trigger
<code>trigonometric_nan</code> on an input like [&pi;/2, &pi;/2].</p>

<h3>Provided classes</h3>

<p>Some checking policies are already defined.
<code>checking_nothing</code> will not do anything; each function is
empty. <code>checking_lax</code> will only throw an exception when
<code>inverted_bound</code> is called. <code>checking_strict</code>
will throw exceptions when <code>inverted_bound</code>,
<code>divide_by_zero(0,0)</code> and each <code>_nan</code> functions
are called. This last policy is the policy by default.</p>

<pre>
namespace boost {
  namespace interval_lib {

template&lt;class T&gt; struct checking_nothing;
template&lt;class T&gt; struct checking_lax;
template&lt;class T&gt; struct checking_strict;

  } // namespace interval_lib
} // namespace boost
</pre>

<p>The thrown exceptions are <code>std::invalid_argument</code> with
an error message looking like <code>"boost::interval: <i>something
appropriate</i>"</code>.</p>

<h2 id="perf">Performance Notes</h2>

<p>This paragraph deals mostly with the performance of the library
with intervals using the floating-point unit (FPU) of the
computer. Let's consider the sum of [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] as an example. The result is
[<code>down</code>(<i>a</i>+<i>c</i>),
<code>up</code>(<i>b</i>+<i>d</i>)]. <code>down</code> and
<code>up</code> indicate the rounding mode needed.</p>

<h3>Rounding Mode Switch</h3>

<p>If the FPU is able to use a different rounding mode for each
operation, there is no problem. For example, it's the case for the
Alpha processor: each floating-point instruction can specify a
different rounding mode. However, the standard IEEE-754 does not
require such a behavior. So most of the FPUs only provide some
instructions to set the rounding mode for all subsequent
operations. And generally, these instructions need to flush the
pipeline of the FPU.</p>

<p>In this situation, the time needed to sum [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] is far worse than the time needed to calculate
<i>a</i>+<i>b</i> and <i>c</i>+<i>d</i> since the two additions cannot
be parallelized. Consequently, the objective is to diminish the number
of rounding mode switch.</p>

<p>If this library is not used to provide exact computations, but only
for pair arithmetic, the solution is quite simple: do not use
rounding. In that case, doing the sum [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] will be as fast as computing <i>a</i>+<i>b</i> and
<i>c</i>+<i>d</i>. Everything is perfect.</p>

<p>However, if exact computations are required, such a solution is
totally unthinkable. So, are we penniless? No, there is still a trick
available. Indeed, <code>down</code>(<i>a</i>+<i>c</i>) =
-<code>up</code>(-<i>a</i>-<i>c</i>) if the unary minus is an exact
operation. It is now possible to calculate the whole sum with the same
rounding mode. Generally, the cost of the mode switching is worse than
the cost of the sign changes.</p>

<p>Let's recapitulate. Before, when doing an addition, there were
three rounding mode switches (<code>down</code>, <code>up</up> and
restore). Now, with this little trick, there are only two switches
(<code>up</up> and restore). It is better, but still a bottleneck when
many operations are nested. Indeed, the generated code for
[<i>a</i>,<i>b</i>] + [<i>c</i>,<i>d</i>] + [<i>e</i>,<i>f</i>] will
probably look like:</p>

<blockquote>
<pre>
up();
t1 = -(-a - c);
t2 = b + d;
restore();
up();
x = -(-t1 - e);
y = t2 + f;
restore();
</pre>
</blockquote>

<p>If you think it is possible to do much better, you are right. For
example, this is better (and probably optimal):</p>

<blockquote>
<pre>
up();
x = -(-a - c - e);
y = b + d + f;
restore();
</pre>
</blockquote>

<p>Such a code will be generated by a compiler if the computations are
made without initialization and restoration of the rounding
mode. However, it would be far too easy if there was no drawback:
because the rounding mode is not restored in the meantime, operations
on floating-point numbers must be prohibited. This method can only be
used if all the operations are operations on interval. Here is an
example of the Horner scheme to compute the value of a polynom.</p>

<pre>
// I is an interval class, the polynom is a simple array
template&lt;class I&gt;
I horner(const I&amp; x, const I p[], int n) {

  // save and initialize the rounding mode
  typename I::traits_type::rounding rnd;

  // define the unprotected version of the interval type
  typedef typename boost::interval_lib::unprotect&lt;I&gt;::type R;
  
  R a = x;
  R y = p[n - 1];
  for(int i = n - 2; i >= 0; i--) {
    y = y * a + (R)(p[i]);
  }
  return y;

  // restore the rounding mode with the destruction of rnd
}
</pre>

<p>It was said at the beginning that the Alpha processors can use a
specific rounding mode for each operation. However, due to the
instruction format, the rounding toward plus infinity is not
available. Only the rounding toward minus infinity can be used. So the
trick using the change of sign becomes essential, but there is no need
to save and restore the rounding mode on both sides of an
operation.</p>

<h3>Extended Registers</h3>

<p>There is another problem besides the cost of the rounding mode
switch. Some FPUs use extended registers (for example,
<code>float</code> computations will be done with <code>double</code>
registers, or <code>double</code> computations with <code>long
double</code> registers). Consequently, many problems can arise.</p>

<p>The first one is due to to the extended precision of the
mantissa. The rounding is also done on this extended precision. And
consequently, we still have <code>down</code>(<i>a</i>+<i>b</i>) =
-<code>up</code>(-<i>a</i>-<i>b</i>) in the extended registers. But
back to the standard precision, we now have
<code>down</code>(<i>a</i>+<i>b</i>) &lt;
-<code>up</code>(-<i>a</i>-<i>b</i>) instead of an equality. A
solution could be not to use this method. But there still are other
problems, with the comparisons between numbers for example.</p>

<p>Naturally, there is also a problem with the extended precision of
the exponent. To illustrate this problem, let <i>m</i> be the biggest
number before +<i>inf</i>. If we calculate 2*[<i>m</i>,<i>m</i>], the
answer should be [<i>m</i>,<i>inf</i>]. But due to the extended
registers, the FPU will first store [<i>2m</i>,<i>2m</i>] and then
convert it to [<i>inf</i>,<i>inf</i>] at the end of the calculus (when
the rounding mode is toward +<i>inf</i>). So the answer is no more
accurate.</p>

<p>There is only one solution: to force the FPU to convert the
extended values back to standard precision after each operation. Some
FPUs provide an instruction able to do this conversion (for example
the PowerPC processors). But for the FPUs that do not provide it (the
x86 processors), the only solution is to write the values to memory
and read them back. Such an operation is obviously very expensive.</p>

<h2>Rationale</h2>

<p>The purpose of this library is to provide an efficient and
generalized way to deal with interval arithmetic through the use of a
templatized class <code>boost::interval</code>. The behavior of this
class can be fixed by three policies. The first one specifies the way
comparison operators are defined. The second one provides all the
mathematical functions on the base type needed to define the functions
on the interval type. The last one sets the way exceptional cases
encoutered during computations are handled.</p>

<p>The library provides specialized implementations of the second
policy for the primitive types <code>float</code> and
<code>double</code>. In order for these implementations to be correct
and fast, the library need to work a lot with rounding modes. Some
processors are directly dealt with and some mecanisms are provided in
order to speed up the computations. It seems to be heavy and hazardous
optimizations for a gain of only a few computer cycles; but in
reality, the speed-up factor can easily go past 2 or 3 depending on
the computer. Moreover, these optimizations do not impact the
interface in some ugly way.</p>

<h2>Test Programs</h2>

<p><code>pi.cpp</code> tests if the interval value of &pi; (for
<code>int</code>, <code>float</code> and <code>double</code> base
types) contains the number &pi; (defined with 21 decimal digits) and
if it is a subset of [&pi;&plusmn;1ulp] (in order to ensure some
precision).</p>

<p><code>cmp.cpp</code> tests if the operators <code>&lt; &gt; &lt;=
&gt;= == !=</code> (for the three pre-defined comparisons) and the
functions <code>cer...</code> and <code>pos...</code> behave correctly
with some simple intervals ([1,2] and [3,4], [1,3] and [2,4], [1,2]
and [2,3], etc).</p>

<p><code>det.cpp</code> tests if the <code>_std</code> and
<code>_opp</code> versions in protected and unprotected mode produce
the same result when Gauss scheme is used on an unstable matrix (in
order to exercise rounding). The tests are done for
<code>interval&lt;float&gt;</code> and
<code>interval&lt;double&gt;</code>.

<p><code>fmod.cpp</code> defines a minimalistic version of
<code>interval&lt;int&gt;</code> and uses it in order to test
<code>fmod</code> on some interval values.</p>

<p><code>interval_test.cpp</code> tests if the interval library
respects the basic property of interval arithmetic by computing some
functions and operations for both <code>double</code> and
<code>interval&lt;double&gt;</code>.</p>

<h2>History and Acknowledgements</h2>

<p>This library was mostly inspired by a previous work from Jens
Maurer. Some discussions about his work were reproduced <a
href="http://www.mscs.mu.edu/~georgec/IFAQ/maurer1.html">here</a> and
the work itself can be found <a
href="http://www.rhein-main.de/people/jmaurer/interval.tar.gz">here</a>.</p>

<p>Herv&eacute; Br&ouml;nnimann and Sylvain Pion have provided some
useful comments in order for this library to be written.</p>

<hr>
Guillaume Melquiond, 2002-08-02

</body>
</html>
