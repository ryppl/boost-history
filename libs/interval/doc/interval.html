<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<title>Boost Interval Arithmetic Library</title>
</head>

<body>

<h1>
<img src="../../c++boost.gif" alt="c++boost.gif (8819 bytes)"
align="center" WIDTH="277" HEIGHT="86">
Header &lt;<a href="../../boost/interval.hpp">boost/interval.hpp</a>&gt;</h1>

<h2>Introduction</h2>

<h3>Interval Arithmetic</h3>

<p>As implied by its name, this library is intended to help
manipulating mathematical intervals. An interval is a pair of numbers
which represents all the numbers between these two. The purpose of
this library is to extend the usual arithmetic functions to
intervals. These intervals will be written [<i>a</i>,<i>b</i>] to
represent all the numbers between <i>a</i> and <i>b</i>. <i>a</i> and
<i>b</i> can be infinite (but they can not be the same infinite) and
<i>a</i> &lt;= <i>b</i>.</p>

<p>The fondamental property of interval arithmetic is: if <i>f</i> is
a function on a set of numbers, <i>f</i> can be extended to a new
function defined on intervals. This new function <i>f</i> takes one
interval argument and returns an interval result such as: <b>for
each</b> <i>x</i> <b>in</b> [<i>a</i>,<i>b</i>], <i>f</i>(<i>x</i>) is
<b>in</b> <i>f</i>([<i>a</i>,<i>b</i>]). Such a property is not
limited to functions with only one argument. Whenever possible, the
interval result should be the smallest one able to satisfy the
property (it is not really useful if the new functions always answer
[-<i>inf</i>,+<i>inf</i>]).</p>

<p>There are two reasons a user would like to use this library. The
obvious one is when the user has to compute intervals. The other one
appears when the computer doesn't produce exact results anymore. By
using intervals, it is possible to quantify the propagation of
rounding errors.</p>

<p>For example, let's suppose the computer stores numbers with ten
decimal significant digits. To the question 1 + 1E-100 - 1, the
computer will answer 0 although the correct answer would be
1E-100. With the help of interval arithmetic, the computer will answer
[0,1E-9]. This is quite a huge interval for such a little result, but
the precision is now known, without having to compute the error
propagation.</p>

<h3>Numbers</h3>

<p>In order to successfully use the interval arithmetic, the bounds of
the interval must present some characteristics. First of all, due to
the definition of an interval, the numbers have to be strongly
ordered. Secondly, the arithmetic must be exact or provide some
rounding methods (toward minus or plus infinity) in order to always
ensure large enough intervals. Finally, because heavy loss of
precision are always possible, some numbers have to represent
infinities or an exceptional behavior must be defined. The same
situation occurs also for NaN (<i>Not a Number</i>).</p>

<p>Knowing all of this, a good candidate can be the set of the
floating point numbers defined by the standard IEEE-754. Indeed, if
the interval arithmetic is intended to replace some arithmetic using
the floating point unit of a processor, they are the best
choice.</p>

<h3>Comparisons</h3>

<p>It is straightforward to define the elementary arithmetic
operations on intervals. It is also possible to define some comparison
operators. Given two intervals, the returned value is a subset of
{<i>false</i>,<i>true</i>}. The answers {<i>false</i>} and
{<i>true</i>} are easy to manipulate. But it is not the case for the
answer {<i>false</i>,<i>true</i>} since comparison operators are
supposed to be boolean functions.</p>

<p>So, what to do in order to obtain boolean answers? Nobody will be
shocked if {<i>false</i>} is transformed in <i>false</i> and
{<i>true</i>} in <i>true</i>. And {<i>false</i>,<i>true</i>}? First
solution, an exceptional behavior can be adopted. It will happen when
the two compared intervals overlap on more than a single point. Second
solution, {<i>false</i>,<i>true</i>} can be transformed in
<i>false</i> or <i>true</i>.</p>

<p>If <i>false</i> is chosen, the comparison will be called
"certain". Indeed, the result of [<i>a</i>,<i>b</i>] &lt;
[<i>c</i>,<i>d</i>] will be <i>true</i> if and only if <b>for each</b>
<i>x</i> <b>in</b> [<i>a</i>,<i>b</i>] and <i>y</i> <b>in</b>
[<i>c</i>,<i>d</i>], <i>x</i> &lt; <i>y</i>.</p>

<p>If <i>true</i> is chosen, the comparison will be called
"possible". Indeed, the result of [<i>a</i>,<i>b</i>] &lt;
[<i>c</i>,<i>d</i>] will be <i>true</i> if and only if it
<b>exists</b> <i>x</i> <b>in</b> [<i>a</i>,<i>b</i>] and <i>y</i>
<b>in</b> [<i>c</i>,<i>d</i>] such as <i>x</i> &lt; <i>y</i>.</p>

<h2><code>interval</code> Class</h2>

<p>This class is templated by a base type and a traits type. Here is
the synopsis of the class :</p>

<pre>
namespace boost {

template&lt;class T, class Traits = interval_traits&lt;T&gt; &gt;
class interval
{
public:
  typedef T base_type;
  typedef std::numeric_limits&lt;base_type&gt; base_limits;
  typedef Traits traits_type;

  interval(const T&amp; value = 0);
  interval(const T&amp; l, const T&amp; u);

  template&lt;class Traits2&gt;
  interval(const interval&lt;T, Traits2&gt;&amp; r);

  // compiler-generated copy constructor and assignment operator are fine
  interval&amp; operator=(const T&amp; x);
  void assign(const T&amp; l, const T&amp; u);

  // constructor-like functions
  static interval empty();
  static interval entire();

  interval&amp; operator+= (const T&amp; r);
  interval&amp; operator+= (const interval&amp; r);
  interval&amp; operator-= (const T&amp; r);
  interval&amp; operator-= (const interval&amp; r);
  interval&amp; operator*= (const T&amp; r);
  interval&amp; operator*= (const interval&amp; r);
  interval&amp; operator/= (const T&amp; r);
  interval&amp; operator/= (const interval&amp; r);

  T lower() const;
  T upper() const;
};

} // namespace boost
</pre>

<p>The <code>interval</code> class requires two template parameters,
the first one is the type of the bounds. And the second one is a class
defining three policies. This second parameter should look like:</p>

<pre>
struct traits {
  typedef ... compare;
  typedef ... rounding;
  typedef ... checking;
};
</pre>

<p>The requirements of these three types are detailled below in their
respective sections: <a href="#compare">compare</a>, <a
href="#rounding">rounding</a>, <a href="#checking">checking</a>. In
order to allow an easier definition of this parameter, the
<code>interval_traits</code> class is provided:</p>

<pre>
namespace boost {

template&lt;class T,
	 class Compare = interval_lib::compare_certainly&lt;T&gt;,
	 class Rounding = interval_lib::rounded_arithmetic&lt;T&gt;,
	 class Checking = interval_lib::checking_strict&lt;T&gt; &gt;
struct interval_traits
{
  typedef T base_type;
  typedef Compare compare;
  typedef Rounding rounding;
  typedef Checking checking;
};

} // namespace boost
</pre>

<p>There is also a bunch of operators and functions defined outside
the <code>interval</code> class in the <code>boost</code>
namespace:</p>

<pre>
namespace boost {

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const T&amp; r, const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerle(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerle(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerle(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cergt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cergt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cergt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerge(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerge(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerge(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cereq(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cereq(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cereq(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerne(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerne(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerne(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool poslt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool poslt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool poslt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posle(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posle(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posle(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posgt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posgt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posgt(const T&amp; x, const interval&lt;T, Traits&gt; &amp; y);

template&lt;class T, class Traits&gt;
bool posge(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posge(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posge(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool poseq(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool poseq(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool poseq(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posne(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posne(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posne(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&lt;(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&lt;=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&gt;(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&gt;=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator==(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator==(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator==(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator!=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator!=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator!=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt; T lower(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T upper(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T width(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T median(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; pred(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; succ(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
bool empty(const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool in(const T&amp; r, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool in_zero(const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool subset(const interval&lt;T, Traits&gt;&amp; a, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool proper_subset(const interval&lt;T, Traits&gt;&amp; a, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool overlap(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; intersect(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T&gt;
interval&lt;T&gt; hull(const T&amp; x, const T&amp; y);

template&lt;class T, class Traits&gt;
std::pair&lt;interval&lt;T, Traits&gt;, interval&lt;T, Traits&gt; &gt;
bisect(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
bool singleton(const interval&lt;T, Traits&gt;&amp; x)
template&lt;class T, class Traits&gt;
bool equal(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y)

template&lt;class T, class Traits&gt;
T dist(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
T dist(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
T dist(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; scale(const interval&lt;T, Traits&gt;&amp; x, const T&amp; mirror, const T&amp; factor);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; symmetric_scale(const interval&lt;T, Traits&gt;&amp; x, const T&amp; factor);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; square(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; fmod(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; fmod(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; abs(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sqrt(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; exp(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; log(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sin(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; cos(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; tan(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; asin(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; acos(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; atan(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sinh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; cosh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; tanh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; asinh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; acosh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; atanh(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

} // namespace boost
</pre>

<p>Finally, there is also a specialization of
<code>std::numeric_limits</code> for the <code>interval</code>
class.</p>

<h2>Operations and Functions</h2>

<p>The basic operations are the unary minus and the binary <code>+ - *
/</code>. The unary operations take an interval and returns an
interval. The binary operations take two intervals, or one interval
and a number, and return an interval.</p>

<p>There are also some assignment operators <code>+= -= *=
/=</code>. There is not much to say.</p>

<p><code>lower</code>, <code>upper</code>, <code>median</code>
respectively compute the lower bound, the upper bound, and the median
number of an interval. <code>width</code> computes the width of an
interval (rounded toward plus infinity). <code>pred</code> and
<code>succ</code> respectively compute an interval strictly smaller
(if possible) and an interval strictly wider (also if possible).</p>

<p>The functions <code>min</code>, <code>max</code>, <code>abs</code>
are also defined. Please do not mistake them for the functions defined
in the standard library (aka <code>a&lt;b?a:b</code>,
<code>a&gt;b?a:b</code>, <code>a&lt;0?-a:a</code>). These functions
are compatible with the elementary property of interval
arithmetic. For example, <code>max</code>([<i>a</i>,<i>b</i>],
[<i>c</i>,<i>d</i>]) = {<code>max</code>(<i>x</i>,<i>y</i>) | <i>x</i>
in [<i>a</i>,<i>b</i>] and <i>y</i> in [<i>c</i>,<i>d</i>]}. They are
not defined in the <code>std</code> namespace but in the
<code>boost</code> namespace to avoid conflict with the other
definitions.</p>

<p>There are also some set functions. <code>intersect</code> does what
you think it does. <code>overlap</code> tests if two intervals have
some common subset. <code>hull</code> computes the smallest interval
which contains the two parameters; those parameters can be numbers or
interval. <code>in</code> tests if a number is in an interval;
<code>in_zero</code> is a variant which tests if zero is in an
interval. <code>subset</code> tests if the first interval is a subset
of the second; and <code>proper_subset</code> tests if it is a proper
subset. <code>empty</code> and <code>singleton</code> test if an
interval is empty or is a singleton. Finally, <code>equal</equal>
tests if two intervals are equal.</p>

<p>The functions <code>square sqrt log exp sin cos tan asin acos atan
sinh cosh tanh asinh acosh atanh</code> are also defined.

<h2 id="compare">Comparisons</h2>

<h3>Synopsis</h3>

<p>As it was said before, the definition of the comparison operators
induces a slight problem. If their return type is restricted to
<code>bool</code>, there are many ways to define them. It is the
reason why the class <code>interval</code> is influenced by a
comparison policy. So the class <code>interval_traits</code> requires
an argument describing a class providing the following functions:</p>

<pre>
struct interval_compare {
  static bool lessthan(T x_low, T x_up, T y_low, T y_up);
  static bool equalto(T x_low, T x_up, T y_low, T y_up);
};
</pre>

<p>The functions <code>lessthan</code> and <code>equalto</code>
compare two intervals given their bounds. Thanks to this comparison
class, the class <code>interval</code> can now define the following
operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
<code>&gt;=</code>, <code>==</code>, <code>!=</code>. All these
operators are defined for two interval parameters, or for one interval
and a number.</p>

<h3>Provided classes</h3>

<p>Three classes are pre-defined for the comparison
policy. <code>compare_certainly</code> implements the "certain"
comparison (it is the comparison policy by default).
<code>compare_possibly</code> implements the "possible" comparison.
And <code>compare_full</code> allows the user to specify a behavior in
case of a non-boolean result (an exception for example).</p>

<pre>
namespace boost {
  namespace interval_lib {

template&lt;class T&gt; struct compare_certainly;
template&lt;class T&gt; struct compare_possibly;
template&lt;class T, class Function&gt; struct compare_full;

  } // namespace interval_lib
} // namespace boost
</pre>

<p>As you have probably guessed, the <code>Function</code> parameter
of <code>compare_full</code> is the type of a function-object called
in case of not-boolean result. So it must have an operator <code>bool
Function::operator()()</code>. Here is a little example of the
behavior of the comparison operators when <code>compare_full</code> is
the choosen policy:</p>

<ul>

<li>[1,2] &gt; [2,3] will return <code>false</code>;

<li>[1,2] &lt;= [2,3] will return <code>true</code>;

<li>[1,2] &lt; [2,3] will return the result of <code>Function()()</code>;

<li>and [1,2] &gt;= [2,3] will return <code>!Function()()</code>.

</ul>

<p>As a side note, if <code>Function</code> is the constant
function-object <code>false</code>, <code>compare_full&lt;T,
Function&gt;</code> is the same as <code>compare_certainly</code>.
Similarly, if <code>Function</code> is <code>true</code>,
<code>compare_full&lt;T, Function&gt;</code> is the same as
<code>compare_possibly</code>. However, <code>compare_full</code> is
twice as slower than <code>compare_certainly</code> and
<code>compare_possibly</code>; and the compiler can not do anything
about that.</p>

<h3>Explicit comparison functions</h3>

<p>The comparison operators are not really handy. For example, if
<code>lessthan</code> is a "certain" comparison, then
<code>&lt;</code> and <code>&gt;</code> are also "certain"
comparisons, but <code>&lt;=</code> and <code>&gt;=</code> are only
"possible" comparisons. The reason of this discordance is: it is
impossible to have <code>&lt;</code> and <code>&lt;=</code> both
"possible", and to have <code>(x&lt;=y) == !(y&lt;x)</code> at the
same time (and the "certain" comparison has the same
problem). However, if you do not consider overlapping intervals, these
two types of comparisons are equivalent.</p>

<p>To avoid these problems, it is probably better to use some explicit
comparison functions. Their names are composed by <code>cer</code>
(for "certain") or <code>pos</code> (for "possible") followed by
<code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>,
<code>eq</code> or <code>ne</code>. Each of these functions takes two
parameters and returns a boolean. For example:</p>

<pre>
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);
</pre>

<h2 id="rounding">Rounded Arithmetic</h2>

<p>Here comes the tricky part. In order to be as general as possible,
the library uses a class to compute all the necessary functions
rounded upward or downward. This class is the second parameter of
<code>interval_traits</code>. By default, it is
<code>boost::interval_lib::rounded_arithmetic&lt;T&gt;</code>.</p>

<p>The class <code>boost::interval_lib::rounded_arithmetic</code> is
already specialized for <code>float</code> and <code>double</code>. So
if the base type of your intervals is not one of these two, a good
solution would probably be a specialization of this class. But if the
default specialization for <code>float</code> and <code>double</code>
is not what you seek, you will have to directly use
<code>interval_traits</code>.</p>

<h3>Synopsis</h3>

<p>Here comes what the class is supposed to provide:</p>

<pre>
struct rounding {
  T add_down(T, T);
  T add_up  (T, T);
  T sub_down(T, T);
  T sub_up  (T, T);
  T mul_down(T, T);
  T mul_up  (T, T);
  T div_down(T, T);
  T div_up  (T, T);
  T sqrt_down(T);
  T sqrt_up  (T);
  T exp_down(T);
  T exp_up  (T);
  T log_down(T);
  T log_up  (T);
  T cos_down(T);
  T cos_up  (T);
  T tan_down(T);
  T tan_up  (T);
  T asin_down(T);
  T asin_up  (T);
  T acos_down(T);
  T acos_up  (T);
  T atan_down(T);
  T atan_up  (T);
  T sinh_down(T);
  T sinh_up  (T);
  T cosh_down(T);
  T cosh_up  (T);
  T tanh_down(T);
  T tanh_up  (T);
  T asinh_down(T);
  T asinh_up  (T);
  T acosh_down(T);
  T acosh_up  (T);
  T atanh_down(T);
  T atanh_up  (T);
  T int_down(T);
  T int_up  (T);
  T pi_down();
  T pi_up  ();
  T pi_1_2_down();
  T pi_1_2_up  ();
  T pi_2_1_down();
  T pi_2_1_up  ();
  typedef ... tonearest_rounding;
  typedef ... unprotected_rounding;
};
</pre>

<p>These functions do not have to worry about invalid
arguments. Moreover, the argument of the <code>cos_</code> function
is between 0 and 2&pi;; and the argument of the <code>tan_</code>
function is between -&pi;/2 and &pi;/2.</p>

<p>The functions <code>int_down</code> and <code>int_up</code>
compute the nearest integer smaller or bigger than their
argument. The <code>pi_</code> functions are supposed to return bounds
of some constants. <code>pi</code> clearly stands for the mathematical
constant &pi;. <code>pi_1_2</code> stands for &pi;/2 and
<code>pi_2_1</code> stands for 2&pi;.</p>

<p>The type <code>unprotected_rounding</code> is another rounding
class able to work if nested inside <code>rounding</code>. Naturally
<code>rounding::unprotected_rounding</code> may simply be
<code>rounding</code> itself. But it can improve performance if it is
a simplified version without constructor and destructor. See the <a
href="#perf">performance notes</a> for an example.</p>

<p>The type <code>tonearest_rounding</code> also provides another
rounding class. However, it does not have to be as complex as
<code>rounding</code>. No members are required. The only purpose of
this type is: the basic operators <code>+ - * /</code> will be rounded
toward the nearest integer while an object of type
<code>rounding::tonearest_rounding</code> is alive. This type is used
by the functions <code>dist</code>, <code>median</code> and
<code>bisect</code>.</p>

<h3>Provided classes</h3>

<p>A lot of classes are provided. When they exist in two versions
<code>_standard</code> and <code>_opposite_trick</code>, the first one
does switch the rounding mode each time, and the second one tries to
keep it oriented toward plus infinity. The main purpose of the
<code>_opposite_trick</code> version is to speed up the computations
(see the <a href="#perf">performance notes</a>). This version requires
the rounding mode to be upward before entering any computation
functions of the class. It guarantees the rounding mode will still be
upward at the exit of the functions.</p>

<p>Please note that it is really a very bad idea to mix the
<code>_opposite_trick</code> version with the <code>_standard</code>
since they do not have compatible properties.</p>

<p>There is a third version named <code>_exact</code> which computes
the functions without changing the rouding mode. It is an "exact"
version because it is intended for a base type that produces exact
results.</p>

<p>At the bottom is the class <code>rounding_control</code>. Then come
<code>rounded_arithmetic_exact</code>,
<code>rounded_arithmetic_standard</code> and
<code>rounded_arithmetic_opposite_trick</code>. Then there are
<code>rounded_transc_dummy</code>, <code>rounded_transc_exact</code>,
<code>rounded_transc_standard</code> and
<code>rounded_transc_opposite_trick</code>. And finally are
<code>save_state</code> and <code>save_state_nothing</code>. Each of
these classes provide a set of members that are required by the
classes of the next stage. For example, a
<code>rounded_transc_...</code> class needs the members of a
<code>rounded_arithmetic_...</code> class.</p>

<p>Here comes what each class defines. Later, when they will be
described more thoroughly, the requirements will not be
repeated. Please come back here in order to see them.</p>

<pre>
namespace boost {
  namespace interval_lib {

template&lt;class T&gt;
struct rounding_control
{
  typedef ... rounding_mode;
  void set_rounding_mode(rounding_mode);
  rounding_mode get_rounding_mode();
  void downward ();
  void upward   ();
  void tonearest();
  T to_int(T);
  T force_rounding(T);
  T pi_down();
  T pi_up  ();
  T pi_1_2_down();
  T pi_1_2_up  ();
  T pi_2_1_down();
  T pi_2_1_up  ();
};

template&lt;class T, class Rounding&gt;
struct rounded_arithmetic_...: Rounding
{
  void init();
  T add_down(T, T);
  T add_up  (T, T);
  T sub_down(T, T);
  T sub_up  (T, T);
  T mul_down(T, T);
  T mul_up  (T, T);
  T div_down(T, T);
  T div_up  (T, T);
  T sqrt_down(T);
  T sqrt_up  (T);
  T int_down(T);
  T int_up  (T);
};

template&lt;class T, class Rounding&gt;
struct rounded_transc_...: Rounding
{
  T exp_down(T);
  T exp_up  (T);
  T log_down(T);
  T log_up  (T);
  T cos_down(T);
  T cos_up  (T);
  T tan_down(T);
  T tan_up  (T);
  T asin_down(T);
  T asin_up  (T);
  T acos_down(T);
  T acos_up  (T);
  T atan_down(T);
  T atan_up  (T);
  T sinh_down(T);
  T sinh_up  (T);
  T cosh_down(T);
  T cosh_up  (T);
  T tanh_down(T);
  T tanh_up  (T);
  T asinh_down(T);
  T asinh_up  (T);
  T acosh_down(T);
  T acosh_up  (T);
  T atanh_down(T);
  T atanh_up  (T);
};

template&lt;class Rounding&gt;
struct save_state: Rounding
{
  typedef ... unprotected_rounding;
  typedef ... tonearest_rounding;
};

  } // namespace interval_lib
} // namespace boost
</pre>

<p>So the following type will be an appropriate rounding policy:</p>

<pre>
save_state&lt;
  rounded_transc_...&lt;T,
    rounded_arithmetic_...&lt;T,
      rounding_control&lt;T&gt;
    &gt;
  &gt;
&gt;
</pre>

<p>and the default policies for <code>float</code> and
<code>double</code> (given by <code>rounded_arithmetic&lt;T&gt;</code>
where <code>T</code> is <code>float</code> or <code>double</code>)
are:</p>

<pre>
save_state&lt;
  rounded_transc_dummy&lt;T,
    rounded_arithmetic_opposite_trick&lt;T,
      rounding_control&lt;T&gt;
    &gt;
  &gt;
&gt;
</pre>

<h4>State saving</h4>

<p>First comes <code>save_state</code>. This class is responsible for
saving the current rounding mode and calling <code>init</code> in its
constructor, and for restoring the saved rounding mode in its
destructor. This class also correctly defines the
<code>tonearest</code> and <code>unprotected</code> variations.</p>

<p>If the rounding mode does not require any save nor initialization,
<code>save_state_nothing</code> can be used instead of
<code>save_state</code>.</p>

<h4>Transcendental functions</h4>

<p>The <code>rounded_transc_exact</code>,
<code>rounded_transc_standard</code> and
<code>rounded_transc_opposite_trick</code> classes expect the
<code>std</code> namespace to provide the functions <code>exp log cos
tan acos asin atan cosh sinh tanh acosh asinh atanh</code>. For the
<code>_standard</code> and <code>_opposite_trick</code> versions, all
these functions should respect the current rounding mode fixed by a
call to <code>downward</code> or <code>upward</code>.</p>

<p>Unfortunately, it rarely is the case. It is the reason why the
<code>rounded_transc_dummy</code> class is provided. This class does
not depend on <code>std</code>. It is the reason why
<code>rounded_transc_dummy</code> is the default class rather than
<code>rounded_transc_opposite_trick</code>.</p>

<p>However, there is no magic. The functions of
<code>rounded_transc_dummy</code> do not compute anything. They only
return valid values. For example, <code>cos_down</code> always returns
-1.</p>

<h4>Basic functions</h4>

<p>The <code>rounded_arithmetic_standard</code> and
<code>rounded_arithmetic_opposite_trick</code> classes expect the
operators <code>+ - * /</code> and the function <code>std::sqrt</code>
to respect the current rounding mode.</p>

<p><code>rounded_arithmetic_opposite_trick</code> also requires
<code>std::sqrt</code> to produce a square root rounded upward no more
than 1 ulp away from the exact value (in order for
<code>sqrt_down</code> to use <code>std::sqrt</code> without switching
the rounding mode).</p>

<p><code>rounded_arithmetic_exact</code> requires
<code>std::floor</code> and <code>std::ceil</code> to be defined since
it can not rest on <code>to_int</code>.</p>

<h4>Rounding control</h4>

<p>The functions defined by each of the previous classes did not need
any explanation. For example, the behavior of <code>add_down</code> is
to compute the sum of two numbers rounded downward. For
<code>rounding_control</code>, it is a bit more complex.</p>

<p><code>get_rounding_mode</code> returns the current rounding
mode. <code>set_rounding_mode</code> sets the rounding mode back to a
previous value returned by
<code>get_rounding_mode</code>. <code>downward</code>,
<code>upward</code> and <code>tonearest</code> sets the rounding mode
in one of the three directions. This rounding mode should be global to
all the functions that use the type <code>T</code>. For example, after
a call to <code>downward</code>, <code>force_rounding(x+y)</code> is
expected to return the sum rounded downward.</p>

<p><code>to_int</code> computes the nearest integer accordingly to the
current rounding mode. <code>force_rounding</code> returns its
argument correctly rounded according to the current rounding mode if
it was not already the case. This function is necessary to compensate
for the extended precision of some floating-point units.</p>

<p>The non-specialized version of <code>rounding_control</code> does
not do anything. The functions for the rounding mode are
empty. <code>to_int</code> and <code>force_rounding</code> are
identity functions. The <code>pi_</code> constant functions return
some integers (for example, <code>pi_up</code> returns
<code>T(4)</code>).</p>

<p><code>rounding_control</code> is specialized for <code>float</code>
and <code>double</code> in order to use the floating point unit of the
computer.</p>

<h3>Some Examples</h3>

<p>Here come several cases:</p>

<ul>

<li>if you need precise computations with the <code>float</code> or
<code>double</code> types, use the default
<code>rounded_arithmetic&lt;T&gt;</code>;

<li>for fast wide intervals without any rounding nor precision, use
<code>save_state_nothing&lt;rounded_transc_exact&lt;T,
rounded_arithmetic_exact&lt;T, rounding_control&lt;T&gt; &gt;
&gt; &gt;</code>;

<li>for an exact type (like <code>int</code> or <code>rational</code>
with a little help for infinite and NaN values) without support for
transcendental functions, the solution could be
<code>save_state_nothing&lt;rounded_transc_dummy&lt;T,
rounded_arithmetic_exact&lt;T, rounding_control&lt;T&gt; &gt;
&gt; &gt;</code>;

<li>for a symbolic type, use
<code>save_state_nothing&lt;rounded_transc_exact&lt;T,
rounded_arithmetic_exact&lt;T, my_rounding_control&gt; &gt;
&gt;</code> (<code>my_rounding_control</code> should be defined in
order to provide useful constants);

<li>if it is a more complex case than the previous ones, the best
thing is probably to directly define your own policy.</p>

</ul>

<h2 id="checking">Checking</h2>

<p>The last customizable part of <code>interval_traits</code> deals
with exception handling. For example, when two intervals are divided,
if the second contains zero, the result of the division is
undefined. In this case, the answer will be the biggest interval in
order to respect the basic property of the interval
arithmetic. However, this behavior is not necessarily the one the user
expects. And here does this third parameter of
<code>interval_traits</code> play a part.</p>

<p>An important fact to understand is: the behavior defined by this
parameter is only invoked if the input intervals of a function are not
fully included in the domain of the function. If the input intervals
are inside this domain but the result are exceptionnal (for example in
case of an overflow during the computations), the members of this
checking class will not be called.</p>

<p>There is another important matter. The checking policy does not
allow to say what the results should be in case of problem. It is only
allowed to point out the problem (through an exception for example).</p>

<h3>Synopsis</h3>

<p>The checking class should be of the following type:</p>

<pre>
struct checking
{
  static void inverted_bound(const T&amp; l, const T&amp; u);
  static void divide_by_zero(const T&amp; l, const T&amp; u);
  static void sqrt_nan();
  static void logarithmic_nan();
  static void logarithmic_inf();
  static void trigonometric_nan();
  static void trigonometric_inf();
  static void hyperbolic_nan();
  static void hyperbolic_inf();
};
</pre>

<p>The first function, <code>inverted_bound</code>, deals with the
call to a constructor like <code>interval::interval(T l, T u)</code>
or a function like <code>void interval::assign(T l, T u)</code> when
<code>l</code> is not less or equal to <code>u</code>. It is
generally a good idea to throw an exception if the function
<code>inverted_bound</code> is called. The parameters of the function
are the faulty bounds of the interval. If the function returns to the
caller, the final result will be the empty interval.</p>

<p><code>divide_by_zero</code> is called each time the second interval
of a division contains zero. If the function returns to the caller,
the final result will be the entire interval. The faulty interval is
given as an argument in order for the user to differentiate between a
loss of precision and a bug in the program.</p>

<p>Indeed if the interval is [0,0], there clearly is a problem
somewhere. It is generally not an error when a floating-point number
is divided by zero, because it can be caused by a loss of precision or
an underflow. For example, the computer will compute the same thing
when asked 1/(1 + 1E-100 - 1) and when asked 1/0. However, that is not
true anymore for the interval arithmetic when used to obtain "exact"
results. Because the interval [0,0] means that the result is exactly
zero (in the previous example, the two computations would be
1/[0,1E-9] and 1/[0,0]).</p>

<p>This is also the reason why the functions <code>sqrt_nan</code>,
<code>logarithmic_nan</code>, <code>trigonometric_nan</code> and
<code>hyperbolic_nan</code> are defined, since a function should not
be called with an input completely outside of its definition
domain. Like it was for <code>inverted_bound</code> and
<code>divide_by_zero(0,0)</code>, it usually is a good idea to throw
an exception because the program is defective.</p>

<p>The purpose of the functions <code>logarithmic_inf</code>,
<code>trigonometric_inf</code>, <code>hyperbolic_inf</code> is
different. These functions are called when the input intervals are
partially outside the definition and that will lead to an infinite
result. For example, <code>log</code>([-1,1]) will trigger
<code>logarithmic_inf</code> but <code>exp</code>([0,1e1000]) will not
trigger anything (although the upper bound will be infinite).</p>

<p><code>sqrt_nan</code> is called by <code>sqrt</code>.
<code>logarithmic_inf</code> and <code>logarithmic_nan</code> are
called by <code>log</code>.  <code>trigonometric_nan</code> is called
by <code>asin</code> and <code>acos</code>.
<code>trigonometric_inf</code> is called by <code>tan</code>.
<code>hyperbolic_nan</code> is called by <code>acosh</code> and
<code>atanh</code>. <code>hyperbolic_inf</code> is called by
<code>atanh</code>.</p>

<p>As a side note, because the constant &pi; usually suffers from a
lack of precision, <code>tan</code> is unfortunately unable to trigger
<code>trigonometric_nan</code> on an input like [&pi;/2, &pi;/2].</p>

<h3>Provided classes</h3>

<p>Some checking policies are already defined.
<code>checking_nothing</code> will not do anything; each function is
empty. <code>checking_lax</code> will only throw an exception when
<code>inverted_bound</code> is called. <code>checking_strict</code>
will throw exceptions when <code>inverted_bound</code>,
<code>divide_by_zero(0,0)</code> and each <code>_nan</code> functions
are called. This last policy is the policy by default.</p>

<pre>
namespace boost {
  namespace interval_lib {

template&lt;class T&gt; struct checking_nothing;
template&lt;class T&gt; struct checking_lax;
template&lt;class T&gt; struct checking_strict;

  } // namespace interval_lib
} // namespace boost
</pre>

<p>The thrown exceptions are <code>std::invalid_argument</code> with
an error message looking like <code>"boost::interval: <i>something
appropriate</i>"</code>.</p>

<h2 id="perf">Performance Notes</h2>

<p>This paragraph deals mostly with the performance of the library
with intervals using the floating-point unit (FPU) of the
computer. Let's consider the sum of [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] as an example. The result is
[<code>down</code>(<i>a</i>+<i>c</i>),
<code>up</code>(<i>b</i>+<i>d</i>)]. <code>down</code> and
<code>up</code> indicate the rounding mode needed.</p>

<h3>Rounding Mode Switch</h3>

<p>If the FPU is able to use a different rounding mode for each
operation, there is no problem. For example, it's the case for the
Alpha processor: each floating-point instruction can specify a
different rounding mode. However, the standard IEEE-754 does not
require such a behavior. So most of the FPUs only provide some
instructions to set the rounding mode for all subsequent
operations. And generally, these instructions need to flush the
pipeline of the FPU.</p>

<p>In this situation, the time needed to sum [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] is far worse than the time needed to calculate
<i>a</i>+<i>b</i> and <i>c</i>+<i>d</i> since the two additions cannot
be parallelized. Consequently, the objective is to diminish the number
of rounding mode switch.</p>

<p>If this library is not used to provide exact computations, but only
for pair arithmetic, the solution is quite simple: do not use
rounding. In that case, doing the sum [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] will be as fast as computing <i>a</i>+<i>b</i> and
<i>c</i>+<i>d</i>. Everything is perfect.</p>

<p>However, if exact computations are required, such a solution is
totally unthinkable. So, are we penniless? No, there is still a trick
available. Indeed, <code>down</code>(<i>a</i>+<i>c</i>) =
-<code>up</code>(-<i>a</i>-<i>c</i>) if the unary minus is an exact
operation. It is now possible to calculate the whole sum with the same
rounding mode. Generally, the cost of the mode switching is worse than
the cost of the sign changes.</p>

<p>Let's recapitulate. Before, when doing an addition, there were
three rounding mode switches (<code>down</code>, <code>up</up> and
restore). Now, with this little trick, there are only two switches
(<code>up</up> and restore). It is better, but still a bottleneck when
many operations are nested. Indeed, the generated code for
[<i>a</i>,<i>b</i>] + [<i>c</i>,<i>d</i>] + [<i>e</i>,<i>f</i>] will
probably look like:</p>

<blockquote>
<pre>
up();
t1 = -(-a - c);
t2 = b + d;
restore();
up();
x = -(-t1 - e);
y = t2 + f;
restore();
</pre>
</blockquote>

<p>If you think it is possible to do much better, you are right. For
example, this is better (and probably optimal):</p>

<blockquote>
<pre>
up();
x = -(-a - c - e);
y = b + d + f;
restore();
</pre>
</blockquote>

<p>Such a code will be generated by a compiler if the computations are
made without initialization and restoration of the rounding
mode. However, it would be far too easy if there was no drawback:
because the rounding mode is not restored in the meantime, operations
on floating-point numbers must be prohibited. This method can only be
used if all the operations are operations on interval. Here is an
example of the Horner scheme to compute the value of a polynom.</p>

<pre>
// I is an interval class, the polynom is a simple array
template&lt;class I&gt;
I horner(const I&amp; x, const I p[], int n) {

  // save and initialize the rounding mode
  typename I::traits_type::rounding rnd;

  // define the unprotected version of the interval type
  typedef typename boost::interval_lib::unprotect&lt;I&gt;::type R;
  
  R a = x;
  R y = p[n - 1];
  for(int i = n - 2; i >= 0; i--) {
    y = y * a + (R)(p[i]);
  }
  return y;

  // restore the rounding mode by the destruction of rnd
}
</pre>

<p>It was said at the beginning that the Alpha processors can use a
specific rounding mode for each operation. However, due to the
instruction format, the rounding toward plus infinity is not
available. Only the rounding toward minus infinity can be used. So the
trick using the change of sign becomes essential, but there is no need
to save and restore the rounding mode on both sides of an
operation.</p>

<h3>Extended Registers</h3>

<p>There is another problem besides the cost of the rounding mode
switch. Some FPUs use extended registers (for example,
<code>float</code> computations will be done with <code>double</code>
registers, or <code>double</code> computations with <code>long
double</code> registers). Consequently, many problems can arise.</p>

<p>The first one is due to to the extended precision of the
mantissa. The rounding is also done on this extended precision. And
consequently, we still have <code>down</code>(<i>a</i>+<i>b</i>) =
-<code>up</code>(-<i>a</i>-<i>b</i>) in the extended registers. But
back to the standard precision, we now have
<code>down</code>(<i>a</i>+<i>b</i>) &lt;
-<code>up</code>(-<i>a</i>-<i>b</i>) instead of an equality. A
solution could be not to use this method. But there still are other
problems, with the comparisons between numbers for example.</p>

<p>Naturally, there is also a problem with the extended precision of
the exponent. To illustrate this problem, let <i>m</i> be the biggest
number before +<i>inf</i>. If we calculate 2*[<i>m</i>,<i>m</i>], the
answer should be [<i>m</i>,<i>inf</i>]. But due to the extended
registers, the FPU will first store [<i>2m</i>,<i>2m</i>] and then
convert it to [<i>inf</i>,<i>inf</i>] at the end of the calculus (when
the rounding mode is toward +<i>inf</i>). So the answer is no more
accurate.</p>

<p>There is only one solution: to force the FPU to convert the
extended values back to standard precision after each operation. Some
FPUs provide an instruction able to do this conversion (for example
the PowerPC processors). But for the FPUs that do not provide it (the
x86 processors), the only solution is to write the values to memory
and read them back. Such an operation is obviously very expensive.</p>


</body>
</html>
