<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<title>Boost Interval Arithmetic Library</title>
</head>

<body>

<h1>
<img src="../../c++boost.gif" alt="c++boost.gif (8819 bytes)"
align="center" WIDTH="277" HEIGHT="86">
Header &lt;<a href="../../boost/interval.hpp">boost/interval.hpp</a>&gt;</h1>

<h2>Introduction</h2>

<h3>Interval Arithmetic</h3>

<p>As implied by its name, this library is intended to help
manipulating mathematical intervals. An interval is a pair of numbers
which represents all the numbers between these two. The purpose of
this library is to extend the usual arithmetic functions to
intervals. And it is underlied by this property: if <i>f</i> is a
function on a set of numbers, <b>for each</b> <i>x</i> <b>in</b> the
interval [<i>a</i>,<i>b</i>], <i>f</i>(<i>x</i>) is <b>in</b>
<i>f</i>([<i>a</i>,<i>b</i>]).</p>

<p>There are two reasons a user would like to use this library. The
obvious one is when the user has to compute intervals. The other one
appears when the computer doesn't produce exact results anymore. By
using intervals, it is possible to quantify the propagation of
rounding errors.</p>

<p>For example, let's suppose the computer stores numbers with ten
decimal significant digits. To the question 1 + 1E-100 - 1, the
computer will answer 0 although the correct answer would be
1E-100. With the help of interval arithmetic, the computer will answer
[0,1E-9]. This is quite a huge interval for such a little result, but
the precision is now known, without having to compute the error
propagation.</p>

<h3>Numbers</h3>

<p>In order to successfully use the interval arithmetic, the bounds of
the interval must present some characteristics. First of all, due to
the definition of an interval, the numbers have to be strongly
ordered. Secondly, the arithmetic must be exact or provide some
rounding methods (toward minus or plus infinity) in order to always
ensure large enough intervals. Finally, because heavy loss of
precision are always possible, some numbers have to represent
infinities or an exceptional behavior must be defined. The same
situation occurs also for NaN (<i>Not a Number</i>).</p>

<p>Knowing all of this, a good candidate can be the set of the
floating point numbers defined by the standard IEEE-754. Indeed, if
the interval arithmetic is intended to replace some arithmetic using
the floating point unit of a processor, they are the best
choice.</p>

<h3>Comparisons</h3>

<p>It is straightforward to define the elementary arithmetic
operations on intervals. It is also possible to define some comparison
operators. Given two intervals, the returned value is a subset of
{<i>false</i>,<i>true</i>}. The answers {<i>false</i>} and
{<i>true</i>} are easy to manipulate. But it is not the case for the
answer {<i>false</i>,<i>true</i>} since comparison operators are
supposed to be boolean functions.</p>

<p>So, what to do in order to obtain boolean answers? Nobody will be
shocked if {<i>false</i>} is transformed in <i>false</i> and
{<i>true</i>} in <i>true</i>. And {<i>false</i>,<i>true</i>}? First
solution, an exceptional behavior can be adopted. It will happen when
the two compared intervals overlap on more than a single point. Second
solution, {<i>false</i>,<i>true</i>} can be transformed in
<i>false</i> or <i>true</i>.</p>

<p>If <i>false</i> is chosen, the comparison will be called
"certain". Indeed, the result of [<i>a</i>,<i>b</i>] &lt;
[<i>c</i>,<i>d</i>] will be <i>true</i> if and only if <b>for each</b>
<i>x</i> <b>in</b> [<i>a</i>,<i>b</i>] and <i>y</i> <b>in</b>
[<i>c</i>,<i>d</i>], <i>x</i> &lt; <i>y</i>.</p>

<p>If <i>true</i> is chosen, the comparison will be called
"possible". Indeed, the result of [<i>a</i>,<i>b</i>] &lt;
[<i>c</i>,<i>d</i>] will be <i>true</i> if and only if it
<b>exists</b> <i>x</i> <b>in</b> [<i>a</i>,<i>b</i>] and <i>y</i>
<b>in</b> [<i>c</i>,<i>d</i>] such as <i>x</i> &lt; <i>y</i>.</p>

<h2><code>interval</code> Class</h2>

<p>This class is templated by a base type and a traits type. Here is
the synopsis of the class :</p>

<pre>
namespace boost {

template&lt;class T, class Traits = interval_traits&lt;T&gt; &gt;
class interval
{
public:
  typedef T base_type;
  typedef std::numeric_limits&lt;base_type&gt; base_limits;
  typedef Traits traits_type;

  interval(const T&amp; value = 0);
  interval(const T&amp; l, const T&amp; u);

  template&lt;class Traits2&gt;
  interval(const interval&lt;T, Traits2&gt;&amp; r);

  // compiler-generated copy constructor and assignment operator are fine
  interval&amp; operator=(const T&amp; x);
  void assign(const T&amp; l, const T&amp; u);

  // constructor-like functions
  static interval empty();
  static interval entire();

  interval&amp; operator+= (const T&amp; r);
  interval&amp; operator+= (const interval&amp; r);
  interval&amp; operator-= (const T&amp; r);
  interval&amp; operator-= (const interval&amp; r);
  interval&amp; operator*= (const T&amp; r);
  interval&amp; operator*= (const interval&amp; r);
  interval&amp; operator/= (const T&amp; r);
  interval&amp; operator/= (const interval&amp; r);

  T lower() const;
  T upper() const;
};

} // namespace boost
</pre>

<p>There is also a bunch of functions defined outside the class:</p>

<pre>
namespace boost {

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator+(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator-(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator*(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; operator/(const T&amp; r, const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerle(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerle(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerle(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cergt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cergt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cergt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerge(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerge(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerge(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cereq(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cereq(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cereq(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool cerne(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerne(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerne(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool poslt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool poslt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool poslt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posle(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posle(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posle(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posgt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posgt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posgt(const T&amp; x, const interval&lt;T, Traits&gt; &amp; y);

template&lt;class T, class Traits&gt;
bool posge(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posge(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posge(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool poseq(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool poseq(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool poseq(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool posne(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool posne(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool posne(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&lt;(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&lt;=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&lt;=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&gt;(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator&gt;=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator&gt;=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator==(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator==(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator==(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
bool operator!=(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool operator!=(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool operator!=(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt; T lower(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T upper(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T width(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt; T median(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; pred(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; succ(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
bool empty(const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool in(const T&amp; r, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool in_zero(const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool subset(const interval&lt;T, Traits&gt;&amp; a, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool proper_subset(const interval&lt;T, Traits&gt;&amp; a, const interval&lt;T, Traits&gt;&amp; b);
template&lt;class T, class Traits&gt;
bool overlap(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; intersect(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; hull(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T&gt;
interval&lt;T&gt; hull(const T&amp; x, const T&amp; y);

template&lt;class T, class Traits&gt;
std::pair&lt;interval&lt;T, Traits&gt;, interval&lt;T, Traits&gt; &gt;
bisect(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
bool singleton(const interval&lt;T, Traits&gt;&amp; x)
template&lt;class T, class Traits&gt;
bool equal(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y)

template&lt;class T, class Traits&gt;
T dist(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
T dist(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
T dist(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; scale(const interval&lt;T, Traits&gt;&amp; x, const T&amp; mirror, const T&amp; factor);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; symmetric_scale(const interval&lt;T, Traits&gt;&amp; x, const T&amp; factor);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; square(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; fmod(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; fmod(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; abs(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sqrt(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; exp(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; log(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sin(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; cos(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; tan(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; asin(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; acos(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; atan(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; sinh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; cosh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; tanh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; asinh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; acosh(const interval&lt;T, Traits&gt;&amp; x);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; atanh(const interval&lt;T, Traits&gt;&amp; x);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; max(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
interval&lt;T, Traits&gt; min(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);

} // namespace boost
</pre>

<h2>Operations and Functions</h2>

<p>The basic operations are the unary minus and the binary <code>+ - *
/</code>. The unary operations take an interval and returns an
interval. The binary operations take two intervals, or one interval
and a number, and return an interval.</p>

<p>There are also some assignment operators <code>+= -= *=
/=</code>. There is not much to say.</p>

<p><code>lower</code>, <code>upper</code>, <code>median</code>
respectively compute the lower bound, the upper bound, and the median
number of an interval. <code>width</code> computes the width of an
interval (rounded toward plus infinity). <code>pred</code> and
<code>succ</code> respectively compute an interval strictly smaller
(if possible) and an interval strictly wider (also if possible).</p>

<p>The functions <code>min</code>, <code>max</code>, <code>abs</code>
are also defined. Please do not mistake them for the functions defined
in the standard library (<code>a&lt;b? a : b</code>, <code>a&gt;b? a :
b</code>, <code>a&lt;0? -a : a</code>). These functions are compatible
with the elementary property of interval arithmetic. For example,
<code>max</code>([<i>a</i>,<i>b</i>], [<i>c</i>,<i>d</i>]) =
{<code>max</code>(<i>x</i>,<i>y</i>) | <i>x</i> in [<i>a</i>,<i>b</i>]
and <i>y</i> in [<i>c</i>,<i>d</i>]}. They are not defined in the
<code>std</code> namespace but in the <code>boost</code> namespace to
avoid conflict with the other definitions.</p>

<p>There are also some set functions. <code>intersect</code> does what
you think it does. <code>overlap</code> tests if two intervals have
some common numbers. <code>hull</code> computes the smallest interval
which contains the two parameters; those parameters can be numbers or
interval. <code>in</code> tests if a number is in an interval;
<code>in_zero</code> is a variant which tests if zero is in an
interval. <code>subset</code> tests if the first interval is a subset
of the second; and <code>proper_subset</code> tests if it is a proper
subset. <code>empty</code> and <code>singleton</code> test if an
interval is empty or is a singleton. Finally, <code>equal</equal>
tests if two intervals are equal.</p>

<p>The functions <code>square sqrt log exp sin cos tan asin acos atan
sinh cosh tanh asinh acosh atanh</code> are also defined.

<h2>Comparisons</h2>

<p>As it was said before, the definition of the comparison operators
induces a slight problem. If their return type is restricted to
<code>bool</code>, there are many ways to define them. It is the
reason why the class <code>interval</code> is influenced by a
comparison policy. So the class <code>interval_traits</code> requires
an argument describing a class providing the following functions:</p>

<pre>
struct interval_compare {
  static bool lessthan(const T&amp; x_low, const T&amp; x_up, const T&amp; y_low, const T&amp; y_up);
  static bool equalto(const T&amp; x_low, const T&amp; x_up, const T&amp; y_low, const T&amp; y_up);
};
</pre>

<p>The functions <code>lessthan</code> and <code>equalto</code>
compares two intervals given their bounds. Thanks to this comparison
class, the class <code>interval</code> can now define the following
operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
<code>&gt;=</code>, <code>==</code>, <code>!=</code>. All these
functions are defined for two interval parameters, or for one interval
and a number.</p>

<p>However, these operators are not really handy. For example, if
<code>lessthan</code> is a "certain" comparison, then
<code>&lt;</code> and <code>&gt;</code> are also "certain" comparison,
but <code>&lt;=</code> and <code>&gt;=</code> are only "possible"
comparison. The reason of this discordance is: it is impossible to
have <code>&lt;</code> and <code>&lt;=</code> both "possible" or
"certain", and to have <code>(x&lt;=y) == !(y&lt;x)</code>. However,
if you do not consider overlapping intervals, these two types of
comparisons are equivalent.</p>

<p>To avoid these problems, it is probably better to use some explicit
comparison functions. Their names are composed by <code>cer</code>
(for "certain") or <code>pos</code> (for "possible") followed by
<code>lt</code>, <code>le</code>, <code>gt</code>, <code>ge</code>,
<code>eq</code> or <code>ne</code>. Each of these functions takes two
parameters and returns a boolean. For example:</p>

<pre>
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const interval&lt;T, Traits&gt;&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const interval&lt;T, Traits&gt;&amp; x, const T&amp; y);
template&lt;class T, class Traits&gt;
bool cerlt(const T&amp; x, const interval&lt;T, Traits&gt;&amp; y);
</pre>

<h2>Rounded Arithmetic (FIXME)</h2>

<p>Here comes the tricky part. In order to be as general as possible,
the library uses a complex class hierarchy. The class
<code>interval_traits</code> requires an argument describing a class
able to compute rounded arithmetic. This class must be able to provide
all the elementary operations on the base type. Two versions of each
operation are needed: one rounded upward, and the other rounded
downward. Here is an example of such a class :</p>

<pre>
struct rounded_arithmetic {
  T add_down(const T&amp;, const T&amp;);
  T add_up(const T&amp;, const T&amp;);
  T sub_down(const T&amp;, const T&amp;);
  T sub_up(const T&amp;, const T&amp;);
  T mul_down(const T&amp;, const T&amp;);
  T mul_up(const T&amp;, const T&amp;);
  T div_down(const T&amp;, const T&amp;);
  T div_up(const T&amp;, const T&amp;);
  T sqrt_down(const T&amp;);
  T sqrt_up(const T&amp;);
};
</pre>

<p>In order to simplify the use of the library, two templates are
provided: <code>rounded_arithmetic_standard</code> and
<code>rounded_arithmetic_opposite_trick</code>. The first one changes
the rounding mode for each operation. The second one use the trick
described in the paragraph "Note on performance" to avoid switching
when possible.</p>

<pre>
template &lt;class T, class Rounding&gt;
struct rounded_arithmetic_standard;
template &lt;class T, class Rounding&gt;
struct rounded_arithmetic_opposite_trick;
</pre>

<p><code>rounded_arithmetic_standard</code> is not really useful and
is only provided as a test case. It is better to use
<code>rounded_arithmetic_opposite_trick</code> when possible and to
define a new class if not (for example in order to use a
multi-precision type). This two structs take two template
parameters. The first one is the base type. And the second one is a
class able to change the rounding mode. It must provide the following
functions:</p>

<pre>
struct rounding {
  void downward();
  void upward();
  T force_rounding(const T&amp;);
};
</pre>

<p>The last function ensures that the current rounding mode is
effectively applied; it can be used as a workaround for FPUs which
compute with an extended precision. In order to use the
<code>save_state</code> described below, the class must be extended
with:</p>

<pre>
struct rounding {
  ...
  typedef ... rounding_mode;
  void set_rounding_mode(rounding_mode mode);
  rounding_mode get_rounding_mode();
};

template&lt;class Rounding&gt;
struct save_state;
</pre>

<p><code>save_state</code> is a structure used to save and restore the
rounding mode at the time of construction and destruction of the
rounding object. Thanks to this behavior, the operations on intervals
restore the rounding mode at the end of their computations.</p>

<h3>Some Examples</h3>

<p>The default behavior uses <code>rounded_arithmetic_standard</code>.
There is a specialization in order to use the primitive types
<code>float</code> and <code>double</code> with
<code>rounded_arithmetic_opposite_trick</code> and
<code>save_state</code>.</p>

<pre>
template&lt;class T&gt;
struct rounded_arithmetic:
    rounded_arithmetic_standard&lt;T, rounding_control&lt;T&gt; &gt;
{};

template&lt;&gt;
struct rounded_arithmetic&lt;double&gt;:
  rounded_arithmetic_opposite_trick&lt;double,
				    save_state&lt;rounding_control&lt;double&gt; &gt; &gt;
{};
</pre>

<p>If the default behavior is not what you seek, there are many
possibilities:</p>

<ul>
<li>For fast wide intervals without any rounding nor precision, use
<code>rounded_arithmetic_standard&lt;T, no_rounding_control&lt;T&gt;
&gt;</code>.

<li>For computations without rounding mode switch, use
<code>rounded_arithmetic_opposite_trick&lt;T,
no_rounding_control&lt;T&gt; &gt;</code>. The rounding mode must be
set at the beginning toward plus infinity, and it must not change
anymore (or it must be restored before each operation on intervals).

<li>For precise computations which do not restore rounding mode at the
end of the operations, use
<code>rounded_arithmetic_opposite_trick&lt;T,
rounding_control&lt;T&gt; &gt;.</code>

<li>For interval on a multi-precision base type, specialize
<code>rounded_arithmetic</code>.

<li>etc

</ul>

<h2>Performance Notes</h2>

<p>This paragraph deals mostly with the performance of the library
with intervals using the floating point unit (FPU) of the
computer. Let's consider the sum of [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] as an example. The result is
[<code>down</code>(<i>a</i>+<i>c</i>),
<code>up</code>(<i>b</i>+<i>d</i>)]. <code>down</code> and
<code>up</code> indicate the rounding mode needed.</p>

<h3>Rounding Mode Switch</h3>

<p>If the FPU is able to use a different rounding mode for each
operation, there is no problem. For example, it's the case for the
Alpha processor: each floating-point instruction can specify a
different rounding mode. However, the standard does not require such a
behavior. So most of the FPUs only provide some instructions to set
the rounding mode for all subsequent operations. And generally, these
instructions need to flush the pipeline of the FPU.</p>

<p>In this situation, the time needed to sum [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] is far worse than the time needed to calculate
<i>a</i>+<i>b</i> and <i>c</i>+<i>d</i> since the two additions cannot
be parallelized. Consequently, the objective is to diminish the number
of rounding mode switch.</p>

<p>If this library is not used to provide exact computations, but only
for pair arithmetic, the solution is quite simple: do not use
rounding. In that case, doing the sum [<i>a</i>,<i>b</i>] and
[<i>c</i>,<i>d</i>] will be as fast as computing <i>a</i>+<i>b</i> and
<i>c</i>+<i>d</i>. Everything is perfect.</p>

<p>However, if exact computations are required, such a solution is
totally unthinkable. So, are we penniless? No, there is still a trick
available. Indeed, <code>down</code>(<i>a</i>+<i>c</i>) =
-<code>up</code>(-<i>a</i>-<i>c</i>) if the unary minus is an exact
operation. It is now possible to calculate the whole sum with the same
rounding mode. Generally, the cost of the mode switching is worse than
the cost of the sign changes.</p>

<p>Let's recapitulate. Before, when doing an addition, there were
three rounding mode switches (<code>down</code>, <code>up</up> and
restore). Now, with this little trick, there are only two switches
(<code>up</up> and restore). It is better, but still a bottleneck when
many operations are nested. Indeed, the generated code for
[<i>a</i>,<i>b</i>] + [<i>c</i>,<i>d</i>] + [<i>e</i>,<i>f</i>] will
probably look like:</p>

<blockquote>
<pre>
up();
t1 = -(-a - c);
t2 = b + d;
restore();
up();
x = -(-t1 - e);
y = t2 + f;
restore();
</pre>
</blockquote>

<p>If you think it is possible to do much better, you are right. For
example, this is better (and probably optimal):</p>

<blockquote>
<pre>
up();
x = -(-a - c - e);
y = b + d + f;
restore();
</pre>
</blockquote>

<p>Such a code will be generated by a compiler if the computations are
made without initialization and restoration of the rounding
mode. However, it would be far too easy if there was no drawback:
because the rounding mode is not restored in the meantime, operations
on floating point numbers must be prohibited. This method can only be
used if all the operations are operations on interval. Here is an
example of the Horner scheme to compute the value of a polynom.</p>

<pre>
// I is an interval class, the polynom is a simple array
template&lt;class I&gt;
I horner(const I&amp; x, const I p[], int n) {

  // define the unprotected version of the interval type
  typedef boost::interval_lib::detail::unprotect&lt;I&gt; unprotected;
  typedef typename unprotected::type R;
  
  // initialize and restore the rounding mode
  typedef typename I::traits_type traits;
  typename traits::rounding rnd;

  R a = x;
  R y = p[n - 1];
  for(int i = n - 2; i >= 0; i--) {
    y = y * a + (R)(p[i]);
  }
  return y;
}
</pre>

<p>It was said at the beginning that the Alpha processors can use a
specific rounding mode for each operation. However, due to the
instruction format, the rounding toward plus infinity is not
available. Only the rounding toward minus infinity can be used. So the
trick using the change of sign becomes essential, but there is no need
to save and restore the rounding mode on both sides of an
operation.</p>

<h3>Extended Registers</h3>

<p>There is another problem besides the cost of the rounding mode
switch. Some FPUs use extended registers (for example,
<code>float</code> computations will be done with <code>double</code>
registers, or <code>double</code> computations with <code>long
double</code> registers). Consequently, many problems can arise.</p>

<p>The first one is due to to the extended precision of the
mantissa. The rounding is also done on this extended precision. And
consequently, we still have <code>down</code>(<i>a</i>+<i>b</i>) =
-<code>up</code>(-<i>a</i>-<i>b</i>) in the extended registers. But
back to the standard precision, we now have
<code>down</code>(<i>a</i>+<i>b</i>) &lt;
-<code>up</code>(-<i>a</i>-<i>b</i>) instead of an equality. A
solution could be not to use this method. But there still are other
problems, with the comparisons between numbers for example.</p>

<p>Naturally, there is also a problem with the extended precision of
the exponent. To illustrate this problem, let <i>m</i> be the biggest
number before +<i>inf</i>. If we calculate 2*[<i>m</i>,<i>m</i>], the
answer should be [<i>m</i>,<i>inf</i>]. But due to the extended
registers, the FPU will first store [<i>2m</i>,<i>2m</i>] and then
convert it to [<i>inf</i>,<i>inf</i>] at the end of the calculus (when
the rounding mode is toward +<i>inf</i>). So the answer is no more
accurate.</p>

<p>There is only one solution: to force the FPU to convert the
extended values back to standard precision after each operation. Some
FPUs provide an instruction able to do this conversion (for example
the PowerPC processors). But for the FPUs that do not provide it (the
x86 processors), the only solution is to write the values to memory
and read them back. Such an operation is obviously very expensive.</p>


</body>
</html>
