<html>
<head>
<link rel="stylesheet" type="text/css" href="boost.css">
<title>Boost.Numeric.Bindings.Traits</title>
</head>

<body link="#0000ff" vlink="#800080">
<table border="0" cellpadding="7" cellspacing="0" width="100%" summary="header">
<tr>
<td valign="top" width="300">
<h3><a href="../../../index.htm"><img height="86" width="277" alt="C++ Boost" src="../../../c++boost.gif" border="0"></a></h3>
</td>
<td valign="top">
<h1 align="center">Boost.Numeric.Bindings.Traits</h1>
</td>
</tr>
</table>
<hr>
<h2>Content</h2>
<ol>
<li><a href="#generic_storage_layout">Generic Storage Layout Information</a></li>
<ol>
<li><a href="#rationale">Rationale</a></li>
<li><a href="#using_the_traits">Using the Traits Classes</a></li>
<li><a href="#vector_traits">Vector Traits</a></li>
<ol>
<li>Description</li>
<li>Definition</li>
<li>Associated Types</li>
<li>Expression Semantics</li>
<li>Default Traits</li> 
<li>Specialisations</li> 
</ol>
<li><a href="#matrix_traits">Matrix Traits</a></li>
<ol>
<li>Description</li>
<li>Definition</li>
<li>Associated Types</li>
<li>Expression Semantics</li>
<li>Default Traits and Specialisations</li> 
</ol>
<li><a href="#free_functions">Free functions</a></li>
</ol>
<li><a href="#calling_conventions">Calling Conventions</a></li>
<li><a href="#type_mapping">Type Mapping</a></li>
</ol>
<hr>

<h2><a name="generic_storage_layout">1. Generic Storage Layout Information</a></h2>

<h3><a name="rationale">1.1 Rationale</a></h3>

<p>The Traits Library provides the mappings from the interfaces of
various vector and matrix C++ libraries to the storage layout
format required by the original API's of different external numeric libraries. 

<p>These mappings are implemented by means of traits classes and their
specialisations. One advantage of this approach is that the traits idiom is
non-intrusive: no changes or additions to vector and matrix classes are needed. 
Another advantage is the extensibility
since traits classes can be specialised for many different vector
or matrix libraries. Furthermore, the traits idiom is a compile-time mechanism
and thus adds no run-time overhead. 

<h3><a name="using_the_traits">1.2 Using the Traits Classes</a></h3>

To use particular vector or matrix class in bindings to some external library, proper traits specialisation must be included. Currently specialisations for following vector and matrix classes are available:
<ul>
<li><a href="http://www.boost.org/libs/array/index.htm"><code>boost::array&lt;&gt;</code></a>: in <code>boost_array.hpp</code>
<li>C array: in <code>c_array.hpp</code>
<li><a href="http://anubis.dkuug.dk/jtc1/sc22/open/n2356/lib-numerics.html#lib.numarray"><code>std::valarray&lt;&gt;</code></a>: in <code>std_valarray.hpp</code>
<li><a href="http://anubis.dkuug.dk/jtc1/sc22/open/n2356/lib-containers.html#lib.vector"><code>std::vector&lt;&gt;</code></a>: in <code>std_vector.hpp</code>
<li><a href="http://math.nist.gov/tnt/index.htm">TNT</a> 1D and 2D arrays: in <code>tnt.hpp</code>
<li><a href="http://www.boost.org/libs/numeric/ublas/doc/index.htm">uBLAS</a>: 
<ul>
<li><code>ublas::vector&lt;&gt;</code> and vector proxies: in <code>ublas_vector.hpp</code>
<li><code>ublas::matrix&lt;&gt;</code> (general) and matrix proxies: in <code>ublas_matrix.hpp</code>
<li><code>ublas::symmetric_matrix&lt;&gt;</code> and <code>ublas::symmetric_adaptor&lt;&gt;</code>: in <code>ublas_symmetric.hpp</code>
<li><code>ublas::hermitian_matrix&lt;&gt;</code> and <code>ublas::hermitian_adaptor&lt;&gt;</code>: in <code>ublas_hermitian.hpp</code>
</ul>
</ul>
All mentioned files are in the directory <code>boost/numeric/bindings/traits</code>. 

<p>
If you are using any of these vector or matrix classes, this is in
fact all you need to know about traits classes and their specialisations. 

<p> 
<b>Example.</b> Dot product of vectors <code>a</code> (represented by
<code>std::vector&lt;&gt;</code>) and <code>b</code> (represented by
`plain' C array) using <a href="../../atlas/doc/index.html">ATLAS bindings</a>: 

<pre class="programlisting">
  #include &lt;iostream&gt; 
  #include &lt;boost/numeric/bindings/traits/std_vector.hpp&gt;
  #include &lt;boost/numeric/bindings/traits/c_array.hpp&gt;
  #include &lt;boost/numeric/bindings/atlas/cblas1.hpp&gt;

  namespace atlas = boost::numeric::bindings::atlas;

  int main() {
    std::vector<double> a (10);
    double b[10]; 
    atlas::set (0.1, a);
    atlas::set (0.2, b); 
    std::cout &lt;&lt; atlas::dot (a, b) &lt;&lt; std::endl; 
  }
</pre> 

<h3><a name="vector_traits">1.3 Vector Traits</code></a></h3>

<h4>1.3.1.Description</h4>

Generic bindings functions which manipulate vectors are written in
terms of types (1.3.3) and static functions (1.3.4) defined in the <code>vector_traits&lt;&gt;</code> class.
This class was designed taking into account requirements of the
interfaces of BLAS levels 1 and 2 functions. 

<h4>1.3.2.Definition</h4>

Defined in the header <code>&lt;boost/numeric/bindings/traits/vector_traits.hpp&gt;</code>.

<h4>1.3.3 Associated Types</h4>

<table border=1>
<tr><td>Value type<td><code>value_type</code><td>The type of the objects contained in the vector
<tr><td>Pointer type<td><code>pointer</code><td>Data type used to point to any entry of the vector in memory
</table>

<h4>1.3.4 Expression Semantics</h4>

<table border=1>
<tr><th>Name<th>Expression<th>Semantics
<tr><td>Beginning of storage<td><code>storage(v)</code><td>Returns a
pointer to the beginning of the storage of vector <code>v</code>
<tr><td>Size of vector<td><code>size(v)</code><td>Returns the size of
vector <code>v</code>
<tr><td>Stride<td><code>stride(v)</code><td>Returns the distance
between pointers pointing to consecutive entries in <code>v</code>
</table>

<h4>1.3.5 Default Traits</h4>

Default implementation of <code>vector_traits&lt;&gt;</code> is: 
<pre class="programlisting">
  template &lt;typename V, typename T = typename V::value_type&gt;
  struct default_vector_traits {
    typedef T value_type;
    typedef T* pointer;
    static pointer storage (V&amp; v) { return v.begin(); }
    static int size (V&amp; v) { return v.size(); }
    static int stride (V&amp; v) { return 1; }
  };
  template &lt;typename V, typename T&gt;
  struct default_vector_traits&lt;V const, T&gt; {
    typedef T value_type;
    typedef T const* pointer;
    static pointer storage (V const&amp; v) { return v.begin(); }
    static int size (V const&amp; v) { return v.size(); }
    static int stride (V const&amp; v) { return 1; }
  };

  template &lt;typename V&gt;
  struct vector_traits : default_vector_traits&lt;V&gt; {};
</pre>
As can be seen from the implementation of <code>storage()</code>,
the assumption is that <code>V::iterator</code> is a pointer
and that <code>V</code> provides functions <code>begin()</code>
and <code>size()</code>, as 
e.g. uBLAS storage classes (<code>unbounded_array&lt;&gt;</code> 
and <code>bounded_array&lt;&gt;</code>) and  
<code>boost::array&lt;&gt;</code>. If this is not the case with your
vector class, you must write specialisation (see next subsection). 

<h4>1.3.6 Specialisations</h4>

All specialisations must provide types defined in subsection 1.3.3 and static
member functions defined in subsection 1.3.4. 

<p>
<p>
<b>Example.</b> Specialisations for non-<code>const</code> and
<code>const</code> built-in C arrays (see <code>traits/c_array.hpp</code>):

<pre class="programlisting">
  template &lt;typename T, std::size_t N&gt;
  struct vector_traits&lt;T[N]&gt; {
    typedef T value_type;
    typedef T* pointer;
    static T* storage (T (&amp;a)[N]) { return a; }
    static int size (T (&amp;)[N]) { return N; }
    static int stride (T (&amp;)[N]) { return 1; }
  };

  template &lt;typename T, std::size_t N&gt;
  struct vector_traits&lt;T const [N]&gt; {
    typedef T value_type;
    typedef T const* pointer;
    static T const* storage (T const (&amp;a)[N]) { return a; }
    static int size (T const (&amp;)[N]) { return N; }
    static int stride (T const (&amp;)[N]) { return 1; }
  };
</pre>

<p>
<b>Example.</b> Specialisations for non-<code>const</code> and
<code>const</code> <code>std::vector&lt;&gt;</code>
(see <code>traits/std_vector.hpp</code>):

<pre class="programlisting">
  template &lt;typename T, typename Alloc&gt;
  struct vector_traits&lt;std::vector&lt;T, Alloc&gt; &gt;
  : default_vector_traits&lt;std::vector&lt;T, Alloc&gt; &gt;
  {
    static T* storage (std::vector&lt;T, Alloc&gt;&amp; v) {
      return &amp;v.front();
      // or: return &amp;v[0]; 
    }
  };
  template &lt;typename T, typename Alloc&gt;
  struct vector_traits&lt;std::vector&lt;T, Alloc&gt; const&gt;
  : default_vector_traits&lt;std::vector&lt;T, Alloc&gt; const&gt;
  {
    static T const* storage (std::vector&lt;T, Alloc&gt; const&amp; v) {
      return &amp;v.front();
    }
  };
</pre>
Types <code>value_type</code> and <code>pointer</code> and functions
<code>size()</code> and <code>stride()</code> are inherited from
<code>default_vector_traits&lt;&gt;</code>, 
which was primarily introduced to facilitate writing of specialisation. 


<h3><a name="matrix_traits">1.4 Matrix Traits</a></h3>

<h4>1.4.1 Description</h4>

Generic bindings functions which manipulate matrices are written in
terms of types (1.4.3) and static 
functions (1.4.4) defined in the <code>matrix_traits&lt;&gt;</code> class. 
This class was  designed taking into account requirements of the
interfaces of BLAS (levels 2 and 3) and LAPACK functions. 

<h4>1.4.2 Definition</h4>

Defined in header <code>&lt;boost/numeric/bindings/traits/matrix_traits.hpp&gt;</code>.

<h4>1.4.3 Associated Types</h4>

<table border=1>
<tr><td>Value type<td><code>value_type</code><td>The type of the objects contained in the matrix
<tr><td>Pointer type<td><code>pointer</code><td>Data type used to point to any entry of the matrix in memory
<tr><td>Matrix structure<td><code>matrix_structure</code><td>Describes
the pattern of nonzero and zero elements and the storage layout [1]
<tr><td>Ordering type<td><code>ordering_type</code><td>Row or column major [2]
<tr><td>Upper/lower type<td><code>uplo_type</code><td> For triangular,
symmetric and hermitian matrices:
indicates whether upper or lower triangle is referenced or stored [3]
</table>

<p>
[1] <code>matrix_structure</code> is a tag which can be: 
<ul>
<li> <code>struct general_t {};</code>
<li> <code>struct symmetric_t {};</code>
<li> <code>struct symmetric_packed_t {};</code>
<li> <code>struct hermitian_t {};</code>
<li> <code>struct hermitian_packed_t {};</code>
<li> <code>struct triangular_t {};</code>
<li> <code>struct triangular_packed_t {};</code>
<li> <code>struct banded_t {};</code>
<li> <code>struct banded_packed_t {};</code>
<li> <code>struct unknown_structure_t {};</code>
</ul>

<p>
[2] <code>ordering_type</code> can be:
<ul>
<li> <code>struct row_major_t {};</code>
<li> <code>struct column_major_t {};</code>
</ul>

<p>
[3] Upper/lower tag must be defined only for triangular (packed),
symmetric (packed) and hermitian (packed) matrices. For packed types
it indicates whether upper or lower triangle is stored, and for
adaptors it indicates which triangle is referenced.
<code>uplo_type</code> can be: 
<ul>
<li> <code>struct upper_t {};</code>
<li> <code>struct lower_t {};</code>
</ul>

</ul>

<h4>1.4.4 Expression Semantics</h4>
<table border=1>
<tr><th>Name<th>Expression<th>Semantics
<tr><td>Beginning of storage<td><code>storage(m)</code><td>Returns a pointer to the
beginning of the storage of matrix <code>m</code>
<tr><td>Size of storage<td><code>storage_size(m)</code><td>Returns the size of the storage
<tr><td>Number of rows<td><code>size1(m)</code><td>Returns the number of rows of matrix <code>m</code>
<tr><td>Number of columns<td><code>size2(m)</code><td>Returns the number of
columns matrix <code>m</code>
<tr><td>Leading
dimension<td><code>leading_dimension(m)</code><td>Returns the distance
between pointers to the first element in consecutive rows (columns) in
case of row-major (column-major) matrices [1] 
</table>

<p>
[1] Not needed for all matrix types (e.g. not needed triangular, symmetric and hermitian packed). 

<h4>1.4.5 Default Traits and Specialisations</h4>

Generic <code>matrix_traits&lt;&gt;</code> is in fact an empty struct, because
there is no reasonable default -- different matrix libraries provide 
different interfaces; for example, functions that return number of
rows and columns are in uBLAS named <code>size1()</code> and
<code>size2()</code>, and in TNT <code>dim1()</code> and <code>dim2()</code>.

<p>
Specialisations of <code>matrix_traits&lt;&gt;</code> must provide
types defined in subsection 1.4.3 and static member functions defined
in subsection 1.4.4. 

<p>
<b>Example.</b> Specialisation of <code>matrix_traits&lt;&gt;</code>
for non-<code>const</code> <code>ublas::matrix&lt;&gt;</code>
(see <code>traits/ublas_matrix.hpp</code>): 
<pre class="programlisting">
  template &lt;typename T, typename F, typename ArrT&gt;
  struct matrix_traits&lt;boost::numeric::ublas::matrix&lt;T, F, ArrT&gt; &gt; {
    typedef general_t matrix_structure;
    typedef T value_type;
    typedef T* pointer;
    typedef typename detail::ublas_ordering&lt;typename F::orientation_category&gt;::type ordering_type;

    typedef boost::numeric::ublas::matrix&lt;T, F, ArrT&gt; matrix_type;
    static pointer storage (matrix_type& m) {
      return vector_traits&lt;typename matrix_type::array_type&gt;::storage (m.data());
    }
    static int size1 (matrix_type&amp; m) { return m.size1(); }
    static int size2 (matrix_type&amp; m) { return m.size2(); }
    static int storage_size (matrix_type&amp; m) { return size1 (m) * size2 (m); }
    static int leading_dimension (matrix_type&amp; m) {
      return matrix_type::functor_type::size2 (m.size1(), m.size2());
    }

    static int stride1 (matrix_type&amp; m) {
      return matrix_type::functor_type::one1 (m.size1(), m.size2());
    }
    static int stride2 (matrix_type&amp; m) {
      return matrix_type::functor_type::one2 (m.size1(), m.size2());
    }
  };
</pre>

Notes: 

<p>
[1] As <code>ublas::matrix&lt;&gt;</code> is general matrix,
<code>uplo_type</code> is not defined.

<p>
[2] Note that the <code>storage()</code> function uses
<code>vector_traits::storage&lt;&gt;()</code>. 

<p> 
[3] This specialisation also defines functions <code>stride1()</code> and
<code>stride2()</code> because they are needed in specialisations of
<code>vector_traits&lt;&gt;</code> for  <code>ublas::matrix_row&lt;&gt;</code>
and <code>ublas::matrix_column&lt;&gt;</code>. 

<p>
<b>Example.</b> Specialisation of <code>matrix_traits&lt;&gt;</code>
for <code>const</code> <code>ublas::symmetric_matrix&lt;&gt;</code>
(see <code>traits/ublas_symmetric.hpp</code>): 
<pre class="programlisting">
  template &lt;typename T, typename F1, typename F2, typename A&gt;
  struct matrix_traits&lt;boost::numeric::ublas::symmetric_matrix&lt;T, F1, F2, A&gt; const&gt; {
    typedef symmetric_packed_t matrix_structure;
    typedef T value_type;
    typedef T const* pointer;
    typedef typename detail::ublas_ordering&lt;typename F2::orientation_category&gt;::type ordering_type;
    typedef typename detail::ublas_uplo&lt;typename F1::packed_category&gt;::type uplo_type;

    typedef boost::numeric::ublas::symmetric_matrix&lt;T, F1, F2, A&gt; matrix_type;

    static pointer storage (matrix_type const&amp; sm) {
      return vector_traits&lt;typename matrix_type::const_array_type&gt;::storage (sm.data());
    }
    static int size1 (matrix_type const&amp; sm) { return sm.size1(); }
    static int size2 (matrix_type const&amp; sm) { return sm.size2(); }
    static int storage_size (matrix_type const&amp; sm) {
      return (size1 (sm) + 1) * size2 (sm) / 2;
    }
  };
</pre>

This specialisation defines <code>uplo_type</code>, but
<code>leading_dimension()</code> makes no sense for packed matrix
storage types. 


<h3><a name="free_functions">1.5 Free functions</a></h3>

<p>There are also free functions available to obtain storage layout
information:
<ul>
<li> in <code>vector_traits.hpp</code>:

<p>
<table border=1>
<tr><th>Expression<th>Semantics
<tr><td><code>vector_storage(v)</code><td>Returns a
pointer to the beginning of the storage of vector <code>v</code>
<tr><td><code>vector_size(v)</code><td>Returns the size of
vector <code>v</code>
<tr><td><code>vector_stride(v)</code><td>Returns the distance
between pointers pointing to consecutive entries in <code>v</code>
</table>
<p>

<li> in <code>matrix_traits.hpp</code>:

<p>
<table border=1>
<tr><th>Expression<th>Semantics
<tr><td><code>matrix_storage(m)</code><td>Returns a pointer to the
beginning of the storage of matrix <code>m</code>
<tr><td><code>matrix_storage_size(m)</code><td>Returns the size of the storage
<tr><td><code>matrix_size1(m)</code><td>Returns the number of rows of matrix <code>m</code>
<tr><td><code>matrix_size2(m)</code><td>Returns the number of
columns matrix <code>m</code>
<tr><td><code>leading_dimension(m)</code><td>Returns the leading
dimension of matrix <code>m</code>
</table>

</ul>

<p>
The syntax of these is slightly simpler than that of the traits class;
e.g. instead of 
<pre class="programlisting">
  traits::vector_traits&lt;some_vector_type const&gt;::storage (v)
</pre>
one can write
<pre class="programlisting">
  traits::vector_storage (v)
</pre>


<p> 
Although these free functions generally rely
on the traits classes, they can also implement an alternative strategy
on compilers that are unable to handle the traits idiom (see
<code>traits/vector_raw.hpp</code> and <code>traits/matrix_raw.hpp</code>).

<h2>2. Calling conventions</h2>
<p>To facilitate generic bindings for libraries of which the API
is defined in Fortran, the Traits Library provides
a multi-platform mapping between C and Fortran calling conventions:
some Fortran compilers add a trailing underscore to all defined 
symbols, some generate symbols in uppercase only. 
<p>When including the <code>traits/fortran.h</code> header, one of following
symbols will be defined:
<ul>
<li><code>BIND_FORTRAN_LOWERCASE_UNDERSCORE</code>
<li><code>BIND_FORTRAN_LOWERCASE</code>
</ul>
Function names are generated using the <code>FORTRAN_ID</code> macro:
<pre  class="programlisting">
      #if defined(BIND_FORTRAN_LOWERCASE_UNDERSCORE)
      #define FORTRAN_ID( id ) id##_
      #elif defined(BIND_FORTRAN_LOWERCASE)
      #define FORTRAN_ID( id ) id
      #endif 
</pre>

<p><a href="http://www.aei.mpg.de/~jthorn/c2f.html">Here's more
information</a> on how to call Fortran routines from C and C++. 

<h2><a name="type_mapping">3. Type mapping</a></h2>

<p>See type.h for mapping of Fortran types to C.
<p>See type.hpp for mapping of Fortran types to C++
<p>See value_traits.hpp for value_type inside complex types.

</body>
</html>
