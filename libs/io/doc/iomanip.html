<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>Boost I/O Manipulator Library</title>
</head>
<body>
<h1><img src="../../../c++boost.gif" alt="c++boost.gif (8819 bytes)"
align="middle" width="277" height="86">I/O Manipulator Library</h1>

<p>The header <cite><a
href="../../../boost/io/iomanip.hpp">boost/io/iomanip.hpp</a></cite>
covers C++ I/O stream-manipulating functions (possibly including
function templates and function-acting [template] classes).</p>

<h2><a name="contents">Contents</a></h2>

<ol>
	<li><a href="#contents">Contents</a></li>
	<li><a href="#rationale">Rationale</a></li>
	<li><a href="#header">Header Synopsis</a></li>
	<li><a href="#newl">Non-flushing Line-break Output Manipulator</a></li>
	<li><a href="#skipl">Line-skipping Input Manipulator</a></li>
	<li><a href="#resetios">Stream Formatting State-reset Manipulator</a></li>
	<li><a href="#mnewer">Repeated-character Output Manipulator</a></li>
	<li><a href="#mskipper">Repeated-character Input Manipulator</a></li>
	<li><a href="#refer">References</a></li>
	<li><a href="#credits">Credits</a>
		<ul>
			<li><a href="#contributors">Contributors</a></li>
			<li><a href="#history">History</a></li>
		</ul></li>
</ol>

<h2><a name="rationale">Rationale</a></h2>

<p>There are several I/O manipulators that can be useful to a general
audience besides the ones given in the Standard library.  This header
supplies some of them.</p>

<h2><a name="header">Header Synopsis</a></h2>

<blockquote><pre>
#include &lt;iosfwd&gt;   <i>// for std::basic_ostream, std::basic_istream, and std::basic_ios (declarations)</i>

namespace boost
{
namespace io
{

template &lt; typename Ch, class Tr &gt;
    std::basic_ostream&lt;Ch, Tr&gt; &amp;  newl( std::basic_ostream&lt;Ch, Tr&gt; &amp;os );

template &lt; typename Ch, class Tr &gt;
    std::basic_istream&lt;Ch, Tr&gt; &amp;  skipl( std::basic_istream&lt;Ch, Tr&gt; &amp;is );

template &lt; typename Ch, class Tr &gt;
    std::basic_ios&lt;Ch, Tr&gt; &amp;  resetios( std::basic_ios&lt;Ch, Tr&gt; &amp;s );

template &lt; char C &gt;
    class multi_newer;
typedef multi_newer&lt;'\n'&gt;  multi_newl;

template &lt; char C &gt;
    class multi_skipper;
typedef multi_skipper&lt;'\n'&gt;  multi_skipl;

}
}
</pre></blockquote>

<h2><a name="newl">Non-flushing Line-break Output Manipulator</a></h2>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::newl( std::basic_ostream&lt;Ch, Tr&gt; &amp;os );
</pre></blockquote>

<p><strong>Effects:</strong> inserts a new-line character (sequence),
appropiate for the stream's character type and locale, into stream
<var>os</var></p>

<p><strong>Returns:</strong> <var>os</var></p>

<p><strong>Rationale:</strong> gives a method of inserting a newline
that looks object-based, without either the additional flushing behavior
of <code>std::endl</code>, or the background formatting adjustments of
using <code>'\n'</code> (or <code>&quot;\n&quot;</code>) directly with
<code>operator &lt;&lt;</code></p>

<h2><a name="skipl">Line-skipping Input Manipulator</a></h2>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_istream&lt;Ch, Tr&gt; &amp;
boost:io::skipl( std::basic_istream&lt;Ch, Tr&gt; &amp;is );
</pre></blockquote>

<p><strong>Effects:</strong> passes over all the characters in stream
<var>is</var> until the first encountered new-line character (sequence)
is passed, or the stream's end is reached</p>

<p><strong>Returns:</strong> <var>is</var></p>

<p><strong>Rationale:</strong> a counterpart to <a
href="#newl"><code>newl</code></a></p>

<h2><a name="resetios">Stream Formatting State-reset Manipulator</a></h2>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_ios&lt;Ch, Tr&gt; &amp;
boost:io::resetios( std::basic_ios&lt;Ch, Tr&gt; &amp;s );
</pre></blockquote>

<p><strong>Effects:</strong> resets the formatting attributes of stream
<var>s</var>, except locale, to their default values</p>

<p><strong>Returns:</strong> <var>s</var></p>

<p><strong>Postconditions:</strong> <code><var>s</var>.flags() == (
std::ios_base::skipws | std::ios_base::dec ) &amp;&amp; <var>s</var>.width()
== 0 &amp;&amp; <var>s</var>.precision() == 6 &amp;&amp; Tr::eq(
<var>s</var>.fill(), <var>s</var>.widen(' ') )</code></p>

<p><strong>Rationale:</strong> a quick method to reset all the formatting
attributes of a stream, especially after many attribute changes</p>

<h2><a name="mnewer">Repeated-character Output Manipulator</a></h2>

<p>Objects from a <code>boost::io::multi_newer</code> template class represent
manipulators that send multiple consecutive copies of a character to a given output
stream.  Said manipulators can be temporarily created (in-line, without a
name) or created conventionally in advance for multiple insertions or for
use as a function object.</p>

<blockquote><pre>
#include &lt;ios&gt;      <i>// for std::streamsize</i>
#include &lt;ostream&gt;  <i>// for std::basic_ostream</i>

template &lt; char C &gt;
class boost::io::multi_newer
{
public:
    // Template argument
    static  char const  marked_char = C;

    // Lifetime management
    explicit  multi_newer( std::streamsize count, bool final_flush = false );

    // Operators
    template &lt; typename Ch, class Tr &gt;
    void  operator ()( std::basic_ostream&lt;Ch, Tr&gt; &amp;os ) const;

};
</pre></blockquote>

<p>The template parameter, <var>C</var>, represents the character that will
be repeatedly inserted into an output stream when desired.  The
<code>marked_char</code> static constant object gives the value of that template
parameter (helpful if the template parameter is hidden by a <code>typedef</code>).</p>

<p>The first (or only) argument of the constructor indicates the number,
or <var>count</var>, of characters that the manipulator object will insert
in a single call.  The optional second constructor argument,
<var>final_flush</var>, determines whether or not a request to flush the
output stream will be done after an insertion (defaults to no flushing).</p>

<p>The function-call operator takes an output stream as its only argument.
While the stream <var>os</var> is in a good condition, an unformatted
insertion of the marked character occurs <var>count</var> (from
the constructor) times.  The marked character shall be appropiate
for the stream's character type and locale.  If mandated by the constructor's
<var>final_flush</var> state, then the stream is flushed (if it's still good).</p>

<p>Type-alias <code>boost::io::multi_newl</code> does the usual case of the
repeatedly printed character being a line break.</p>

<blockquote><pre>
template &lt; typename Ch, class Tr, char C &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;os, multi_newer&lt;C&gt; const &amp;n );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>n</var>( <var>os</var> )</code></p>

<p><strong>Returns:</strong> <var>os</var></p>

<p><strong>Rationale:</strong> alternative to using something like <a href="#newl"><code>newl</code></a> or <code>std::endl</code> multiple times consecutively</p>

<h2><a name="mskipper">Repeated-character Input Manipulator</a></h2>

<p>Objects from a <code>boost::io::multi_skipper</code> template class represent
manipulators that pass over many characters until a given count of a certain character
is encountered in a given input stream.  Said manipulators can be temporarily
created (in-line, without a name) or created conventionally in advance for
multiple extractions or for use as a function object.</p>

<blockquote><pre>
#include &lt;ios&gt;      <i>// for std::streamsize</i>
#include &lt;istream&gt;  <i>// for std::basic_istream</i>

template &lt; char C &gt;
class boost::io::multi_skipper
{
public:
    // Template argument
    static  char const  marked_char = C;

    // Lifetime management
    explicit  multi_skipper( std::streamsize count, bool final_sync = false );

    // Operators
    template &lt; typename Ch, class Tr &gt;
    void  operator ()( std::basic_istream&lt;Ch, Tr&gt; &amp;is ) const;

};
</pre></blockquote>

<p>The template parameter, <var>C</var>, represents the character that will
be repeatedly watched and extracted from an input stream when desired.  The
<code>marked_char</code> static constant object gives the value of that template
parameter (helpful if the template parameter is hidden by a <code>typedef</code>).</p>

<p>The first (or only) argument of the constructor indicates the number,
or <var>count</var>, of marked characters that the manipulator object will
watch for in a single call.  The optional second constructor argument,
<var>final_sync</var>, determines whether or not a request to synchronize the
input stream will be done after an extraction (defaults to no synchronization).</p>

<p>The function-call operator takes an input stream as its only argument.
While the stream <var>is</var> is in a good condition, characters will be
extracted from the stream and ignored until an expanded marked character
is encountered <var>count</var> (from the constructor) times.
The marked character expansion shall be appropiate for the
stream's character type, traits type, and locale.  If mandated by the constructor's
<var>final_sync</var> state, then the stream is synchronized (if it's still good).</p>

<p>Type-alias <code>boost::io::multi_skipl</code> does the usual case of the
repeatedly watched character being a line break.</p>

<blockquote><pre>
template &lt; typename Ch, class Tr, char C &gt;
std::basic_istream&lt;Ch, Tr&gt; &amp;
boost::io::operator &gt;&gt;( std::basic_istream&lt;Ch, Tr&gt; &amp;is, multi_skipper&lt;C&gt; const &amp;s );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>s</var>( <var>is</var> )</code></p>

<p><strong>Returns:</strong> <var>is</var></p>

<p><strong>Rationale:</strong> alternative to using something like <a href="#skipl"><code>skipl</code></a> multiple times consecutively</p>

<h2><a name="refer">References</a></h2>

<ul>
	<li>The I/O manipulator library header itself: <cite><a
		href="../../../boost/io/iomanip.hpp">boost/io/iomanip.hpp</a></cite></li>
	<li>Some test/example code: <cite><a
		href="../test/iomanip_test.cpp">iomanip_test.cpp</a></cite></li>
</ul>

<h2><a name="credits">Credits</a></h2>

<h3><a name="contributors">Contributors</a></h3>

<dl>
	<dt><a href="http://www.josuttis.com">Nicolai Josuttis</a>
	<dd>Section 13.6.2 of his <cite>The C++ Standard Library: A Tutorial
		and Reference</cite> book is the basis of <a
		href="#skipl"><code>skipl</code></a> (called
		<code>ignore_line</code> in the book).

	<dt><a href="../../../people/dietmar_kuehl.htm">Dietmar Kuehl</a>
	<dd><a href="news:94atsm$27u$6@news.BelWue.DE">Posted the idea</a>
		that led to <a href="#newl"><code>newl</code></a> on
		<a
		href="news:comp.lang.c++.moderated">comp.lang.c++.moderated</a>.

	<dt>Angelika Langer and Klaus Kreft
	<dd>Section 3.2.2.1 of their <cite>Standard C++ IOStreams and Locales:
		Advanced Programmer's Guide and Reference</cite> book is the
                basis of <a href="#mnewer"><code>multi_newl</code></a> (called
		<code>mendl</code> in the book).

	<dt><a href="../../../people/daryle_walker.html">Daryle Walker</a>
	<dd>Started the library.  Contributed the initial versions of <a
		href="#skipl"><code>skipl</code></a>, <a
                href="#newl"><code>newl</code></a>, <a
                href="#resetios"><code>resetios</code></a>, <a
                href="#mnewer"><code>multi_newer</code></a>, and <a
                href="#mskipper"><code>multi_skipper</code></a>.  Contributed
                <cite><a
                href="../test/iomanip_test.cpp">iomanip_test.cpp</a></cite>.
</dl>

<h3><a name="history">History</a></h3>

<dl>
	<dt>20 Nov 2002, Daryle Walker
	<dd>Initial version
</dl>

<hr>

<p>Revised: 6 December 2003</p>

<p>Copyright 2003 Daryle Walker.  Use, modification, and distribution
are subject to the Boost Software License, Version 1.0.  (See accompanying
file <a href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or a copy at
&lt;<a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>&gt;.)</p>
</body>
</html>
