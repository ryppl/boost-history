<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>Boost I/O Manipulator Library</title>
</head>
<body>
<h1><img src="../../../c++boost.gif" alt="c++boost.gif (8819 bytes)"
align="middle" width="277" height="86">I/O Manipulator Library</h1>

<p>The header <cite><a
href="../../../boost/io/iomanip.hpp">boost/io/iomanip.hpp</a></cite>
covers C++ I/O stream-manipulating functions (possibly including
function templates and function-acting [template] classes).</p>

<h2><a name="contents">Contents</a></h2>

<ol>
	<li><a href="#contents">Contents</a></li>
	<li><a href="#rationale">Rationale</a></li>
	<li><a href="#header">Header Synopsis</a></li>
	<li><a href="#mbnewer">Repeated-character Output Manipulator</a></li>
	<li><a href="#mbskipper">Repeated-character Input Manipulator</a></li>
	<li><a href="#mnewer">Repeated-narrow-character Output Manipulator</a></li>
	<li><a href="#mskipper">Repeated-narrow-character Input Manipulator</a></li>
	<li><a href="#mnewl">Repeated-line-break Output Manipulator</a></li>
	<li><a href="#mskipl">Repeated-line-break Input Manipulator</a></li>
	<li><a href="#newl">Non-flushing Line-break Output Manipulator</a></li>
	<li><a href="#skipl">Line-skipping Input Manipulator</a></li>
	<li><a href="#resetios">Stream Formatting State-reset Manipulator</a></li>
	<li><a href="#ios_form">Form-based Manipulator</a>
		<ul>
			<li><a href="#ios_form_types">Member Types &amp; Templates</a></li>
			<li><a href="#ios_form_ctr">Constructors</a></li>
			<li><a href="#ios_form_observe">Observer Member Functions</a></li>
			<li><a href="#ios_form_mutate">Mutating Member Functions</a></li>
			<li><a href="#ios_form_ops">Operators</a></li>
		</ul></li>
	<li><a href="#refer">References</a></li>
	<li><a href="#credits">Credits</a>
		<ul>
			<li><a href="#contributors">Contributors</a></li>
			<li><a href="#history">History</a></li>
		</ul></li>
</ol>

<h2><a name="rationale">Rationale</a></h2>

<p>There are several I/O manipulators that can be useful to a general
audience besides the ones given in the Standard library.  This header
supplies some of them.</p>

<h2><a name="header">Header Synopsis</a></h2>

<blockquote><pre>
#include &lt;iosfwd&gt;  <i>// for std::basic_ostream, std::basic_istream, and std::char_traits (declarations)</i>
#include &lt;ios&gt;     <i>// for std::streamsize and std::basic_ios</i>

namespace boost
{
namespace io
{

template &lt; typename Ch = char &gt;
    class multi_basic_newer;
template &lt; typename Ch = char &gt;
    class multi_basic_skipper;

class multi_newer;
class multi_skipper;

template &lt; typename Ch, class Tr = std::char_traits&lt;Ch&gt; &gt;
    class basic_ios_form;

typedef basic_ios_form&lt;char&gt;      ios_form;
typedef basic_ios_form&lt;wchar_t&gt;  wios_form;

multi_newer  multi_newl( std::streamsize count, bool final_flush = false );

multi_skipper  multi_skipl( std::streamsize count, bool final_sync = false );

template &lt; typename Ch, class Tr &gt;
    std::basic_ostream&lt;Ch, Tr&gt; &amp;  newl( std::basic_ostream&lt;Ch, Tr&gt; &amp;os );

template &lt; typename Ch, class Tr &gt;
    std::basic_istream&lt;Ch, Tr&gt; &amp;  skipl( std::basic_istream&lt;Ch, Tr&gt; &amp;is );

template &lt; typename Ch, class Tr &gt;
    std::basic_ios&lt;Ch, Tr&gt; &amp;  resetios( std::basic_ios&lt;Ch, Tr&gt; &amp;s );

}
}
</pre></blockquote>

<h2><a name="mbnewer">Repeated-character Output Manipulator</a></h2>

<p>Objects from a <code>boost::io::multi_basic_newer</code> template class represent manipulators that send multiple consecutive copies of a character to a given output stream.  Said manipulators can be temporarily created (in-line, without a name) or created conventionally in advance for multiple insertions or for use as a function object.</p>

<blockquote><pre>
#include &lt;ios&gt;      <i>// for std::streamsize</i>
#include &lt;ostream&gt;  <i>// for std::basic_ostream</i>

template &lt; typename Ch &gt;
class boost::io::multi_basic_newer
{
public:
    // Template argument
    typedef Ch  char_type;

    // Lifetime management
    multi_basic_newer( char_type c, std::streamsize count, bool final_flush = false );

    // Accessors
    char_type        repeated_char() const;
    std::streamsize  repeat_count() const;
    bool             will_synchronize_afterwards() const;

    // Operator
    template &lt; class Tr &gt;
    void  operator ()( std::basic_ostream&lt;Ch, Tr&gt; &amp;os ) const;

};
</pre></blockquote>

<p>The template parameter, <var>Ch</var>, represents type of characters that will be marked for repeated insertions.  The <code>char_type</code> type-alias reveals that type of that template parameter (helpful if the template parameter is hidden by a <code>typedef</code>).</p>

<p>The first constructor argument is the marked character <var>c</var> to be repeatedly inserted.  The second argument of the constructor indicates the number, or <var>count</var>, of characters that the manipulator object will insert in a single call.  The optional third constructor argument, <var>final_flush</var>, determines whether or not a request to synchronize the stream will be done after an insertion (defaults to no synchronization).  The values used in these arguments can be retrieved later with the <code>repeated_char</code>, <code>repeat_count</code>, and <code>will_synchronize_afterwards</code> member functions, respectively.</p>

<p>The function-call operator takes an output stream as its only argument.  While the stream <var>os</var> is in a good condition, an unformatted insertion of the marked character occurs <var>count</var> (from the constructor) times.  The marked character shall be appropiate for the stream's character type and locale.  If mandated by the constructor's <var>final_flush</var> state, then the stream is flushed (if it's still good).</p>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;os, multi_basic_newer&lt;Ch&gt; const &amp;n );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>n</var>( <var>os</var> )</code></p>

<p><strong>Returns:</strong> <var>os</var></p>

<p><strong>Rationale:</strong> enables <code>multi_basic_newer&lt;&gt;</code> objects to be activated by output streaming</p>

<h2><a name="mbskipper">Repeated-character Input Manipulator</a></h2>

<p>Objects from a <code>boost::io::multi_basic_skipper</code> template class represent manipulators that receive and ignore several copies of a character (and all characters in between) from a given input stream.  Said manipulators can be temporarily created (in-line, without a name) or created conventionally in advance for multiple extractions or for use as a function object.</p>

<blockquote><pre>
#include &lt;ios&gt;      <i>// for std::streamsize</i>
#include &lt;istream&gt;  <i>// for std::basic_istream</i>

template &lt; typename Ch &gt;
class boost::io::multi_basic_skipper
{
public:
    // Template argument
    typedef Ch  char_type;

    // Lifetime management
    multi_basic_skipper( char_type c, std::streamsize count, bool final_sync = false );

    // Accessors
    char_type        repeated_char() const;
    std::streamsize  repeat_count() const;
    bool             will_synchronize_afterwards() const;

    // Operator
    template &lt; class Tr &gt;
    void  operator ()( std::basic_istream&lt;Ch, Tr&gt; &amp;is ) const;

};
</pre></blockquote>

<p>The template parameter, <var>Ch</var>, represents type of characters that will be marked for repeated extractions.  The <code>char_type</code> type-alias reveals that type of that template parameter (helpful if the template parameter is hidden by a <code>typedef</code>).</p>

<p>The first constructor argument is the marked character <var>c</var> to be repeatedly extracted.  The second argument of the constructor indicates the number, or <var>count</var>, of (matching) characters that the manipulator object will extract in a single call.  The optional third constructor argument, <var>final_sync</var>, determines whether or not a request to synchronize the stream will be done after an extraction (defaults to no synchronization).  The values used in these arguments can be retrieved later with the <code>repeated_char</code>, <code>repeat_count</code>, and <code>will_synchronize_afterwards</code> member functions, respectively.</p>

<p>The function-call operator takes an input stream as its only argument.  While the stream <var>is</var> is in a good condition, characters will be extracted from the stream and ignored until the expanded marked character is encountered <var>count</var> (from the constructor) times.  The marked character expansion shall be appropiate for the stream's character type, traits type, and locale.  If mandated by the constructor's <var>final_sync</var> state, then the stream is synchronized (if it's still good).</p>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_istream&lt;Ch, Tr&gt; &amp;
boost::io::operator &gt;&gt;( std::basic_istream&lt;Ch, Tr&gt; &amp;is, multi_basic_skipper&lt;Ch&gt; const &amp;s );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>s</var>( <var>is</var> )</code></p>

<p><strong>Returns:</strong> <var>is</var></p>

<p><strong>Rationale:</strong> enables <code>multi_basic_skipper&lt;&gt;</code> objects to be activated by input streaming</p>

<h2><a name="mnewer">Repeated-narrow-character Output Manipulator</a></h2>

<p>Objects from the <code>boost::io::multi_newer</code> class represent
manipulators that send multiple consecutive copies of a character to a given output
stream.  Said manipulators can be temporarily created (in-line, without a
name) or created conventionally in advance for multiple insertions or for
use as a function object.</p>

<blockquote><pre>
#include &lt;ios&gt;      <i>// for std::streamsize</i>
#include &lt;ostream&gt;  <i>// for std::basic_ostream</i>

class boost::io::multi_newer
{
public:
    // Lifetime management
    multi_newer( char c, std::streamsize count, bool final_flush = false );

    // Accessors
    char             repeated_char() const;
    std::streamsize  repeat_count() const;
    bool             will_synchronize_afterwards() const;

    // Operators
    template &lt; typename Ch, class Tr &gt;
    void  operator ()( std::basic_ostream&lt;Ch, Tr&gt; &amp;os ) const;

};
</pre></blockquote>

<p>The first constructor argument is the marked character <var>c</var> to be repeatedly inserted.  The second argument of the constructor indicates the number, or <var>count</var>, of characters that the manipulator object will insert in a single call.  The optional third constructor argument, <var>final_flush</var>, determines whether or not a request to flush the output stream will be done after an insertion (defaults to no flushing).  The values used in these arguments can be retrieved later with the <code>repeated_char</code>, <code>repeat_count</code>, and <code>will_synchronize_afterwards</code> member functions, respectively.</p>

<p>The function-call operator takes an output stream as its only argument.  While the stream <var>os</var> is in a good condition, an unformatted insertion of the marked character occurs <var>count</var> (from the constructor) times.  The marked character shall be appropiate for the stream's character type and locale.  If mandated by the constructor's <var>final_flush</var> state, then the stream is flushed (if it's still good).</p>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;os, multi_newer const &amp;n );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>n</var>( <var>os</var> )</code></p>

<p><strong>Returns:</strong> <var>os</var></p>

<p><strong>Rationale:</strong> enables <code>multi_newer</code> objects to be activated by streaming</p>

<h2><a name="mskipper">Repeated-narrow-character Input Manipulator</a></h2>

<p>Objects from the <code>boost::io::multi_skipper</code> class represent
manipulators that pass over many characters until a given count of a certain character
is encountered in a given input stream.  Said manipulators can be temporarily
created (in-line, without a name) or created conventionally in advance for
multiple extractions or for use as a function object.</p>

<blockquote><pre>
#include &lt;ios&gt;      <i>// for std::streamsize</i>
#include &lt;istream&gt;  <i>// for std::basic_istream</i>

class boost::io::multi_skipper
{
public:
    // Lifetime management
    multi_skipper( char c, std::streamsize count, bool final_sync = false );

    // Accessors
    char             repeated_char() const;
    std::streamsize  repeat_count() const;
    bool             will_synchronize_afterwards() const;

    // Operators
    template &lt; typename Ch, class Tr &gt;
    void  operator ()( std::basic_istream&lt;Ch, Tr&gt; &amp;is ) const;

};
</pre></blockquote>

<p>The first constructor argument is the marked character <var>c</var> to be repeatedly ignored.  The second argument of the constructor indicates the number, or <var>count</var>, of marked characters that the manipulator object will extract in a single call.  The optional third constructor argument, <var>final_sync</var>, determines whether or not a request to synchronize the input stream will be done after an extraction (defaults to no synchronization).  The values used in these arguments can be retrieved later with the <code>repeated_char</code>, <code>repeat_count</code>, and <code>will_synchronize_afterwards</code> member functions, respectively.</p>

<p>The function-call operator takes an input stream as its only argument.  While the stream <var>is</var> is in a good condition, characters will be extracted from the stream and ignored until an expanded marked character is encountered <var>count</var> (from the constructor) times.  The marked character expansion shall be appropiate for the stream's character type, traits type, and locale.  If mandated by the constructor's <var>final_sync</var> state, then the stream is synchronized (if it's still good).</p>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_istream&lt;Ch, Tr&gt; &amp;
boost::io::operator &gt;&gt;( std::basic_istream&lt;Ch, Tr&gt; &amp;is, multi_skipper const &amp;s );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>s</var>( <var>is</var> )</code></p>

<p><strong>Returns:</strong> <var>is</var></p>

<p><strong>Rationale:</strong> enables <code>multi_skipper</code> objects to be activated by streaming</p>

<h2><a name="mnewl">Repeated-line-break Output Manipulator</a></h2>

<blockquote><pre>
<em>smanip</em>
boost::io::multi_newl( std::streamsize count, bool final_flush = false );
</pre></blockquote>

<p><strong>Returns:</strong> an object <code>s</code> such that <code>os &lt;&lt; s</code>, when <code>os</code> is a <code>std::basic_ostream&lt;&gt;</code>, inserts (unformatted) <var>count</var> instances of the line-break character, followed by a flush to <code>os</code> if <var>final_flush</var> is TRUE</p>

<p><strong>Rationale:</strong> gives a method of inserting several newlines consecutively, with or without additional flushing behavior</p>

<h2><a name="mskipl">Repeated-line-break Input Manipulator</a></h2>

<blockquote><pre>
<em>smanip</em>
boost:io::multi_skipl( std::streamsize count, bool final_sync = false );
</pre></blockquote>

<p><strong>Returns:</strong> an object <code>s</code> such that <code>is &gt;&gt; s</code>, when <code>is</code> is a <code>std::basic_istream&lt;&gt;</code>, extracts (unformatted) and ignores all characters until <var>count</var> instances of the line-break character have been encountered (or when the end-of-file is reached), followed by a synchronization to <code>is</code> if <var>final_sync</var> is TRUE</p>

<p><strong>Rationale:</strong> gives a method of removing several consecutive lines, with or without additional syncing behavior</p>

<h2><a name="newl">Non-flushing Line-break Output Manipulator</a></h2>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::newl( std::basic_ostream&lt;Ch, Tr&gt; &amp;os );
</pre></blockquote>

<p><strong>Effects:</strong> inserts a new-line character (sequence),
appropiate for the stream's character type and locale, into stream
<var>os</var></p>

<p><strong>Returns:</strong> <var>os</var></p>

<p><strong>Rationale:</strong> gives a method of inserting a newline
that looks object-based, without either the additional flushing behavior
of <code>std::endl</code>, or the background formatting adjustments of
using <code>'\n'</code> (or <code>&quot;\n&quot;</code>) directly with
<code>operator &lt;&lt;</code></p>

<h2><a name="skipl">Line-skipping Input Manipulator</a></h2>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_istream&lt;Ch, Tr&gt; &amp;
boost:io::skipl( std::basic_istream&lt;Ch, Tr&gt; &amp;is );
</pre></blockquote>

<p><strong>Effects:</strong> passes over all the characters in stream
<var>is</var> until the first encountered new-line character (sequence)
is passed, or the stream's end is reached</p>

<p><strong>Returns:</strong> <var>is</var></p>

<p><strong>Rationale:</strong> a counterpart to <a
href="#newl"><code>newl</code></a></p>

<h2><a name="resetios">Stream Formatting State-reset Manipulator</a></h2>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_ios&lt;Ch, Tr&gt; &amp;
boost:io::resetios( std::basic_ios&lt;Ch, Tr&gt; &amp;s );
</pre></blockquote>

<p><strong>Effects:</strong> resets the formatting attributes of stream
<var>s</var>, except locale, to their default values</p>

<p><strong>Returns:</strong> <var>s</var></p>

<p><strong>Postconditions:</strong> <code><var>s</var>.flags() == (
std::ios_base::skipws | std::ios_base::dec ) &amp;&amp; <var>s</var>.width()
== 0 &amp;&amp; <var>s</var>.precision() == 6 &amp;&amp; Tr::eq(
<var>s</var>.fill(), <var>s</var>.widen(' ') )</code></p>

<p><strong>Rationale:</strong> a quick method to reset all the formatting
attributes of a stream, especially after many attribute changes</p>

<h2><a name="ios_form">Form-based Manipulator</a></h2>

<p>Objects from a <code>boost::io::basic_ios_form</code> template class represent manipulators that determine what and how to affect the standard I/O attributes via repeated calls to its member functions, then can change how a single insertion or extraction call happens for an streamable object.  Said manipulators can be temporarily created (in-line, without a name) or created conventionally in advance for multiple insertions/extractions.</p>

<blockquote><pre>
#include &lt;ios&gt;  <i>// for std::streamsize, std::ios_base, and std::basic_ios</i>

template &lt; typename Ch, class Tr &gt;
class boost::io::basic_ios_form
{
    template &lt; typename Obj &gt;  struct binder_out;
    template &lt; typename Obj &gt;  struct binder_inout;

public:
    // Template arguments
    typedef Ch  char_type;
    typedef Tr  traits_type;

    // Lifetime management (use automatic destructor and copy constructor)
              basic_ios_form();
    explicit  basic_ios_form( std::basic_ios&lt;Ch, Tr&gt; const &amp;i );

    // Accessors
    bool  override_fill() const;
    bool  override_precision() const;
    bool  override_width() const;

    std::ios_base::fmtflags  overridden_flags() const;
    bool                     override_flags() const;

    bool  override_adjustfield() const;
    bool  override_basefield() const;
    bool  override_floatfield() const;

    bool  override_boolalpha() const;
    bool  override_showbase() const;
    bool  override_showpoint() const;
    bool  override_showpos() const;
    bool  override_skipws() const;
    bool  override_unitbuf() const;
    bool  override_uppercase() const;

    char_type                fill() const;
    std::streamsize          precision() const;
    std::streamsize          width() const;
    std::ios_base::fmtflags  flags() const;

    // Mutators
    basic_ios_form &amp;  fill( char_type const &amp;c );

    basic_ios_form &amp;  precision( std::streamsize s );
    basic_ios_form &amp;  width( std::streamsize s );

    basic_ios_form &amp;    flag( std::ios_base::fmtflags f );
    basic_ios_form &amp;  unflag( std::ios_base::fmtflags f );
    basic_ios_form &amp;    flags( std::ios_base::fmtflags f, std::ios_base::fmtflags mask );

    basic_ios_form &amp;  boolalpha();
    basic_ios_form &amp;  noboolalpha();

    basic_ios_form &amp;  showbase();
    basic_ios_form &amp;  noshowbase();

    basic_ios_form &amp;  showpoint();
    basic_ios_form &amp;  noshowpoint();

    basic_ios_form &amp;  showpos();
    basic_ios_form &amp;  noshowpos();

    basic_ios_form &amp;  skipws();
    basic_ios_form &amp;  noskipws();

    basic_ios_form &amp;  unitbuf();
    basic_ios_form &amp;  nounitbuf();

    basic_ios_form &amp;  uppercase();
    basic_ios_form &amp;  nouppercase();

    basic_ios_form &amp;  internal();
    basic_ios_form &amp;  left();
    basic_ios_form &amp;  right();

    basic_ios_form &amp;  dec();
    basic_ios_form &amp;  hex();
    basic_ios_form &amp;  oct();

    basic_ios_form &amp;  fixed();
    basic_ios_form &amp;  scientific();

    // Operators
    template &lt; typename Obj &gt;
    binder_out&lt;Obj&gt;  operator ()( Obj const &amp;o ) const;

    template &lt; typename Obj &gt;
    binder_inout&lt;Obj&gt;  operator ()( Obj &amp;o ) const;

};
</pre></blockquote>

<p>The template parameters <var>Ch</var> and <var>Tr</var> represent the character and character traits types for the streams that can use this manipulator type.  The <code>char_type</code> and <code>traits_type</code> aliases reveals those types when the parameters of the manipulator type are hidden by a <code>typedef</code>.</p>

<h3><a name="ios_form_types">Member Types &amp; Templates</a></h3>

<dl>
	<dt><code>char_type</code>
	<dd>a synonym for the manipulator's character type

	<dt><code>traits_type</code>
	<dd>a synonym for the manipulator's character-traits type

	<dt><code>template &lt; typename Obj &gt;  struct binder_out;</code>
	<dd>type of temporary objects returned when using this manipulator type with a constant object; (output) streaming this object results in streaming the constant object with the attributes given by this manipulator type

	<dt><code>template &lt; typename Obj &gt;  struct binder_inout;</code>
	<dd>type of temporary objects returned when using this manipulator type with a mutable object; streaming this object results in streaming the mutable object with the attributes given by this manipulator type
</dl>

<h3><a name="ios_form_ctr">Constructors</a></h3>

<p><strong>Note:</strong> the automatically-defined destructor and copy constructor are used.</p>

<dl>
	<dt><code>basic_ios_form();</code>
	<dd>
		<strong>Effects:</strong> initializes all the usage flags to FALSE (<i>i.e.</i> no attributes will be overridden); sets the saved attributes to arbitrary values

	<dt><code>explicit  basic_ios_form( std::basic_ios&lt;Ch, Tr&gt; const &amp;i );</code>
	<dd>
		<strong>Effects:</strong> initializes all the usage flags to TRUE (<i>i.e.</i> all attributes will be overridden); sets the saved attributes to copies of the attributes in stream <var>i</var>
</dl>

<h3><a name="ios_form_observe">Observer Member Functions</a></h3>

<dl>
	<dt><code>bool  override_fill() const;</code><br>
	    <code>bool  override_precision() const;</code><br>
	    <code>bool  override_width() const;</code><br>
	    <code>bool  override_flags() const;</code>
	<dd>
		<strong>Returns:</strong> whether or not attribute <var>XX</var> of <code>override_<var>XX</var></code> has been overridden in this manipulator object<br>
		<strong>Rationale:</strong> status indicator of which attribute changes will be applied

	<dt><code>std::ios_base::fmtflags  overridden_flags() const;</code>
	<dd>
		<strong>Returns:</strong> which format flags have been overridden; returns the equivalent of zero if <code>this-&gt;override_flags()</code> returns FALSE<br>
		<strong>Rationale:</strong> status indicator of which specific format-flag attribute changes will be applied

	<dt><code>bool  override_adjustfield() const;</code><br>
	    <code>bool  override_basefield() const;</code><br>
	    <code>bool  override_floatfield() const;</code><br>
	    <code>bool  override_boolalpha() const;</code><br>
	    <code>bool  override_showbase() const;</code><br>
	    <code>bool  override_showpoint() const;</code><br>
	    <code>bool  override_showpos() const;</code><br>
	    <code>bool  override_skipws() const;</code><br>
	    <code>bool  override_unitbuf() const;</code><br>
	    <code>bool  override_uppercase() const;</code>
	<dd>
		<strong>Returns:</strong> for attribute <var>XX</var> of member function <code>override_<var>XX</var></code>, <code>0 != ( std::ios_base::<var>XX</var> &amp; this-&gt;overridden_flags() )</code><br>
		<strong>Rationale:</strong> status indicator of which subset of format-flag attribute changes will be applied

	<dt><code>char_type                fill() const;</code><br>
	    <code>std::streamsize          precision() const;</code><br>
	    <code>std::streamsize          width() const;</code><br>
	    <code>std::ios_base::fmtflags  flags() const;</code>
	<dd>
		<strong>Preconditions:</strong> for attribute <var>XX</var> of member function <code><var>XX</var></code>, <code>this-&gt;override_<var>XX</var>()</code> must return TRUE<br>
		<strong>Returns:</strong> the attribute value that will be applied to any streams using this manipulator object (for <code>flags</code>, only the flags masked by <code>this-&gt;overridden_flags()</code> will be changed in any applied stream)<br>
		<strong>Rationale:</strong> values of the actual changes to be applied
</dl>

<h3><a name="ios_form_mutate">Mutating Member Functions</a></h3>

<dl>
	<dt><code>basic_ios_form &amp;  fill( char_type const &amp;c );</code><br>
	    <code>basic_ios_form &amp;  precision( std::streamsize s );</code><br>
	    <code>basic_ios_form &amp;  width( std::streamsize s );</code>
	<dd>
		<strong>Effects:</strong> for attribute <var>XX</var> of member function <code><var>XX</var></code>, changes that attribute to the value of the given argument <var>c</var> or <var>s</var> (for <code>fill</code>, the copying routine from the character-traits type is used)<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_<var>XX</var>()</code> becomes TRUE<br>
		<strong>Rationale:</strong> setting the changes to be applied

	<dt><code>basic_ios_form &amp;  flag( std::ios_base::fmtflags f );</code>
	<dd>
		<strong>Effects:</strong> adds the flags selected in <var>f</var> to the replacement flag list in the active state and to the mask of overridden flags<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( <var>f</var> &amp; this-&gt;overridden_flags() )</code> and <code>( <var>f</var> &amp; this-&gt;flags() )</code> become <var>f</var><br>
		<strong>Rationale:</strong> setting the changes of specific active format flags to be applied

	<dt><code>basic_ios_form &amp;  unflag( std::ios_base::fmtflags f );</code>
	<dd>
		<strong>Effects:</strong> adds the flags selected in <var>f</var> to the replacement flag list in the inactive state and to the mask of overridden flags<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( <var>f</var> &amp; this-&gt;overridden_flags() )</code> becomes <var>f</var>; <code>( <var>f</var> &amp; this-&gt;flags() )</code> becomes zero<br>
		<strong>Rationale:</strong> setting the changes of specific inactive format flags to be applied

	<dt><code>basic_ios_form &amp;  flags( std::ios_base::fmtflags f, std::ios_base::fmtflags mask );</code>
	<dd>
		<strong>Effects:</strong> adds the flags selected in <var>mask</var> to the replacement flag list in the state given in <var>f</var> (restricted by <var>mask</var>);  adds the flags selected in <var>mask</var> to the mask of overridden flags<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( <var>mask</var> &amp; this-&gt;overridden_flags() )</code> becomes <var>mask</var>; <code>( <var>mask</var> &amp; this-&gt;flags() )</code> becomes <code>( <var>f</var> &amp; <var>mask</var> )</code><br>
		<strong>Rationale:</strong> setting the changes to be applied for a specific set of format flags and values

	<dt><code>basic_ios_form &amp;  boolalpha();</code><br>
	    <code>basic_ios_form &amp;  showbase();</code><br>
	    <code>basic_ios_form &amp;  showpoint();</code><br>
	    <code>basic_ios_form &amp;  showpos();</code><br>
	    <code>basic_ios_form &amp;  skipws();</code><br>
	    <code>basic_ios_form &amp;  unitbuf();</code><br>
	    <code>basic_ios_form &amp;  uppercase();</code>
	<dd>
		<strong>Effects:</strong> for attribute <var>XX</var> of member function <code><var>XX</var></code>, adds that format flag to the replacement flag list in the active state and to the mask of overriden flags<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( std::ios_base::<var>XX</var> &amp; this-&gt;overridden_flags() )</code> and <code>( std::ios_base::<var>XX</var> &amp; this-&gt;flags() )</code> become <code>std::ios_base::<var>XX</var></code><br>
		<strong>Rationale:</strong> setting the changes to be applied for a single active format flag

	<dt><code>basic_ios_form &amp;  noboolalpha();</code><br>
	    <code>basic_ios_form &amp;  noshowbase();</code><br>
	    <code>basic_ios_form &amp;  noshowpoint();</code><br>
	    <code>basic_ios_form &amp;  noshowpos();</code><br>
	    <code>basic_ios_form &amp;  noskipws();</code><br>
	    <code>basic_ios_form &amp;  nounitbuf();</code><br>
	    <code>basic_ios_form &amp;  nouppercase();</code>
	<dd>
		<strong>Effects:</strong> for attribute <var>XX</var> of member function <code>no<var>XX</var></code>, adds that format flag to the replacement flag list in the inactive state and to the mask of overriden flags<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( std::ios_base::<var>XX</var> &amp; this-&gt;overridden_flags() )</code> becomes <code>std::ios_base::<var>XX</var></code>; <code>( std::ios_base::<var>XX</var> &amp; this-&gt;flags() )</code> becomes zero<br>
		<strong>Rationale:</strong> setting the changes to be applied for a single inactive format flag

	<dt><code>basic_ios_form &amp;  internal();</code><br>
	    <code>basic_ios_form &amp;  left();</code><br>
	    <code>basic_ios_form &amp;  right();</code><br>
	    <code>basic_ios_form &amp;  dec();</code><br>
	    <code>basic_ios_form &amp;  hex();</code><br>
	    <code>basic_ios_form &amp;  oct();</code><br>
	    <code>basic_ios_form &amp;  fixed();</code><br>
	    <code>basic_ios_form &amp;  scientific();</code>
	<dd>
		<strong>Effects:</strong> for attribute <var>XX</var> of member function <code><var>XX</var></code> and matching mask attribute <var>YY</var>, adds the flags selected in <var>YY</var> to the replacement flags list in the state given by <var>XX</var>; adds the flags selected in <var>YY</var> to the mask of overridden flags (for <code>internal</code>, <code>left</code>, and <code>right</code>, <var>YY</var> is <code>adjustfield</code>; for <code>dec</code>, <code>hex</code>, and <code>oct</code>, <var>YY</var> is <code>basefield</code>; and for <code>fixed</code> and <code>scientific</code>, <var>YY</var> is <code>floatfield</code>)<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( std::ios_base::<var>YY</var> &amp; this-&gt;overridden_flags() )</code> and <code>( std::ios_base::<var>YY</var> &amp; this-&gt;flags() )</code> become <code>std::ios_base::<var>XX</var></code><br>
		<strong>Rationale:</strong> setting the changes to be applied for a single state within a group of format flag values
</dl>

<h3><a name="ios_form_ops">Operators</a></h3>

<p><strong>Note:</strong> the automatically-defined assignment operator is used.</p>

<dl>
	<dt><code>template &lt; typename Obj &gt;  binder_out&lt;Obj&gt;  operator ()( Obj const &amp;o ) const;</code>
	<dd>
		<strong>Returns:</strong> an object <var>x</var>, that contains constant references to <code>*this</code> and <var>o</var>; when <code><var>s</var> &lt;&lt; <var>x</var></code> is applied, such that <var>s</var> is an output stream object, <code><var>s</var> &lt;&lt; <var>o</var></code> will occur, with <var>s</var>'s attributes temporarily set to the ones in <code>*this</code>, in effect only during this streaming call; specifically, if <code>this-&gt;override_flags()</code>, then <code><var>s</var>.flags() == ( (this-&gt;flags() &amp; this-&gt;overridden_flags()) | (<var>old_s_flags</var> &amp; ~this-&gt;overridden_flags()) )</code>, if <code>this-&gt;override_precision()</code>, then <code><var>s</var>.precision() == this-&gt;precision()</code>, if <code>this-&gt;override_width()</code>, then <code><var>s</var>.width() == this-&gt;width()</code>, and if <code>this-&gt;override_fill()</code>, then <code>traits_type::eq( <var>s</var>.fill(), this-&gt;fill() )</code><br>
		<strong>Rationale:</strong> lets this manipulator actually do its work for output

	<dt><code>template &lt; typename Obj &gt;  binder_inout&lt;Obj&gt;  operator ()( Obj &amp;o ) const;</code>
	<dd>
		<strong>Returns:</strong> an object <var>x</var>, that contains a constant reference to <code>*this</code> and a non-constant reference to <var>o</var>; when <code><var>s</var> &lt;&lt; <var>x</var></code> or <code><var>s</var> &gt;&gt; <var>x</var></code> is applied, such that <var>s</var> is a stream object, <code><var>s</var> &lt;&lt; <var>o</var></code> or <code><var>s</var> &gt;&gt; <var>o</var></code> will occur, with <var>s</var>'s attributes temporarily set to the ones in <code>*this</code>, in effect only during this streaming call; specifically, if <code>this-&gt;override_flags()</code>, then <code><var>s</var>.flags() == ( (this-&gt;flags() &amp; this-&gt;overridden_flags()) | (<var>old_s_flags</var> &amp; ~this-&gt;overridden_flags()) )</code>, if <code>this-&gt;override_precision()</code>, then <code><var>s</var>.precision() == this-&gt;precision()</code>, if <code>this-&gt;override_width()</code>, then <code><var>s</var>.width() == this-&gt;width()</code>, and if <code>this-&gt;override_fill()</code>, then <code>traits_type::eq( <var>s</var>.fill(), this-&gt;fill() )</code><br>
		<strong>Rationale:</strong> lets this manipulator actually do its work with non-constant objects (for input or output)
</dl>

<blockquote><pre>
template &lt; typename Ch, class Tr, typename Obj &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;os, boost::io::basic_ios_form&lt;Ch, Tr&gt;::binder_out&lt;Obj&gt; const &amp;b );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>os</var> &lt;&lt; <var>X</var></code>, where <var>X</var> is the streamable object held in reference by <var>b</var>; the stream <var>os</var> temporarily uses the stream attributes selected by the manipulator object held in reference by <var>b</var></p>

<p><strong>Returns:</strong> <var>os</var></p>

<p><strong>Rationale:</strong> enables <code>basic_ios_form&lt;&gt;</code> objects to be activated by output streaming for constant streamable objects</p>

<blockquote><pre>
template &lt; typename Ch, class Tr, typename Obj &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;os, boost::io::basic_ios_form&lt;Ch, Tr&gt;::binder_inout&lt;Obj&gt; const &amp;b );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>os</var> &lt;&lt; <var>X</var></code>, where <var>X</var> is the streamable object held in reference by <var>b</var>; the stream <var>os</var> temporarily uses the stream attributes selected by the manipulator object held in reference by <var>b</var></p>

<p><strong>Returns:</strong> <var>os</var></p>

<p><strong>Rationale:</strong> enables <code>basic_ios_form&lt;&gt;</code> objects to be activated by output streaming for mutable streamable objects</p>

<blockquote><pre>
template &lt; typename Ch, class Tr, typename Obj &gt;
std::basic_istream&lt;Ch, Tr&gt; &amp;
boost::io::operator &gt;&gt;( std::basic_istream&lt;Ch, Tr&gt; &amp;is, boost::io::basic_ios_form&lt;Ch, Tr&gt;::binder_inout&lt;Obj&gt; const &amp;b );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>is</var> &gt;&gt; <var>X</var></code>, where <var>X</var> is the streamable object held in reference by <var>b</var>; the stream <var>is</var> temporarily uses the stream attributes selected by the manipulator object held in reference by <var>b</var></p>

<p><strong>Returns:</strong> <var>is</var></p>

<p><strong>Rationale:</strong> enables <code>basic_ios_form&lt;&gt;</code> objects to be activated by input streaming for mutable streamable objects</p>

<h2><a name="refer">References</a></h2>

<ul>
	<li>The I/O manipulator library header itself: <cite><a
		href="../../../boost/io/iomanip.hpp">boost/io/iomanip.hpp</a></cite></li>
	<li>Some test/example code: <cite><a
		href="../test/iomanip_test.cpp">iomanip_test.cpp</a></cite></li>
</ul>

<h2><a name="credits">Credits</a></h2>

<h3><a name="contributors">Contributors</a></h3>

<dl>
	<dt><a href="http://www.josuttis.com">Nicolai Josuttis</a>
	<dd>Section 13.6.2 of his <cite>The C++ Standard Library: A Tutorial
		and Reference</cite> book is the basis of <a
		href="#skipl"><code>skipl</code></a> (called
		<code>ignore_line</code> in the book).

	<dt><a href="../../../people/dietmar_kuehl.htm">Dietmar Kuehl</a>
	<dd><a href="news:94atsm$27u$6@news.BelWue.DE">Posted the idea</a>
		that led to <a href="#newl"><code>newl</code></a> on
		<a href="news:comp.lang.c++.moderated">comp.lang.c++.moderated</a>.

	<dt><a href="http://www.langer.camelot.de/Welcome.html">Angelika Langer</a>
		and Klaus Kreft
	<dd>Section 3.2.2.1 of their <cite>Standard C++ IOStreams and Locales:
		Advanced Programmer's Guide and Reference</cite> book is the
		basis of <a href="#mnewl"><code>multi_newl</code></a> (called
		<code>mendl</code> in the book).

	<dt><a href="http://www.research.att.com/~bs/homepage.html">Bjarne Stroustrup</a>
	<dd>Exercise 27 of Section 21.10 of his <cite>The C++ Programming Language,
		3<sup>rd</sup> edition</cite> book is the basis of <a
		href="#resetios"><code>resetios</code></a> (called
		<code>general</code> in the book).  Exercise 20 of the same section
		of the same book is the inspiration for <a
		href="#ios_form"><code>basic_ios_form</code></a>

	<dt><a href="../../../people/daryle_walker.html">Daryle Walker</a>
	<dd>Started the library.  Contributed the initial versions of <a
		href="#skipl"><code>skipl</code></a>, <a
		href="#newl"><code>newl</code></a>, <a
		href="#resetios"><code>resetios</code></a>, <a
		href="#mnewl"><code>multi_newl</code></a>, <a
		href="#mskipl"><code>multi_skipl</code></a>, <a
		href="#mbnewer"><code>multi_basic_newer</code></a>, <a
		href="#mbskipper"><code>multi_basic_skipper</code></a>, <a
		href="#mnewer"><code>multi_newer</code></a>, <a
		href="#mskipper"><code>multi_skipper</code></a>, and <a
		href="#ios_form"><code>basic_ios_form</code></a>.  Contributed
		<cite><a href="../test/iomanip_test.cpp">iomanip_test.cpp</a></cite>.
</dl>

<h3><a name="history">History</a></h3>

<dl>
	<dt>20 Nov 2002, Daryle Walker
	<dd>Initial version
</dl>

<hr>

<p>Revised: 23 January 2004</p>

<p>Copyright 2003-2004 Daryle Walker.  Use, modification, and distribution
are subject to the Boost Software License, Version 1.0.  (See accompanying
file <a href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or a copy at
&lt;<a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>&gt;.)</p>
</body>
</html>
