<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>Array-based I/O Stream Library</title>
</head>
<body text="black" bgcolor="white" link="blue" vlink="purple" alink="red">
<h1><img src="../../../c++boost.gif" alt="c++boost.gif (8819 bytes)"
align="middle" width="277" height="86">Array-Based Streams</h1>

<p>The header <cite><a
href="../../../boost/io/array_stream.hpp">boost/io/array_stream.hpp</a></cite
> covers streams and stream buffers that use an internal array for
their source/sink.</p>

<h2><a name="contents">Contents</a></h2>

<ol>
	<li><a href="#contents">Contents</a></li>
	<li><a href="#rationale">Rationale</a></li>
	<li><a href="#header">Header Synopsis</a></li>
	<li><a href="#array_sb">Array-based Stream Buffer Class Template</a>
		<ul>
			<li><a href="#m_types">Member Types</a></li>
			<li><a href="#m_ctr">Constructors</a></li>
			<li><a href="#m_observe">Observer Member Functions</a></li>
			<li><a href="#m_obj">Member Objects</a></li>
		</ul></li>
	<li><a href="#array_s">Array-based Stream Class Templates</a></li>
	<li><a href="#refer">References</a></li>
	<li><a href="#credits">Credits</a>
		<ul>
			<li><a href="#contributors">Contributors</a></li>
			<li><a href="#history">History</a></li>
		</ul></li>
</ol>

<h2><a name="rationale">Rationale</a></h2>

<p>The buffering for C++ IOStream stream buffers work like a virtual
array of characters.  The stream buffer class template in this library
represents the virtual array as an actual array that is stored in the
stream buffer.  This library is fairly uninteresting; meant mainly as a
test case for the <a
href="streambuf_wrapping.html">stream-buffer-wrapping stream base
library</a>, but it may have real-life applications.  For outputting,
an user can observe how inserted objects are represented.  For
inputting, an user can have the internal array mapped to some
inspection process.</p>

<h2><a name="header">Header Synopsis</a></h2>

<blockquote><pre>
#include &lt;cstddef&gt; <i>// for std::size_t</i>
#include &lt;iosfwd&gt;  <i>// for std::char_traits (declaration)</i>

namespace boost
{
namespace io
{

template &lt; std::size_t N, typename Ch, class Tr = ::std::char_traits&lt;Ch&gt; &gt;
    class basic_array_streambuf;

template &lt; std::size_t N, typename Ch, class Tr = ::std::char_traits&lt;Ch&gt; &gt;
    class basic_array_istream;
template &lt; std::size_t N, typename Ch, class Tr = ::std::char_traits&lt;Ch&gt; &gt;
    class basic_array_ostream;
template &lt; std::size_t N, typename Ch, class Tr = ::std::char_traits&lt;Ch&gt; &gt;
    class basic_array_stream;

}
}
</pre></blockquote>

<h2><a name="array_sb">Array-based Stream Buffer Class Template</a></h2>

<p>The <code>boost::io::basic_array_streambuf</code> acts like a
<code>std::basic_streambuf</code>, except that its virtual buffering
array is mapped to a compile-time-sized array that is stored in the
stream buffer.</p>

<blockquote><pre>
#include &lt;cstddef&gt;    <i>// for std::size_t</i>
#include &lt;ios&gt;        <i>// for std::streamsize</i>
#include &lt;streambuf&gt;  <i>// for std::basic_streambuf</i>

template &lt; std::size_t N, typename Ch, class Tr &gt;
class boost::io::basic_array_streambuf
    : public std::basic_streambuf&lt;Ch, Tr&gt;
{
public:
    // Template arguments
    static  std::size_t const  array_size = N;

    typedef Ch  char_type;
    typedef Tr  traits_type;

    // Other types
    typedef typename Tr::int_type  int_type;
    typedef typename Tr::pos_type  pos_type;
    typedef typename Tr::off_type  off_type;

    // Constructors
    basic_array_streambuf();
    basic_array_streambuf( basic_array_streambuf const &amp;c );
    basic_array_streambuf( char_type const *b, char_type const *e );

    template &lt; typename InIter &gt;
        basic_array_streambuf( InIter b, InIter e );

    // Accessors
    char_type *  array_begin();
    char_type *  array_end();

    char_type const *  array_begin() const;
    char_type const *  array_end() const;

    std::streamsize  characters_written() const;
    std::streamsize  characters_read() const;

};
</pre></blockquote>

<p>The value-based template argument <var>N</var> represents the size of
the internal buffering array.  The type-based template arguments
<var>Ch</var> and <var>Tr</var> represent the character type and
character-traits type used for the stream buffer, respectively.  The
character type is the array's element type.</p>

<h3><a name="m_types">Member Types</a></h3>

<dl>
	<dt><code>char_type</code>
	<dd>a synonym for the stream buffer's character type

	<dt><code>traits_type</code>
	<dd>a synonym for the stream buffer's character-traits type

	<dt><code>int_type</code>
	<dd>a synonym for the stream buffer's character with end-of-file type

	<dt><code>pos_type</code>
	<dd>a synonym for the stream buffer's position type

	<dt><code>off_type</code>
	<dd>a synonym for the stream buffer's offset type
</dl>

<h3><a name="m_ctr">Constructors</a></h3>

<p><strong>Note 1:</strong> the automatically-defined destructor is used.</p>

<p><strong>Note 2:</strong> all the constructors set the bounds of the get
and put areas to the bounds of the internal array.  The place-marking pointers
for the get and put areas are set to the beginning of the internal array.</p>

<dl>
	<dt><code>basic_array_streambuf();</code>
	<dd>
		<strong>Effects:</strong> besides the bounds setting,
			all elements of the internal array are set to
                        the default value of the elements' type

	<dt><code>basic_array_streambuf( basic_array_streambuf const &amp;c );</code>
	<dd>
		<strong>Effects:</strong> default-constructs the base class
			subobject; copies the locale information from <var>c</var>;
                        copies the element values in <var>c</var>'s internal
                        array to the new object's internal array and sets the
                        bounds
	<dt><code>basic_array_streambuf( char_type const *b, char_type const *e );</code>
	<dd>
		<strong>Effects:</strong> besides the bounds setting,
			copies the values of the array-segment between <var>b</var>
			and <var>e</var> to the internal array
	<dt><code>template &lt; typename InIter &gt;
        	basic_array_streambuf( InIter b, InIter e );</code>
	<dd>
		<strong>Effects:</strong> besides the bounds setting,
			copies the values of the sequence between <var>b</var> and
			<var>e</var> to the internal array
</dl>

<h3><a name="m_observe">Observer Member Functions</a></h3>

<dl>
    <dt><code>char_type *  array_begin();</code>
	<dd>
		<strong>Returns:</strong> a pointer to the first element of
			the internal array<br>
		<strong>Rationale:</strong> useful to initialize or read the
			internal array

    <dt><code>char_type *  array_end();</code>
	<dd>
		<strong>Returns:</strong> a pointer to the one-past-the-end
			element of the internal array<br>
		<strong>Rationale:</strong> useful to initialize or read the
			internal array

    <dt><code>char_type const *  array_begin() const;</code>
	<dd>
		<strong>Returns:</strong> a pointer to the first element of
			the internal array<br>
		<strong>Rationale:</strong> similar to the
			non-<code>const</code> version

    <dt><code>char_type const *  array_end() const;</code>
	<dd>
		<strong>Returns:</strong> a pointer to the one-past-the-end
			element of the internal array<br>
		<strong>Rationale:</strong> similar to the
			non-<code>const</code> version

    <dt><code>std::streamsize  characters_written() const;</code>
	<dd>
		<strong>Returns:</strong> the current number of characters
			valid in the put area<br>
		<strong>Rationale:</strong> required to analyze just the
			written-to portion of the internal array

    <dt><code>std::streamsize  characters_read() const;</code>
	<dd>
		<strong>Returns:</strong> the current number of characters
			valid in the get area<br>
		<strong>Rationale:</strong> required to analyze just the
			read-from portion of the internal array
</dl>

<h3><a name="m_obj">Member Objects</a></h3>

<dl>
	<dt><code>static std::size_t const array_size;</code>
	<dd>a (compile-time) constant for the internal array's element count
</dl>

<h2><a name="array_s">Array-based Stream Class Templates</a></h2>

<p>The <code>boost::io::basic_array_istream</code>,
<code>boost::io::basic_array_ostream</code>, and
<code>boost::io::basic_array_stream</code> class templates are stream
classes that use an internal <code>basic_array_streambuf</code> object. 
They are implemented with the <a
href="streambuf_wrapping.html">stream-buffer-wrapping stream base
library</a>.  (Do the appropriate substitutions for <var>stream</var>.)

<blockquote><pre>
#include &lt;boost/io/streambuf_wrapping.hpp&gt;

template &lt; std::size_t N, typename Ch, class Tr &gt;
class boost::io::basic_array_<var>stream</var>
    : public boost::io::basic_wrapping_<var>stream</var>&lt;
       boost::io::basic_array_streambuf&lt;N, Ch, Tr&gt; &gt;
{
public:
    // Template arguments
    static  std::size_t const  array_size = N;

    typedef Ch  char_type;
    typedef Tr  traits_type;

    // Other types
    typedef typename Tr::int_type  int_type;
    typedef typename Tr::pos_type  pos_type;
    typedef typename Tr::off_type  off_type;

    // Constructors (forwarded to the internal streambuf)
    basic_array_<var>stream</var>();
    basic_array_<var>stream</var>( char_type const *b, char_type const *e );

    template &lt; typename InIter &gt;
        basic_array_<var>stream</var>( InIter b, InIter e );

    // Accessors (forwarded to the internal streambuf)
    char_type *  array_begin();
    char_type *  array_end();

    char_type const *  array_begin() const;
    char_type const *  array_end() const;

};
</pre></blockquote>

<h2><a name="refer">References</a></h2>

<ul>
	<li>The array-based streams library header itself: <cite><a
		href="../../../boost/io/array_stream.hpp">boost/io/array_stream.
		hpp</a></cite></li>
	<li>Some test/example code: <cite><a
		href="../test/array_stream_test.cpp">array_stream_test.cpp</a></
		cite></li>
</ul>

<h2><a name="credits">Credits</a></h2>

<h3><a name="contributors">Contributors</a></h3>

<dl>
	<dt><a href="../../../people/daryle_walker.html">Daryle Walker</a>
	<dd>Started the library.  Contributed the initial versions of the
		array-based stream and stream-buffer class templates.
</dl>

<h3><a name="history">History</a></h3>

<dl>
	<dt>11 Nov 2002, Daryle Walker
	<dd>Initial version
</dl>

<hr>

<p>Revised: 8 June 2003</p>

<p>Copyright &copy; Daryle Walker 2003.  Permission to copy, use,
modify, sell and distribute this document is granted provided this
copyright notice appears in all copies.  This document is provided
&quot;as is&quot; without express or implied warranty, and with no claim
as to its suitability for any purpose.</p>
</body>
</html>
