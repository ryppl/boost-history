<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Boost.Move Library : Header &quot;boost/move.hpp&quot;</title>
<meta content="Eric Friedman, mailto:ebf@users.sourceforge.net" name="author">
</head>

<body text="#000000" bgColor="#ffffff">

<h1>
	<img height="86" src="../../c++boost.gif" width="277" align="center" border="0">
	<a href="index.html">Boost.Move Library</a></h1>
<h2>Header "<a href="../../boost/move.hpp">boost/move.hpp</a>"</h2>
<ul>
	<li><a href="#synopsis">Synopsis</a></li>
	<li><code><a href="#move">move</a></code></li>
	<li><code><a href="#move_traits">move_traits</a></code></li>
	<li><code><a href="#is_moveable">is_moveable</a></code></li>
</ul>
<hr>
<h2><a name="synopsis">Synopsis</a></h2>
<p>Dependencies and library features defined in <code>&quot;<a href="../../boost/move.hpp">boost/move.hpp</a>&quot;</code>: </p>
  <blockquote><pre>namespace boost
{
    template &lt;typename T&gt;
      T &amp; <a href="#move">move</a>(void * destination, T &amp; source);

    template &lt;typename T&gt;
      struct <a href="#move_traits">move_traits</a>;

    template &lt;typename T&gt;
      struct <a href="#is_moveable">is_moveable</a>;
}
</pre></blockquote>
<p>Test harness defined in <code>&quot;<a href="move_test.cpp">move_test.cpp</a>&quot;</code>.</p>
<hr>
<h2><code><a name="move">move</a></code></h2>
<blockquote>
  <pre>template &lt;typename T&gt;
  T &amp; move(void * destination, T &amp; source);</pre>
</blockquote>
<p>Non-throwing relocation of <code>source</code> to the storage indicated by <code>destination</code> 
-- effectively, <code><a href="#move_traits">move_traits</a>&lt;T&gt;::move(destination, source)</code>. Returns a reference to the relocated 
object.</p>
<p>Preconditions:</p>
<ul>
  <li><code>is_moveable&lt;T&gt;::value</code> must evaluate to <code>true</code>.</li>
  <li><code>destination</code> must point to empty storage of proper size and alignment for an object 
  of type <code>T</code>.</li>
</ul>
<hr>
<h2><a name="move_traits"><code>move_traits</code></a></h2>
<p><i>Canonical structure is as follows:</i></p>
<blockquote><pre>template &lt;typename T&gt;
struct move_traits
{
    static void move(void * destination, T &amp; source);
};</pre></blockquote>
<p>To qualify as a valid specialization for type <code>T</code>, <code>move_traits&lt;T&gt;::move</code> must execute a non-throwing 
relocation of source to the storage indicated by destination.</p>
<p>Notes:</p>
<ul>
  <li><a name="move_traits-default">Inclusion of <code>&quot;boost/move.hpp&quot;</code> automatically provides</a> 
  an appropriately-defined, default implementation of <code>move_traits</code> 
for the following:</li>
  <ul>
  	<li>all types <code>T</code> satisfying the <code>has_trivial_copy&lt;T&gt;</code> <a href="../type_traits/index.htm#properties">type traits predicate</a> 
    (includes all primitive and POD types);</li>
  	<li>all types <code>T</code> satisfying the <code>has_nothrow_copy&lt;T&gt;</code> type traits predicate;</li>
  	<li>all types <code>T</code> satisfying <em>both</em> the <code>has_nothrow_constructor&lt;T&gt;</code> <em>and </em>
    <code>has_nothrow_assign&lt;T&gt;</code> type traits predicates; and</li>
  	<li>all types <code>T</code> satisfying <em>both</em> the <code>has_nothrow_constructor&lt;T&gt;</code> <em>and</em> 
    <code>has_nothrow_swap&lt;T&gt;</code> type traits predicates.</li>
  </ul>
  <li>[<b>Under development</b>: Support for additional types is optionally provided by the <code>&quot;boost/move/move_XXX.hpp&quot;</code> header series.]</li>
</ul>
<p>Preconditions:</p>
<ul>
  <li><code>destination</code> must point to empty storage of proper size and alignment for 
  an object of type <code>T</code>.</li>
</ul>
<hr>
<h2><a name="is_moveable"><code>is_moveable</code></a></h2>
<blockquote><pre>template &lt;typename T&gt;
struct is_moveable
{
    static const bool value = <b>/* implementation-defined */</b>;

    typedef is_moveable type; // <i>NOTE: useable as MPL predicate</i>
};</pre></blockquote>
<p>For any specified type <code>T</code>, <code>is_moveable&lt;T&gt;::value</code> exposes a boolean value 
indicating whether the following expression, given an object <code>x</code> of type <code>T</code> and a pointer <code>p</code>, is 
valid:</p>
<blockquote><pre><a href="#move">move</a>(p,x);</pre></blockquote
<hr>
<p>Notes:</p>
<ul>
  <li>Specialization of <code>is_moveable</code> is <em>not</em> required under any 
  circumstance.</li>
</ul>
<hr>
<block
<hr>
<div align="right">
  <small><i>© Copyright Eric Friedman, 2002</i></small>
  <p><a href="index.html">Back to library index</a></p>
</div>

</body>

</html>