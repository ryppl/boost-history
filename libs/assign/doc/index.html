<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
  <title>Assignment Library</title>
  <meta content="Thorsten, mailto:nesotto@cs.auc.dk" name="author">
</head>

<body text="#000000" bgcolor="#ffffff">

  <table border="0" width="799" height="134">
    <tr>
      <td width="288" height="134"><img id="IMG1" src="cboost.gif"
        align="middle" border="0" width="277" height="86"></td>
      <td width="1152" height="134">
        <h1 align="center">Assignment Library</h1>
      </td>
    </tr>
  </table>
  <ul>
    <li><a href="#intro">Introduction</a>
    <li>
      <p align="left">
        <a href="#reference">Reference</a>
      <ul>
        <li><a href="#stl">Standard containers</a></li>
        <li><a href="#array"><code>boost::array</code></a></li>
        <!--<li><a href="#graph"><code>boost::graph</code></a></li>-->
        <!--<li><a href="#multi_array"><code>boost::multi_array</code></a></li>-->
        <li><a href="#ublas"><code>boost::ublas</code></a></li>   
        <li><a href="#semantics">Semantics of functions and overloaded operators</a>
       <li><a href="#insert_assigner">Class <code>insert_assigner</code></a></li> 
            <li><a href="#fixed_assigner">Class <code>fixed_sized_assigner</code></a></li> </ul>     
    <li><a href="#extensions">Extensions</a></li>   
    <ul>
       <li><a href="#iterator_insert">Function <code>make_iterator_insertion()</code></a></li> </ul>
    <li><a href="#exceptions">Exceptions</a>
        <ul>
        <li><a href="#assignment_exception">Class <code>assignment_exception</code></a></li> </ul> </li>
    <li><a href="#portability">Portability</a></li>
    <!--<li><a href="#performance">Performance</a></li>-->
    <li><a href="#ref">References</a></li>
  </ul>
  
  <hr>
  
  <h2><a name="intro">Introduction</a></h2>
  <p>
  <i>There appear to be few practical uses of <code>operator,()</code></i>.
  <!-- p. 247 -->
  <br><b>Bjarne Stroustrup</b>, The Design and Evolution of C++
  </p>
  <p>
    The purpose of this library is to make easy to fill containers with 
    constant data by overloading <code>operator,()</code> and 
<code>operator()()</code>. This is particularly useful in
learning, testing, and prototyping situations, but can also be handy otherwise. 
  The library comes with predefined operators for the standard library
  and some of the libraries from boost. It also gives access to a 
  few classes that makes it simple to extend the functionality to
  new handle new container types. Below are given some examples.
  </p>
  <p>
    To fill a vector with values you write   
    <pre>
    #include &ltboost/assign/stl.hpp&gt
    #include &ltvector&gt
    using namespace std;
    using namespace boost::assignment;
    ...
    {
        vector&ltint&gt values;  
        values += 1,2,3,4,5,6,7,8,9;
    }
    </pre>
   </p> 
   <p>
   To fill a map with pairs of values you write
   <pre>
    #include &ltboost/assign/stl.hpp&gt
    #include &ltvector&gt
    using namespace std;
    using namespace boost::assignment;
    ...
    {
        map&ltconst char*,int&gt months;  
        assign( months )
    	    ( "january",   31 )( "february", 28 )
    	    ( "march",     31 )( "april",    30 )
    	    ( "may",       31 )( "june",     30 )
    	    ( "july",      31 )( "august",   31 )
    	    ( "september", 30 )( "october",  31 )
    	    ( "november",  30 )( "december", 31 );
    }
   </pre> 
  </p>
  <p>
  Assume you have a class with a constructor that takes several arguments
  and want to fill a vector with objects of that type. This can be done
  like this:
  <pre>
    #include &ltboost/assign/stl.hpp&gt
    #include &ltvector&gt
    using namespace std;
    using namespace boost::assignment;
    ...
    struct five
    {
        five( int, int, int, int, int ) { }
        five( const string&, const string&, const string&,  
	          const string&, const string& ) { }
    };
    ...
    {
        vector&ltfive&gt my_vector;   
        assign( my_vector )(1,2,3,4,5)("1","2","3","4","5")(6,7,8,9,10);
    }
  </pre>
   Now <code>my_vector</code> holds three objects constructed with one of the 
   three lists of arguments, respectively.
  </p>
   
  <h2><a name="reference">Reference</a></h2>
  <p>
  #include <code>&ltboost/assign.hpp&gt</code>
  </p>
  <p>
    This section will describe how to use the library. At the end of this 
    section is an overview of the semantics of the functions and operators.
    If you plan to extend the functionality of this library, you should
    stick to the same samantics.
    Examples showing the basic usage of the library can be found in the 
    <code>libs/assign/test</code> directory.  
  </p>
  <p>
  It is worth noticing the way the library is implemented.
  A function or overloaded operator returns an object which is 
  responsible for the insertion or the assignment. The object does
  the insertion or assignment by overloading <code>operator,()</code>
  and <code>operator()()</code>. Often overloading of 
  <code>operator,()</code> is discouraged because it can lead to suprising
  results, but the approach taken in this library is safe since the
  user never deals with objects that have overloaded <code>operator,()</code>
  directly.
  </p>
  <p>
  Most of the code in this document use <code>int</code> in the examples, 
  but of course it works for arbitrary types as they constructible, copy 
  constructible and assignable. Each section shows you which header to
  include to use the library. Everything is put in namespace 
  <code>boost::assigment</code>. </p>
  <h3><a name="stl">Standard containers </a></h3>
  <p>
  <code>#include &ltboost/assign/stl.hpp&gt</code>
  </p>
  <p>
  For each of the standard containers (including container adapters)
  one can do the following:
  <pre>
  {
      container<int> c;
      c += 1,2,3,4,5,6;
      insert( c )(7)(8)(9);
      assign( c )(1)(2)(3)(4);
  }
  </pre>
  Both <code>operator+=()</code> and <code>insert()</code> returns an object 
  that can insert elements at the end of the container. <code>assign()</code> 
  does the same, but clears
  the container first. If the contained objects are cubersome to construct,
  it is preferable to use the <code>operator()()</code> to insert elements.
  </p>

  <h3><a name="array"><code>boost::array</code></a></h3>
  <p>
  <code>#include &ltboost/assign/array.hpp&gt</code>
  </p>
  The <code>array</code> template in boost can be filled with values like this:
  <pre>
      boost::array&ltint,6&gt my_array;
      my_array << 1,2,3,4,5,6;    
      assign_all( my_array )(1)(2)(3)(4)(5)(6);
  </pre>
  This is easier when the <code>array</code> template is used inside a class, or 
  when your compiler does not support initilization for the <code>array</code> 
  template. Both <code>operator<<()</code> and <code>assign_all()</code> will
  throw an <a href="#exception"> <code>assignment_exception</code></a> if
  too few values are specified or is one tries to write past the end of the 
  end. This way it is impossible to have an <code>array</code> with undefined 
  elements.

  <h3><a name="ublas"><code>boost::ublas</code></a></h3>   
  <p>
  <code>#include &ltboost/assign/ublas.hpp&gt</code>
  </p>
  <p>
  It is possible to use <code>assign_all()</code> or <code>operator<<()</code> 
  with both vectors and matrices from <code>boost::ublas</code>. This
  example shows how it is done:
  </p>
  <pre>
    using namespace std;
    namespace bnu = boost::numeric::ublas;
    using namespace boost::assignment;
	
    try
    {
        bnu::vector<double>  v( 3 );
        v << 1,2,3; 
        
        bnu::matrix<int>     m( 3, 3 );
        m << 1,2,3,
             4,5,6,
             7,8,9;
        
        //
        // This needs to be remedied or documented.
        //    
        bnu::matrix<double, bnu::column_major> m2( 3, 3 );
        m2 << 1,2,3,
              4,5,6,
              7,8,9;
        
        cout << v << endl <<  m << endl << m2 << endl;
        
        bnu::triangular_matrix<double, bnu::lower> ml (3, 3);
        ml << 1,
              2,3,
              4,5,6;
        	
        bnu::triangular_matrix<double, bnu::upper> mu (3, 3);
        mu << 1,2,3,
              4,5,
              6;
        	
        cout << ml << endl << mu << endl;
        
        bnu::symmetric_matrix<double, bnu::lower> msl (3, 3);
        msl << 0, 
               2, 0,
               3, 4, 0; 
        
        bnu::symmetric_matrix<double, bnu::upper> msu (3, 3);
        msu << 0, 2, 3,
               0, 4,
               0; 
        
        cout << msl << endl << msu << endl;
   }
  </pre>
     
  <h3><a name="semantics">Semantics of functions and overloaded operators</a></h3>
  The functions <code>insert(),</code> and <code>assign()</code> and 
  <code>operator+=()</code> all return a instance of class 
  <a href="#insert_assigner"><code>insert_assigner</code></a>. The function
  <code>assign_all()</code> and <code>operator<<()</code> both return an 
   instance of class 
   <a href="#fixed_size_assigner"><code>fixed_size_assigner</code></a>.
   
   <ul>
    <li><code>operator+=()</code></li> The default version from  
      <code>&ltboost/assign/insert_assigner.hpp&gt</code> is:
    <pre>
    template&lt typename C &gt 
    inline insert_assigner&ltC&gt 
    operator+=( C& c, const typename C::value_type& v )
    {
        return insert_assigner&ltC&gt( c, v );
    }
    </pre>
      
    <li>function <code>insert()</code></a></li> 
    The default version from  
      <code>&ltboost/assign/insert_assigner.hpp&gt</code> is:
    <pre> 
    template< typename C >
    inline insert_assigner&ltC&gt 
    insert( C& c )
    {
        return insert_assigner&ltC&gt( c );
    }
    </pre>
      
    <li>function <code>assign()</code></a></li>
           The default version from  
      <code>&ltboost/assign/insert_assigner.hpp&gt</code> is:

    <pre>
    template< typename C >
    inline insert_assigner&ltC&gt 
    assign( C& c )
    {
        c.clear();
        return insert_assigner&ltC&gt( c );
    }   
    </pre>   
       
    <li><code>operator<<()</code></li>  
           The default version from  
      <code>&ltboost/assign/fixed_size_assigner.hpp&gt</code> is:
    <pre>
    template< typename C >
    inline fixed_size_assigner< typename C::value_type, typename C::iterator>
    operator<<( C& c, typename C::value_type v )
    {
        return fixed_size_assigner< typename C::value_type,typename C::iterator>( c.begin(), c.end(), v ); 
    }
    </pre>       
       
    <li>function <code>assign_all()</code></a></li>     
           The default version from  
      <code>&ltboost/assign/fixed_size_assigner.hpp&gt</code> is:
    <pre>
    template< typename C >
    inline fixed_size_assigner< typename C::value_type, typename C::iterator>
    assign_all( C& c )
    {
        return fixed_size_assigner< typename C::value_type, typename C::iterator>( c.begin(), c.end() );
    }
    </pre>  
  </ul> 
  
  <h3><a name="insert_assigner">Class <code>insert_assigner</code></a></h3> 
  This class is responsible for inserting elements into standard containers. It 
  does so by calling <code>make_insertion()</code> from
  within <code>operator,()</code> and <code>operator()()</code>. The arguments 
  to <code>operator()()</code> will be passed to the constructor of 
  <code>Container::value_type</code>. 
  <p>
  <b>Synopsis:</b> (header <code>&ltboost/assign/insert_assigner.hpp&gt</code>)
  <pre>
  namespace boost
  {
    namespace assignment
    {
        template< typename Container, typename V = typename Container::value_type > 
        class insert_assigner
        {
        public:
            typedef V  value_type;
        public:
            explicit insert_assigner( C& c );
            insert_assigner( C& c, const value_type& v );
        public:
            insert_assigner& operator,( const value_type& v );
            insert_assigner& operator()( const value_type& v )
    
            template< typename T, typename T2 >
            insert_assigner& operator()( const T& t, const T2& t2 );
    
            // ... etc. up to 6 arguments
        };
     }
  }
  </pre>
  </p>
    
  <h3><a name="fixed_assigner">Class <code>fixed_sized_assigner</code></a></h3> 
  This class is responsible for inserting elements into fixed size containers, 
  that is, typically containers that use an array underneith. It does so by 
  using an input iterator from within <code>operator,()</code> and 
  <code>operator()()</code>. The arguments to <code>operator()()</code> will be 
passed to the constructor of <code>Container::value_type</code>. The destructor
 throws an <code>assignment_exception</code> if some elements in the range have 
 not
been assigned to wheres <code>operator,()</code> and <code>operator()()</code>
 throws if one tries to write past the end of the range.
<p>
<b>Synopsis:</b> (header <code>&ltboost/assign/fixed_size_assigner.hpp&gt</code>) 
  <pre>
  namespace boost
  {
    namespace assignment
    {    
        template< typename ValueType, typename InputIterator >
        class fixed_size_assigner
        {
        public:
            typedef ValueType      value_type;
            typedef InputIterator  iterator;
        public:
            fixed_size_assigner( const iterator& begin, const iterator& end );
            fixed_size_assigner( const iterator& begin, const iterator& end,
                                 const value_type& v ); 
            fixed_size_assigner( const fixed_size_assigner& r ); 
            ~fixed_size_assigner(); // might throw 
        public:
            fixed_size_assigner& operator,( const value_type& v );  // might throw 
            fixed_size_assigner& operator()( const value_type& v ); // might throw 
            template< typename T, typename T2 >
            insert_assigner& operator()( const T& t, const T2& t2 ); // might throw 
            
            // ... etc. up to 6 arguments
        };
     }   
  }
  </pre>
  <h2><a name="extensions">Extensions</a></h2> 
  It is very simple to make the library work with new classes. If you
  have a standard compliant container, you do not have to do anything.
  If not, you might need to overload one or two functions:
  <ul>
      <li> If your container does not have a <code>value_type</code> type,
           you need to specialize the functions that returns the
           inserter/assigner object.
      <li> If your container does not have an <code>iterator</code> type,
           you need to specialize <code>assign_all()</code> and 
          <code>operator<<()</code>. 
      <li> If you type does not work with the default versions of
           <code>make_insertion()</code> then you need to
           specialize those too.
  </ul>

  <h3><a name="iterator_insert">Function <code>make_insertion()</code></a></h3>
  The default version from   <code>&ltboost/assign/make_insertion.hpp&gt</code> is: <pre>
      template< typename Container, typename Value >
      inline void make_insertion( Container& c, const Value& v )
      {
          c.insert( c.end(), v );
      }
  </pre>
      
  <h2><a name="exceptions">Exceptions</a></h2>
  The exception guarantees by the library is the same as guarantee as the 
  underlying container. For standard containers this means that the strong 
  guarantee is give for a single insertions and that the basic guarantee is 
  given for many insertions (provided that the user supplied type gives the 
  basic guarantee). The same holds for fixed size containers, but if the
  assignment is <i>inadequate</i>, that is, if there are two few or too many 
  elements inserted, then an exception is thrown.
  
  <h3><a name="assignment_exception">Class 
  <code>assignment_exception</code></a></h3>
  <pre>
  namespace boost 
  {
    namespace assignment
    {
        class assignment_exception : public std::exception
        {
        public:
        	explicit assignment_exception( const char* what ); 
         	virtual const char* what() const throw();
        };
    }   
  }
  </pre> 
   The exception is thrown by
  the <code>fixed_size_assigner</code> object returned from 
  <code>assign_all()</code> or <code>operator<<()</code> when the user
  is trying to write past the end of the data or when some elements have been
  left unassigned.
  
  <p>

  </p>
  <h2><a name="portability">Portability</a></h2>
  <p>
    Library has been successfully compiled and tested with MVC++ 6.0,
    MVC++ 7.0, MVC++ 7.1, GCC 3.2 (under Cygwin).
  </p>
  <p>
    There are known limitation on platforms not supporting partial template
    specialization. 
  </p>
  <h2><a name="rationale">History and Rationale</a></h2>
  <p>
  The idea for an initialization library is not new . The functionality of this 
  library resembles Leor Zolman's STL Container Initialization Library a great 
  deal, but it does not rely on string passing to achieve its goals. 
   
  The  
  The library is non-intrusive and puts only a minimum of requirements 
  on its supported classes.
 Overloading operator comma is sometimes viewed as a bad practice <a 
href=#meyers>[1]</A>. However, it has been done
  with success in eg. the Generative Matrix Computation Library  and Blitz to initialize matrices 
      (see <a href=#gmcl>[2]</A>) and <a href=#blitz>[3]</A>). The 
Initialization Library overloads
      the comma operator in a safe manner by letting free standing functions
 return an object that is responsible for the initialization. Therefore it takes 
explicit
      action from the programmer to begin using the overloaded <code>operator,()</CODE>.
      
    
  </p>
  <h2><a name="ref">References</a></h2>
  <p>
  <ol>
      <li> <a name="meyers">     Scott. Meyers, "More Effective C++", Item 7, Addison Wesley, 1996       
      <li> <a name="gmcl">       K. Czarnecki and U.W. Eisenecker, "Generative programming", Addison-Wesley, 2000        
      <li> <a name="blitz">      <a href=http://www.oonumerics.org/blitz/> http://www.oonumerics.org/blitz/ </A>     
 </OL>
  </p>
  <hr>
  <p>
    (C) Copyright Thorsten Ottosen 2003 (nesotto@cs.auc.dk). Permission to copy, 
    use, modify, sell and distribute this software is granted provided this 
    copyright notice appears
    in all copies. This software is provided &quot;as is&quot; without express
    or implied warranty, and with no claim as to its suitability for any
    purpose.
  </p>

</body>

</html>
