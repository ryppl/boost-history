<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
  <title>Assignment Library</title>
  <meta content="Thorsten, mailto:nesotto@cs.auc.dk" name="author">
</head>

<body text="#000000" bgcolor="#ffffff">

  <table border="0" width="799" height="134">
    <tr>
      <td width="288" height="134"><img id="IMG1" src="cboost.gif"
        align="middle" border="0" width="277" height="86"></td>
      <td width="1152" height="134">
        <h1 align="center">Assignment Library</h1>
      </td>
    </tr>
  </table>
  <ul>
    <li><a href="#intro">Introduction</a>
    <li>
      <p align="left">
        <a href="#reference">Reference</a>
      <ul>
        <li><a href="#stl">Standard containers</a></li>
        <li><a href="#array"><code>boost::array</code></a></li>
        <!--<li><a href="#graph"><code>boost::graph</code></a></li>-->
        <li><a href="#multi_array"><code>boost::multi_array</code></a></li>
        <li><a href="#ublas"><code>boost::ublas</code></a></li>   
        <li><a href="#operator_plus"><code>operator+=()</code></a>  
        <li><a href="#operator_pipe"><code>operator<<()</code></a>  
        <li><a href="#assign"><code>function insert()</code></a></li>    
        <li><a href="#assign"><code>function assign()</code></a></li>
        <li><a href="#assign_all"><code>function assign_all()</code></a></li>     
      </ul>     
    <li><a href="#extensions">Extensions</a></li>   
    <ul>
        <li><a href="#insert_assigner">class <code>insert_assigner</code></a></li>
        <li><a href="#fixed_assigner">class <code>fixed_sized_assigner</code></a></li> 
        <li><a href="#iterator_insert">function <code>make_iterator_insertion()</code></a></li>
        <li><a href="#iterator_assignment">function <code>make_iterator_assignment()</a> </li> </ul>       
    <li><a href="#exceptions">Exceptions</a>
        <ul>
        <li><a href="assignmenr_exception">class <code>assignment_exception</code></a></li> </ul>    
    </li>    
    <li><a href="#portability">Portability</a></li>
    <li><a href="#performance">Performance</a></li>
    <li><a href="#ack">Acknowledgements</a></li>
  </ul>
  
  <hr>
  
  <h2><a name="intro">Introduction</a></h2>
  <p>
    The purpose of this library is to make easy to fill containers with 
    constant data. This is particularly useful in learning, testing, and 
    prototyping situations, but can also be handy otherwise. 
  The library comes with predefined operators for the standard library
  and some of the libraries from boost. It also gives access to a 
  few classes that makes it simple to extend the functionality to
  new handle new container types. Below are given some examples.
  </p>
  <p>
    To fill a vector with values you write   
    <pre>
    #include &ltboost/assign/stl.hpp&gt
    #include &ltvector&gt
    using namespace std;
    using namespace boost::assignment;
    ...
    {
        vector&ltint&gt values;  
        values += 1,2,3,4,5,6,7,8,9;
    }
    </pre>
   </p> 
   <p>
   To fill a map with pairs of values you write
   <pre>
    #include &ltboost/assign/stl.hpp&gt
    #include &ltvector&gt
    using namespace std;
    using namespace boost::assignment;
    ...
    {
        map&ltconst char*,int&gt months;  
        assign( months )
    	    ( "january",   31 )( "february", 28 )
    	    ( "march",     31 )( "april",    30 )
    	    ( "may",       31 )( "june",     30 )
    	    ( "july",      31 )( "august",   31 )
    	    ( "september", 30 )( "october",  31 )
    	    ( "november",  30 )( "december", 31 );
    }
   </pre> 
  </p>
  <p>
  Assume you have a class with a constructor that takes several arguments
  and want to fill a vector with objects of that type. This can be done
  like this:
  <pre>
    #include &ltboost/assign/stl.hpp&gt
    #include &ltvector&gt
    using namespace std;
    using namespace boost::assignment;
    ...
    struct five
    {
        five( int, int, int, int, int ) { }
        five( const string&, const string&, const string&,  
	          const string&, const string& ) { }
    };
    ...
    {
        vector&ltfive&gt my_vector;   
        assign( my_vector )(1,2,3,4,5) ("1","2","3","4","5")(6,7,8,9,10);
    }
  </pre>
   Now <code>my_vector</code> holds three objects constructed with one of the 
   three lists of arguments, respectively.
 </p>
  <p>
  </p>
  <h2><a name="reference">Reference</a></h2>
  <p>
    The library is organized into several parts and each part deals with a
    different set of problems:
  </p>
  <ul>
    <li><a href="trim.html">Trim</a> facility provides algorithms for removing
      trailing and leading spaces from sequences.</li>
    <li><a href="conv.html">Case conversion</a> facility contains sequence
      variants for <code>std::toupper</code> and <code>std::tolower</code>
      algorithms.</li>
    <li>
      <p align="left">
        <a href="predicate.html">Predicates</a> facility includes some popular
        string related predicates like <code>starts_with</code>, <code>contains</code>
        and etc.</li>
    <li>
      <p align="left">
        <a href="find.html">Find</a> facility provides a set of algorithms for
        searching for a substring within a sequence.</li>
    <li>
      <p align="left">
        <a href="replace.html">Replace/Erase</a> facility contains various
        search and replace algorithms for sequences.</li>
    <li>
      <p align="left">
        <a href="classification.html">Classification</a> header contains a set
        of useful classification predicates which can be used with other
        algorithms in this library.</li>
  </ul>
  <p>
    Every component is provided in separate header. The library contains two
    cumulative headers for convenience. <a href="../../../boost/string_algo.hpp">&lt;boost/string_algo.hpp&gt;</a>
    contain all components except regex related ones. <a
    href="../../../boost/string_algo_regex.hpp">&lt;boost/string_algo_regex.hpp&gt;</a>
    includes also regex algorithms.
  </p>
  <h3><a name="examples">Examples</a></h3>
  <p>
    Examples showing the basic usage of the library can be found in the <code>libs/string_algo/example</code>
    directory. There is a separate file for the each part of the library. Follow
    the <a href="http://www.boost.org/tools/build/index.html">boost build
    guidelines</a> to build examples using the bjam. To succesfully build
    examples the Regex++ library is required.
  </p>
  <h2><a name="portability">Portability</a></h2>
  <p>
    Library has been successfully compiled and tested with Microsoft Visual C++
    7.0 and GCC 3.2.
  </p>
  <p>
    There are known limitation on platforms not supporting partial template
    specialization. Library depends on correctly implemented <code>std::iterator_traits</code>
    class. If a standard library provided with compiler is broken, the String
    Algorithm Library cannot function properly. Usually it implies, that
    primitive pointer iterators are not working with the library functions.
  </p>
  <h2><a name="rationale">Rationale</a></h2>
  <h3><a name="regex">Regular expressions</a></h3>
  <p>
    Regular expressions are essential part of text processing. For this reason,
    the library provides also regex variants of algorithms. In some places they
    copy a functionality from the Regex++ library. The goal was to provide
    complete unified interface for all relevant algorithms in the library.
  </p>
  <h2><a name="ack">Acknowledgements</a></h2>
  <p>
  </p>
  <hr>
  <p>
    (C) Copyright Thorsten Ottosen 2003. Permission to copy, use, modify, sell 
     and distribute this software is granted provided this copyright notice 
    appears
    in all copies. This software is provided &quot;as is&quot; without express
    or implied warranty, and with no claim as to its suitability for any
    purpose.
  </p>

</body>

</html>
