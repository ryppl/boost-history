<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title> Pointer Container Library </title><meta http-equiv="Content-Type"content="text/html; charset=iso-8859-1"></head> <body><table  ><tr  ><td  ><img src="cboost.gif" width="100%" border="0"></td><td  ><h1  >Pointer Container Library</h1></td></tr></table><ul  ><li  ><a href="#Introduction" >Introduction</a></li><li  ><a href="#Reference" >Reference</a></li><li  ><a href="#Examples" >Examples</a></li><li  ><a href="#Portability" >Portability</a></li><li  ><a href="#FAQ" >FAQ</a></li><li  ><a href="#References" >References</a></li></ul><hr size="1" ><h2  >Introduction</h2><a name="Introduction" ></a><p  >This library provides standard-like containers that are suitable
                     for storing pointers to both polymorphic and non-polymorphic objects.
                     For each of the standard containers there is a pointer container 
                     equivalent that takes ownership of the stored pointers in an exception 
                     safe manner. In this respect it is intended to solve 
                     the so-called <i  >polymorphic class problem.</i></p><p  >The advantages are <ul  ><li  >Exception-safe and fool proof pointer storage and manipulation.</li><li  >Exception-guarantees are generally much better than with standard containers (very often the strong guarantee)</li><li  >Notational convinience compared to the use of containers of smart pointers.</li><li  >Iterators are automatically indirected so the comparison operations can be kept
                                on object basis instead of making/adding pointer based variants.</li><li  >No memory-overhead as containers of smart_pointers can have.</li><li  >Usually faster than using containers of smart pointers.</li><li  >Provides an elegant solution to potential <code  >vector&lt; vector&lt;T&gt; &gt;</code> performance
                                problems; simply use <code  >ptr_vector&lt; vector&lt;T&gt; &gt;.</code><li  >Offers more explicit control of lifetime issues.</li><li  >Can be used for types that are neither Assignable nor CopyConstructible. </li></li></ul></p><p  >The disadvantages are: <ul  ><li  >Some standard algorithms like <code  >unique()</code> need special care when using them with raw pointers</li></ul></p><p  >Below is given a small example that show how the usage compares to a container of smart pointers:<pre  >
                       
    using namespace boost;
    using namespace std;
                       
    class Poly
    {
    public:
        virtual ~Poly() {}
        void foo() { doFoo(); }
    private:    
        virtual void doFoo() 
        {
            int i;
            ++i;
        }
    };
                                                             
    //
    // one doesn't need to introduce new names or live with long ones
    //                                                         
    typedef shared_ptr&lt;Poly&gt; PolyPtr;
    
    //
    // one doesn't need to write this anymore
    //                   
    struct PolyPtrOps 
    {
      void operator()( const PolyPtr & a )
        { a-&gt;foo(); }
    };
    
    int main()
    {
        enum { size = 2000000 };
        vector&lt;PolyPtr&gt;    svec   
        ptr_vector&lt;Poly&gt;   pvec;
        
        for( int i = 0; i &lt; size; ++i ) 
        {
            svec.push_back( PolyPtr( new Poly ) ); 
            pvec.push_back( new Poly );  // no extra syntax      
        }
                       
        for_each( svec.begin(), svec.end(), PolyPtrOps() );

        for_each( pvec.begin(), pvec.end(), mem_fun_ref( &Poly::foo ) );
     } </pre></p><hr size="1" ><h2  >Reference</h2><a name="Reference" ></a><p  >There are a few design decisions that will affect how the
                     classes are used. Besides these the classes are much like
                     normal standard containers and provides almost the same interface.
                     The new conventions are: </p><ul  ><li  ><i  >The containers are neither Copy-Constructible nor Assignable.</i> This is because cloning a lot of pointers can be a very expensive operation; instead functions are
                               provided to transfer ownership. If a 
                              deep-copy is needed anyway, every container has <code  >clone()</code> member function.</li><li  ><i  >Stored elements need not be CopyConstructible or Assignable, but 
                                for a subset of the operations they are required to be Clonable.</i> This is because most polymophic objects cannot be copied directly, 
                              but they can often be so by a use of a member function. Often it does not even make
                              sense to clone an object in which case a large subset of the operations are still workable.</li><li  ><i  >Whenever objects are inserted into a container, they are cloned before insertion. 
                                 Whenever pointers are inserted into a container, ownership is transferred to the container.</i> All containers take ownership of the stored pointers and therefore a cntainer needs to have its 
                               own copies. </li><li  ><i  >Ownership can be tranferred from a container on a per pointer basis.</i> This can of course also be convenient. Whenever it happens, an <code  >std::auto_ptr&lt;&gt;</code> is used to provide an exception-safe transfer. </li><li  ><i  >Ownership can be transferred from a container to another container on a per iterator range basis.</i> This makes it possible to exchange data safely between different pointer containers
                               without cloning the objects again. </li></ul><p  >The documentation is divided into a common section and an explanation for each container. 
                        The so-called "pseudo class" sections
                        shows the interface that some or all of the classes have in common and the indvisual parts shows the interface
                        that is only part of some of the individual classes:</p><ul  ><li  ><a href="#Pseudo class <code  >ptr_container&lt;&gt;</code>" >Pseudo class <code  >ptr_container&lt;&gt;</code></a></li><li  ><a href="# Class <code  >ptr_deque&lt;&gt;</code>" > Class <code  >ptr_deque&lt;&gt;</code></a></li><li  ><a href="# Class <code  >ptr_list&lt;&gt;</code>" > Class <code  >ptr_list&lt;&gt;</code></a></li><li  ><a href="# Class <code  >ptr_vector&lt;&gt;</code>" > Class <code  >ptr_vector&lt;&gt;</code></a></li><li  ><a href="# Class <code  >ptr_set&lt;&gt;</code>" > Class <code  >ptr_set&lt;&gt;</code></a></li><li  ><a href="# Class <code  >ptr_map&lt;&gt;</code>" > Class <code  >ptr_map&lt;&gt;</code></a></li><li  ><a href="#Exception classes" >Exception classes</a></li></ul><p  >The recommended usage pattern of the container classes are the 
                same as the for normal standard containers.<code  >ptr_vector</code>, <code  >ptr_list</code> and <code  >ptr_deque</code> offer the programmer 
                different complexity tradeoffs and should be used accordingly. <code  >ptr_vector</code> is the type of sequence that should be used by default. <code  >ptr_list</code> should be used when there 
             are frequent insertions and deletions from the middle of the sequence <i  >and</i> if the
                 container is fairly large (eg. more than 100 elements). <code  >ptr_deque</code> is 
              the data structure of choice when most insertions and deletions take place at 
            the beginning or at the end of the sequence.  An associative container supports  
            unique keys if it may contain at most one element for each key.  Otherwise, it 
            supports equivalent keys. <code  >ptr_set</code> and <code  >ptr_map</code> support unique keys. 
                <code  >ptr_multiset</code> and <code  >ptr_multimap</code> support equivalent keys.</p><br><hr size="1" ><h2  >Pseudo class <code  >ptr_container&lt;&gt;</code></h2><a name="Pseudo class <code  >ptr_container&lt;&gt;</code>" ></a>This section describe all the common operations for all the pointer containers. If there are differences in
                 complexity or exception-safety, the differences will be stated under the documentation of the particular
                 container.<h3  >Synopsis:</h3><pre>             
namespace boost
{      
    template< typename T, typename Allocator = std::allocator< T* > >
    class ptr_container 
    {
    public: // typedefs
        typedef  T                                            value_type;
        typedef  T&                                           reference;
        typedef  const T&                                     const_reference;
        typedef  <b>implementation defined</b>                       iterator;
        typedef  <b>implementation defined</b>                       const_iterator;
        typedef  <b>implementation defined</b>                       difference_type; 
        typedef  <b>implementation defined</b>                       size_type;
        typedef  Allocator                                    allocator_type;
        typedef  typename Allocator::pointer                  pointer;
        typedef  typename Allocator::const_pointer            const_pointer; 
        typedef  std::reverse_iterator< iterator >            reverse_iterator;
        typedef  std::reverse_iterator< const_iterator >      const_reverse_iterator;
    
    public: // construct/copy/destroy
        explicit ptr_container( const allocator_type& = allocator_type() );
        ptr_container( size_type n, const_reference x, const allocator_type& = allocator_type() );
        ptr_container( auto_ptr< ptr_container > r );
        template< typename InputIterator >
        ptr_container( InputIterator first, InputIterator last, const allocator_type& = allocator_type() );
        ~ptr_container();
        void operator=( std::auto_ptr< ptr_container > r )  
        template< typename InputIterator >
        assign( InputIterator first, InputIterator last );
        assign( size_type n, const_reference u );
        allocator_type get_allocator() const;                                      
    
    public: // iterators
        iterator                begin();
        const_iterator          begin() const;
        iterator                end();
        const_iterator          end() const;
        reverse_iterator        rbegin();
        const_reverse_iterator  rbegin();
        reverse_iterator        rend();
        const_reverse_iterator  rend();
    
    public: // capacity
        size_type  size() const;
        size_type  max_size() const;
        void       resize( size_type sz, ptr_type = new value_type() );
        bool       empty() const;	
    
    public: // element access
        reference        front();
        const_reference  front() const;
        reference        back();
        const_reference  back() const;
    
    public: // modifiers
        void      push_back( T* x );
        void      push_back( const_reference x );
        void      pop_back();
        iterator  insert( iterator position, const_reference x );
        void      insert( iterator position, size_type n, ptr_type x );
        template< typename InputIterator >
        void      insert( iterator position, InputIterator first, InputIterator last ); 
        iterator  erase( iterator position );
        iterator  erase( iterator first, iterator last );
        void      swap( ptr_container& r );
        void      clear():
    
    public: // pointer container requirements
    
        std::auto_ptr< ptr_container >  clone() const;    
        std::auto_ptr< ptr_container >  release();
        std::auto_ptr< T >              release_back();
        std::auto_ptr< T >              release( iterator position );
    
    }; //  class 'ptr_container'
    
    template < typename T, typename Allocator >
    bool operator==( const ptr_container< T,Allocator >& x,
                 const ptr_container< T,Allocator >& y);
    
    template < typename T, typename Allocator >
    bool operator<( const ptr_container< T,Allocator >& x,
            const ptr_container< T,Allocator >& y);
    
    template < typename T, typename Allocator >
    bool operator!=( const ptr_container< T,Allocator >& x,
                 const ptr_container< T,Allocator >& y);
    
    template < typename T, typename Allocator>
    bool operator>( const ptr_container< T,Allocator >& x,
            const ptr_container< T,Allocator >& y);
    
    template < typename T, typename Allocator>
    bool operator>=( const ptr_container< T,Allocator >& x,
                 const ptr_container< T,Allocator >& y);
    
    template < typename T, typename Allocator>
    bool operator<=( const ptr_container< T,Allocator >& x,
                 const ptr_container< T,Allocator >& y);
    
    template< typename T, typaname Allocator  >
    void swap( ptr_container< T,Allocator >& x, 
               ptr_container< T,Allocator >& y );
    
} // namespace 'boost'  
    </pre> <p  ><h3  >Semantics: <i  >construct/copy/destroy</i></h3></p><code  >explicit ptr_container( const allocator_type& = allocator_type() );</code><blockquote  ><p  ><b  >Effects: </b>Constructs an empty container</p><p  ><b  >Postconditions: </b><code  >size() == 0</code></p></blockquote><code  >ptr_container( size_type n, const_reference x, const allocator_type& = allocator_type() )</code><blockquote  ><p  ><b  >Effects: </b>Constructs a container with <code  >n</code> clones of <code  >x</code></p><p  ><b  >Postconditions: </b><code  >size() == n</code></p></blockquote><code  >explicit ptr_container( std::auto_ptr&lt; ptr_container &gt; r );</code><blockquote  ><p  ><b  >Effects: </b>Constructs a container by taking ownership of the supplied pointers</p></blockquote><pre  >template&lt; typename InputIterator &gt;
    ptr_container( InputIterator first, InputIterator last, const allocator_type& = allocator_type() ); </pre><blockquote  ><p  ><b  >Requirements: </b><code  >(first,last]</code> is a valid range</p><p  ><b  >Effects: </b>Constructs a container with a cloned range of <code  >(first,last]</code></p><p  ><b  >Postconditions: </b><code  >size() == std::distance( first, last )</code></p></blockquote><code  >~ptr_container();</code><blockquote  ><p  ><b  >Effects: </b>Deletes the stored pointers and then the container itself</p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >void operator=( std::auto_ptr&lt; ptr_container &gt; r );</code><blockquote  ><p  ><b  >Effects: </b>Deletes the stored pointers and then takes ownership of the supplied pointers</p><p  ><b  >Throws: </b>Nothing</p></blockquote><pre  >template&lt; typename InputIterator &gt;
    assign( InputIterator first, InputIterator last );</pre><blockquote  ><p  ><b  >Requirements: </b><code  >(first,last]</code> is a valid range</p><p  ><b  >Effects: </b><code  >clear(); insert( first, last );</code></p><p  ><b  >Postconditions: </b><code  >size() == std::distance( first, last )</code></p><p  ><b  >Exception safety: </b>strong guarantee</p></blockquote><code  >assign( size_type n, const_reference u )</code><blockquote  ><p  ><b  >Effects: </b><code  >clear(); insert( begin(), n, u );</code></p><p  ><b  >Postconditions: </b><code  >size() == n</code></p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><code  >allocator_type get_allocator() const</code><blockquote  ><p  ><b  >Effects: </b>Returns a copy of the allocator of the container object</p></blockquote><p  ><h3  >Semantics: <i  >iterators</i></h3></p><code  >iterator begin();</code><blockquote  ><p  ><b  >Effects: </b>Returns a mutable iterator with <code  >value_type T</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >const_iterator begin() const;</code><blockquote  ><p  ><b  >Effects: </b>Returns a non-mutable iterator with <code  >value_type T</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >iterator end();</code><blockquote  ><p  ><b  >Effects: </b>Returns a mutable iterator with <code  >value_type T</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >const_iterator end() const;</code><blockquote  ><p  ><b  >Effects: </b>Returns a non-mutable iterator with <code  >value_type T</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >iterator rbegin();</code><blockquote  ><p  ><b  >Effects: </b>Returns a mutable iterator with <code  >value_type T</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >const_iterator rbegin() const;</code><blockquote  ><p  ><b  >Effects: </b>Returns a non-mutable iterator with <code  >value_type T</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >iterator rend();</code><blockquote  ><p  ><b  >Effects: </b>Returns a mutable iterator with <code  >value_type T</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >const_iterator rend() const;</code><blockquote  ><p  ><b  >Effects: </b>Returns a non-mutable iterator with <code  >value_type T</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><p  ><h3  >Semantics: <i  >capacity</i></h3></p><code  >size_type size() const;</code><blockquote  ><p  ><b  >Effects: </b>Returns the number of stored elements</p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >size_type max_size() const;</code><blockquote  ><p  ><b  >Effects: </b>Returns the maximum number of stored elements</p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >bool empty() const;</code><blockquote  ><p  ><b  >Effects: </b>Returns whether the container is empty or not</p><p  ><b  >Throws: </b>Nothing</p></blockquote><p  ><h3  >Semantics: <i  >element access</i></h3></p><code  >reference front();</code><blockquote  ><p  ><b  >Effects: </b><code  >return *begin()</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >const_reference front() const;</code><blockquote  ><p  ><b  >Effects: </b><code  >return *begin()</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >reference back();</code><blockquote  ><p  ><b  >Effects: </b><code  >return *end()</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >const_reference back() const;</code><blockquote  ><p  ><b  >Effects: </b><code  >return *end()</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><p  ><h3  >Semantics: <i  >modifiers</i></h3></p><code  >void push_back( T* x );</code><blockquote  ><p  ><b  >Requirements: </b><code  >x</code> is heap-allocated and cannot be <code  >0</code></p><p  ><b  >Effects: </b>Inserts the pointer into container and takes ownership of it</p><p  ><b  >Throws: </b><code  >bad_pointer</code> if <code  >x</code> is <code  >0</code></p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><code  >void push_back( const_reference x );</code><blockquote  ><p  ><b  >Effects: </b><code  >push_back( make_clone( x ) );</code></p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><code  >void pop_back();</code><blockquote  ><p  ><b  >Effects: </b>Removes the last element in the container if it exists</p><p  ><b  >Postconditions: </b><code  >not empty()</code> implies <code  >size()</code> is one less</p><p  ><b  >Exception safety: </b>Nothrow guaarantee</p></blockquote><code  >iterator insert( iterator position, const_reference x );</code><blockquote  ><p  ><b  >Requirements: </b><code  >position</code> is a valid iterator from the container</p><p  ><b  >Effects: </b><code  >return insert( position, make_clone( x ) );</code></p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><code  >iterator insert( iterator position, ptr_type x );</code><blockquote  ><p  ><b  >Requirements: </b><code  >position</code> is a valid iterator from the container and <code  >x</code> is heap-allocated and cannot be <code  >0</code></p><p  ><b  >Effects: </b>Inserts <code  >x</code> before <code  >position</code> and returns an iterator pointing to it</p><p  ><b  >Throws: </b><code  >bad_pointer</code> if <code  >x</code> is <code  >0</code></p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><code  >void insert( iterator position, size_type n, const_reference x );</code><blockquote  ><p  ><b  >Requirements: </b><code  >position</code> is a valid iterator from the container</p><p  ><b  >Effects: </b>Inserts <code  >n</code> clones of <code  >x</code> before <code  >position</code> into the container </p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><pre  >template&lt; typename InputIterator &gt;
    void insert( iterator position, InputIterator first, InputIterator last );</pre><blockquote  ><p  ><b  >Requirements: </b><code  >position</code> is a valid iterator from the container</p><p  ><b  >Effects: </b>Inserts a cloned range before <code  >position</code></p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><code  >iterator erase( iterator position );</code><blockquote  ><p  ><b  >Requirements: </b><code  >position</code> is a valid iterator from the container</p><p  ><b  >Effects: </b>Removes the element defined by <code  >position</code> and returns an
                      iterator to the following element</p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >iterator erase( iterator first, iterator last );</code><blockquote  ><p  ><b  >Requirements: </b><code  >(first,last]</code> is a valid range</p><p  ><b  >Effects: </b>Removes the range of element defined by <code  >position</code> and returns an
                 iterator to the following element</p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >void swap( ptr_container& r );</code><blockquote  ><p  ><b  >Effects: </b>Swaps the content of the two containers</p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >void clear();</code><blockquote  ><p  ><b  >Effects: </b>Destroys all object of the container </p><p  ><b  >Postconditions: </b><code  >empty() == true</code></p><p  ><b  >Throws: </b>Nothing</p></blockquote><p  ><h3  >Semantics: <i  >pointer container requirements</i></h3></p><code  >std::auto_ptr&lt; ptr_container &gt;  clone() const;</code><blockquote  ><p  ><b  >Effects: </b>Returns a deep copy of the container</p><p  ><b  >Throws: </b><code  >std::bad_alloc</code> if there is not enough memory to make a clone of the container</p><p  ><b  >Complexity: </b>Linear</p></blockquote><code  >std::auto_ptr&lt; ptr_container &gt;  release();</code><blockquote  ><p  ><b  >Effects: </b>Releases ownership of the container. This is a useful way of returning
                 a container from a function.</p><p  ><b  >Postconditions: </b><code  >empty() == true</code></p><p  ><b  >Exception safety: </b>Strong guarantee</p><p  ><b  >Throws: </b><code  >std::bad_alloc</code> if the return value cannot be allocated</p></blockquote><code  >std::auto_ptr&lt; T &gt; release_back();</code><blockquote  ><p  ><b  >Requirements: </b><code  >not empty()</code></p><p  ><b  >Effects: </b>Releases ownership of the last pointer in the container</p><p  ><b  >Postconditions: </b><code  >size()</code> is one less </p><p  ><b  >Throws: </b><code  >bad_ptr_container_operation</code> if the container is empty</p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><code  >std::auto_ptr&lt; T &gt; release( iterator position );</code><blockquote  ><p  ><b  >Requirements: </b><code  >not empty()</code></p><p  ><b  >Effects: </b>Releases ownership of the pointer referred to by <code  >position</code></p><p  ><b  >Postconditions: </b><code  >size()</code> is one less </p><p  ><b  >Throws: </b><code  >bad_ptr_container_operation</code> if the container is empty</p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><hr size="1" ><h2  > Class <code  >ptr_deque&lt;&gt;</code></h2><a name=" Class <code  >ptr_deque&lt;&gt;</code>" ></a><h3  >Synopsis:</h3><pre>             
namespace boost
{
    template< typename T, typename Allocator = std::allocator< T* > >
    class ptr_deque 
    {
        //
        // reversible ptr_container requirements + 
        // 
        
    public: // element access
        reference        operator[]( size_type n );
        const_reference  operator[]( size_type n ) const;
        reference        at( size_type n );
        const_reference  at( size_type n ) const;
    
   public: // modifiers
        void                push_front( T* );
        void                push_front( const_reference x );
        void                pop_front();
        std::auto_ptr< T >  release_front(); 
    
    }; //  class 'ptr_deque'
    
} // namespace 'boost'  
    </pre> <p  ><h3  >Semantics: <i  >element access</i></h3></p><code  >reference operator[]( size_type n );</code><blockquote  ><p  >See description in ptr_vector::operator[]</p></blockquote><code  >const_reference operator[]( size_type n ) const;</code><blockquote  ><p  >See description in ptr_vector::operator[]</p></blockquote><code  >reference at( size_type n );</code><blockquote  ><p  >See description in ptr_vector::at()</p></blockquote><code  >const_reference at( size_type n );</code><blockquote  ><p  >See description in ptr_vector::at()</p></blockquote><p  ><h3  >Semantics: <i  >modifiers</i></h3></p><code  >void push_front( T* );</code><blockquote  ><p  ><b  >Requirements: </b><code  >x</code> is heap-allocated and cannot be <code  >0</code></p><p  ><b  >Effects: </b>Inserts the pointer into container and takes ownership of it</p><p  ><b  >Throws: </b><code  >bad_pointer</code> if <code  >x</code> is <code  >0</code></p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><code  >void push_front( const_reference x );</code><blockquote  ><p  ><b  >Effects: </b><code  >push_back( make_clone( x ) );</code></p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><code  >void pop_front()</code><blockquote  ><p  ><b  >Effects: </b>Removes the first element of the container if it exists</p><p  ><b  >Postconditions: </b><code  >not empty()</code> implies <code  >size()</code> is one less</p><p  ><b  >Exception safety: </b>Nothrow guarantee</p></blockquote><code  >std::auto_ptr&lt; T &gt; release_front();</code><blockquote  ><p  ><b  >Requirements: </b><code  >not empty()</code></p><p  ><b  >Effects: </b>Releases ownership of the first pointer in the container</p><p  ><b  >Postconditions: </b><code  >size()</code> is one less </p><p  ><b  >Throws: </b><code  >bad_ptr_container_operation</code> if the container is empty</p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><hr size="1" ><h2  > Class <code  >ptr_list&lt;&gt;</code></h2><a name=" Class <code  >ptr_list&lt;&gt;</code>" ></a><h3  >Synopsis:</h3><pre>             
namespace boost
{
template< typename T, typename Allocator = std::allocator< T* > >
class ptr_list 
{
    //
    // reversible ptr_container requirements + 
    // 

public: // modifiers
    void                push_front( T* );
    void                pop_front();
    std::auto_ptr< T >  release_front(); 

public: // list operations
    void  splice( iterator before, ptr_list& x );
    void  splice( iterator before, ptr_list& x, iterator i );
    void  splice( iterator before, ptr_list& x, iterator first, iterator last );
    
    // Q: are they really faster as member functions???    
    void  remove( const_reference value );                           
    template< typename Predicate > 
    void  remove_if( Predicate pred );                               
      
    void  unique();    
    template< typename BinaryPredicate >
    void  unique( BinaryPredicate binary_pred );                     
    
    void  merge( ptr_list& x ); 
    template< typename Compare > 
    void  merge( ptr_list& x, Compare comp );
    
    void  sort();    
    template< typename Compare > 
    void  sort( Compare comp );                             
    
    void  reverse();

}; //  class 'ptr_list'

} // namespace 'boost'  
</pre> <p  ><h3  >Semantics: <i  >modifiers</i></h3></p><code  >void push_front( T* );</code><blockquote  ><p  >See description in <code  >deque::push_front()</code></p></blockquote><code  >void pop_front()</code><blockquote  ><p  >See description in <code  >deque::pop_front()</code></p></blockquote><code  >std::auto_ptr&lt; T &gt; release_front();</code><blockquote  ><p  >See description in <code  >deque::release_front()</code></p></blockquote><hr size="1" ><h2  > Class <code  >ptr_vector&lt;&gt;</code></h2><a name=" Class <code  >ptr_vector&lt;&gt;</code>" ></a><h3  >Synopsis:</h3><pre>             
namespace boost
{
    template< typename T, typename Allocator = std::allocator< T* > >
    class ptr_vector 
    {
        //
        // reversible ptr_container requirements + 
        // 

    public: // capacity
        size_type  capacity() const;
        void       reserve( size_type n );
    
    public: // element access
        reference        operator[]( size_type n );
        const_reference  operator[]( size_type n ) const;
        reference        at( size_type n );
        const_reference  at( size_type n ) const;
        
    }; //  class 'ptr_vector'
    
} // namespace 'boost'  
    </pre> <p  ><h3  >Semantics: <i  >capacity</i></h3></p><code  >size_type capacity() const;</code><blockquote  ><p  ><b  >Effects: </b>Returns the size of the allocated buffer</p><p  ><b  >Throws: </b>Nothing</p></blockquote><code  >void resize( size_type sz, const_reference x );</code><blockquote  ><p  ><b  >Effects: </b><pre  >if ( sz &gt; size() )
    insert( end(), sz-size(), x );
    else if ( sz &lt; size() )
    erase( begin()+sz, end() );
    else
    ; //do nothing </pre></p><p  ><b  >Postconditions: </b><code  >size() == sz</code></p><p  ><b  >Exception safety: </b>Strong guarantee</p></blockquote><p  ><h3  >Semantics: <i  >element access</i></h3></p><code  >reference operator[]( size_type n );</code><blockquote  ><p  ><b  >Requirements: </b><code  >n &lt; size()</code></p><p  ><b  >Effects: </b>Returns a reference to the n'th element</p></blockquote><code  >const_reference operator[]( size_type n ) const;</code><blockquote  ><p  ><b  >Requirements: </b><code  >n &lt; size()</code></p><p  ><b  >Effects: </b>Returns a const reference to the n'th element</p></blockquote><code  >reference at( size_type n );</code><blockquote  ><p  ><b  >Requirements: </b><code  >n &lt; size()</code></p><p  ><b  >Effects: </b>Returns a reference to the n'th element</p><p  ><b  >Throws: </b><code  >std::out_of_range</code> if <code  >n &gt;=size()</code></p></blockquote><code  >const_reference at( size_type n );</code><blockquote  ><p  ><b  >Requirements: </b><code  >n &lt; size()</code></p><p  ><b  >Effects: </b>Returns a const reference to the n'th element</p><p  ><b  >Throws: </b><code  >std::out_of_range</code> if <code  >n &gt;= size()</code></p></blockquote><hr size="1" ><h2  > Class <code  >ptr_set&lt;&gt;</code></h2><a name=" Class <code  >ptr_set&lt;&gt;</code>" ></a><hr size="1" ><h2  > Class <code  >ptr_map&lt;&gt;</code></h2><a name=" Class <code  >ptr_map&lt;&gt;</code>" ></a><hr size="1" ><h2  >Exception classes</h2><a name="Exception classes" ></a><hr size="1" ><h2  >Examples</h2><a name="Examples" ></a><p  >Some examples are given in the accompanying test
                      files:</p><ul  ><li  > <a href="../test/incomplete_type_test.cpp" target="_self" ><code  >incomplete_type_test.cpp</code></a>  shows how to implement the Composite pattern.</li><li  > <a href="../test/associative_test_data.hpp" target="_self" ><code  >associative_test_data.hpp</code></a>  shows the common interface for all associative containers.</li><li  > <a href="../test/sequence_test_data.hpp" target="_self" ><code  >sequence_test_data.hpp</code></a>  shows the common interface for all sequences.</li></ul><hr size="1" ><h2  >Portability</h2><a name="Portability" ></a><p  >This library does not rely on any difficult template code, and so it should work
                        with most compilers---even the older onces.</p><p  >Most of the tests have been run successfully on these compilers:<ul  ><li  >vc7.1</li><li  >gcc3.3.1</li><li  >como4.3.3</li><li  >bcc6</li></ul></p><hr size="1" ><h2  >FAQ</h2><a name="FAQ" ></a><ol  ><p  ><i  >Since a pointer container is not Copy-Constructible and Assignable, I cannot 
                 put them into standard containers; what do I do?</i> Since they are Clonable, you simply put them in a pointer container.</p><p  ><i  >Calling <code  >assign()</code> is very costly and I do not really need to store
                  cloned objects; I merely need to overwrite the existing ones; what do I do?;</i> Call <code  >std::copy( first, last, c.begin() );.</code></p><p  ><i  >Why is there no equivalent of <code  >boost::array&lt;T,size&gt;</code> for storing pointers?</i> For heap-allocated pointers there would be little performance benefit of having such a class.</p><p  ><i  >Why does the classes have some mutating algorithms as member functions?</i> Some mutating algorithms are inherently unsafe and error-prone to use with pointers. These few
                 often-used algorithms are implemented so the user does not need to care about those pitfalls.</p><p  ><i  >Which mutating algorithms are safe to use with pointers?</i> Any mutating algorithm that moves elements around by swapping them. An important example is <code  >std::sort()</code>; examples of unsafe algorithms are <code  >std::unique()</code> and <code  >std::remove(). That is why these algorithms are provided as member functions. </code></p><p  ><i  >Why does <code  >ptr_map&lt;T&gt;::insert()/replace() </code> take two arguments (the key and the pointer) 
                   instead of one <code  >std::pair&lt;&gt;</code>? And why is the key passed by non-const reference? </i> This is the only way the function can be implemented in an exception-safe manner; since 
                  the copy-constructor of the key might throw, and since function arguments are not guaranteed to
                  be evaluated from left to right, we need to ensure that evaluating the first argument does not throw.
                  Passing the key as a reference achieves just that.</p><p  ><i  >When instantiating a ptr_container with a type <code  >T,</code> is <code  > T </code> then
                  allowed to be incomplete at that point? </i> Yes.</p><p  ><i  >Why are inserting member functions overloaded for both pointers and references?</i> Assuming only pointer arguments were allowed, the inexperienced programmer might forget
                 to call <code  >make_clone()</code> on an object. So the code would not compile. To fix it he
                 just takes the address of the object and now he is happy because the code compiles. So to avoid
                  that from hapening, we add the overloaded version. Notice that containers of smart pointers does
                  not have this problem. </p></ol><hr size="1" ><h2  >References</h2><a name="References" ></a><hr size="1" ><p  >&copy; Thorsten Ottosen 2003 (nesotto@cs.auc.dk).
    Permission to copy, use, modify, sell and distribute this software is granted provided this copyright notice appears
     in all copies. This software is provided "as is" without express or implied warranty, and with no
         claim as to its suitability for any purpose.</p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></body></html>
 <!-- Copyright Dezide Aps 2003-2004 -->