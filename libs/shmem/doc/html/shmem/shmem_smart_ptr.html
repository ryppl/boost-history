<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title> Shmem ownership smart pointers</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.67.0">
<link rel="start" href="../index.html" title="Chapter 1. Shmem 0.92">
<link rel="up" href="../index.html" title="Chapter 1. Shmem 0.92">
<link rel="prev" href="streams.html" title=" Direct iostream formatting: vectorstream and bufferstream">
<link rel="next" href="shared_message_queue.html" title=" Process-shared message queue">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%">
<td valign="top"><img alt="boost.png (6897 bytes)" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.htm">Home</a></td>
<td align="center"><a href="../libraries.html">Libraries</a></td>
<td align="center"><a href="../../../../../people/people.htm">People</a></td>
<td align="center"><a href="../../../../../more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="streams.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="shared_message_queue.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="shmem.shmem_smart_ptr"></a> Shmem ownership smart pointers</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="shmem_smart_ptr.html#shmem.intrusive_ptr"> Intrusive pointer</a></span></dt>
<dt><span class="section"><a href="shmem_smart_ptr.html#shmem.scoped_ptr"> Scoped pointer</a></span></dt>
</dl></div>
<p>
C++ users know the importance of ownership smart pointers when dealing with resources.
Boost offers a wide range of such type of pointers: <code class="computeroutput"><span class="identifier">intrusive_ptr</span><span class="special">&lt;&gt;</span></code>,
<code class="computeroutput"><span class="identifier">scoped_ptr</span><span class="special">&lt;&gt;</span></code>, <code class="computeroutput"><span class="identifier">shared_ptr</span><span class="special">&lt;&gt;</span></code>...</p>
<p>
When building complex shared memory/memory mapped files structures, programmers
would like to use also the advantages of these smart pointers. The problem is that
Boost and C++ TR1 smart pointers are not ready to be used for shared memory. The cause 
is that those smart pointers contain raw pointers and they use virtual functions,
something that is not possible if you want to place your data in shared memory.
The virtual function limitation makes even impossible to achieve the same level of
functionality of Boost and TR1 with Shmem smart pointers.</p>
<p>
Shmem ownership smart pointers are mainly "smart pointers contaning smart pointers",
so we can specify the pointer type they contain.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="shmem.intrusive_ptr"></a> Intrusive pointer</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shmem</span><span class="special">::</span><span class="identifier">intrusive_ptr</span><span class="special">&lt;&gt;</span></code> is the generalization of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive_ptr</span><span class="special">&lt;&gt;</span></code>
to allow non-raw pointers as intrusive pointer members. As the known 
<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive_ptr</span></code> we must specify the pointee type but we also must also specify 
the pointer type to be stored in the intrusive_ptr:</p>
<p></p>
<pre class="programlisting"><code class="literal"><span class="comment">/*!The intrusive_ptr class template stores a pointer to an object
   with an embedded reference count. intrusive_ptr is parameterized on
   T (the type of the object pointed to) and VoidPointer(a void pointer type 
   that defines the type of pointer that intrusive_ptr will store).
   intrusive_ptr&lt;T, void *&gt; defines a class with a T* member whereas
   intrusive_ptr&lt;T, offset_ptr&lt;void&gt; &gt; defines a class with a offset_ptr&lt;T&gt; member.
   Relies on unqualified calls to:
    
   void intrusive_ptr_add_ref(T * p);
   void intrusive_ptr_release(T * p);

   with (p != 0)

   The object is responsible for destroying itself.*/</span><span class="keyword">
template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="identifier"> T</span><span class="special">,</span><span class="keyword"> class</span><span class="identifier"> VoidPointer</span><span class="special">&gt;</span><span class="keyword">
class</span><span class="identifier"> intrusive_ptr</span><span class="special">
{</span><span class="keyword">
   public</span><span class="special">:</span><span class="comment">
   /*!Provides the type of the internal stored pointer.*/</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> detail</span><span class="special">::</span><span class="identifier">pointer_to_other</span><span class="special">&lt;</span><span class="identifier">VP</span><span class="special">,</span><span class="identifier"> T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="identifier"> pointer</span><span class="special">;</span><span class="comment">
   /*!Provides the type of the stored pointer.*/</span><span class="keyword">
   typedef</span><span class="identifier"> T</span><span class="identifier"> element_type</span><span class="special">;</span><span class="comment">

   /*!Constructor. Initializes internal pointer to 0. Does not throw*/</span><span class="identifier">
   intrusive_ptr</span><span class="special">();</span><span class="comment">

   /*!Constructor. Copies pointer and if "p" is not zero and 
      "add_ref" is true calls intrusive_ptr_add_ref(get_pointer(p)).
      Does not throw*/</span><span class="identifier">
   intrusive_ptr</span><span class="special">(</span><span class="keyword">const</span><span class="identifier"> pointer</span><span class="special"> &amp;</span><span class="identifier">p</span><span class="special">,</span><span class="keyword"> bool</span><span class="identifier"> add_ref</span><span class="special"> =</span><span class="keyword"> true</span><span class="special">);</span><span class="comment">

   /*!Copy constructor. Copies the internal pointer and if "p" is not
      zero calls intrusive_ptr_add_ref(get_pointer(p)). Does not throw*/</span><span class="identifier">
   intrusive_ptr</span><span class="special">(</span><span class="identifier">intrusive_ptr</span><span class="keyword"> const</span><span class="special"> &amp;</span><span class="identifier"> rhs</span><span class="special">);</span><span class="comment">

   /*!Constructor from related. Copies the internal pointer and if "p" is not
      zero calls intrusive_ptr_add_ref(get_pointer(p)). Does not throw*/</span><span class="keyword">
   template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="identifier"> U</span><span class="special">&gt;</span><span class="identifier"> intrusive_ptr</span><span class="special"> (</span><span class="identifier">intrusive_ptr</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">,</span><span class="identifier"> VP</span><span class="special">&gt;</span><span class="keyword"> const</span><span class="special"> &amp;</span><span class="identifier"> rhs</span><span class="special">);</span><span class="comment">

   /*!Destructor. If internal pointer is not 0, calls
      intrusive_ptr_release(get_pointer(m_ptr)). Does not throw*/</span><span class="special">
   ~</span><span class="identifier">intrusive_ptr</span><span class="special">();</span><span class="comment">

   /*!Assignment operator. Equivalent to intrusive_ptr(r).swap(*this). 
      Does not throw*/</span><span class="identifier">
   intrusive_ptr</span><span class="special"> &amp;</span><span class="keyword"> operator</span><span class="special">=(</span><span class="identifier">intrusive_ptr</span><span class="keyword"> const</span><span class="special"> &amp;</span><span class="identifier"> rhs</span><span class="special">);</span><span class="comment">

   /*!Assignment from related. Equivalent to intrusive_ptr(r).swap(*this). 
      Does not throw*/</span><span class="keyword">
   template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="identifier"> U</span><span class="special">&gt;</span><span class="identifier"> intrusive_ptr</span><span class="special"> &amp;</span><span class="keyword"> operator</span><span class="special">=</span><span class="special"> (</span><span class="identifier">intrusive_ptr</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">,</span><span class="identifier"> VP</span><span class="special">&gt;</span><span class="keyword"> const</span><span class="special"> &amp;</span><span class="identifier"> rhs</span><span class="special">);</span><span class="comment">

   /*!Assignment from pointer. Equivalent to intrusive_ptr(r).swap(*this). 
      Does not throw*/</span><span class="identifier">
   intrusive_ptr</span><span class="special"> &amp;</span><span class="keyword"> operator</span><span class="special">=(</span><span class="identifier">pointer</span><span class="identifier"> rhs</span><span class="special">);</span><span class="comment">
   
   /*!Returns a reference to the internal pointer. Does not throw*/</span><span class="identifier">
   pointer</span><span class="special"> &amp;</span><span class="identifier">get</span><span class="special">();</span><span class="comment">

   /*!Returns a reference to the internal pointer. Does not throw*/</span><span class="keyword">
   const</span><span class="identifier"> pointer</span><span class="special"> &amp;</span><span class="identifier">get</span><span class="special">()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Returns *get(). Does not throw*/</span><span class="identifier">
   T</span><span class="special"> &amp;</span><span class="keyword"> operator</span><span class="special">*()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Returns *get(). Does not throw*/</span><span class="keyword">
   const</span><span class="identifier"> pointer</span><span class="special"> &amp;</span><span class="keyword">operator</span><span class="special">-&gt;()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Returns get(). Does not throw*/</span><span class="identifier">
   pointer</span><span class="special"> &amp;</span><span class="keyword">operator</span><span class="special">-&gt;();</span><span class="keyword">

   operator</span><span class="identifier"> unspecified_bool_type</span><span class="special"> ()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Not operator. Does not throw*/</span><span class="keyword">
   bool</span><span class="keyword"> operator</span><span class="special">!</span><span class="special"> ()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Exchanges the contents of the two smart pointers. Does not throw*/</span><span class="keyword">
   void</span><span class="identifier"> swap</span><span class="special">(</span><span class="identifier">intrusive_ptr</span><span class="special"> &amp;</span><span class="identifier"> rhs</span><span class="special">);</span><span class="special">
};</span></code></pre>
<p>
So <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shmem</span><span class="special">::</span><span class="identifier">intrusive_ptr</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">,</span><span class="keyword"> void</span><span class="special">*&gt;</span></code> is equivalent to 
<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">instrusive_ptr</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">&gt;</span></code>. But if we want to place the intrusive_ptr in 
shared memory we must specify a relative pointer type like 
<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shmem</span><span class="special">::</span><span class="identifier">intrusive_ptr</span><span class="special">&lt;</span><span class="identifier">MyClass</span><span class="special">,</span><span class="identifier"> boost</span><span class="special">::</span><span class="identifier">shmem</span><span class="special">::</span><span class="identifier">offset_ptr</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span><span class="special"> &gt;</span></code></p>
<p></p>
<pre class="programlisting"><code class="literal"><span class="preprocessor">#include</span><span class="special"> &lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">shmem</span><span class="special">/</span><span class="identifier">named_shared_object</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="preprocessor">
#include</span><span class="special"> &lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">shmem</span><span class="special">/</span><span class="identifier">smart_ptr</span><span class="special">/</span><span class="identifier">intrusive_ptr</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="keyword">

using</span><span class="keyword"> namespace</span><span class="identifier"> boost</span><span class="special">::</span><span class="identifier">shmem</span><span class="special">;</span><span class="keyword">

namespace</span><span class="identifier"> N</span><span class="special"> {</span><span class="comment">

//A class that has an internal reference count
</span><span class="keyword">class</span><span class="identifier"> reference_counted_class</span><span class="special">
{</span><span class="keyword">
   private</span><span class="special">:</span><span class="comment">
   //Non-copyable
</span><span class="identifier">   reference_counted_class</span><span class="special">(</span><span class="keyword">const</span><span class="identifier"> reference_counted_class</span><span class="special">  &amp;);</span><span class="comment">
   //Non-assignable
</span><span class="identifier">   reference_counted_class</span><span class="special"> &amp;</span><span class="keyword"> operator</span><span class="special">=(</span><span class="keyword">const</span><span class="identifier"> reference_counted_class</span><span class="special"> &amp;);</span><span class="comment">
   //A typedef to save typing
</span><span class="keyword">   typedef</span><span class="identifier"> named_shared_object</span><span class="special">::</span><span class="identifier">segment_manager</span><span class="identifier"> segment_manager</span><span class="special">;</span><span class="comment">
   //This is the reference count
</span><span class="keyword">   unsigned</span><span class="keyword"> int</span><span class="identifier"> m_use_count</span><span class="special">;</span><span class="comment">
   //The segment manager allows deletion from shared memory segment
</span><span class="identifier">   offset_ptr</span><span class="special">&lt;</span><span class="identifier">segment_manager</span><span class="special">&gt;</span><span class="identifier"> mp_segment_manager</span><span class="special">;</span><span class="keyword">

   public</span><span class="special">:</span><span class="comment">
   //Constructor
</span><span class="identifier">   reference_counted_class</span><span class="special">(</span><span class="identifier">segment_manager</span><span class="special"> *</span><span class="identifier">s_mngr</span><span class="special">)</span><span class="special">
   :</span><span class="identifier"> m_use_count</span><span class="special">(</span><span class="number">0</span><span class="special">),</span><span class="identifier"> mp_segment_manager</span><span class="special">(</span><span class="identifier">s_mngr</span><span class="special">){}</span><span class="comment">
   //Destructor
</span><span class="special">   ~</span><span class="identifier">reference_counted_class</span><span class="special">(){}</span><span class="keyword">

   public</span><span class="special">:</span><span class="comment">
   //Returns the reference count
</span><span class="keyword">   unsigned</span><span class="keyword"> int</span><span class="identifier"> use_count</span><span class="special">()</span><span class="keyword"> const</span><span class="special">
   {</span><span class="keyword">  return</span><span class="identifier"> m_use_count</span><span class="special">;</span><span class="special">   }</span><span class="comment">
   //Adds a reference
</span><span class="keyword">   inline</span><span class="keyword"> friend</span><span class="keyword"> void</span><span class="identifier"> intrusive_ptr_add_ref</span><span class="special">(</span><span class="identifier">reference_counted_class</span><span class="special"> *</span><span class="identifier"> p</span><span class="special">)</span><span class="special">
   {</span><span class="special">  ++</span><span class="identifier">p</span><span class="special">-&gt;</span><span class="identifier">m_use_count</span><span class="special">;</span><span class="special"> }</span><span class="comment">
   //Releases a reference
</span><span class="keyword">   inline</span><span class="keyword"> friend</span><span class="keyword"> void</span><span class="identifier"> intrusive_ptr_release</span><span class="special">(</span><span class="identifier">reference_counted_class</span><span class="special"> *</span><span class="identifier"> p</span><span class="special">)</span><span class="special">
   {</span><span class="keyword">  if</span><span class="special">(--</span><span class="identifier">p</span><span class="special">-&gt;</span><span class="identifier">m_use_count</span><span class="special"> ==</span><span class="number"> 0</span><span class="special">)</span><span class="identifier">  p</span><span class="special">-&gt;</span><span class="identifier">mp_segment_manager</span><span class="special">-&gt;</span><span class="identifier">destroy_ptr</span><span class="special">(</span><span class="identifier">p</span><span class="special">);</span><span class="special"> }</span><span class="special">
};</span><span class="special">

}</span><span class="comment">  //namespace N {

//A class that has an intrusive pointer to reference_counted_class
</span><span class="keyword">class</span><span class="identifier"> intrusive_ptr_owner</span><span class="special">
{</span><span class="keyword">
   typedef</span><span class="identifier"> intrusive_ptr</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">::</span><span class="identifier">reference_counted_class</span><span class="special">,</span><span class="identifier"> 
                         offset_ptr</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span><span class="special"> &gt;</span><span class="identifier"> intrusive_ptr_t</span><span class="special">;</span><span class="identifier">
   intrusive_ptr_t</span><span class="identifier"> m_intrusive_ptr</span><span class="special">;</span><span class="keyword">

   public</span><span class="special">:</span><span class="comment">
   //Takes a pointer to the reference counted class
</span><span class="identifier">   intrusive_ptr_owner</span><span class="special">(</span><span class="identifier">N</span><span class="special">::</span><span class="identifier">reference_counted_class</span><span class="special"> *</span><span class="identifier">ptr</span><span class="special">)</span><span class="special"> 
      :</span><span class="identifier"> m_intrusive_ptr</span><span class="special">(</span><span class="identifier">ptr</span><span class="special">){}</span><span class="special">
};</span><span class="keyword">

int</span><span class="identifier"> main</span><span class="special"> ()</span><span class="special">
{</span><span class="comment">
   //Create shared memory
</span><span class="identifier">   named_shared_object</span><span class="identifier"> shmem</span><span class="special">;</span><span class="identifier">
   shmem</span><span class="special">.</span><span class="identifier">create</span><span class="special">(</span><span class="string">"my_shmem"</span><span class="special">,</span><span class="number"> 10000</span><span class="special">);</span><span class="comment">
   //Create the unique reference counted object in shared memory
</span><span class="identifier">   N</span><span class="special">::</span><span class="identifier">reference_counted_class</span><span class="special"> *</span><span class="identifier">ref_counted</span><span class="special"> =</span><span class="identifier"> 
      shmem</span><span class="special">.</span><span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">::</span><span class="identifier">reference_counted_class</span><span class="special">&gt;</span><span class="special">
         (</span><span class="string">"ref_counted"</span><span class="special">)(</span><span class="identifier">shmem</span><span class="special">.</span><span class="identifier">get_segment_manager</span><span class="special">());</span><span class="comment">
   //Create an array of ten intrusive pointer owners in shared memory
</span><span class="identifier">   intrusive_ptr_owner</span><span class="special"> *</span><span class="identifier">intrusive_owner_array</span><span class="special"> =</span><span class="identifier"> 
      shmem</span><span class="special">.</span><span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">intrusive_ptr_owner</span><span class="special">&gt;</span><span class="special">
         (</span><span class="identifier">anonymous_instance</span><span class="special">)[</span><span class="number">10</span><span class="special">](</span><span class="identifier">ref_counted</span><span class="special">);</span><span class="comment">
   //Now test that reference count is ten
</span><span class="keyword">   if</span><span class="special">(</span><span class="identifier">ref_counted</span><span class="special">-&gt;</span><span class="identifier">use_count</span><span class="special">()</span><span class="special"> !=</span><span class="number"> 10</span><span class="special">)</span><span class="keyword">
      return</span><span class="special"> -</span><span class="number">1</span><span class="special">;</span><span class="comment">

   //Now destroy the array of intrusive pointer owners
   //This should destroy every intrusive_ptr and because of
   //that reference_counted_class will be destroyed
</span><span class="identifier">   shmem</span><span class="special">.</span><span class="identifier">destroy_ptr</span><span class="special">(</span><span class="identifier">intrusive_owner_array</span><span class="special">);</span><span class="comment">

   //Now the reference counted object should have been destroyed
</span><span class="keyword">   if</span><span class="special">(</span><span class="identifier">shmem</span><span class="special">.</span><span class="identifier">find</span><span class="special">&lt;</span><span class="identifier">intrusive_ptr_owner</span><span class="special">&gt;(</span><span class="string">"ref_counted"</span><span class="special">).</span><span class="identifier">first</span><span class="special">)</span><span class="keyword">
      return</span><span class="special"> -</span><span class="number">1</span><span class="special">;</span><span class="comment">
   //Success!
</span><span class="keyword">   return</span><span class="number"> 0</span><span class="special">;</span><span class="special">
}</span></code></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="shmem.scoped_ptr"></a> Scoped pointer</h3></div></div></div>
<p><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shmem</span><span class="special">::</span><span class="identifier">scoped_ptr</span><span class="special">&lt;&gt;</span></code> is the big brother of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">scoped_ptr</span><span class="special">&lt;&gt;</span></code>, which
adds a custom deleter to specify how the pointer passed to the scoped_ptr must be destroyed.
Also, the <code class="computeroutput"><span class="identifier">pointer</span></code> typedef of the deleter will specify the pointer type stored by scoped_ptr.</p>
<p></p>
<pre class="programlisting"><code class="literal"><span class="comment">/*!scoped_ptr stores a pointer to a dynamically allocated object. 
   The object pointed to is guaranteed to be deleted, either on destruction
   of the scoped_ptr, or via an explicit reset. The user can avoid this
   deletion using release().
   scoped_ptr is parameterized on T (the type of the object pointed to) and 
   Deleter (the functor to be executed to delete the internal pointer).
   The internal pointer will be of the same pointer type as typename 
   Deleter::pointer type (that is, if typename Deleter::pointer is 
   offset_ptr&lt;void&gt;, the internal pointer will be offset_ptr&lt;T&gt;).*/</span><span class="keyword">
template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="identifier"> T</span><span class="special">,</span><span class="keyword"> class</span><span class="identifier"> Deleter</span><span class="special">&gt;</span><span class="keyword">
class</span><span class="identifier"> scoped_ptr</span><span class="special">
{</span><span class="keyword">
   public</span><span class="special">:</span><span class="comment">

   /*!Provides the type of the stored pointer.*/</span><span class="keyword">
   typedef</span><span class="identifier"> T</span><span class="identifier"> element_type</span><span class="special">;</span><span class="comment">

   /*!Provides the type of the internal stored pointer.*/</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> detail</span><span class="special">::</span><span class="identifier">pointer_to_other</span><span class="special">
            &lt;</span><span class="keyword">typename</span><span class="identifier"> Deleter</span><span class="special">::</span><span class="identifier">pointer</span><span class="special">,</span><span class="identifier"> T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="identifier"> pointer</span><span class="special">;</span><span class="comment">

   /*!Constructs a scoped_ptr, storing a copy of p(which can be 0) and d.
      Does not throw.*/</span><span class="keyword">
   explicit</span><span class="identifier"> scoped_ptr</span><span class="special">(</span><span class="keyword">const</span><span class="identifier"> pointer</span><span class="special"> &amp;</span><span class="identifier">p</span><span class="special"> =</span><span class="number"> 0</span><span class="special">,</span><span class="keyword"> const</span><span class="identifier"> Deleter</span><span class="special"> &amp;</span><span class="identifier">d</span><span class="special"> =</span><span class="identifier"> Deleter</span><span class="special">());</span><span class="comment">

   /*!If the stored pointer is not 0, destroys the object pointed to by the stored pointer. 
      calling the operator() of the stored deleter.*/</span><span class="special">
   ~</span><span class="identifier">scoped_ptr</span><span class="special">();</span><span class="comment">

   /*!Deletes the object pointed to by the stored pointer and then
      stores a copy of p. Never throws*/</span><span class="keyword">
   void</span><span class="identifier"> reset</span><span class="special">(</span><span class="keyword">const</span><span class="identifier"> pointer</span><span class="special"> &amp;</span><span class="identifier">p</span><span class="special"> =</span><span class="number"> 0</span><span class="special">);</span><span class="comment">

   /*!Deletes the object pointed to by the stored pointer and then
      stores a copy of p and a copy of d.*/</span><span class="keyword">
   void</span><span class="identifier"> reset</span><span class="special">(</span><span class="keyword">const</span><span class="identifier"> pointer</span><span class="special"> &amp;</span><span class="identifier">p</span><span class="special">,</span><span class="keyword"> const</span><span class="identifier"> Deleter</span><span class="special"> &amp;</span><span class="identifier">d</span><span class="special">);</span><span class="comment">

   /*!Assigns internal pointer as 0 and returns previous pointer. This will
      avoid deletion on destructor*/</span><span class="identifier">
   pointer</span><span class="identifier"> release</span><span class="special">():</span><span class="comment">

   /*!Returns a reference to the object pointed to by the stored pointer.
      Never throws.*/</span><span class="identifier">
   reference</span><span class="keyword"> operator</span><span class="special">*()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Returns the internal stored pointer. Never throws*/</span><span class="identifier">
   pointer</span><span class="special"> &amp;</span><span class="keyword">operator</span><span class="special">-&gt;();</span><span class="comment">

   /*!Returns the internal stored pointer. Never throws.*/</span><span class="keyword">
   const</span><span class="identifier"> pointer</span><span class="special"> &amp;</span><span class="keyword">operator</span><span class="special">-&gt;()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Returns the stored pointer. Never throws.*/</span><span class="identifier">
   pointer</span><span class="special"> &amp;</span><span class="identifier"> get</span><span class="special">();</span><span class="comment">

   /*!Returns the stored pointer. Never throws.*/</span><span class="keyword">
   const</span><span class="identifier"> pointer</span><span class="special"> &amp;</span><span class="identifier"> get</span><span class="special">()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Returns true if the stored pointer is 0. Never throws.*/</span><span class="keyword">
   bool</span><span class="keyword"> operator</span><span class="special">!</span><span class="special"> ()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Exchanges the internal pointer and deleter with other scoped_ptr
      Never throws.*/</span><span class="keyword">
   void</span><span class="identifier"> swap</span><span class="special">(</span><span class="identifier">scoped_ptr</span><span class="special"> &amp;</span><span class="identifier"> b</span><span class="special">);</span><span class="special">
};</span></code></pre>
<p><code class="computeroutput"><span class="identifier">scoped_ptr</span><span class="special">&lt;&gt;</span></code> comes handy to implement <span class="bold"><strong>rollbacks</strong></span> with exceptions: if an exception 
is thrown or we call <code class="computeroutput"><span class="keyword">return</span></code> in the scope of <code class="computeroutput"><span class="identifier">scoped_ptr</span><span class="special">&lt;&gt;</span></code> the deleter is
automatically called so that <span class="bold"><strong>the deleter can be considered as a rollback</strong></span> function.
If all goes well, we call <code class="computeroutput"><span class="identifier">release</span><span class="special">()</span></code> member function to avoid rollback when
the <code class="computeroutput"><span class="identifier">scoped_ptr</span></code> goes out of scope.</p>
<p></p>
<pre class="programlisting"><code class="literal"><span class="preprocessor">#include</span><span class="special"> &lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">shmem</span><span class="special">/</span><span class="identifier">named_shared_object</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="preprocessor">
#include</span><span class="special"> &lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">shmem</span><span class="special">/</span><span class="identifier">smart_ptr</span><span class="special">/</span><span class="identifier">scoped_ptr</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="keyword">

using</span><span class="keyword"> namespace</span><span class="identifier"> boost</span><span class="special">::</span><span class="identifier">shmem</span><span class="special">;</span><span class="keyword">

class</span><span class="identifier"> my_class</span><span class="special">
{};</span><span class="keyword">

class</span><span class="identifier"> my_exception</span><span class="special">
{};</span><span class="comment">

//A functor that destroys the shared memory object
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="identifier"> T</span><span class="special">&gt;</span><span class="keyword">
class</span><span class="identifier"> deleter</span><span class="special">
{</span><span class="keyword">
   private</span><span class="special">:</span><span class="comment">
   //A typedef to save typing
</span><span class="keyword">   typedef</span><span class="identifier"> named_shared_object</span><span class="special">::</span><span class="identifier">segment_manager</span><span class="identifier"> segment_manager</span><span class="special">;</span><span class="comment">
   //This deleter is created in the stack, not in shared memory,
   //so we can use raw pointers
</span><span class="identifier">   segment_manager</span><span class="special"> *</span><span class="identifier">mp_segment_manager</span><span class="special">;</span><span class="keyword">

   public</span><span class="special">:</span><span class="comment">
   //This typedef will specify the pointer type that
   //scoped_ptr will store
</span><span class="keyword">   typedef</span><span class="identifier"> T</span><span class="special"> *</span><span class="identifier">pointer</span><span class="special">;</span><span class="comment">
   //Constructor
</span><span class="identifier">   deleter</span><span class="special">(</span><span class="identifier">segment_manager</span><span class="special"> *</span><span class="identifier">s_mngr</span><span class="special">)</span><span class="special">
   :</span><span class="identifier"> mp_segment_manager</span><span class="special">(</span><span class="identifier">s_mngr</span><span class="special">){}</span><span class="keyword">

   void</span><span class="keyword"> operator</span><span class="special">()(</span><span class="identifier">pointer</span><span class="identifier"> object_to_delete</span><span class="special">)</span><span class="special">
   {</span><span class="identifier">  mp_segment_manager</span><span class="special">-&gt;</span><span class="identifier">destroy_ptr</span><span class="special">(</span><span class="identifier">object_to_delete</span><span class="special">);</span><span class="special">  }</span><span class="special">
};</span><span class="keyword">

int</span><span class="identifier"> main</span><span class="special"> ()</span><span class="special">
{</span><span class="comment">
   //Create shared memory
</span><span class="identifier">   named_shared_object</span><span class="identifier"> shmem</span><span class="special">;</span><span class="identifier">
   shmem</span><span class="special">.</span><span class="identifier">create</span><span class="special">(</span><span class="string">"my_shmem"</span><span class="special">,</span><span class="number"> 10000</span><span class="special">);</span><span class="comment">

   //In the first try, there will be no exceptions
   //in the second try we will throw an exception
</span><span class="keyword">   for</span><span class="special">(</span><span class="keyword">int</span><span class="identifier"> i</span><span class="special"> =</span><span class="number"> 0</span><span class="special">;</span><span class="identifier"> i</span><span class="special"> &lt;</span><span class="number"> 2</span><span class="special">;</span><span class="special"> ++</span><span class="identifier">i</span><span class="special">){</span><span class="comment">
      //Create an object in shared memory
</span><span class="identifier">      my_class</span><span class="special"> *</span><span class="identifier"> my_object</span><span class="special"> =</span><span class="identifier"> shmem</span><span class="special">.</span><span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">my_class</span><span class="special">&gt;(</span><span class="string">"my_object"</span><span class="special">)();</span><span class="comment">
      
      //Since the next shared memory allocation can throw
      //assign it to a scoped_ptr so that if an exception occurs
      //we destroy the object automatically
</span><span class="identifier">      deleter</span><span class="special">&lt;</span><span class="identifier">my_class</span><span class="special">&gt;</span><span class="identifier"> d</span><span class="special">(</span><span class="identifier">shmem</span><span class="special">.</span><span class="identifier">get_segment_manager</span><span class="special">());</span><span class="keyword">

      try</span><span class="special">{</span><span class="identifier">
         scoped_ptr</span><span class="special">&lt;</span><span class="identifier">my_class</span><span class="special">,</span><span class="identifier"> deleter</span><span class="special">&lt;</span><span class="identifier">my_class</span><span class="special">&gt;</span><span class="special"> &gt;</span><span class="identifier"> s_ptr</span><span class="special">(</span><span class="identifier">my_object</span><span class="special">,</span><span class="identifier"> d</span><span class="special">);</span><span class="comment">
         //Let's emulate a exception capable operation
         //In the second try, throw an exception
</span><span class="keyword">         if</span><span class="special">(</span><span class="identifier">i</span><span class="special"> ==</span><span class="number"> 1</span><span class="special">){</span><span class="keyword">
            throw</span><span class="special">(</span><span class="identifier">my_exception</span><span class="special">());</span><span class="special">
         }</span><span class="comment">
         //If we have passed the dangerous zone
         //we can release the scoped pointer
         //to avoid destruction
</span><span class="identifier">         s_ptr</span><span class="special">.</span><span class="identifier">release</span><span class="special">();</span><span class="special">
      }</span><span class="keyword">
      catch</span><span class="special">(</span><span class="keyword">const</span><span class="identifier"> my_exception</span><span class="special"> &amp;){}</span><span class="comment">

      //Here, scoped_ptr is destroyed
      //so it we haven't thrown an exception
      //the object should be there, otherwise, destroyed
</span><span class="keyword">      if</span><span class="special">(</span><span class="identifier">i</span><span class="special"> ==</span><span class="number"> 0</span><span class="special">){</span><span class="comment">
         //Make sure the object is alive
</span><span class="keyword">         if</span><span class="special">(!</span><span class="identifier">shmem</span><span class="special">.</span><span class="identifier">find</span><span class="special">&lt;</span><span class="identifier">my_class</span><span class="special">&gt;(</span><span class="string">"my_object"</span><span class="special">).</span><span class="identifier">first</span><span class="special">){</span><span class="keyword">
            return</span><span class="special"> -</span><span class="number">1</span><span class="special">;</span><span class="special">
         }</span><span class="comment">
         //Now we can use it and delete it manually
</span><span class="identifier">         shmem</span><span class="special">.</span><span class="identifier">destroy</span><span class="special">&lt;</span><span class="identifier">my_class</span><span class="special">&gt;(</span><span class="string">"my_object"</span><span class="special">);</span><span class="special">
      }</span><span class="keyword">
      else</span><span class="special">{</span><span class="comment">
         //Make sure the object has been deleted
</span><span class="keyword">         if</span><span class="special">(</span><span class="identifier">shmem</span><span class="special">.</span><span class="identifier">find</span><span class="special">&lt;</span><span class="identifier">my_class</span><span class="special">&gt;(</span><span class="string">"my_object"</span><span class="special">).</span><span class="identifier">first</span><span class="special">){</span><span class="keyword">
            return</span><span class="special"> -</span><span class="number">1</span><span class="special">;</span><span class="special">
         }</span><span class="special">
      }</span><span class="special">
   }</span><span class="keyword">
   return</span><span class="number"> 0</span><span class="special">;</span><span class="special">
}</span></code></pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><small>Copyright © 2005 - 2006 Ion Gaztañaga</small></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="streams.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="shared_message_queue.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
