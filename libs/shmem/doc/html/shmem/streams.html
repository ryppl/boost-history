<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title> Direct iostream formatting: vectorstream and bufferstream</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.67.0">
<link rel="start" href="../index.html" title="Chapter 1. Shmem 0.9">
<link rel="up" href="../index.html" title="Chapter 1. Shmem 0.9">
<link rel="prev" href="beyond_shared_memory.html" title=" Beyond shared memory">
<link rel="next" href="shmem_smart_ptr.html" title=" Shmem ownership smart pointers">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%">
<td valign="top"><img alt="boost.png (6897 bytes)" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.htm">Home</a></td>
<td align="center"><a href="../libraries.html">Libraries</a></td>
<td align="center"><a href="../../../../../people/people.htm">People</a></td>
<td align="center"><a href="../../../../../more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="beyond_shared_memory.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="shmem_smart_ptr.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="shmem.streams"></a> Direct iostream formatting: vectorstream and bufferstream</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="streams.html#shmem.vectorstream"> Formatting directly in your character vector: vectorstream</a></span></dt>
<dt><span class="section"><a href="streams.html#shmem.bufferstream"> Formatting directly in your character buffer: bufferstream</a></span></dt>
</dl></div>
<p>
Shared memory, memory-mapped files and all Shmem mechanisms are focused
on efficiency. The reason why shared memory is used is that it's the
fastest IPC mechanism available. When passing text-oriented messages through
shared memory, there is need to format the message. Obviously C++ offers
the iostream framework for that work.</p>
<p>
Some programmers appreciate the iostream safety and design for memory
formatting but feel that the stringstream family is far from efficient not
when formatting, but when obtaining formatted data to a string, or when 
setting the string from which the stream will extract data. An example:</p>
<p></p>
<pre class="programlisting"><code class="literal"><span class="comment">//Some formatting elements
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="identifier"> my_text</span><span class="special"> =</span><span class="string"> "..."</span><span class="special">;</span><span class="keyword">
int</span><span class="identifier"> number</span><span class="special">;</span><span class="comment">

//Data reader
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">istringstream</span><span class="identifier"> input_processor</span><span class="special">;</span><span class="comment">

//This makes a copy of the string. If not using a
//reference counted string, this is a serious overhead.
</span><span class="identifier">input_processor</span><span class="special">.</span><span class="identifier">str</span><span class="special">(</span><span class="identifier">my_text</span><span class="special">);</span><span class="comment">

//Extract data
</span><span class="keyword">while</span><span class="special">(/*...*/){</span><span class="identifier">
   input_processor</span><span class="special"> &gt;&gt;</span><span class="identifier"> number</span><span class="special">;</span><span class="special">
}</span><span class="comment">

//Data writer
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostringstream</span><span class="identifier"> output_processor</span><span class="special">;</span><span class="comment">

//Write data
</span><span class="keyword">while</span><span class="special">(/*...*/){</span><span class="identifier">
   output_processor</span><span class="special"> &lt;&lt;</span><span class="identifier"> number</span><span class="special">;</span><span class="special">
}</span><span class="comment">

//This returns a temporary string. Even with return-value
//optimization this is expensive.
</span><span class="identifier">my_text</span><span class="special"> =</span><span class="identifier"> input_processor</span><span class="special">.</span><span class="identifier">str</span><span class="special">();</span></code></pre>
<p>
The problem is even worse if the string is a shared-memory string, because
to extract data, we must copy the data first from shared-memory to a 
std::string and then to a stringstream. To encode data in a shared-memory
string we should copy data from a stringstream to a std::string and then 
to the shared-memory string.</p>
<p>
Because of this overhead, Shmem offers a way to format memory-strings
(in shared memory, memory mapped files or any other memory segment) that
can avoid all unneeded string copy and memory allocation/deallocation, while
using all iostream facilities. Shmem <span class="bold"><strong>vectorstream</strong></span> and <span class="bold"><strong>bufferstream</strong></span> implement
vector-based and fixed-size buffer based storage support for iostreams and
all the formatting/locale hard work is done by standard std::basic_streambuf&lt;&gt;
and std::basic_iostream&lt;&gt; classes.</p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="shmem.vectorstream"></a> Formatting directly in your character vector: vectorstream</h3></div></div></div>
<p>
The <span class="bold"><strong>vectorstream</strong></span> class family (<span class="bold"><strong>basic_vectorbuf</strong></span>, <span class="bold"><strong>basic_ivectorstream</strong></span>
,<span class="bold"><strong>basic_ovectorstream</strong></span> and <span class="bold"><strong>basic_vectorstream</strong></span>) is an efficient way to obtain 
formatted reading/writing directly in a character vector. This way, if
a shared-memory vector is used, data is extracted/written from/to the shared-memory
vector, without additional copy/allocation. We can see the declaration of 
basic_vectorbuf and basic_vectorstream here:</p>
<p></p>
<pre class="programlisting"><code class="literal"><span class="comment">/*!A streambuf class that controls the transmission of elements to and from
   a basic_ivectorstream, basic_ovectorstream or basic_vectorstream. 
   It holds a character vector specified by CharVector template parameter
   as its formatting buffer. The vector must have contiguous storage, like 
   std::vector, boost::shmem::vector or boost::shmem::basic_string*/</span><span class="keyword">
template</span><span class="special"> &lt;</span><span class="keyword">class</span><span class="identifier"> CharVector</span><span class="special">,</span><span class="keyword"> class</span><span class="identifier"> CharTraits</span><span class="special"> =</span><span class="identifier"> 
         std</span><span class="special">::</span><span class="identifier">char_traits</span><span class="special">&lt;</span><span class="keyword">typename</span><span class="identifier"> CharVector</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&gt;</span><span class="special"> &gt;</span><span class="keyword">
class</span><span class="identifier"> basic_vectorbuf</span><span class="special"> 
   :</span><span class="keyword"> public</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_streambuf</span><span class="special">&lt;</span><span class="keyword">typename</span><span class="identifier"> CharVector</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;</span><span class="special">
{</span><span class="keyword">
   public</span><span class="special">:</span><span class="keyword">
   typedef</span><span class="identifier"> CharVector</span><span class="identifier">                        vector_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> CharVector</span><span class="special">::</span><span class="identifier">value_type</span><span class="identifier">   char_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> CharTraits</span><span class="special">::</span><span class="identifier">int_type</span><span class="identifier">     int_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> CharTraits</span><span class="special">::</span><span class="identifier">pos_type</span><span class="identifier">     pos_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> CharTraits</span><span class="special">::</span><span class="identifier">off_type</span><span class="identifier">     off_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="identifier"> CharTraits</span><span class="identifier">                        traits_type</span><span class="special">;</span><span class="comment">

   /*!Constructor. Throws if vector_type default constructor throws.*/</span><span class="keyword">
   explicit</span><span class="identifier"> basic_vectorbuf</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">openmode</span><span class="identifier"> mode</span><span class="special">
                              =</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">in</span><span class="special"> |</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">out</span><span class="special">);</span><span class="comment">

   /*!Constructor. Throws if vector_type(const Parameter &amp;param) throws.*/</span><span class="keyword">
   template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="identifier"> Parameter</span><span class="special">&gt;</span><span class="keyword">
   explicit</span><span class="identifier"> basic_vectorbuf</span><span class="special">(</span><span class="keyword">const</span><span class="identifier"> Parameter</span><span class="special"> &amp;</span><span class="identifier">param</span><span class="special">,</span><span class="identifier">
                           std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">openmode</span><span class="identifier"> mode</span><span class="special">
                                 =</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">in</span><span class="special"> |</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">out</span><span class="special">);</span><span class="keyword">
   virtual</span><span class="special"> ~</span><span class="identifier">basic_vectorbuf</span><span class="special">(){}</span><span class="comment">

   /*!Swaps the underlying vector with the passed vector. 
      This function resets the position in the stream.
      Does not throw.*/</span><span class="keyword">
   void</span><span class="identifier"> swap_vector</span><span class="special">(</span><span class="identifier">vector_type</span><span class="special"> &amp;</span><span class="identifier">vect</span><span class="special">);</span><span class="comment">

   /*!Returns a const reference to the internal vector.
      Does not throw.*/</span><span class="keyword">
   const</span><span class="identifier"> vector_type</span><span class="special"> &amp;</span><span class="identifier">vector</span><span class="special">()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Calls resize() method of the internal vector.
      Resets the stream to the first position.
      Throws if the internals vector's resize throws.*/</span><span class="keyword">
   void</span><span class="identifier"> resize</span><span class="special">(</span><span class="keyword">typename</span><span class="identifier"> vector_type</span><span class="special">::</span><span class="identifier">size_type</span><span class="identifier"> size</span><span class="special">);</span><span class="special">
};</span><span class="comment">

/*!A basic_iostream class that holds a character vector specified by CharVector
   template parameter as it's formatting buffer. The vector must have
   contiguous storage, like std::vector, boost::shmem::vector or
   boost::shmem::basic_string*/</span><span class="keyword">
template</span><span class="special"> &lt;</span><span class="keyword">class</span><span class="identifier"> CharVector</span><span class="special">,</span><span class="keyword"> class</span><span class="identifier"> CharTraits</span><span class="special"> =</span><span class="identifier"> 
         std</span><span class="special">::</span><span class="identifier">char_traits</span><span class="special">&lt;</span><span class="keyword">typename</span><span class="identifier"> CharVector</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">&gt;</span><span class="special"> &gt;</span><span class="keyword">
class</span><span class="identifier"> basic_vectorstream</span><span class="special"> 
:</span><span class="keyword"> public</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_iostream</span><span class="special">&lt;</span><span class="keyword">typename</span><span class="identifier"> CharVector</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;</span><span class="special">

{</span><span class="keyword">
   public</span><span class="special">:</span><span class="keyword">
   typedef</span><span class="identifier"> CharVector</span><span class="identifier">                                                   vector_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_ios</span><span class="special">
      &lt;</span><span class="keyword">typename</span><span class="identifier"> CharVector</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;::</span><span class="identifier">char_type</span><span class="identifier">          char_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_ios</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;::</span><span class="identifier">int_type</span><span class="identifier">     int_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_ios</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;::</span><span class="identifier">pos_type</span><span class="identifier">     pos_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_ios</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;::</span><span class="identifier">off_type</span><span class="identifier">     off_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_ios</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;::</span><span class="identifier">traits_type</span><span class="identifier">  traits_type</span><span class="special">;</span><span class="comment">

   /*!Constructor. Throws if vector_type default constructor throws.*/</span><span class="identifier">
   basic_vectorstream</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">openmode</span><span class="identifier"> mode</span><span class="special"> 
                     =</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">in</span><span class="special"> |</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">out</span><span class="special">);</span><span class="comment">

   /*!Constructor. Throws if vector_type(const Parameter &amp;param) throws.*/</span><span class="keyword">
   template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="identifier"> Parameter</span><span class="special">&gt;</span><span class="identifier">
   basic_vectorstream</span><span class="special">(</span><span class="keyword">const</span><span class="identifier"> Parameter</span><span class="special"> &amp;</span><span class="identifier">param</span><span class="special">,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">openmode</span><span class="identifier"> mode</span><span class="special">
                     =</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">in</span><span class="special"> |</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">out</span><span class="special">);</span><span class="special">

   ~</span><span class="identifier">basic_vectorstream</span><span class="special">(){}</span><span class="comment">

   //Returns the address of the stored stream buffer.
</span><span class="identifier">   basic_vectorbuf</span><span class="special">&lt;</span><span class="identifier">CharVector</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;*</span><span class="identifier"> rdbuf</span><span class="special">()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Swaps the underlying vector with the passed vector. 
      This function resets the position in the stream.
      Does not throw.*/</span><span class="keyword">
   void</span><span class="identifier"> swap_vector</span><span class="special">(</span><span class="identifier">vector_type</span><span class="special"> &amp;</span><span class="identifier">vect</span><span class="special">);</span><span class="comment">

   /*!Returns a const reference to the internal vector.
      Does not throw.*/</span><span class="keyword">
   const</span><span class="identifier"> vector_type</span><span class="special"> &amp;</span><span class="identifier">vector</span><span class="special">()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Calls resize() method of the internal vector.
      Resets the stream to the first position.
      Throws if the internals vector's resize throws.*/</span><span class="keyword">
   void</span><span class="identifier"> resize</span><span class="special">(</span><span class="keyword">typename</span><span class="identifier"> vector_type</span><span class="special">::</span><span class="identifier">size_type</span><span class="identifier"> size</span><span class="special">);</span><span class="special">
};</span></code></pre>
<p>
The vector type is templatized, so that we can use any type of vector:
<span class="bold"><strong>std::vector</strong></span>, <span class="bold"><strong>boost::shmem::vector</strong></span>.... But the storage must be <span class="bold"><strong>contiguous</strong></span>,
we can't use a deque. We can even use <span class="bold"><strong>boost::shmem::basic_string</strong></span>, since it has a 
vector interface and it has contiguous storage. <span class="bold"><strong>We can't use std::string</strong></span>, because 
although some std::string implementation are vector-based, others can have 
optimizations and reference-counted implementations.</p>
<p>
The user can obtain a const reference to the internal vector using 
<code class="computeroutput"><span class="identifier">vector_type</span><span class="identifier"> vector</span><span class="special">()</span><span class="keyword"> const</span></code> function and he also can swap the internal vector
with an external one calling <code class="computeroutput"><span class="keyword">void</span><span class="identifier"> swap_vector</span><span class="special">(</span><span class="identifier">vector_type</span><span class="special"> &amp;</span><span class="identifier">vect</span><span class="special">)</span></code>. 
The swap function resets the stream position.
This functions allow efficient methods to obtain the formatted data avoiding
all allocations and data copies.</p>
<p>
Let's see an example to see how to use vectorstream:</p>
<p></p>
<pre class="programlisting"><code class="literal"><span class="preprocessor">#include</span><span class="special"> &lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">shmem</span><span class="special">/</span><span class="identifier">containers</span><span class="special">/</span><span class="identifier">vector</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="preprocessor">
#include</span><span class="special"> &lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">shmem</span><span class="special">/</span><span class="identifier">containers</span><span class="special">/</span><span class="identifier">string</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="preprocessor">
#include</span><span class="special"> &lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">shmem</span><span class="special">/</span><span class="identifier">named_shared_object</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="preprocessor">
#include</span><span class="special"> &lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">shmem</span><span class="special">/</span><span class="identifier">streams</span><span class="special">/</span><span class="identifier">vectorstream</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="preprocessor">
#include</span><span class="special"> &lt;</span><span class="identifier">iterator</span><span class="special">&gt;</span><span class="keyword">

using</span><span class="keyword"> namespace</span><span class="identifier"> boost</span><span class="special">::</span><span class="identifier">shmem</span><span class="special">;</span><span class="keyword">

typedef</span><span class="identifier"> allocator</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span><span class="identifier"> named_shared_object</span><span class="special">::</span><span class="identifier">segment_manager</span><span class="special">&gt;</span><span class="identifier"> 
   IntAllocator</span><span class="special">;</span><span class="keyword">
typedef</span><span class="identifier"> allocator</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span><span class="identifier"> named_shared_object</span><span class="special">::</span><span class="identifier">segment_manager</span><span class="special">&gt;</span><span class="identifier"> 
   CharAllocator</span><span class="special">;</span><span class="keyword">
typedef</span><span class="identifier"> vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span><span class="identifier"> IntAllocator</span><span class="special">&gt;</span><span class="identifier">   MyVector</span><span class="special">;</span><span class="keyword">
typedef</span><span class="identifier"> basic_string</span><span class="special">
   &lt;</span><span class="keyword">char</span><span class="special">,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">char_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;,</span><span class="identifier"> CharAllocator</span><span class="special">&gt;</span><span class="identifier">   MyString</span><span class="special">;</span><span class="keyword">
typedef</span><span class="identifier"> basic_vectorstream</span><span class="special">&lt;</span><span class="identifier">MyString</span><span class="special">&gt;</span><span class="identifier">               MyVectorStream</span><span class="special">;</span><span class="keyword">

int</span><span class="identifier"> main</span><span class="special"> ()</span><span class="special">
{</span><span class="comment">
   //Create shared memory
</span><span class="identifier">   named_shared_object</span><span class="identifier"> segment</span><span class="special">;</span><span class="keyword">
   if</span><span class="special">(!</span><span class="identifier">segment</span><span class="special">.</span><span class="identifier">create</span><span class="special">(</span><span class="string">"/MySharedMemory"</span><span class="special">,</span><span class="comment">  //segment name
</span><span class="number">                      65536</span><span class="special">)){</span><span class="comment">            //segment size in bytes
</span><span class="keyword">      return</span><span class="special"> -</span><span class="number">1</span><span class="special">;</span><span class="special">
   }</span><span class="comment">

   //Construct shared memory vector
</span><span class="identifier">   MyVector</span><span class="special"> *</span><span class="identifier">myvector</span><span class="special"> =</span><span class="identifier"> 
      segment</span><span class="special">.</span><span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">MyVector</span><span class="special">&gt;(</span><span class="string">"MyVector"</span><span class="special">)</span><span class="special">
      (</span><span class="identifier">IntAllocator</span><span class="special">(</span><span class="identifier">segment</span><span class="special">.</span><span class="identifier">get_segment_manager</span><span class="special">()));</span><span class="comment">

   //Fill vector
</span><span class="identifier">   myvector</span><span class="special">-&gt;</span><span class="identifier">reserve</span><span class="special">(</span><span class="number">100</span><span class="special">);</span><span class="keyword">
   for</span><span class="special">(</span><span class="keyword">int</span><span class="identifier"> i</span><span class="special"> =</span><span class="number"> 0</span><span class="special">;</span><span class="identifier"> i</span><span class="special"> &lt;</span><span class="number"> 100</span><span class="special">;</span><span class="special"> ++</span><span class="identifier">i</span><span class="special">){</span><span class="identifier">
      myvector</span><span class="special">-&gt;</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span><span class="special">
   }</span><span class="comment">

   //Create the vectorstream. To create the internal shared memory
   //basic_string we need to pass the shared memory allocator as
   //a constructor argument
</span><span class="identifier">   MyVectorStream</span><span class="identifier"> myvectorstream</span><span class="special">(</span><span class="identifier">CharAllocator</span><span class="special">(</span><span class="identifier">segment</span><span class="special">.</span><span class="identifier">get_segment_manager</span><span class="special">()));</span><span class="comment">

   //Resize the internal string
</span><span class="identifier">   myvectorstream</span><span class="special">.</span><span class="identifier">resize</span><span class="special">(</span><span class="number">100</span><span class="special">*</span><span class="number">5</span><span class="special">);</span><span class="comment">

   //Write all vector elements as text in the internal string
   //Data will be directly written in shared memory, because
   //internal string's allocator is a shared memory allocator
</span><span class="keyword">   for</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="identifier"> i</span><span class="special"> =</span><span class="number"> 0</span><span class="special">,</span><span class="identifier"> max</span><span class="special"> =</span><span class="identifier"> myvector</span><span class="special">-&gt;</span><span class="identifier">size</span><span class="special">();</span><span class="identifier"> i</span><span class="special"> &lt;</span><span class="identifier"> max</span><span class="special">;</span><span class="special"> ++</span><span class="identifier">i</span><span class="special">){</span><span class="identifier">
      myvectorstream</span><span class="special"> &lt;&lt;</span><span class="special"> (*</span><span class="identifier">myvector</span><span class="special">)[</span><span class="identifier">i</span><span class="special">]</span><span class="special"> &lt;&lt;</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><span class="special">
   }</span><span class="comment">

   //Auxiliary vector to compare original data
</span><span class="identifier">   MyVector</span><span class="special"> *</span><span class="identifier">myvector2</span><span class="special"> =</span><span class="identifier">
      segment</span><span class="special">.</span><span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">MyVector</span><span class="special">&gt;(</span><span class="string">"MyVector2"</span><span class="special">)</span><span class="special">
      (</span><span class="identifier">IntAllocator</span><span class="special">(</span><span class="identifier">segment</span><span class="special">.</span><span class="identifier">get_segment_manager</span><span class="special">()));</span><span class="comment">

   //Avoid reallocations
</span><span class="identifier">   myvector2</span><span class="special">-&gt;</span><span class="identifier">reserve</span><span class="special">(</span><span class="number">100</span><span class="special">);</span><span class="comment">

   //Extract all values from the internal 
   //string directly to a shared memory vector.
</span><span class="identifier">   std</span><span class="special">::</span><span class="identifier">istream_iterator</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span><span class="identifier"> it</span><span class="special">(</span><span class="identifier">myvectorstream</span><span class="special">),</span><span class="identifier"> itend</span><span class="special">;</span><span class="identifier">
   std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span><span class="identifier">it</span><span class="special">,</span><span class="identifier"> itend</span><span class="special">,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">back_inserter</span><span class="special">(*</span><span class="identifier">myvector2</span><span class="special">));</span><span class="comment">

   //Compare vectors
</span><span class="identifier">   assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal</span><span class="special">(</span><span class="identifier">myvector</span><span class="special">-&gt;</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier"> myvector</span><span class="special">-&gt;</span><span class="identifier">end</span><span class="special">(),</span><span class="identifier"> myvector2</span><span class="special">-&gt;</span><span class="identifier">begin</span><span class="special">()));</span><span class="comment">

   //Create a copy of the internal string
</span><span class="identifier">   MyString</span><span class="identifier"> stringcopy</span><span class="special"> (</span><span class="identifier">myvectorstream</span><span class="special">.</span><span class="identifier">vector</span><span class="special">());</span><span class="comment">

   //Now we create a new empty shared memory string...
</span><span class="identifier">   MyString</span><span class="special"> *</span><span class="identifier">mystring</span><span class="special"> =</span><span class="identifier"> 
      segment</span><span class="special">.</span><span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">MyString</span><span class="special">&gt;(</span><span class="string">"MyString"</span><span class="special">)</span><span class="special">
      (</span><span class="identifier">CharAllocator</span><span class="special">(</span><span class="identifier">segment</span><span class="special">.</span><span class="identifier">get_segment_manager</span><span class="special">()));</span><span class="comment">

   //...and we swap vectorstream's internal string
   //with the new one: after this statement mystring
   //will be the owner of the formatted data.
   //No reallocations, no data copies
</span><span class="identifier">   myvectorstream</span><span class="special">.</span><span class="identifier">swap_vector</span><span class="special">(*</span><span class="identifier">mystring</span><span class="special">);</span><span class="comment">

   //Let's compare both strings
</span><span class="identifier">   assert</span><span class="special">(</span><span class="identifier">stringcopy</span><span class="special"> ==</span><span class="special"> *</span><span class="identifier">mystring</span><span class="special">);</span><span class="comment">

   //Done, destroy and delete vectors and string from the segment
</span><span class="identifier">   segment</span><span class="special">.</span><span class="identifier">destroy_ptr</span><span class="special">(</span><span class="identifier">myvector2</span><span class="special">);</span><span class="identifier">
   segment</span><span class="special">.</span><span class="identifier">destroy_ptr</span><span class="special">(</span><span class="identifier">myvector</span><span class="special">);</span><span class="identifier">
   segment</span><span class="special">.</span><span class="identifier">destroy_ptr</span><span class="special">(</span><span class="identifier">mystring</span><span class="special">);</span><span class="keyword">
   return</span><span class="number"> 0</span><span class="special">;</span><span class="special">
}</span></code></pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="shmem.bufferstream"></a> Formatting directly in your character buffer: bufferstream</h3></div></div></div>
<p>
As seen, vectorstream offers an easy and secure way for efficient iostream
formatting, but many times, we have to read or write formatted data from/to a
fixed size character buffer (a static buffer, a c-string, or any other).
Because of the overhead of stringstream, many developers (specially in 
embedded systems) choose sprintf family. The <span class="bold"><strong>bufferstream</strong></span> classes offer 
iostream interface with direct formatting in a fixed size memory buffer with 
protection against buffer overflows. This is the interface:</p>
<pre class="programlisting"><code class="literal"><span class="comment">/*!A streambuf class that controls the transmission of elements to and from
   a basic_xbufferstream. The elements are transmitted from a to a fixed
   size buffer*/</span><span class="keyword">
template</span><span class="special"> &lt;</span><span class="keyword">class</span><span class="identifier"> CharT</span><span class="special">,</span><span class="keyword"> class</span><span class="identifier"> CharTraits</span><span class="special"> =</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">char_traits</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">&gt;</span><span class="special"> &gt;</span><span class="keyword">
class</span><span class="identifier"> basic_bufferbuf</span><span class="special"> 
   :</span><span class="keyword"> public</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_streambuf</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;</span><span class="special">
{</span><span class="keyword">
   public</span><span class="special">:</span><span class="keyword">
   typedef</span><span class="identifier"> CharT</span><span class="identifier">                             char_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> CharTraits</span><span class="special">::</span><span class="identifier">int_type</span><span class="identifier">     int_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> CharTraits</span><span class="special">::</span><span class="identifier">pos_type</span><span class="identifier">     pos_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> CharTraits</span><span class="special">::</span><span class="identifier">off_type</span><span class="identifier">     off_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="identifier"> CharTraits</span><span class="identifier">                        traits_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_streambuf</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span><span class="identifier"> traits_type</span><span class="special">&gt;</span><span class="identifier"> base_t</span><span class="special">;</span><span class="keyword">

   public</span><span class="special">:</span><span class="comment">
   /*!Constructor. Does not throw.*/</span><span class="keyword">
   explicit</span><span class="identifier"> basic_bufferbuf</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">openmode</span><span class="identifier"> mode</span><span class="special">
                            =</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">in</span><span class="special"> |</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">out</span><span class="special">);</span><span class="comment">

   /*!Constructor. Assigns formatting buffer. Does not throw.*/</span><span class="keyword">
   explicit</span><span class="identifier"> basic_bufferbuf</span><span class="special">(</span><span class="identifier">CharT</span><span class="special"> *</span><span class="identifier">buffer</span><span class="special">,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">size_t</span><span class="identifier"> length</span><span class="special">,</span><span class="identifier"> 
                            std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">openmode</span><span class="identifier"> mode</span><span class="special">
                              =</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">in</span><span class="special"> |</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">out</span><span class="special">);</span><span class="comment">

   /*!Returns the pointer and size of the internal buffer. 
      Does not throw.*/</span><span class="identifier">
   std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special"> *,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">&gt;</span><span class="identifier"> buffer</span><span class="special">()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Sets the underlying buffer to a new value. Does not throw.*/</span><span class="keyword">
   void</span><span class="identifier"> buffer</span><span class="special">(</span><span class="identifier">CharT</span><span class="special"> *</span><span class="identifier">buffer</span><span class="special">,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">size_t</span><span class="identifier"> length</span><span class="special">);</span><span class="special">
};</span><span class="comment">

/*!A basic_iostream class that uses a fixed size character buffer
   as it's formatting buffer.*/</span><span class="keyword">
template</span><span class="special"> &lt;</span><span class="keyword">class</span><span class="identifier"> CharT</span><span class="special">,</span><span class="keyword"> class</span><span class="identifier"> CharTraits</span><span class="special"> =</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">char_traits</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">&gt;</span><span class="special"> &gt;</span><span class="keyword">
class</span><span class="identifier"> basic_bufferstream</span><span class="special"> 
   :</span><span class="keyword"> public</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_iostream</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;</span><span class="special">

{</span><span class="keyword">
   public</span><span class="special">:</span><span class="comment">                         // Typedefs
</span><span class="keyword">   typedef</span><span class="keyword"> typename</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_ios</span><span class="special">
      &lt;</span><span class="identifier">CharT</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;::</span><span class="identifier">char_type</span><span class="identifier">          char_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_ios</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;::</span><span class="identifier">int_type</span><span class="identifier">     int_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_ios</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;::</span><span class="identifier">pos_type</span><span class="identifier">     pos_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_ios</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;::</span><span class="identifier">off_type</span><span class="identifier">     off_type</span><span class="special">;</span><span class="keyword">
   typedef</span><span class="keyword"> typename</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">basic_ios</span><span class="special">&lt;</span><span class="identifier">char_type</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;::</span><span class="identifier">traits_type</span><span class="identifier">  traits_type</span><span class="special">;</span><span class="comment">
   
   /*!Constructor. Does not throw.*/</span><span class="identifier">
   basic_bufferstream</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">openmode</span><span class="identifier"> mode</span><span class="special"> 
                     =</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">in</span><span class="special"> |</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">out</span><span class="special">);</span><span class="comment">

   /*!Constructor. Assigns formatting buffer. Does not throw.*/</span><span class="identifier">
   basic_bufferstream</span><span class="special">(</span><span class="identifier">CharT</span><span class="special"> *</span><span class="identifier">buffer</span><span class="special">,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">size_t</span><span class="identifier"> length</span><span class="special">,</span><span class="identifier">
                     std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">openmode</span><span class="identifier"> mode</span><span class="special">
                        =</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">in</span><span class="special"> |</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">out</span><span class="special">);</span><span class="comment">

   /*!Returns the address of the stored stream buffer.*/</span><span class="identifier">
   basic_bufferbuf</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">,</span><span class="identifier"> CharTraits</span><span class="special">&gt;*</span><span class="identifier"> rdbuf</span><span class="special">()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Returns the pointer and size of the internal buffer. 
      Does not throw.*/</span><span class="identifier">
   std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special"> *,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">&gt;</span><span class="identifier"> buffer</span><span class="special">()</span><span class="keyword"> const</span><span class="special">;</span><span class="comment">

   /*!Sets the underlying buffer to a new value. Resets 
      stream position. Does not throw.*/</span><span class="keyword">
   void</span><span class="identifier"> buffer</span><span class="special">(</span><span class="identifier">CharT</span><span class="special"> *</span><span class="identifier">buffer</span><span class="special">,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">size_t</span><span class="identifier"> length</span><span class="special">);</span><span class="special">
};</span><span class="comment">   

//Some typedefs to simplify usage
</span><span class="keyword">typedef</span><span class="identifier"> basic_bufferbuf</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span><span class="identifier">        bufferbuf</span><span class="special">;</span><span class="keyword">
typedef</span><span class="identifier"> basic_bufferstream</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span><span class="identifier">     bufferstream</span><span class="special">;</span><span class="keyword">
typedef</span><span class="identifier"> basic_ibufferstream</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span><span class="identifier">    ibufferstream</span><span class="special">;</span><span class="keyword">
typedef</span><span class="identifier"> basic_obufferstream</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span><span class="identifier">    obufferstream</span><span class="special">;</span><span class="keyword">

typedef</span><span class="identifier"> basic_bufferbuf</span><span class="special">&lt;</span><span class="keyword">wchar_t</span><span class="special">&gt;</span><span class="identifier">     wbufferbuf</span><span class="special">;</span><span class="keyword">
typedef</span><span class="identifier"> basic_bufferstream</span><span class="special">&lt;</span><span class="keyword">wchar_t</span><span class="special">&gt;</span><span class="identifier">  wbufferstream</span><span class="special">;</span><span class="keyword">
typedef</span><span class="identifier"> basic_ibufferstream</span><span class="special">&lt;</span><span class="keyword">wchar_t</span><span class="special">&gt;</span><span class="identifier"> wibufferstream</span><span class="special">;</span><span class="keyword">
typedef</span><span class="identifier"> basic_obufferstream</span><span class="special">&lt;</span><span class="keyword">wchar_t</span><span class="special">&gt;</span><span class="identifier"> wobufferstream</span><span class="special">;</span></code></pre>
<p>
While reading from a fixed size buffer, <span class="bold"><strong>bufferstream</strong></span> activates endbit flag if
we try to read an address beyond the end of the buffer. While writing to a
fixed size buffer, <span class="bold"><strong>bufferstream</strong></span> will active the badbit flag if a buffer overflow
is going to happen and disallows writing. This way, the fixed size buffer 
formatting through <span class="bold"><strong>bufferstream</strong></span> is secure and efficient, and offers a good 
alternative to sprintf/sscanf functions. Let's see an example:</p>
<p></p>
<pre class="programlisting"><code class="literal"><span class="preprocessor">#include</span><span class="special"> &lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">shmem</span><span class="special">/</span><span class="identifier">named_shared_object</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="preprocessor">
#include</span><span class="special"> &lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">shmem</span><span class="special">/</span><span class="identifier">streams</span><span class="special">/</span><span class="identifier">bufferstream</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span><span class="preprocessor">
#include</span><span class="special"> &lt;</span><span class="identifier">vector</span><span class="special">&gt;</span><span class="preprocessor">
#include</span><span class="special"> &lt;</span><span class="identifier">iterator</span><span class="special">&gt;</span><span class="keyword">

using</span><span class="keyword"> namespace</span><span class="identifier"> boost</span><span class="special">::</span><span class="identifier">shmem</span><span class="special">;</span><span class="keyword">

int</span><span class="identifier"> main</span><span class="special"> ()</span><span class="special">
{</span><span class="comment">
   //Create shared memory
</span><span class="identifier">   named_shared_object</span><span class="identifier"> segment</span><span class="special">;</span><span class="keyword">
   if</span><span class="special">(!</span><span class="identifier">segment</span><span class="special">.</span><span class="identifier">create</span><span class="special">(</span><span class="string">"/MySharedMemory"</span><span class="special">,</span><span class="comment">  //segment name
</span><span class="number">                      65536</span><span class="special">)){</span><span class="comment">            //segment size in bytes
</span><span class="keyword">      return</span><span class="special"> -</span><span class="number">1</span><span class="special">;</span><span class="special">
   }</span><span class="comment">

   //Fill data
</span><span class="identifier">   std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span><span class="identifier"> data</span><span class="special">,</span><span class="identifier"> data2</span><span class="special">;</span><span class="identifier">
   data</span><span class="special">.</span><span class="identifier">reserve</span><span class="special">(</span><span class="number">100</span><span class="special">);</span><span class="keyword">
   for</span><span class="special">(</span><span class="keyword">int</span><span class="identifier"> i</span><span class="special"> =</span><span class="number"> 0</span><span class="special">;</span><span class="identifier"> i</span><span class="special"> &lt;</span><span class="number"> 100</span><span class="special">;</span><span class="special"> ++</span><span class="identifier">i</span><span class="special">){</span><span class="identifier">
      data</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span><span class="special">
   }</span><span class="comment">

   //Allocate a buffer in shared memory to write data
</span><span class="keyword">   char</span><span class="special"> *</span><span class="identifier">my_cstring</span><span class="special"> =</span><span class="identifier"> 
      segment</span><span class="special">.</span><span class="identifier">construct</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;(</span><span class="string">"MyCString"</span><span class="special">)[</span><span class="number">100</span><span class="special">*</span><span class="number">5</span><span class="special">](</span><span class="number">0</span><span class="special">);</span><span class="identifier">
   bufferstream</span><span class="identifier"> mybufstream</span><span class="special">(</span><span class="identifier">my_cstring</span><span class="special">,</span><span class="number"> 100</span><span class="special">*</span><span class="number">5</span><span class="special">);</span><span class="comment">

   //Now write data to the buffer
</span><span class="keyword">   for</span><span class="special">(</span><span class="keyword">int</span><span class="identifier"> i</span><span class="special"> =</span><span class="number"> 0</span><span class="special">;</span><span class="identifier"> i</span><span class="special"> &lt;</span><span class="number"> 100</span><span class="special">;</span><span class="special"> ++</span><span class="identifier">i</span><span class="special">){</span><span class="identifier">
      mybufstream</span><span class="special"> &lt;&lt;</span><span class="identifier"> data</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span><span class="special"> &lt;&lt;</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><span class="special">
   }</span><span class="comment">

   //Check there was no overflow attempt
</span><span class="identifier">   assert</span><span class="special">(</span><span class="identifier">mybufstream</span><span class="special">.</span><span class="identifier">good</span><span class="special">());</span><span class="comment">

   //Extract all values from the shared memory string
   //directly to a shared memory vector.
</span><span class="identifier">   data2</span><span class="special">.</span><span class="identifier">reserve</span><span class="special">(</span><span class="number">100</span><span class="special">);</span><span class="identifier">
   std</span><span class="special">::</span><span class="identifier">istream_iterator</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span><span class="identifier"> it</span><span class="special">(</span><span class="identifier">mybufstream</span><span class="special">),</span><span class="identifier"> itend</span><span class="special">;</span><span class="identifier">
   std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span><span class="identifier">it</span><span class="special">,</span><span class="identifier"> itend</span><span class="special">,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">back_inserter</span><span class="special">(</span><span class="identifier">data2</span><span class="special">));</span><span class="comment">

   //This extraction should have ended will fail error
   //since the numbers formatted in the buffer end
   //before the end of the buffer. (Otherwise it would
   //trigger eofbit)
</span><span class="identifier">   assert</span><span class="special">(</span><span class="identifier">mybufstream</span><span class="special">.</span><span class="identifier">fail</span><span class="special">());</span><span class="comment">

   //Compare data
</span><span class="identifier">   assert</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal</span><span class="special">(</span><span class="identifier">data</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span><span class="identifier"> data</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span><span class="identifier"> data2</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()));</span><span class="comment">

   //Clear errors and rewind
</span><span class="identifier">   mybufstream</span><span class="special">.</span><span class="identifier">clear</span><span class="special">();</span><span class="identifier">
   mybufstream</span><span class="special">.</span><span class="identifier">seekp</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">ios</span><span class="special">::</span><span class="identifier">beg</span><span class="special">);</span><span class="comment">
   
   //Now write again the data trying to do a buffer overflow
</span><span class="keyword">   for</span><span class="special">(</span><span class="keyword">int</span><span class="identifier"> i</span><span class="special"> =</span><span class="number"> 0</span><span class="special">;</span><span class="identifier"> i</span><span class="special"> &lt;</span><span class="number"> 500</span><span class="special">;</span><span class="special"> ++</span><span class="identifier">i</span><span class="special">){</span><span class="identifier">
      mybufstream</span><span class="special"> &lt;&lt;</span><span class="identifier"> data</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span><span class="special"> &lt;&lt;</span><span class="identifier"> std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span><span class="special">
   }</span><span class="comment">

   //Now make sure badbit is active
   //which means overflow attempt.
</span><span class="identifier">   assert</span><span class="special">(!</span><span class="identifier">mybufstream</span><span class="special">.</span><span class="identifier">good</span><span class="special">());</span><span class="identifier">
   assert</span><span class="special">(</span><span class="identifier">mybufstream</span><span class="special">.</span><span class="identifier">bad</span><span class="special">());</span><span class="identifier">
   segment</span><span class="special">.</span><span class="identifier">destroy_ptr</span><span class="special">(</span><span class="identifier">my_cstring</span><span class="special">);</span><span class="keyword">      
   return</span><span class="number"> 0</span><span class="special">;</span><span class="special">
}</span></code></pre>
<p>
As seen, <span class="bold"><strong>bufferstream</strong></span> offers an efficient way to format data without any 
allocation and extra copies. This is very helpful in embedded systems, or
formatting inside time-critical loops, where stringstream extra copies would
be too expensive. Unlike sprintf/sscanf, it has protection against buffer
overflows. As we know, according to the <span class="bold"><strong>Technical Report on C++ Performance</strong></span>, 
it's possible to design efficient iostreams for embedded platforms, so this 
bufferstream class comes handy to format data to stack, static or shared memory
buffers.</p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><small>Copyright © 2005 - 2006 Ion Gaztañaga</small></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="beyond_shared_memory.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="shmem_smart_ptr.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
