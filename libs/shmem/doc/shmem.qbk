[library Shmem
    [version 2005-12-30]
    [authors [Gazta&ntilde;aga, Ion]]
    [copyright 2005 Ion Gazta&ntilde;aga]
    [purpose Shared memory utilities]
    [license
         Distributed under the Boost Software License, Version 1.0.
         (See accompanying file LICENSE_1_0.txt or copy at
         <ulink url="http://www.boost.org/LICENSE_1_0.txt">
            http://www.boost.org/LICENSE_1_0.txt
         </ulink>)
    ]
    [last-revision $Date$]
]

[/ QuickBook Document version 1.1 ]


[section:intro Introduction]


[section:disclaimer Disclaimer: Shmem is NOT a Boost library]

The Shmem library is being developed under Boost libraries conditions since a
Boost review process will possibly be requested in a near future, to check if 
this library is good enough to be part of Boost libraries.

Shmem classes are contained in boost::shmem namespace but this namespace is 
not reserved in Boost for this library, although this library is being 
developed and improved by Boost mailing list members.
  
[endsect]

[section:introduction Introduction]

The Shmem Library simplifies the use of shared memory and provides 
some STL compatible allocators that allow shared memory STL container 
placement. It also offers helper classes, such as offset pointers, 
process shared mutexes, condition variables, and named semaphores.

Library user can apply all STL algorithms and utilities with 
created shared memory objects. Shmem also wants to present 
a portable implementation, unifying UNIX and Windows shared 
memory object creation, providing simple wrapper classes. 

Shmem offers the following to the user:

*  [link shmem.oswrappers Portable synchronization 
   primitives] for shared memory, including shared 
   mutexes and shared condition variables.

*  [link shmem.allocate_deallocate Dynamic allocation] of portions of a shared memory segment.

*  [link shmem.named_shared_object 
   Named allocation in shared memory.] Shmem can create objects in shared memory 
   and associate it with a c-string offering a similar mechanism to a named
   new/delete. Created object can be found by other processes using Shmem framework.

*  [link shmem.offset_ptr 
   Offset pointers] that can be safely placed in shared memory to point to 
   another object of the same shared memory segment even if the memory is mapped 
   to a different address.

*  [link shmem.stl_allocators STL compatible shared memory allocators] 
   so that STL containers can be placed in shared memory. Shmem also offers 
   a pooled node allocator to save and optimize shared memory allocation in 
   node containers.

*  [link shmem.containers STL compatible containers] for systems with STL 
   implementations that cannot deal with shared memory. The user can map shared 
   memory to different addresses and use STL compatible containers and algorithms. 
   Useful to store common data or implement shared memory databases. These 
   containers also show how STL compatible containers can make use of shared 
   memory STL compatible allocators to place such containers in the shared 
   memory. Shmem also offers the basic_string pseudo-container to use 
   full-powered C++ strings in shared memory.

[endsect]

[endsect]


[section:quick_guide Quick Guide for the Impatient]

[section:qg_memory_pool Using shared memory as a pool of unnamed memory blocks]

You can just allocate a portion of a shared memory segment, copy the 
message to that buffer, send the offset of that portion of shared 
memory to another process, and you are done. Let's see the example:
     
[/include doc/doc_ipc_messageA.cpp]

[/ shmem_doc_ipc_messageA.cpp]

[c++]


   #include <boost/shmem/named_shared_object.hpp>
   #include <cstddef>

   int main ()
   {
      using namespace boost::shmem;

      //A shared memory front-end that is able to 
      //allocate raw memory buffers from a shared memory segment
      named_shared_object segment;

      //Create the shared memory segment and initialize needed resources
      if(!segment.create("/MySharedMemory",  //segment name
                        65536)){            //segment size in bytes
         return -1;
      }

      //Allocate a portion of the segment
      void * shptr   = segment.allocate(1024/*bytes to allocate*/);

      //An offset from the base address can identify any byte of the shared 
      //memory segment even if it is mapped in different base addresses
      std::ptrdiff_t offset = segment.get_offset_from_address(shptr);
      (void)offset;
      // Copy message to buffer
      // . . .
      // Send offset to other process
      // . . .
      // Wait response from other process
      // . . .

      //Deallocate the portion previously allocated
      segment.deallocate(shptr);
      return 0;
   }


In receiver process one just could write the following lines:

[/ shmem_doc_ipc_messageB.cpp]
[c++]

   #include <boost/shmem/named_shared_object.hpp>
   #include <cstddef>

   int main ()
   {
      using namespace boost::shmem;

      //A shared memory front-end that is able to 
      //allocate raw memory buffers from a shared memory segment
      named_shared_object segment;

      //Connect to the shared memory segment and initialize needed resources
      if(!segment.open("/MySharedMemory")){  //segment name
         return -1;
      }

      //An offset from the base address can identify any byte of the shared 
      //memory segment even if it is mapped in different base addresses
      std::ptrdiff_t offset = 0;

      //Wait offset msg from the other process and put it in
      //"offset" local variable
      //Get buffer local address from offset
      void *msg = segment.get_address_from_offset(offset);
      (void)msg;
      //Do anything with msg
      //. . .
      //Send ack to sender process
      return 0;
   }

[endsect]


[section:qg_named_shmem Creating named shared memory objects]

You want to create objects in a shared memory segment, giving a string name to them so that 
any other process can find, use and delete them from the segment when the objects are not 
needed anymore. Just write this code in one process:

[/ shmem_doc_name_allocA ]
[c++]

   #include <boost/shmem/named_shared_object.hpp>

   int main ()
   {
      using namespace boost::shmem;
      typedef std::pair<double, int> MyType;

      //A shared memory front-end that is able to construct 
      //objects associated with a c-string
      named_shared_object segment;

      //Create the shared memory segment and initialize resources
      if(!segment.create("/MySharedMemory",  //segment name
                         65536)){            //segment size in bytes
         return -1;
      }
                     

      //Create an object of MyType initialized to {0.0, 0}
      MyType *instance = segment.construct<MyType>
         ("MyType instance")  /*name of the object*/
         (0.0                 /*ctor first argument*/,
          0                   /*ctor second argument*/);    

      //Create an array of 10 elements of MyType initialized to {0.0, 0}
      MyType *array = segment.construct<MyType>
         ("MyType array")     /*name of the object*/
         [10]                 /*number of elements*/
         (0.0                 /*ctor first argument*/,
          0                   /*ctor second argument*/);    
      return 0;
   }

In other process, while the first process is alive, execute the following:

[/ shmem_doc_name_allocB ]
[c++]

   #include <boost/shmem/named_shared_object.hpp>
   #include <cstddef>
   #include <assert.h>

   int main ()
   {
      using namespace boost::shmem;
      typedef std::pair<double, int> MyType;

      //A shared memory front-end that is able to construct 
      //objects associated with a c-string
      named_shared_object segment;

      //Connect to the shared memory segment and initialize resources
      if(!segment.open("/MySharedMemory")){
         return -1;
      }

      //Find the array and object
      std::pair<MyType*, std::size_t> res;
      res = segment.find<MyType> ("MyType array");   

      std::size_t array_len   = res.second;
      //Length should be 10
      assert(array_len == 10);

      //Find the array and the object
      res = segment.find<MyType> ("MyType instance");   

      std::size_t len   = res.second;

      //Length should be 1
      assert(len == 1);

      //Use data
      // . . . 

      //We're done, delete array from memory
      segment.destroy<MyType>("MyType array");

      //We're done, delete object from memory
      segment.destroy<MyType>("MyType instance");
      return 0;
   }


[endsect]

[section:qg_offset_ptr Using an offset smart pointer for shared memory]

Shmem offers offset_ptr smart pointer family 
as an offset pointer that stores the distance between the address of 
the offset pointer itself and the address of the pointed object.  
When this pointer is placed in a shared memory segment, it 
can point safely objects stored in the same shared 
memory segment, even if the segment is mapped in 
different base addresses in different processes.

This allows placing objects with pointer members 
in shared memory. For example, if we want to create 
a linked list in shared memory:

[/ shmem_doc_offset_ptr]
[c++]

   #include <boost/shmem/named_shared_object.hpp>
   #include <boost/shmem/offset_ptr.hpp>

   using namespace boost::shmem;

   //Shared memory linked list node
   struct list_node
   {
      offset_ptr<list_node> next;
      int                   value;
   };

   int main ()
   {
      //Create shared memory
      named_shared_object segment;
      segment.create("/MySharedMemory",//segment name
                     65536);           //segment size in bytes

      //Create linked list with 10 nodes in shared memory
      offset_ptr<list_node> prev = 0, current, first;

      int i;
      for(i = 0; i < 10; ++i, prev = current){
         current = static_cast<list_node*>(segment.allocate(sizeof(list_node)));
         current->value = i;
         current->next  = 0;

         if(!prev)
            first = current;
         else
            prev->next = current;
      }

      //Communicate list to other processes
      //. . .
      //When done, destroy list
      for(current = first; current; /**/){
         prev = current;
         current = current->next
         segment.deallocate(prev.get());
      }
      return 0;
   }

To help with basic data structures, Shmem offers containers like vector, list, map,
so you can avoid these manual data structures just like with standard containers.

[endsect]

[section:qg_shmem_container Creating vectors in shared memory with different base addresses]

To place STL-compatible containers in shared memory, Shmem allocators
define allocator<T>::pointer typedef as offset_ptr<T>, instead of T*.
Although the use of smart pointers is allowed by the standard, 
current STL implementations can't handle Shmem shared memory STL 
compatible allocators. 

Until STL implementations fix this and for older STL owners, 
Shmem provides STL compatible containers. 
All these containers can be safely placed 
in shared memory. For this, we need to obtain STL compatible 
shared memory allocators and pass them to the Shmem containers
in constructors:
      
[c++]

   #include <boost/shmem/containers/vector.hpp>
   #include <boost/shmem/named_shared_object.hpp>
   #include <algorithm>

   int main ()
   {
      using namespace boost::shmem;

      //Shared memory front-end that is able to construct objects
      //associated with a c-string
      named_shared_object segment;

      //Create the memory segment and initialize resources
      if(!segment.create("/MySharedMemory",  //segment name
                         65536)){            //segment size in bytes
         return -1;
      }

      //Alias an STL compatible allocator of ints that allocates ints from the segment
      typedef allocator<int, named_shared_object::segment_manager> ShmemAllocator;

      //Alias a vector that uses the previous STL compatible allocator
      typedef boost::shmem::vector<int, ShmemAllocator> MyVector;

      int initVal[] = {0, 1, 2, 3, 4, 5, 6 };
      const int *begVal    = initVal;
      const int *endVal    = initVal + sizeof(initVal)/sizeof(initVal[0]);

      //Initialize the STL compatible allocator
      const ShmemAllocator alloc_inst (segment.get_segment_manager());

      //Construct the vector in the shared memory segment with the STL compatible allocator 
      //from a range of iterators
      MyVector *myvector = 
         segment.construct<MyVector>
           ("MyVector")/*object name*/
           (begVal     /*first ctor parameter*/,
            endVal     /*second ctor parameter*/, 
            alloc_inst /*third ctor parameter*/); 

      //Use vector as your want
      std::sort(myvector->rbegin(), myvector->rend());
      // . . .
      //When done, destroy and delete vector from the segment
      segment.destroy<MyVector>("MyVector");
      return 0;
   }

[endsect]

[section:qg_mapping Using STL containers and mapping the memory at a fixed address]

By default, Shmem maps the shared memory in an address chosen by the operating system, 
but you can change this. If your STL implementation is not compatible with Shmem STL 
compatible allocators or if you prefer to use raw pointers instead of offset ones 
to obtain better performance (a offset pointer assignment needs a couple of arithmetic operations)
and forget about managing offset_ptr-s, you can specify the mapping address. To do this, 
you just have to create the shared memory passing the desired address in one process and 
use a Shmem STL compatible allocator with a raw pointer as allocator::pointer typedef.

[c++]

   #include <vector>
   #include <boost/shmem/named_shared_object.hpp>

   int main ()
   {
      using namespace boost::shmem;
      //Shared memory front-end that is able to construct objects
      //associated with a c-string
      fixed_named_shared_object segment;

      //Create the memory segment at the specified address and initialize resources
      segment.create("/MySharedMemory",  //segment name
                     65536,              //segment size in bytes
                     (void*)0x03000000); //mapping address

      //Alias an STL compatible allocator of ints that allocates ints from the segment
      //and that defines allocator::pointer as "int *". This allocator will be compatible
      //with most STL implementations.
      typedef allocator<int, fixed_named_shared_object::segment_manager> 
         ShmemAllocator;

      //Alias a vector that uses the previous STL-like allocator
      typedef std::vector<int, ShmemAllocator> MyVector;

      //Initialize shared memory STL-compatible allocator
      const ShmemAllocator alloc_inst (segment.get_segment_manager());

      //Initialize vector
      MyVector *myvector = 
         segment.construct<MyVector>("MyVector") //object name
                                    (alloc_inst);//first ctor parameter 
      (void)myvector;
      return 0;
   }


Other process can open the segment and map it in the same 
address. The container can be found using the Shmem 
framework. 
      
[c++]

   #include <vector>
   #include <boost/shmem/named_shared_object.hpp>

   int main ()
   {
      using namespace boost::shmem;
       //Shared memory front-end that is able to construct objects
      //associated with a c-string
      fixed_named_shared_object segment;

      //Open the memory segment at the specified address and initialize resources
      if(!segment.open("/MySharedMemory",    //segment name
                       (void*)0x03000000)){  //mapping address
         return -1;
      }

      //Alias an STL compatible allocator of ints that allocates ints from the segment
      //and that defines allocator::pointer as "int *". This allocator will be compatible
      //with most STL implementations.
      typedef allocator<int, fixed_named_shared_object::segment_manager> 
         ShmemAllocator;

      //Alias a vector that uses the previous STL-like allocator
      typedef std::vector<int, ShmemAllocator> MyVector;

      //Find the vector using the c-string name
      MyVector *myvector = segment.find<MyVector>("MyVector").first;

      //Use vector as you want
      std::sort(myvector->rbegin(), myvector->rend());
      // . . .

      //When done, destroy and delete vector
      segment.destroy<MyVector>("MyVector");
   }

[endsect]

[endsect]


[section:limitations Current limitations]

[section:growing_limitation Memory growth Limitation]

Shmem wants to be portable across multiple operating systems
so that it can not count with an operating systems that maps shared
memory to the same base address in all processes in the system,
although it provides a way to map the shared memory in the same
base address.

However, without this capability, it is quite complicated to
design a growing shared memory allocator, one that allocates
new shared memory segments when a segment is full of objects.
To achieve this, it would be necessary to maintain a map with the
base address for each process in the shared memory, and a correct
design would be difficult. For this reason, this first version of
this library will be limited to a shared memory segment, and its
size must be calculated beforehand by the user. If there is no more
memory, an exception will be thrown. This is very performance
friendly, but it is also a limiting factor. In near future, there
is a plan to add growing capacity to the allocator.

[endsect]

[section:stl_limitation Problems with most STL implementations]

Since Shmem does not count with same mapping address in
different processes for the same shared memory segment, it
must use a new, offset containing smart pointer. Many STL 
container implementations, suppose that
allocator::pointer type is a raw pointer, so they do not
allow Shmem allocators to be used in those containers. Currently, I 
am not aware of any STL implementation that works with this smart 
pointer approach. Dinkumware STL from Visual .NET 2003 is very
close, but fails in some instantiations. libstdc++ and STLPort
use directly raw pointers in containers, and they don't pay 
attention to this allocator::pointer type. This is likely 
to change soon, as soon as containers start using allocators 
with pointer types different from T*.

To solve this, Shmem provides some STL compliant
containers, that are ready to use with shared memory. 
These implementations, valid for both normal 
(std::)allocator and shared memory allocator, 
implement the techniques described in the
[link shmem.stl_container_requirements "Container requirements for Shmem allocators"]
section.

[endsect]

[section:offset_pointer Offset pointers instead of raw pointers]

When placing objects in shared memory and mapping
that memory in different segments in different processes,
raw pointers are a problem since they are only valid for
the process that placed them there. To solve this, Shmem offers
an offset pointer that can be used instead of a raw pointer.

But user classes containing raw pointers (or Boost smart pointers, that 
internally own a raw pointer) can't be safely placed in shared memory. 
These pointers must be replaced with offset pointers, and these
pointers must point only to objects placed in the same memory
segment if you want to use these shared objects from different processes.

[endsect]

[section:references_forbidden References forbidden]

References suffer from the same problem as pointers 
(mainly because they are implemented as pointers).
However, it is not possible to create a fully workable 
smart reference currently in C++(for example,
"operator dot" can't be overloaded). Because of this,
if the user wants to put an object in shared memory, 
the object can't have any member (smart or not) reference.

References will only work if memory is mapped in the same
base address in all processes sharing a memory segment.

[endsect]

[section:virtuality_limitation Virtuality forbidden]

This is not an specific problem of Shmem, it is a problem
for all shared memory object placing mechanisms.
The virtual table pointer and the virtual table
are in the address space of the process
that constructs the object, so if we place a class
with virtual function or inheritance, the virtual
function pointer placed in shared memory will be
invalid for other processes.

This problem would be very difficult to solve, since each process needs a 
different virtual table pointer and the object that contains tha pointer
is shared accross many processes.The virtual table pointer is the most 
common mechanism to implement virtual functions but it's implementation 
defined and can't be easily overwriten. Maybe even compiler help is needed 
for this. So Shmem does not have any plan to support virtual function and 
virtual inheritance in shared memory.

[endsect]

[section:statics_warning Be careful with static class members]

Static members of classes are global objects shared by 
all instances of the class. Because of this, static
members are implemented as global variables in processes.

When constructing a class with static members, each process
has its own copy of the static member, so updating a static
member in one process does not change the value the other 
process has. So be careful with these classes. Static members
are not dangerous if they are just constant variables initialized
when the process starts, but they don't change at all (for example,
when used like enums).

[endsect]

[endsect]

[section:rationale Rationale]

[section:rationale_mutex Rationale for process-shared mutexes and condition variables]

A shared memory segment is not itself very useful to share data between processes 
without synchronization primitives like mutexes and and condition variables. Following
Boost.Thread's interface, Shmem defines process-shared mutexes and condition variables.

This interface follows Boost.Thread's mutex and condition variables' rationale, so 
that the constructors of shared_mutex and shared_condition can throw if the 
construction of the resource fails, and mutexes are used mainly with scoped locks.

However, currently it's not possible to reuse Boost Threads utilities like scoped 
locks and time functions (xtime time structure, functions to obtain time, etc...)
because Boost.Thread checks in headers if those headers are included in a 
multithreaded build. This is logical since Boost.Thread has no sense without
multithreaded builds, but with Shmem two single-threaded processes can use
process-shared mutexes, so Boost.Thread locks and utilities don't allow this.

Because of this, Shmem reproduces the needed scoped locks and time structures from
Boost.Thread in the boost::shmem namespace. In the future, it would be logical to
share utilities and locks between Boost.Thread or Shmem or even to move 
process-shared mutex synchronization objects from Shmem to Boost.Thread.

If Boost.Thread's model changes or C++ standarized mutex and condition variables
are published, process-shared mutex and condition variable should follow this change.


[endsect]

[section:rationale_containers Rationale for process-shared STL compatible containers]

One the most important features of Shmem are the shared-memory STL compatible containers.
To make this possible, Shmem makes use of standard allocator interface, so that
Shmem STL compatible allocators define allocator::pointer as an offset pointer.

The standard allows allocator::pointer to be a smart pointer but allows 
implementations to ignore this and suppose allocator::pointer is equal to T*.
Most implementations tested don't support smart allocator::pointer approach, 
because in practice, all STL compatible allocators (like Boost.Pool) use T* as 
pointer typedef.

For this reason, Shmem offers implementations of STL containers that can be placed
in shared memory. This implementations show how a STL compatible container can easily
be modified to use it in shared memory.

The allocator::pointer typedef is a type that provides a pointer to the type of 
object managed by the allocator. But the container can use internally pointers
not related to objects allocated with a STL compatible allocator, because the standard
says nothing about members. However, to place a container in shared memory, 
mapped in different base addresses across several processes, all member pointers 
of a containers must be offset pointers. This is why Shmem offers a wide-range of
containers that can be safely placed in shared memory.

[endsect]

[endsect]

[section:concepts Concepts and definitions]

Shmem uses some concepts that can be confusing: algorithm, allocator, memory, etc...
This section tries to clarify how these concepts are used in Shmem:

* An *memory algorithm* is an object that takes control of one (or more) big memory 
segments and returns portions from them. The memory algorithm is built in the same
memory it controls (for example, in shared memory, if the memory algorithm returns
portions of shared memory).

* A *segment manager* is an object that *contains* a memory algorithm and offers
additional higher level services, like named allocations. The segment manager
is an object constructed in the same memory it manages. For example, if a segment
manager offers shared memory named allocations, the segment manager itself is
constructed in the shared memory.

* An *allocator* is a class that follows the STL-allocator interface and is
used to allocate memory portions for STL-like containers. In Shmem, an allocator
usually contains a pointer to a *segment manager*, which is the one that
really implements the memory allocation. The *allocator* can implement more
complex strategies, like node pooling, using the services the *segment manager*
offers. In Shmem, an allocator can be placed in the same memory as the *segment manager*,
that is, it can be placed in shared memory or memory mapped files.

*A *front-end* is a class that constructs/destroys the memory to be used (for 
example, shared memory) and places the *segment manager* there. It also *forwards* all
user requests to the *segment manager* (allocations, named allocations...).
The front-end is just an ordinary class that is not constructed in the same 
memory type of the *segment manager*, it's just a proxy to the segment manager.

*A *container* in Shmem has the same meaning as STL containers. The difference is
that a Shmem *container* is ready to be constructed in the same memory type as
the *segment manager* (shared memory, memory mapped files...)

[endsect]

[section:oswrappers Basic Shmem classes]

These classes provide basic operating system resources to build higher
level inter-process communications. In named objects, like shared memory,
memory-mapped files, and named semaphore and mutex, the semantic of the
name used to construct the object is operating system dependant. All basic
objects in Shmem share the same namespace, so a we can't create a named mutex
called "MyObject" and shared memory called also "MyObject". The user should 
choose separate names for both objects.

[section:shared_memory Shared memory]

This class allows the creation, connection and destruction 
of a shared memory segment. 

[c++]

   /*!A class that wraps basic shared memory management*/
   class shared_memory : private boost::noncopyable
   {
   public:

      class segment_info_t
      {
       public:
         /*!Returns pointer to the shared memory fragment
            the user can overwrite*/
         void *      get_user_ptr() const;
         /*!Returns the size of the shared memory fragment
            the user can overwrite*/
         std::size_t get_user_size()const;
      };

      /*!Initializes members. Does not throw*/
      shared_memory();

      /*!Calls close. Does not throw*/
      ~shared_memory();

      /*!Creates a shared memory segment with name "name", with size "size".
         User can specify the mapping address. Never throws.*/
      bool create(const char *name,          std::size_t size, 
                  const void *addr = 0);

      /*!Creates a shared memory segment with name "name", with size "size".
         User can also specify the mapping address in "addr". Never throws.
         It also executes the functor "func" atomically if the segment is created.
         Functor has must have the following signature:

         bool operator()(const segment_info_t * info, bool created) const
         
         "info" is an initialized segment info structure, and "created" 
         must be "true". If the functor returns "false", an error is supposed
         and segment will be closed. The functor must not throw.
         */
      template <class Func>
      bool create_with_func(const char *name, std::size_t size, Func func,
                            const void *addr = 0);

      /*!Opens previously created shared memory segment with name "name". 
         If the memory segment was not previously created, 
         the function return false. User can specify the mapping address. 
         Never throws.*/
      bool open(const char *name, const void *addr = 0);

      /*!Opens previously created shared memory segment with name "name". 
         If the memory segment was not previously created, 
         the function returns "false". User can specify the mapping address. 
         Never throws.
         It also executes the functor "func" atomically if the segment is opened.
         Functor has must have the following signature:

         bool operator()(const segment_info_t * info, bool created) const
         
         "info" is an initialized segment info structure, and "created" 
         must be "false". If the functor returns "false", an error is supposed
         and segment will be closed. The functor must not throw.*/
      template <class Func>
      bool open_with_func(const char *name, Func func,
                        const void *addr = 0);

      /*!Creates a shared memory segment with name "name", and size "size" if
         the shared memory was not previously created. If it was previously 
         created it tries to open it. User can specify the mapping address.
         Never throws.*/
      bool open_or_create(const char *name, std::size_t size, const void *addr = 0);

      /*!Creates a shared memory segment with name "name", and size "size" if
         the shared memory was not previously created. If it was previously 
         created it tries to open it. User can specify the mapping address.
         Never throws.
         It also executes the functor "func" atomically if the segment is 
         created or opened. Functor has must have the following signature:

         bool operator()(const segment_info_t * info, bool created) const
         
         "info" is an initialized segment info structure, and "created" 
         will be "true" if the segment was created or "false" if the segment was
         opened. If the functor returns "false", an error is supposed
         and segment will be closed. The functor must not throw.*/
      template <class Func>
      bool open_or_create_with_func(const char *name, std::size_t size, 
                                    Func func,        const void *addr = 0);

      /*!Returns the size of the shared memory segment. Never throws.*/
      std::size_t get_size()  const;

      /*!Returns shared memory segment's base address for this process. 
         Never throws.*/
      void* get_base()  const;

      /*!Unmaps shared memory from process' address space. Never throws.*/
      void close();

      /*!Unmaps shared memory from process' address space . Never throws.
         It also executes the functor "func" atomically.
         Functor has must have the following signature:

         void operator()(const segment_info_t * info, bool last) const
         
         "info" is an initialized segment info structure, and "last" 
         indicates if this unmapping is the last unmapping so that
         there will be no no other processes attached to the segment.
         The functor must not throw.*/
      template <class Func>
      void close_with_func(Func func);
   };


The create function takes 3 parameters. The first one 
is the name of the shared memory we want to create, 
the second is the size of the shared memory, and the last 
the mapping address. The function returns false if the shared memory exists 
previously or the mapping can be achieved.

Caution: If you specify the mapping address, (for example, 0x30000000)
this does not mean that you can start to write that in that address! shared_memory
stores some metadata in the first bytes of the segment, so please get the address
you can overwrite calling get_base() function. The "size" argument passed when
constructing the segment represents the size the user needs. The real segment
size will be bigger to store the metadata.

The open function opens a previously 
created shared memory segment. The open_or_create 
function opens the segment if it was previously 
created or creates it otherwise.

All creation, opening and closing functions are atomic. This means that two processes
can concurrently try to open_or_create a segment. One will create the segment and other
will connect. The xxx_with_func functions will also execute the functor atomically.

The xxx_with_with_func versions are really useful to execute logic atomically so that
we can implement higher level IPC mechanisms like message queues with atomic 
initializations.

The close() call does not destroy the shared memory segment, it just unmaps it from the
process' address space. When all processes connected to the shared memory segment
execute the close call, the shared memory segment is destroyed.

[endsect]

[section:mmapped_file Memory mapped file]

This class allows portable memory-mapping files so that we can work with files
just like memory. We can map a file to the address-space of the process and 
achieve automatic persistence for data written in memory.

[c++]

   /*!A class that wraps basic file-mapping management*/
   class mmapped_file : private boost::noncopyable
   {
    public:
      typedef enum { 
                     ro_mode = 0x01, rw_mode = 0x02, access_mode_mask = 0xff 
                   }    accessmode;

      /*!Initializes members. Does not throw*/
      mmapped_file();

      /*!Calls close. Does not throw*/
      ~mmapped_file();

      /*!Opens a file mapping of file "filename", starting in offset 
         "file_offset", and the mapping's size will be "size". The mapping 
         can be opened as read-only "ro_mode" or read-write "rw_mode. 
         Never throws.*/
      bool open(const char *filename,  fileoff_t file_offset, 
                std::size_t size,      accessmode mode);

      /*!Closes a previously opened mode file mapping. Never throws.*/
      void close();

      /*!Returns if file mapping is open. Never throws.*/
      bool     is_open()  const;

      /*!Returns the size of the file mapping. Never throws.*/
      std::size_t get_size() const;

      /*!Returns the base address of the file mapping. Never throws.*/
      void* get_base() const;

      /*!Returns the file offset of the file mapping from the beginning of the file.
         Never throws.*/
      fileoff_t get_file_offset() const;

      /*!Flushes to the disk a byte range within the mapped file. 
         Never throws*/
      bool flush(std::size_t mapping_offset = 0, std::size_t numbytes = 0);
   };


[endsect]

[section:shared_mutex Process-shared mutexes]

Shmem process shared mutexes follow the basic guidelines of Boost Thread Mutexes. 
Mutexes can't be used without a scoped_lock and for that reason, Shmem provides 
lock classes similar to Boost Thread ones. In the future it would be interesting 
to unify both locks under the same library. The same happens with xtime structure
and functions. The reason for this duplication is that Boost Threads checks for multithreaded
builds when including headers, and emits a compilation error when a single threaded
process includes xtime or scoped_lock classes. Since Shmem can be used between
single threaded processes, that functionality is replicated in Shmem. If Shmem
is reviewed and accepted, this scoped lock and xtime structs could be independized
from multithreaded builds so that the same locks and xtime could beused by 
Boost.Thread and Shmem.     

shared_mutex wraps a mutex that can be placed in shared memory and used to 
mutually exclude different process and threads. shared_try_mutex, wraps the 
same mutex functionality with additional try_lock mechanism to avoid blocking 
if the mutex is already blocked by another process.

shared_recursive_mutex wraps a mutex that can be placed in shared 
memory and used to mutually exclude different process and threads 
and that can be blocked several times by the same process/thread. 
shared_recursive_try_mutex and shared_recursive_timed_mutex, wraps the 
same mutex functionality with additional try_lock and timed_lock mechanisms 
to avoid blocking if the mutex is already blocked by another process.
The recursive mutexes can be locked by the same thread several times.

All mutexes have the same interface, taken from Boost Threads library:

[c++]

   /*!Wraps a mutex that can be placed in shared memory and can be 
      shared between processes. Allows lock trying*/
   class shared_try_mutex : private boost::noncopyable
   {
    public:

      /*!Creates mutex resources, throws process_resource_error
         if there are available resources */
      shared_try_mutex();

      /*!Destructs resources, does not throw */
     ~shared_try_mutex();

      // Friend classes.. .
    private:
      /*!Locks mutex, sleeps when mutex is already locked.
         Throws process_lock_error if a severe error is found*/
      void do_lock(void);

      /*! Tries to lock the mutex, returns false when mutex 
         is already locked, returns true when success.
         Throws process_lock_error if a severe error is found*/
      bool do_trylock(void);

      /*! Unlocks the mutex */
      void do_unlock(void);
      // . . .
   };

[endsect]

[section:shared_condition Process-shared condition variables]

Similar to boost thread conditions, shared_condition class provides 
a way to signal and wait for events, but between processes. This 
shared_condition can be placed in shared memory to construct more 
complex inter-process communication mechanisms, like message queues.

[c++]

   class shared_condition: private boost::noncopyable
   {
    public:
      /*!Constructs a shared_condition*/
      shared_condition();

      /*!Destroys *this*/
     ~shared_condition();

      /*!If there is a thread waiting on *this, change that 
         thread's state to ready. Otherwise there is no effect.*/
      void notify_one();

      /*!Change the state of all threads waiting on *this to ready.
         If there are no waiting threads, notify_all() has no effect.*/
      void notify_all();

      /*!Releases the lock on the mutex object associated with lock, blocks 
         the current thread of execution until readied by a call to 
         this->notify_one() or this->notify_all(), and then reacquires the lock.*/
      template <class L>
      void wait(L& lock);

      /*!The same as: while (!pred()) wait(lock)*/
      template <class L, class Pr>
      void wait(L& lock, Pr pred);

      /*!Releases the lock on the mutex object associated with lock, blocks 
         the current thread of execution until readied by a call to 
         this->notify_one() or this->notify_all(), or until time xt is reached, 
         and then reacquires the lock.
         Returns: false if time xt is reached, otherwise true.*/
      template <class L>
      bool timed_wait(L& lock, const xtime& xt);

      /*!The same as:   while (!pred()) { 
                           if (!timed_wait(lock, xt)) return false; 
                        } return true;*/
      template <class L, class Pr>
      bool timed_wait(L& lock, const xtime& xt, Pr pred);
      // . . .
   };

[endsect]

[section:named_semaphore Named semaphore]

Not necessary for shmem management but very useful to synchronize 
different processes and send very efficient acknowledgements. 
It can also guarantee atomicity for object creation and initialization.

named_semaphore can't be placed in shared memory, each process must have 
its own named_semaphore instance.

[c++]
   /*!A semaphore with a global name, so it can be found from different 
      processes. Allows several resource sharing patterns and efficient 
      acknowledgment mechanisms.*/
   class named_semaphore : private boost::noncopyable
   {
   public:
      /*!Initializes member variables. Does not throw*/
      named_semaphore();

      /*!Calls close(). Does not throw*/
      ~named_semaphore();

      /*!Creates a global semaphore with a name, and an initial count. 
         It will return an false if the semaphore is already created. 
         Does not throw*/
      bool create(const char *name, int initialCount);

      /*!Opens or creates a global semaphore with a name, and an initial count. 
         If the semaphore is created, this call is equivalent to create(). 
         If the semaphore is already created, this call is equivalent to open()
         and initialCount is ignored. Does not throw*/
      bool open_or_create(const char *name, int initialCount);

      /*!Opens a global semaphore with a name if that semaphore is previously.
         created. If it is not previously created this function return false.
         Does not throw*/
      bool open(const char *name);

      /*!Frees system resources. Does not throw*/
      void close();

      /*!Increments semaphore count. If there is any waiting process, wakes
         up the process. If there is an error throws sem_exception*/
      void post();

      /*!Waits for the semaphore to the posted if count is 0. 
         If there is an error throws sem_exception*/
      void wait();

      /*!Waits for the semaphore to the posted if count is 0 or until
         timeout expires. Returns true if wait was ok, false if timeout
         expires. If there is an error throws sem_exception*/
      bool timed_wait(const xtime& xt);

      /*!Tries to wait for the semaphore to the posted if count is 0 or until
         timeout expires. Returns true if wait was ok, false if wait was not
         successful. If there is an error throws sem_exception*/
      bool try_wait();
      //. . .
   };

[endsect]


[section:named_mutex Named mutex]

Not necessary for shmem management but very useful to synchronize 
different processes without creating a shared memory segment and 
constructing there a shared_mutex. named_mutex can't be placed in shared memory, each process must have 
its own named_mutex instance.

[c++]

   /*!A mutex with a global name, so it can be found from different 
      processes. This mutex can't be placed in shared memory, and
      each process should have it's own mutex.*/
   class named_mutex : private boost::noncopyable
   {
   public:
      /*!Initializes member variables. Does not throw*/
      named_mutex();

      /*!Calls close(). Does not throw*/
      ~named_mutex();

      /*!Creates a global mutex with a name. 
         It will return an false if the mutex is already created. 
         Does not throw*/
      bool create(const char *name);

      /*!Opens or creates a global mutex with a name. 
         If the mutex is created, this call is equivalent to create(). 
         If the mutex is already created, this call is equivalent to open(). 
         Does not throw*/
      bool open_or_create(const char *name);

      /*!Opens a global mutex with a name if that mutex is previously.
         created. If it is not previously created this function return false.
         Does not throw*/
      bool open(const char *name);

      /*!Closes the mutex. Does not throw*/
      void close();

      /*!Unlocks a previously locked mutex.*/
      void unlock();

      /*!Locks mutex, sleeps when mutex is already locked.
         Throws process_resource_exception if a severe error is found*/
      void lock();

      /*! Tries to lock the mutex, returns false when mutex 
         is already locked, returns true when success.
         Throws process_resource_exception if a severe error is found*/
      bool try_lock();

      /*! Tries to lock the mutex until time xt,
         Returns false when timeout expires, returns true when locks.
         Throws process_resource_exception if a severe error is found*/
      bool timed_lock(const xtime& xt);
	//. . .
   };

[endsect]

[section:shared_barrier Process-shared barrier]

Similar to boost barrier, shared_barrier is a synchronization primitive 
used to cause a set of threads from different processes to wait until they 
each perform a certain function or each reach a particular point in their 
execution. It has the same interface as boost::threads

[c++]

   /*!An object of class shared_barrier is a synchronization primitive that 
      can be placed in shared memory used to cause a set of threads from 
      different processes to wait until they each perform a certain 
      function or each reach a particular point in their execution.*/
   class shared_barrier
   {
    public:
      /*!Constructs a barrier object that will cause count threads 
         to block on a call to wait(). */
      shared_barrier(unsigned int count);

      /*!Destroys *this. If threads are still executing their wait() 
         operations, the behavior for these threads is undefined.*/
      ~shared_barrier(){};

      /*!Effects: Wait until N threads call wait(), where N equals the count 
         provided to the constructor for the barrier object.
         Note that if the barrier is destroyed before wait() can return, 
         the behavior is undefined.
         Returns: Exactly one of the N threads will receive a return value 
         of true, the others will receive a value of false. Precisely which 
         thread receives the return value of true will be implementation-defined. 
         Applications can use this value to designate one thread as a leader that 
         will take a certain action, and the other threads emerging from the barrier 
         can wait for that action to take place.*/
      bool wait();
      //. . .
   };

[endsect]

[section:shared_read_write_mutex Process-shared read/write mutexes]

These read_write_mutexes, follow the same interface as Boost Thread 
read_write_mutexes and offer the same functionality but between threads
of different processes.  

Shmem has adapted Boost.Thread read/write locks to offer shared memory
versions of Boost.Thread read/write locks: shared_read_write_mutex, 
shared_read_write_try_mutex and shared_read_write_timed_mutex classes

[c++]

   class shared_read_write_mutex
   {
    public:
      /*!Effects: Constructs a read_write_mutex object with a scheduling policy. 
         Postconditions: *this is in an unlocked state.*/
      shared_read_write_mutex
         (read_write_scheduling_policy::read_write_scheduling_policy_enum sp) 
         : m_impl(sp) { }

      /*!Effects: Destroys a read_write_mutex object.
         Requires: *this is in an unlocked state.
         Notes: Danger: Destruction of a locked mutex is a serious programming 
         error resulting in undefined behavior such as a program crash.*/
      ~shared_read_write_mutex() { }

      /*!Returns the scheduling policy used by this shared_read_write_mutex.*/
      read_write_scheduling_policy::read_write_scheduling_policy_enum policy() const 
         { return m_impl.m_sp; }

      friend class boost::shmem::read_write_lock_ops<shared_read_write_mutex>;
      typedef boost::shmem::scoped_read_write_lock
         <shared_read_write_mutex>; scoped_read_write_lock;
      typedef boost::shmem::scoped_read_lock
         <shared_read_write_mutex>; scoped_read_lock;
      typedef boost::shmem::scoped_write_lock
         <shared_read_write_mutex>; scoped_write_lock;
      //. . .
   };

[endsect]

[endsect]

[section:offset_ptr A shared memory pointer: offset_ptr]

As said, Shmem does not count with same address shared memory 
mapping. Because of that, raw pointers stored in shared memory may become 
invalid. To solve this we can use offsets instead absolute addresses 
to point to an object in the same shared memory segment.

The smart pointer offset_ptr wraps all the background operations 
needed to offer a pointer-like interface. The class interface is 
inspired in Boost Smart Pointers and stores the offset between 
the pointee's address and the "this" pointer (the address of the
offset_ptr itself). One of the big problems of 
offset_ptr is the representation of NULL pointer. Null pointer 
can't be safely represented like an offset, since the 0 address 
is always out of the shared memory segment. Some implementations choose 
0 offset as a null pointer but this is not valid for many uses, 
since many times nodes from STL containers point to themselves (the 
end node in an empty container, for example), and 0 offset value 
is needed.

offset_ptr offers a templatized basic implementation that allows 
different flavours of offset pointers. 

[c++]

   template <class PointedType, class RootPtr = offset_1_null_ptr>
   class offset_ptr;

The default implementation considers offset==1 as null pointer.
This implies that the pointer can not point the byte pointed by
(reinterpret_cast<char>(&offset_ptr))+1
because this byte is considered as the null value. The pointer
will contain only a std::ptrdiff_t value. This default 
implementation is activated using offset_1_null_ptr type in
the second template parameter. 

To obtain a full range addressing, an additional member is needed
so the size of the pointer grows to sizeof(std::ptrdiff_t) + sizeof(bool).
The bool member indicates if the pointer is null or not. This implementation
is activated using full_offset_ptr in the second template parameter.

The offset_ptr class offers all pointer-like operations and
random_access_iterator typedefs, so it can be used in STL 
algorithms requiring random access and detected via traits:

[c++]

   template <class PointedType, class RootPtr>
   class offset_ptr : public RootPtr
   {
      //. . .
    public:   //Public Functions 
      typedef     /*...*/     pointer;
      typedef     /*...*/     reference;
      typedef     /*...*/     value_type;
      typedef     /*...*/     difference_type;
      typedef     /*...*/     iterator_category;

      /*! Default Constructor */
      offset_ptr(){ }

      /*!   Ctor from raw pointer (allows "0" pointer conversion) */
      offset_ptr(pointer ptr) {  this->set_offset(ptr); }

      /*!   Ctor from other offset_ptr */
      offset_ptr(const offset_ptr& ptr);

      /*!   Ctor from other offset_ptr. If pointers of pointee types 
            are convertible, offset_ptrs will be convertibles. */
      template<class T2>
      offset_ptr(const offset_ptr<T2>& ptr);

      /*!   Obtains raw pointer from offset. */
      pointer get()const;

      /*!   Pointer-like -> operator. It can return 0 pointer */
      pointer operator->() const;

      /*!   Derefencing operator, if it is a null offset_ptr behaviour 
            is undefined. */
      reference operator* () const;

      /*!   Indexing operator. */
      reference operator[](ptrdiff_t idx) const;

      /*!   Assignment from pointer (saves extra conversion). */
      offset_ptr& operator= (const_pointer from);

      /*!   Assignment from other offset_ptr. */
      offset_ptr& operator= (const offset_ptr & pt);

      /*!   Assignment from related offset_ptr. If pointers of pointee types 
            are assignable, offset_ptrs will be assignable. */
      template <class T2>
      offset_ptr& operator= (const offset_ptr<T2> & pt);

      /*!   safe bool conversion operator*/
      operator unspecified_bool_type() const;

      /*!   Not operator. Not needed in theory, but improves portability */
      bool operator! () const;

      //. . . Pointer Arithmetic and Comparison 
   };

[endsect]

[section:named_shared_object Named shared memory object allocation]

The most useful feature of Shmem is the ability to treat a shared memory
segment like a memory pool where you can allocate/deallocate fragments or
construct/destroy objects just like you can do with malloc/free or new/delete.
This way, several processes can share memory buffers to implement fast 
inter-process communication and create named objects that can be found 
using that name.

When creating objects in shared memory, however, there are two problems, 
the explicit constructor call needed and the problem when other 
process has to find the created object in shared memory.

Shmem solves this with the front-end *basic_named_shared_object*. It offers
a simple interface to construct objects in shared 
memory associated with a string. All constructions and 
destructions are atomic so that two processes can't create 
two objects associated with the same name.

[section:named_shared_object_int The interface]

[c++]

   template
         <
            class CharType, 
            class MemoryAlgorithm, 
            template<class IndexConfig> class IndexType
         >
   class basic_named_shared_object
   {
      /*...*/
   public: 
      typedef /*...*/                                    segment_manager;
      typedef CharType                                   char_t;
      typedef typename MemoryAlgorithm::void_pointer     void_pointer;

      /*!Returns the  memory base address in this process. Never throws.*/
      void *   get_base   () const;

      /*!Returns the size of memory segment. Never throws.*/
      std::size_t   get_size   () const;

      /*!Returns a pointer to the segment manager. Never throws.*/
      segment_manager *get_segment_manager() const;

      /*!Transforms an absolute address into an offset from base address. 
         The address must belong to the memory segment. Never throws.*/
      std::ptrdiff_t get_offset_from_address   (const void *ptr) const;

      /*!Transforms previously obtained offset into an absolute address in the 
         process space of the current process. Never throws.*/
      void *    get_address_from_offset (std::ptrdiff_t offset) const;

      /*!Searches for nbytes of free memory in the segment, marks the
         memory as used and return the pointer to the memory. If no 
         memory is available throws a boost::shmem::bad_alloc exception*/
      void* allocate             (size_t nbytes);

      /*!Searches for nbytes of free memory in the segment, marks the 
         memory as used and return the pointer to the memory. If no memory 
         is available return 0. Never throws.*/
      void* allocate             (size_t nbytes, std::nothrow_t &nothrow);

      /*!Marks previously allocated memory as free. Never throws.*/
      void  deallocate           (void *addr);

      /*!Creates shared memory from file. Never throws.*/
      template<class CharT> 
      bool create_from_file (const CharT *filename, const char *mem_name, 
                             const void *addr = 0);

      /*!Creates shared memory from an istream. Never throws.*/
      bool create_from_istream (std::istream &instream, std::size_t size,
                                const char *mem_name, const void *addr = 0);

      /*!Saves shared memory to a file. Never throws.*/
      template<class CharT> 
      bool save_to_file (const CharT *filename);

      /*!Saves memory to a std::ostream. Never throws.*/
      bool save_to_ostream (std::ostream &outstream)

      /*!Constructor. Allocates basic resources. Never throws.*/
      basic_named_shared_object(){}

      /*!Destructor. Calls close. Never throws.*/
      ~basic_named_shared_object();

      /*!Creates shared memory, and places segment manager there. Never throws.*/
      bool  create   (const char *name, std::size_t size, const void *addr = 0);
    
      /*!Connects to a created share memory and its segment manager. Never throws.*/
      bool  open     (const char* name, std::size_t size, const void *addr = 0);

      /*!Frees resources and unmaps memory. Never throws.*/
      void close();

      /*!Tries to find the address of a previous named allocation. Returns a memory
         buffer and the object count. If not found returned pointer is 0.
         Never throws.*/
      template <class T>
      std::pair<T*, std::size_t> find  (char_ptr_holder_t name);

      /*!Creates a named object or array in shared memory.*/
      template <class T>
      typename named_object_algo_t::template construct_proxy<T, true>::type
         construct(char_ptr_holder_t name);

      /*!Finds or creates a named object or array in shared memory.*/
      template <class T>
      typename named_object_algo_t::template find_construct_proxy<T, true>::type
         find_or_construct(char_ptr_holder_t name);

      /*!Creates a named object or array in shared memory.*/
      template <class T>
      typename named_object_algo_t::template construct_proxy<T, false>::type
         construct(char_ptr_holder_t name, std::nothrow_t nothrow);

      /*!Finds or creates a named object or array in shared memory.*/
      template <class T>
      typename named_object_algo_t::template find_construct_proxy<T, false>::type
         find_or_construct(char_ptr_holder_t name, std::nothrow_t nothrow);

      /*!Creates a named array from iterators in shared memory .*/
      template <class T>
      typename named_object_algo_t::template construct_iter_proxy<T, true>::type
         construct_it(char_ptr_holder_t name);

      /*!Finds or creates a named array from iterators in shared memory.*/
      template <class T>
      typename named_object_algo_t::template find_construct_iter_proxy<T, true>::type
         find_or_construct_it(char_ptr_holder_t name);

      /*!Creates a named array from iterators in shared memory.*/
      template <class T>
      typename named_object_algo_t::template construct_iter_proxy<T, false>::type
         construct_it(char_ptr_holder_t name, std::nothrow_t nothrow);

      /*!Finds or creates a named array from iterators in shared memory.*/
      template <class T>
      typename named_object_algo_t::template find_construct_iter_proxy<T, false>::type
         find_or_construct_it(char_ptr_holder_t name, std::nothrow_t nothrow);

      /*!Calls a functor and guarantees that no new construction, search or
         destruction will be executed by any process while executing the object
         function call. If the functor throws, this function throws.*/
      template <class Func>
      void atomic_func(Func &f);

      /*!Destroys a named shared memory object or array.*/
      template <class T>
      bool destroy(const CharType *name);

      /*!Destroys an anonymous shared memory object or array.*/
      template <class T>
      bool destroy(const detail::anonymous_instance_t *, const void *object);

      /*!Destroys the unique instance of type T of the shared memory segment.*/
      template <class T>
      bool destroy(const detail::unique_instance_t *);

      /*!Destroys the object (named, anonymous, or unique)of type T.*/
      template <class T>
      bool destroy_ptr(const T *name);

      /*!Preallocates needed index resources to optimize the 
         creation of "num" named objects in the shared memory segment.
         Can throw boost::shmem::bad_alloc if there is no enough memory.*/
      void reserve_named_objects(std::size_t num);

      /*!Preallocates needed index resources to optimize the 
         creation of "num" unique objects in the shared memory segment.
         Can throw boost::shmem::bad_alloc if there is no enough memory.*/
      void reserve_unique_objects(std::size_t num);

      //. . .
   };

The close() call does not destroy the shared memory segment, it just unmaps it from the
process' address space. When all processes connected to the shared memory segment
execute the close call, the shared memory segment is destroyed.

This class can be customized with the following parameters:

[c++]

   class CharType, 
   class MemoryAlgorithm, 
   template<class IndexConfig> class IndexType


* *CharType* is the type of the character that will be used to identify
  the created named objects (for example, *char* or *wchar_t*)

* *MemoryAlgorithm* is the shared memory segment management algorithm 
   (for example simple sequential fit). The typedefs of memory algorithm 
   also define the synchronization type (`MemoryAlgorithm::mutex_family`)
   and pointer type (`MemoryAlgorithm::void_pointer`) to be used in all 
   classes based on basic_named_shared_object (STL allocators, for example).
   See [link shmem.custom_shmem_alloc Writing a new shared memory allocation
   algorithm] for details about memory algorithms.
     
* *IndexType* is the type of index that will be used to store the name-object association 
   (for example, a map, a hash-map, or an ordered vector)

This way, we can use char or wchar_t to name the shared memory 
objects, we can plug new shared memory allocation algorithms, and
use the index type that is best suited to our needs.

[endsect]

[section:common_named_shared_objects Common named shared object classes]

As seen, *basic_named_shared_object* offers a great variety of customization. But
for the average user, a common, default shared memory named object creation is needed.
Because of this, Shmem defines the most common named shared object specializations:

[c++]

   /*!Defines the named shared object allocation with a c-string as 
      a key, the simple sequential fit algorithm (with process-shared mutexes)
      as memory management algorithm and flat_map as a index.
      This class allows the shared memory to be mapped in different base 
      in different processes*/
   typedef 
      basic_named_shared_object <char
                                ,simple_seq_fit<shared_mutex_family, offset_ptr<void> >
                                ,flat_map_index>  
      named_shared_object;

   /*!Defines the named shared object allocation with a wchar_t string as 
      a key, the simple sequential fit algorithm (with process-shared mutexes) 
      as memory management algorithm and flat_map as a index
      This class allows the shared memory to be mapped in different base 
      in different processes*/
   typedef 
      basic_named_shared_object <wchar_t
                                ,simple_seq_fit<shared_mutex_family, offset_ptr<void> >
                                ,flat_map_index>  
      wnamed_shared_object;

   /*!Defines the named shared object allocation with a c-string as 
      a key, the simple sequential fit algorithm (with process-shared mutexes)
      as memory management algorithm and flat_map as a index.
      This class only works if shared memory is mapped to the same address
      in different processes*/
   typedef 
      basic_named_shared_object <char
                                ,simple_seq_fit<shared_mutex_family, void *>
                                ,flat_map_index>  
      fixed_named_shared_object;

   /*!Defines the named shared object allocation with a wchar_t string as 
      a key, the simple sequential fit algorithm (with process-shared mutexes) 
      as memory management algorithm and flat_map as a index
      This class only works if shared memory is mapped to the same address
      in different processes*/
   typedef 
      basic_named_shared_object <wchar_t
                                ,simple_seq_fit<shared_mutex_family, void *>
                                ,flat_map_index>  
      wfixed_named_shared_object;

named_shared_object allocates objects in shared memory asociated with a c-string and
wnamed_shared_object allocates objects in shared memory asociated with a wchar_t null
terminated string. Both define the pointer type as `offset_ptr<void>` so they can be
used to map the shared memory at different base addresses in different processes.
*fixed_named_shared_object* and *wfixed_named_shared_object* are the counterparts
for fixed shared memory mapping, since they define the pointer type as `void*` 

[endsect]

[section:allocate_deallocate Allocating fragments of a shared memory segment]

If a basic raw-byte allocation is needed from a shared memory segment, for
example, to implement top-level inter-process communications, this class
offers *allocate* and *deallocate* functions. The allocation function
comes with throwing and no throwing versions. Throwing version throws 
boost::shmem::bad_alloc if there is no more memory and the non-throwing
version returns 0 pointer.

[c++]

   //Front-end that allocates portions of a shared memory segment
   //with the default shared memory segment management algorithm
   named_shared_object shmalloc;

   //Create the segment and initialize resources
   shmalloc.create("/MySegment", 65536);

   void* ptr;

   //Allocate 100 bytes of memory from segment, throwing version
   ptr = shmalloc.allocate(100);

   //Deallocate it
   shmalloc.deallocate(ptr);

   //Non throwing version
   ptr = shmalloc.allocate(100, std::nothrow);

   //Deallocate it
   shmalloc.deallocate(ptr);

[endsect]

[section:segment_offset Obtaining offsets to identify data]

The class also offers conversions between absolute addresses that belong to 
the segment and the offset of that address regarding to the base mapping address 
of the segment, so that offsets can be used as keys between processes
to identify shared memory buffers. 

[c++]

	//Process A obtains the offset of the address
	std::ptrdiff_t offset = segment.get_offset_from_address(processA_address);
	//Process A sends this address using IPC
	//
	//Process B obtains the address of the offset (which can be 
	//different if segments were mapped with different base addresses)
	void * processB_address = segment.get_address_from_offset(offset);

[endsect]


[section:allocation_types Object construction function family]

When constructing objects in shared memory associated with a name, the user has a varied
function family to "construct" or "construct if not found" objects. Shmem can construct
a single object or an array of objects. The array can be constructed with the same 
parameters for all objects or we can define each parameter from a list of iterators:

[c++]

   /*!Allocates and constructs an object of type MyType (throwing version) */
   MyType *ptr = named_shared_object.construct<MyType>("Name") (par1, par2...);

   /*!Allocates and constructs an array of objects of type MyType (throwing version) 
     Each object receives the same parameters (par1, par2, ...)*/
   MyType *ptr = named_shared_object.construct<MyType>("Name")[count](par1, par2...);

   /*!Tries to find a previously created object. If not present, allocates 
      and constructs an object of type MyType (throwing version) */
   MyType *ptr = named_shared_object.find_or_construct<MyType>("Name") (par1, par2...);

   /*!Tries to find a previously created object. If not present, allocates and 
      constructs an array of objects of type MyType (throwing version). Each object 
      receives the same parameters (par1, par2, ...)*/
   MyType *ptr = named_shared_object.find_or_construct<MyType>("Name")[count](par1, par2...);

   /*!Allocates and constructs an array of objects of type MyType (throwing version) 
     Each object receives parameters returned with the expression (*it1++, *it2++,... )*/
   MyType *ptr = named_shared_object.construct_it<MyType>("Name")[count](it1, it2...);

   /*!Tries to find a previously created object. If not present, allocates and constructs 
      an array of objects of type MyType (throwing version).  Each object receives  
      parameters returned with the expression (*it1++, *it2++,... ) */
   MyType *ptr = named_shared_object.find_or_construct_it<MyType>("Name")[count](it1, it2...);

   /*!Tries to find a previously created object. Returns a pointer to the object and the 
      count (if it is not an array, returns 1). If not present, the returned pointer is 0*/
   std::pair<MyType *,std::size_t> ret = named_shared_object.find<MyType>("Name");

   /*!Destroys the created object, returns false if not present*/
   bool destroyed = named_shared_object.destroy<MyType>("Name");

   /*!Destroys the created object via pointer*/
   named_shared_object.destroy_ptr(ptr);

All these functions have a non-throwing version, that 
is invoked with an additional parameter std::nothrow. 
For example, for simple object construction:

[c++]

   /*!Allocates and constructs an object of type MyType (no throwing version) */
   MyType *ptr = named_shared_object.construct<MyType>("Name", std::nothrow) (par1, par2...);

[endsect]

[section:anonymous Anonymous instance construction]

Sometimes, the user doesn't want to create objects associated with a name. For this purpose,
Shmem can create anonymous objects in shared memory. All named object construction functions
are available to construct anonymous objects. To allocate an anonymous objects, the user
must use "boost::shmem::anonymous_instance" object instead of a name:

[c++]

   MyType *ptr = named_shared_object.construct<MyType>(anonymous_instance) (par1, par2...);
   // Other construct variants can also be used (including non-throwing ones)
   //We can only destroy the anonymous object via pointer
   named_shared_object.destroy_ptr(ptr);

Find functions have no sense here, since many anonymous objects can be created in
the same memory segment. We can only destroy the anonymous object via pointer.

[endsect]

[section:unique Unique instance construction]

Sometimes, the user wants to emulate a singleton in shared memory. Obviously, 
as shared memory is constructed at run-time, the user must construct and destroy
this object explicitly. But how can the user be sure that the object is the only
object of its type in the shared memory segment? This can be emulated using
a named object and checking if it is present before trying to create one, but
all processes must agree in the object's name, that can also conflict with
other existing names.

To solve this, Shmem offers a "unique object" creation in shared memory.
Only one instance of a class can be created in a shared memory segment using this service,
so it makes easier the emulation of singleton-like objects across processes, for example,
to design pooled, shared memory allocators. The object can be searched using the type 
of the class as a key. 

[c++]

   // Construct
   MyType *ptr = named_shared_object.construct<MyType>(unique_instance) (par1, par2...);
   // Find it
   std::pair<MyType *,std::size_t> ret = named_shared_object.find<MyType>(unique_instance);
   // Destroy it
   named_shared_object.destroy<MyType>(unique_instance);
   // Other construct and find variants can also be used (including non-throwing ones)

[c++]

   // We can also destroy the unique object via pointer
   MyType *ptr = named_shared_object.construct<MyType>(unique_instance) (par1, par2...);
   named_shared_object.destroy_ptr(ptr);


The find function obtains a pointer to the only object of type T that can be created
using this unique_instance mechanism. 

[endsect]

[section:index_types Index types for name/object mappings]

As seen, basic_named_shared_object, when creating named objects, stores the name/object
relation in an index. The index is a map with the name of the object as a key and
a pointer to the object as the mapped type. The default specializations, *named_shared_object* 
and *wnamed_shared_object*, use *flat_map_index* as the index type.

Each index has its own characteristics, like search-time, insertion time, deletion time, 
memory use, and memory allocation patterns. Shmem offers 3 index types right now:

* *boost::shmem::flat_map_index*: Based on boost::shmem::flat_map, an ordered 
   vector similar to Loki library's AssocVector class, offers great search time and
   minimum memory use. But the vector must be reallocated when is full, so all data
   must be copied to the new buffer. Ideal when insertions are mainly in initialization
   time and in run-time we just need searches.

* *boost::shmem::map_index*: Based on boost::shmem::map, a shared memory version of std::map.
   Since it's a node based container, it has no reallocations, the tree must be just 
   rebalanced somtimes. Offers equilibrated insertion/deletion/search times with
   a little more overhead per node comparing to *boost::shmem::flat_map_index*. Ideal
   when searches/insertions/deletions are in random order.

* *boost::shmem::null_index*: This index is for people using basic_named_shared_object
   just for raw memory buffer allocations and they don't make use of named/unique 
   allocations. This class is just empty and saves some space and compilation time.

To create a *basic_named_shared_object* using *boost::shmem::map* as the index type we
just must specify *boost::shmem::map_index* as template parameter:

[c++]

   //This front-end can allocate objects with:
   // -> a wchar_t string as key
   // -> boost::shmem::simple_seq_fit with process-shared mutexes 
   //       as memory allocation algorithm.
   // -> boost::shmem::map<...> as the index to store name/object mappings
   typedef boost::shmem::basic_named_shared_object
            <  wchar_t
            ,  boost::shmem::simple_seq_fit<boost::shmem::shared_mutex_family, offset_ptr<void> >
            ,  boost::shmem::map_index
            >  my_named_shared_object;

Shmem plans to offer an *unordered_map* based index as soon as this container is included
in Boost. If these indexes are not enough for you, you can define your own index type.
To know how to do this, go to [link shmem.custom_indexes Building custom indexes] section.

[endsect]

[endsect]


[section:stl_allocators Shmem STL compatible allocators]

[section:allocator_introduction Introduction to Shmem STL compatible allocators]

As seen, Shmem offers raw memory allocation and object construction in shared memory, but
one of the first user requests is the use of containers in shared memory. To achieve this, Boost 
Shmem makes use of previous shared memory allocation algorithms to build 2 common memory allocation
schemes: variable size object allocation and fixed size object allocation (segregated storage),
implemented in these allocators: 

* *boost::shmem::allocator* offers general purpose allocation within a fixed size memory segment.

* *boost::shmem::node_allocator* offers a segregated storage allocation scheme sharing a common
  pool between all instances of the class node_allocator placed in the same fixed size memory 
  segment, so memory usage is optimized.

* *boost::shmem::private_allocator* offers a segregated storage allocation scheme where
  each private_allocator owns its own pool. This allocator offers faster allocation
  than node_allocator since it avoids synchronization between threads/processes but imposes 
  a higher memory usage. Take in care that the standard does not recommend this private
  per allocator pool.

* *boost::shmem::cached_node_allocator* offers a segregated storage allocation scheme between
  node_allocator and private_allocator. This allocator caches some nodes from the common
  the common pool and stores them privately so that these are quickly available
  without the synchronization overhead for future allocations.


Shmem STL compatible allocators are configurable via template types so that the can use different 
allocation algorithms and pointer types. And when used offset_ptr as pointer type, the user 
can place these allocators in shared memory mapped in different base addresses in several processes.

[endsect]

[section:allocator boost::shmem::allocator: The shared memory STL compatible allocator]

The *boost::shmem::allocator* class defines a STL compatible allocator class that 
uses the shared memory management algorithm from the segment to allocate and deallocate memory. 
This allocator is templatized with the allocated type, the type pointer, 
and the allocation algorithm.

[c++]

   namespace boost::shmem {

   /*!An STL compatible allocator that uses a segment manager as 
      memory source. The internal pointer type will of the same type (raw, smart) as
      "typename SegmentManager::void_pointer" type. This allows
      placing the allocator in shared memory, memory mapped-files, etc...*/
   template<class T, class SegmentManager>
   class allocator 
   {
      public:

      /*!Returns the segment manager. Never throws*/
      segment_manager* get_segment_manager()const
         {  using boost::get_pointer;  return  get_pointer(mp_mngr);   }

      /*!Constructor from the segment manager. Never throws*/
      allocator(segment_manager *segment_mngr) 
         : mp_mngr(segment_mngr) { }

      //The rest of the interface is the same of std::allocator
   };

   }} //      namespace boost::shmem {

The class *allocator* must be always initialized with the allocation
algorithm obtained from the segment where you want *boost::shmem::allocator* 
to allocate memory.


[c++]

   //Alias allocator type with
   //    T=int
   //    SegmentManager = named_shared_object::segment_manager
   typedef allocator<int, named_shared_object::segment_manager> Allocator;

   //Initialize allocator with the segment manager
   Allocator alloc_inst (segment.get_segment_manager());

The allocator just provides the needed typedefs and forwards 
all allocation and deallocation requests to the memory allocation
algorithm passed in the constructor.

[endsect]


[section:node_allocator boost::shmem::node_allocator: a simple segregated storage between processes]

As seen in the shared memory default algorithm, memory algorithms waste 
some space in management information for each allocation. Sometimes, 
usually for small objects, this is not acceptable. Usually shared 
memory allocators become fragmented under some allocation and 
deallocation schemes, reducing their performance. When allocating 
many objects of the same type, a simple segregated storage becomes 
a fast and space-friendly allocator, as explained in Boost Pool library.

To build normal node allocators, usually a global, thread shared singleton
pool is used for each node size. This is not possible if you try to share 
a node allocator between processes. To achieve this sharing, the *node_allocator* 
uses a unique name to identify the pool shared by all this node_allocators. In the
initialization, a *node_allocator* object searches this unique object in the segment.
If it is not preset, it builds one.  This way, all *node_allocator* objects built
inside a memory segment share a unique memory pool. 

The common segregated storage is not only shared between node_allocators of the
same type, but it is also  shared between all node_allocators that allocate objects 
of the same size, for example, *node_allocator<uint32>* and *node_allocator<float32>*. 
This saves a lot of memory but also imposes an synchronization overhead for each 
node allocation.

The common segregated storage, dynamically created using the unique name explained before,
integrates a reference count so that a node_allocator can know if any other node_allocator 
is attached to the same common segregated storage to allow an ordered common segregated 
storage destruction when the last node_allocator is destroyed.

[c++]

   /*!An STL node allocator that uses a segment manager as memory 
      source. The internal pointer type will of the same type (raw, smart) as
      "typename SegmentManager::void_pointer" type. This allows
      placing the allocator in shared memory, memory mapped-files, etc...
      This node allocator shares a segregated storage between all instances 
      of node_allocator with equal sizeof(T) placed in the same segment 
      group.*/
   template<class T, std::size_t N, class SegmentManager>
   class node_allocator
   {
    public:

      //No default constructor

      /*!Constructor from a segment manager.
         Can throw boost::shmem::bad_alloc*/
      node_allocator(SegmentManager *segment_mngr);

      /*!Returns a pointer to the segment manager. Never throws*/
      SegmentManager *get_segment_manager() const;

      /*...*/
      //The rest is the same interface as std::allocator
      /*...*/

The *node_allocator* must be always initialized with the allocation
algorithm obtained from the segment 
where you want *node_allocator* to allocate memory

[c++]

   //Alias allocator type with
   //    T=int
   //    N=64
   //    SegmentManager = named_shared_object::segment_manager
   typedef node_allocator<int, 64, named_shared_object::segment_manager> NodeAllocator;

   //Initialize allocator instance with the named algorithm
   NodeAllocator alloc_inst (segment.get_segment_manager());

All STL compatible containers that want to use this allocation scheme 
must be constructed with an initialized node_allocator so 
that they can allocate the values with the node allocator:

[c++]

   MyIntList mylist(alloc_inst);
   for(int i = 0; true; ++i){
      mylist.insert(mylist.begin(), 3);
   }  

[endsect]

[section:private_allocator boost::shmem::private_allocator: a private segregated storage]

As said, the node_allocator shares a common segregated storage between 
node_allocators that allocate objects of the same size and this optimizes
memory usage. However, it needs a named_shared memory algorithm to use
the unique instance service so that this sharing can be possible. Also
imposes a synchronization overhead per node allocation because of this share.
Sometimes, the named object algorithm is not available (for example, when
building index types for the named object algorithm itself) or the 
synchronization overhead is not acceptable.

So *private_allocator* uses the same segregated storage as node_allocator,
but each *private_allocator* has its own segregated storage. No synchronization
is used when allocating nodes, so there is far less overhead for an operation
that usually involves just a few pointer operations when allocating and 
deallocating a node.

[c++]

   /*!An STL node allocator that uses a segment manager as memory 
      source. The internal pointer type will of the same type (raw, smart) as
      "typename SegmentManager::void_pointer" type. This allows
      placing the allocator in shared memory, memory mapped-files, etc...
      This allocator has its own node pool.*/
   template<class T, std::size_t N, class SegmentManager>
   class private_node_pool
   {
    public:

      //No default constructor

      /*!Constructor from a segment manager. Never throws*/
      private_allocator(SegmentManager *segment_mngr);

      /*!Returns a pointer to the segment manager. Never throws*/
      SegmentManager *get_segment_manager() const;

      /*...*/
      //The rest is the same interface as std::allocator
      /*...*/

Any *private_allocator* must be initialized with a pointer 
to the segment manager of the semgment from you want *private_allocator* 
to allocate memory:

[c++]

   //Alias allocator type with
   //    T=int
   //    N=64
   //    SegmentManager = named_shared_object::segment_manager
   typedef private_allocator<int, 64, named_shared_object::segment_manager> 
      PrivateNodeAllocator;

   //Initialize allocator instance with algorithm
   PrivateNodeAllocator alloc_inst (segment.get_segment_manager());

All STL compatible containers that want to use this allocation scheme 
must be constructed with an initialized private_allocator so 
that they can allocate the values with the private node allocator:

[c++]

   MyIntList mylist(alloc_inst);
   for(int i = 0; true; ++i){
      mylist.insert(mylist.begin(), 3);
   }  

[endsect]

[section:cached_node_allocator boost::shmem::cached_node_allocator: caching nodes to avoid overhead]

The total node sharing of *boost::shmem::node_allocator* can impose a high overhead for some 
applications and the no synchronization overhead of *boost::shmem::private_allocator*
can impose a unacceptable memory waste for other applications.

To solve this, Shmem offers an allocator, *boost::shmem::cached_node_allocator*, that 
allocates nodes from the common pool but caches some of them privately so that following 
allocations have no synchronization overhead. When the cache is full, the allocator 
returns some cached nodes to the common pool, so that they are available to other 
allocators.

[c++]

   /*!An STL node allocator that uses a shared memory management algorithm as memory 
      source and a templatized Ptr as pointer type. Allows placing STL containers in 
      shared memory if Ptr is an offset pointer. This node allocator shares a segregated
      storage between all instances of cached_node_allocator with equal sizeof(T) placed
      in the same fixed size memory segment. But also caches some nodes privately to
      avoid some synchronization overhead.*/

   template<class T, std::size_t N, class Ptr, class SegmentManager>
   class cached_node_allocator
   {
    public:

      //No default constructor

      /*!Constructor from a segment manager. Never throws*/
      cached_node_allocator(AllocAlgo_t *segment_mngr);

      /*!Returns a pointer to the segment manager. Never throws*/
      SegmentManager *get_segment_manager() const;

      /*!Sets the new max cached nodes value. This can provoke deallocations
         if "newmax" is less than current cached nodes. Never throws*/
      void set_max_cached_nodes(std::size_t newmax);

      /*!Returns the max cached nodes parameter. Never throws*/
      std::size_t get_max_cached_nodes() const;

      /*...*/
      //The rest is the same interface as std::allocator
      /*...*/

Any *cached_node_allocator* must be initialized with a pointer to a named shared
shared memory allocation algorithm:

[c++]

   //Alias allocator type with
   //    T=int
   //    N=64
   //    SegmentManager = named_shared_object::segment_manager
   typedef cached_node_allocator<int, 64, named_shared_object::segment_manager> 
      CachedNodeAllocator;

   //Initialize allocator instance with algorithm
   CachedNodeAllocator alloc_inst (segment.get_segment_manager());

All STL compatible containers that want to use this allocation scheme 
must be constructed with an initialized cached_node_allocator so 
that they can allocate the values with the cached_node_allocator:

[c++]

   //Change cache size as desired (for example 100 nodes)
   alloc_inst.set_max_cached_nodes(100);

   //Initialize container
   MyIntList mylist(alloc_inst);
   for(int i = 0; true; ++i){
      mylist.insert(mylist.begin(), 3);
   }  

[endsect]

[section:allocator_swapping Swapping Shmem STL compatible allocators]

When swapping STL containers, there is an active discussion on what to do with 
the allocators. Some STL implementations, for example Dinkumware from Visual .NET 2003,
make a deep swap of the whole container through a temporary when allocators are not equal.
The [@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1599.html proposed resolution]
to container swapping is that allocators should be swapped in a non-throwing way.

Unfortunately, this approach is not valid with shared memory. Using heap allocators, if
Group1 of node allocators share a common segregated storage, and Group2 share another common
segregated storage, a simple pointer swapping is needed to swap an allocator of Group1 and another
allocator of Group2. But when the user wants to swap two shared memory allocators, each one
placed in a different shared memory segment, this is not possible. As generally shared memory
is mapped in different addresses in each process, a pointer placed in one segment can't point
to any object placed in other shared memory segment, since in each process, the distance between
the segments is different. However, if both shared memory allocators are in the same segment,
a non-throwing swap is possible, just like heap allocators.

Until a final resolution is achieved. Shmem STL compatible allocators implement a non-throwing
swap function that swaps internal pointers. If an allocator placed in a shared memory segment is
swapped with other placed in a different shared memory segment, the result is undefined. But a 
crash is quite sure.

[endsect]

[endsect]


[section:containers_explained Shmem and containers in shared memory]

[section:stl_container_requirements Container requirements for Shmem allocators]

Shmem STL compatible allocators offer a STL compatible allocator interface and 
if they define their internal *pointer* typedef as offset_ptr<T>, they can 
be used to place STL containers in shared memory.

However, as Scott Meyers mentions in his Effective STL 
book, Item 10, ['"Be aware of allocator conventions and 
restrictions"]: 

* ['"the Standard explicitly allows library implementers 
to assume that every allocator's pointer typedef is 
a synonym for T*"]

* ['"the Standard says that an implementation of the STL is 
permitted to assume that all allocator objects of the 
same type are equivalent and always compare equal"]

Obviously, if any STL implementation ignores pointer typedefs, 
no smart pointer can be used as allocator::pointer. If STL 
implementations assume all allocator objects of the same 
type compare equal, it will assume that two allocators, 
each one allocating from a different shared memory segment 
are equal, which is a complete disaster. 

STL container implementations that we want to place in shared 
memory with Shmem can't make any of these assumptions, so:

* STL containers may not assume that memory allocated with 
  an allocator can be deallocated with other allocators of 
  the same type. All allocators objects must compare equal 
  only if memory allocated with one object can be deallocated 
  with the other one, and this can only tested with 
  operator==() at run-time.

* Containers' internal pointers should be of the type allocator::pointer 
  and containers may not assume allocator::pointer is a raw pointer.

* All objects must be constructed-destroyed via 
  allocator::construct and allocator::destroy functions.

[endsect]

[section:containers STL containers in shared memory]

Unfortunately, some STL implementations use raw pointers
for internal data and ignore allocator pointer typedefs 
and others suppose at some point that the allocator::typedef 
is T*. This is because in practice,
there wasn't need of allocators with a pointer typedef 
different from T* for pooled/node memory
allocators.

Until STL implementations handle allocator::pointer typedefs
in a generic way, Shmem offers the following classes:

* *boost:shmem::vector* is the implementation of std::vector ready for the shared memory.
        
* *boost:shmem::deque* is the implementation of std::deque ready for the shared memory.
        
* *boost:shmem::list* is the implementation of std::list ready for the shared memory.

* *boost:shmem::slist* is the implementation of SGI's slist container (singly linked list) ready for the shared memory.
        
* *boost:shmem::set/multiset/map/multimap* family is the implementation of 
   std::set/multiset/map/multimap family ready for the shared memory.
        
* *boost:shmem::flat_set/flat_multiset/flat_map/flat_multimap* classes are the 
   adaptation and extension of Andrei Alexandrescu's famous AssocVector class 
   from Loki library, ready for the shared memory. These classes offer the same 
   functionality as std::set/multiset/map/multimap implemented with an ordered vector, 
   which has faster lookups than the standard ordered associative containers 
   based on red-black trees, but slower insertions.
        
* *boost:shmem::basic_string* is the implementation of std::basic_string ready for 
   the shared memory. It's implemented using a vector-like contiguous storage, so
   it has fast c_string conversion and can be used with the 
   [link shmem.vectorstream vectorstream] iostream formatting classes.
        
All these containers have the same default arguments as standard 
containers and they can be used with other, non-shared memory 
allocators (std::allocator, or boost::pool_allocator, for example). 

To place any of these containers in shared memory, we must define
the allocator template parameter with a shared memory allocator
so that the container allocates the values in the shared memory.
To place the container itself in shared memory, we construct it
in shared memory just like any other object with Shmem:

[c++]

   #include <boost/shmem/containers/vector.hpp>
   #include <boost/shmem/named_shared_object.hpp>

   int main ()
   {
      using namespace boost::shmem;

      //Shared memory front-end that is able to construct objects
      //associated with a c-string
      named_shared_object segment;

      //Create the memory segment and initialize resources
      if(!segment.create("/MySharedMemory",  //segment name
                         65536)){            //segment size in bytes
         return -1;
      }

      //Alias an STL-like allocator of ints that allocates ints from the segment
      typedef allocator<int, named_shared_object::segment_manager> 
         ShmemAllocator;

      //Alias a vector that uses the previous STL-like allocator
      typedef vector<int, ShmemAllocator> MyVector;

      int initVal[]        = {0, 1, 2, 3, 4, 5, 6 };
      const int *begVal    = initVal;
      const int *endVal    = initVal + sizeof(initVal)/sizeof(initVal[0]);

      //Initialize the STL-like allocator
      const ShmemAllocator alloc_inst (segment.get_segment_manager());

      //Construct the vector in the shared memory segment with the STL-like allocator 
      //from a range of iterators
      MyVector *myvector = 
         segment.construct<MyVector>
           ("MyVector")/*object name*/
           (begVal     /*first ctor parameter*/,
            endVal     /*second ctor parameter*/, 
            alloc_inst /*third ctor parameter*/); 

      //Use vector as your want
      std::sort(myvector->rbegin(), myvector->rend());
      // . . .
      //When done, destroy and delete vector from the segment
      segment.destroy<MyVector>("MyVector");
      return 0;
   }


These containers also show how easy is to create/modify 
an existing container making possible to place it in shared memory.

[endsect]

[endsect]


[section:customizing_boost_shmem Customizing Shmem]

[section:custom_shmem_alloc Writing a new shared memory allocation algorithm]

Shmem by default, uses a simple, space-friendly allocation algorithm implemented
by the class simple_seq_fit:

[section:simple_seq_fit simple_seq_fit: Default shared memory management algorithm]

The algorithm is a variation of sequential fit using singly 
linked list of free memory buffers. The algorithm is based 
on the article about shared memory titled 
[@http://home.earthlink.net/~joshwalker1/writing/SharedMemory.html ['"Taming Shared Memory"] ]. 
The algorithm is as follows:

The shared memory is divided in blocks of free shared memory, 
each one with some control data and several bytes of memory 
ready to be used. The control data contains a pointer (in 
our case offset_ptr) to the next free block and the size of 
the block. The allocator consists of a singly linked list 
of free blocks, ordered by address. The last block, points 
always to the first block:

[c++]

   simple_seq_fit  extra    free_block  1         free_block  2         free_block  3    
                   header   block_ctrl    usr     block_ctrl    usr     block_ctrl    usr
    ____________   _____   ___________________   ___________________   ___________________ 
   |            | |     | |             |     | |             |     | |             |     |
   | free | ctrl| |extra| | next | size | mem | | next | size | mem | | next | size | mem |
   |____________| |_____| |_____________|_____| |_____________|_____| |_____________|_____|
         |                 |   |                 |    |                 |  |               
         |__>__>__>__> _> _|   |__>__>__>__>__>__|    |__>__>__>__>__>__|  |              
                           |                                               | 
                           |_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_|


When a user requests N bytes of memory, the allocator 
traverses the free block list looking for a block large 
enough. If the "mem" part of the block has the same 
size as the requested memory, we erase the block from 
the list and return a pointer to the "mem" part of the 
block. If the "mem" part size is bigger than needed, 
we split the block in two blocks, one of the requested 
size and the other with remaining size. Now, we take 
the block with the exact size, erase it from list and 
give it to the user.

When the user deallocates a block, we traverse the list (remember 
that the list is ordered), and search its place depending on 
the block address. Once found, we try to merge the block with 
adjacent blocks if possible.

To ease implementation, the size of the free memory block 
is measured in multiples of "basic_size" bytes.  The basic 
size will be the size of the control block aligned to 
machine most restrictive alignment.

[c++]

   /*!This class implements the simple sequential fit algorithm with a simply
      linked list of free buffers.*/
   template<class MutexFamily, class VoidPointer>
   class simple_seq_fit : private boost::noncopyable
   {
    private:

      /*!Block control stucture*/
      struct block_ctrl
      {
         /*!Offset pointer to the next block. This pointer
            can't be null, since it's a diff pointer.*/
         offset_ptr<block_ctrl, offset_1_null_ptr>    next;
         /*!This block's memory size (including block_ctrl 
            header) in BasicSize units*/
         std::size_t                                  size;
      };

      /*...*/  
   
    public:
      /*!Shared mutex family used for the rest of the shmem framework*/
      typedef MutexFamily                          mutex_family;
      /*!the pointer type to be used for the rest of the shmem framework*/
      typedef VoidPointer                          void_pointer;

    public:
      /*!Constructor. "size" is the total size of the fixed size memory segment, 
         "extra_hdr_bytes" indicates the extra bytes after the sizeof(simple_seq_fit)
         that the allocator should not use at all.*/
      simple_seq_fit           (size_t size, std::size_t extra_hdr_bytes);
      /*!Obtains the minimium size needed by the algorithm*/
      static std::size_t get_min_size (size_t extra_hdr_bytes);
      /*!Allocates bytes, returns 0 if there is not more memory*/
      void* allocate            (size_t nbytes);
      /*!Deallocates previously allocated bytes*/
      void   deallocate          (void *adr);
      /*!Returns the size of the memory segment*/
      std::size_t get_size()  const;
      /*!Increases managed memory in extra_size bytes more*/
      void grow(std::size_t extra_size);
      /*...*/  
   };

Let's explain these structs:

* *simple_seq_fit* is the main control block of the allocator. 

* The *extra_hdr_bytes* memory comes just after simple_seq_fit object. 
  This memory will be used by other classes to write more control 
  data at fixed position.

* *block_ctrl* is the structure which controls a free block 
  in memory. It contains the size of the free block (in aligned 
  sizeof (block_ctrl) units, called basic_size, as we've 
  said before) and an offset pointer to the next free block 
  in the shared memory segment. The number of bytes returned 
  by the allocator will be multiple of basic_size bytes to 
  maintain the alignment requirements.

[endsect]

[section:custom_alloc_algo How to implement you own algorithm]

If the default algorithm does not satisfy user requirements, 
it's easy to provide different algorithms like bitmapping or 
more advanced segregated lists to meet requirements. The characteristics
of your own algorithm:

* It shouldn't have any virtual function or virtual inheritance or
  any indirect base class with virtual function or inheritance.

* I has to implement the same public functions and typedefs of 
simple_seq_fit:

[c++]

   typedef /* . . . */ mutex_family;

The class must specify a structure containing typedefs for 
different mutex types to be used in the Shmem 
framework. For example the defined

[c++]

   struct shared_mutex_family
   {
      typedef boost::shmem::shared_mutex                 mutex_t;
      typedef boost::shmem::shared_try_mutex             try_mutex_t;
      typedef boost::shmem::shared_timed_mutex           timed_mutex_t;
      typedef boost::shmem::shared_recursive_mutex       recursive_mutex_t;
      typedef boost::shmem::shared_recursive_try_mutex   recursive_try_mutex_t;
      typedef boost::shmem::shared_recursive_timed_mutex recursive_timed_mutex_t;
   };

defines all mutex types using boost::shmem mutex types. The 
user can specify the desired mutex family.

[c++]

   typedef shared_mutex_family mutex_family;

The new algorithm (let's call it *my_algorithm*) must implement the all the functions
that boost::shmem::simple_seq_fit class offers:

* The *my_algorithm* constructor must take 2 arguments: 
   * *size* indicates the total size of the managed memory segment, and
     the *my_algorithm* object will be always constructed a at offset 0 
     of the memory segment. 
 
   * The *extra_hdr_bytes* parameter indicates the number of bytes after
     the offset sizeof(*my_algorithm*) that *my_algorithm* can't use at all. This extra
     bytes will be used to store additional data that should not be overwritten.
     So, *my_algorithm* will be placed at offset 0 of the memory segment, and will
     manage the *[sizeof(my_algorithm) + extra_hdr_bytes, size)* range of the 
     segment.

* The *get_min_size()* function should return the minimum space the algorithm 
  needs to be valid with the passed *extra_hdr_bytes* parameter. This function will 
  be used to check if the memory segment is big enough to place the algorithm there.

* The *allocate()* function must return 0 if there is no more available memory. 
  The memory returned by *my_algorithm*
  must be aligned to the most restrictive memory alingment of the system, for example,
  to the value returned by *boost::alignment_of<boost::detail::max_align>::value*.

* The *deallocate()* function must make the returned buffer 
  available for new allocations.

* The *size()* function will return the passed *size* parameter in the constructor. 
  So, *my_algorithm* should store the size internally.

* The *grow()* function will expand the managed memory by *my_algorithm* in *extra_size* 
  bytes. So *size()* function should return the updated size,
  and the new managed memory range will be: *[sizeof(my_algorithm) + extra_hdr_bytes, old_size + extra_size)*

That's it. Now we can create new front-ends that use our new algorithm:

[c++]

   //Front-end to allocate named (c-string) objects
   //using special algorithm
   basic_named_shared_object< 
                              char, 
                              my_algorithm,
                              flat_map_index
                            >  
      my_named_shared_object;

[endsect]

[endsect]

[section:custom_allocators Building custom STL compatible allocators for Shmem]

If provided STL-like allocators don't satisfy user needs, the user 
can use another STL compatible allocator and use basic shared 
memory allocation functions and named shared memory functions. 
The user can this way implement more suitable allocation 
schemes on top of basic shared memory allocation schemes, 
just like more complex allocators are built on top of 
new/delete functions.

When using a shared memory front-end, the *get_segment_manager()* 
function returns a pointer to the segment manager.With this pointer,
the raw memory and named shared memory allocation functions can be 
called directly:

[c++]

   //A named shared memory object creation fron-end
   named_shared_object segment;

   //Create the shared memory segment and initialize resources
   segment.create("/MySharedMemory",//segment name
                  65536);           //segment size in bytes
                  
   //Obtain the segment manager
   named_shared_object::segment_manager *segment_mngr 
      = segment.get_segment_manager();

   //With the segment manager, now we have access to all allocation functions
   segment_mngr->deallocate(segment_mngr->allocate(32));
   segment_mngr->construct<int>("My_Int")[32](0);
   segment_mngr->destroy<int>("My_Int");

   //Initialize the custom, shared memory STL compatible 
   //allocator with the segment manager
   MySTLAllocator<int> stl_alloc(segment_mngr);

   //Alias a new vector type that uses the custom STL compatible allocator
   typedef std::vector<int, MySTLAllocator<int> > MyVect;

   //Construct the vector in shared memory with allocator as constructor parameter
   segment.construct<MyVect>("MyVect_instance")(stl_alloc);

The user can create another STL compatible allocator that uses this pointer to access
to all shared memory named/raw object management functions. Shmem STL compatible
allocators are based on this approach. *Remember* that shared memory STL-like allocators
should define their *pointer* typedef as an offset pointer so that STL-like containers
can be placed in shared memory.

If the user wants to optimize further allocator usage in Shmem node containers, he can 
change the common allocator::construct function from:

[c++]

   void construct(pointer _Ptr, const value_type &value);

to this one:

[c++]

   template<class Convertible>
   void construct(pointer ptr, const Convertible &value)

and define a specialization of `boost::shmem::has_convertible_construct<...>` 
defined in `<boost/shmem/detail/utilities.hpp>` file:

[c++]

   namespace boost{ namespace shmem{ 

   template<class T, class SegmentManager>
   struct has_convertible_construct
      <my_allocator<T, SegmentManager> >
   {
      enum {   value = true };
   };

   }} //namespace boost{ namespace shmem{ 

Using this optimization, Shmem node containers will just store one allocator instance
instead of 2, because nodes could be constructed from the value type directly.

[endsect]

[section:custom_indexes Building custom indexes]

The named shared memory object allocation algorithm uses a name/buffer index to
speed up object searching and creation. Default specializations of 
basic_named_shared_object, use boost::shmem::flat_map as index.

However, the index type can be chosen via template parameter, so that
the user can define its own index type if he needs that. To construct
a new index type, the user must create a class with the following guidelines:

* The interface of the index must follow the common public interface of std::map
  and future std::unordered_map including public typedefs. 
  The value_type typedef can be of type:

[c++]

   std::pair<key_type, mapped_type> 

or 

[c++]

   std::pair<const key_type, mapped_type>


so that ordered arrays or deques can be used as index types. 
Some known classes following this basic interface are boost::unordered_map, 
boost::shmem::flat_map and boost::shmem::map.

* The class must be a class template taking only a traits struct of this type:

[c++]

   struct index_traits
   {
      typedef /*...*/   key_type;
      typedef /*...*/   mapped_type;
      typedef /*...*/   segment_manager;
   };


[c++]

   template <class IndexTraits>
   class my_index_type;

The key_type typedef of the passed index_traits will be a instantiation of the following class:
            
[c++]

   /*!The key of the the named allocation information index. Stores a to
      a null string and the length of the string to speed up sorting*/
   template<...>
   struct index_key
   {
      typedef /*...*/                              char_type;
      typedef /*...*/                              const_char_ptr_t;

      //Offset pointer to the object's name
      const_char_ptr_t                             mp_str;

      //Length of the name buffer (null NOT included)
      std::size_t                                  m_len;

      /*!Constructor of the key*/
      index_key (const CharT *name, std::size_t length);

      /*!Less than function for index ordering*/
      bool operator < (const index_key & right) const;

      /*!Equal to function for index ordering*/
      bool operator == (const index_key & right) const;
   };

The mapped_type is not directly modified by the customized index but it is needed to 
define the index type. The *segment_manager* will be the type of the segment manager
that provides memory allocation.
            
* The constructor of the customized index type must take a pointer to segment_manager
  as constructor argument:

[c++]

   constructor(segment_manager *alloc);

* The index must provide a memory reservation function, that optimizes the index if the 
  user knows the number of elements to be inserted in the index:

[c++]

   void reserve(std::size_t n);

For example, the default index type flat_map_index based in boost::shmem::flat_map 
is just defined as:

[c++]

   namespace boost { namespace shmem { namespace detail {

   /*!Helper class to define typedefs from IndexTraits*/
   template <class MapConfig>
   struct flat_map_index_aux
   {
      typedef typename MapConfig::key_type                  key_type;
      typedef typename MapConfig::mapped_type               mapped_type;
      typedef typename MapConfig::segment_manager           segment_manager;
      typedef std::less<key_type>                           key_less;
      typedef std::pair<key_type, mapped_type>              value_type;
      typedef boost::shmem::allocator
               <value_type, segment_manager>                allocator_type;
      typedef boost::shmem::flat_map<key_type,  mapped_type,
                                    key_less, allocator_type>   index_t;
   };

   /*!Index type based in flat_map. Just derives from flat_map and
      defines the interface needed by the shared named object creation class*/
   template <class MapConfig>
   class flat_map_index
      //Derive class from map specialization
      : public flat_map_index_aux<MapConfig>::index_t
   {
      typedef flat_map_index_aux<MapConfig>        index_aux;
      typedef typename index_aux::index_t          base_type;
      typedef typename index_aux::segment_manager  segment_manager;

   public:
      /*!Constructor. Takes a pointer to the memory
         allocation algorithm. Can throw*/
      flat_map_index(segment_manager *segment_mngr)
         : base_type(typename index_aux::key_less(),
                     segment_mngr){}

      /*!This reserves memory to optimize the insertion of n
         elements in the index*/
      void reserve(std::size_t n)
         {  base_type::reserve(n);  }
   };

   }}}   //namespace boost { namespace shmem { namespace detail {

If the user is defining a node container based index (a container whose iterators 
are not invalidated when inserting or erasing other elements), Shmem can optimize
named object destruction when destructing via pointer. Shmem can store an iterator
next to the object and this way, instead of using the name of the object to erase 
the index entry, it uses the iterator, which is a faster way. So if you are creating
a new node container based index (for example, a tree), you should define an
specialization of `boost::shmem::is_node_index<...>` defined in 
`<boost/shmem/detail/utilities.hpp>`:

[c++]

   /*!Trait classes to detect if an index is a node
      index. This allows more efficient operations
      when deallocating named objects.*/
   template<class MapConfig>
   struct is_node_index
      <my_index<MapConfig> >
   {
      enum {   value = true };
   };

Shmem also defines other index types:

* [*boost:shmem::unordered_map_index], uses *boost::unordered_map* as index type.

* [*boost::map_index] uses *boost::shmem::map* as index type.

* [*boost::null_index] that uses an dummy index type if the user just needs
  anonymous allocations and want's to save some space and class instantations.

To define a new front-end that uses the new index:

[c++]

   /*!Defines the named shared object allocation with a c-string as 
      a key, the simple sequential fit algorithm (with process-shared mutexes)
      as raw shared memory management algorithm and a custom index*/
   typedef 
      basic_named_shared_object < 
                                 char, 
                                 simple_seq_fit<shared_mutex_family>,
                                 my_index_type
                                >  
      my_named_shared_object;

[endsect]

[endsect]


[section:beyond_shared_memory Beyond shared memory]

Shmem offers shared memory management, and allows placing STL compatible 
containers and allocators. It offers raw memory allocation and
anonymous and named object creation.

Shared memory management is mainly a fixed size buffer management, so several
Shmem services could be reused to use other non-shared memory fixed size buffers. 
These services include STL compatible containers, STL compatible allocators, named object creation, etc...

Applications for Shmem services using non-shared memory buffers:

* Create and use STL compatible containers and allocators, in systems with no dynamic memory

* Build complex, easily serializable databases in a single buffer:

   * To share data between threads

   * To save and load information from/to files.

* Duplicate information (containers, allocators, etc...) just copying the contents of one buffer to another one.

* Send complex information and objects/databases using serial/inter-process/network communications.

* Data persistence through memory-mapped files.

To help with this management, Shmem provides some useful classes, 
with the same functionality as *basic_named_shared_object*:

[section:user_buffer_shmem Constructing all Shmem objects in a user provided buffer]

Sometimes, the user wants to create simple objects, STL compatible containers, STL compatible
strings and more, all in a single buffer. This buffer could be a big static buffer, 
a memory-mapped auxiliary device or any other user buffer.

This would allow a easy serialization, since we just have copy the buffer to duplicate
all the objects created in the original buffer, and this includes complex objects like
maps, lists or any user classes. Shmem offers classes to handle user provided buffers
that allow the same functionality as shared memory classes:

[c++]

   //Named object creation front-end
   //All objects are constructed in a a user provided buffer
   template <
               class CharType, 
               class MemoryAlgorithm, 
               template<class IndexConfig> class IndexType
            >
   class basic_named_user_object;

   //Named object creation front-end
   //All objects are constructed in a a user provided buffer
   //   Names are c-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_named_user_object < 
      char, 
      simple_seq_fit<null_mutex_family>, offset_ptr<void> ,
      flat_map_index
      >  named_user_object;

   //Named object creation front-end
   //All objects are constructed in a a user provided buffer
   //   Names are wide-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_named_user_object< 
      wchar_t, 
      simple_seq_fit<null_mutex_family, offset_ptr<void> >,
      flat_map_index
      >  wnamed_user_object;
   
Let's see an example of the use of these classes:

[c++]

   //Create the user memory who will store all objects
   const int memsize = 65536;
   static char static_buffer [memsize];

   //Named (wide-string) new capable user mem front-end
   wnamed_user_object objects_in_user_memory;

   //Initialize the static buffer and initialize resources
   objects_in_user_memory.create(static_buffer, memsize);

   //We optimize resources to create 100 named objects in the static buffer
   objects_in_user_memory.reserve_named_objects(100);

   //Alias <integer, 64 element per chunk> node allocator type
   //This allocator will allocate memory inside the static buffer
   typedef wnamed_user_object::node_allocator_type
      <int, 64>::type node_allocator_t;

   //Alias a STL compatible list to be constructed in the static buffer
   typedef boost::shmem::list<int, node_allocator_t>    MyBufferList;

   //The list must be initialized with the allocator
   MyBufferList *list = objects_in_user_memory.construct<MyBufferList>(L"MyList")
                           (objects_in_user_memory.get_segment_manager());

   //All objects created with objects_in_user_memory will be stored in the static_buffer!

   //Destroy the whole list from the static buffer
   objects_in_user_memory.destroy<MyBufferList>(L"MyList");

Shmem STL compatible allocators can also be used to place STL 
compatible containers in the user segment.

[endsect]

[section:heap_buffer_shmem Shmem machinery in heap memory]

The use of heap memory (new/delete) to obtain a buffer where the user wants to store all 
his data is very common, so Shmem provides some specialized 
classes that work exclusively with heap memory. 

These are the classes:

[c++]

   //Named object creation front-end
   //All objects are constructed in a single buffer allocated via new[]
   template <
               class CharType, 
               class MemoryAlgorithm, 
               template<class IndexConfig> class IndexType
            >
   class basic_named_heap_object;

   //Named object creation front-end
   //All objects are constructed in a single buffer allocated via new[]
   //   Names are c-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_named_heap_object < 
      char, 
      simple_seq_fit<null_mutex_family, void*>,
      flat_map_index
      >  named_heap_object;

   //Named object creation front-end
   //All objects are constructed in a single buffer allocated via new[]
   //   Names are wide-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_named_heap_object< 
      wchar_t, 
      simple_seq_fit<null_mutex_family, void*>,
      flat_map_index
      >  wnamed_heap_object;

and the use is exactly the same as before, except that memory is created by the front-end 
itself using dynamic (new/delete) memory:

[c++]

   //Create the heap memory who will store all objects
   const int memsize = 65536;

   //Named new capable heap mem front-end
   wnamed_heap_object objects_in_heap_memory;

   //Create a dynamic buffer of size "memsize" and initialize resources
   objects_in_heap_memory.create(memsize);

   //We optimize resources to create 100 named objects in the dynamic buffer
   objects_in_heap_memory.reserve_named_objects(100);

   //Alias <integer, 64 element per chunk> node allocator type
   //This allocator will allocate memory inside the dynamic buffer
   typedef wnamed_heap_object::node_allocator_type
      <int, 64 >::type node_allocator_t;

   //Alias a STL compatible list to be constructed in the dynamic buffer
   typedef boost::shmem::list<int, node_allocator_t>    MyHeapList;

   //The list must be initialized with the allocator
   //since it has no default constructor
   MyHeapList *heaplist = objects_in_heap_memory.construct<MyHeapList>(L"MyList")
                           (objects_in_heap_memory.get_segment_manager());

   //All objects created with objects_in_user_memory will be stored in the static_buffer!

   //Destroy the whole list from the dynamic buffer
   objects_in_heap_memory.destroy<MyHeapList>(L"MyList");

[*basic_named_heap_object] also offers a `grow(std::size_t extra_bytes)` function that
tries to resize internal heap memory so that we have room for more objects. 
But *be careful*, if memory is reallocated, the old buffer will be copied into 
the new one so all the objects will be binary-copied to the new buffer. 
To be able to use this function, all pointers constructed in the heap buffer that
point to objects in the heap buffer must be offset pointers and all objects should be
binary copiable. Otherwise, the result is undefined. Here is an example:

[c++]

   #include <boost/shmem/containers/list.hpp>
   #include <boost/shmem/named_heap_object.hpp>
   #include <boost/shmem/allocators/allocator.hpp>
   #include <cstddef>

   using namespace boost::shmem;
   typedef list<int, allocator<int, named_heap_object::segment_manager> > MyList;

   int main ()
   {
      named_heap_object heap_memory;

      //We will create a buffer of 1000 bytes to store a list
      heap_memory.create(1000);
      MyList * mylist = heap_memory.construct<MyList>("MyList")
                           (heap_memory.get_segment_manager());

      //Obtain offset, that identifies the list in the buffer
      std::ptrdiff_t list_offset = heap_memory.get_offset_from_address(mylist);

      //Fill list until there is no more memory in the buffer
      try{
         while(1) {
            mylist->insert(mylist->begin(), 0);
         }
      }
      catch(const bad_alloc &){
         //memory is full
      }
      //Let's obtain the size of the list
      std::size_t old_size = mylist->size();

      //To make the list bigger, let's increase the heap buffer
      //in 1000 bytes more.
      heap_memory.grow(1000);

      //If memory has been reallocated, the old pointer is invalid, so
      //use previously obtained offset to find the new pointer.
      mylist = static_cast<MyList *>
                  (heap_memory.get_address_from_offset(list_offset));
      
      //Fill list until there is no more memory in the buffer
      try{
         while(1) {
            mylist->insert(mylist->begin(), 0);
         }
      }
      catch(const bad_alloc &){
         //memory is full
      }

      //Let's obtain the new size of the list      
      std::size_t new_size = mylist->size();

      assert(new_size > old_size);

      //Destroy list
      heap_memory.destroy_ptr(mylist);

      return 0;
   }


[endsect]

[section:memory_mapped_shmem Shmem with memory-mapped files]

One of the most useful things in operating systems are memory-mapped files, since the
OS user works directly in memory with a big file whose contents are too big to fit in 
memory, and the OS automatically loads, dumps, and synchronizes to memory the current
file contents.

Shmem can directly work with memory mapped files, so that all objects, containers and 
other Shmem resources get automatic data persistence support:

[c++]

   //Named object creation front-end
   //All objects are constructed in the memory-mapped file
   template <
               class CharType, 
               class MemoryAlgorithm, 
               template<class IndexConfig> class IndexType
            >
   class basic_named_mfile_object;

   //Named object creation front-end
   //All objects are constructed in the memory-mapped file
   //   Names are c-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_named_mfile_object < 
      char, 
      simple_seq_fit<shared_mutex_family, offset_ptr<void> >,
      flat_map_index
      >  named_mfile_object;

   //Named object creation front-end
   //All objects are constructed in the memory-mapped file
   //   Names are wide-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_named_mfile_object< 
      wchar_t, 
      simple_seq_fit<shared_mutex_family, offset_ptr<void> >,
      flat_map_index
      >  wnamed_mfile_object;

We can use any Shmem container, allocator, named object creation, etc... And we have a 
*flush()* function to make sure data is dumped to the file:

[/ shmem_doc_named_heap_object.cpp]

[c++]

   #include <boost/shmem/named_mfile_object.hpp>
   #include <boost/shmem/allocator.hpp>
   #include <boost/shmem/containers/vector.hpp>

   using namespace boost::shmem;

   int main ()
   {
      //STL compatible allocator object for memory-mapped file
      typedef allocator<int, named_mfile_object::segment_manager> allocator_int_t;
      typedef boost::shmem::vector<int, allocator_int_t > MyVect;

      const int filesize = 65536;
      const char *const fileName = "MyMappedFile";

      //Named allocate capable memory mapped file front-end
      named_mfile_object mapped_file;

      //Create memory-mapped file and initialize Shmem machinery
      if(!mapped_file.create(fileName, filesize)){
         return false;
      }

      //Construct the STL compatible allocator with the memory management algorithm
      const allocator_int_t myallocator (mapped_file.get_segment_manager());

      //Construct vector
      MyVect *mfile_vect = mapped_file.construct<MyVect> ("MyVector") (myallocator);

      //Test that vector can be found via name
      if(mfile_vect != mapped_file.find<MyVect>("MyVector").first)
         return -1;

      //Destroy and check it is not present
      mapped_file.destroy<MyVect> ("MyVector");
      if(0 != mapped_file.find<MyVect>("MyVector").first)
         return -1;

      //Construct another vector in the memory-mapped file
      mfile_vect = mapped_file.construct<MyVect> ("MyVector") (myallocator);
      
      //Flush cached data from memory-mapped file to disk
      mapped_file.flush();

      //Close mapped file
      mapped_file.close();

      //Map preexisting file again in memory
      if(!mapped_file.open(fileName)){
         return -1;
      }

      //Check vector is still there
      mfile_vect = mapped_file.find<MyVect>("MyVector").first;
      if(!mfile_vect)
         return -1;

      //Destroy and check it is not present
      mapped_file.destroy_ptr(mfile_vect);
      if(0 != mapped_file.find<MyVect>("MyVector").first)
         return -1;
      return 0;
   }

[*basic_named_mfile_object] also offers a `grow(std::size_t extra_bytes)` function that
tries to resize the mapped file so that we have room for more objects. 
But *be careful*, the file can be remapped in another base
address. To be able to use this function, all pointers constructed in the mapped file that
point to objects in the mapped file must be offset pointers. [*If `grow()` fails, ] 
[*the mapping can't be recovered] and the file mapping will be closed. You will need 
to call *open()* again to open it with the old size. Here the same example as with
basic_named_heap_object, but using memory mapped files:

[/ shmem_doc_named_mfile_object.cpp]

[c++]

   #include <boost/shmem/containers/list.hpp>
   #include <boost/shmem/named_mfile_object.hpp>
   #include <boost/shmem/allocators/allocator.hpp>
   #include <cstddef>

   using namespace boost::shmem;
   typedef list<int, allocator<int, named_mfile_object::segment_manager> > MyList;

   int main ()
   {
      named_mfile_object mfile_memory;

      //We will create a mapped file of 1000 bytes to store a list
      mfile_memory.create("./mapped_file", 1000);
      MyList * mylist = mfile_memory.construct<MyList>("MyList")
                           (mfile_memory.get_segment_manager());

      //Obtain offset, that identifies the list in the buffer
      std::ptrdiff_t list_offset = mfile_memory.get_offset_from_address(mylist);

      //Fill list until there is no more room in the file
      try{
         while(1) {
            mylist->insert(mylist->begin(), 0);
         }
      }
      catch(const bad_alloc &){
         //mapped file is full
      }
      //Let's obtain the size of the list
      std::size_t old_size = mylist->size();

      //To make the list bigger, let's increase the mapped file
      //in 1000 bytes more.
      mfile_memory.grow(1000);

      //If mapping address has changed, the old pointer is invalid,
      //so use previously obtained offset to find the new pointer.
      mylist = static_cast<MyList *>
                  (mfile_memory.get_address_from_offset(list_offset));
      
      //Fill list until there is no more room in the file
      try{
         while(1) {
            mylist->insert(mylist->begin(), 0);
         }
      }
      catch(const bad_alloc &){
         //mapped file is full
      }

      //Let's obtain the new size of the list      
      std::size_t new_size = mylist->size();

      assert(new_size > old_size);

      //Destroy list
      mfile_memory.destroy_ptr(mylist);

      return 0;
   }

[endsect]

[endsect]

[section:streams Direct iostream formatting: vectorstream and bufferstream]

Shared memory, memory-mapped files and all Shmem mechanisms are focused
on efficiency. The reason why shared memory is used is that it's the
fastest IPC mechanism available. When passing text-oriented messages through
shared memory, there is need to format the message. Obviously C++ offers
the iostream framework for that work.

Some programmers appreciate the iostream safety and design for memory
formatting but feel that the stringstream family is far from efficient not
when formatting, but when obtaining formatted data to a string, or when 
setting the string from which the stream will extract data. An example:

[c++]

   //Some formatting elements
   std::string my_text = "...";
   int number;
   
   //Data reader
   std::istringstream input_processor;
   
   //This makes a copy of the string. If not using a
   //reference counted string, this is a serious overhead.
   input_processor.str(my_text);

   //Extract data
   while(/*...*/){
      input_processor >> number;
   }
   
   //Data writer
   std::ostringstream output_processor;
   
   //Write data
   while(/*...*/){
      output_processor << number;
   }
   
   //This returns a temporary string. Even with return-value
   //optimization this is expensive.
   my_text = input_processor.str();

The problem is even worse if the string is a shared-memory string, because
to extract data, we must copy the data first from shared-memory to a 
std::string and then to a stringstream. To encode data in a shared-memory
string we should copy data from a stringstream to a std::string and then 
to the shared-memory string. 

Because of this overhead, Shmem offers a way to format memory-strings
(in shared memory, memory mapped files or any other memory segment) that
can avoid all unneeded string copy and memory allocation/deallocation, while
using all iostream facilities. Shmem *vectorstream* and *bufferstream* implement
vector-based and fixed-size buffer based storage support for iostreams and
all the formatting/locale hard work is done by standard std::basic_streambuf<>
and std::basic_iostream<> classes.

[section:vectorstream Formatting directly in your character vector: vectorstream]

The *vectorstream* class family (*basic_vectorbuf*, *basic_ivectorstream*
,*basic_ovectorstream* and *basic_vectorstream*) is an efficient way to obtain 
formatted reading/writing directly in a character vector. This way, if
a shared-memory vector is used, data is extracted/written from/to the shared-memory
vector, without additional copy/allocation. We can see the declaration of 
basic_vectorbuf and basic_vectorstream here:

[c++]

   /*!A streambuf class that controls the transmission of elements to and from
      a basic_ivectorstream, basic_ovectorstream or basic_vectorstream. 
      It holds a character vector specified by CharVector template parameter
      as its formatting buffer. The vector must have contiguous storage, like 
      std::vector, boost::shmem::vector or boost::shmem::basic_string*/
   template <class CharVector, class CharTraits = 
            std::char_traits<typename CharVector::value_type> >
   class basic_vectorbuf 
      : public std::basic_streambuf<typename CharVector::value_type, CharTraits>
   {
      public:
      typedef CharVector                        vector_type;
      typedef typename CharVector::value_type   char_type;
      typedef typename CharTraits::int_type     int_type;
      typedef typename CharTraits::pos_type     pos_type;
      typedef typename CharTraits::off_type     off_type;
      typedef CharTraits                        traits_type;

      /*!Constructor. Throws if vector_type default constructor throws.*/
      explicit basic_vectorbuf(std::ios_base::openmode mode
                                 = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Throws if vector_type(const Parameter &param) throws.*/
      template<class Parameter>
      explicit basic_vectorbuf(const Parameter &param,
                              std::ios_base::openmode mode
                                    = std::ios_base::in | std::ios_base::out);
      virtual ~basic_vectorbuf(){}

      /*!Swaps the underlying vector with the passed vector. 
         This function resets the position in the stream.
         Does not throw.*/
      void swap_vector(vector_type &vect);

      /*!Returns a const reference to the internal vector.
         Does not throw.*/
      const vector_type &vector() const;

      /*!Calls resize() method of the internal vector.
         Resets the stream to the first position.
         Throws if the internals vector's resize throws.*/
      void resize(typename vector_type::size_type size);
   };

   /*!A basic_iostream class that holds a character vector specified by CharVector
      template parameter as it's formatting buffer. The vector must have
      contiguous storage, like std::vector, boost::shmem::vector or
      boost::shmem::basic_string*/
   template <class CharVector, class CharTraits = 
            std::char_traits<typename CharVector::value_type> >
   class basic_vectorstream 
   : public std::basic_iostream<typename CharVector::value_type, CharTraits>

   {
      public:
      typedef CharVector                                                   vector_type;
      typedef typename std::basic_ios
         <typename CharVector::value_type, CharTraits>::char_type          char_type;
      typedef typename std::basic_ios<char_type, CharTraits>::int_type     int_type;
      typedef typename std::basic_ios<char_type, CharTraits>::pos_type     pos_type;
      typedef typename std::basic_ios<char_type, CharTraits>::off_type     off_type;
      typedef typename std::basic_ios<char_type, CharTraits>::traits_type  traits_type;

      /*!Constructor. Throws if vector_type default constructor throws.*/
      basic_vectorstream(std::ios_base::openmode mode 
                        = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Throws if vector_type(const Parameter &param) throws.*/
      template<class Parameter>
      basic_vectorstream(const Parameter &param, std::ios_base::openmode mode
                        = std::ios_base::in | std::ios_base::out);

      ~basic_vectorstream(){}

      //Returns the address of the stored stream buffer.
      basic_vectorbuf<CharVector, CharTraits>* rdbuf() const;

      /*!Swaps the underlying vector with the passed vector. 
         This function resets the position in the stream.
         Does not throw.*/
      void swap_vector(vector_type &vect);

      /*!Returns a const reference to the internal vector.
         Does not throw.*/
      const vector_type &vector() const;

      /*!Calls resize() method of the internal vector.
         Resets the stream to the first position.
         Throws if the internals vector's resize throws.*/
      void resize(typename vector_type::size_type size);
   };

The vector type is templatized, so that we can use any type of vector:
*std::vector*, *boost::shmem::vector*.... But the storage must be *contiguous*,
we can't use a deque. We can even use *boost::shmem::basic_string*, since it has a 
vector interface and it has contiguous storage. *We can't use std::string*, because 
although some std::string implementation are vector-based, others can have 
optimizations and reference-counted implementations.

The user can obtain a const reference to the internal vector using 
`vector_type vector() const` function and he also can swap the internal vector
with an external one calling `void swap_vector(vector_type &vect)`. 
The swap function resets the stream position.
This functions allow efficient methods to obtain the formatted data avoiding
all allocations and data copies. 

Let's see an example to see how to use vectorstream:

[c++]

   #include <boost/shmem/containers/vector.hpp>
   #include <boost/shmem/containers/string.hpp>
   #include <boost/shmem/named_shared_object.hpp>
   #include <boost/shmem/streams/vectorstream.hpp>
   #include <iterator>
   
   using namespace boost::shmem;

   typedef allocator<int, named_shared_object::segment_manager> 
      IntAllocator;
   typedef allocator<char, named_shared_object::segment_manager> 
      CharAllocator;
   typedef vector<int, IntAllocator>   MyVector;
   typedef basic_string
      <char, std::char_traits<char>, CharAllocator>   MyString;
   typedef basic_vectorstream<MyString>               MyVectorStream;

   int main ()
   {
      //Create shared memory
      named_shared_object segment;
      if(!segment.create("/MySharedMemory",  //segment name
                         65536)){            //segment size in bytes
         return -1;
      }

      //Construct shared memory vector
      MyVector *myvector = 
         segment.construct<MyVector>("MyVector")
         (IntAllocator(segment.get_segment_manager()));

      //Fill vector
      myvector->reserve(100);
      for(int i = 0; i < 100; ++i){
         myvector->push_back(i);
      }

      //Create the vectorstream. To create the internal shared memory
      //basic_string we need to pass the shared memory allocator as
      //a constructor argument
      MyVectorStream myvectorstream(CharAllocator(segment.get_segment_manager()));

      //Resize the internal string
      myvectorstream.resize(100*5);

      //Write all vector elements as text in the internal string
      //Data will be directly written in shared memory, because
      //internal string's allocator is a shared memory allocator
      for(std::size_t i = 0, max = myvector->size(); i < max; ++i){
         myvectorstream << (*myvector)[i] << std::endl;
      }

      //Auxiliary vector to compare original data
      MyVector *myvector2 =
         segment.construct<MyVector>("MyVector2")
         (IntAllocator(segment.get_segment_manager()));

      //Avoid reallocations
      myvector2->reserve(100);

      //Extract all values from the internal 
      //string directly to a shared memory vector.
      std::istream_iterator<int> it(myvectorstream), itend;
      std::copy(it, itend, std::back_inserter(*myvector2));

      //Compare vectors
      assert(std::equal(myvector->begin(), myvector->end(), myvector2->begin()));

      //Create a copy of the internal string
      MyString stringcopy (myvectorstream.vector());

      //Now we create a new empty shared memory string...
      MyString *mystring = 
         segment.construct<MyString>("MyString")
         (CharAllocator(segment.get_segment_manager()));
   
      //...and we swap vectorstream's internal string
      //with the new one: after this statement mystring
      //will be the owner of the formatted data.
      //No reallocations, no data copies
      myvectorstream.swap_vector(*mystring);

      //Let's compare both strings
      assert(stringcopy == *mystring);

      //Done, destroy and delete vectors and string from the segment
      segment.destroy_ptr(myvector2);
      segment.destroy_ptr(myvector);
      segment.destroy_ptr(mystring);
      return 0;
   }
   
[endsect]

[section:bufferstream Formatting directly in your character buffer: bufferstream]

As seen, vectorstream offers an easy and secure way for efficient iostream
formatting, but many times, we have to read or write formatted data from/to a
fixed size character buffer (a static buffer, a c-string, or any other).
Because of the overhead of stringstream, many developers (specially in 
embedded systems) choose sprintf family. The *bufferstream* classes offer 
iostream interface with direct formatting in a fixed size memory buffer with 
protection against buffer overflows. This is the interface:

   /*!A streambuf class that controls the transmission of elements to and from
      a basic_xbufferstream. The elements are transmitted from a to a fixed
      size buffer*/
   template <class CharT, class CharTraits = std::char_traits<CharT> >
   class basic_bufferbuf 
      : public std::basic_streambuf<CharT, CharTraits>
   {
      public:
      typedef CharT                             char_type;
      typedef typename CharTraits::int_type     int_type;
      typedef typename CharTraits::pos_type     pos_type;
      typedef typename CharTraits::off_type     off_type;
      typedef CharTraits                        traits_type;
      typedef std::basic_streambuf<char_type, traits_type> base_t;

      public:
      /*!Constructor. Does not throw.*/
      explicit basic_bufferbuf(std::ios_base::openmode mode
                               = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Assigns formatting buffer. Does not throw.*/
      explicit basic_bufferbuf(CharT *buffer, std::size_t length, 
                               std::ios_base::openmode mode
                                 = std::ios_base::in | std::ios_base::out);

      /*!Returns the pointer and size of the internal buffer. 
         Does not throw.*/
      std::pair<CharT *, std::size_t> buffer() const;

      /*!Sets the underlying buffer to a new value. Does not throw.*/
      void buffer(CharT *buffer, std::size_t length);
   };

   /*!A basic_iostream class that uses a fixed size character buffer
      as it's formatting buffer.*/
   template <class CharT, class CharTraits = std::char_traits<CharT> >
   class basic_bufferstream 
      : public std::basic_iostream<CharT, CharTraits>

   {
      public:                         // Typedefs
      typedef typename std::basic_ios
         <CharT, CharTraits>::char_type          char_type;
      typedef typename std::basic_ios<char_type, CharTraits>::int_type     int_type;
      typedef typename std::basic_ios<char_type, CharTraits>::pos_type     pos_type;
      typedef typename std::basic_ios<char_type, CharTraits>::off_type     off_type;
      typedef typename std::basic_ios<char_type, CharTraits>::traits_type  traits_type;
      
      /*!Constructor. Does not throw.*/
      basic_bufferstream(std::ios_base::openmode mode 
                        = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Assigns formatting buffer. Does not throw.*/
      basic_bufferstream(CharT *buffer, std::size_t length,
                        std::ios_base::openmode mode
                           = std::ios_base::in | std::ios_base::out);

      /*!Returns the address of the stored stream buffer.*/
      basic_bufferbuf<CharT, CharTraits>* rdbuf() const;

      /*!Returns the pointer and size of the internal buffer. 
         Does not throw.*/
      std::pair<CharT *, std::size_t> buffer() const;

      /*!Sets the underlying buffer to a new value. Resets 
         stream position. Does not throw.*/
      void buffer(CharT *buffer, std::size_t length);
   };   

   //Some typedefs to simplify usage
   typedef basic_bufferbuf<char>        bufferbuf;
   typedef basic_bufferstream<char>     bufferstream;
   typedef basic_ibufferstream<char>    ibufferstream;
   typedef basic_obufferstream<char>    obufferstream;

   typedef basic_bufferbuf<wchar_t>     wbufferbuf;
   typedef basic_bufferstream<wchar_t>  wbufferstream;
   typedef basic_ibufferstream<wchar_t> wibufferstream;
   typedef basic_obufferstream<wchar_t> wobufferstream;

While reading from a fixed size buffer, *bufferstream* activates endbit flag if
we try to read an address beyond the end of the buffer. While writing to a
fixed size buffer, *bufferstream* will active the badbit flag if a buffer overflow
is going to happen and disallows writing. This way, the fixed size buffer 
formatting through *bufferstream* is secure and efficient, and offers a good 
alternative to sprintf/sscanf functions. Let's see an example:

[c++]

   #include <boost/shmem/named_shared_object.hpp>
   #include <boost/shmem/streams/bufferstream.hpp>
   #include <vector>
   #include <iterator>
   
   using namespace boost::shmem;

   int main ()
   {
      //Create shared memory
      named_shared_object segment;
      if(!segment.create("/MySharedMemory",  //segment name
                         65536)){            //segment size in bytes
         return -1;
      }

      //Fill data
      std::vector<int> data, data2;
      data.reserve(100);
      for(int i = 0; i < 100; ++i){
         data.push_back(i);
      }

      //Allocate a buffer in shared memory to write data
      char *my_cstring = 
         segment.construct<char>("MyCString")[100*5](0);
      bufferstream mybufstream(my_cstring, 100*5);

      //Now write data to the buffer
      for(int i = 0; i < 100; ++i){
         mybufstream << data[i] << std::endl;
      }

      //Check there was no overflow attempt
      assert(mybufstream.good());

      //Extract all values from the shared memory string
      //directly to a shared memory vector.
      data2.reserve(100);
      std::istream_iterator<int> it(mybufstream), itend;
      std::copy(it, itend, std::back_inserter(data2));

      //This extraction should have ended will fail error
      //since the numbers formatted in the buffer end
      //before the end of the buffer. (Otherwise it would
      //trigger eofbit)
      assert(mybufstream.fail());

      //Compare data
      assert(std::equal(data.begin(), data.end(), data2.begin()));

      //Clear errors and rewind
      mybufstream.clear();
      mybufstream.seekp(0, std::ios::beg);
      
      //Now write again the data trying to do a buffer overflow
      for(int i = 0; i < 500; ++i){
         mybufstream << data[i] << std::endl;
      }

      //Now make sure badbit is active
      //which means overflow attempt.
      assert(!mybufstream.good());
      assert(mybufstream.bad());
      segment.destroy_ptr(my_cstring);      
      return 0;
   }

As seen, *bufferstream* offers an efficient way to format data without any 
allocation and extra copies. This is very helpful in embedded systems, or
formatting inside time-critical loops, where stringstream extra copies would
be too expensive. Unlike sprintf/sscanf, it has protection against buffer
overflows. As we know, according to the *Technical Report on C++ Performance*, 
it's possible to design efficient iostreams for embedded platforms, so this 
bufferstream class comes handy to format data to stack, static or shared memory
buffers.

[endsect]

[endsect]


[section:shared_message_queue Process-shared message queue]

Built above Shmem operating system wrappers, shared_message_queue class 
offers a classic, priority-capable inter-process message queue. Using this 
queue, two threads from different processes, can send/receive 
messages with many send/receive strategies, like blocking, non-blocking
or timed. 

We can send messages with different priorities and higher priority messages will 
be always received before lower priority ones. 

The implementation of this class shows how Shmem primitives can be used to
construct more complex inter-process communication mechanism, like queues,
pipes, etc...

[section:shared_message_queue_int The interface]

The interface provides functions to create, open or create, or only open the queue.
It also provices 3 send and receive functions: blocking, non-blocking and timed, and
some functions to obtain the message queue's parameters like the maximum number of 
messages in the queue and the maximum size of any message.

[c++]

   /*!A class that allows sending messages between processes.*/
   class shared_message_queue
   {
    public:
      /*!Result types when sending or receiving messages*/
      enum result_t  { 
                     ok, 
                     internal_error, 
                     empty, 
                     full, 
                     too_small_buffer, 
                     timeout,  
                     too_big_buffer, 
                     };

      /*!Constructor. Never throws*/
      shared_message_queue();

      /*!Destructor. Calls close. Never throws*/
      ~shared_message_queue(); 

      /*!Creates a process shared message queue with name "name". For this message queue,
         the maximum number of messages will be "max_num_msg" and the maximum message size
         will be "max_msg_size". If queue was previously created or there are no free 
         resources, the function returns false. Never throws*/
      bool create(const char *name, std::size_t max_num_msg, std::size_t max_msg_size);

      /*!Opens or creates a process shared message queue with name "name". 
         If the queue is created, the maximum number of messages will be "max_num_msg" 
         and the maximum message size will be "max_msg_size". If queue was previously 
         created the queue will be opened and "max_num_msg" and "max_msg_size" parameters
         are ignored. If there are no free resources, the function returns false. Never throws*/
      bool open_or_create(const char *name, std::size_t max_num_msg, std::size_t max_msg_size);

      /*!Opens a previously created process shared message queue with name "name". 
         If the was not previously created or there are no free resources, the 
         function returns false. Never throws*/
      bool open(const char *name);

      /*!Sends a message stored in buffer "buffer" with size "buffer_size" in the 
         message queue with priority "priority". If the message queue is full
         the sender is blocked. Returns "ok" if message is placed in the message
         queue, "internal_error" if message queue is corrupted, or "too_big_buffer"
         if parameter "buffer_size" is bigger than the maximum message size allowed
         in the queue. Never throws*/
      result_t send    (const void *buffer,     std::size_t buffer_size, 
                        unsigned int priority);

      /*!Sends a message stored in buffer "buffer" with size "buffer_size" in the 
         message queue with priority "priority". If the message queue is full
         the sender is not blocked. Returns "ok" if message is placed in the message
         queue, "internal_error" if message queue is corrupted, "too_big_buffer"
         if parameter "buffer_size" is bigger than the maximum message size allowed
         in the queue and "full" if message queue is full and message can't be
         placed there. Never throws*/
      result_t try_send    (const void *buffer,     std::size_t buffer_size, 
                            unsigned int priority);

      /*!Sends a message stored in buffer "buffer" with size "buffer_size" in the 
         message queue with priority "priority". If the message queue is full
         the sender is retries until time "xt" is reached. Returns "ok" if message 
         is placed in the message queue, "internal_error" if message queue is corrupted, 
         "too_big_buffer" if parameter "buffer_size" is bigger than the maximum message 
         size allowed in the queue and "timeout" if message can't be placed and time 
         "xt" is reached. Never throws*/
      result_t timed_send    (const void *buffer,     std::size_t buffer_size, 
                              unsigned int priority,  const xtime &xt);

      /*!Receives a message from the message queue. The message is stored in buffer 
         "buffer", which has size "buffer_size". The received message has size 
         "recvd_size" and priority "priority". If the message queue is empty
         the receiver is blocked. Returns "ok" if a message is received from the 
         message queue, "internal_error" if message queue is corrupted, or 
         "too_small_buffer" if parameter "buffer_size" is smaller than the maximum 
         message size allowed in the queue. Never throws*/
      result_t receive (void *buffer,           std::size_t buffer_size, 
                        std::size_t &recvd_size,unsigned int &priority);

      /*!Receives a message from the message queue. The message is stored in buffer 
         "buffer", which has size "buffer_size". The received message has size 
         "recvd_size" and priority "priority". If the message queue is empty
         the receiver is not blocked. Returns "ok" if a message is received from the 
         message queue, "internal_error" if message queue is corrupted, 
         "too_small_buffer" if parameter "buffer_size" is smaller than the maximum 
         message size allowed in the queue or "empty" is message queue is empty. 
         Never throws*/
      result_t try_receive (void *buffer,           std::size_t buffer_size, 
                            std::size_t &recvd_size,unsigned int &priority);

      /*!Receives a message from the message queue. The message is stored in buffer 
         "buffer", which has size "buffer_size". The received message has size 
         "recvd_size" and priority "priority". If the message queue is empty
         the receiver retries until time "xt" is reached. Returns "ok" if a message is
         received from the message queue, "internal_error" if message queue is 
         corrupted, "too_small_buffer" if parameter "buffer_size" is smaller than the 
         maximum message size allowed in the queue or "timeout" is message queue is 
         empty. Never throws*/
      result_t timed_receive (void *buffer,           std::size_t buffer_size, 
                              std::size_t &recvd_size,unsigned int &priority,
                              const xtime &xt);

      /*!Closes the message queue and frees resources. A new message queu can be opened
         after close() is called. Never throws*/
      void close();

      /*!Returns the maximum number of messages allowed by the queue. The message
         queue must be opened or created previously. Otherwise, returns 0. 
         Never throws*/
      std::size_t get_max_num_msg() const;

      /*!Returns the maximum size of message allowed by the queue. The message
         queue must be opened or created previously. Otherwise, returns 0. 
         Never throws*/
      std::size_t get_max_msg_size() const;
   };

The message queue is destroyed when the last process connected to the queue closes
the connection calling *close()*.

[endsect]

[section:shared_message_queue_ex Example: Serializing a database through the message queue]

The following example shows how a message queue can be used to serialize a whole
database constructed in a buffer using Shmem machinery, so that the database
is duplicated in another buffer:

[c++]
   
   //This test creates a in memory data-base using Shmem machinery and 
   //serializes it through a message queue. Then rebuilds the data-base in 
   //another buffer and checks it against the original data-base
   bool test_serialize_db()
   {
      //Shared memory queues
      shared_message_queue mq1, mq2;

      //Typedef data to create a Shmem map   
      typedef std::pair<const std::size_t, std::size_t> MyPair;
      typedef std::less<std::size_t>   MyLess;
      typedef node_allocator<MyPair, 64, named_user_object::segment_manager> 
         node_allocator_t;
      typedef map<std::size_t, 
                  std::size_t, 
                  std::less<std::size_t>, 
                  node_allocator_t>
                  MyMap;

      //Some constants
      const std::size_t BufferSize  = 4096;
      const std::size_t MaxMsgSize  = 100;

      //Allocate two memory buffers from heap using vector<char>
      std::vector<char> buffer1(BufferSize, 0), buffer2(BufferSize, 0);

      //Create the message-queue
      if(!mq1.create("message_queue", 1, MaxMsgSize)){
         return false;
      }

      //Open previously created message-queue simulating other process
      if(!mq2.open("message_queue")){
         return false;
      }

      //Shmem machinery to manage previously allocated buffer1 and buffer2
      named_user_object db1, db2;      

      //Create Shmem machinery in the first buffer
      if(!db1.create(&buffer1[0], buffer1.size())){
         return false;
      }

      //Construct the map in the first buffer
      MyMap *map1 = db1.construct<MyMap>("MyMap")
                                        (MyLess(), 
                                         db1.get_segment_manager());
      if(!map1)
         return false;

      //Fill map1 until is full 
      try{
         std::size_t i = 0;
         while(1){
            (*map1)[i] = i;
            ++i;
         }
      }
      catch(boost::shmem::bad_alloc &){}

      //Data control data sending through the message queue
      std::size_t sent = 0;
      std::size_t recvd = 0;
      std::size_t total_recvd = 0;
      unsigned int priority;

      //Send whole first buffer through the mq1, read it 
      //through mq2 to the second buffer
      while(1){
         //Send a fragment of buffer1 through mq1
         std::size_t bytes_to_send = MaxMsgSize < (BufferSize - sent) ? 
                                       MaxMsgSize : (BufferSize - sent);
         switch(mq1.send(&buffer1[sent], bytes_to_send, 0)){
            case shared_message_queue::ok:
               sent += bytes_to_send;         
            break;

            default:
               return false;
         }
         //Receive the fragment through mq2 to buffer2
         switch(mq2.receive(&buffer2[total_recvd], BufferSize - recvd, 
                           recvd,                 priority)){   
            case shared_message_queue::ok:
               total_recvd += recvd; 
            break;

            default:
               return false;
         }

         //Check if we have received all the buffer
         if(total_recvd == BufferSize){
            break;
         }
      }
      
      //We don't need message queues anymore
      mq1.close();
      mq2.close();
       
      //The second buffer will contain a copy of the buffer1 
      //map so let's open Shmem machinery in the second buffer  
      if(!db2.open(&buffer2[0], BufferSize)){
         return false;
      }

      //Let's find the map
      std::pair<MyMap *, std::size_t> ret = db2.find<MyMap>("MyMap");
      MyMap *map2 = ret.first;

      //Check if we have found it
      if(!map2){
         return false;
      }

      //Check if it is a single variable (not an array)
      if(ret.second != 1){
         return false;
      }

      //Now let's compare size
      if(map1->size() != map2->size()){
         return false;
      }

      //Now let's compare all db values
      for(std::size_t i = 0, num_elements = map1->size(); i < num_elements; ++i){
         if((*map1)[i] != (*map2)[i]){
            return false;
         }
      }
      
      //Destroy maps from db-s
      db1.destroy_ptr(map1);
      db2.destroy_ptr(map2);

      db1.close();
      db2.close();

      return true;
   }

[endsect]

[endsect]

[section:architecture Shmem architecture and internals]

[section:basic_guidelines Basic guidelines]

When building Shmem architecture, I took some basic guidelines that can be
resumed in these points:

*  Shmem should be portable at least in UNIX and Windows systems. That means
   I've tried to unify not only interfaces but also behaviour. This is why
   Shmem does not support (for the moment) the file-like (unlink, etc..) behaviour 
   of Unix shared memory or supposes no fixed address mappings. 

*  Shmem inter-process synchronization primitives should be equal to thread 
   synchronization primitives. That's why Shmem synchronization primitives 
   are based in Boost Thread's interface.

*  Shmem architecture should be modular, customizable but efficient. That's why
   I took templates approach and I made memory algorithms, index types, mutex
   types and other classes templatizable.

*  Shmem architecture should allow the same concurrency as thread based programming.
   This is why there are different mutual exclusion levels so that a process can 
   concurrently allocate raw memory when expanding a shared memory vector while another
   process can be safely searching a named object.

*  Shmem containers know nothing about Shmem. All specific behaviour is contained
   in the STL-like allocators. That allows STL vendors to slightly modify 
   (or better said, generalize) their standard container implementations and obtain
   a fully std::allocator and boost::shmem::allocator compatible container. This also
   make Shmem containers compatible with standard algorithms.

Shmem is built above 3 basic classes: a *memory algorithm* a *segment manager* and
an *front-end*:

[endsect]

[section:architecture_memory_algorithm The memory algorithm]

The *memory algorithm* is an object that is placed in the first bytes of a 
shared memory/memory mapped file segment. The *memory algorithm* can return 
portions of that segment to users marking them as used and the user can return those
portions to the memory manager so that the memory manager mark them as free
again. There is an exception though, some bytes after the memory algorithm
object end, are reserved and can't be used for this dynamic allocation.
This "reserved" zone will be used to place other additional objects
in a known place.

To sum up, a *memory algorithm* has the same mission as malloc/free of
standard C library, but it just can returns portions of the segment
where it is placed. The layout of a memory segment would be:

[c++]

   Layout of the memory segment:
    ____________ __________ ____________________________________________  
   |            |          |                                            | 
   |   memory   | reserved |  The memory algorithm will return portions | 
   | algorithm  |          |  of the rest of the segment.               | 
   |____________|__________|____________________________________________| 


The memory algorithm takes care of memory synchronizations, just like malloc/free
guarantees that two threads can call malloc/free at the same time. This is usually
achieved placing a process-shared mutex as a member of the memory algorithm.Take 
in care that the memory algorithm knows *nothing* about the segment (if it is
shared memory, a shared memory file, etc.). For the memory algorithm the segment 
is just a fixed size memory buffer.

The *memory manager* is also a configuration point for the rest of the Shmem 
framework since it defines two basic types as member typedefs:

[c++]

   typedef /*implementation dependant*/ void_pointer;
   typedef /*implementation dependant*/ mutex_family;


The `void_pointer` typedef defines the pointer type that will be used in the Shmem
framework (segment manager, allocators, containers). If the memory algorithm is ready
to be placed in a shared memory/mapped file mapped in different base addresses, this
pointer type will be defined as offset_ptr<void> or a similar relative pointer. 
If the memory algorithm will be used just with fixed address shared 
memory/memory mapped file, void_pointer can be defined as `void*`.

The rest of the interface of a Shmem *memory manager* is described in 
[link shmem.custom_shmem_alloc Writing a new shared memory allocation algorithm] 
section. As memory algorithm examples, you can see the implementations
[@../../../../boost/shmem/mem_algo/simple_seq_fit.hpp  boost::shmem::simple_seq_fit] or
[@../../../../boost/shmem/mem_algo/seq_fit.hpp  boost::shmem::seq_fit] classes.

[endsect]

[section:architecture_segment_manager The segment manager]

The *segment manager*, is an object also placed in the first bytes of the
memory segment (shared memory, memory mapped file), that offers more sofisticated 
services built above the *memory algorithm*. How can *both* the segment manager 
and memory algorithm be placed in the beginning of the segment? That's 
because the segment manager *owns* the memory algorithm: The
truth is that the memory algorithm is *embedded* in the segment manager:


[c++]

   The layout of segment manager:
    _______ _________________
   |       |         |       |
   | some  | memory  | other |<- The memory algorithm considers 
   |members|algorithm|members|   "other members" as reserved memory, so
   |_______|_________|_______|   it does not use it for dynamic allocation.
   |_________________________|____________________________________________
   |                         |                                            |
   |    segment manager      |  The memory algorithm will return portions |
   |                         |  of the rest of the segment.               |
   |_________________________|____________________________________________|


The segment manager initializes the memory algorithm and tells the memory 
manager that it should not use the memory where the rest of the 
segment manager's member are placed for dynamic allocations. The 
other members of the *segment manager* are *a recursive mutex*
(described by the memory algorithm's *mutex_family* typedef member),
and *two indexes (maps)*: one to make named allocations, and another one to 
make "unique instance" allocations. 

*  The first index is a map with a c-string (the name of the named object) 
   as a key and a structure with information of the dynamically allocated object
   (the most importants being the address and the size of the object). 

*  The second index is used to implement "unique instances" 
   and is basically the same as the first index, 
   but the name of the object comes from a `typeid(T).name()` operation.

The memory needed to store [name, object information] pairs in the index is 
allocated also via the *memory algorithm*, so we can tell that internal indexes
are just like ordinary user objects built in the segment.

As seen, the segment manager knows *nothing* about shared memory/memory mapped files. 
The segment segment manager itself does not allocate portions of the segment, 
it just asks the *memory algorithm* to allocate the needed memory from the rest 
of the segment. The *segment manager* is a class built above the memory algorithm 
that offers named object construction, unique instance constructions, and many
other services.

The *segment manager* is implemented in Shmem in 
[@../../../../boost/shmem/detail/segment_manager.hpp boost::shmem::detail::segment_manager]
class.

[c++]

   template<class CharType 
           ,class MemoryAlgorithm
           ,template<class IndexConfig> class IndexType>
   class segment_manager;

As seen, the segment manager is quite generic: we can specify the char type to be
used to identify named objects, we can specify the memory algorithm that will
control dynamically the portions of the memory segment, and we can specify 
also the index type that will store the [name, object information] mapping.
We can construct our own index types as explained in
[link shmem.custom_indexes Building custom indexes] section.

[endsect]

[section:architecture_front_end Shmem front-ends]

The Shmem front-ends are classes that construct the shared memory/memory mapped file, 
place there the segment manager and forward the user requests to the segment manager. 
For example, *boost::shmem::basic_named_shared_object<...>* is a Shmem front-end
that works with shared memory. *boost::shmem::basic_named_mfile_object<...>*

Basically, the interface of a Shmem front-end is the same as the *segment manager*
but they also offer functions to open, create, open_or_create or shared 
memory/memory-mapped files segments, initialize all needed resources 
and they store a pointer to the segment manager. Shmem front-ends are not built in
shared memory or memory mapped files.

Apart from this, front-ends offer specific functions: front-ends for memory mapped files
offer functions to flush memory contents to the file, heap memory front-ends offer
functions to expand the memory, etc...

Most of the functions of Shmem front-ends can be shared between all front-ends, since
many times they just forward the functions to the segment manager. Because of this,
in Shmem all front-ends derive from a common class that implements memory-independent
(shared memory, memory mapped files) functions:
[@../../../../boost/shmem/detail/named_object_impl.hpp 
boost::shmem::detail::basic_named_object_impl]

Deriving from this class, Shmem implements several front-ends, for different memory backends:

* [@../../../../boost/shmem/named_shared_object.hpp boost::shmem::basic_named_shared_object] (for shared memory),
* [@../../../../boost/shmem/named_mfile_object.hpp boost::shmem::basic_named_mfile_object] (for memory mapped files),
* [@../../../../boost/shmem/named_heap_object.hpp boost::shmem::basic_named_heap_object] (for heap allocated memory),
* [@../../../../boost/shmem/named_user_object.hpp boost::shmem::basic_named_user_object] (for user provided memory buffer),

[endsect]

[section:architecture_allocators Shmem allocators]

The Shmem STL-like allocators are fairly simple and follow the usual C++ allocator
approach. Normally, allocators for STL containers are based above new/delete operators
and above those, they implement pools, arenas and other allocation tricks.

In Shmem allocators, the approach is similar, but all allocators are based on the
*segment manager*. The segment manager is the only one that provides from simple
memory allocation to named object creations. Shmem allocators always store a pointer
to the segment manager, so that they can obtain memory from the segment or share
a common pool between allocators.

As you can imagine, the member pointers of the allocator are not a raw pointers, but
pointer types defined by the `segment_manager::void_pointer` type. Apart from this,
the `pointer` typedef of Shmem allocators is also of the same type of
`segment_manager::void_pointer`.

This means that if our allocation algorithm defines `void_pointer` as 
`offset_ptr<void>`, `boost::shmem::allocator<T>` will store an `offset_ptr<segment_manager>`
to point to the segment manager and the `boost::shmem::allocator<T>::pointer` type will
be `offset_ptr<T>`. This way, Shmem allocators can be placed in the same memory as
the segment manager, that is, shared memory, memory mapped files, etc...

Shmem implements basically two allocator approaches: normal and pooled. The pool is
implemented in [@../../../../boost/shmem/allocators/detail/node_pool.hpp boost::shmem::named_shared_object],

[endsect]

[section:architecture_containers Shmem containers]

Shmem containers are basically common STL containers: they can even use
STL allocators. Basically a Shmem container has the same implementation as
the STL container, but with these little details:

*  Shmem STL containers don't assume that memory allocated with 
   an allocator can be deallocated with other allocator of 
   the same type. They always compare allocators with `operator==()`
   to know if this is possible. If allocators are equal Shmem containers optimize
   swapping and similar operations, if not, they use alternative approaches.

*  The pointers of the internal structures of the Shmem containers are of the 
   same type the `pointer` type defined by the allocator of the container.

*  All objects are constructed-destroyed via allocator::construct and 
   allocator::destroy functions.

[endsect]

[endsect]

[section:open_issues Open Issues]

In this section open design issues are described. These should be closed
during the review process. Some issues are related to (perhaps) soon to be 
changed Boost Thread interface, so those will require consensus with Boost
Threads's mantainers and users.

[section:open_names Class names]

Name suggestions for class names are also welcome if people find the current 
ones don't express well their functionality.

[endsect]

[section:open_objectnames Names of Shmem basic resources]

Currently Shmem does not guarantee their own namespace for all named basic Shmem 
objects (shared_memory, mmapped_file, named_semaphore...), so that we can't create
a named semaphore and a shared memory called "MyName".

If this approach is considered harmful, during the review process we should
reach an agreement about naming conventions.

[endsect]

[section:open_time Time management should be changed]

Shmem implements the same interface as Boost Thread with timed methods
in synchronization primitives, like mutexes and condition variables.
Boost Thread uses boost::xtime functions and since in single threaded
processes we can't use Boost Thread headers, Shmem duplicates these
functions with boost::shmem::xtime.

However, boost::xtime was supossed to be a temporary solution until
a general Boost time framework was developed. Shmem should follow
Boost Thread's path and there are two ways to solve this:

* Don't forbid using xtime with single threaded processes.
* Port timed functions from Boost Thread and Shmem to Boost Date_Time
  if Date_Time provides the needed resolution for real-time programming.

[endsect]

[section:open_sync Interface of synchronization primitives and Boost Thread]

Shmem mutexes and conditions implements the same interface as Boost Thread,
but this interface has some restrictions:

* Boost Thread's scoped locks can't be used with Shmem, leading to duplication.
* Boost Thread's read_write_mutex implementation seems to hurt performance and
  some have requested a simpler implementation.
* The process-shared message queue should have the same interface as a
  future thread-shared message queue Boost Thread could have.
  
Some personal suggestions about improving mutex and condition's interface:

* Implement public lock(), unlock(), etc... functions for mutexes. Using
  scoped_locks should be optional. This can convert scoped_locks in general
  locking classes that can lock any *lockable* object. Some standard proposals
  seem to go this route.

* Implement read_write_mutex using with a simpler interface, without scheduling
  issues (just like POSIX standard). This will help performance and we can
  implement read_write_mutex using efficient atomic primitives.

* Design a simple message queue interface that can be used for both inter-thread
  and inter-process communications.
  
All these issues require coordination with Boost Thread users and developers.

[endsect]

[endsect]

[section:future_improvements Future Improvements...]

There are some Shmem features that I would like to implement and
some Shmem code that can be much better. Let's see some ideas:

[section:win32_sync Win32 synchronization is too basic]

Win32 version of shared mutexes and shared conditions are based on
"spin and wait" atomic instructions. This leads to poor performance
and does not manage any memory synchronization (memory model) or 
priority inversions. We would need very serious help from threading 
experts on this. And I'm not sure that 
this can be achieved in user-level software. Posix based implementations
use PTHREAD_PROCESS_SHARED attribute to place mutexes in shared memory, so
there are no such problems. I'm not aware of any implementation that 
simulates PTHREAD_PROCESS_SHARED attribute for Win32. We should be able
to construct these primitives in memory mapped files, so that we can 
get filesystem persistence just like with POSIX primitives.

[endsect]

[section:default_algorithm Default allocation algorithm can be improved]

The default memory management algorithm used by Shmem to manage the
fixed size memory segment is a "first fit" algorithm. This could be changed
to a "best fit" algorithm to try to minimize fragmentation, but this would 
hurt performance if a list is used to mantain the free memory portions.
This can be solved with a tree-like free memory management, so that we can
search the best portion in logarithmic time. And we have to implement the
tree inside the given segment wasting minimum space. This seems complicated, 
but with the help of an intrusive tree implementation this can be achieved.

Suggestions and help from memory management experts are welcome!

[endsect]

[section:future_objectnames Use of wide character names on Shmem basic resources]

Currently Shmem only allows *char* based names for basic synchronizationobjects. 
However, several operating systems use *wchar_t* names for resources 
(mapped files, for example). 
In the future Shmem should try to present a portable narrow/wide char interface.
To do this, it would be useful to have a boost wstring <-> string conversion 
utilities to translate resource names (escaping needed characters
that can conflict with OS names) in a portable way. It would be interesting also 
the use of *boost::filesystem* paths to avoid operating system specific issues.

[endsect]

[section:future_security Security attributes]

Shmem does not define security attributes for shared memory and synchronization
objects. Standard C++ also ignores security attributes with files so adding
security attributes would require some serious work.

[endsect]

[section:future_ipc Future inter-process communications]

Shmem offers a process-shared message queue based on Shmem primitives
like mutexes and conditions. I would want to develop more mechanisms, like
stream-oriented named fifo so that we can use it with a iostream-interface
wrapper (we can imitate Unix pipes).

C++ needs more complex mechanisms and it would be nice to have a stream and
datagram oriented PF_UNIX-like mechanism in C++. And for very fast inter-process 
remote calls Solaris doors is an interesting alternative to implement
for C++. But the work to implement PF_UNIX-like sockets and doors would
be huge. Any network expert volunteer?

[endsect]

[section:future_containers Unordered associative containers and other containers]

We should be able to construct boost::unordered_xxx family in shared memory,
so that there is no code duplication in boost. So Shmem should cooperate with
boost container developers instead of duplicating effort writing it's own containers.

A very interesting project is making *multi_index* ready for shared memory. This
could be a good basis for memory mapped data-bases. The work to achieve this, 
however, can be huge. It would be interesting a collaboration with *Intrusive* library
to achieve shared memory intrusive containers.

[endsect]

[endsect]

[section:thanks_to Thanks to...]

Many people have contributed with ideas and revisions, so this is the place to
thank them:

* Thanks to all people who have shown interest in the library and have downloaded
  and tested the snapshots.

* Thanks to [*Francis Andre] and [*Anders Hybertz] for their ideas and suggestions. 
  Many of them are not implemented yet but I hope to include them when library gets some stability.

* Thanks to [*Phil Endecott], [*Rene Rivera], [*Harold Pirtle] and [*Kim Barrett] for their bug fixes and library testing.

* Thanks to [*Martin Adrian] who suggested the use of Shmem framework for user defined buffers.

* Thanks to [*Synge Todo] for his boostbook-doxygen patch to improve Shmem documentation.

* Thanks to [*Olaf Krzikalla] for his Intrusive library. I have taken some ideas to 
  improve red black tree implementation from his library.
      
* Thanks to [*Daniel James] for his unordered_map/set family and his help with allocators.
  His great unordered implementation has been a reference to design exception safe containers.  

* Thanks to [*Howard Hinnant] for his patience explaining allocator swapping and showing me
  new "moving" concepts with future rvalue references. Kill those temporaries!

* Thanks to [*Pavel Vozenilek] for his continuous review process, suggestions, code and 
  help. He is the major supporter of Shmem library. The library has grown with his
  many and great advices.

* And finally, thank you to all Boosters. *Long live to C++!*

[endsect]

[section:references References and interesting links]

Some useful references about C++ language, C++ internals, shared memory, 
allocators and containers, I've used to design Shmem.

[section:references_books Books]

* Great book about multithreading, and POSIX: [*['"Programming with Posix Threads"]],
  [*David R. Butenhof]

* The UNIX inter-process bible: [*['"UNIX Network Programming, Volume 2: Interprocess Communications"]],
  [*W. Richard Stevens]

* Current STL allocator issues: [*['"Effective STL"]], [*Scott Meyers]

* My C++ bible: [*['"Thinking in C++, Volume 1 & 2"]], [*Bruce Eckel]

* The book every C++ programmer should read: [*['"Inside the C++ Object Model"]], [*Stanley B. Lippman]

* A must-read: [*['"ISO/IEC TR 18015: Technical Report on C++ Performance"]], [*ISO WG21-SC22 members.]



[endsect]

[section:references_links Links]

* A framework to put STL in shared memory: [@http://allocator.sourceforge.net/ ['"A C++ Standard Allocator for the Standard Template Library"] ]. 

* A design for instantiating C++ objects in shared memory: [@http://www.cs.ubc.ca/local/reading/proceedings/cascon94/htm/english/abs/hon.htm ['"Using objects in shared memory for C++ application"] ].

* A shared memory allocator and relative pointer: [@http://home.earthlink.net/~joshwalker1/writing/SharedMemory.html ['"Taming Shared Memory"] ].


[endsect]

[endsect]

[xinclude shmem.doxygen.boostbook]

