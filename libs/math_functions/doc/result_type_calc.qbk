
[section:result_type Calculation of the Type of the Result]

[blurb ['"Given a special function with N arguments of
types T1, T2, T3 ... TN, then what type is the result?"]]

If all the arguments are of the same (floating point) type then the 
result is the same type as the arguments, otherwise, the type of the result
is computed using the following logic:

# For each type in the argument list, if that type is an integer type
then it is treated as if it were of type double for the purposes of
further analysis.
# If any of the arguments is a user-defined class type, then the result type
is the first such class type that is constructable from all of the other
argument types.
# If any of the arguments is of type `long double`, then the result is of type
`long double`.
# If any of the arguments is of type `double`, then the result is of type
`double`.
# Otherwise the result is of type `float`.

For example:
   
   cyl_bessel(2, 3.0);
   
Returns a `double` result, as does:

   cyl_bessel(2, 3.0f);
   
as in this case the integer first argument is treated as a `double` and takes
presidence over the `float` second argument.  To get a `float` result we would need
all the arguments to be of type float:

   cyl_bessel_j(2.0f, 3.0f);

And for user defined types, all of the following return an NTL::RR result:

   cyl_bessel_j(0, NTL::RR(2));
   
   cyl_bessel_j(NTL::RR(2), 3);
   
   cyl_bessel_j(NTL::quad_float(2), NTL::RR(3));
   
In the last case, quad_float is convertible to RR, but not vice-versa, so
the result will be an NTL::RR.  Note that this assumes that you are using
a [link math_toolkit.Using_UDT.use_NTL patched NTL library].

These rules are chosen to be compatible with the behaviour of 
['ISO/IEC 9899:1999 Programming languages - C]
and with the ['[@www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf Technical Report on C++ Library Extensions]].

[endsect]

