[#igamma][section The Incomplete Gamma Function]

[caution __caution ]

[h4 Synopsis]

``
#include <boost/math/special_functions/gamma.hpp>
``

   namespace boost{ namespace math{
   
   template <class T>
   T tgamma(T a, T z);
   
   template <class T>
   T tgamma_lower(T a, T z);
   
   template <class T>
   T gamma_Q(T a, T z);
   
   template <class T>
   T gamma_P(T a, T z);
   
   }} // namespaces
   
[h4 Description]

There are four incomplete gamma functions: two are normalised versions
that return values in the range [0, 1], and two are non-normalised and
return values in the range [0, gamma(a)].  Users interested in statistical
applications should use the normalised versions (gamma_P and gamma_Q).

All of these function require /a > 0/ and /z >= 0/.

   template <class T>
   T tgamma(T a, T z);

Returns the full (non-normalised) upper incomplete gamma function of a and z:

[$../equations/igamma1.png]

   template <class T>
   T tgamma_lower(T a, T z);

Returns the full (non-normalised) lower incomplete gamma function of a and z:

[$../equations/igamma2.png]

   template <class T>
   T gamma_Q(T a, T z);

Returns the normalised upper incomplete gamma function of a and z:

[$../equations/igamma3.png]

This function changes rapidly from 1 to 0 around the point z == a:

[$../graphs/gamma_q.png]

   template <class T>
   T gamma_P(T a, T z);
   
Returns the normalised lower incomplete gamma function of a and z:

[$../equations/igamma4.png]

This function changes rapidly from 0 to 1 around the point z == a:

[$../graphs/gamma_p.png]

[h4 Accuracy]

The following tables give peek and mean relative errors in over various domains of
a and z, along with comparisons to other open source implementations where available.  
Note that only results for the widest floating point type on the system are given as
narrower types have __zero_error.

Note that for very large /a/ and /a ~ z/, these functions are currently quite slow.  
Errors also grow as /a/ grows larger.

[table Errors In the Function tgamma(a,z)
[[Mantissa Size] [Platform and Compiler] [0.5 < a < 100\nand\n0.01*a < z < 100*a]  [1e-12 < a < 5e-2\nand\n0.01*a < z < 100*a]]
[[53] [Win32, Visual C++ 8] [Peek=5.9 Mean=1.5]  [Peek=1.8 Mean=0.6]]
[[64] [RedHat Linux IA32, gcc-3.3] [Peek=596 Mean=116]  [Peek=3.2 Mean=0.84]]
[[64] [Redhat Linux IA64, gcc-3.4.4] [Peek=40.2 Mean=2.5]  [Peek=3.2 Mean=0.8]]
[[113] [HPUX IA64, aCC A.06.06] [Peek=364 Mean=17.6]  [Peek=12.7 Mean=1.8]]
]

[table Errors In the Function tgamma_lower(a,z)
[[Mantissa Size] [Platform and Compiler] [0.5 < a < 100\nand\n0.01*a < z < 100*a]  [1e-12 < a < 5e-2\nand\n0.01*a < z < 100*a]]
[[53] [Win32, Visual C++ 8] [Peek=5.5 Mean=1.4]  [Peek=3.6 Mean=0.78]]
[[64] [RedHat Linux IA32, gcc-3.3] [Peek=402 Mean=79]  [Peek=3.4 Mean=0.8]]
[[64] [Redhat Linux IA64, gcc-3.4] [Peek=6.8 Mean=1.4]  [Peek=3.4 Mean=0.78]]
[[113] [HPUX IA64, aCC A.06.06] [Peek=6.1 Mean=1.8]  [Peek=3.7 Mean=0.89]]
]

[table Errors In the Function gamma_Q(a,z)
[[Mantissa Size] [Platform and Compiler] [0.5 < a < 100\nand\n0.01*a < z < 100*a]  [1e-12 < a < 5e-2\nand\n0.01*a < z < 100*a] [1e-6 < a < 1.7e6\nand\n1 < z < 100*a]]
[[53] [Win32, Visual C++ 8] [Peek=28.3 Mean=7.2\n\n(GSL Peek=201 Mean=13)\n(Cephes Peek=556 Mean=97)]  [Peek=4.8 Mean=1.6\n\n(GSL Peek~1.3e10 Mean=1e+9)\n(Cephes Peek~3e11 Mean=4e10)] [Peek=469 Mean=33\n\n(GSL Peek=27,050 Mean=2159)\n(Cephes Peek~8e6 Mean~7e5)]]
[[64] [RedHat Linux IA32, gcc-3.3] [Peek=280 Mean=33]  [Peek=4.1 Mean=1.6] [Peek=11,490 Mean=732]]
[[64] [Redhat Linux IA64, gcc-3.4] [Peek=32 Mean=9.4]  [Peek=4.7 Mean=1.5] [Peek=6815 Mean=414]]
[[113] [HPUX IA64, aCC A.06.06] [Peek=37 Mean=10]  [Peek=11.2 Mean=2.0] [Peek=4,999 Mean=298]]
]

[table Errors In the Function gamma_P(a,z)
[[Mantissa Size] [Platform and Compiler] [0.5 < a < 100\nand\n0.01*a < z < 100*a]  [1e-12 < a < 5e-2\nand\n0.01*a < z < 100*a] [1e-6 < a < 1.7e6\nand\n1 < z < 100*a]]
[[53] [Win32, Visual C++ 8] [Peek=36 Mean=9.1\n\n(GSL Peek=342 Mean=46)\n(Cephes Peek=491 Mean=102)]  [Peek=4.5 Mean=1.4\n\n(GSL Peek=4.8 Mean=0.76)\n(Cephes Peek=21 Mean=5.6)] [Peek=244 Mean=21\n\n(GSL Peek=1022 Mean=1054)\n(Cephes Peek~8e6 Mean~7e4)]]
[[64] [RedHat Linux IA32, gcc-3.3] [Peek=241 Mean=36]  [Peek=4.7 Mean=1.5] [Peek~30,220 Mean=1929]]
[[64] [Redhat Linux IA64, gcc-3.4] [Peek=41 Mean=10]  [Peek=4.7 Mean=1.4] [Peek~30,790 Mean=1864]]
[[113] [HPUX IA64, aCC A.06.06] [Peek=40.2 Mean=10.2]  [Peek=5 Mean=1.6] [Peek=5,476 Mean=440]]
]

[h4 Testing]

There are two sets of tests: spot tests compare values taken from Mathworld's
online calculator with this implementation: they provide a basic "sanity check"
for the implementation.  Accuracy tests use data generated at very high precision
(using NTL's RR class set at 1000-bit precision) using this implementation 
with a very high precision 60-term __lanczos.
This is less than satisfactory: an independent method should really be used,
but apparently a complete lack of such methods are available.  We can't even use a deliberately
naive implementation without special case handling since Legendre's continued fraction
(see below) is unstable for small a and z.

[h4 Implementation]

The implementation of these functions are all related since:

[$../equations/igamma5.png]

[$../equations/igamma6.png]

[$../equations/igamma7.png]

The lower incomplete gamma is computed from it's series representation:

[$../equations/igamma8.png]

Or by subtraction of the upper integral from either gamma(a) or 1
when /x > max(a+1, 10)/.

The upper integral is computed from Legendre's continued fraction representation:

[$../equations/igamma9.png]

When /x > 1/ or by subtraction of the lower integral from either gamma(a) or 1
when /x < a+1/.

For /x < 1/ computation of the upper integral is more complex as the continued 
fraction representation is inaccurate in this area.  However there is another 
series representation for the lower integral:

[$../equations/igamma10.png]

That lends itself to calculation of the upper integral via rearrangement
to:

[$../equations/igamma11.png]

Obviously this is only accurate if the functions "powm1" and "gp1m1" are
accurately calculated. "gp1m1" is computed via the following rearrangement
of the __lanczos, note that no generic version of this function is available
and so the accuracy of the fully generic version of the upper incomplete
gamma functions is likely to limited to approximately long double precision.

[$../equations/igamma11b.png]

The terms in square brackets in the above are evaluated as special
functions in their own right to avoid cancellation errors.

For the normalised incomplete gamma function's then calculation of the 
leading power terms
is central to the accuracy of the function.  For smallish a and x combining
the power terms with the __lanczos gives the greatest accuracy:

[$../equations/igamma12.png]

In the event that this causes underflow/overflow then the exponent can 
be reduced by a factor of /a/ and brought inside the power term.

When a and x are large we end up with a very large exponent with a base
near one: this will not be computed accurately via the pow function,
and taking logs simply leads to cancellation errors.  The worst of the
errors can be avoided by using:

[$../equations/igamma13.png]

when /a-x/ is small and a and x are large.  There is still a subtraction
and therefore some cancellation errors - but the terms are small so the absolute
error will be small - and it's absolute rather than relative error that 
counts in the argument to the /exp/ function.  Note that for sufficiently
large a and x the errors will still get you eventually, although this does
delay the inevitable much longer than other methods.  Use of /log(1+x)-x/ here
is inspired by Temme (see references below).

Finally, I note that there is an asymptotic expansion available
when a and x are large: however this requires backwards evaluation
of a series (forwards evaluation is unstable), and therefore 
foreknowledge of the number of terms required (see Temme).  The accuracy quoted
by it's authors is also lower than that obtained here with careful
evaluation of the leading power terms.  However, the Legendre continued
fraction in particular become increasingly expensive to compute for larger
a and x, so this area needs more investigation.

Also needing further attention is the area where a is very small and x is near 1, 
and where a and x are both vanishingly small.

[h4 References]

* N. M. Temme, A Set of Algorithms for the Incomplete Gamma Functions,
Probability in the Engineering and Informational Sciences, 8, 1994.
* W. Gautschi, The Incomplete Gamma Functions Since Tricomi, In Tricomi's Ideas 
and Contemporary Applied Mathematics, Atti dei Convegni Lincei, n. 147, 
Accademia Nazionale dei Lincei, Roma, 1998, pp. 203--237. 
[@http://citeseer.ist.psu.edu/gautschi98incomplete.html http://citeseer.ist.psu.edu/gautschi98incomplete.html]

[endsect]

