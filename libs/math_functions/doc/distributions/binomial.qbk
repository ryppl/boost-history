[section:binomial_dist Binomial]

``#include <boost/math/distributions/binomial.hpp>``

   namespace boost{ namespace math{ 
   
   template <class RealType = double>
   class binomial_distribution;
   
   // typedef binomial_distribution<double> binomial;
   // Note that this is NOT provided to avoid a clash with the function name.
   // Use binomial_distribution<> myBinomial(...) to construct type double. 
   
   template <class RealType>
   class binomial_distribution
   {
   public:
      // construct:
      binomial_distribution(RealType n, RealType p);
      
      // parameter access::
      RealType success_fraction() const;
      RealType trials() const;
      
      // Bounds on success fraction:
      static RealType estimate_lower_bound_on_p(
         RealType trials, 
         RealType successes,
         RealType probability);
      static RealType estimate_upper_bound_on_p(
         RealType trials, 
         RealType successes,
         RealType probability);
         
      // estimate min/max number of trials:
      static RealType estimate_number_of_trials(
         RealType k,     // number of events
         RealType p,     // success fraction
         RealType probability); // probability threshold
         
      template <class P1, class P2, class P3>
      static RealType estimate_number_of_trials(
         const ``['unspecified-complemented-type]``<P1, P2, P3>& c);
   };
   
   }} // namespaces
   
The class type `binomial_distribution` represents a binomial distribution:
it is used when there are exactly two mutually 
exclusive outcomes of a trial. These outcomes are labelled 
"success" and "failure". The binomial distribution is used to obtain 
the probability of observing k successes in N trials, with the 
probability of success on a single trial denoted by p. The 
binomial distribution assumes that p is fixed for all trials.

The PDF for the binomial distribution is given by:

[$../equations/binomial_ref2.png]

The following two graphs illustrate how the PDF changes depending
upon the distributions parameters, first we'll keep the success
fraction /p/ fixed at 0.5, and vary the sample size:

[$../graphs/binomial_pdf_1.png]

Alternatively, we can keep the sample size fixed at N=20 and
vary the success fraction /p/:

[$../graphs/binomial_pdf_2.png]

   
[h4 Member Functions]

   binomial_distribution(RealType n, RealType p);

Constructor: /n/ is the total number of trials, /p/ is the
probability of success of a single trial.

   RealType success_fraction() const;
   
Returns the parameter /p/ from which this distribution was constructed.
   
   RealType trials() const;
   
Returns the parameter /n/ from which this distribution was constructed.

   static RealType estimate_lower_bound_on_p(
      RealType trials, 
      RealType successes,
      RealType alpha);
      
Returns a lower bound on the success fraction:

[variablelist
[[trials][The total number of trials conducted.]]
[[successes][The number of successes that occurred.]]
[[alpha][The largest acceptable probability that the true value of
         the success fraction is [*less than] the value returned.]]
]

For example, if you observe /k/ successes from /n/ trials the
best estimate for the success fraction is simply ['k/n], but if you
want to be 95% sure that the true value is [*greater than] some value, 
['p[sub min]], then:

   p``[sub min]`` = binomial_distribution<RealType>::estimate_lower_bound_on_p(
                       n, k, 0.05);

[link math_toolkit.dist.stat_tut.weg.binom_eg.binom_conf See worked example.]
      
   static RealType estimate_upper_bound_on_p(
      RealType trials, 
      RealType successes,
      RealType alpha);
      
Returns an upper bound on the success fraction:

[variablelist
[[trials][The total number of trials conducted.]]
[[successes][The number of successes that occurred.]]
[[alpha][The largest acceptable probability that the true value of
         the success fraction is [*greater than] the value returned.]]
]

For example, if you observe /k/ successes from /n/ trials the
best estimate for the success fraction is simply ['k/n], but if you
want to be 95% sure that the true value is [*less than] some value, 
['p[sub max]], then:

   p``[sub max]`` = binomial_distribution<RealType>::estimate_upper_bound_on_p(
                       n, k, 0.05);

[link math_toolkit.dist.stat_tut.weg.binom_eg.binom_conf See worked example.]

   static RealType estimate_number_of_trials(
      RealType k,     // number of events
      RealType p,     // success fraction
      RealType alpha); // probability threshold
      
   template <class P1, class P2, class P3>
   static RealType estimate_number_of_trials(
      const ``['unspecified-complemented-type]``<P1, P2, P3>& c);
      
These functions estimate the number of trials required to achieve a certain
probability that [*k events or fewer will be observed].

[variablelist
[[k][The number of success observed.]]
[[p][The probability of success for each trial.]]
[[alpha][The maximum acceptable probability that k events or fewer will be observed.]]
]

For example:
   
   binomial_distribution<RealType>::estimate_number_of_trials(10, 0.5, 0.05);
      
Returns the smallest number of trials we must conduct to be 95% sure
of seeing 10 events that occur with frequency one half.
   
While:

   binomial_distribution<RealType>::estimate_number_of_trials(
      complement(0, 1.0/1000000, 0.05));

Returns the largest number of trials we can conduct and still be 95% certain
of not observing any events that occur with one in a million frequency.
This is typically used in failure analysis.

[link math_toolkit.dist.stat_tut.weg.binom_eg.binom_size_eg See Worked Example.]

[h4 Non-member Accessors]

All the [link math_toolkit.dist.dist_ref.nmp usual non-member accessor functions]
that are generic to all distributions are supported: __usual_accessors.

However it's worth taking a moment to define what these actually mean in 
the context of this distribution:

[table Meaning of the non-member accessors
[[Function][Meaning]]
[[__pdf]
   [The probability of obtaining [*exactly k successes] from n trials
   with success fraction p.  For example:\n\n``pdf(binomial(n, p), k)``]]
[[__cdf]
   [The probability of obtaining [*k successes or fewer] from n trials
   with success fraction p.  For example:\n\n ``cdf(binomial(n, p), k)``]]
[[__ccdf]
   [The probability of obtaining [*more than k successes] from n trials
   with success fraction p.  For example:\n\n ``cdf(complement(binomial(n, p), k))``]]
[[__quantile]
   [The [*greatest] number of successes that may be observed from n trials
   with success fraction p, at probability P.  Note that the value returned
   is a real-number, and not an integer.  Depending on the use case you may
   want to take either the floor or ceiling of the result.  For example:\n\n
   ``quantile(binomial(n, p), P)``]]
[[__quantile_c]
   [The [*smallest] number of successes that may be observed from n trials
   with success fraction p, at probability P.  Note that the value returned
   is a real-number, and not an integer.  Depending on the use case you may
   want to take either the floor or ceiling of the result. For example:
   ``quantile(complement(binomial(n, p), P))``]]
]

[h4 Accuracy]

This distribution is implemented using the 
incomplete beta functions __ibeta and __ibetac, 
please refer to these functions for information on accuracy.

[h4 Implementation]

In the following table /p/ is the probablity that one trial will
be successful (the success fraction), /n/ is the number of trials,
/k/ is the number of successes, /p/ is the probablity and /q = 1-p/.

[table
[[Function][Implementation Notes]]
[[pdf][Implementation is in terms of __ibeta_derivative: if [sub n]C[sub k ] is the binomial
       coefficient of a and b, then we have:\n\n
       [$../equations/binomial_ref1.png]\n\n
       Which can be evaluated as `ibeta_derivative(k+1, n-k+1, p) / (n+1)`\n\n
       The function __ibeta_derivative is used here, since it has already
       been optimised for the lowest possible error - indeed this is really
       just a thin wrapper around part of the internals of the incomplete
       beta function.\n\n
       There are also various special cases: refer to the code for details.
       ]]
[[cdf][Using the relation: \n\n
       p = I[sub 1-p](n - k, k + 1)\n
         = 1 - I[sub p](k + 1, n - k)\n
         = __ibetac(k + 1, n - k, p)\n\n
         There are also various special cases: refer to the code for details.
]]
[[cdf complement][Using the relation: q = __ibeta(k + 1, n - k, p)\n\n
     There are also various special cases: refer to the code for details. ]]
[[quantile][Since the cdf is non-linear in variate /k/ none of the inverse
            incomplete beta functions can be used here.  Instead the quantile
            is found numerically using a derivative free method 
            ([link math_toolkit.toolkit.roots2 TOMS Algorithm 748]).]]
[[quantile from the complement][Found numerically as above.]]
[[mean][ `p * n` ]]
[[variance][ `p * n * (1-p)` ]]
[[mode][`floor(p * (n + 1))`]]
[[skewness][`(1 - 2 * p) / sqrt(n * p * (1 - p))`]]
[[kurtosis][`3 - (6 / n) + (1 / (n * p * (1 - p)))`]]
[[kurtosis excess][`(1 - 6 * p * q) / (n * p * q)`]]
[[parameter estimation][The member functions `estimate_upper_bound_on_p`
       `estimate_lower_bound_on_p` and `estimate_number_of_trials` are 
       implemented in terms of the inverse incomplete beta functions
       __ibetac_inv, __ibeta_inv, and __ibetac_invb respectively]]
]

[endsect][/section:binomial_dist Binomial]

[/ binomial.qbk
  Copyright 2006 John Maddock and Paul A. Bristow.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]
