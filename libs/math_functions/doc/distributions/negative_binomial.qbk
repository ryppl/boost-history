[section:negative_binomial_dist Negative Binomial]

``#include <boost/math/distributions/negative_binomial.hpp>``

   namespace boost{ namespace math{ 
   
   template <class RealType = double>
   class negative_binomial_distribution;
   
   typedef negative_binomial_distribution<double> negative_binomial;
   
   template <class RealType>
   class negative_binomial_distribution
   {
   public:
      // Constructor from successes and success_fraction:
      negative_binomial_distribution(RealType r, RealType p);
      
      // Parameter accessors:
      RealType success_fraction() const;
      RealType successes() const;
      
      // Bounds on success fraction:
      static RealType estimate_lower_bound_on_p(
         RealType trials, 
         RealType successes,
         RealType probability);
      static RealType estimate_upper_bound_on_p(
         RealType trials, 
         RealType successes,
         RealType probability);
         
      // Estimate min/max number of trials:
      static RealType estimate_number_of_trials(
         RealType k,     // Number of failures.
         RealType p,     // Success fraction.
         RealType probability); // Probability threshold.
         
      template <class P1, class P2, class P3>
      static RealType estimate_number_of_failures(
         const ``['unspecified-complemented-type]``<P1, P2, P3>& c);
   };
   
   }} // namespaces
   
The class type `negative_binomial_distribution` represents a
[@http://en.wikipedia.org/wiki/Negative_binomial_distribution negative_binomial distribution]:
it is used when there are exactly two mutually exclusive outcomes of a
[@http://en.wikipedia.org/wiki/Bernoulli_trial Bernoulli trial]:
these outcomes are labelled "success" and "failure".
The negative_binomial distribution is used to obtain 
the probability of observing x failures in n trials, with the 
probability of success on a single trial denoted by success_fraction p. The 
negative_binomial distribution assumes that success_fraction p is fixed for all trials.

[h4 Related Distributions]

The name negative binomial distribution is reserved by some to the
case where the successes parameter r is an integer.
This integer version is also called the Pascal distribution.

This implementation uses real numbers for the computation throughout
(because it uses the *real* incomplete beta function family of functions).
This real-valued version is also called the Polya Distribution.

To obtain the Pascal distribution,
you must ensure that an integer value is provided for r,
and you may want to take either the floor or ceiling (or integer)
of the result in order to ensure it is integral.

For large values of r (successes), the negative binomial distribution
converges to the Poisson distribution.

The geometric distribution is a special case
where the successes parameter r = 1;

geometric(p) = negative-binomial(1,p)

poisson([lambda]) = lim [sub r] [sub larr] [sub infin] negative_binomial(r, r/ [lambda] + r))

   
[h4 Member Functions]

   negative_binomial_distribution(RealType r, RealType p);

Constructor: /r/ is the total number of successes, /p/ is the
probability of success of a single trial.

   RealType success_fraction() const;
   
Returns the parameter /p/ from which this distribution was constructed.
   
   RealType successes() const;
   
Returns the parameter /r/ from which this distribution was constructed.

      static RealType estimate_lower_bound_on_p(
        RealType failures, 
        RealType successes,
        RealType probability)
      
Returns a lower bound on the success fraction:

[variablelist
[[failures][The total number of failures before the r th success.]]
[[successes][The number of successes required.]]
[[alpha][The largest acceptable probability that the true value of
         the success fraction is [*less than] the value returned.]]
]

For example, if you observe /k/ failures from /n/ trials the
best estimate for the success fraction is simply ['k/n], but if you
want to be 95% sure that the true value is [*greater than] some value, 
['p[sub min]], then:

   p``[sub min]`` = negative_binomial_distribution<RealType>::estimate_lower_bound_on_p(
                       failures, successes, 0.05);

[/link math_toolkit.dist.stat_tut.weg.binom_eg.binom_conf TO worked example.]
      
   static RealType estimate_upper_bound_on_p(
      RealType trials, 
      RealType successes,
      RealType alpha);
      
Returns an upper bound on the success fraction:

[variablelist
[[trials][The total number of trials conducted.]]
[[successes][The number of successes that occurred.]]
[[alpha][The largest acceptable probability that the true value of
         the success fraction is [*greater than] the value returned.]]
]

For example, if you observe /k/ successes from /n/ trials the
best estimate for the success fraction is simply ['k/n], but if you
want to be 95% sure that the true value is [*less than] some value, 
['p[sub max]], then:

   p``[sub max]`` = negative_binomial_distribution<RealType>::estimate_upper_bound_on_p(
                       n, k, 0.05);

[/link math_toolkit.dist.stat_tut.weg.binom_eg.binom_conf TODO worked example.]

   static RealType estimate_number_of_trials(
      RealType k,     // number of events
      RealType p,     // success fraction
      RealType alpha); // probability threshold
      
   template <class P1, class P2, class P3>
   static RealType estimate_number_of_trials(
      const ``['unspecified-complemented-type]``<P1, P2, P3>& c);
      
These functions estimate the number of trials required to achieve a certain
probability that [*k failure or fewer will be observed].

[variablelist
[[k][The number of success observed.]]
[[p][The probability of success for each trial.]]
[[alpha][The maximum acceptable probability that k events or fewer will be observed.]]
]

For example:
   
   negative_binomial_distribution<RealType>::estimate_number_of_trials(10, 0.5, 0.05);
      
Returns the smallest number of trials we must conduct to be 95% sure
of seeing 10 events that occur with frequency one half.
   
While:

   negative_binomial_distribution<RealType>::estimate_number_of_trials(
      complement(0, 1.0/1000000, 0.05));

Returns the largest number of trials we can conduct and still be 95% certain
of not observing any events that occur with one in a million frequency.
This is typically used in failure analysis.

[/link math_toolkit.dist.stat_tut.weg.binom_eg.binom_size_eg TODO Worked Example.]

[h4 Non-member Accessors]

All the [link math_toolkit.dist.dist_ref.nmp usual non-member accessor functions]
that are generic to all distributions are supported: __usual_accessors.

However it's worth taking a moment to define what these actually mean in 
the context of this distribution:

[table Meaning of the non-member accessors.
[[Function][Meaning]]
[[__pdf]
   [The probability of obtaining [*exactly k successes] from n trials
   with success fraction p.  For example:\n\n``pdf(negative_binomial(n, p), k)``]]
[[__cdf]
   [The probability of obtaining [*k successes or fewer] from n trials
   with success fraction p.  For example:\n\n ``cdf(negative_binomial(n, p), k)``]]
[[__ccdf]
   [The probability of obtaining [*more than k successes] from n trials
   with success fraction p.  For example:\n\n ``cdf(complement(negative_binomial(n, p), k))``]]
[[__quantile]
   [The [*greatest] number of successes that may be observed from n trials
   with success fraction p, at probability P.  Note that the value returned
   is a real-number, and not an integer.  Depending on the use case you may
   want to take either the floor or ceiling of the result.  For example:\n\n
   ``quantile(negative_binomial(n, p), P)``]]
[[__quantile_c]
   [The [*smallest] number of successes that may be observed from n trials
   with success fraction p, at probability P.  Note that the value returned
   is a real-number, and not an integer.  Depending on the use case you may
   want to take either the floor or ceiling of the result. For example:
   ``quantile(complement(negative_binomial(n, p), P))``]]
]

[h4 Accuracy]

This distribution is implemented using the 
incomplete beta functions __ibeta and __ibetac: 
please refer to these functions for information on accuracy.

[h4 Implementation]

In the following table, /p/ is the probability that one trial will
be successful (the success fraction), /r/ is the number of successes,
/k/ is the number of failures, /p/ is the probablity and /q = 1-p/.

[table
[[Function][Implementation Notes]]
[[pdf][exp(lgamma(r + k) - lgamma(r) - lgamma(k+1)) * pow(p, r) * pow((1-p), k)\n
Implementation is in terms of __ibeta_derivative:\n
(p/(r + k)) * ibeta_derivative(r, static_cast<RealType>(k+1), p)
The function __ibeta_derivative is used here, since it has already
been optimised for the lowest possible error - indeed this is really
just a thin wrapper around part of the internals of the incomplete
beta function.\n\n
]]
[[cdf][Using the relation: \n
I[sub p](r, k+1) = ibeta(r, k+1, p)\n
= ibeta(r, static_cast<RealType>(k+1), p)]]
[[cdf complement][Using the relation:\n
I[sub p](k+1, r)\n
= ibetac(r, static_cast<RealType>(k+1), p)\n\n]]
[[quantile][ibeta_invb(r, p, P) - 1]]
[[quantile from the complement][ibetac_invb(r, p, Q) -1)]]
[[mean][ `r(1-p)/p` ]]
[[variance][ `r (1-p) / p * p` ]]
[[mode][`floor[(r-1) * (1 - p)/p`]]
[[skewness][`(2 - p) / sqrt(r * (1 - p))`]]
[[kurtosis][`6 / r + (p * p) / r * (1 - p )`]]
[[kurtosis excess][`6 / r + (p * p) / r * (1 - p ) -3`]]
[[parameter estimation member functions][]]
[[`estimate_upper_bound_on_p`][ibetac_inv(successes + 1, failures - successes, probability)]]
[[`estimate_lower_bound_on_p`][ibeta_inv(successes + 1, failures - successes, probability)]]
[[`estimate_number_of_trials`][ibetac_invb(k + 1, p, probability)]]
]

Implementation notes: 
* The real concept type (that deliberately lacks the Lanczos approximation),
was found to take several minutes to evaluate some extreme test values,
so the test has been disabled for this type.
* Much greater speed, and perhaps greater accuracy,
might be achieved for extreme values by using a normal approximation.
This is NOT been tested or implemented.

[endsect][/section:negative_binomial_dist Negative Binomial]

[/ negative_binomial.qbk
  Copyright 2006 John Maddock and Paul A. Bristow.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

