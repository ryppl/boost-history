
[section:sph_bessel Spherical Bessel Functions of the First and Second Kinds]

[h4 Synopsis]

   template <class T1, class T2>
   ``['deduced-real-type]`` sph_bessel(unsigned v, T2 x);

   template <class T1, class T2>
   ``['deduced-real-type]`` sph_neumann(unsigned v, T2 x);
   
   
[h4 Description]

The functions __sph_bessel and __sph_neumann return the result of the
Spherical Bessel functions of the first and second kind's respectively:

sph_bessel(v, x) = j[sub v](x)

sph_neumann(v, x) = y[sub v](x) = n[sub v](x)

where:

[$../equations/sbessel2.png]

The return type of these functions is computed using the __arg_pomotion_rules
for the single argument type T.

The functions return the result of __domain_error whenever the result is
undefined or complex: this occurs when `x < 0`.

[h4 Testing]

There are two sets of test values: spot values calculated using
functions.wolfram.com and a much larger set of tests computed using
a simplified version of this implementation (with all the special
case handling removed).

[h4 Accuracy]

Other than for some special cases, these functions are computed in terms of
__cyl_bessel_j and __cyl_neumann: refer to these functions for accuracy data.

[h4 Implementation]

Other than error handling and a couple of special cases these functions
are implemented directly in terms of their definitions:

[$../equations/sbessel2.png]

The special cases occur for:

j[sub 0][space]= __sinc_pi(x) = sin(x) / x

and for small ['x < 1] we can use the series:

[$../equations/sbessel5.png]

which neatly avoids the problem of calculating 0/0 that can occur with the
main definition as x -> 0.


[endsect]

