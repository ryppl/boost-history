[section:use_NTL Using With NTL - a High-Precision Floating-Point Library]

The special functions and tools in this library can be used with
[@http://shoup.net/ntl/doc/RR.txt NTL::RR (an arbitrary precision number type)],
and to a lesser extent with [@http://shoup.net/ntl/doc/quad_float.txt 
NTL::quad_float] (128-bit, using 106 significand bits).
[@http://shoup.net/ntl/ Refer to NTL: A Library for doing Number Theory by 
Victor Shoup]

In order to do so you will need to apply the following patch to 
NTL: [@../tools/ntl.diff libs/math/tools/ntl.diff].
This patch adds trivial converting constructors to NTL::RR and NTL::quad_float,
and forces conversions to RR to proceed via `long double` rather than `double`.
The latter change is essential to accurately measure relative errors between
high precision calculations (using NTL::RR) and fixed precision calculations
(using `long double`).  These occur if, for example, you are generating additional
__lanczos's or rational approximations suitable for use with `long double`.

You will also need to include NTL via the header `<boost/math/tools/ntl.hpp>`
and include that header /before/ you include any of the special function headers.
The rationale for this is that the header `<boost/math/tools/ntl.hpp>` includes some traits classes
and boilerplate code (mostly runtime substitutes for numeric_limits) that are
required by the special functions.  Unfortunately, some of the stricter compilers
require these definitions to be seen before the templates that will use them are
parsed.

Finally there is a high precision __lanczos suitable for use with NTL::RR,
used at 1000-bit precision in 
[@../tools/ntl_rr_lanczos.hpp libs/math/tools/ntl_rr_lanczos.hpp].  
The approximation has a theoretical precision of > 90 decimal digits, 
and an experimental precision of > 100 decimal digits.  To use that 
approximation, just include that header before any of the special 
function headers (if you don't use it, you'll get a slower, but
fully generic implementation for all of the gamma-like functions).

[endsect][/section:use_NTL Using With NTL - a High Precision Floating-Point Library]

[section:concepts Conceptual Requirements for Real Number Types]

The functions, and statistical distributions in this library can be used with
any type /RealType/ that meets the conceptual requirements given below.  All
the built in floating point types will meet these requirements.  
User defined types that meet the requirements can also be used.  For example,
with [link math_toolkit.Using_UDT.use_NTL minor modifications] two of the types 
provided with [@http://shoup.net/ntl/ NTL (RR and quad_float)] can be used.

The guiding principal behind these requirements, is that a /RealType/
behaves just like a built in floating point type.

[h4 Basic Arithmetic Requirements]

These requirements are common to all of the functions in this library.

In the following table /r/ is an object of type `RealType`, /cr/ and
/cr2/ are objects
of type `const RealType`, and /ca/ is an object of type `const arithmetic-type`
(arithmetic types include all the built in integers and floating point types).

[table
[[Expression][Result Type][Notes]]
[[`RealType(cr)`][RealType]
      [RealType is copy constructible.]]
[[`RealType(ca)`][RealType]
      [RealType is copy constructible from the arithmetic types.]]
[[`r = cr`][RealType&][Assignment operator.]]
[[`r = ca`][RealType&][Assignment operator from the arithmetic types.]]
[[`r += cr`][RealType&][Adds cr to r.]]
[[`r += ca`][RealType&][Adds ar to r.]]
[[`r -= cr`][RealType&][Subtracts cr from r.]]
[[`r -= ca`][RealType&][Subtracts ca from r.]]
[[`r *= cr`][RealType&][Multiplies r by cr.]]
[[`r *= ca`][RealType&][Multiplies r by ca.]]
[[`r /= cr`][RealType&][Divides r by cr.]]
[[`r /= ca`][RealType&][Divides r by ca.]]
[[`-r`][RealType][Unary Negation.]]
[[`+r`][RealType&][Identity Operation.]]
[[`cr + cr2`][RealType][Binary Addition]]
[[`cr + ca`][RealType][Binary Addition]]
[[`ca + cr`][RealType][Binary Addition]]
[[`cr - cr2`][RealType][Binary Subtraction]]
[[`cr - ca`][RealType][Binary Subtraction]]
[[`ca - cr`][RealType][Binary Subtraction]]
[[`cr * cr2`][RealType][Binary Multiplication]]
[[`cr * ca`][RealType][Binary Multiplication]]
[[`ca * cr`][RealType][Binary Multiplication]]
[[`cr / cr2`][RealType][Binary Subtraction]]
[[`cr / ca`][RealType][Binary Subtraction]]
[[`ca / cr`][RealType][Binary Subtraction]]
[[`cr == cr2`][bool][Equality Comparison]]
[[`cr == ca`][bool][Equality Comparison]]
[[`ca == cr`][bool][Equality Comparison]]
[[`cr != cr2`][bool][Inequality Comparison]]
[[`cr != ca`][bool][Inequality Comparison]]
[[`ca != cr`][bool][Inequality Comparison]]
[[`cr <= cr2`][bool][Less than equal to.]]
[[`cr <= ca`][bool][Less than equal to.]]
[[`ca <= cr`][bool][Less than equal to.]]
[[`cr >= cr2`][bool][Greater than equal to.]]
[[`cr >= ca`][bool][Greater than equal to.]]
[[`ca >= cr`][bool][Greater than equal to.]]
[[`cr < cr2`][bool][Less than comparison.]]
[[`cr < ca`][bool][Less than comparison.]]
[[`ca < cr`][bool][Less than comparison.]]
[[`cr > cr2`][bool][Greater than comparison.]]
[[`cr > ca`][bool][Greater than comparison.]]
[[`ca > cr`][bool][Greater than comparison.]]
[[`boost::math::tools::digits<RealType>()`][int]
      [The number of digits in the significand of RealType.]]
[[`boost::math::tools::max_value<RealType>()`][RealType]
      [The largest representable number by type RealType.]]
[[`boost::math::tools::min_value<RealType>()`][RealType]
      [The smallest representable number by type RealType.]]
[[`boost::math::tools::log_max_value<RealType>()`][RealType]
      [The natural logarithm of the largest representable number by type RealType.]]
[[`boost::math::tools::log_min_value<RealType>()`][RealType]
      [The natural logarithm of the smallest representable number by type RealType.]]
[[`boost::math::tools::epsilon<RealType>()`][RealType]
      [The machine epsilon of RealType.]]
]

Note that:

# The functions `log_max_value` and `log_min_value` can be 
synthesised from the others, and so no explicit specialisation is required.
# The function `epsilon` can be synthesised from the others, so no
explicit specialisation is required provided the precision
of RealType does not vary at runtime (see the header 
[@../../../../boost/math/tools/ntl.hpp boost/math/tools/ntl.hpp]
for an example where the precision does vary at runtime).
# The functions `digits`, `max_value` and `min_value`, all get synthesised
automatically from `std::numeric_limits`.  However, if `numeric_limits`
is not specialised for type RealType, then you will get a compiler error
when code tries to use these functions, /unless/ you explicitly specialise them.
For example if the precision of RealType varies at runtime, then
`numeric_limits` support may not be appropriate, see 
[@../../../../boost/math/tools/ntl.hpp boost/math/tools/ntl.hpp] for examples.

[h4 Standard Library Support Requirements]

Many (though not all) of the functions in this library make calls
to standard library functions, the following table summarises the
requirements.  Note that most of the functions in this library
will only call a small subset of the functions listed here, so if in
doubt whether a user defined type has enough standard library
support to be useable the best advise is to try it and see!

In the following table /r/ is an object of type `RealType`, 
/cr1/ and /cr2/ are objects of type `const RealType`, and
/i/ is an object of type `int`.

[table
[[Expression][Result Type]]
[[`fabs(cr1)`][RealType]]
[[`abs(cr1)`][RealType]]
[[`ceil(cr1)`][RealType]]
[[`floor(cr1)`][RealType]]
[[`exp(cr1)`][RealType]]
[[`pow(cr1, cr2)`][RealType]]
[[`sqrt(cr1)`][RealType]]
[[`log(cr1)`][RealType]]
[[`frexp(cr1, &i)`][RealType]]
[[`ldexp(cr1, i)`][RealType]]
[[`cos(cr1)`][RealType]]
[[`sin(cr1)`][RealType]]
[[`asin(cr1)`][RealType]]
[[`tan(cr1)`][RealType]]
[[`atan(cr1)`][RealType]]
]

Note that the table above lists only those standard library functions known to
be used (or likely to be used in the near future) by this library.  
The following functions: `acos`, `atan2`, `fmod`, `cosh`, `sinh`, `tanh`, `modf` and `log10`
are not currently used, but may be if further special functions are added.

[endsect]

[section:dist_concept Conceptual Requirements for Distribution Types]

A /DistributionType/ is a type that implements the following conceptual
requirements, and encapsulates a statistical distribution.

Please note that this documentation should not be used as a substitute
for the 
[link math_toolkit.dist.dist_ref reference documentation], and 
[link math_toolkit.dist.stat_tut tutorial] of the statistical
distributions.

In the following table, /d/ is an object of type `DistributionType`, 
/cd/ is an object of type `const DistributionType` and /cr/ is an
object of type `const RealType`.

[table
[[Expression][Result Type][Notes]]
[[DistributionType::value_type][RealType]
      [The real-number type /RealType/ upon which the distribution operates.]]
[[d = cd][Distribution&][Distribution types are assignable]]
[[pdf(cd, cr)][RealType][Returns the PDF of the distribution.]]
[[cdf(cd, cr)][RealType][Returns the CDF of the distribution.]]
[[cdf(complement(cd, cr))][RealType]
      [Returns the complement of the CDF of the distribution, 
      the same as: `1-cdf(cd, cr)`]]
[[quantile(cd, cr)][RealType][Returns the quantile of the distribution.]]
[[quantile(complement(cd, cr))][RealType]
      [Returns the quantile of the distribution, starting from
      the complement of the probability, the same as: `quantile(cd, 1-cr)`]]
[[chf(cd, cr)][RealType][Returns the cumulative hazard function of the distribution.]]
[[hazard(cd, cr)][RealType][Returns the hazard function of the distribution.]]
[[kurtosis(cd)][RealType][Returns the kurtosis of the distribution.]]
[[kurtosis_excess(cd)][RealType][Returns the kurtosis excess of the distribution.]]
[[mean(cd)][RealType][Returns the mean of the distribution.]]
[[mode(cd)][RealType][Returns the mode of the distribution.]]
[[skewness(cd)][RealType][Returns the skewness of the distribution.]]
[[standard_deviation(cd)][RealType][Returns the standard deviation of the distribution.]]
[[variance(cd)][RealType][Returns the variance of the distribution.]]
]

[endsect]

[section:archetypes Conceptual Archetypes and Testing]

std_real_concept is an archetype for built-in Real types.

The main purpose in providing this type is to verify
that std lib functions are found via a using declaration,
bringing those functions into the current scope, and not
just because they happen to be in global scope.

If ::pow is found rather than std::pow say, then the code
will silently compile, but truncation of long doubles to
double will cause a significant loss of precision.
A template instantiated with std_real_concept will *only*
compile if it std::whatever is in scope.

real_concept is an archetype for User defined Real types.

This file defines the features, constructors, operators, functions...
that are essential to use mathematical and statistical functions.
The template typename "RealType" is used where this type
(as well as the normal built-in types, float, double & long double)
can be used.
That this is the minimum set is confirmed by use as a type
in tests of all functions & distributions, for example:
  test_spots(0.F); & test_spots(0.);  for float and double, but also
  test_spots(boost::math::concepts::real_concept(0.));
  
NTL quad_float type is an example of a type meeting the requirements,
but note minor additions are needed - see ntl.diff and documentation
"Using With NTL - a High-Precision Floating-Point Library".

TODO.

See boost/math/concepts/real_concept.hpp for the current concept-archetype
test case.

real_concept basically requires:

* The usual arithmetic operations.
* The usual comparison operations.
* The usual math functions (those in <cmath>).
* Either `std::numeric_limits` support (the easy way), or a small number
helper functions that provide the same functionality at runtime
rather than compile time (see boost/math/tools/precision.hpp).
* Promotion from the built-in floating point types to T, and the function 
`real_cast` that converts from T to a narrower floating-point type
(see boost/math/tools/real_cast.hpp).

For efficient and accurate results, a __lanczos is also highly desirable.
You may be able to adapt an existing approximation from 
boost/math/special_functions/lanczos.hpp: you will need change
static_cast's to lexical_cast's, and the constants to /strings/ 
(in order to ensure the coefficients aren't truncated to long double)
and then specialise lanczos_traits for type T.  Otherwise you may have to hack 
libs/math/tools/lanczos_generator.cpp to find a suitable
approximation for your type T.

[warning
1  Real concept type T assumes that the number of significand bits
is the same as long double,
*unless* std::numeric_limits<T>::is_specialized
to provide std::numeric_limits<T>::digits.\n
2  If std::numeric_limits<T> is *NOT specialized* to provide std::numeric_limits<T>::digits
(or in future max_digits10) then the default float precision of 6 decimal digits
will be used by other Boost programs including:\n
* Boost.test giving misleading error messages like\n
"difference between {9.79796} and {9.79796} exceeds 5.42101e-19%".\n
* Boost.lexical cast to decimal digit string types\n
and Boost.serialization output causing potentially serious loss of accuracy.\n
Although it might seem the real_concept would best require std::numeric_limits
to be specialized for all types to provide digits, this is not sensible for
NTL::RR and similar classes where the number of digits is a runtime 
parameter (for numeric_limits it has to be fixed at compile time).
(One could still define digits, digits10, epsilon etc to be suitable values,
but one would have to ensure that the precision chosen at runtime,
for example, using the NTL function NTL::setprecision(40), matched
that chosen at compile time by these definitions,
for example, std::numeric_limits<RR>::digits10 = 40;).\n
To mitigate the problems caused by lack of full numeric_limits specialization,
boost::math::tools:: provides some compile time asserts which will alert
the user by failure to compile unless
both numeric_limits<T>::is_specilized and numeric_limits<T>::digits.
]


[endsect][/section:real_concept Conceptual Requirements]


[section:concept_check Concept Checking]

The test program is distribution_concept_check.cpp 
The concept checks and archetypes
(see the Boost Concept Check lib for more info)
are in boost/math/concepts/distributions.hpp.

Implementations of distributions require them to be:

CopyConstructible and Assignable.

All support the following non-member accessor functions

pdf
cdf
quantile
mean
mode
standard_deviation
variance
hazard
chf
coefficient_of_variation
skewness
kurtosis
kurtosis_excess

Their existence (but not proper function) is checked by calls like

v = pdf(dist, x); // (Result v is ignored).

And in addition, those that accept two arguments do the right thing when the 
arguments are of different types (the result type is always the same as the 
distribution's value_type).  This is implemented by some additional 
forwarding-functions in derived_accessors.hpp, so no need for any code 
changes.  Likewise hazard/chf/coefficient_of_variation are implemented in 
there too.

[endsect][/section:concept_check Concept Checking]

[/ 
  Copyright 2006 John Maddock and Paul A. Bristow.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]



