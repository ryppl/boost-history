[#factorials][section Factorials]

[caution __caution ]

[h4 Synopsis]

``
#include <boost/math/special_functions/factorials.hpp>
``

   namespace boost{ namespace math{
   
   template <class T>
   T factorial(unsigned i);
   
   template <class T>
   T unchecked_factorial(unsigned i);
   
   template <class T>
   struct max_factorial;
   
   }} // namespaces
   
[h4 Description]

   template <class T>
   T factorial(unsigned i);

Returns [^i!].

For [^i <= max_factorial<T>::value] this is implemented by table lookup, 
for larger values of [^i], this function is implemented in terms of [link tgamma the
tgamma function].  

If [^i] is so large that the result can not be represented in type T, then 
calls __overflow_error.

   template <class T>
   T unchecked_factorial(unsigned i);

Returns [^i!].

Internally this function performs table lookup of the result.  Further it performs
no range checking on the value of i: it is up to the caller to ensure
that [^i <= max_factorial<T>::value].  This function is intended to be used
inside inner loops that require fast table lookup of factorials, but requires
care to ensure that argument [^i] never grows too large.

   template <class T>
   struct max_factorial
   {
      static const unsigned value = X;
   };

This traits class defines the largest value that can be passed to
[^unchecked_factorial].  The member `value` can be used where integral
constant expressions are required: for example to define the size of
further tables that depend on the factorials.
 
[h4 Accuracy]

For arguments smaller than `max_factorial<T>::value` the result should be
correctly rounded.  For larger arguments the accuracy will be the same
as for [link tgamma the tgamma function].

[h4 Testing]

Basic sanity checks and spot values to verify the data tables: 
the main tests for the tgamma function handle those cases already.

[h4 Implementation]

Table driven for small arguments, in terms of [link tgamma tgamma]
for larger arguments.

[endsect]

