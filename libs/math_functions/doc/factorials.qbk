[section:factorials Factorials and Binomial Coefficients]

[caution __caution ]

[h4 Synopsis]

``
#include <boost/math/special_functions/factorials.hpp>
``

   namespace boost{ namespace math{
   
   template <class T>
   T factorial(unsigned i);
   
   template <class T>
   T unchecked_factorial(unsigned i);
   
   template <class T>
   struct max_factorial;
   
   template <class T>
   T double_factorial(unsigned i);
   
   template <class T>
   T rising_factorial(T x, int i);
   
   template <class T>
   T falling_factorial(T x, unsigned i);
   
   }} // namespaces
   
``
#include <boost/math/special_functions/binomial.hpp>
``

   namespace boost{ namespace math{
   
   template <class T>
   T binomial_coefficient(unsigned n, unsigned k);

   }} // namespaces

[h4 Description]

   template <class T>
   T factorial(unsigned i);

Returns [^i!].

For [^i <= max_factorial<T>::value] this is implemented by table lookup, 
for larger values of [^i], this function is implemented in terms of [link tgamma the
tgamma function].  

If [^i] is so large that the result can not be represented in type T, then 
calls __overflow_error.

   template <class T>
   T unchecked_factorial(unsigned i);

Returns [^i!].

Internally this function performs table lookup of the result.  Further it performs
no range checking on the value of i: it is up to the caller to ensure
that [^i <= max_factorial<T>::value].  This function is intended to be used
inside inner loops that require fast table lookup of factorials, but requires
care to ensure that argument [^i] never grows too large.

   template <class T>
   struct max_factorial
   {
      static const unsigned value = X;
   };

This traits class defines the largest value that can be passed to
[^unchecked_factorial].  The member `value` can be used where integral
constant expressions are required: for example to define the size of
further tables that depend on the factorials.
 
   template <class T>
   T double_factorial(unsigned i);
   
Returns [^i!!].  

May return the result of __overflow_error if the result is too large
to represent in type T.  The implementation is designed to be optimised
for small /i/ where table lookup of i! is possible.
   
   template <class T>
   T rising_factorial(T x, int i);
   
Returns the rising factorial of /x/ and /i/:

rising_factorial(x, i) = tgamma(x + i) / tgamma(x);

or

rising_factorial(x, i) = x(x+1)(x+2)(x+3)...(x+i)
                          
Note that both /x/ and /i/ can be negative as well as positive.

May return the result of __overflow_error if the result is too large
to represent in type T.
   
   template <class T>
   T falling_factorial(T x, unsigned i);
   
Returns the falling factorial of /x/ and /i/:

falling_factorial(x, i) = x(x-1)(x-2)(x-3)...(x-i+1)
   
Note that this function is only defined for positive /i/, hense the
`unsigned` second argument.  Argument /x/ can be either positive or
negative however.

May return the result of __overflow_error if the result is too large
to represent in type T.
   
   template <class T>
   T binomial_coefficient(unsigned n, unsigned k);

Returns the binomial coefficient: [sub n]C[sub k].

Requires k <= n.

May return the result of __overflow_error if the result is too large
to represent in type T.
   
[h4 Accuracy]

For the factorials and arguments smaller than `max_factorial<T>::value` 
the result should be
correctly rounded.  For larger arguments the accuracy will be the same
as for [link tgamma the tgamma function].

For double factorials, the implementation uses a trivial adaptation of
the factorial function, so error rates should be no more than a couple
of epsilon higher.

For the rising and falling factorials, the accuracy will be the same as
the __tgamma_delta_ratio function.

For the binomial coefficients, the accuracy will be the same as for the
factorials for small arguments, and the __beta function for larger arguments.

[h4 Testing]

Basic sanity checks and spot values to verify the data tables: 
the main tests for the tgamma function handle those cases already.

The spot tests for the double factorial, rising and falling factorials,
and binomial coefficients, use data generated by functions.wolfram.com.

[h4 Implementation]

The factorial is table driven for small arguments, and implemented in terms of 
[link tgamma tgamma] for larger arguments.

The double factorial is implemented in terms of the factorial and gamma
functions using the relations:

(2n)!! = 2[super n ] * n!

(2n+1)!! = (2n+1)! / (2[super n ] n!)

and

(2n-1)!! = [GAMMA]((2n+1)/2) * 2[super n ] / sqrt(pi)

Rising and falling factorials are implemented as ratios of gamma functions
using __tgamma_delta_ratio.  Opimisations for
small integer arguments are handled internally by that function.

Binomial coefficients are calculated using table lookup of factorials
where possible using:

[sub n]C[sub k] = n! / (k!(n-k)!)

Otherwise in terms of the beta function using the relations:

[sub n]C[sub k] = 1 / (k * __beta(k, n-k+1))

and

[sub n]C[sub k] = 1 / ((n-k) * __beta(k+1, n-k))

[endsect][/section:factorials Factorials]

[/ 
  Copyright 2006 John Maddock and Paul A. Bristow.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]
