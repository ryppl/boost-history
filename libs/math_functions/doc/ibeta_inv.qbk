[#ibeta_inv][section The Incomplete Beta Function Inverses]

[caution __caution ]

[h4 Synopsis]

``
#include <boost/math/special_functions/beta.hpp>
``

   namespace boost{ namespace math{
   
   template <class T>
   T ibeta_inv(T a, T b, T p);
   
   template <class T>
   T ibetac_inv(T a, T b, T q);
   
   }} // namespaces
   
[h4 Description]

There are two incomplete beta function inverses which return the inverses
of ibeta and ibetac respectively.

Both of these function require /a,b > 0/ and /0 <= p,q <= 1/.

   template <class T>
   T ibeta_inv(T a, T b, T p);

Returns a value x such that: `p = ibeta(a, b, x);`

   template <class T>
   T ibetac_inv(T a, T b, T q);
   
Returns a value x such that: `q = ibetac(a, b, x);`

[h4 Accuracy]

The accuracy of these functions doesn't vary much by platform or by
the type T.  Given that these functions are computed by iterative methods,
they are deliberately "detuned" so as not to be too accurate: it is in
any case impossible for these function to be more accurate than the
regular forward incomplete beta functions.

[h4 Testing]

There are two sets of tests: 

* Basic sanity checks attempt to "round-trip" from
/a, b/ and /x/ to /p/ or /q/ and back again.  These tests have quite
generous tolerances: in general both the incomplete beta and it's
inverses change so rapidly, that round tripping to more than a couple
of significant digits isn't possible.  This is especially true when
/p/ or /q/ is very near one: in this case there isn't enough 
"information content" in the input to the inverse function to get
back where you started.
* Accuracy checks using high precision test values.  These measure
the accuracy of the result, given exact input values.

[h4 Implementation]

These two functions share a common implementation.

First an initial approximation to x is computed then the
last few bits are cleaned up using Halley iteration.  The iteration
limit is set to 1/2 of the number of bits in T, which by experiment is
sufficient to ensure that the inverses are at least as accurate as the normal
incomplete beta functions.  Up to 5 iterations may be
required in extreme cases, although normally only one or two are required.
Further the number of iterations requires decreases with increasing /a/ and
/b/ (which generally form the more important use cases).  

The initial guesses used for iteration are obtained as follows: 

Firstly recall that:

[$../equations/ibeta_inv5.png]

We may wish to start from either p or q, and to calculate either x or y.  
In addition at
any stage we can exchange a for b, p for q, and x for y if it results in a 
more manageable problem.

For `a+b >= 5` the initial guess is computed using the methods described in:

Asymptotic Inversion of the Incomplete Beta Function, by N. M. Temme.
Journal of Computational and Applied Mathematics 41 (1992) 145-157.

The nearly symetrical case (section 2 of the paper) is used for

[$../equations/ibeta_inv2.png]

and involves solving the inverse error function first.  The method is accurate
to at least 2 decimal digits when [^a = 5] rising to at least 8 digits when
[^a = 10[super 5]].

The general error function case (section 3 of the paper) is used for

[$../equations/ibeta_inv3.png]

and again expresses the inverse incomplete beta in terms of the 
inverse of the error function.  The method is accurate to at least 
2 decimal digits when [^a+b = 5] rising to 11 digits when [^a+b = 10[super 5]].
However, when the result is expected to be very small, and when a+b is 
also small, then it's accuracy tails off, in this case when p[super 1/a] < 0.0025
then it's better to use the following as an initial estimate:

[$../equations/ibeta_inv4.png]

Finally the for all other cases where `a+b > 5` the method of section
4 of the paper is used.  This expresses the inverse incomplete beta in terms
of the inverse of the incomplete gamma function, and is therefore significantly
more expensive to compute than the other cases.  However the method is accurate 
to at least 3 decimal digits when [^a = 5] rising to at least 10 digits when 
[^a = 10[super 5]].  This method is limited to a > b, and therefore we need to perform
an exchange a for b, p for q and x for y when this is not the case.  In addition
when p is close to 1 the method is inaccurate should we actually want y rather 
than x as output.  Therefore when q is small ([^q[super 1/p] < 10[super -3]]) we use:

[$../equations/ibeta_inv6.png]

which is both cheaper to compute than the full method, and a more accurate 
estimate on q.

When a and b are both small there is a distinct lack of information in the
literature on how to proceed.  I am extremely grateful to Prof Nico Temme
who provided the following information with a great deal of patience and
explanation on his part.  Any errors that follow are entirely my own, and not
Prof Temme's.

When a and b are both less than 1, then there is a point of inflection in
the incomplete beta at point `xs = (1 - a) / (2 - a - b)`.  Therefore if
[^p > I[sub x](a,b)] we swap a for b, p for q and x for y, so that now we always
look for a point x below the point of inflection `xs`, and on a convex curve.
An initial estimate for x is made with:

[$../equations/ibeta_inv7.png]

which is provably below the true value for x: Newton iteration will
therefore smoothly converge on x without problems caused by overshooting etc.

When a and b are both greater than 1, but a+b is too small to use the other
methods mentioned above, we proceed as follows.  Observe that there is a point
of inflection in the incomplete beta at `xs = (1 - a) / (2 - a - b)`.  Therefore
if [^p > I[sub x](a,b)] we swap a for b, p for q and x for y, so that now we always
look for a point x below the point of inflection `xs`, and on a concave curve.
An initial estimate for x is made with:

[$../equations/ibeta_inv4.png]

which can be improved somewhat to:

[$../equations/ibeta_inv1.png]

when b and x are both small (I've used b < a and x < 0.2).  These forms
actually under-estimate x, which drops us on the wrong side of x for Newton
iteration to coverge monotonically.  However, use of higher derivatives
and Halley iteration keeps everything under control.

The final case to be considered if when one of a and b is less than or equal
to 1, and the other greater that 1.  Here, if b < a we swap a for b, p for q 
and x for y.  Now the curve of the incomplete beta is convex with no points
of inflection in [0,1].  For small p, x can be estimated using

[$../equations/ibeta_inv4.png]

which under-estimates x, and drops us on the right side of the true value
for Newton iteration to converge monotonically.  However, when p is large
this can quite badly underestimate x.  This is especially an issue when we
really want to find y, in which case this method can be an arbitrary number
of order of magnitudes out, leading to very poor convergence during iteration.

Things can be improved by considering the incomplete beta as a distorted
quarter circle, and estimating y from:

[$../equations/ibeta_inv8.png]

This doesn't guarentee that we will drop in on the right side of x for
monotonic convergence, but it does get us close enough that Halley iteration
rapidly converges on the true value.


[endsect]

