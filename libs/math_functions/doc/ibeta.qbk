[#ibeta][section:ibeta_function The Incomplete Beta Function]
[/ TODO replace use of anchor with link]

[caution __caution ]

[h4 Synopsis]

``
#include <boost/math/special_functions/gamma.hpp>
``

   namespace boost{ namespace math{
   
   template <class T>
   T beta(T a, T b, T x);
   
   template <class T>
   T betac(T a, T b, T x);
   
   template <class T>
   T ibeta(T a, T b, T x);
   
   template <class T>
   T ibetac(T a, T b, T x);
   
   }} // namespaces
   
[h4 Description]

There are four [@http://en.wikipedia.org/wiki/Incomplete_beta_function incomplete beta functions]
: two are normalised versions
that return values in the range [0, 1], and two are non-normalised and
return values in the range [0, beta(a, b)].  Users interested in statistical
applications should use the normalised (or
[@http://mathworld.wolfram.com/RegularizedBetaFunction.html regularized]
) versions (ibeta and ibetac).

All of these functions require /a > 0/, /b > 0/ and /0 <= x <= 1/.

   template <class T>
   T beta(T a, T b, T x);

Returns the full (non-normalised) incomplete beta function of a, b and x:

[$../equations/ibeta1.png]

   template <class T>
   T betac(T a, T b, T x);

Returns the full (non-normalised) complement of the incomplete beta function of a, b and x:

[$../equations/ibeta2.png]

   template <class T>
   T ibeta(T a, T b, T x);

Returns the normalised incomplete beta function of a, b and x:

[$../equations/ibeta3.png]

[$../graphs/ibeta.png]

   template <class T>
   T ibetac(T a, T zb, T x);   
Returns the normalised complement of the incomplete beta function of a, b and x:

[$../equations/ibeta4.png]

[h4 Accuracy]

The following tables give peak and mean relative errors in over various domains of
a, b and x, along with comparisons to other open source implementations where available.  
Note that only results for the widest floating-point type on the system are given as
narrower types have __zero_error.

[table Errors In the Function beta(a, b, x)
[[Significand Size] [Platform and Compiler] [0 < a,b < 10\nand\n0 < x < 1]  [0 < a,b < 100\nand\n0 < x < 1][1e-5 < a,b < 1e5\nand\n0 < x < 1]]
[[53] [Win32, Visual C++ 8] [Peak=39 Mean=2.9] [Peak=91 Mean=12.7] [Peak=635 Mean=25]]
[[64] [Redhat Linux IA32, gcc-3.4.4] [Peak=26 Mean=3.6] [Peak=180.7 Mean=30.1] [Peak~68,580 Mean=2,816]]
[[64] [Redhat Linux IA64, gcc-3.4.4] [Peak=13 Mean=2.4] [Peak=67.1 Mean=13.4] [Peak~68,380 Mean=2,760]]
[[113] [HPUX IA64, aCC A.06.06] [Peak=27.3 Mean=3.6] [Peak=49.8 Mean=9.1] [Peak~60,900 Mean=2,920]]
]

[table Errors In the Function betac(a,b,x)
[[Significand Size] [Platform and Compiler] [0 < a,b < 10\nand\n0 < x < 1]  [0 < a,b < 100\nand\n0 < x < 1][1e-5 < a,b < 1e5\nand\n0 < x < 1]]
[[53] [Win32, Visual C++ 8] [Peak=12.0 Mean=2.4] [Peak=91 Mean=15] [Peak=3718 Mean=113]]
[[64] [Redhat Linux IA32, gcc-3.4.4] [Peak=19.8 Mean=3.8] [Peak=295.1 Mean=33.9] [Peak~104,400 Mean=5,468]]
[[64] [Redhat Linux IA64, gcc-3.4.4] [Peak=11.2 Mean=2.4] [Peak=63.5 Mean=13.6] [Peak~104,500 Mean=5,444]]
[[113] [HPUX IA64, aCC A.06.06] [Peak=15.6 Mean=3.5] [Peak=39.8 Mean=8.9] [Peak~89,780 Mean=4,946]]
]

[table Errors In the Function ibeta(a,b,x)
[[Significand Size] [Platform and Compiler] [0 < a,b < 10\nand\n0 < x < 1]  [0 < a,b < 100\nand\n0 < x < 1][1e-5 < a,b < 1e5\nand\n0 < x < 1]]
[[53] [Win32, Visual C++ 8] [Peak=42.3 Mean=2.9\n\n(GSL Peak=682 Mean=32.5)\n(Cephes Peak=42.7 Mean=7.0)]  [Peak=108 Mean=16.6\n\n(GSL Peak=690 Mean=151)\n(Cephes Peak=1545 Mean=218)] [Peak=4109 Mean=203\n\n(GSL Peak~390000 Mean~18000)\n(Cephes Peak~560000 Mean~20000)]]
[[64] [Redhat Linux IA32, gcc-3.4.4] [Peak=21.9 Mean=3.1] [Peak=270.7 Mean=26.8] [Peak~53,560 Mean=2,948]]
[[64] [Redhat Linux IA64, gcc-3.4.4] [Peak=15.4 Mean=3.0] [Peak=112.9 Mean=14.3] [Peak~53,560 Mean=2,893]]
[[113] [HPUX IA64, aCC A.06.06] [Peak=20.9 Mean=2.6] [Peak=88.1 Mean=14.3] [Peak~25,920 Mean=1,671]]
]

[table Errors In the Function ibetac(a,b,x)
[[Significand Size] [Platform and Compiler] [0 < a,b < 10\nand\n0 < x < 1]  [0 < a,b < 100\nand\n0 < x < 1][1e-5 < a,b < 1e5\nand\n0 < x < 1]]
[[53] [Win32, Visual C++ 8] [Peak=13.9 Mean=2.0]  [Peak=56.2 Mean=14] [Peak=2670 Mean=159]]
[[64] [Redhat Linux IA32, gcc-3.4.4] [Peak=21.1 Mean=3.6] [Peak=221.7 Mean=25.8] [Peak~91,790 Mean=3,047]]
[[64] [Redhat Linux IA64, gcc-3.4.4] [Peak=10.6 Mean=2.2] [Peak=73.9 Mean=11.9] [Peak~91,790 Mean=3,029]]
[[113] [HPUX IA64, aCC A.06.06] [Peak=9.9 Mean=2.6] [Peak=117.7 Mean=15.1] [Peak~27,860 Mean=1,195]]
]

[h4 Testing]

There are two sets of tests: spot tests compare values taken from 
[@http://functions.wolfram.com/webMathematica/FunctionEvaluation.jsp?name=BetaRegularized Mathworld's online function evaluator]
with this implementation: they provide a basic "sanity check"
for the implementation, with one spot-test in each implementation-domain 
(see implementation notes below). 
 
Accuracy tests use data generated at very high precision
(with [@http://shoup.net/ntl/doc/RR.txt NTL RR class] set at 1000-bit precision),
using the "textbook" continued fraction representation (fraction 1 below).
Note that this continued fraction is /not/ used in the implementation,
and therefore we have test data that is fully independent of the code.  

[h4 Implementation]

This implementation is closely based upon 
[@http://portal.acm.org/citation.cfm?doid=131766.131776 "Algorithm 708; Significant digit computation of the incomplete beta function ratios", DiDonato and Morris, ACM, 1992.]

All four of these functions share a common implementation: this is passed both
x and y, and can return either p or q where these are related by:

[$../equations/ibeta_inv5.png]

so at any point we can swap a for b, x for y and p for q if this results in
a more favourable position.  Generally such swaps are performed so that we always
compute a value less than 0.9, when required this can then be subtracted from 1
without undue cancellation error.

The following continued fraction representation is found in many textbooks
but is not used in this implementation - it's both slower and less accurate than
the alternatives - however it is used to generate test data:

[$../equations/ibeta5.png]

The following continued fraction is due to [@http://portal.acm.org/citation.cfm?doid=131766.131776 Didonato and Morris],
and is used in this implementation when a and b are both greater than 1:

[$../equations/ibeta6.png]

For smallish b and x then a series representation can be used:

[$../equations/ibeta7.png]

When b << a then the transition from 0 to 1 occurs very close to x = 1
and some care has to be taken over the method of computation, in that case
the following series representation is used:

[$../equations/ibeta8.png]
[/[$../equations/ibeta9.png]]

Where Q(a,x) is an [@http://functions.wolfram.com/GammaBetaErf/Gamma2/ incomplete gamma function].
Note that this method relies
on keeping a table of all the p[sub n ] previously computed, which does limit
the precision of the method, depending upon the size of the table used.

Finally we can sidestep difficult areas, or move to an area with a more
efficient means of computation, by using the duplication formulae:

[$../equations/ibeta10.png]
[$../equations/ibeta11.png]

The domains of a, b and x for which the various methods are used are identical
to those described in
[@http://portal.acm.org/citation.cfm?doid=131766.131776 Didonato and Morris TOMS 708 paper].

[endsect][/section:ibeta_function The Incomplete Beta Function]

[/ 
  Copyright 2006 John Maddock and Paul A. Bristow.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]
