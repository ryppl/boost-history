[section:laguerre Laguerre (and Associated) Polynomials]

[caution __caution ]

[h4 Synopsis]

``
#include <boost/math/special_functions/laguerre.hpp>
``

   namespace boost{ namespace math{
   
   template <class T>
   T laguerre(unsigned n, T x);
   
   template <class T>
   T laguerre(unsigned n, unsigned m, T x);
   
   template <class T>
   T laguerre_next(unsigned n, T x, T Ln, T Lnm1);
   
   template <class T>
   T laguerre_next(unsigned n, unsigned m, T x, T Ln, T Lnm1);

   
   }} // namespaces

[h4 Description]

   template <class T>
   T laguerre(unsigned n, T x);
   
Returns the value of the Laguerre Polynomial of order /n/ at point /x/:

[$../equations/laguerre_0.png]

The following graph illustrates the behaviour of the first few 
Laguerre Polynomials:

[$../graphs/laguerre.png]
   
   template <class T>
   T laguerre(unsigned n, unsigned m, T x);
   
Returns the Associated Laguerre polynomial of degree /n/ 
and order /m/ at point /x/:

[$../equations/laguerre_1.png]
   
   template <class T>
   T laguerre_next(unsigned n, T x, T Ln, T Lnm1);
   
Implements the three term recurrence relation for the Laguerre
polynomials, this function can be used to create a sequence of
values evaluated at the same /x/, and for rising /n/.

[$../equations/laguerre_2.png]

For example we could produce a vector of the first 10 polynomial
values using:

   double x = 0.5;  // Abscissa value
   vector<double> v;
   v.push_back(laguerre(0, x)).push_back(laguerre(1, x));
   for(unsigned l = 1; l < 10; ++l)
      v.push_back(laguerre_next(l, x, v[l], v[l-1]));
      
Formally the arguments are:

[variablelist
[[n][The degree /n/ of the last polynomial calculated.]]
[[x][The abscissa value]]
[[Ln][The value of the polynomial evaluated at degree /n/.]]
[[Lnm1][The value of the polynomial evaluated at degree /n-1/.]]
]
   
   template <class T>
   T laguerre_next(unsigned n, unsigned m, T x, T Ln, T Lnm1);

Implements the three term recurrence relation for the Associated Laguerre
polynomials, this function can be used to create a sequence of
values evaluated at the same /x/, and for rising degree /n/.

[$../equations/laguerre_3.png]

For example we could produce a vector of the first 10 polynomial
values using:

   double x = 0.5;  // Abscissa value
   int m = 10;      // order
   vector<double> v;
   v.push_back(laguerre(0, m, x)).push_back(laguerre(1, m, x));
   for(unsigned l = 1; l < 10; ++l)
      v.push_back(laguerre_next(l, m, x, v[l], v[l-1]));
      
Formally the arguments are:

[variablelist
[[n][The degree of the last polynomial calculated.]]
[[m][The order of the Associated Polynomial.]]
[[x][The abscissa value.]]
[[Ln][The value of the polynomial evaluated at degree /n/.]]
[[Lnm1][The value of the polynomial evaluated at degree /n-1/.]]
]
   
[h4 Accuracy]

The following table shows peak errors (in units of epsilon) 
for various domains of input arguments.  
Note that only results for the widest floating point type on the system are 
given as narrower types have __zero_error.

[table Peak Errors In the Laguerre Polynomial
[[Significand Size] [Platform and Compiler] [Errors in range\n0 < l < 20] ]
[[53] [Win32, Visual C++ 8] [Peak=3000 Mean=185] ]
[[64] [SUSE Linux IA32, g++ 4.1] [Peak=1x10[super 4] Mean=828]]
[[64] [Red Hat Linux IA64, g++ 3.4.4] [Peak=1x10[super 4] Mean=828] ]
[[113] [HPUX IA64, aCC A.06.06] [Peak=680 Mean=40]]
]

[table Peak Errors In the Associated Laguerre Polynomial
[[Significand Size] [Platform and Compiler] [Errors in range\n0 < l < 20] ]
[[53] [Win32, Visual C++ 8] [Peak=433 Mean=11]]
[[64] [SUSE Linux IA32, g++ 4.1] [Peak=61.4 Mean=19.5]]
[[64] [Red Hat Linux IA64, g++ 3.4.4] [Peak=61.4 Mean=19.5] ]
[[113] [HPUX IA64, aCC A.06.06] [Peak=540 Mean=13.94] ]
]

Note that the worst errors occur when the degree increases, values greater than
~120 are very unlikely to produce sensible results, especially in the associated
polynomial case when the order is also large.  Further the relative errors
are likely to grow arbitrarily large when the function is very close to a root.

[h4 Testing]

A mixture of spot tests of values calculated using functions.wolfram.com, 
and randomly generated test data are
used: the test data was computed using
[@http://shoup.net/ntl/doc/RR.txt NTL::RR] at 1000-bit precision.

[h4 Implementation]

These functions are implemented using the stable three term
recurrence relations.  These relations guarentee low absolute error
but cannot guarentee low relative error near one of the roots of the
polynomials.

[endsect][/section:beta_function The Beta Function]
[/ 
  Copyright 2006 John Maddock and Paul A. Bristow.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

