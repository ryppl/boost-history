<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <title>Boost Named Template Parameters</title>
  </head>

  <body bgcolor="#FFFFFF" text="#000000">
  <img SRC="../../../c++boost.gif" ALT="C++ Boost" width="277" height="86">
  </img>

<h1>
Named Template Parameters
</h1>


<h2>Table of Contents</h2>

<ul>
  <li><a href="#introduction">Introduction</a></li>

  <li><a href="#using_named_template_parameters">Using named template parameters</a>

  <ul>
    <li><a href="#defining_parameter_names">Defining the parameter names</a></li>
     <li><a href="#default_values">Default values</a></li>
     <li><a href="#class_that_supports_NTP">The class that needs to support NTPs</a></li>
  </ul>

  </li>

  <li><a href="#advanced_topics">Advanced topics</a>

    <ul>
      <li><a href="#unnamed_named_coexistence">Mixing named and unnamed template parameters</a></li>
      <li><a href="#nontrivial_defaults">Nontrivial default values</a></li>
       <li><a href="#avoiding_pitfalls">Avoiding some pitfalls</a></li>
    </ul>

  </li>

  <li><a href="#how_it_works">How it works</a></li>

  <li><a href="#references">References</a></li>

</ul>

<h2 id="introduction">Introduction</h2>

<p>
The mapping between the <i>actual</i> template arguments and the <i>formal</i> 
template parameters in C++ is defined by the ordering of the parameters.

For example, consider the template definition:
</p>


<pre>
template&lt;class T1, class T2, class T3&gt; class A { ... };
</pre>
The mapping defined, say, by the instantiation:
<pre>
A&lt;int, char, float&gt;
</pre>


<p>is</p>

<p>
<code>T1 = int, T2 = char, T3 = float</code>
</p>


<p>When there are a large number of template parameters, the order based
mapping is seldom ideal.

First, it is easy to get the order of the parameters wrong, which can lead to 
hard to find errors. 

Second, many of the template parameters can have default values. 
Whether one can take advantage of the default value for a particular 
template argument or not, is dependent on the relative position of 
the parameter in the template parameter list.

Consider the following example:
</p>

<pre>template &lt;class Model = basic, class Color = black, 
          class Seats = no_leather, class Transmission = automatic&gt;
class car { ... }; 
</pre>

<p>

Suppose we make two instantiations of the <code>car</code> template: 

In the first one, we want to change the <code>Model</code> from <code>basic</code> to <code>limited_edition</code>, but otherwise the defaults are fine.

In the second one, we want <code>Transmission</code> to be <code>manual</code>
and, again, apply the default values for other parameters.

The two instantiations are:
</p>

<pre>
car&lt;limited_edition&gt; // first 
car&lt;basic, black, no_leather, manual&gt; // second
</pre>

<p>
In the second example all template arguments had to be written explicitly,
even though we only wanted to change one parameter.

This is because the <i>n</i> template arguments given in a template 
instantiation are always mapped to be the
<i>n</i> leftmost template parameters in the template definition.
</p>

<p>
In situations such as this, instead of defining the <i>actual argument &rarr; 
formal parameter</i> mapping
by the ordering of the parameter list, it would be preferrable 
to use <i>names</i> for template parameters. 
For example, with syntax like (pseudo code):
</p>

<pre>
car&lt;Transmission = manual&gt;
</pre>

<p>
There is no direct support for this in C++, 
but one can mimic the behaviour.
The technique is referred to as <i>Named Template Parmaters</i> (NTP).
</p>

<p>
The Boost Named Template Parameter library provides support for NTPs
with the following syntax:
</p>

<pre>
car&lt;Transmission_is&lt;manual&gt; &gt;
</pre>

<p>
Our implementation is a modified version of the solution presented in 
the forthcoming (at the time of writing this) book by 
<i>Daveed Vandevoorde</i> and <i>Nicolas Josuttis</i>.
</p>


<h2 id = "using_named_template_parameters">Using named template parameters</h2>

<p>Making your template class support named template parameters requires 
some work.
The feature cannot be encapsulated in a black box, but 
rather an interplay of
templates defined in the <i>Named Template Parameter</i> (NTP in the sequel) 
library and user defined templates is required.
The coarse steps that need to be taken are:
</p>

<ol>
<li><code>#include "boost/named_template_parameters.hpp"</code></li>
<li>Define templates that give names for the parameters.</li>
<li>Define a classes that give default values to the parameters.</li>
<li>Define the class that needs to support named template parameters.</li>
</ol>

<p>
The next three sections describe the steps 2, 3 and 4 in more detail.
Our starting point is the original definition of the <code>car</code> 
template we gave
in the introduction:
</p>

<pre>template &lt;class Model = basic, class Color = black, 
          class Seats = no_leather, class Transmission = automatic&gt;
class car { ... }; 
</pre>

<p>
The goal is to make this template accept any number (up to four) of the types 
<code>Model_is&lt;A&gt;</code>,
<code>Color_is&lt;B&gt;</code>,
<code>Seats_is&lt;C&gt;</code> or
<code>Transmission_is&lt;D&gt;</code> as its arguments, in arbitrary order. 

The types <code>A</code>, <code>B</code>,
<code>C</code> and <code>D</code> are the arguments for 
<code>Model</code>, <code>Color</code>,
<code>Seats</code> and <code>Transmission</code>.
Furthermore, for all arguments that are not defined, default type should 
be applied.
</p>

<h3 id="defining_parameter_names">Defining the parameter names</h3>

<p>
We have used the convention <code><i>name</i>_is</code> in our named template 
parameters.
The named template parameters are template classes themselves and can thus be 
named freely, but it is advisable to use consistent naming convention.
The orginal template parameters in the <code>car</code> template are named
as <code>Model</code>, <code>Color</code>, <code>Seats</code> and 
<code>Transmission</code>.
This suggests the names <code>Model_is</code>, <code>Color_is</code>, 
<code>Seats_is</code> and <code>Transmission_is</code>.

Whatever the naming convention, here is what a <i>named template parameter
template</i> needs to be like. 
We use <code>Model_is</code> as an example:
</p>

<pre>
template &lt;class T&gt struct Model_is : virtual public car_defaults
{ 
  typedef T Model; 
};
</pre>


<p>
The class contains one typedef <code>Model</code> which is the name of the
<i>feature</i> that it encapsulates. 
We have chosen to name the features with the names of the orginal template
arguments.
Again, consistent naming is advisable.
</p>

<p>
Each named template parameter template must inherit form a <i>default value 
class</i>.
In our example, this is <code>car_defaults</code>, which is
described below.


If a feature has a default value, the named template parmameter template
must inherit (using virtual inheritance) 
form a <i>default value class</i>, which in our example is 
<code>car_defaults</code>, described below.

</p>


<h3 id="default_values">Default values</h3>

<p>In its simplest form, just one class that contains the typedefs
for each feature is required:</p>

<pre>
struct car_defaults : 
  virtual public boost::ntp::named_parameter_tag {

  typedef basic Model;
  typedef black Color;
  typedef boost::ntp::unspecified Seats;
  typedef automatic Transmission;
};
</pre>

<p>
This class expresses that the default values are <code>basic</code> for 
<code>Model</code>, <code>black</code> for <code>Color</code>, etc.

Note the default value for <code>Seats</code>, which is
<code>boost:::ntp::unspecified</code>.

This just means that there is no default value, or that there is, but it may 
depend on the values of other features, which has to be dealt with another
mechanism. 
We explain this mechanism in section 
<a href="#nontrivial_defaults">Nontrivial default values</a>.
</p>

<h3 id = "class_that_supports_NTP">The class that needs to support NTPs</h3>

<p>
Our original template definition without NTPs was:
</p>

<pre>template &lt;class Model = basic, class Color = black, 
          class Seats = no_leather, class Transmission = automatic&gt;
class car { ... }; 
</pre>

<p>
This changes to:
</p>

<pre>
template &lt;class Model = car_defaults, 
          class Color = car_defaults,
          class Seats = car_defaults, 
          class Transmission = car_defaults&gt;
class car {

  typedef boost::tuple&lt;Model, Color, Seats, Transmission&gt; argument_tuple;

  typedef boost::ntp::named_parameter_extractor&lt;argument_tuple&gt; features;

public:

  typedef typename features::Model model;
  typedef typename features::Color color;
  typedef typename features::Seats seats;
  typedef typename features::Transmission transmission;

  ...
};
</pre>

<p>
The first thing to notice is that our default value class, 
<code>car_defaults</code>,
is used as the default for all parameters.
</p>

<p>
Second, the template parameter names <code>Model</code>, <code>Color</code> 
etc. do not make much sense anymore, as say <code>Model</code> could be
carrying the type <code>Color_is&lt;red&gt;</code> etc.
<a href="#footnote1"><sup>1</sup></a>

The task is to extract the types of different features from the template 
parameters. 
</p>

<p>
To accomplish this, we first group all template parameters 
into a 
<a href="http://www.boost.org/libs/tuple/doc/tuple_users_guide.html"><code>tuple</code></a> type:
</p>

<pre>
typedef boost::tuple&lt;Model, Color, Seats, Transmission&gt; argument_tuple;
</pre>

<p>
The order of the elements can be arbitrary.
</p>

<p>Next, the <code>argument_tuple</code> type is passed to 
<code>named_parameter_extractor</code> metafunction:
</p>

<pre>
typedef boost::ntp::named_parameter_extractor&lt;argument_tuple&gt; features;
</pre>

<p>
Now, the <code>features</code> type contains our four features as 
nested types. 
The typedefs we define make the features 
<code>model</code>, <code>color</code>, <code>seats</code> 
and <code>transmission</code> conveniently available as 
'first class citizens' of the <code>car</code> template class.
</p>


<p>
We have now covered the basic mechanism.
There are a few cases this basic mechanism cannot cover.
We have already alluded to the coexistense of unnamed and named 
template parameters being possible, as well as default values that 
are dependent on the values of other features. 
These are the topics of the next section.
</p>

<h2 id = "advanced_topics">Advanced topics</h2>

<h3 id = "unnamed_named_coexistence">Mixing named and unnamed template parameters</h3>

<p>
Named template parameters and normal unnamed parameters can coexist.
The same argument slot can be made to accept either a named or 
unnamed template argument. 

Let us choose to provide this functionality for the first two 
argument positions in the <code>car</code> template, 
that is, for <code>Model</code> and <code>Color</code>.
Concretely, we want to allow instantiations like:
</p>
<pre>
car&lt;limited_edition, black, Seats_is&lt;no_leather&gt; &gt;
car&lt;basic, Seats_is&lt;no_leather&gt;, Color_is&lt;black&gt; &gt;
</pre>

<p>
To give this dual behaviour to a template parameter slot,
one must wrap the template parameter with the <code>as_named</code> 
metafunction in the argument tuple type.
The argument tuple in our example becomes:
</p>
<pre>
typedef boost::tuple&lt;
  typename boost::ntp::as_named&lt;Model, Model_is&gt;::type, 
  typename boost::ntp::as_named&lt;Color, Color_is&gt;::type, 
  Seats, 
  Transmission    
&gt; argument_tuple;
</pre>

<p>
The first parameter to <code>as_named</code> is the template parameter, 
the second is the corresponding named template parameter template.
The <code>as_named</code> metafunction simply examines its first parameter,
and converts it to a NTP (using the second parameter) if it is not one already.
This is all that is needed. 
</p>

<!--Note, that using in our design goals we decided to 
allow instantiations where the first argument, 
or the first and the second arguments are unnamed template arguments.
In such instantiations <code>Model</code> really contains information about 
the model of the car etc.-->


<h3 id="nontrivial_defaults">Default value functions</h3>

<p>
Suppose we want to implement some logic to the default values for features
in the <code>car</code> template,
namely we want to make the value of <code>Model</code> imply the default value 
of <code>Seats</code>.
Concretely, if <code>Model == limited_edition</code>, the default value for 
<code>Seats</code> should be <code>leather</code>, 
otherwise it should be <code>no_leather</code>.
</p>

<p>
We can see that the default value for <code>Seats</code> is
dependent on the value the user gives for <code>Model</code>.
Our simple <code>car_defaults</code> class cannot handle this
situation as it can only provide a fixed type for each typedef.
Instead, we need a metafunction that takes the values provided for
other arguments as parameters and computes the default value based
on its parameters.
</p>

<p>
A convenient way to build such a metafunction is to have another
default value class, or actually a class template.
This template takes one template parameter, from which it inherits
using public inheritance.
The template parameter will contain the inputs to the metafunction, that
is, the features after the <em>trivial defaults</em> have been applied.
By trivial defaults we refer to the typedefs defined in the 
<code>car_defaults</code> class.
Hence, the second default value class defines defaults for all features
that do not have trivial defaults.
Naturally, if a feature intentionally does not have a default value,
one does not need to define a typedef for it in neither class.

Here is our default value template:
</p>

<pre>
using namspace boost;

template &lt;class Features&gt; struct nontrivial_car_defaults
  : public Features {
    typedef typename
      mpl::if_c&lt;is_same&lt;typename Features::Seats, ntp::unspecified&gt;::value,
        typename mpl::if_c&lt;is_same&lt;typename Features::Model, limited_edition&gt;::value,
          leather,
          no_leather
        &gt;::type,
      typename Features::Seats  
    &gt;::type Seats;
};
</pre>				    

<p>
The code of the metafunction is somewhat hard to read.
It uses the compile time if template from the Boost Metaprogramming Library.
The logic the metafunction implements is expressed in the following pseudocode:
</p>

<pre>
if (Features::Seats is unspecified) {
  if (Features::Model is limited_edition) Seats = leather;
  else Seats = no_leather;
}
else Seats = Features::Seats;
</pre>

<p>
Note that the trivial default value we gave for <code>Seats</code> was 
<code>unspecified</code>, a fact that we rely on here.
</p>

<p>To apply the nontrivial defaults we need to do some changes in
the <code>car</code> template.
Basically, the <code>features</code> type contains an intermediate feature set, and needs to be routed via the metafunction we just defined:
</p>
<pre>
typedef nontrivieal_car_defaults&lt;features&gt; final_features;
</pre>
<p>
Hence, the input to this metafunction is the features we had before.
As the result we get the same features with the nontrivial default 
values applied.
</p>

Below is the definition of the entire <code>car</code> template after
the changes in this and the previous section:
<pre>
template &lt;class Model = car_defaults, 
          class Color = car_defaults,
          class Seats = car_defaults, 
          class Transmission = car_defaults&gt;
class car {

  typedef boost::tuple&lt;
    typename boost::ntp::as_named&lt;Model, Model_is&gt;::type, 
    typename boost::ntp::as_named&lt;Color, Color_is&gt;::type, 
    Seats, 
    Transmission    
  &gt; argument_tuple;

  typedef boost::ntp::named_parameter_extractor&lt;argument_tuple&gt; features;

  typedef nontrivial_car_defaults&lt;features&gt; final_features;

public:

  typedef typename final_features::Model model;
  typedef typename final_features::Color color;
  typedef typename final_features::Seats seats;
  typedef typename final_features::Transmission transmission;

  ...
};
</pre>

<h3 id = "avoiding_pitfalls">Avoiding some pitfalls</h3>

<h4 id ="name_clashes">Name clashes</h4>

<p>
The named parameter templates must be defined in some namespace and you may
end up wanting to use the same template name for two different classes that
use the NTP scheme.
For example, a <code>bicycle</code> class could very well have a 
<code>Model</code> feature and thus <code>Model_is</code> would be a 
natural choice for the name of the named parameter template.

Also, most likely <code>car</code> and <code>bicycle</code> models do
not share the same default value.
</p>

<p>
The easiest way to solve this is to come up with different names for the
parameter.
Another possibility is to define the default classes like this:
</p>

<pre>
struct common_features {
  typedef boost::ntp::unspecified Model;
};

struct car_defaults : virtual public common_features { ... };
struct default_bicycle_features : virtual public common_features { ... };
</pre>

<p>
and make the <code>Model_is</code> class inherit from 
<code>common_features</code>, instead of car or bicycle defaults.
The real default values for car and bicycle are then defined in the templates
that define the default value metafunctions 
(cf. <code>nontrivial_car_defaults</code>).
</p>

<h4 id="nontype_parameters">Nontype template parameters</h4>

<p>The scheme discribed here does not directly support nontype template 
parameters.
The simplest solution to this is to use wrappers which can be used as
type template parameters.
For example:
</p>

<pre>
template&lt;int N&gt; struct int_wrapper {
  BOOST_STATIC_CONSTANT(int, value = N);
};
</pre>

<p>
defines a wrapper that can carry an integral constant.
</p>



<h2 id="how_it_works">How it works</h2>

<p>Do we need this?</p>

<h2 id = "rererences">References</h2>

<p>
Vandevoorde, Josuttis: C++ Template Book.
</p>

<fn id="footnote1"><sup>1</sup> 
We continue to use these names, however, as we later show how to allow
the coexistence of normal unnamed template parameters an NTPs (see section
xxx).</fn>

<hr></hr>

<p>
&copy; Copyright Jaakko Järvi and Jeremy Siek 2002. 
Permission to copy, use, modify, sell and distribute this document is 
granted provided this copyright notice appears in all copies. 
This document is provided "as is" without express or implied warranty, 
and with no claim as to its suitability for any purpose. 
</p>


</body>




</html>




<!-- (cf. <code>transmission_is</code> in the example in <i>Introduction</i>).

selitä, että kaikilla ei välttämättä ole oletusarvoa
-->

<!--

  typedef car_default_value_2&lt;
    intermediate_feature_list
  &gt; features;
  ...



    typename boost::ntp::as_named&lt;Model, Model_is&gt;::type, 
    typename boost::ntp::as_named&lt;Color, Color_is&gt;::type, 




<p>
Note that in the case where some named template parameter does not have 
a default value, 
there is no need to specify a typedef for that feature.
Alternatively, a typedef with a value like <code>boost::ntp::unsepcied</code> 
can be used. This latter method may lead to more readable error messages, if
the user fails to provide the named template argument in question.
</p>


-->
