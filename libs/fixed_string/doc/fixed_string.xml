<?xml version = "1.0" encoding = "UTF-8"?>

<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
          "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd"
>

<library name = "FixedString" dirname = "fixed_string" id = "fixedstr"
   last-revision = "$Date$"
   xmlns:xi = "http://www.w3.org/2003/XInclude"
>
<title>Fixed Capacity Strings</title>

<libraryinfo>
   <author><firstname>Reece</firstname><surname>Dunn</surname></author>
   <copyright><year>2004</year><holder>Reece H. Dunn</holder></copyright>
   <legalnotice><para>
      Distributed under the Boost Software License, Version 1.0.
      (See accompanying file LICENSE_1_0.txt or copy at
      <ulink url = "http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
   </para></legalnotice>
   <librarypurpose>
      Provide buffer overrun protected character arrays as a safe migration
      path from C-style code. Allow basic_string/STL operations on the strings
      for interoperability between C-style and C++-style strings.
   </librarypurpose>
   <librarycategory name = "category:string-text"/>
</libraryinfo>

<section id = "fixedstr.background"><title>Background</title>
<para>
   There is a lot of C (and even C++) code, that uses character buffers and
   the C-style string functions for various reasons: updating legacy C code,
   wanting to keep executable size down without linking to a large dynamic
   library or wanting to tune performance by keeping the strings on the
   stack. The problem with using this approach is that this can be
   potentially unsafe due to buffer overrun. Consider the following simple
   example:
</para>
<programlisting>
   char str[ 5 ];
   strcpy( str, "buffer overrun" );
   std::cout &lt;&lt; str &lt;&lt; '\n';
</programlisting>
<para>
   The simple solution is to use the <code>strn</code> variants of the string
   functions, specifying the size of the buffer:
</para>
<programlisting>
   char str[ 5 ];
   strncpy( str, "this is safer", 5 ); // #1
   std::cout &lt;&lt; str &lt;&lt; '\n';
   strncpy( str, "unsafe usage", 15 ); // #2
</programlisting>
<para>
   but there is still no guarantee that <code>str</code> is null-terminated
   or that the number of characters to copy provided is less than or equal
   to the length of the buffer (see #2 in the above).
</para><para>
   Microsoft supply a <code>&lt;strsafe.h&gt;</code> header file in the
   <ulink url = "http://www.microsoft.com/msdownload/platformsdk/sdkupdate/">PlatformSDK</ulink>
   that supports buffer-safe string functions, but these are Microsoft/Windows
   specific and are also fairly large inlined functions. These, like the
   <code>strn</code> library functions do not prevent the user specifying
   a size larger than the destination buffer.
</para><para>
   Microsoft have also submitted save variants of the various C API functions,
   including the string functions. However, these have not yet been
   standardized and are only (currently) available on the Microsoft Visual C++
   8.0 compiler.
</para><para>
   The standard library string allocates its own buffer so it protects
   against potential buffer attacks, but this may not be a viable option in
   a given situation (e.g. on an embedded system where space is a premium).
   It is also time consuming to port existing C code that uses character
   buffers to use C++-style strings.
</para>

<section id = "fixedstr.solution"><title>The Solution</title>
<para>
   The <code>boost::fixed_string</code> class is aimed at solving the problem
   outlined above and is designed to be a direct replacement for character
   buffers, operating as a fixed-capacity string. The class can be used
   like this:
</para>
<programlisting>
   #include &lt;boost/fixed_string/fsstring.hpp&gt; // safe C-style string functions

   // ...

   boost::fixed_string&lt; 5 &gt; str;
   strcpy( str, "buffer safe!" );
   std::cout &lt;&lt; "\"" &lt;&lt; str &lt;&lt; "\"\n"; // output: "buffe"
</programlisting>
</section>

</section><section id = "fixedstr.design"><title>The Design</title>

<section id = "fixedstr.requirements"><title>Requirements</title>
<itemizedlist>
   <listitem><para>
      The <code>boost::fixed_string</code> class should be a direct replacement
      for <code>char[ n ]</code> constructs. This is to make it easier to update
      existing code that uses C-style strings.
   </para></listitem>
   <listitem><para>
      The operations on <code>boost::fixed_string</code> should be protected
      against buffer overrun. This will make programs that use the class safer
      and more resiliant to malicious users.
   </para></listitem>
   <listitem><para>
      You should be able to operate on variable-capacity
      <code>boost::fixed_string</code>. This is to make it easy to update
      existing code and allow you to keep functions in a static or dynamic
      library (i.e. there is no need to replace the functions with template
      versions).
   </para></listitem>
   <listitem><para>
         The <code>boost::fixed_string</code> class should implement the
         <code>std::basic_string</code> interface. (See C++98[21.3] for
         the <code>std::basic_string</code> interface). The motivation behind
         this is to allow integration with STL code and provide a small
         learning curve for programmers familiar with std::string.
   </para></listitem>
</itemizedlist>
</section><section id = "fixedstr.basic_string_impl"><title>boost::detail::basic_string_impl</title>
<para>
   header: <code>&lt;boost/fixed_string/detail/basic_string_impl.hpp&gt;</code>
</para>
<synopsis>
   namespace boost { namespace detail {
   {
      template&lt; class Base, class ErrorPolicy = noerror_string_policy &gt;
      class basic_string_impl;
   }}
</synopsis>
         <para>
            The <code>std::basic_string</code> interface is a complex beast with a large set of functions. Many of
            these are implementable in terms of others, e.g.:
         </para>
<programlisting>
   inline this_type &amp; assign( const char_type * s )
   {
      return( assign( s, traits_type::length( s ));
   }
</programlisting>
         <para>
            so only a small subset need to be implemented, the others are all derivable. This is the principle
            behind Andrei Alexandrescu's 
            <ulink url = "http://www.cuj.com/experts/1906/alexandr.htm?topic=experts">flex_string</ulink>,
            from which <code>boost::detail::basic_string_impl</code> is based.
         </para><para>
            The interface that the user needs to implement (passed as the <code>Base</code> template parameter)
            is defined by the <code>StringPolicy</code>, the requirements of which are given in the table below
            (with <code>SP</code> as the <code>StringPolicy</code>):
         </para>
         <table><title>StringPolicy</title><tgroup cols = "3" align = "left" valign = "top">
            <thead><row>
               <entry>expression</entry>
               <entry>return type</entry>
               <entry>description</entry>
            </row></thead>
            <tbody>
               <row>
                  <entry><simpara><code>SP::substring_type</code></simpara></entry>
                  <entry><simpara><code><emphasis>implementation-defined</emphasis></code></simpara></entry>
                  <entry><simpara>specifies the return type of the <code>substring</code> function.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::traits_type</code></simpara></entry>
                  <entry><simpara><code><emphasis>implementation-defined</emphasis></code></simpara></entry>
                  <entry><simpara>specifies the <code>char_traits</code> policy class being used.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::allocator_type</code></simpara></entry>
                  <entry><simpara><code><emphasis>implementation-defined</emphasis></code></simpara></entry>
                  <entry><simpara>specifies the <code>allocator</code> policy class being used.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::iterator</code></simpara></entry>
                  <entry><simpara><code><emphasis>implementation-defined</emphasis></code></simpara></entry>
                  <entry><simpara>specifies the iterator type for the string data.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::const_iterator</code></simpara></entry>
                  <entry><simpara><code><emphasis>implementation-defined</emphasis></code></simpara></entry>
                  <entry><simpara>specifies the const variant of the iterator type.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::begin_()</code></simpara></entry>
                  <entry><simpara><code>iterator</code></simpara></entry>
                  <entry><simpara>returns the first element in the character sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::begin_() const</code></simpara></entry>
                  <entry><simpara><code>const_iterator</code></simpara></entry>
                  <entry><simpara>returns the first element in the character sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::end_()</code></simpara></entry>
                  <entry><simpara><code>iterator</code></simpara></entry>
                  <entry><simpara>returns the end of the character sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::end_() const</code></simpara></entry>
                  <entry><simpara><code>const_iterator</code></simpara></entry>
                  <entry><simpara>returns the end of the character sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::data_() const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::const_pointer</code></simpara></entry>
                  <entry><simpara>returns a pointer to the character sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::c_str_() const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::const_pointer</code></simpara></entry>
                  <entry><simpara>
                     returns a pointer to the character sequence; this function ensures that the
                     redurned value is null-terminated.
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::at_( allocator_type::size_type n )</code></simpara></entry>
                  <entry><simpara><code>allocator_type::reference</code></simpara></entry>
                  <entry><simpara>returns a reference to the <code>n</code>th character in the sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::at_( allocator_type::size_type n ) const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::const_reference</code></simpara></entry>
                  <entry><simpara>returns a reference to the <code>n</code>th character in the sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::length_() const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::size_type</code></simpara></entry>
                  <entry><simpara>returns the length of the string.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::capacity_() const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::size_type</code></simpara></entry>
                  <entry><simpara>returns the total space currently available to the string.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::max_size_() const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::size_type</code></simpara></entry>
                  <entry><simpara>returns the maximum size that a string can be.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::resize_( allocator_type::size_type n, allocator_type::value_type c )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>
                     resizes the space available to the string to <code>n</code>; if <code>n &gt; size()</code>, the
                     rest of the buffer is filled with the character <code>c</code>.
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::reserve_( szie_type n )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>ensures there is space available for <code>n</code> characters.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::assign_( allocator_type::const_pointer s, allocator_type::size_type n )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>
                     copies the string <code>s</code>, replacing the contents of the existing string; if
                     <code>n</code> is less than the length of <code>s</code>, only the first <code>n</code>
                     characters are copied.
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::append_( allocator_type::const_pointer s, allocator_type::size_type n )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>
                     adds the contents of the string <code>s</code> to the end of the existing string; if
                     <code>n</code> is less than the length of <code>s</code>, only the first <code>n</code>
                     characters are copied.
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::push_back_( allocator_type::value_type c )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>adds <code>c</code> to the end of the string.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::swap_( SP &amp; sp )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>swaps the two strings.</simpara></entry>
               </row>
            </tbody>
         </tgroup></table>
      </section><section id = "fixedstr.FormatPolicy"><title>Format Policy</title>
         <para>
            The character traits design provides an interface to a range of string functions that
            allow <code>std::basic_string</code> and the I/O streams to operate generically over
            the string type. It also allows for alternative implementations to the C string functions
            to be used (e.g. native platform functions or for/while loop implementations).
         </para><para>
            Using the <code>std::basic_string</code> interface, it is possible to implement most of
            the C-style string functions. However, the <code>printf</code> group of functions do not
            have an implementation equivalent (without implementing a low-level version of the <code>printf</code>
            function using I/O streams).
         </para><para>
            This is where the Format Policy comes in: it allows <code>printf</code>-style formatting
            that the <code>boost::fixed_string_base</code> class uses to provide a formatting function.
            The Format Policy has the folloring interface:
         </para>
         <table><title>FormatPolicy</title><tgroup cols = "3" align = "left" valign = "top">
            <thead><row>
               <entry>expression</entry>
               <entry>return type</entry>
               <entry>description</entry>
            </row></thead>
            <tbody>
               <row>
                  <entry><simpara><code>FP::format( CharT * s, size_t n, const CharT * fmt, va_list args )</code></simpara></entry>
                  <entry><simpara><code>int</code></simpara></entry>
                  <entry><simpara>
                     Formats the string <code>s</code> using the formatting string <code>fmt</code> and the
                     arguments supplied by <code>args</code>. It will write a maximum of <code>n</code>
                     characters.
                  </simpara></entry>
               </row>
            </tbody>
         </tgroup></table>
         <section id = "fixedstr.format_policy"><title>boost::detail::format_policy</title>
<synopsis>
   namespace boost { namespace detail
   {
      template&lt; typename CharT &gt;
      struct format_policy;
   }}
</synopsis>
         <para>
            This is an implementation of the <code>FormatPolicy</code> interface using the C library
            function <code>vsnprintf</code> for <code>char</code> strings and <code>vsnwprintf</code>
            for <code>wchar_t</code> strings.
         </para>
         </section>
      </section><section id = "fixedstr.fixed_string_impl"><title>boost::detail::fixed_string_impl</title>
<synopsis>
   namespace boost { namespace detail
   {
      template
      &lt;
         typename CharT, class Policy = std::char_traits&lt; CharT &gt;
         class FmtPolicy = format_policy&lt; CharT &gt;
      &gt;
      struct fixed_string_impl;
   }}
</synopsis>
         <para>
            This is an implementation of <code>StringPolicy</code> that holds the strings capacity
            as well as its length, thus allowing requirement [3] to be met without the use of
            virtual functions. It is not intended for external use.
         </para><para>
            <code>FmtPolicy</code> is a policy type conformant with the Format Policy interface.
         </para>
      </section><section id = "fixedstr.fixed_string_base"><title>boost::fixed_string_base</title>
         <para>
            header: <code>&lt;boost/fixed_string/fixed_string.hpp&gt;</code>
         </para>
<synopsis>
   namespace boost
   {
      template
      &lt;
         typename CharT, class Policy = std::char_traits&lt; CharT &gt;
         class FmtPolicy = detail::format_policy&lt; CharT &gt;
      &gt;
      struct fixed_string_base;

      typedef fixed_string_base&lt; char &gt;    char_string;
      typedef fixed_string_base&lt; wchar_t &gt; wchar_string;
   }
</synopsis>
         <para>
            This is the variable-capacity interface that allows you to operate on 
            <code>boost::fixed_string&lt; n &gt;</code> variables with different capacities. The
            typedefs are provided for convenience, e.g.:
         </para>
<programlisting>
   inline void print( const boost::char_string &amp; s )
   {
      std::cout &lt;&lt; "string = \"" &lt;&lt; s &lt;&lt; "\"\n";
   }
   // ...
   
   boost::fixed_string&lt; 10 &gt; str = "Halo Meine Welt!";
   print( str ); // output: string = "Halo Meine"
</programlisting>
         <para>
            Because of the way it is implemented, boost::fixed_string_base provides the <code>std::basic_string</code>
            interface (it derives from <code>boost::detail::basic_string_impl</code>) with the following
            limitations/differences:
            <itemizedlist>
               <listitem><para>
                  It is possible to construct a <code>boost::fixed_string_base</code> but there are limitations
                  on how to do this. You cannot create a default <code>boost::fixed_string_base</code> object
                  and it is inadvisable to construct a <code>boost::fixed_string_base</code> using the <code>+</code>
                  operator and <code>substr</code> function from <code>boost::fixed_string</code>.
               </para></listitem>
               <listitem><para>
                  The <code>substr</code> function and <code>+</code> operator are not implemented in this
                  class, although they are available in <code>boost::fixed_string</code>.
               </para></listitem>
            </itemizedlist>
         </para><para>
            <code>FmtPolicy</code> is a policy type conformant with the Format Policy interface.
         </para>
         <table><title>Additional Interface</title><tgroup cols = "3" align = "left" valign = "top">
            <thead><row>
               <entry>expression</entry>
               <entry>return type</entry>
               <entry>description</entry>
            </row></thead>
            <tbody>
               <row>
                  <entry><simpara><code>operator const char_type *() const</code></simpara></entry>
                  <entry><simpara><code>const char_type *</code></simpara></entry>
                  <entry><simpara>returns <code>c_str()</code>.</simpara></entry>
               </row><row>
                  <entry><simpara><code>buffer() const</code></simpara></entry>
                  <entry><simpara><code>char_type *</code></simpara></entry>
                  <entry><simpara>
                     Returns access to the internal string buffer.
                     <emphasis role = "bold">[Note:</emphasis>
                        This is not buffer safe -- use with caution!
                     <emphasis role = "bold">]</emphasis>
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>setlength( size_type sz = npos )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>
                     Recalculate the size of the string after external modification.
                     <emphasis role = "bold">[Note:</emphasis>
                        The modified string must be null-terminated and shorter than
                        <code>capacity()</code>, otherwise unpredictable behaviour
                        will occur.
                     <emphasis role = "bold">]</emphasis>
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>newlength()</code></simpara></entry>
                  <entry><simpara><code>length_proxy</code></simpara></entry>
                  <entry><simpara>
                     This method allows you to use the class with functions that return the
                     length of the string in a parameter, e.g.:
                     <programlisting>   get_string( buf, buf.newlength());</programlisting>.
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>ncapacity</code></simpara></entry>
                  <entry><simpara><code>size_t</code></simpara></entry>
                  <entry><simpara>
                     This is a static constant that contains the capacity of the string. It
                     is useful for copying fixed_string objects:
                     <programlisting>   boost::fixed_string&lt; buf.ncapacity &gt; duplicate( buf );</programlisting>
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>format( const char_type * fmt, va_list args )</code></simpara></entry>
                  <entry><simpara><code>int</code></simpara></entry>
                  <entry><simpara>
                     returns the number of characters copied by the <code>printf</code> operation on the
                     string.
                  </simpara></entry>
               </row>
            </tbody>
         </tgroup></table>
      </section><section id = "fixedstr.fixed_string"><title>boost::fixed_string</title>
         <para>
            header: <code>&lt;boost/fixed_string/fixed_string.hpp&gt;</code>
         </para>
<synopsis>
   namespace boost
   {
      template
      &lt;
         size_t n, typename CharT = char,
         class CharStringPolicy = std::char_traits&lt; CharT &gt;
         class FmtPolicy = detail::format_policy&lt; CharT &gt;
      &gt;
      class fixed_string;
   }
</synopsis>
         <para>
            This is the main class that provides the fixed-capacity string implementation, deriving
            itself from <code>boost::fixed_string_base</code>. It also provides the constructors
            specified in the <code>std::basic_string</code> interface.
         </para><para>
            <code>FmtPolicy</code> is a policy type conformant with the Format Policy interface.
         </para>
      </section><section id = "fixedstr.cstyle"><title>C-style Functions</title>
         <para>
            There are a set of headers that mirror the C standard library headers, providing fixed_string
            variants of the common C functions. The motivation behind this is to make it easier to move C
            code over to a buffer-safe environment.
         </para><para>
            header: <code>&lt;boost/fixed_string/fsstring.hpp&gt;</code>
         </para><para>
            This header implements the fixed_string variants of the following <code>&lt;string.h&gt;</code> functions:
            <code>strcpy</code>; <code>strcat</code>; <code>strcmp</code>; <code>strlen</code>;
            <code>strncpy</code>; <code>strncat</code>; and <code>strncmp</code>.
         </para><para>
            header: <code>&lt;boost/fixed_string/fsstdio.hpp&gt;</code>
         </para><para>
            This header implements the fixed_string variants of the following <code>&lt;stdio.h&gt;</code> functions:
            <code>sprintf</code>; and <code>vsprintf</code>.
         </para><para>
            header: <code>&lt;boost/fixed_string/fswchar.hpp&gt;</code>
         </para><para>
            This header implements the fixed_string variants of the following <code>&lt;wchar.h&gt;</code> functions:
            <code>wcscpy</code>; <code>wcscat</code>; <code>wcscmp</code>; <code>wcslen</code>
            <code>swprintf</code>; and <code>vswprintf</code>.
         </para>
      </section><section id = "fixedstr.formatter"><title>boost::formatter</title>
         <para>
            header: <code>&lt;boost/fixed_string/formatter.hpp&gt;</code>
         </para>
<synopsis>
   namespace boost
   {
      template
      &lt;
         size_t n, typename CharT = char,
         class CharStringPolicy = std::char_traits&lt; CharT &gt;
         class FmtPolicy = detail::format_policy&lt; CharT &gt;
      &gt;
      class formatterex;
      typedef formatterex&lt; 512 &gt; formatter;
   }
</synopsis>
         <para>
            <code>FmtPolicy</code> is a policy type conformant with the Format Policy interface.
         </para><para>
            It is quite often useful to have a string buffer to format variable messages (e.g. error
            messages from parsing a file with line number, file and error description) or queries
            such as XPath expressions or SQL queries. This can be done using <code>std::stringstream</code>
            like:
         </para>
<programlisting>
   std::stringstream xpath;
   xpath &lt;&lt; "coll/items[name = '" &lt;&lt; name &lt;&lt; "']";
   xmlnode n = xpath_query( xml, xpath.c_str());
</programlisting>
         <para>
            You may in these situations decide to use a C-string buffer for performance reasons, e.g.:
         </para>
<programlisting>
   char xpath[ 256 ];
   sprintf( xpath, "coll/items[name = '%s']", name );
   xmlnode n = xpath_query( xml, xpath );
</programlisting>
         <para>
            The fixed_string library provides a utility class called <code>boost::formatter</code> to
            simplify this style of programming, making it usable as a single line expression:
         </para>
<programlisting>
   xmlnode n = xpath_query( xml, boost::formatter( "coll/items[name = '%s']", name ));
</programlisting>
      </section>
   </section>

<xi:include href="autodoc.boostbook"/>

</library>
