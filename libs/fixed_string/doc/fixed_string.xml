<?xml version = "1.0" encoding = "UTF-8"?>

<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
          "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd"
>

<library name = "FixedString" dirname = "fixed_string" id = "fixedstr"
   last-revision = "$Date$"
   xmlns:xi = "http://www.w3.org/2003/XInclude"
>
   <title>Fixed Capacity Strings</title>

   <libraryinfo>
      <author><firstname>Reece</firstname><surname>Dunn</surname></author>
      <copyright><year>2004</year><holder>Reece H. Dunn</holder></copyright>
      <legalnotice><para>
         Distributed under the Boost Software License, Version 1.0.
         (See accompanying file LICENSE_1_0.txt or copy at
         <ulink url = "http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
      </para></legalnotice>
      <librarypurpose>
         Provide buffer overrun protected character arrays as a safe migration path from C-style
         code. Allow basic_string/STL operations on the strings for interoperability between
         C-style and C++-style strings.
      </librarypurpose>
      <librarycategory name = "category:string-text"/>
   </libraryinfo>

   <section id = "fixedstr.background"><title>Background</title>
      <para>
         There is a lot of C code, and even C++ code, that uses character buffers and the C string functions,
         for various reasons: updating legacy C code; wanting to keep executable size down without linking to
         a large dynamic library; or wanting to tune performance by keeping the strings on the stack. The
         problem with using this approach is that this can be potentially unsafe due to buffer overrun.
         Consider the following simple example:
      </para>
<programlisting>
   char str[ 5 ];
   strcpy( str, "buffer overrun" );
   std::cout &lt;&lt; str &lt;&lt; '\n';
</programlisting>
      <para>
         The simple solution is to use the <code>strn</code> variants of the string functions, specifying the
         size of the buffer:
      </para>
<programlisting>
   char str[ 5 ];
   strncpy( str, "this is safer", 5 ); // #1
   std::cout &lt;&lt; str &lt;&lt; '\n';
   strncpy( str, "unsafe usage", 15 ); // #2
</programlisting>
      <para>
         but there is still no guarantee that <code>str</code> is null-terminated or that the number of characters
         to copy provided is less than or equal to the length of the buffer (see #2 in the above).
      </para><para>
         Microsoft supply a <code>&lt;strsafe.h&gt;</code> header file in the
         <ulink url = "http://www.microsoft.com/msdownload/platformsdk/sdkupdate/">PlatformSDK</ulink>
         that supports buffer-safe string functions, but these are MS/Windows specific and are also fairly large
         inlined functions. These, like the <code>strn</code> library functions do not prevent the user specifying
         a size larger than the destination buffer.
      </para><para>
         The standard library string allocates its own buffer so it protects against potential buffer attacks,
         but this may not be a viable option in a given situation (e.g. on an embedded system where space is a
         premium). It is also time consuming to port existing C code that uses character buffers to use C++-style
         strings.
      </para>
      <section id = "fixedstr.solution"><title>The Solution</title>
         <para>
            The boost::fixed_string class is aimed at solving the problem outlined above and is designed to be a
            direct replacement for character buffers, operating as a fixed-capacity string. The class can be used
            like this:
         </para>
<programlisting>
   #include &lt;boost/fixed_string/fsstring.hpp&gt; // safe C-style string functions

   // ...

   boost::fixed_string&lt; 5 &gt; str;
   strcpy( str, "buffer safe!" );
   std::cout &lt;&lt; "\"" &lt;&lt; str &lt;&lt; "\"\n"; // output: "buffe"
</programlisting>
      </section>
   </section><section id = "fixedstr.design"><title>The Design</title>
      <section id = "fixedstr.requirements"><title>Requirements</title>
         <itemizedlist>
            <listitem><para>
               The <code>boost::fixed_string</code> class should be a direct replacement for <code>char[ n ]</code>
               constructs. This is to make it easier to update existing code that uses C-style strings.
            </para></listitem>
            <listitem><para>
               The operations on boost::fixed_string should be protected against buffer overrun. This will make
               programs that use the class safer and more resiliant to malicious users.
            </para></listitem>
            <listitem><para>
               You should be able to operate on variable-capacity <code>boost::fixed_string</code>. This is to
               make it easy to update existing code and allow you to keep functions in a static or dynamic
               library (i.e. there is no need to replace the functions with template versions).
            </para></listitem>
            <listitem>
               <para>
                  The <code>boost::fixed_string</code> class should implement the <code>std::basic_string</code>
                  interface. (See C++98[21.3] for the <code>std::basic_string</code> interface).
                  <emphasis role = "bold">[Note:</emphasis>
                     I am aware that this interface is flawed, but it is part of the standard and as such outlines
                     how a C++ string behaves.
                  <emphasis role = "bold">]</emphasis>
               </para><para>
                  The motivation behind this is to allow integration with STL code and provide a small learning
                  curve for programmers familiar with std::string.
               </para>
            </listitem>
         </itemizedlist>
      </section><section id = "fixedstr.basic_string_impl"><title>boost::detail::basic_string_impl</title>
         <para>
            header: <code>&lt;boost/fixed_string/detail/basic_string_impl.hpp&gt;</code>
         </para>
<synopsis>
   namespace boost { namespace detail {
   {
      template&lt; class Base, class ErrorPolicy = noerror_string_policy &gt;
      class basic_string_impl;
   }}
</synopsis>
         <para>
            The <code>std::basic_string</code> interface is a complex beast with a large set of functions. Many of
            these are implementable in terms of others, e.g.:
         </para>
<programlisting>
   inline this_type &amp; assign( const char_type * s )
   {
      return( assign( s, traits_type::length( s ));
   }
</programlisting>
         <para>
            so only a small subset need to be implemented, the others are all derivable. This is the principle
            behind Andrei Alexandrescu's 
            <ulink url = "http://www.cuj.com/experts/1906/alexandr.htm?topic=experts">flex_string</ulink>,
            from which <code>boost::detail::basic_string_impl</code> is based.
         </para><para>
            The interface that the user needs to implement (passed as the <code>Base</code> template parameter)
            is defined by the <code>StringPolicy</code>, the requirements of which are given in the table below
            (with <code>SP</code> as the <code>StringPolicy</code>):
         </para>
         <table><title>StringPolicy</title><tgroup cols = "3" align = "left" valign = "top">
            <thead><row>
               <entry>expression</entry>
               <entry>return type</entry>
               <entry>description</entry>
            </row></thead>
            <tbody>
               <row>
                  <entry><simpara><code>SP::substring_type</code></simpara></entry>
                  <entry><simpara><code><emphasis>implementation-defined</emphasis></code></simpara></entry>
                  <entry><simpara>specifies the return type of the <code>substring</code> function.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::traits_type</code></simpara></entry>
                  <entry><simpara><code><emphasis>implementation-defined</emphasis></code></simpara></entry>
                  <entry><simpara>specifies the <code>char_traits</code> policy class being used.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::allocator_type</code></simpara></entry>
                  <entry><simpara><code><emphasis>implementation-defined</emphasis></code></simpara></entry>
                  <entry><simpara>specifies the <code>allocator</code> policy class being used.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::iterator</code></simpara></entry>
                  <entry><simpara><code><emphasis>implementation-defined</emphasis></code></simpara></entry>
                  <entry><simpara>specifies the iterator type for the string data.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::const_iterator</code></simpara></entry>
                  <entry><simpara><code><emphasis>implementation-defined</emphasis></code></simpara></entry>
                  <entry><simpara>specifies the const variant of the iterator type.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::begin_()</code></simpara></entry>
                  <entry><simpara><code>iterator</code></simpara></entry>
                  <entry><simpara>returns the first element in the character sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::begin_() const</code></simpara></entry>
                  <entry><simpara><code>const_iterator</code></simpara></entry>
                  <entry><simpara>returns the first element in the character sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::end_()</code></simpara></entry>
                  <entry><simpara><code>iterator</code></simpara></entry>
                  <entry><simpara>returns the end of the character sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::end_() const</code></simpara></entry>
                  <entry><simpara><code>const_iterator</code></simpara></entry>
                  <entry><simpara>returns the end of the character sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::data_() const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::const_pointer</code></simpara></entry>
                  <entry><simpara>returns a pointer to the character sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::c_str_() const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::const_pointer</code></simpara></entry>
                  <entry><simpara>
                     returns a pointer to the character sequence; this function ensures that the
                     redurned value is null-terminated.
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::at_( allocator_type::size_type n )</code></simpara></entry>
                  <entry><simpara><code>allocator_type::reference</code></simpara></entry>
                  <entry><simpara>returns a reference to the <code>n</code>th character in the sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::at_( allocator_type::size_type n ) const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::const_reference</code></simpara></entry>
                  <entry><simpara>returns a reference to the <code>n</code>th character in the sequence.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::length_() const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::size_type</code></simpara></entry>
                  <entry><simpara>returns the length of the string.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::capacity_() const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::size_type</code></simpara></entry>
                  <entry><simpara>returns the total space currently available to the string.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::max_size_() const</code></simpara></entry>
                  <entry><simpara><code>allocator_type::size_type</code></simpara></entry>
                  <entry><simpara>returns the maximum size that a string can be.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::resize_( allocator_type::size_type n, allocator_type::value_type c )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>
                     resizes the space available to the string to <code>n</code>; if <code>n &gt; size()</code>, the
                     rest of the buffer is filled with the character <code>c</code>.
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::reserve_( szie_type n )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>ensures there is space available for <code>n</code> characters.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::assign_( allocator_type::const_pointer s, allocator_type::size_type n )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>
                     copies the string <code>s</code>, replacing the contents of the existing string; if
                     <code>n</code> is less than the length of <code>s</code>, only the first <code>n</code>
                     characters are copied.
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::append_( allocator_type::const_pointer s, allocator_type::size_type n )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>
                     adds the contents of the string <code>s</code> to the end of the existing string; if
                     <code>n</code> is less than the length of <code>s</code>, only the first <code>n</code>
                     characters are copied.
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::push_back_( allocator_type::value_type c )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>adds <code>c</code> to the end of the string.</simpara></entry>
               </row><row>
                  <entry><simpara><code>SP::swap_( SP &amp; sp )</code></simpara></entry>
                  <entry><simpara><code>void</code></simpara></entry>
                  <entry><simpara>swaps the two strings.</simpara></entry>
               </row>
            </tbody>
         </tgroup></table>
      </section><section id = "fixedstr.fixed_string_iface"><title>boost::detail::fixed_string_iface</title>
<synopsis>
   namespace boost { namespace detail
   {
      template&lt; typename CharT, class Policy = std::char_traits&lt; CharT &gt; &gt;
      struct fixed_string_iface;
   }}
</synopsis>
         <para>
            This is an implementation of <code>StringPolicy</code> that exposes the methods as pure
            virtual functions. The virtual functions are used to help meed requirement [3] and is
            not intended for external use.
         </para>
      </section><section id = "fixedstr.fixed_string_base"><title>boost::fixed_string_base</title>
         <para>
            header: <code>&lt;boost/fixed_string/fixed_string.hpp&gt;</code>
         </para>
<synopsis>
   namespace boost
   {
      template&lt; typename CharT, class CharStringPolicy = std::char_traits&lt; CharT &gt; &gt;
      struct fixed_string_base;

      typedef fixed_string_base&lt; char &gt;    char_string;
      typedef fixed_string_base&lt; wchar_t &gt; wchar_string;
   }
</synopsis>
         <para>
            This is the variable-capacity interface that allows you to operate on 
            <code>boost::fixed_string&lt; n &gt;</code> variables with different capacities. The
            typedefs are provided for convenience, e.g.:
         </para>
<programlisting>
   inline void print( const boost::char_string &amp; s )
   {
      std::cout &lt;&lt; "string = \"" &lt;&lt; s &lt;&lt; "\"\n";
   }
   // ...
   
   boost::fixed_string&lt; 10 &gt; str = "Halo Meine Welt!";
   print( str ); // output: string = "Halo Meine"
</programlisting>
         <para>
            Because of the way it is implemented, boost::fixed_string_base provides the <code>std::basic_string</code>
            interface (it derives from <code>boost::detail::basic_string_impl</code>) with the following
            limitations/differences:
            <itemizedlist>
               <listitem><para>
                  you cannot directly create a boost::fixed_string_base, it can only be used as a reference
                  or pointer to a boost::fixed_string object, and as such it does not have any constructors;
               </para></listitem>
               <listitem><para>
                  the substring operations return a <code>std::basic_string</code> type.
               </para></listitem>
            </itemizedlist>
         </para>
         <table><title>Additional Interface</title><tgroup cols = "3" align = "left" valign = "top">
            <thead><row>
               <entry>expression</entry>
               <entry>return type</entry>
               <entry>description</entry>
            </row></thead>
            <tbody>
               <row>
                  <entry><simpara><code>operator const char_type *() const</code></simpara></entry>
                  <entry><simpara><code>const char_type *</code></simpara></entry>
                  <entry><simpara>returns <code>c_str()</code>.</simpara></entry>
               </row><row>
                  <entry><simpara><code>buffer() const</code></simpara></entry>
                  <entry><simpara><code>char_type *</code></simpara></entry>
                  <entry><simpara>
                     returns access to the internal string buffer.
                     <emphasis role = "bold">[Note:</emphasis>
                        This is not buffer safe -- use with caution!
                     <emphasis role = "bold">]</emphasis>
                  </simpara></entry>
               </row><row>
                  <entry><simpara><code>format( const char_type * fmt, va_list args )</code></simpara></entry>
                  <entry><simpara><code>int</code></simpara></entry>
                  <entry><simpara>
                     returns the number of characters copied by the <code>printf</code> operation on the
                     string.
                  </simpara></entry>
               </row>
            </tbody>
         </tgroup></table>
      </section><section id = "fixedstr.fixed_string"><title>boost::fixed_string</title>
         <para>
            header: <code>&lt;boost/fixed_string/fixed_string.hpp&gt;</code>
         </para>
<synopsis>
   namespace boost
   {
      template&lt; size_t n, typename CharT = char, class CharStringPolicy = std::char_traits&lt; CharT &gt; &gt;
      class fixed_string;
   }
</synopsis>
         <para>
            This is the main class that provides the fixed-capacity string implementation, deriving
            itself from <code>boost::fixed_string_base</code>. It also provides the constructors
            specified in the <code>std::basic_string</code> interface.
         </para>
      </section><section id = "fixedstr.cstyle"><title>C-style Functions</title>
         <para>
            There are a set of headers that mirror the C standard library headers, providing fixed_string
            variants of the common C functions. The motivation behind this is to make it easier to move C
            code over to a buffer-safe environment.
         </para><para>
            header: <code>&lt;boost/fixed_string/fsstring.hpp&gt;</code>
         </para><para>
            This header implements the fixed_string variants of the following <code>&lt;string.h&gt;</code> functions:
            <code>strcpy</code>; <code>strcat</code>; <code>strcmp</code>; <code>strlen</code>;
            <code>strncpy</code>; <code>strncat</code>; and <code>strncmp</code>.
         </para><para>
            header: <code>&lt;boost/fixed_string/fsstdio.hpp&gt;</code>
         </para><para>
            This header implements the fixed_string variants of the following <code>&lt;stdio.h&gt;</code> functions:
            <code>sprintf</code>; and <code>vsprintf</code>.
         </para><para>
            header: <code>&lt;boost/fixed_string/fswchar.hpp&gt;</code>
         </para><para>
            This header implements the fixed_string variants of the following <code>&lt;wchar.h&gt;</code> functions:
            <code>wcscpy</code>; <code>wcscat</code>; <code>wcscmp</code>; <code>wcslen</code>
            <code>swprintf</code>; and <code>vswprintf</code>.
         </para>
      </section>
   </section>
</library>
