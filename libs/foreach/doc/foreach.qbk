
[library BOOST_FOREACH
    [version 1.0]
    [authors [Niebler, Eric]]
    [copyright 2004 Eric Niebler]
    [category algorithms]
    [purpose 
        foreach looping construct, for writing simple loops over STL containers,
        null-terminated strings, arrays, iterator pairs and user defined types.
    ]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        <ulink url="http://www.boost.org/LICENSE_1_0.txt">
            http://www.boost.org/LICENSE_1_0.txt
        </ulink>)
    ]
]

[/ QuickBook Document version 1.0 ]

[/  Images   ]

[def _note_               [$images/note.png]]
[def _alert_              [$images/caution.png]]
[def _detail_             [$images/note.png]]
[def _tip_                [$images/tip.png]]

[/  Links   ]

[def _iterator_           [@http://boost.org/libs/iterator/doc/index.html Boost.Iterator]]
[def _range_              [@http://boost.org/libs/range/index.html Boost.Range]]
[def _iterator_range_     [@http://boost.org/libs/range/doc/utility_class.html#iter_range `boost::iterator_range<>`]]
[def _sub_range_          [@http://boost.org/libs/range/doc/utility_class.html#sub_range `boost::sub_range<>`]]
[def _foreach_            `BOOST_FOREACH`]

[section Introduction]

[:"Make simple things easy."]
[:[*['-- Larry Wall]]]

[h2 What is _foreach_?]

In C++, writing a loop that iterates over a sequence is tedious. You can either
use iterators, which requires a considerable amount of boiler-plate, or you can
use the `std::for_each()` algorithm and move your loop body into a predicate, which
requires no less boiler-plate and forces you to move your logic far from where
it will be used. In contrast, some other languages provide a dedicated "foreach"
construct that automates this process. _foreach_ is just such a construct for C++.
It iterates over sequences for you, freeing you from having to deal directly with
iterators or write predicates.

_foreach_ is designed for ease-of-use and efficiency. It does no dynamic allocations,
makes no virtual function calls or calls through function pointers, and makes no calls
that are not transparent to the compiler's optimizer. This results in near-optimal code
generation; the performance of _foreach_ is usually within a few percent of the
equivalent hand-coded loop. And although _foreach_ is a macro, it is a remarkably
well-behaved one. On modern compilers, it evaluates its arguments exactly once, leading
to no nasty surprises.

[h2 Hello, world!]

Below is a sample program that uses _foreach_ to loop over the contents of
a null-terminated C-style string.

    #include <iostream>
    #include <boost/foreach.hpp>

    int main()
    {
        BOOST_FOREACH( char ch, "Hello, world!" )
        {
            std::cout << ch;
        }
        return 0;
    }

This program outputs the following:

[pre
Hello, world!
]

[h2 Supported Sequence Types]

_foreach_ iterates over sequences. But what qualifies as a sequence, exactly? Since
_foreach_ is built on top of _range_, it automatically supports those types which
_range_ recognizes as sequences. In particular, you can use _foreach_ with:

* STL containers
* arrays
* Null-terminated strings (`char` and `wchar_t`)
* std::pair of iterators

[blurb _note_ The support for STL containers is very general; anything that looks like
an STL container counts. If it has nested `iterator` and `const_iterator` types and `begin()`
and `end()` member functions, _foreach_ will automatically know how to iterate over
it. It is in this way that _iterator_range_ and _sub_range_ work with _foreach_.]

See the section on [link boost_foreach.extending_boost_foreach Extending _foreach_] to find
out how to make _foreach_ work with other types.

[h2 Examples]

Below are some examples that demonstrate all the different ways you can use _foreach_.

Iterate over an STL container:

    std::list<int> list_int( /*...*/ );
    BOOST_FOREACH( int i, list_int )
    {
        // do something with i
    }

Iterate over an array, with covariance (i.e., the type of the iteration variable is
not exactly the same as the element type of the container):

    short array_short[] = {1,2,3};
    BOOST_FOREACH( int i, array_short )
    {
        // The short was implicitly converted to an int
    }

Predeclare the loop variable, and use `break`, `continue`, and `return` in the loop body:

    std::deque<int> deque_int( /*...*/ );
    int i = 0;
    BOOST_FOREACH( i, deque_int )
    {
        if(i==0) return;
        if(i==1) continue;
        if(i==2) break;
    }

Iterate over a sequence by reference, and modify the underlying sequence:

    short array_short[] = {1,2,3};
    BOOST_FOREACH( short & i, array_short )
    {
        ++i;
    }
    // array_short contains {2,3,4} here

Iterate over an expression that returns a sequence by value (i.e. an r-value):

    extern std::vector<float> get_vector_float();
    BOOST_FOREACH( float f, get_vector_float() )
    {
        // Note: get_vector_float() will be called exactly once
    }    

Iterating over r-values doesn't work on some older compilers. Check the 
[link boost_foreach.portability Portability] section to see whether your
compiler supports this.    

[endsect]

[section Extending BOOST_FOREACH]

If you want to use _foreach_ to iterate over some new collection type, you must
"teach" _foreach_ how to interact with your type. Since _foreach_ is built on top
of _range_, you must extend _range_ in order to extend _foreach_.

Below is an example for extending _foreach_ to iterate over a type which wraps a
`std::string`.

    struct StringWrapper
    {
        std::string str;
    };

    namespace boost
    {
        // specialize rannge_iterator and range_const_iterator
        template<>
        struct range_iterator<StringWrapper>
        {
            typedef std::string::iterator type;
        };

        template<>
        struct range_const_iterator<StringWrapper>
        {
            typedef std::string::const_iterator type;
        };

        // Overload begin() and end(), both const and non-const versions
        std::string::iterator begin(StringWrapper & w) { return w.str.begin(); }
        std::string::iterator end(StringWrapper & w) { return w.str.end(); }

        std::string::const_iterator begin(StringWrapper const & w) { return w.str.begin(); }
        std::string::const_iterator end(StringWrapper const & w) { return w.str.begin(); }
    }

Now that you have taught _range_ (and hence _foreach_) about your type, you
can now use _foreach_ to iterate over your type.

    StringWrapper my_string_wrapper;
    BOOST_FOREACH( char ch, my_string_wrapper )
    {
        // Woo-hoo!
    }

There are some portability issues you should be aware of when extending _foreach_. Be sure
to check out the [link boost_foreach.portability Portability] section.

[endsect]

[section Portability]

_foreach_ uses some fairly sophisticated techniques that not all compilers support. Depending
on how compliant your compiler is, you may not be able to use _foreach_ in some scenarios. Since
_foreach_ uses _range_, it inherits _range_'s portability issues. You can read about those
issues in that library's [@http://boost.org/libs/range/doc/portability.html Portability]
section.

In addition to the demands placed on the compiler by _range_, _foreach_ places additional demands
in order to handle r-value sequences properly. (Recall that an r-value is an unnamed object, so
an example of an r-value sequence would be a function that returns a `std::vector<>` by value.) Compilers
vary in their handling of r-values and l-values. To cope with the situation _foreach_ defines three
levels of compliance, described below:

[table BOOST_FOREACH Compliance Levels
  [[Level]   [Meaning]]
  [[*Level 0*] [['[_Highest level of compliance]]\n
                _foreach_ works with l-values, r-values and const-qualified r-values.]]
  [[*Level 1*] [['[_Moderate level of compliance]]\n
                _foreach_ works with l-values and plain r-values, but not const-qualified r-values.\n
                `BOOST_FOREACH_NO_CONST_RVALUE_DETECTION` is defined in this case.]]
  [[*Level 2*] [['[_Lowest level of compliance]]\n
                _foreach_ works with l-values only, not r-values.\n
                `BOOST_FOREACH_NO_RVALUE_DETECTION` is defined in this case.]]
]

Below are the compilers _foreach_ has been tested with, and the compliance level you can expect
from each.

[table Compiler Compliance Level
  [[Compiler]                [Compliance Level]]
  [[Visual C++ 7.1]          [Level 1]]
  [[Visual C++ Whidbey Beta] [Level 1]]
  [[Visual C++ 7.0]          [Level 2]]
  [[Visual C++ 6.0]          [Level 2]]
  [[gcc 3.3.3]               [Level 0]]
  [[Intel for Windows 8.0]   [Level 1]]
  [[Intel for Windows 7.0]   [Level 2]]
  [[Comeau 4.3.3]            [Level 0]]
]

Also, if your compiler is one for which the Boost config system defines `BOOST_NO_FUNCTION_TEMPLATE_ORDERING`,
then the compliance level for the _foreach_ macro is Level 2, the lowest.

[endsect]

[section Acknowledgements]

_foreach_ wouldn't have been possible without the help and incessant prodding of Anson Tsao at
Microsoft, with whom I co-authored an article for the November 2003 issue of the [@http://www.cuj.com CUJ].
I would also like to thank [@http://boost.org/people/thorsten_ottosen.html Thorsten Ottosen] for
the _range_ library, on which the current version of _foreach_ is built.

[endsect]
