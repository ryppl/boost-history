<html>
	<head>
		<title>A Proposal to Add General Purpose Smart Pointers to the Standard Library</title>
		<meta http-equiv="Content-Language" content="en-us">
		<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
	</head>
	<body>
		<h1>A Proposal to Add General Purpose Smart Pointers to the Standard Library</h1>
		<h2>I. Motivation</h2>
		<p>Resource management, particularly of dynamically allocated memory, has been a 
			serious concern since the days of the earliest digital computers. Many modern 
			computer languages (Python, Perl, Java) provide built-in facilities for 
			managing dynamically allocated memory. In both the C and C++ languages, leaving 
			dynamic memory management choices up to the programmer is a long-standing 
			design decision.</p>
		<p>Use of a pointer-like object called a <i>smart-pointer</i> to manage dynamically 
			allocated memory has been the preferred approach in C++ for many years. Google 
			finds 153,000 references to the term "smart pointer", with the high-ranking 
			listings almost entirely in the context of C++ programming. Leading authors of 
			C++ related books often treat smart pointers in depth. Of the 50 plus C++ 
			libraries available on the Boost web site, the Boost Smart Pointer library is 
			the most commonly visited. Smart pointers are encountered with great frequency 
			in production code. There is clearly great interest and need for quality smart 
			pointers in the C++ community.</p>
		<p>The list of possible smart pointer features is extremely broad. The C++ Standard 
			Library currently provides a single smart pointer, <i>std::auto_ptr</i>, which 
			provides specific and focused transfer-of-ownership semantics. Arguably the 
			most common need, however, is for shared-ownership semantics. Because<i> std::auto_ptr</i>
			does not provide shared-ownership semantics, it cannot even be used with 
			Standard Library containers.</p>
		<p>This document proposes a smart-pointer with shared-ownership semantics which 
			meets a very broad spectrum of smart-pointer needs, is based on existing 
			practice, and has many other beneficial characteristics. An implementation is 
			available at <a href="http://www.boost.org/libs/smart_ptr">http://www.boost.org/libs/smart_ptr</a>.</p>
		<h3>A. Motivation for a shared-ownership smart pointer</h3>
		<ul>
			<li>
			Is a reasonable default choice for many or even most smart pointer needs, 
			consistent with the spirit of the Standard Library.
			<li>
			Can be used in Standard Library containers, filling a major embarrassing gap in 
			the current Standard Library.
			<li>
				Has been reinvented thousands of times [<a href="#Google03">Google03</a>] 
			(often with gratuitous mistakes and misfeatures).
			<li>
				Is very hard to specify and implement correctly, particularly as regards 
				exception safety, thread safety, and weak pointers. See <a href="#Implementation-difficulty">
					Implementation difficulty</a> below.</li>
		</ul>
		<h3>B. Motivation for the <i>shared_ptr</i> shared-ownership smart pointer</h3>
		<p><i>[Rather than specifying memory management policy via class template parameters, 
				shared_ptr has an alternate constructor with a second argument supplying a 
				destruction policy functor. This is the key to understanding both the design 
				itself and several of the claimed advantages.]</i></p>
		<ul>
			<li>
			Has the same object type regardless of features used, greatly facilitating 
			interoperability between libraries, including third-party libraries.
			<li>
			Supports custom deallocators, allowing user-specified memory policies and 
			extending management to a wide range of object types, such as COM objects.
			<li>
			Supports weak pointers, allowing cycle breaking and supporting observer 
			applications such as caches.
			<li>
			Delivers exceptional expressive power without additional template 
			parameterization, easing use by novices and experts alike.
			<li>
			Supports encapsulation and implementation hiding via the ability to safely use 
			incomplete classes and protected nonvirtual base destructors, and the ability 
			to hide allocation details.
			<li>
			"Just works" in numerous tricky situations, such as calling the right 
			destructor and crossing load-unit/heap boundaries.
			<li>
			Requires no language support and does not prevent users or the Standard Library 
			from later adding other smart pointers to meet additional needs.
			<li>
			Allows several implementation techniques, leaving implementors room for 
			tradeoffs.
			<li>
				Reflects existing practice with a decade of refinement and use, including many 
				non-obvious enhancements. [<a href="#Colvin94">Colvin94</a>]
			<li>
				Is widely recommended in books, magazine articles, and newsgroup postings by 
				both C++ experts and everyday users.</li>
		</ul>
		<h3>C. Motivation for the <i>weak_ptr</i> shared-ownership-observer smart pointer</h3>
		<ul>
			<li>
				Supports data structures with cyclic pointers, with the benefit that either <i>weak_ptr</i>
				or <i>shared_ptr</i>
			covers all important shared-ownership use cases.
			<li>
			Supports observer idioms such as caches, simplifying their use.
			<li>
			Replaces unsafe uses of raw pointers, guaranteeing an exception rather than 
			undefined behavior if used after object deletion.
			<li>
				Reflects existing practice with a decade of refinement and use. [<a href="#Ellis94">Ellis94</a>]</li>
		</ul>
		<h2>II. Impact On the Standard</h2>
		<p>
			This proposal is almost a pure library extension. It proposes changes to an 
			existing header, <code>&lt;memory&gt;</code>, but it does not require changes 
			to any standard classes or functions and it does not require changes to any of 
			the standard requirement tables. It does not require any changes in the core 
			language, and it has been implemented in standard C++. The proposal does not 
			depend on any other library extensions.
		</p>
		<h2>III. Design Decisions</h2>
		<h3>A. General Principles</h3>
		<h4>1. "As Close to Raw Pointers as Possible, but no Closer"</h4>
		<p>[...]</p>
		<h4>2. "Just Do the Right Thing"</h4>
		<p>[...]</p>
		<h4>3. No Extra Parameters</h4>
		<p>[...]</p>
		<h4>4. No Preferred Implementation</h4>
		<p>[...]</p>
		<h4>5. The "Shares Ownership with" Equivalence Relation</h4>
		<p>[...]</p>
		<h4>6. The "Empty Pointer" Concept</h4>
		<p>[...]</p>
		<h3>B. shared_ptr</h3>
		<h4>1.</h4>
		<p>[...]</p>
		<h3>C. weak_ptr</h3>
		<h4>1.</h4>
		<p>[...]</p>
		<h3>D. Alternatives</h3>
		<h4>1. Policy Based Smart Pointers</h4>
		<p>[...]</p>
		<h4>2. Garbage Collection</h4>
		<p>[...]</p>
		<h2>IV. Proposed Text</h2>
		<h3>A. Additions to header &lt;memory&gt; synopsis (20.4)</h3>
		<pre>
  class bad_weak_ptr;

  template&lt;class T&gt; class shared_ptr;

  template&lt;class T, class U&gt;
    bool operator==(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b);

  template&lt;class T, class U&gt;
    bool operator!=(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b);

  template&lt;class T, class U&gt;
    bool operator&lt;(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b);

  template&lt;class T&gt;
    void swap(shared_ptr&lt;T&gt; &amp; a, shared_ptr&lt;T&gt; &amp; b);

  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt; const &amp; r);

  template&lt;class T, class U&gt;
    shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt; const &amp; r);

  template&lt;class E, class T, class Y&gt;
    basic_ostream&lt;E, T&gt; &amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt; &amp; os, shared_ptr&lt;Y&gt; const &amp; p);

  template&lt;class D, class T&gt;
    D * get_deleter(shared_ptr&lt;T&gt; const &amp; p);

  template&lt;class T&gt; class weak_ptr;

  template&lt;class T, class U&gt;
    bool operator&lt;(weak_ptr&lt;T&gt; const &amp; a, weak_ptr&lt;U&gt; const &amp; b);

  template&lt;class T&gt;
    void swap</A>(weak_ptr&lt;T&gt; &amp; a, weak_ptr&lt;T&gt; &amp; b);

  template&lt;class T&gt; class enable_shared_from_this;
</pre>
		<h3>B. Class <code>bad_weak_ptr</code></h3>
		<pre>
    namespace std {
      class bad_weak_ptr: public exception
      {
      public:
        bad_weak_ptr();
      };
    }
</pre>
		<p>An exception of type <code>bad_weak_ptr</code> is thrown by the <code>shared_ptr</code>
			constructor taking a <code>weak_ptr</code>.</p>
		<pre>
    bad_weak_ptr();
</pre>
		<p><b>Postconditions:</b> <code>what()</code> returns <code>"std::bad_weak_ptr"</code>.</p>
		<p><b>Throws:</b> nothing.</p>
		<h3>C. Class template <code>shared_ptr</code></h3>
		<p>The class template <code>shared_ptr</code>...</p>
		<pre>
    namespace std {
      template&lt;class T&gt; class shared_ptr {
      public:
        typedef T element_type;

        <em>// constructors</em>
        shared_ptr();
        template&lt;class Y&gt; explicit shared_ptr(Y * p);
        template&lt;class Y, class D&gt; shared_ptr(Y * p, D d);
        shared_ptr(shared_ptr const &amp; r);
        template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt; const &amp; r);
        template&lt;class Y&gt; explicit shared_ptr(weak_ptr&lt;Y&gt; const &amp; r);
        template&lt;class Y&gt; explicit shared_ptr(auto_ptr&lt;Y&gt; &amp; r);

        <em>// destructor</em>
        ~shared_ptr();

        <em>// assignment</em>
        shared_ptr &amp; operator=(shared_ptr const &amp; r);
        template&lt;class Y&gt; shared_ptr &amp; operator=(shared_ptr&lt;Y&gt; const &amp; r);
        template&lt;class Y&gt; shared_ptr &amp; operator=(auto_ptr&lt;Y&gt; &amp; r);

        <em>// modifiers</em>
        void swap(shared_ptr &amp; r);
        void reset();
        template&lt;class Y&gt; void reset(Y * p);
        template&lt;class Y, class D&gt; void reset(Y * p, D d);

        <em>// observers</em>
        T * get() const;
        T &amp; operator*() const;
        T * operator-&gt;() const;
        long use_count() const;
        bool unique() const;
        operator <em>unspecified-bool-type</em>() const;
      };

      <em>// comparison</em>
      template&lt;class T, class U&gt;
        bool operator==(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b);

      template&lt;class T, class U&gt;
        bool operator!=(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b);

      template&lt;class T, class U&gt;
        bool operator&lt;(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b);

      <em>// other operators</em>
      template&lt;class E, class T, class Y&gt;
        basic_ostream&lt;E, T&gt; &amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt; &amp; os, shared_ptr&lt;Y&gt; const &amp; p);

      <em>// specialized algorithms</em>
      template&lt;class T&gt; void swap(shared_ptr&lt;T&gt; &amp; a, shared_ptr&lt;T&gt; &amp; b);

      <em>// casts</em>
      template&lt;class T, class U&gt;
        shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt; const &amp; r);

      template&lt;class T, class U&gt;
        shared_ptr&lt;T&gt; dynamic_pointer_cast</A>(shared_ptr&lt;U&gt; const &amp; r);

      <em>// get_deleter</em>
      template&lt;class D, class T&gt;
        D * get_deleter(shared_ptr&lt;T&gt; const &amp; p);
    }
</pre>
		<p><code>shared_ptr</code> is <code>CopyConstructible</code> and <code>Assignable</code>, 
			allowing its use in standard containers, and convertible to <code>bool</code>, 
			allowing its use in boolean expressions and declarations in conditions.</p>
		<h4><code>shared_ptr</code> constructors</h4>
		<pre>
    shared_ptr();
</pre>
		<p><b>Effects:</b> Constructs an <EM>empty</EM> <code>shared_ptr</code>.</p>
		<p><b>Postconditions:</b> <code>get() == 0</code>.</p>
		<p><b>Throws:</b> nothing.</p>
		<pre>
    template&lt;class Y&gt; explicit shared_ptr(Y * p);
</pre>
		<p><b>Requires:</b> <code>p</code> must be convertible to <code>T *</code>. <code>Y</code>
			must be a complete type. The expression <code>delete p</code> must be 
			well-formed, must not invoke undefined behavior, and must not throw exceptions.
		</p>
		<p><b>Effects:</b> Constructs a <code>shared_ptr</code> that <EM>owns</EM> the 
			pointer <code>p</code>.</p>
		<p><b>Postconditions:</b> <code>use_count() == 1 &amp;&amp; get() == p</code>.</p>
		<p><b>Throws:</b> <code>bad_alloc</code> or an implementation-defined exception 
			when a resource other than memory could not be obtained.</p>
		<p><b>Exception safety:</b> If an exception is thrown, <code>delete p</code> is 
			called.</p>
		<pre>
    template&lt;class Y, class D&gt; shared_ptr(Y * p, D d);
</pre>
		<p><b>Requires:</b> <code>p</code> must be convertible to <code>T *</code>. <code>D</code>
			must be <code>CopyConstructible</code>. The copy constructor and destructor of <code>
				D</code> must not throw. The expression <code>d(p)</code> must be 
			well-formed, must not invoke undefined behavior, and must not throw exceptions.
		</p>
		<p><b>Effects:</b> Constructs a <code>shared_ptr</code> that <EM>owns</EM> the 
			pointer <code>p</code> and the deleter <code>d</code>.</p>
		<p><b>Postconditions:</b> <code>use_count() == 1 &amp;&amp; get() == p</code>.</p>
		<p><b>Throws:</b> <code>bad_alloc</code> or an implementation-defined exception 
			when a resource other than memory could not be obtained.</p>
		<p><b>Exception safety:</b> If an exception is thrown, <code>d(p)</code> is called.</p>
		<pre>
    shared_ptr(shared_ptr const &amp; r);
    template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt; const &amp; r);
</pre>
		<p><b>Effects:</b> If <code>r</code> is <EM>empty</EM>, constructs an <EM>empty</EM>
			<code>shared_ptr</code>; otherwise, constructs a <code>shared_ptr</code> that <EM>shares 
				ownership</EM> with <code>r</code>.</p>
		<p><b>Postconditions:</b> <code>get() == r.get() &amp;&amp; use_count() == 
				r.use_count()</code>.</p>
		<p><b>Throws:</b> nothing.</p>
		<pre>
    template&lt;class Y&gt; explicit shared_ptr(weak_ptr&lt;Y&gt; const &amp; r);
</pre>
		<p><b>Effects:</b> If <code>r</code> is <EM>empty</EM>, constructs an <EM>empty</EM>
			<code>shared_ptr</code>; otherwise, constructs a <code>shared_ptr</code> that <EM>shares 
				ownership</EM> with <code>r</code> and stores a copy of the pointer stored 
			in <code>r</code>.</p>
		<p><b>Postconditions:</b> <code>use_count() == r.use_count()</code>.</p>
		<p><b>Throws:</b> <code>bad_weak_ptr</code> when <code>r.use_count() == 0</code>.</p>
		<p><b>Exception safety:</b> If an exception is thrown, the constructor has no 
			effect.</p>
		<pre>
    template&lt;class Y&gt; shared_ptr(auto_ptr&lt;Y&gt; &amp; r);
</pre>
		<p><b>Requires:</b> <code>r.release()</code> must be convertible to <code>T *</code>.
			<code>Y</code> must be a complete type. The expression <code>delete r.release()</code>
			must be well-formed, must not invoke undefined behavior, and must not throw 
			exceptions.
		</p>
		<P><B>Effects:</B> Constructs a <code>shared_ptr</code> that stores and <em>owns</em>
			<code>r.release()</code>.</P>
		<p><b>Postconditions:</b> <code>use_count() == 1</code>.</p>
		<p><b>Throws:</b> <code>bad_alloc</code> or an implementation-defined exception 
			when a resource other than memory could not be obtained.</p>
		<P><B>Exception safety:</B> If an exception is thrown, the constructor has no 
			effect.</P>
		<h4><code>shared_ptr</code> destructor</h4>
		<pre>
    ~shared_ptr();
</pre>
		<P><B>Effects:</B></P>
		<UL>
			<LI>
				If <code>*this</code> is <EM>empty</EM>, or <EM>shares ownership</EM> with 
				another <code>shared_ptr</code> instance (<code>use_count() &gt; 1</code>), 
			there are no side effects.
			<LI>
				Otherwise, if <code>*this</code> <EM>owns</EM> a pointer <code>p</code> and a 
				deleter <code>d</code>, <code>d(p)</code>
			is called.
			<LI>
				Otherwise, <code>*this</code> <EM>owns</EM> a pointer <code>p</code>, and <code>delete 
					p</code> is called.</LI></UL>
		<P><B>Throws:</B> nothing.</P>
		<h4><code>shared_ptr</code> assignment</h4>
		<pre>
    shared_ptr &amp; operator=(shared_ptr const &amp; r);
    template&lt;class Y&gt; shared_ptr &amp; operator=(shared_ptr&lt;Y&gt; const &amp; r);
    template&lt;class Y&gt; shared_ptr &amp; operator=(auto_ptr&lt;Y&gt; &amp; r);
</pre>
		<P><B>Effects:</B> Equivalent to <code>shared_ptr(r).swap(*this)</code>.</P>
		<P><B>Returns:</B> <code>*this</code>.</P>
		<P><B>Notes:</B> The use count updates caused by the temporary object construction 
			and destruction are not considered observable side effects, and the 
			implementation is free to meet the effects (and the implied guarantees) via 
			different means, without creating a temporary. In particular, in the example:</P>
		<pre>
  shared_ptr&lt;int&gt; p(new int);
  shared_ptr&lt;void&gt; q(p);
  p = p;
  q = p;
</pre>
		<p>both assignments may be no-ops.</p>
		<h4><code>shared_ptr</code> modifiers</h4>
		<pre>
    void swap(shared_ptr &amp; r);
</pre>
		<p><b>Effects:</b> Exchanges the contents of <code>*this</code> and <code>r</code>.</p>
		<p><b>Throws:</b> nothing.</p>
		<pre>
    void reset();
</pre>
		<P><B>Effects:</B> Equivalent to <code>shared_ptr().swap(*this)</code>.</P>
		<pre>
    template&lt;class Y&gt; void reset(Y * p);
</pre>
		<P><B>Effects:</B> Equivalent to <code>shared_ptr(p).swap(*this)</code>.</P>
		<pre>
    template&lt;class Y, class D&gt; void reset(Y * p, D d);
</pre>
		<P><B>Effects:</B> Equivalent to <code>shared_ptr(p, d).swap(*this)</code>.</P>
		<h4><code>shared_ptr</code> observers</h4>
		<pre>
    T * get() const;
</pre>
		<p><b>Returns:</b> the stored pointer.</p>
		<p><b>Throws:</b> nothing.</p>
		<pre>
    T &amp; operator*() const;
</pre>
		<p><b>Requires:</b> <code>get() != 0</code>.</p>
		<p><b>Returns:</b> <code>*get()</code>.</p>
		<p><b>Throws:</b> nothing.</p>
		<pre>
    T * operator-&gt;() const;
</pre>
		<p><b>Requires:</b> <code>get() != 0</code>.</p>
		<p><b>Returns:</b> <code>get()</code>.</p>
		<p><b>Throws:</b> nothing.</p>
		<pre>
    long use_count() const;
</pre>
		<p><b>Returns:</b> the number of <code>shared_ptr</code> objects, <code>*this</code>
			included, that <i>share ownership</i> with <code>*this</code>, or an 
			unspecified nonnegative value when <code>*this</code> is <EM>empty</EM>.</p>
		<p><b>Throws:</b> nothing.</p>
		<P><B>Notes:</B> <code>use_count()</code> is not necessarily efficient. Use only 
			for debugging and testing purposes, not for production code.</P>
		<pre>
    bool unique() const;
</pre>
		<p><b>Returns:</b> <code>use_count() == 1</code>.</p>
		<p><b>Throws:</b> nothing.</p>
		<P><B>Notes:</B> <code>unique()</code> may be faster than <code>use_count()</code>. 
			If you are using <code>unique()</code> to implement copy on write, do not rely 
			on a specific value when <code>get() == 0</code>.</P>
		<pre>
    operator <em>unspecified-bool-type</em> () const;
</pre>
		<p><b>Returns:</b> an unspecified value that, when used in boolean contexts, is 
			equivalent to <code>get() != 0</code>.</p>
		<p><b>Throws:</b> nothing.</p>
		<P><B>Notes:</B> This conversion operator allows <b>shared_ptr</b> objects to be 
			used in boolean contexts, like <code>if (p &amp;&amp; p-&gt;valid()) {}</code>. 
			The actual target type is typically a pointer to a member function, avoiding 
			many of the implicit conversion pitfalls.</P>
		<h4><code>shared_ptr</code> comparison</h4>
		<pre>
    template&lt;class T, class U&gt;
      bool operator==(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b);
</pre>
		<p><b>Returns:</b> <code>a.get() == b.get()</code>.</p>
		<p><b>Throws:</b> nothing.</p>
		<pre>
    template&lt;class T, class U&gt;
      bool operator!=(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b);
</pre>
		<p><b>Returns:</b> <code>a.get() != b.get()</code>.</p>
		<p><b>Throws:</b> nothing.</p>
		<pre>
    template&lt;class T, class U&gt;
      bool operator&lt;(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b);
</pre>
		<p><b>Returns:</b> an unspecified value such that</p>
		<UL>
			<LI>
				<code>operator&lt;</code> is a strict weak ordering as described in section 
				25.3 <code>[lib.alg.sorting]</code>;
			<LI>
				under the equivalence relation defined by <code>operator&lt;</code>, <code>!(a &lt; 
					b) &amp;&amp; !(b &lt; a)</code>, two <code>shared_ptr</code> instances are 
				equivalent if and only if they <EM>share ownership</EM>.</LI></UL>
		<p><b>Throws:</b> nothing.</p>
		<P><B>Notes:</B> Allows <code>shared_ptr</code> objects to be used as keys in 
			associative containers.</P>
		<h4><code>shared_ptr</code> operators</h4>
		<pre>
    template&lt;class E, class T, class Y&gt;
      basic_ostream&lt;E, T&gt; &amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt; &amp; os, shared_ptr&lt;Y&gt; const &amp; p);
</pre>
		<p><STRONG>Effects:</STRONG> <code>os &lt;&lt; p.get();</code>.</p>
		<P><B>Returns:</B> <code>os</code>.</P>
		<h4><code>shared_ptr</code> specialized algorithms</h4>
		<pre>
    template&lt;class T&gt;
      void swap(shared_ptr&lt;T&gt; &amp; a, shared_ptr&lt;T&gt; &amp; b);
</pre>
		<P><B>Effects:</B> Equivalent to <code>a.swap(b)</code>.</P>
		<P><B>Throws:</B> nothing.</P>
		<h4><code>shared_ptr</code> casts</h4>
		<pre>
    template&lt;class T, class U&gt;
      shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt; const &amp; r);
</pre>
		<P><STRONG>Requires:</STRONG> The expression <code>static_cast&lt;T*&gt;(r.get())</code>
			must be well-formed.</P>
		<P><B>Returns:</B> If <code>r</code> is <em>empty</em>, an <em>empty</em> <code>shared_ptr&lt;T&gt;</code>; 
			otherwise, a <code>shared_ptr&lt;T&gt;</code> object that stores <code>static_cast&lt;T*&gt;(r.get())</code>
			and <em>shares ownership</em> with <code>r</code>.</P>
		<P><B>Throws:</B> nothing.</P>
		<P><B>Notes:</B> the seemingly equivalent expression</P>
		<p><code>shared_ptr&lt;T&gt;(static_cast&lt;T*&gt;(r.get()))</code></p>
		<p>will eventually result in undefined behavior, attempting to delete the same 
			object twice.</p>
		<pre>
    template&lt;class T, class U&gt;
      shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt; const &amp; r);
</pre>
		<P><STRONG>Requires:</STRONG> The expression <CODE>dynamic_cast&lt;T*&gt;(r.get())</CODE>
			must be well-formed and its behavior defined.</P>
		<P><B>Returns:</B></P>
		<UL>
			<LI>
				When <CODE>dynamic_cast&lt;T*&gt;(r.get())</CODE> returns a nonzero value, a <code>shared_ptr&lt;T&gt;</code>
				object that stores a copy of it and <em>shares ownership</em> with <code>r</code>;
			<LI>
				Otherwise, an <em>empty</em> <code>shared_ptr&lt;T&gt;</code> object.</LI></UL>
		<P><B>Throws:</B> nothing.</P>
		<P><B>Notes:</B> the seemingly equivalent expression</P>
		<P><CODE>shared_ptr&lt;T&gt;(dynamic_cast&lt;T*&gt;(r.get()))</CODE></P>
		<P>will eventually result in undefined behavior, attempting to delete the same 
			object twice.</P>
		<h4>get_deleter</h4>
		<pre>
    template&lt;class D, class T&gt;
      D * get_deleter(shared_ptr&lt;T&gt; const &amp; p);
</pre>
		<P><B>Returns:</B> If <code>*this</code> <EM>owns</EM> a deleter <code>d</code> of 
			type (cv-unqualified) <code>D</code>, returns <code>&amp;d</code>; otherwise 
			returns 0.</P>
		<P><B>Throws:</B> nothing.</P>
		<h3>D. Class template <code>weak_ptr</code></h3>
		<p>The class template <code>weak_ptr</code>...</p>
<pre>
    namespace std {
      template&lt;class T&gt; class weak_ptr {

      public:
        typedef T element_type;

        <em>// constructors</em>
        weak_ptr();
        template&lt;class Y&gt; weak_ptr(shared_ptr&lt;Y&gt; const &amp; r);
        weak_ptr(weak_ptr const &amp; r);
        template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt; const &amp; r);

        <em>// destructor</em>
        ~weak_ptr();

        <em>// assignment</em>
        weak_ptr &amp; operator=(weak_ptr const &amp; r);
        template&lt;class Y&gt; weak_ptr &amp; operator=(weak_ptr&lt;Y&gt; const &amp; r);
        template&lt;class Y&gt; weak_ptr &amp; operator=(shared_ptr&lt;Y&gt; const &amp; r);

        <em>// modifiers</em>
        void swap(weak_ptr &amp; r);
        void reset();

        <em>// observers</em>
        long use_count() const;
        bool expired() const;
        shared_ptr&lt;T&gt; lock() const;
      };

      <em>// comparison</em>
      template&lt;class T, class U&gt;
        bool operator&lt;(weak_ptr&lt;T&gt; const &amp; a, weak_ptr&lt;U&gt; const &amp; b);

      <em>// specialized algorithms</em>
      template&lt;class T&gt;
        void swap(weak_ptr&lt;T&gt; &amp; a, weak_ptr&lt;T&gt; &amp; b);
    }
</pre>
		<p><code>weak_ptr</code> is <code>CopyConstructible</code>, <code>Assignable</code>, 
			and <code>LessThanComparable</code>, allowing its use in standard containers.</p>
		<h4><code>weak_ptr</code> constructors</h4>
<pre>
    weak_ptr();
</pre>
			<p><b>Effects:</b> Constructs an <EM>empty</EM> <code>weak_ptr</code>.</p>
			<p><b>Postconditions:</b> <code>use_count() == 0</code>.</p>
			<p><b>Throws:</b> nothing.</p>
<pre>
    template&lt;class Y&gt; weak_ptr</A>(shared_ptr&lt;Y&gt; const &amp; r);
    weak_ptr(weak_ptr const &amp; r);
    template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt; const &amp; r);
</pre>
			<p><b>Effects:</b> If <code>r</code> is <EM>empty</EM>, constructs an <EM>empty</EM>
				<code>weak_ptr</code>; otherwise, constructs a <code>weak_ptr</code> that <EM>shares 
					ownership</EM> with <code>r</code> and stores a copy of the 
				pointer stored in <code>r</code>.</p>
			<p><b>Postconditions:</b> <code>use_count() == r.use_count()</code>.</p>
			<p><b>Throws:</b> nothing.</p>
		<h4><code>weak_ptr</code> destructor</h4>
<pre>
    ~weak_ptr();
</pre>
			<P><B>Effects:</B> Destroys this <code>weak_ptr</code> but has no effect on the object 
				its stored pointer points to.</P>
			<P><B>Throws:</B> nothing.</P>
		<h4><code>weak_ptr</code> assignment</h4>
<pre>
    weak_ptr &amp; operator=(weak_ptr const &amp; r);
    template&lt;class Y&gt; weak_ptr &amp; operator=(weak_ptr&lt;Y&gt; const &amp; r);
    template&lt;class Y&gt; weak_ptr &amp; operator=(shared_ptr&lt;Y&gt; const &amp; r);
</pre>
			<P><B>Effects:</B> Equivalent to <code>weak_ptr(r).swap(*this)</code>.</P>
			<P><B>Throws:</B> nothing.</P>
			<P><B>Notes:</B> The implementation is free to meet the effects (and the implied 
				guarantees) via different means, without creating a temporary.</P>
		<h4><code>weak_ptr</code> modifiers</h4>
<pre>
    void swap(weak_ptr &amp; r);
</pre>
			<p><b>Effects:</b> Exchanges the contents of <code>*this</code> and <code>r</code>.</p>
			<p><b>Throws:</b> nothing.</p>
<pre>
    void reset();
</pre>
			<P><B>Effects:</B> Equivalent to <code>weak_ptr().swap(*this)</code>.</P>
		<h4><code>weak_ptr</code> observers</h4>
<pre>
    long use_count() const;
</pre>
			<p><b>Returns:</b> if <code>*this</code> is <EM>empty</EM>, an unspecified 
				nonnegative value; otherwise, the number of <code>shared_ptr</code> instances that <EM>share 
					ownership</EM> with <code>*this</code>.</p>
			<p><b>Throws:</b> nothing.</p>
			<P><B>Notes:</B> <code>use_count()</code> is not necessarily efficient. Use only 
				for debugging and testing purposes, not for production code.</P>
<pre>
    bool expired() const;
</pre>
			<p><b>Returns:</b> <code>use_count() == 0</code>.</p>
			<p><b>Throws:</b> nothing.</p>
			<P><B>Notes:</B> <code>expired()</code> may be faster than <code>use_count()</code>.</P>
<pre>
    shared_ptr&lt;T&gt; lock() const;
</pre>
			<P><B>Returns:</B> <code>expired()? shared_ptr&lt;T&gt;(): shared_ptr&lt;T&gt;(*this)</code>.</P>
			<P><B>Throws:</B> nothing.</P>
		<h4><code>weak_ptr</code> comparison</h4>
<pre>
    template&lt;class T, class U&gt;
      bool operator&lt;(weak_ptr&lt;T&gt; const &amp; a, weak_ptr&lt;U&gt; const &amp; b);
</pre>
			<p><b>Returns:</b> an unspecified value such that</p>
			<UL>
				<LI>
					<code>operator&lt;</code> is a strict weak ordering as described in section 25.3 <code>[lib.alg.sorting]</code>;
				<LI>
					under the equivalence relation defined by <code>operator&lt;</code>, <code>!(a 
						&lt; b) &amp;&amp; !(b &lt; a)</code>, two <code>weak_ptr</code> instances 
					are equivalent if and only if they <EM>share ownership</EM>.</LI></UL>
			<p><b>Throws:</b> nothing.</p>
			<P><B>Notes:</B> Allows <code>weak_ptr</code> objects to be used as keys in 
				associative containers.</P>
		<h4><code>weak_ptr</code> specialized algorithms</h4>
<pre>
    template&lt;class T&gt;
      void swap(weak_ptr&lt;T&gt; &amp; a, weak_ptr&lt;T&gt; &amp; b)
</pre>
			<P><B>Effects:</B> Equivalent to <code>a.swap(b)</code>.</P>
			<P><B>Throws:</B> nothing.</P>
		<h3>E. Class template <code>enable_shared_from_this</code></h3>
		<pre>
    namespace std {
      template&lt;class T&gt; class enable_shared_from_this {
      public:
        shared_ptr&lt;T&gt; shared_from_this();
        shared_ptr&lt;T const&gt; shared_from_this() const;
      };
    }
</pre>
<pre>
    template&lt;class T&gt; shared_ptr&lt;T&gt; 
      enable_shared_from_this&lt;T&gt;::shared_from_this();
    template&lt;class T&gt; shared_ptr&lt;T const&gt; 
      enable_shared_from_this&lt;T&gt;::shared_from_this() const;
</pre>
			<p>
				<b>Requires:</b> <code>enable_shared_from_this&lt;T&gt;</code> must be an 
				accessible base class of <code>T</code>. <code>*this</code> must be a subobject 
				of an instance <code>t</code> of type <code>T</code> . There must exist 
				at least one <code>shared_ptr</code> instance <code>p</code> that <EM>owns</EM>
				<code>&amp;t</code>.
			</p>
			<p>
				<b>Returns:</b> A <code>shared_ptr&lt;T&gt;</code> instance <code>r</code> that shares 
				ownership with <code>p</code>.
			</p>
			<p>
				<b>Postconditions:</b> <code>r.get() == this</code>.
			</p>
		<h2>V. Code Examples</h2>
		<h3><a name="Implementation-difficulty">Implementation difficulty</a></h3>
		<p>The Boost developers found a shared-ownership smart pointer exceedingly 
			difficult to implement correctly. Others have made the same observation. For 
			example, Scott Meyers [<a href="#Meyers01">Meyers01</a>] says:</p>
		<blockquote>
			<p>The STL itself contains no reference-counting smart pointer, and writing a good 
				one - one that works correctly all the time - is tricky enough that you don't 
				want to do it unless you have to. I published the code for a reference-counting 
				smart pointer in More Effective C++ in 1996, and despite basing it on 
				established smart pointer implementations and submitting it to extensive 
				pre-publication reviewing by experienced developers, a small parade of valid 
				bug reports has trickled in for years. The number of subtle ways in which 
				reference-counting smart pointers can fail is remarkable.</p>
		</blockquote>
		<h4>Example 1</h4>
		<blockquote>
			<pre>shared_ptr&lt;X&gt; p(new X);</pre>
		</blockquote>
		<p>It is very common for even expert implementations to leak the X object when the 
			constructor throws an exception.</p>
		<h4>Example 2</h4>
		<blockquote>
			<pre>p.reset(new X);</pre>
		</blockquote>
		<p>A variation of the above example. The behavior when reset throws should be to 
			delete the X object, and have no other effects, i.e. p must be left unchanged.</p>
		<h4>Example 3</h4>
		<p>Taken from Boost's shared_ptr_test.cpp:</p>
		<blockquote>
			<pre>struct X
{
    boost::shared_ptr&lt;X&gt; next;
};

void test()
{
    boost::shared_ptr&lt;X&gt; p(new X);
    p-&gt;next = boost::shared_ptr&lt;X&gt;(new X);
    p = p-&gt;next;
    BOOST_TEST(!p-&gt;next);
}</pre>
		</blockquote>
		<p>Again, it is surprising how many experts get this wrong.</p>
		<h2>VI. Acknowledgements</h2>
		<h2>VII. References</h2>
		<p>[<a name="Colvin94">Colvin94</a>] Gregory Colvin, <i>Exception Safe Smart Pointers</i>, 
			C++ committee document 94-168/N0555, July, 1994. Available online at <a href="http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/1994/N0555.pdf">
				http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/1994/N0555.pdf</a></p>
		<p>[<a name="Ellis94">Ellis94</a>] John R. Ellis and David L. Detlefs, <i>Safe, 
				Efficient Garbage Collection for C++</i>, Usenix Proceedings, February, 
			1994. This paper includes an extensive discussion of weak pointers and an 
			extensive bibliography. Available online at <a href="http://www.usenix.org/publications/library/proceedings/c++94/full_papers/ellis.a">
				http://www.usenix.org/publications/library/proceedings/c++94/full_papers/ellis.a</a></p>
		<p>[<a name="Meyers01">Meyers01</a>] Scott Meyers, <i><a href="http://www.awl.com/cseng/titles/0-201-74962-9/">
					Effective STL</a></i>, page 39, Addison-Wesley, 2001, ISBN 
			0-201-74962-9.</p>
		<p>[<a name="Google03">Google03</a>] Searching <a href="http://www.google.com">www.google.com</a>
			for &quot;reference counted smart pointer&quot; yields 2,400 entries. Anyone 
			doubting that shared-ownership smart pointers have been reinvented a large 
			number of times should read a random selection of these entries.</p>
	</body>
</html>
