<HTML>
<HEAD>
  <TITLE>Generic Combinatorial Algorithms</TITLE>
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
<H1>
  <CENTER>
    next_r_permutation, prev_r_permutation, next_r_combination, prev_r_combination
  </CENTER>
</H1>
<H3>
  Contents
</H3>
<UL>
  <LI>
    <A href="#Introduction">Introduction</A>
  <LI>
    <A href="#Description">Description</A>
  <LI>
    <A href="#Performance">Performance</A>
  <LI>
    <A href="#Examples">Examples and Test Programs</A>
  <LI>
    <A href="#References">References</A>
</UL>
<P>
<H3>
  <A name="Introduction">Introduction</A>
</H3>
<P>
A common problem is the a need to generate a combinations of a subset of
objects from a larger set of objects. The STL's permutation algorithms,
next_permutation and prev_permutation, will work on entire sets, but not
on subsets. For this reason, I've written a suite of generic combinatorial
algorithms to complement the existing functions. Specifically, they are
algorithms to implement ordered and unordered selection without replacement
(referred to as r-permutations and r-combinations in some texts
<A href="#Johnsonbaugh">[1]</A>).
<P>
The programs have been compiled and tested on MacOS 9 using Metrowerks
Codewarrior version 5 and on Windows 98 using Microsoft Visual C++ version
6.0.
<P>
<H3>
  <A name="Description">Description</A>
</H3>
<P>
There are eight primary functions in this collection and they follow the
format and semantics commonly found among functions in the STL. They are
<UL>
  <LI>
    <A href="#next_r_permutation">next_r_permutation</A>,
  <LI>
    <A href="#prev_r_permutation">prev_r_permutation</A>,
  <LI>
    <A href="#next_r_combination">next_r_combination</A>,
  <LI>
    <A href="#prev_r_combination">prev_r_combination</A>,
  <LI>
    and user-supplied binary comparison predicate versions of each.
</UL>
<P>
They're defined in the header file <STRONG>rcombo.hpp</STRONG> in the directory
libs/sequence_algo. They are members of the boost namespace. The file itself
uses a function from the boost library, so make sure that the Boost directory
is in your header include path. See the example programs listed in the section
below.
<P>
Items in input sequences must either work with the built-in less than (&lt;)
operator, have a less than operator defined, or have a user-defined binary
comparison operation provided at the call.
<P>
Like the STL's permutation algorithms, input to these functions should be
in lexicographical order (based on the less than operator) on the first call.
<P>
The input must define a strick weak ordering <A href="#Musser">[3]</A>.
<P>
<STRONG><A name="next_r_permutation">next_r_permutation</A></STRONG> - arranges
the elements in [first, r), from the larger range [first, last) where first
&lt; r &lt;= last, such that they represent the next r-permutation of elements
in lexicographical order. When calling the function for the first time, the
elements in [first, last) must be in ascending lexicographical order. Typically,
when the function is called it arranges the next r-permutation in [first,
r) and returns true. When the last permutation in lexicographical order is
passed in, the function sorts the entire range, [first, last) into ascending
order, restarting the sequence, and returns false.
<PRE>
template&lt;class RandomAccessIterator&gt;
bool
next_r_permutation(RandomAccessIterator first, RandomAccessIterator r,
    RandomAccessIterator last)

template&lt;class RandomAccessIterator, class Compare&gt;
bool
next_r_permutation(RandomAccessIterator first, RandomAccessIterator r,
    RandomAccessIterator last, Compare comp)
</PRE>
<P>
<STRONG><A name="prev_r_permutation">prev_r_permutation</A></STRONG> - arranges
the elements in [first, r), from the larger range [first, last) where first
&lt; r &lt;= last, such that they represent the previous r-permutation of
elements in lexicographical order. When calling the function for the first
time, the elements in [first, last) must be in descending lexicographical
order. Typically, when the function is called it arranges the previous
r-permutation in [first, r) and returns true. When the first permutation
in lexicographical order is passed in, the function sorts the entire range,
[first, last) into descending order, restarting the sequence at the end,
and returns false.
<PRE>
template&lt;class RandomAccessIterator&gt;
bool
prev_r_permutation(RandomAccessIterator first, RandomAccessIterator r,
    RandomAccessIterator last)

template&lt;class RandomAccessIterator, class Compare&gt;
bool
prev_r_permutation(RandomAccessIterator first, RandomAccessIterator r,
    RandomAccessIterator last, Compare comp)
</PRE>
<P>
<STRONG><A name="next_r_combination">next_r_combination</A></STRONG> - arranges
the elements in [first, r), from the larger range [first, last) where first
&lt; r &lt;= last, such that they represent the next r-combination of elements
in lexicographical order. The elements in [first, last) must be in ascending
lexicographical order. When the function is called and a next combination
exists, it arranges the next r-combination in [first, r) and returns true.
If the next combination does not exist, the function sorts the entire range,
[first, last) into ascending order, restarting the sequence, and returns
false.
<PRE>
template&lt;class RandomAccessIterator&gt;
bool
next_r_combination(RandomAccessIterator first, RandomAccessIterator r,
    RandomAccessIterator last)

template&lt;class RandomAccessIterator, class Compare&gt;
bool
next_r_combination(RandomAccessIterator first, RandomAccessIterator r,
    RandomAccessIterator last, Compare comp)
</PRE>
<P>
<STRONG><A name="prev_r_combination">prev_r_combination</A></STRONG> - arranges
the elements in [first, r), from the larger range [first, last) where first
&lt; r &lt;= last, such that they represent the previous r-combination of
elements in lexicographical order. The elements in [first, last) must be
in ascending lexicographical order. When the function is called and a prior
combination exists, it arranges the previous r-combination in [first, r)
and returns true. If the prior combination does not exist, the function arranges
the sequence [first, last) into the last r-combination,thus restarting the
sequence at the end, and returns false.
<PRE>
template&lt;class RandomAccessIterator&gt;
bool
prev_r_combination(RandomAccessIterator first, RandomAccessIterator r,
    RandomAccessIterator last)

template&lt;class RandomAccessIterator, class Compare&gt;
bool
prev_r_combination(RandomAccessIterator first, RandomAccessIterator r,
    RandomAccessIterator last, Compare comp)
</PRE>
<H4>
  -- Support Functions --
</H4>
<P>
<STRONG>in_order</STRONG> - returns true if [first, last) is in sorted order,
based on the less than operator or the compare operator.
<PRE>
template&lt;class ForwardIterator&gt;
bool
in_order(ForwardIterator first, ForwardIterator last)

template&lt;class ForwardIterator, class Compare&gt;
bool
in_order(ForwardIterator first, ForwardIterator last, Compare comp)
</PRE>
<P>
<STRONG>smallest_greater</STRONG> - returns an iterator pointing to the smallest
value in [first, last) greater than x. last is returned if value is not found.
Time complexity is linear, O((last-first)/2) assignments in average case.
<PRE>
template&lt;class ForwardIterator, class T&gt;
ForwardIterator
smallest_greater(ForwardIterator first, ForwardIterator last,
    const T&amp; x)

template&lt;class ForwardIterator, class T, class Compare&gt;
ForwardIterator
smallest_greater(ForwardIterator first, ForwardIterator last,
    const T&amp; x, Compare comp)
</PRE>
<P>
<STRONG>largest_less</STRONG> - returns an iterator pointing to the largest
object in [first, last) less than x. last is returned if the value doesn't
exist.
<PRE>
template&lt;class ForwardIterator, class T&gt;
ForwardIterator
largest_less(ForwardIterator first, ForwardIterator last, const T&amp; x)

template&lt;class ForwardIterator, class T, class Compare&gt;
ForwardIterator
largest_less(ForwardIterator first, ForwardIterator last,
    const T&amp; x, Compare comp)
</PRE>
<H3>
  <A name="Performance">Performance</A>
</H3>
<P>
Each permutation or combination function performs (r - first)/2 swaps on
average. (To be verified.)
<H3>
  <A name="Examples">Examples and Test Programs</A>
</H3>
<P>
Both of the following test programs include rcombo.hpp, headers from the
C++ standard library, and Boost. Make sure these files are in your include
paths. Then just compile and link the single source file.
<DL>
  <DT>
    <STRONG>rcombo.cpp</STRONG>
  <DD>
    This is a console I/O program presents a menu that lets you exercise each
    of the functions. It is in the sequence_algo/test subdirectory.
  <DT>
    <STRONG>rcomboex.cpp</STRONG>
  <DD>
    This console I/O program solves a puzzle from a recent "Ask Marilyn" column
    in Parade magazine using next_r_permutation. It reads in the dictionary file
    lexicon.txt. You'll find these two files in the sequence_algo/example
    subdirectory.
</DL>
<H3>
  <A name="References">References</A>
</H3>
<OL>
  <LI>
    <A name="Johnsonbaugh">Johnsonbaugh</A>, Richard. <CITE>Discrete Math</CITE>.
    2nd ed. New York: Macmillan, 1990.
  <LI>
    Lippman, Stanley B. and Jos&eacute;e Lajoie. <CITE>C++ Primer</CITE>. 3rd
    ed. Reading, MA: Addison-Wesley-AT&amp;T, 1998.
  <LI>
    <A name="Musser">Musser</A>, David R. and Atul Saini. <CITE>STL Tutorial
    and Reference Guide: C++ Programming with the Standard Template Library</CITE>.
    Reading, MA: Addison-Wesley-Modena Software, 1996.
  <LI>
    Sedgewick, Robert. <CITE>Algorithms</CITE>. 2nd ed. Reading, MA: Addison-Wesley,
    1988.
  <LI>
    Stepanov, Alexander and Meng Lee. <CITE>The Standard Template Library</CITE>.
    Palo Alto: Hewlett-Packard, 1995.
  <LI>
    Stroustrup, Bjarne. <CITE>The C++ Programming Language</CITE>. Special ed.
    Reading, MA: Addison-Wesley-AT&amp;T, 2000.
</OL>
<P>
  <HR size="2" width="100%">
<P>
Copyright &copy; Philip F. Garofalo 2002. All rights reserved.
<P>
Permission to copy, use, modify, sell and distribute this software is granted
provided this copyright notice appears in all copies. This software is provided
"as is" without express or implied warranty, and with no claim as to its
suitability for any purpose.
<P>
Updated on June 5, 2002
</BODY></HTML>
