<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title> Container Algortihms </title><meta http-equiv="Content-Type"content="text/html; charset=iso-8859-1"></head> <body><table  ><tr  ><td  ><img src="cboost.gif" width="100%" border="0"></td><td  ><h1  >Container Algorithms</h1></td></tr></table><ul  ><li  ><a href="#Introduction" >Introduction</a></li><li  ><a href="#Synopsis" >Synopsis</a></li><li  ><a href="#Portability" >Portability</a></li><li  ><a href="#References" >References</a></li></ul><hr size="1" ><h2  >Introduction</h2><a name="Introduction" ></a><p  >This library makes it possible to use all the standard 
                      algorithms with an  <a href="iterator_range.html" target="_self" >IteratorRange</a>  instead of a pair of iterators.
                      An  <a href="iterator_range.html" target="_self" >IteratorRange</a>  is any type from which is is possible
                      to extract a pair of iterators that defines a valid sequence. This
                      means that one can can use the library with standard containers, <code  >std::pair&lt;iterator,iterator&gt;</code> and builtin arrays in a 
                      uniform way.</p><p  >The magic that makes this possible are overloaded versions of the 
                     free-standing functions <code  >begin()</code> and <code  >end()</code> and the accompanying traits class <code  >iterator_range_traits&lt;&gt;</code> (see  <a href="iterator_range.html" target="_self" >IteratorRange</a> ).</p><p  >The iterator range algorithms has several advantages over
                     the normal algorithms:<ul  ><li  >Shorter and more comprehensible code</li><li  >Functional style programming is now possible</li><li  >Less error prone when using built-in arrays</li><li  >Container specialized algorithms are 
                                 called whenever possible</li></ul></p><p  >Below are given some small examples:<pre  >
       //
       // Example 1: basic iteration
       //
       
       std::vector&lt;int&gt; my_vector;
       int              my_array[size];
       std::pair&lt;iterator,iterator&gt; my_range;
       // ...
       
       // for_each( begin( my_vector ), end( my_vector ), print() );
       for_each( my_vector, print() );
       
       // for_each( begin( my_array ), end( my_array ), print() );
       for_each( my_array, print() );
       
       // for_each( begin( my_range ), end( my_range ), print() );
       for_each( my_range, print() );
       
       //
       // Example 2: functional style programming
       //            (courtesy of Aleksey Gurtovoy)
       //
       
       // std::pair&lt;record_iterator,record_iterator&gt; sel = selection();
       // std::pair&lt;record_iterator,record_iterator&gt; mismatching_part =
       // std::mismatch( sel.first, sel.second, old_selection.begin() );
       // std::vector&lt;record&gt; v( mismatching_part.first, mismatching_part.second );
       std::vector&lt;record&gt; v( mismatch( selection(), begin( old_selection ) ):

       //
       // Example 3: specialized algorithm called for std::map
       //
       
       std::map&lt;int,int&gt; my_map;
       std::vector&lt;int&gt;  my_vector;
       // ...
       
       // my_map.find( 4 );
       find( my_map, 4 );
       // find( begin( my_vector ), end( my_vector ), 4 );
       find( my_vector, 4 );
                          
                       </pre></p><hr size="1" ><h2  >Synopsis</h2><a name="Synopsis" ></a><pre  >
namespace boost 
{

/////////////////////////////////////////////////////////////////////////
// Nonmodifying Sequence Operations
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container, typename UnaryOperation &gt;
inline UnaryOperation 
for_each( Container& c, UnaryOperation fun );

template&lt; typename Container, typename UnaryOperation &gt;
inline UnaryOperation 
for_each( const Container& c, UnaryOperation fun );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator 
find( Container& c, const T& value );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator 
find( const Container& c, const T& value );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator 
find_if( Container& c, Predicate pred );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
find_if( const Container& c, Predicate pred );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
adjacent_find( Container& c );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
adjacent_find( const Container& c );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator 
adjacent_find( Container& c, BinaryPredicate pred );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator 
adjacent_find( const Container& c, BinaryPredicate pred );

template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator 
find_first_of( Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator 
find_first_of( const Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2, 
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator 
find_first_of( Container1& c1, const Container2& c2, 
               BinaryPredicate pred );
template&lt; typename Container1, typename Container2, 
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator 
find_first_of( const Container1& c1, const Container2& c2, 
               BinaryPredicate pred );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::difference_type
count( const Container& c, const T& value );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::difference_type
count_if( const Container& c, Predicate pred );

template&lt; typename Container, typename InputIterator &gt;
inline std::pair&lt; typename iterator_range_traits&lt;Container&gt;::iterator,
InputIterator &gt;
mismatch( Container& c, InputIterator first2 );

template&lt; typename Container, typename InputIterator &gt;
inline std::pair&lt; typename iterator_range_traits&lt;Container&gt;::const_iterator,
InputIterator &gt;
mismatch( const Container& c, InputIterator first2 );

template&lt; typename Container, typename InputIterator, 
typename BinaryPredicate &gt;
inline std::pair&lt; typename iterator_range_traits&lt;Container&gt;::iterator,
InputIterator &gt;
mismatch( Container& c, InputIterator first2, BinaryPredicate pred );

template&lt; typename Container, typename InputIterator, 
typename BinaryPredicate &gt;
inline std::pair&lt; typename iterator_range_traits&lt;Container&gt;::const_iterator, 
InputIterator &gt;
mismatch( const Container& c, InputIterator first2, 
          BinaryPredicate pred );

template&lt; typename Container, typename InputIterator &gt;
inline bool 
equal( const Container& c, InputIterator first2 );

template&lt; typename Container, typename InputIterator, 
typename BinaryPredicate &gt; 
inline bool 
equal( const Container& c, InputIterator first2, 
       BinaryPredicate pred );
template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator 
search( Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator 
search( const Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2,
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator
search( Container1& c1, const Container2& c2, BinaryPredicate pred );

template&lt; typename Container1, typename Container2,
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator
search( const Container1& c1, const Container2& c2, BinaryPredicate pred );

template&lt; typename Container, typename Integer, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator 
search_n( Container& c, Integer count, const T& value );

template&lt; typename Container, typename Integer, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator 
search_n( const Container& c, Integer count, const T& value );

template&lt; typename Container, typename Integer, 
typename T, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
search_n( Container& c, Integer count, const T& value,
          BinaryPredicate pred );
template&lt; typename Container, typename Integer, 
typename T, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
search_n( const Container& c, Integer count, const T& value,
          BinaryPredicate pred );

template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator 
find_end( Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator 
find_end( const Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2,
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator 
find_end( Container1& c1, const Container2& c2, BinaryPredicate pred );

template&lt; typename Container1, typename Container2,
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator 
find_end( const Container1& c1, const Container2& c2, 
          BinaryPredicate pred );

/////////////////////////////////////////////////////////////////////////
// Modifying Sequance Operations
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container, typename OutputIterator &gt;
inline OutputIterator
copy( const Container& c, OutputIterator result );

template&lt; typename Container, typename BidirectionalIterator &gt; 
inline BidirectionalIterator
copy_backward( const Container& c, BidirectionalIterator result ); 

template&lt; typename Container, typename ForwardIterator &gt;
inline ForwardIterator 
swap_ranges( Container& c, ForwardIterator first2 ); 

template&lt; typename Container, typename OutputIterator, 
typename UnaryOperation &gt; 
inline OutputIterator 
transform( const Container& c, OutputIterator result, 
           UnaryOperation fun );

template&lt; typename Container, typename InputIterator,
typename OutputIterator, typename BinaryOperation &gt;
inline OutputIterator
transform( const Container& c, InputIterator first2,
           OutputIterator result, BinaryOperation fun );

template&lt; typename Container, typename T &gt;
inline void
replace( Container& c, const T& what, const T& with_what );

template&lt; typename Container, typename Predicate , typename T &gt;
inline void
replace_if( Container& c, Predicate pred, const T& value );

template&lt; typename Container, typename OutputIterator, typename T &gt; 
inline OutputIterator
replace_copy( const Container& c, OutputIterator result, 
              const T& what, const T& with_what );

template&lt; typename Container, typename OutputIterator, 
typename Predicate, typename T &gt;
inline OutputIterator
replace_copy_if( const Container& c, OutputIterator result,
                 Predicate pred, const T& value );

template&lt; typename Container, typename T &gt;
inline void
fill( Container& c, const T& value );

template&lt; typename Container, typename Integer, typename T &gt;
inline void
fill_n( Container& c, Integer size, const T& value );

template&lt; typename Container, typename Generator &gt;
inline void
generate( Container& c, Generator gen );

template&lt; typename Container, typename Integer, typename Generator &gt;
void
generate_n( Container& c, Integer size, Generator gen );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
remove( Container& c, const T& what );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
remove_if( Container& c, Predicate pred );

template&lt; typename Container, typename OutputIterator, typename T &gt;
inline OutputIterator
remove_copy( const Container& c, OutputIterator result, const T& value );

template&lt; typename Container, typename OutputIterator, typename Predicate &gt;
inline OutputIterator
remove_copy_if( const Container& c, OutputIterator result, Predicate pred );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
unique( Container& c );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
unique( Container& c, BinaryPredicate pred );

template&lt; typename Container, typename OutputIterator &gt;
inline OutputIterator
unique_copy( const Container& c, OutputIterator result );

template&lt; typename Container, typename OutputIterator, 
typename BinaryPredicate &gt;
inline OutputIterator
unique_copy( const Container& c, OutputIterator result, 
             BinaryPredicate pred );

template&lt; typename Container &gt;
inline void
reverse( Container& c );

template&lt; typename Container, typename OutputIterator &gt;
inline OutputIterator
reverse_copy( const Container& c, OutputIterator result );

template&lt; typename Container &gt; 
inline void
rotate( Container& c, 
        typename iterator_range_traits&lt;Container&gt;::iterator middle );

template&lt; typename Container, typename ForwardIterator, 
typename OutputIterator &gt;
inline OutputIterator
rotate_copy( Container& c, ForwardIterator middle, OutputIterator result ); 

template&lt; typename Container, typename ForwardIterator, 
typename OutputIterator &gt;
inline OutputIterator
rotate_copy( const Container& c, ForwardIterator middle, 
             OutputIterator result ); 

template&lt; typename Container &gt;
inline void
random_shuffle( Container& c );

template&lt; typename Container, typename Generator &gt;
inline void
random_shuffle( Container& c, Generator gen );

/////////////////////////////////////////////////////////////////////////
// Sorted Sequences
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container &gt;
inline void
sort( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
sort( Container& c, Compare comp );

template&lt; typename Container &gt;
inline void
stable_sort( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
stable_sort( Container& c, Compare comp );

template&lt; typename Container, typename RandomAccessIterator &gt;
inline void
partial_sort( Container& c, RandomAccessIterator middle );

template&lt; typename Container, typename RandomAccessIterator, 
typename Compare &gt;
inline void
partial_sort( Container& c, RandomAccessIterator middle,
              Compare comp );

template&lt; typename Container1, typename InputIterator &gt;
inline typename iterator_range_traits&lt;InputIterator&gt;::iterator
partial_sort_copy( const Container1& c1, InputIterator& c2 );

template&lt; typename Container1, typename InputIterator, typename Compare &gt;
inline typename iterator_range_traits&lt;InputIterator&gt;::iterator
partial_sort_copy( const Container1& c1, InputIterator& c2, Compare comp );

template&lt; typename Container &gt;
inline void
nth_element( Container& c, 
             typename iterator_range_traits&lt;Container&gt;::iterator nth );
template&lt; typename Container, typename Compare &gt;
inline void
nth_element( Container& c, 
             typename iterator_range_traits&lt;Container&gt;::iterator nth, 
             Compare comp );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
lower_bound( Container& c, const T& value );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
lower_bound( const Container& c, const T& value );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
lower_bound( Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
lower_bound( const Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
upper_bound( Container& c, const T& value );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
upper_bound( const Container& c, const T& value );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
upper_bound( Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
upper_bound( const Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T &gt;
inline typename pair_return&lt;Container,Container&gt;::mutable_pair 
equal_range( Container& c, const T& value );

template&lt; typename Container, typename T &gt;
inline typename pair_return&lt;Container,Container&gt;::const_pair 
equal_range( const Container& c, const T& value );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename pair_return&lt;Container,Container&gt;::mutable_pair
equal_range( Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename pair_return&lt;Container,Container&gt;::const_pair
equal_range( const Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T &gt;
inline bool
binary_search( const Container& c, const T& value );


template&lt; typename Container, typename T, typename Compare &gt;
inline bool
binary_search_( const Container& c, const T& value, Compare comp );

template&lt; typename Container1, typename Container2, typename Container3 &gt; 
inline typename iterator_range_traits&lt;Container3&gt;::iterator
merge( const Container1& c1, const Container2& c2, Container3& c3 );

template&lt; typename Container1, typename Container2, typename Container3, 
typename Compare &gt;
inline typename iterator_range_traits&lt;Container3&gt;::iterator
merge( const Container1& c1, const Container2& c2, Container3& c3,
       Compare comp );

template&lt; typename Container &gt;
inline void
inplace_merge( Container& c, 
               typename iterator_range_traits&lt;Container&gt;::iterator middle );

template&lt; typename Container, typename Compare &gt;
inline void
inplace_merge_( Container& c,
                typename iterator_range_traits&lt;Container&gt;::iterator middle, 
                Compare comp );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
partition( Container& c, Predicate pred );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
stable_partition( Container& c, Predicate pred );

/////////////////////////////////////////////////////////////////////////
// Set Algorithms
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container1, typename Container2 &gt;
inline bool 
includes( const Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2, typename Compare &gt;
inline bool 
includes( const Container1& c1, const Container2& c2, Compare comp );

template&lt; typename Container1, typename Container2, 
typename OutputIterator &gt; 
inline OutputIterator
set_union( const Container1& c1, const Container2& c2, 
           OutputIterator result );

template&lt; typename Container1, typename Container2, 
typename OutputIterator, typename Compare &gt;
inline OutputIterator
set_union( const Container1& c1, const Container2& c2,
           OutputIterator result, Compare comp );

template&lt; typename Container1, typename Container2, 
typename OutputIterator &gt; 
inline OutputIterator
set_intersection( const Container1& c1, const Container2& c2, 
                  OutputIterator result );

template&lt; typename Container1, typename Container2, 
typename OutputIterator, typename Compare &gt; 
inline OutputIterator
set_intersection( const Container1& c1, const Container2& c2, 
                  OutputIterator result, Compare comp );

template&lt; typename Container1, typename Container2, 
typename OutputIterator &gt; 
inline OutputIterator
set_difference( const Container1& c1, const Container2& c2,  
                OutputIterator result );

template&lt; typename Container1, typename Container2, 
typename OutputIterator, typename Compare &gt;
inline OutputIterator
set_difference( const Container1& c1, const Container2& c2,  
                OutputIterator result, Compare comp );

template&lt; typename Container1, typename Container2, 
typename OutputIterator &gt;
inline OutputIterator
set_symmetric_difference( const Container1& c1, const Container2& c2,
                          OutputIterator result );

template&lt; typename Container1, typename Container2, 
typename OutputIterator, typename Compare &gt;
inline OutputIterator
set_symmetric_difference( const Container1& c1, const Container2& c2,
                          OutputIterator result, Compare comp );

///////////////////////////////////////////////////////////////////////////
// Heap Operations
///////////////////////////////////////////////////////////////////////////

template&lt; typename Container &gt;
inline void 
push_heap( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
push_heap( Container& c, Compare comp );

template&lt; typename Container &gt;
inline void 
pop_heap( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
pop_heap( Container& c, Compare comp );

template&lt; typename Container &gt;
inline void 
make_heap( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
make_heap( Container& c, Compare comp );

template&lt; typename Container &gt;
inline void 
sort_heap( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
sort_heap( Container& c, Compare comp );

/////////////////////////////////////////////////////////////////////////
// Minimum and Maximum
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
min_element( Container& c );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
min_element( const Container& c );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
min_element( Container& c, BinaryPredicate pred );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
min_element( const Container& c, BinaryPredicate pred );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
max_element( Container& c );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
max_element( const Container& c );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
max_element( Container& c, BinaryPredicate pred );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
max_element( const Container& c, BinaryPredicate pred );

template&lt; typename Container1, typename Container2 &gt;
inline bool
lexicographical_compare( const Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2, 
typename BinaryPredicate &gt; 
inline bool
lexicographical_compare( const Container1& c1, const Container2& c2, 
                         BinaryPredicate pred );

/////////////////////////////////////////////////////////////////////////
// Permutations
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container &gt;
inline bool
next_permutation( Container& c );

template&lt; typename Container, typename Compare &gt;
inline bool
next_permutation( Container& c, Compare comp );

template&lt; typename Container &gt;
inline bool
prev_permutation( Container& c );

template&lt; typename Container, typename Compare &gt;
inline bool
prev_permutation( Container& c, Compare comp );

/////////////////////////////////////////////////////////////////////////
// Generalized Numeric Algorithms
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container, typename T &gt;
inline T
accumulate( const Container& c, T initial );

template&lt; typename Container, typename T, typename BinaryOperation &gt;
inline T
accumulate( const Container& c, const T initial, BinaryOperation fun );

template&lt; typename Container, typename InputIterator, typename T &gt;
inline T                            
inner_product( const Container& c, InputIterator first2,
               const T initial );

template&lt; typename Container, typename InputIterator, typename T,
typename BinaryOperation1, typename BinaryOperation2 &gt;
inline T                            
inner_product( const Container& c, InputIterator first2,
               const T initial, BinaryOperation1 fun1, 
               BinaryOperation2 fun2 );

template&lt; typename Container, typename OutputIterator &gt;
inline OutputIterator
partial_sum( const Container& c, OutputIterator result );

template&lt; typename Container, typename OutputIterator, 
typename BinaryOperation &gt; 
inline OutputIterator
partial_sum_( const Container& c, OutputIterator result, 
              BinaryOperation fun );

template&lt; typename Container, typename OutputIterator &gt;
inline OutputIterator
adjacent_difference( const Container& c, OutputIterator result );

template&lt;typename Container, typename OutputIterator, typename Predicate &gt;
inline OutputIterator
adjacent_difference( const Container& c, OutputIterator result, 
                     Predicate pred );

} // namespace 'boost' </pre><hr size="1" ><h2  >Portability</h2><a name="Portability" ></a><hr size="1" ><h2  >References</h2><a name="References" ></a></body></html>