<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title> Container Traits </title><meta http-equiv="Content-Type"content="text/html; charset=iso-8859-1"></head> <body><table  ><tr  ><td  ><img src="cboost.gif" width="100%" border="0"></td><td  ><h1  >Container Traits</h1></td></tr></table><ul  ><li  ><a href="#Introduction" >Introduction</a></li><li  ><a href="#Reference" >Reference</a></li><ul  ><li  ><a href="#Synopsis" >Synopsis</a></li><li  ><a href="#Semantics" >Semantics</a></li></ul><li  ><a href="#Examples" >Examples</a></li><li  ><a href="#Portability" >Portability</a></li><li  ><a href="#History and Acknowledgements" >History and Acknowledgements</a></li></ul><hr size="1" ><h2  >Introduction</h2><a name="Introduction" ></a><p  >This library makes it possible to treat different types as if they have 
                     implemented a subset of the container requirements 
                     (See &sect;23.1). The subset deals mostly with
                     iterator returning functions and nested <code  >typedef</code>s.
                     It therefore becomes possible to treat built-in arrays, standard containers,
                     pairs of iterators and some iterators uniformly.</p><p  >The main advantages are <ul  ><li  >safe use of built-in arrays</li><li  >simpler implementation of generic container algorithms</li><li  >more flexible client code</li></ul></p><p  >Below are given some small examples:<pre  >
       //
       // Example 1: extracting bounds of an array
       //
       int my_array[size] = { ... };
       // ...
       // for_each( my_array, my_array + size, print() );                 
       for_each( begin( my_array ), end( my_array ), print() );
                                  
       //
       // Example 2: extracting bound in generic container algorithms
       //                
       template&lt; typename Container, typename T &gt;
       inline typename container_traits&lt;Container&gt;::result_iterator 
       find( Container& c, const T& value )
       {
           return std::find( begin( c ), end( c ), value´);
       }
       // ...
       find( my_vector, 5 );
       find( my_array, 3 ); </pre>Note that by using the free-standing functions, the code in Example 1 still
         works if a <code  >my_array</code> is replaced with eg. a <code  >vector&lt;int&gt;.</code> In Example 2, the code automatically 
         works for all the types supported by this library. </p><hr size="1" ><h2  >Reference</h2><a name="Reference" ></a><code  >#include</code> <a href="container_traits.hpp" target="_self" ><code  >&lt;container_traits.hpp&gt;</code></a> <p  >Four types are currently supported by the library:<ul  ><li  >standard containers</li><li  >built-in arrays</li><li  ><code  >std::pair&lt;iterator,iterator&gt;</code></li><li  >iterators which when default constructed denotes the end of the range</li></ul>It is worth noticing that some functionality requires partial template specializtaion, in particular,
                    full array support does. Also note that arrays of <code  >char</code> or <code  >whar_t</code> are treated special because of their use in string algorithms. </p><h3  >Synopsis</h3><a name="Synopsis" ></a><p  ><pre>
    namespace boost 
    {
        template< typename Container >
        class container_traits
        {
        public:
            typedef ...  <a href="#value_type" >value_type</a> 
     	    typedef ...  <a href="#iterator" >iterator</a>;
    	    typedef ...  <a href="#const_iterator" >const_iterator</a>;
            typedef ...  <a href="#difference_type" >difference_type</a>;       	
    	    typedef ...  <a href="#size_type" >size_type</a>;
    	    typedef ...  <a href="#result_iterator" >result_iterator</a>; // follows constness of template argument
        }; 
        
        template< typename C >
        inline typename container_traits< C >::result_iterator
        <a href="#begin" >begin</a>( C& c );
    
        template< typename C >
        inline typename container_traits< C >::result_iterator
        <a href="#end" >end</a>( C& c );
                          
        template< typename C >
        inline bool
        <a href="#empty" >empty</a>( const C& c );
                         
        template< typename C >
        inline typename container_traits< C >::size_type
        <a href="#size" >size</a>( const C& c );
                      
        template< typename T, std::size_t sz >
        inline <b>implementation defined</b> 
        <a href="#sizer" >sizer</a>( const T (&array)[sz] ); // use: 'sizeof( sizer( my_array ) )'            

     } // namespace 'boost' </pre></p><br><h3  >Semantics</h3><a name="Semantics" ></a><p  >In the table <code  >C</code> is a container as defined above and <code  >c</code> is an object of that type.<code  > SC</code> will denote a standard
                  container, <code  > T[]</code> will denote an array of type <code  >T, </code><code  >P</code> will denote <code  >std::pair&lt;&gt;,</code><code  > I</code> means an iterator which default construction
                  denotes the end of the range and <code  >sc, t, p, i </code>are objects of these types, 
                  respectively </p><table border=1 width=100% cellpadding=5 > <tr  ><th  >Expression</th><th  >Return type</th><th  >Effects</th><th  >Complexity</th></tr><tr  ><a name="value_type" ></a><td  ><code  >container_traits&lt;C&gt;::value_type</code></td><td  ><code  >SC::value_type</code><br><code  >T</code><br><code  >std::iterator_traits&lt;P::first_type&gt;::value_type</code><br><code  >std::iterator_traits&lt;I&gt;::value_type</code></td><td  ><br></td><td  >compile time</td></tr><tr  ><a name="iterator" ></a><td  ><code  >container_traits&lt;C&gt;::iterator</code></td><td  ><code  >SC::iterator</code><br><code  >T*</code><br><code  >P::first_type</code><br><code  >I</code></td><td  ><br></td><td  >compile time</td></tr><tr  ><a name="const_iterator" ></a><td  ><code  >container_traits&lt;C&gt;::const_iterator</code></td><td  ><code  >SC::const_iterator</code><br><code  >const T*</code><br><code  >P::first_type</code><br><code  >I</code></td><td  ><br></td><td  >compile time</td></tr><tr  ><a name="difference_type" ></a><td  ><code  >container_traits&lt;C&gt;::difference_type</code></td><td  ><code  >SC::difference_type</code><br><code  >std::size_t</code><br><code  >std::iterator_traits&lt;P::first_type&gt;::difference_type</code><br><code  >std::iterator_traits&lt;I&gt;::difference_type</code></td><td  ><br></td><td  >compile time</td></tr><tr  ><a name="result_iterator" ></a><td  ><code  >container_traits&lt;C&gt;::result_iterator</code></td><td  ><code  >container_traits&lt;C&gt;::const_iterator</code> if <code  >C</code> is <code  >const</code><br><code  >container_traits&lt;C&gt;::iterator</code> otherwise </td><td  ><br></td><td  >compile time</td></tr><tr  ><a name="size_type" ></a><td  ><code  >container_traits&lt;C&gt;::size_type</code></td><td  ><code  >SC::size_type</code><br><code  >std::size_t</code><br><code  >std::size_t</code><br><code  >std::size_t</code></td><td  ><br></td><td  >compile time</td></tr><tr  ><a name="begin" ></a><td  ><code  >begin( c )</code></td><td  ><code  >container_traits&lt;C&gt;::result_iterator</code></td><td  ><code  >sc.begin()</code><br><code  >&t[0]</code><br><code  >p.first</code><br><code  >i</code></td><td  >constant time</td></tr><tr  ><a name="end" ></a><td  ><code  >end( c )</code></td><td  ><code  >container_traits&lt;C&gt;::result_iterator</code></td><td  ><code  >sc.end()</code><br><code  >begin( t ) + size( t )</code><br><code  >p.second</code><br><code  >I()</code></td><td  >linear if <code  >C</code> is <code  >char[]</code> or <code  >wchar_t[]</code><br>constant time otherwise</td></tr><tr  ><a name="empty" ></a><td  ><code  >empty( c )</code></td><td  ><code  >bool</code></td><td  ><code  >sc.empty()</code><br><code  >size( t ) == 0</code><br><code  >p.first == p.second</code><br><code  >begin( i ) == end( i )</code></td><td  >linear if <code  >C</code> is <code  >char[]</code> or <code  >wchar_t[]</code><br>constant time otherwise</td></tr><tr  ><a name="size" ></a><td  ><code  >size( c )</code></td><td  ><code  >container_traits&lt;C&gt;::size_type</code></td><td  ><code  >sc.size()</code><br><code  >std::strlen( t )</code> if <code  >C</code> is <code  >char[]</code><br><code  >std::wcstrlen( t )</code> if <code  >C</code> is <code  >wchar_t[]</code><br><code  >array_size&lt;T[]&gt;::value</code> otherwise <br><code  >distance( p.first, p.second )</code><br><code  >not available for iterators</code></td><td  >linear if <code  >C</code> is <code  >char[]</code> or <code  >wchar_t[]</code><br> or if <code  >distance()</code> is linear <br>constant time otherwise</td></tr><tr  ><a name="sizer" ></a><td  ><code  >sizeof( sizer( t ) )</code></td><td  ><code  >std::size_t</code></td><td  >returns the size of the array</td><td  >compile time</td></tr> </table><br><hr size="1" ><h2  >Examples</h2><a name="Examples" ></a><p  >four small complete examples</p><hr size="1" ><h2  >Portability</h2><a name="Portability" ></a><hr size="1" ><h2  >History and Acknowledgements</h2><a name="History and Acknowledgements" ></a><p  >The library have been under way for a long time. Dietmar Kühl originally
     submitted an <code  >array_traits</code> template which had most 
     of the functionality present now, but only for arrays. Meanwhile work on container algorithms
     in various context showed the need for handling pairs of iterators, and 
     string libraries needed special treatment of character arrays. 
     Thorsten Ottosen wrote everything from the ground up including the first
     work-around for missing partial template specialization. Pavol Dropa
     improved the work-around and added the special character support.</p><hr size="1" ><p  >&copy; Thorsten Ottosen 2003 (nesotto@cs.auc.dk).
    Permission to copy, use, modify, sell and distribute this software is granted provided this copyright notice appears
     in all copies. This software is provided "as is" without express or implied warranty, and with no
         claim as to its suitability for any purpose.</p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></body></html>