<?xml version = "1.0" encoding = "UTF-8"?>
<!--
(C) Copyright 2003-2004: Reece H. Dunn 
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-->

<section id = "outfmt.intro"><title>Introduction</title>
   <para>
      The C++ standard library provides input/output facilities via streams with a
      mechanism for extending it to support your own types; the standard library
      does this for <code>std::complex</code>, for instance. The Standard Template
      Library (STL) provides a mechanism for storing collections of objects, but
      does not provide I/O support via streams.
   </para><para>
      The lack of stream support on STL containers creates a gap that needs to be
      filled. There is a valid reason for not providing such a facility as part of
      the standard library: how should the container be rendered? There is no good
      default way for doing this. Different applications want different ways for
      the list to be represented. Is it possible to configure how the list is formatted?
      What about nested constructs, <code>std::pair</code>, arrays and other complex
      constructs?
   </para><para>
      The outfmt library is an attempt to solve the problems outlined above, providing
      an extensible framework that sits between containers and the I/O stream library,
      for example:
   </para>
   <programlisting>
   #include &lt;boost/outfmt/stl/vector.hpp&gt;
   std::vector&lt; int &gt; vec; // = { 1, 2, 3 };

   std::cout &lt;&lt; boost::io::formatob( vec );
   // output: [ 1, 2, 3 ]
   std::cout &lt;&lt; boost::io::formatob( vec ).format( "{ ", " }" );
   // output: { 1 : 2 : 3 }</programlisting>
   <para>
      The library supports input as well as output of sequential types. The syntax is
      exactly the same, for example:
   </para>
   <programlisting>
   #include &lt;boost/outfmt/stl/vector.hpp&gt;
   std::vector&lt; int &gt; vec;

   std::cin &gt;&gt; boost::io::formatob( vec1 )
            &gt;&gt; boost::io::formatob( vec2 ).format( "{ ", " }" );</programlisting>

   <para>
      Here, <code>boost::io::formatob</code> is a
      <link linkend = "outfmt.manipulators">manipulator</link> that is responsible for
      controlling the input/output of an object from/to a standard stream. It uses
      automatic type deduction to evaluate <code>vec</code>'s type and uses that
      information to construct the appropriate
      <link linkend = "outfmt.fmtobj">format object</link>. The format object will
      perform the reading/writing of the type from/to the stream. Both manipulators
      and format objects use
      <link linkend = "outfmt.delimeters">delimeters and formatters</link>
      to control how the sequential type is rendered.
   </para><para>
      The program file <ulink url = "../../example/basic-facilities.cpp">libs/outfmt/example/basic-facilities.cpp</ulink>
      contains more examples.
   </para>

   <section id = "outfmt.stlio"><title>STL IO</title>
      <para>
         The I/O formatting library provides a mechanism for rendering sequential types
         using manipulators and is described in more depth in later sections. As well
         as this, it provides inserters and extractors for the STL types listed in the
         following table:
      </para>
      <table><title>STL Types</title><tgroup cols = "2">
         <thead><row>
            <entry>Include File</entry>
            <entry>Supported Type</entry>
         </row></thead><tbody>
            <row><entry>boost/outfmt/stl/deque.hpp</entry>   <entry>std::deque</entry></row>
            <row><entry>boost/outfmt/stl/hash_map.hpp</entry><entry>ext::hash_map; ext::hash_multimap</entry></row>
            <row><entry>boost/outfmt/stl/hash_set.hpp</entry><entry>ext::hash_set; ext::hash_multiset</entry></row>
            <row><entry>boost/outfmt/stl/list.hpp</entry>    <entry>std::list</entry></row>
            <row><entry>boost/outfmt/stl/map.hpp</entry>     <entry>std::map; std::multimap</entry></row>
            <row><entry>boost/outfmt/stl/pair.hpp</entry>    <entry>std::pair</entry></row>
            <row><entry>boost/outfmt/stl/set.hpp</entry>     <entry>std::set; std::multiset</entry></row>
            <row><entry>boost/outfmt/stl/slist.hpp</entry>   <entry>ext::slist</entry></row>
            <row><entry>boost/outfmt/stl/vector.hpp</entry>  <entry>std::vector</entry></row>
         </tbody>
      </tgroup></table>
      <para>
         You can use the STL container types in an I/O expression like you would any other type,
         for example:
      </para>
      <programlisting>
   std::list&lt; int &gt; l;
   std::cin  &gt;&gt; l; // read in a list
   std::cout &lt;&lt; l; // format the list</programlisting>
      <para>
         Given the input <code>"[1, 2  , 3, 4 ]"</code>, the output will be:
      </para>
      <programlisting>[ 1, 2, 3, 4 ]</programlisting>
      <para>
         The above is the equivalent of:
      </para>
      <programlisting>
   std::cin  &gt;&gt; boost::io::formatob( l ); // read in a list
   std::cout &lt;&lt; boost::io::formatob( l ); // format the list</programlisting>
      <para>
         using the <code>boost::io::formatob</code> <link linkend = "outfmt.manip">manipulator</link>.
      </para><para>
         N-ary types (e.g. <code>std::pair</code>, <code>boost::rational</code>,
         <code>boost::math::quaternion</code>) are rendered using parenthesis instead
         of square brackets. See <ulink url = "../../example/stl_io.cpp">libs/outfmt/example/stl_io.cpp</ulink> for
         more examples.
      </para><para>
         The library also provides support for the following types, but does not define
         inserters and extractors for them since they are already defined elsewhere:
      </para>
      <table><title>Supported Types</title><tgroup cols = "2">
         <thead><row>
            <entry>Include File</entry>
            <entry>Supported Type</entry>
         </row></thead><tbody>
            <row><entry>boost/outfmt/stl/complex.hpp</entry>          <entry>std::complex</entry></row>
            <row><entry>boost/outfmt/boost/compressed_pair.hpp</entry><entry>boost::compressed_pair</entry></row>
            <row><entry>boost/outfmt/boost/interval.hpp</entry>       <entry>boost::numeric::interval</entry></row>
            <row><entry>boost/outfmt/boost/octonion.hpp</entry>       <entry>boost::math::octonion</entry></row>
            <row><entry>boost/outfmt/boost/quaternion.hpp</entry>     <entry>boost::math::quaternion</entry></row>
            <row><entry>boost/outfmt/boost/rational.hpp</entry>       <entry>boost::rational</entry></row>
         </tbody>
      </tgroup></table>
      <para>
         Examples of outputting these types can be found at
         <ulink url = "../../example/boost_output.cpp">libs/outfmt/example/boost_output.cpp</ulink>.
      </para>
   </section>
</section>
