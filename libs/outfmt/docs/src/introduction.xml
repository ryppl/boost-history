<?xml version = "1.0" encoding = "UTF-8"?>
<!--
(C) Copyright 2003-2004: Reece H. Dunn 
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-->

<section id = "outfmt.intro"><title>Introduction</title>
   <para>
      The C++ standard library provides input/output facilities via streams with a
      mechanism for extending it to support your own types; the standard library
      does this for <code>std::complex</code>, for instance. The Standard Template
      Library (STL) provides a mechanism for storing collections of objects, but
      does not provide I/O support via streams.
   </para><para>
      This lack of stream support seems to be a defect of STL design (and indeed it
      is), but there is a valid reason for not providing such a facility: how should
      the list be rendered? Different applications want different ways for the list
      to be represented. Is it possible to configure how the list is formatted?
      What about nested constructs, <code>std::pair</code>, arrays and other complex
      constructs?
   </para><para>
      The outfmt library is an attempt to solve the problems outlined above, providing
      an extensible framework that sits between containers and the I/O stream library,
      for example:
   </para>
   <programlisting>
   #include &lt;boost/outfmt/stl/vector.hpp&gt;
   std::vector&lt; int &gt; vec; // = { 1, 2, 3 };

   std::cout &lt;&lt; boost::io::formatob( vec );
   // output: [ 1, 2, 3 ]
   std::cout &lt;&lt; boost::io::formatob( vec ).format( "{ ", " }" );
   // output: { 1 : 2 : 3 }</programlisting>
   <para>
      The library supports input as well as output of sequential types. The syntax is
      exactly the same, for example:
   </para>
   <programlisting>
   #include &lt;boost/outfmt/stl/vector.hpp&gt;
   std::vector&lt; int &gt; vec;

   std::cin &gt;&gt; boost::io::formatob( vec )
            &gt;&gt; boost::io::formatob( vec ).format( "{ ", " }" );</programlisting>

   <para>
      Here, <code>boost::io::formatob</code> is a
      <link linkend = "outfmt.manipulators">manipulator</link> that is responsible for
      controlling the input/output of an object from/to a standard stream. It uses
      automatic type deduction to evaluate <code>vec</code>'s type and uses that
      information to construct the appropriate
      <link linkend = "outfmt.fmtobj">format object</link>. The format object will
      perform the reading/writing of the type from/to the stream. Both manipulators
      and format objects use
      <link linkend = "outfmt.delimeters">delimeters and formatters</link>
      to control how the sequential type is rendered.
   </para><para>
      The program file <ulink url = "../../example/basic-facilities.cpp">libs/outfmt/example/basic-facilities.cpp</ulink>
      contains more examples.
   </para>

   <section id = "outfmt.stlio"><title>STL IO</title>
      <para>
         The I/O formatting library provides a mechanism for rendering sequential types
         using manipulators and is described in more depth in later sections. As well
         as this, it provides inserters and extractors for the STL types listed in the
         following table:
      </para>
      <table><title>STL Types</title><tgroup cols = "2">
         <thead><row>
            <entry>Include File</entry>
            <entry>Supported Type</entry>
         </row></thead><tbody>
            <row><entry>boost/outfmt/stl/deque.hpp</entry>   <entry>std::deque</entry></row>
            <row><entry>boost/outfmt/stl/hash_map.hpp</entry><entry>ext::hash_map; ext::hash_multimap</entry></row>
            <row><entry>boost/outfmt/stl/hash_set.hpp</entry><entry>ext::hash_set; ext::hash_multiset</entry></row>
            <row><entry>boost/outfmt/stl/list.hpp</entry>    <entry>std::list</entry></row>
            <row><entry>boost/outfmt/stl/map.hpp</entry>     <entry>std::map; std::multimap</entry></row>
            <row><entry>boost/outfmt/stl/pair.hpp</entry>    <entry>std::pair</entry></row>
            <row><entry>boost/outfmt/stl/set.hpp</entry>     <entry>std::set; std::multiset</entry></row>
            <row><entry>boost/outfmt/stl/slist.hpp</entry>   <entry>ext::slist</entry></row>
            <row><entry>boost/outfmt/stl/vector.hpp</entry>  <entry>std::vector</entry></row>
         </tbody>
      </tgroup></table>
      <para>
         You can use the STL container types in an I/O expression like you would any other type,
         for example:
      </para>
      <programlisting>
   std::list&lt; int &gt; l;
   std::cin &gt;&gt; l; // read in a list
   std::cout &lt;&lt; l; // format the list</programlisting>
      <para>
         Given the input <code>"[1, 2  , 3, 4 ]"</code>, the output will be:
      </para>
      <programlisting>[ 1, 2, 3, 4 ]</programlisting>
      <para>
         N-ary types (e.g. <code>std::pair</code>, <code>boost::rational</code>,
         <code>boost::math::quaternion</code>) are rendered using parenthesis instead
         of square brackets. See <ulink url = "../../example/stl_io.cpp">libs/outfmt/example/stl_io.cpp</ulink> for
         more examples.
      </para><para>
         The library also provides support for the following types, but does not define
         inserters and extractors for them since they are already defined elsewhere:
      </para>
      <table><title>Supported Types</title><tgroup cols = "2">
         <thead><row>
            <entry>Include File</entry>
            <entry>Supported Type</entry>
         </row></thead><tbody>
            <row><entry>boost/outfmt/stl/complex.hpp</entry>          <entry>std::complex</entry></row>
            <row><entry>boost/outfmt/boost/compressed_pair.hpp</entry><entry>boost::compressed_pair</entry></row>
            <row><entry>boost/outfmt/boost/interval.hpp</entry>       <entry>boost::numeric::interval</entry></row>
            <row><entry>boost/outfmt/boost/octonion.hpp</entry>       <entry>boost::math::octonion</entry></row>
            <row><entry>boost/outfmt/boost/quaternion.hpp</entry>     <entry>boost::math::quaternion</entry></row>
            <row><entry>boost/outfmt/boost/rational.hpp</entry>       <entry>boost::rational</entry></row>
         </tbody>
      </tgroup></table>
      <para>
         Examples of outputting these types can be found at
         <ulink url = "../../example/boost_output.cpp">libs/outfmt/example/boost_output.cpp</ulink>.
      </para>
   </section>
</section>
