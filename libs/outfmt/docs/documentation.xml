<?xml version = "1.0" encoding = "UTF-8"?>
<?xml-stylesheet href = "http://mscl/xslt/docs/document.xsl" type = "text/xsl"?>

<d:document para-format = "none" hastoc = "display" title  = "Input/Output Formatters"
   xmlns:d = "http://www.softwave.net/XML/Document"
   xmlns   = "http://www.softwave.net/XML/HyperText"
   xmlns:c = "http://www.softwave.net/XML/CodeListing"
>
   <d:note>Save As: Web Page, HTML Only; encoding: Western European (ISO)</d:note>

   <d:copyright year = "2003-2004">
      <d:author name = "Reece H. Dunn" email = "msclrhd@hotmail.com"/>
   </d:copyright>

   <d:section title = "Introduction" id = "intro.intro">
      <d:section title = "The Problem" id = "intro.problem">
         <paragraph>
            The C++ Input/Output library provides a mechanism for customizing the way a class is represented
            on a linear text stream. There are output operations for the basic data types as well as for
            <code>std::complex</code> and other data types in the standard library.
         </paragraph><paragraph>
            Having said that, there are no output operations for any of the STL container types. There is a
            reason for this: how do we represent the list? Different applications would want different ways
            for the list to be represented, so there is no easy way to specify a default format. What if you
            need to output a sub-list? Or have the same format across different container types? Or have
            different formatting for different objects that have the same container type?
         </paragraph>
      </d:section><d:section title = "The Solution" id = "intro.solution">
         <paragraph>
            Designing a library that can cope with these problems, as well as others not considered here,
            while remaining efficient is no easy task. There are other attempts to solve these sorts of
            problems.
         </paragraph><paragraph>
            The motivation behind using manipulators is that they are already designed into the C++ I/O
            library and require little overhead in the input and output mechanism. They also give the user maximum
            choice in <i>how</i> the data being outputted is formatted.
         </paragraph>
      </d:section><d:section title = "Definitions" id = "intro.def">
         <d:section title = "ForwardIterator" id = "def.fwditer">
            <paragraph>
               A type indicating a forward iterator as defined by C++98, that supports the following
               operations:
               <table border = "1">
                  <tr><td><code>a != b</code></td><td>compare two iterators for inequality</td></tr>
                  <tr><td><code>++i</code>   </td><td>move to the next item               </td></tr>
                  <tr><td><code>*i</code>    </td><td>access the item data                </td></tr>
               </table>
            </paragraph>
         </d:section><d:section title = "Container" id = "def.container">
            <paragraph>
               A container type that has the following:
               <table border = "1">
                  <tr>
                     <th valign = "top">read or write?</th>
                     <th valign = "top">type or method</th>
                     <th valign = "top">effects</th>
                  </tr><tr>
                     <td valign = "top">output</td>
                     <td valign = "top"><code>typename Container::iterator</code></td>
                     <td valign = "top">an iterator that is a ForwardIterator type</td>
                  </tr><tr>
                     <td valign = "top">output</td>
                     <td valign = "top"><code>typename Container::iterator Container::begin()</code></td>
                     <td valign = "top">returns the first element in the container</td>
                  </tr><tr>
                     <td valign = "top">output</td>
                     <td valign = "top"><code>typename Container::iterator Container::end()</code></td>
                     <td valign = "top">returns "one-past-the-end" for the container type</td>
                  </tr><tr>
                     <td valign = "top">sequential container input</td>
                     <td valign = "top"><code>void Container::clear()</code></td>
                     <td valign = "top">remove all data in the container</td>
                  </tr><tr>
                     <td valign = "top">sequential container input</td>
                     <td valign = "top"><code>void Container::push_back( const T &amp; value )</code></td>
                     <td valign = "top">adds value to the end of the container</td>
                  </tr>
               </table>
            </paragraph>
         </d:section><d:section title = "Output Facilities" id = "def.output">
            <paragraph>
               The type is capable of being outputted to a standard ostream. It supports:
               <c:code indent = "true">
                  <c:line>std::basic_ostream&lt; CharT, Traits &gt; &amp; operator&lt;&lt;</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>std::basic_ostream&lt; CharT, Traits &gt; &amp; os,</c:line>
                     <c:line>const T &amp; type</c:line>
                  </c:block>
               </c:code>
            </paragraph>
         </d:section><d:section title = "Input Facilities" id = "def.input">
            <paragraph>
               The type is capable of being inputted from a standard istream. It supports:
               <c:code indent = "true">
                  <c:line>std::basic_istream&lt; CharT, Traits &gt; &amp; operator&gt;&gt;</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>std::basic_istream&lt; CharT, Traits &gt; &amp; is,</c:line>
                     <c:line>T &amp; type</c:line>
                  </c:block>
               </c:code>
            </paragraph>
         </d:section><d:section title = "Markers" id = "def.markers">
            <paragraph>
               A sequence of characters used between data items. There are three markers
               currently used by this library: open sequence; close sequence; and separator. 
            </paragraph>
         </d:section><d:section title = "FormatType" id = "def.fmttype">
            <paragraph>
               This is the type that the markers take. They can be: <code>char</code>,
               <code>wchar_t</code>, <code>char *</code>, <code>wchar_t *</code> or
               one of the <code>std::basic_string</code> variants. It is possible to
               add support for other format types.
            </paragraph>
         </d:section>
      </d:section><d:section title = "Portability" id = "intro.portability">
         <paragraph>
            The code has been succesfully tested on:
            <list>
               <li>
                  MS VC++ 6.0, 7.0 and 7.1
                  <note>
                     C-style arrays are only supported within type deduction for MS VC 7.1.
                  </note>
               </li>
               <li>Borland C++Compiler 5.5.1 and 5.6.4</li>
               <li>GNU G++ 3.x (under the i686-pc-cygwin environment)</li>
               <li>
                  GNU G++ 2.95.3-5 (under the i686-pc-cygwin environment)
                  <note>
                     Type deduction does not work, but the rest of the library does.
                  </note>
               </li>
               <li>Intel 7.1</li>
            </list>
         </paragraph><paragraph>
            Most of the code will now work on MSVC 6.0: thanks to Jonathan Turkanis for his
            help porting the code.
         </paragraph>
      </d:section>
   </d:section><d:section title = "Standard Container Input/Output" id = "io.stdcontainer">
      <paragraph><table cellpadding = "0">
         <tr><td>include:  </td><td><link href = "../../../boost/outfmt/stl_io.hpp">boost/outfmt/stl_io.hpp</link></td></tr>
         <tr><td>examples: </td><td><link href = "../examples/stl_io.cpp">libs/outfmt/examples/stl_io.cpp</link></td></tr>
      </table></paragraph>
      
      <paragraph>
         This is a helper file that provides input and output semantics for the
         standard library containers.
      </paragraph><example>
         <c:code indent = "true">
            <c:line>std::list&lt; char &gt; l;</c:line>
            <c:comment>...</c:comment>
            <c:line>std::cout &lt;&lt; l;
               <c:comment>output: [ A, B, C ]</c:comment>
            </c:line>
         </c:code>
      </example><example>
         <c:code indent = "true">
            <c:line>std::list&lt; char &gt; l;</c:line>
            <c:line>std::ifstream file( "data.txt" );</c:line>
            <c:comment>read in data of the form: [ a1, a2, ..., aN ]</c:comment>
            <c:line>file &gt;&gt; l;</c:line>
         </c:code>
      </example><paragraph>
         supported standard containers and types:
         <table border = "1">
            <tr>
               <td><code>std::pair     </code></td>
               <td><code>std::map      </code></td>
               <td><code>std::multimap </code></td>
            </tr><tr>
               <td><code>std::vector   </code></td>
               <td><code>std::set      </code></td>
               <td><code>std::multiset </code></td>
            </tr><tr>
               <td><code>std::list          </code></td>
               <td><code>std::hash_map      </code></td>
               <td><code>std::hash_multimap </code></td>
            </tr><tr>
               <td><code>std::slist         </code></td>
               <td><code>std::hash_set      </code></td>
               <td><code>std::hash_multiset </code></td>
            </tr><tr>
               <td><code>std::deque  </code></td>
            </tr>
         </table>
      </paragraph>
   </d:section><d:section title = "Input/Output Manipulators" id = "iomanip.iomanip">
      <d:section title = "Sequence Formatters" id = "iomanip.seqfmt">
         <paragraph><table cellpadding = "0">
            <tr><td>include:  </td><td><link href = "../../../boost/outfmt/formatlist.hpp">boost/outfmt/formatlist.hpp</link></td></tr>
            <tr><td>examples: </td><td><link href = "../examples/basic-facilities.cpp">libs/outfmt/examples/basic-facilities.cpp</link></td></tr>
         </table></paragraph>

         <d:section title = "boost::io::formatlist" id = "iomanip.formatlist">
            <c:code indent = "true">
               <c:line>boost::io::formatlist</c:line>
               <c:block open = "(" close = ");">
                  <c:line>ForwardIterator first,</c:line>
                  <c:line>ForwardIterator last</c:line>
               </c:block>
            </c:code><paragraph>
               This manipulator will format the list specified by the range
               [first, last). It requires that the elements contained in the
               sequence have <d:ref section = "def.output">Output Facilities</d:ref>.
            </paragraph><example>
               <c:code indent = "true">
                  <c:line>int i[ 4 ] = { 1, 2, 3, 4 };</c:line>
                  <c:line>std::cout &lt;&lt; boost::io::formatlist( i, i + 4 );
                     <c:comment>output: [ 1, 2, 3, 4 ]</c:comment>
                  </c:line>
               </c:code>
            </example><paragraph>
               The manipulator conforms to the format object generator guidelines in
               section <d:ref section = "fogen.requirements"/>.
            </paragraph>
         </d:section><d:section title = "boost::io::format" id = "iomanip.format">
            <c:code indent = "true">
               <c:line>boost::io::format</c:line>
               <c:block open = "(" close = ");">
                  <c:line>Container &amp; c</c:line>
               </c:block>
            </c:code><paragraph>
               This manipulator takes a sequential container as its argument. It
               outputs the range [begin(), end()), and requires that the elements
               in the sequence have <d:ref section = "def.output">Output Facilities</d:ref>.
            </paragraph><example>
               <c:code indent = "true">
                  <c:line>std::vector&lt; int &gt; v;</c:line>
                  <c:comment>...</c:comment>
                  <c:line>std::cout &lt;&lt; boost::io::format( v );
                     <c:comment>output: [ 3, 6, 9, 12 ]</c:comment>
                  </c:line>
               </c:code>
            </example><paragraph>
               The manipulator conforms to the format object generator guidelines
               in section <d:ref section = "fogen.requirements"/>.
            </paragraph>
         </d:section><d:section title = "boost::io::formatrange" id = "iomanip.formatrange">
            <c:code indent = "true">
               <c:line>boost::io::formatrange</c:line>
               <c:block open = "(" close = ");">
                  <c:line>std::pair&lt; ForwardIterator, ForwardIterator &gt; &amp; ip</c:line>
               </c:block>
            </c:code><paragraph>
               This manipulator takes an iterator range as its argument in the form
               of a pair of iterators. It outputs the range [ip.first, ip.second),
               and requires that the elements in the sequence have
               <d:ref section = "def.output">Output Facilities</d:ref>.
            </paragraph><example>
               <c:code indent = "true">
                  <c:line>int i[ 4 ] = { 1, 2, 3, 4 };</c:line>
                  <c:comment>construct an iterator range in a std::pair object</c:comment>
                  <c:line>std::pair&lt; int *, int * &gt; ip = std::make_pair( i, i + 2 );</c:line>
                  <c:line>std::cout &lt;&lt; boost::io::formatrange( ip );
                     <c:comment>output: [ 1, 2 ]</c:comment>
                  </c:line>
               </c:code>
            </example><paragraph>
               The manipulator conforms to the format object generator guidelines
               in section <d:ref section = "fogen.requirements"/>.
            </paragraph>
         </d:section>
      </d:section><d:section title = "boost::io::formatob" id = "iomanip.formatob">
         <paragraph><table cellpadding = "0">
            <tr><td>include: </td><td><link href = "../../../boost/outfmt/formatob.hpp">boost/outfmt/formatob.hpp</link></td></tr>
         </table></paragraph>

         <d:section title = "Form" id = "formatob.form">
            <c:code indent = "true">
               <c:line>boost::io::formatob</c:line>
               <c:block open = "(" close = ");">
                  <c:line>const T &amp; ob</c:line>
               </c:block>
            </c:code><paragraph>
               The manipulator conforms to the format object generator guidelines
               in section <d:ref section = "fogen.requirements"/>. It supports input
               and output semantics.
            </paragraph>
         </d:section><d:section title = "Automatic Type Deduction" id = "formatob.deduction">
            <paragraph><table cellpadding = "0">
               <tr>
                  <td rowspan = "2" valign = "top">examples: </td>
                  <td><link href = "../examples/output-2D.cpp">libs/outfmt/examples/output-2D.cpp</link></td>
               </tr><tr>
                  <td><link href = "../examples/output-3D.cpp">libs/outfmt/examples/output-3D.cpp</link></td>
               </tr>
            </table></paragraph>

            <paragraph>
               The library is capable of deducing the type being output, including
               complex nested types. The library uses this type information to
               produce a format object that can format that type.
            </paragraph><note>
               Type deduction is not present on <code>boost::io::formatob</code> when
               a format object is specified, since the format structure is provided by
               the user.
            </note>
         </d:section>
      </d:section>
   </d:section><d:section title = "Formatting Options" id = "fmt.fmt">
      <paragraph><table cellpadding = "0">
         <tr>
            <td rowspan = "2" valign = "top">examples: </td>
            <td><link href = "../examples/format-options.cpp">libs/outfmt/examples/format-options.cpp</link></td>
         </tr><tr>
            <td><link href = "../examples/formatter.cpp">libs/outfmt/examples/formatter.cpp</link></td>
         </tr>
      </table></paragraph>

      <paragraph>
         The formatting facilities are included indirectly when you include other
         files in the library. They are used in the implementation of the output
         facilities of the library, including <code>boost::io::formatlist</code>.
      </paragraph><paragraph>
         These facilities control what is output at the start of a sequence, as a
         separator between elements and at the end of the sequence.
      </paragraph>
      
      <d:section title = "Format Traits" id = "fmt.traits">
         <paragraph>
            The format traits contain the default values for pair types
            (<code>boost::io::detail::pair_traits</code>) and sequence types
            (<code>boost::io::detail::format_traits</code>). These have the
            following form:
         </paragraph><c:code indent = "true">
            <c:line>template&lt; typename CharT &gt;</c:line>
            <c:line>struct format_traits</c:line>
            <c:block open = "{" close = "};">
               <c:line>static const CharT open_default = <c:impl>implemenation defined</c:impl>;</c:line>
               <c:line>static const CharT close_default = <c:impl>implemenation defined</c:impl>;</c:line>
               <c:line>static const CharT separator_default = <c:impl>implemenation defined</c:impl>;</c:line>
            </c:block>
         </c:code><paragraph>
            <code>boost::io::detail::pair_traits</code> provides the default formatting:
            <c:code indent = "true"><c:line>( ..., ... )</c:line></c:code>
         </paragraph><paragraph>
            <code>boost::io::detail::format_traits</code> defaults the default formatting:
            <c:code indent = "true"><c:line>[ ..., ... ]</c:line></c:code>
         </paragraph><paragraph>
            Both are defined for <code>char</code>, <code>wchar_t</code>, <code>char *</code>
            and <code>wchar_t *</code>. If partial template specialisation is supported,
            it is also specialized for <code>std::basic_string</code>, otherwise
            <code>std::string</code> and <code>std::wstring</code> are supported.
         </paragraph>
      </d:section><d:section title = "Open/Close Formatter" id = "fmt.openclose">
         <d:section title = "boost::io::openclose_formatter_t" id = "openclose.class">
            <c:code indent = "true">
               <c:list>template</c:list>
               <c:block open = "&lt;" close = "&gt;">
                  <c:line>typename FormatType,</c:line>
                  <c:line>class ReferenceType,</c:line>
                  <c:line>class FormatTraits = boost::io::detail::format_traits&lt; FormatType &gt;</c:line>
               </c:block>
               <c:line>class openclose_formatter_t;</c:line>
            </c:code><paragraph>
               <code>boost::io::openclose_formatter_t</code> defines the formatting
               facilities for wrapping around a output type. It defines the following
               types:
               <table border = "1">
                  <tr>
                     <td valign = "top"><code>format_type</code></td>
                     <td>the character/string type used in the formatting</td>
                  </tr><tr>
                     <td valign = "top"><code>traits_type</code></td>
                     <td>a format traits class defined in section <d:ref section = "fmt.traits"/></td>
                  </tr>
               </table>
            </paragraph><paragraph>
               The ReferenceType parameter is used to specify the return type on the
               format( ... ) function, allowing further access to the derived object.
               This allows you to apply formatting onto a manipulator, like the example
               in section <d:ref section = "openclose.format"/>.
            </paragraph>
            <d:section title = "open" id = "openclose.open">
               <c:code indent = "true">
                  <c:line>typename openclose_formatter_t::format_type
                     openclose_formatter_t::open() const;
                  </c:line>
               </c:code><paragraph>
                  Returns the current value for the formatting at the start of the
                  output type.
               </paragraph>
            </d:section><d:section title = "close" id = "openclose.close">
               <c:code indent = "true">
                  <c:line>typename openclose_formatter_t::format_type
                     openclose_formatter_t::close() const;
                  </c:line>
               </c:code><paragraph>
                  Returns the current value for the formatting at the end of the output type.
               </paragraph>
            </d:section><d:section title = "format" id = "openclose.format">
               <c:code indent = "true">
                  <c:line>ReferenceType &amp; openclose_formatter_t::format</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>format_type o,</c:line>
                     <c:line>format_type c</c:line>
                  </c:block>
               </c:code><paragraph>
                  Sets the values for the opening and closing formatting.
               </paragraph><example>
                  <c:code indent = "true">
                     <c:line>std::vector&lt; int &gt; v;</c:line>
                     <c:comment>...</c:comment>
                     <c:line>std::cout &lt;&lt; boost::io::formatlist( v ).format( "[ ", " )" );
                        <c:comment>output: [ 3, 12 )</c:comment>
                     </c:line>
                  </c:code>
               </example>

               <c:code indent = "true">
                  <c:line>template&lt; typename RT2, class FormatTraits2 &gt;</c:line>
                  <c:line>ReferenceType &amp; openclose_formatter_t::format</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>const openclose_formatter_t&lt; FormatType, RT2, FormatTraits2 &gt; &amp; fmt</c:line>
                  </c:block>
               </c:code><paragraph>
                  Copies the values of the opening and closing formatting from one
                  formatter to another, requiring only that they have the same FormatType.
               </paragraph><paragraph>
                  See <d:ref section = "openclose.ocfmt"/> for an example of this.
               </paragraph>
            </d:section>
         </d:section><d:section title = "boost::io::openclose_formatter"  id = "openclose.ocfmt">
            <c:code indent = "true">
               <c:line>template</c:line>
               <c:block open = "&lt;" close = "&gt;">
                  <c:line>typename FormatType,</c:line>
                  <c:line>class FormatTraits = boost::io::detail::format_traits&lt; FormatType &gt;</c:line>
               </c:block>
               <c:line>class openclose_formatter;</c:line>
            </c:code><paragraph>
               <code>boost::io::openclose_formatter</code> is the usable end of
               this formatter. The user can create an object of this type, set
               special formatting to it, and then reuse it across different output
               operations.
            </paragraph><example>
               <c:code indent = "true">
                  <c:line>boost::io::openclose_formatter&lt; char * &gt; fmt( "| ", " |" );</c:line>
                  <c:line>int i[ 4 ] = { 1, 2, 3, 4 };</c:line>
                  <c:line>std::cout &lt;&lt; boost::io::formatlist( i, i + 2 ).format( fmt );
                     <c:comment>output: | 1, 2 |</c:comment>
                  </c:line>
               </c:code>
            </example>
            <d:section title = "Constructors" id = "openclose.cons">
               <c:code indent = "true"><c:line>openclose_formatter();</c:line></c:code>
               <paragraph>
                  Creates a <code>boost::io::openclose_formatter</code> object
                  with default formatting.
               </paragraph>

               <c:code indent = "true"><c:line>openclose_formatter( format_type o, format_type c );</c:line></c:code>
               <paragraph>
                  Creates a <code>boost::io::openclose_formatter</code> object
                  with custom formatting.
               </paragraph>

               <c:code indent = "true">
                  <c:line>template&lt; typename RT2, class FormatTraits2 &gt;</c:line>
                  <c:line>openclose_formatter</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>const openclose_formatter_t&lt; FormatType, RT2, FormatTraits2 &gt; &amp; fmt</c:line>
                  </c:block>
               </c:code>
               <paragraph>
                  Creates a <code>boost::io::openclose_formatter</code> object
                  with formatting inherited from <code>fmt</code>.
               </paragraph>
            </d:section>
         </d:section>
      </d:section><d:section title = "Formatter" id = "fmt.formatter">
         <d:section title = "boost::io::formatter_t" id = "formatter.class">
            <paragraph>
               <code>boost::io::formatter_t</code> inherits from
               <code>boost::io::openclose_formatter_t</code>, extending
               <code>boost::io::openclose_formatter_t</code>'s capabilities to
               include separators.
            </paragraph>
            <d:section title = "separator" id = "formatter.separator">
               <c:code indent = "true"><c:line>typename openclose_formatter_t::format_type
                  openclose_formatter_t::separator() const;</c:line>
               </c:code>
               <paragraph>
                  Returns the current value for the formatting inbetween items in
                  the sequence.
               </paragraph>
            </d:section><d:section title = "format" id = "formatter.format">
               <c:code indent = "true">
                  <c:line>ReferenceType &amp; formatter_t::format(
                     format_type o, format_type c, format_type s );</c:line>
               </c:code><paragraph>
                  Sets the values for the opening, closing and separator formatting.
               </paragraph>

               <c:code indent = "true">
                  <c:line>ReferenceType &amp; formatter_t::format(
                     format_type o, format_type c );</c:line>
               </c:code><paragraph>
                  Sets the values for the opening and closing formatting.
               </paragraph>

               <c:code indent = "true"><c:line>ReferenceType &amp; formatter_t::format( format_type s );</c:line></c:code>
               <paragraph>
                  Sets the value for the separator.
               </paragraph>

               <c:code indent = "true">
                  <c:line>template&lt; typename RT2, class FormatTraits2 &gt;</c:line>
                  <c:line>ReferenceType &amp; formatter_t::format</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>const openclose_formatter_t&lt; FormatType, RT2, FormatTraits2 &gt; &amp; fmt</c:line>
                  </c:block>
               </c:code><paragraph>
                  Copies the values of the opening and closing formatting from an
                  <code>openclose_formatter</code> to a formatter object, requiring
                  only that they have the same FormatType.
               </paragraph>

               <c:code indent = "true">
                  <c:line>template&lt; typename RT2, class FormatTraits2 &gt;</c:line>
                  <c:line>ReferenceType &amp; formatter_t::format</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>const formatter_t&lt; FormatType, RT2, FormatTraits2 &gt; &amp; fmt</c:line>
                  </c:block>
               </c:code><paragraph>
                  Copies the values of the opening, closing and separator
                  formatting from one formatter to another, requiring only
                  that they have the same FormatType.
               </paragraph>
            </d:section>
         </d:section><d:section title = "boost::io::formatter" id = "formatter.fmt">
            <paragraph>
               <code>boost::io::formatter</code> is the usable end of this
               formatter. The user can create an object of this type, set
               special formatting to it, and then reuse it across different
               output operations.
            </paragraph><example>
               <c:code indent = "true">
                  <c:line>boost::io::formatter&lt; char * &gt; fmt( "| ", " |", " : " );</c:line>
                  <c:line>int i[ 4 ] = { 1, 2, 3, 4 };</c:line>
                  <c:line>std::cout &lt;&lt; boost::io::formatlist( i, i + 2 ).format( fmt );
                     <c:comment>output: | 1 : 2 |</c:comment>
                  </c:line>
               </c:code>
            </example><d:section title = "Constructors" id = "formatter.cons">
               <c:code indent = "true"><c:line>formatter()</c:line></c:code>
               <paragraph>
                  Creates a <code>boost::io::formatter</code> object with default formatting.
               </paragraph>

               <c:code indent = "true">
                  <c:line>formatter</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>format_type o,</c:line>
                     <c:line>format_type c,</c:line>
                     <c:line>format_type s = traits_type::separator_default</c:line>
                  </c:block>
               </c:code><paragraph>
                  Creates a <code>boost::io::formatter</code> object with custom formatting.
               </paragraph>

               <c:code indent = "true"><c:line>formatter( format_type s )</c:line></c:code>
               <paragraph>
                  Creates a <code>boost::io::formatter</code> object with custom
                  formatting for the separator only.
               </paragraph>
               
               <c:code indent = "true">
                  <c:line>template&lt; typename RT2, class FormatTraits2 &gt;</c:line>
                  <c:line>formatter</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>const openclose_formatter_t&lt; FormatType, RT2, FormatTraits2 &gt; &amp; fmt,</c:line>
                     <c:line>format_type s = traits_type::separator_default</c:line>
                  </c:block>
               </c:code><paragraph>
                  Creates a <code>boost::io::formatter</code> object with formatting
                  inherited from fmt and providing optional separator formatting.
               </paragraph>

               <c:code indent = "true">
                  <c:line>template&lt; typename RT2, class FormatTraits2 &gt;</c:line>
                  <c:line>formatter</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>const formatter_t&lt; FormatType, RT2, FormatTraits2 &gt; &amp; fmt</c:line>
                  </c:block>
               </c:code><paragraph>
                  Creates a <code>boost::io::formatter</code> object with formatting
                  inherited from fmt.
               </paragraph>
            </d:section>
         </d:section>
      </d:section>
   </d:section><d:section title = "Format Objects" id = "fo.fo">
      <d:section title = "Requirements" id = "fo.requirements">
         <d:section title = "Output Facilities" id = "fo.output">
            <paragraph>
               A format object that is intending to provide output of a type to a stream
               must define a <code>write</code> function that accepts that type by defining:
            </paragraph>

            <c:code indent = "true">
               <c:line>template&lt; typename T, class OutputStream &gt;</c:line>
               <c:line>inline OutputStream &amp; write( OutputStream &amp; os, const T &amp; value ) const</c:line>
               <c:block open = "(" close = ");">
                  <c:comment>...</c:comment>
                  <c:line>return( os );</c:line>
               </c:block>
            </c:code>

            <paragraph>
               T is the type being outputted using this format object.
            </paragraph><note>
               The type T here is a standin for the actual type being used. For
               example, the format object can be implemented to accept
               <code>std::complex&lt; T &gt;</code>, allowing complex types to be
               formatted.
            </note><paragraph>
               OutputStream is the stream type. This is not
               <code>std::basic_ostream&lt; CharT, Traits &gt;</code> here to
               simplify the implementation of the operator (it is easier to type!).
               If you want to use <code>std::basic_ostream&lt; CharT, Traits &gt;</code>
               instead, you can, but this is not advised for compatibility with
               older libraries that do not support <code>std::basic_ostream</code>.
            </paragraph><paragraph>
               The operator is const because the format object is not modified. For
               state-based formatting that requires modification of the data,
               like position information, there is a special format object. See
               <link href = "../examples/john-torjo.cpp">libs/outfmt/examples/john-torjo.cpp</link>
               for an example of this.
            </paragraph>
         </d:section><d:section title = "Input Facilities" id = "fo.input">
            <paragraph>
               A format object that is intending to provide input of a type to a stream
               must define a <code>read</code> function that accepts that type by defining:
            </paragraph>

            <c:code indent = "true">
               <c:line>template&lt; typename T, class InputStream &gt;</c:line>
               <c:line>inline bool read( InputStream &amp; is, T &amp; value ) const</c:line>
               <c:block open = "(" close = ");">
                  <c:comment>...</c:comment>
                  <c:line>return( true );</c:line>
               </c:block>
            </c:code>

            <paragraph>
               Where <code>true</code> indicates a successful read operation and
               <code>false</code> indicates there was a problem.
            </paragraph>
         </d:section><d:section title = "Formatting" id = "fo.formatting">
            <paragraph>
               In order to be chained (when forming complex format objects for nested types),
               the format object must define the type <code>format_type</code> to be the
               string or character type to be used for markers.
            </paragraph><paragraph>
               In order to allow the user to customise the markers, a format object should
               inherit from a formatter. See section <d:ref section = "fmt.fmt"/> for more
               information on formatters.
               <note>
                  Formatters define the type <code>format_type</code>.
               </note>
            </paragraph>
         </d:section>
      </d:section><d:section title = "Simple Types" id = "fo.simple">
         <d:section title = "boost::io::basic_object" id = "fo.basic">
            <paragraph>
               <code>boost::io::basic_object</code> is used as a generic format object,
               providing no specific formatting.
            </paragraph>
         </d:section><d:section title = "boost::io::wrapped_object" id = "fo.wrapped">
            <paragraph>
               <code>boost::io::wrapped_object</code> inherits its formatting from
               <code>boost::io::openclose_formatter_t</code>, allowing specific
               formatting to be added around a type. This would be useful for things
               like formatting a complex type as XML data.
            </paragraph>
         </d:section>
      </d:section><d:section title = "N-ary Types" id = "fo.nary">
         <d:section title = "boost::io::pair_object" id = "fo.pair">
            <paragraph><table cellpadding = "0">
               <tr>
                  <td rowspan = "2" valign = "top">examples: </td>
                  <td><link href = "../examples/pair_output.cpp">libs/outfmt/examples/pair_output.cpp</link></td>
               </tr><tr>
                  <td><link href = "../examples/boost_output.cpp">libs/outfmt/examples/boost_output.cpp</link></td>
               </tr>
            </table></paragraph>

            <paragraph>
               <code>boost::io::pair_object</code> inherits its formatting from
               <code>boost::io::formatter_t</code>, providing input and output of
               <code>std::pair</code>, <code>std::complex</code>,
               <code>boost::numeric::interval</code>, <code>boost::rational</code>
               and <code>boost::compressed_pair</code> types.
            </paragraph>
         </d:section><d:section title = "boost::io::static_nary_object" id = "fo.static_nary">
            <paragraph><table cellpadding = "0">
               <tr>
                  <td>examples: </td>
                  <td><link href = "../examples/boost_output.cpp">libs/outfmt/examples/boost_output.cpp</link></td>
               </tr>
            </table></paragraph>

            <paragraph>
               <code>boost::io::static_nary_object</code> inherits its formatting
               from <code>boost::io::formatter_t</code>, providing input and output of
               <code>boost::math::quaternion</code> and
               <code>boost::math::octonion</code> types.
            </paragraph>
         </d:section><d:section title = "Adding Support For An N-Ary Type" id = "fo.nary-getput">
            <paragraph>
               [todo]
            </paragraph>
         </d:section>
      </d:section><d:section title = "Sequences" id = "fo.sequence">
         <d:section title = "boost::io::detail::list_object" id = "fo.list">
            <paragraph>
               <code>boost::io::detail::list_object</code> is a helper class,
               inheriting its formatting from <code>boost::io::formatter_t</code>.
               It is used to output sequential lists of the form [first, last).
            </paragraph><paragraph>
               <code>boost::io::detail::list_object</code> is not technically a format
               object, since it has the function operator:
            </paragraph>

            <c:code indent = "true">
               <c:line>template&lt; typename ForwardIterator, class OutputStream &gt;</c:line>
               <c:line>inline OutputStream &amp; operator()</c:line>
               <c:block open = "(" close = ");">
                  <c:line>OutputStream &amp; os,</c:line>
                  <c:line>ForwardIterator first,</c:line>
                  <c:line>ForwardIterator last</c:line>
               </c:block>
            </c:code>
            <paragraph>
               The class is used to help the implementations of
               <code>boost::io::array_object</code>, <code>boost::io::container_object</code>
               and <code>boost::io::range_object</code>.
            </paragraph>
         </d:section><d:section title = "boost::io::array_object" id = "fo.array">
            <paragraph><table cellpadding = "0">
               <tr>
                  <td rowspan = "2" valign = "top">examples: </td>
                  <td><link href = "../examples/output-2D.cpp">libs/outfmt/examples/output-2D.cpp</link></td>
               </tr><tr>
                  <td><link href = "../examples/output-3D.cpp">libs/outfmt/examples/output-3D.cpp</link></td>
               </tr>
            </table></paragraph>

            <paragraph>
               <code>boost::io::array_object</code> inherits its functionality from
               <code>boost::io::detail::list_object</code>, supporting the output of
               C-style arrays of the form <code>const T *</code>.
            </paragraph><paragraph>
               To facilitate the output of arrays, it defines two special function operators:
            </paragraph>

            <c:code indent = "true"><c:line>operator()( long len );</c:line></c:code>
            <paragraph>
               Specify the range [0, len) to be outputted.
            </paragraph>

            <c:code indent = "true"><c:line>operator()( long off, long len );</c:line></c:code>
            <paragraph>
               Specify the range [off, off + len) to be outputted.
            </paragraph>
         </d:section><d:section title = "boost::io::container_object" id = "fo.container">
            <paragraph><table cellpadding = "0">
               <tr>
                  <td rowspan = "2" valign = "top">examples: </td>
                  <td><link href = "../examples/output-2D.cpp">libs/outfmt/examples/output-2D.cpp</link></td>
               </tr>
            </table></paragraph>

            <paragraph>
               <code>boost::io::container_object</code> inherits its functionality
               from <code>boost::io::detail::list_object</code>, supporting the
               output of containers as defined in section <d:ref section = "def.container"/>.
            </paragraph>
         </d:section><d:section title = "boost::io::range_object" id = "fo.range">
            <paragraph>
               <code>boost::io::range_object</code> inherits its functionality
               from <code>boost::io::detail::list_object</code>, supporting the
               output of an iterator range. The iterator range is a pair of
               iterators are defined in section <d:ref section = "def.fwditer"/>.
            </paragraph><paragraph>
               This formatter allows ranges to be constructed from a container,
               a <code>std::pair</code>, a set of values and a C-style array
               through the use of the <code>boost::io::range</code> function.
            </paragraph><note>
               This is different from <code>boost::io::pair_object</code>, that
               formats the elements in the pair as the first and last elements
               in a list.
            </note>
         </d:section>
      </d:section><d:section title = "Input/Output Manipulators" id = "fo.iomanip">
         <d:section title = "boost::io::formatob_t" id = "fo.fmtob">
            <paragraph>
               <code>boost::io::formatob_t</code> is the class that is used to implement
               the <code>boost::io::formatob</code> manipulators. It is a hybrid between
               a format object and a manipulator, that inherits it's output capabilities
               from another format object. See section <d:ref section = "iomanip.formatob"/>
               for more details.
            </paragraph><paragraph>
               This is used to construct the <d:ref section = "iomanip.seqfmt">Sequence
               Formatters</d:ref>: they are really helper functions that represent a
               more complex format object.
            </paragraph>
         </d:section>
      </d:section><d:section title = "State Information" id = "fo.stateio">
         <paragraph><table cellpadding = "0">
            <tr>
               <td rowspan = "2" valign = "top">examples: </td>
               <td><link href = "../examples/john-torjo.cpp">libs/outfmt/examples/john-torjo.cpp</link></td>
            </tr>
         </table></paragraph>

         <d:section title = "boost::io::state_object" id = "fo.state">
            <paragraph>
               <code>boost::io::state_object</code> does not inherit from a formatter class,
               and as such is not a standard format object. It is a helper that will bind
               a state object and a format object without the need for casts in the user
               code (see the example for a demonstration of this).
            </paragraph>
            <d:section title = "State Objects" id = "state.ob">
               <paragraph>
                  A state object is a type of function object that has the form:
               </paragraph>

               <c:code indent = "true">
                  <c:line>template&lt; class OutputStream &gt;</c:line>
                  <c:line>inline OutputStream &amp; operator()</c:line>
                  <c:block open = "(" close = ");">
                     <c:line>OutputStream &amp; os</c:line>
                  </c:block>
               </c:code>

               <paragraph>
                  A state object should only output state information to the stream.
               </paragraph>
            </d:section>
         </d:section>
      </d:section>
   </d:section><d:section title = "Format Object Generators" id = "fogen.fogen">
      <d:section title = "Requirements" id = "fogen.requirements">
         <d:section title = "Default" id = "fogen.default">
            <paragraph>
               The default format object generator has the form:
               <c:code indent = "true">
                  <c:line>name()</c:line>
               </c:code>
               where <code>name</code> is the format object name for its generator,
               unless otherwise noted.
            </paragraph><paragraph>
               It uses the <code>char *</code> format type, and the default sub-element
               format object.
            </paragraph>
         </d:section><d:section title = "FormatType Specifier" id = "fogen.fmtspec">
            <paragraph>
               This format object generator has the form:
               <c:code indent = "true">
                  <c:line>nameex&lt; FormatType &gt;()</c:line>
               </c:code>
               where <code>name</code> is the format object name for its generator,
               unless otherwise noted.
            </paragraph><paragraph>
               It uses the format type specified by <code>FormatType</code>, and the
               default sub-element format object.
            </paragraph>
         </d:section><d:section title = "Format Object Specifier" id = "fogen.fospec">
            <paragraph>
               This format object generator has the form:
               <c:code indent = "true">
                  <c:line>name( const FormatObject &amp; )</c:line>
               </c:code>
               where <code>name</code> is the format object name for its generator,
               unless otherwise noted.
            </paragraph><paragraph>
               It uses the format type specified by <code>FormatObject::format_type</code>,
               and uses <code>FormatObject</code> to format its sub-elements.
            </paragraph>
         </d:section>
      </d:section><d:section title = "Simple Types" id = "fogen.simple">
         <d:section title = "boost::io::basicfmt" id = "fogen.basic">
            <paragraph>
               This generator function creates a <code>boost::io::basic_object</code>
               object. It does not meets the requirements specified in section
               <d:ref section = "fogen.requirements"/>: it does not have any variants.
            </paragraph>
         </d:section><d:section title = "boost::io::wrappedfmt" id = "fogen.wrapped">
            <paragraph>
               This generator function creates a <code>boost::io::wrapped_o</code>
               object. It meets the requirements specified in section
               <d:ref section = "fogen.requirements"/>.
            </paragraph>
         </d:section>
      </d:section><d:section title = "N-ary Types" id = "fogen.nary">
         <d:section title = "boost::io::pairfmt" id = "fogen.pair">
            <paragraph><table cellpadding = "0">
               <tr>
                  <td rowspan = "2" valign = "top">examples: </td>
                  <td><link href = "../examples/pair_output.cpp">libs/outfmt/examples/pair_output.cpp</link></td>
               </tr><tr>
                  <td><link href = "../examples/boost_output.cpp">libs/outfmt/examples/boost_output.cpp</link></td>
               </tr>
            </table></paragraph>

            <paragraph>
               This generator function creates a <code>boost::io::pair_object</code>
               object. It meets the requirements specified in section
               <d:ref section = "fogen.requirements"/>.
            </paragraph>

            <c:code indent = "true">
               <c:line>boost::io::pairfmt</c:line>
               <c:block open = "(" close = ");">
                  <c:line>const Outputter &amp; out</c:line>
               </c:block>
            </c:code>
            <paragraph>
               In this case, both types are outputted using the same format object.
            </paragraph>

            <c:code indent = "true">
               <c:line>boost::io::pairfmt</c:line>
               <c:block open = "(" close = ");">
                  <c:line>const Outputter1 &amp; out1,</c:line>
                  <c:line>const Outputter2 &amp; out2</c:line>
               </c:block>
            </c:code>

            <paragraph>
               In this case, each type is outputted using its own format object,
               allowing specialist formatting for each type.
            </paragraph>
         </d:section><d:section title = "boost::io::naryfmt" id = "fogen.static_nary">
            <paragraph><table cellpadding = "0">
               <tr>
                  <td>examples: </td>
                  <td><link href = "../examples/boost_output.cpp">libs/outfmt/examples/boost_output.cpp</link></td>
               </tr>
            </table></paragraph>

            <paragraph>
               This generator function creates a <code>boost::io::static_nary_object</code>
               object. It meets the requirements specified in section
               <d:ref section = "fogen.requirements"/>.
            </paragraph>
         </d:section>
      </d:section><d:section title = "Sequences" id = "fogen.sequence">
         <d:section title = "boost::io::arrayfmt" id = "fogen.array">
            <paragraph><table cellpadding = "0">
               <tr>
                  <td rowspan = "2" valign = "top">examples: </td>
                  <td><link href = "../examples/output-2D.cpp">libs/outfmt/examples/output-2D.cpp</link></td>
               </tr><tr>
                  <td><link href = "../examples/output-3D.cpp">libs/outfmt/examples/output-3D.cpp</link></td>
               </tr>
            </table></paragraph>

            <paragraph>
               This generator function creates a <code>boost::io::array_object</code>
               object. It meets the requirements specified in section
               <d:ref section = "fogen.requirements"/>. Each form has three sub-variants:
            </paragraph>

            <c:code indent = "true"><c:line>boost::io::arrayfmt( long off, long len )</c:line></c:code>
            <paragraph>
               Construct an array formatter for the range [off, off + len).
            </paragraph>

            <c:code indent = "true"><c:line>boost::io::arrayfmt( long len )</c:line></c:code>
            <paragraph>
               Construct an array formatter for the range [0, len).
            </paragraph>

            <c:code indent = "true"><c:line>boost::io::arrayfmt()</c:line></c:code>
            <paragraph>
               Constructs an array formatter, no range specified.
            </paragraph>

            <note>
               The variants that specify a format object have <code>out</code> at the end
               of their names.
            </note>
         </d:section><d:section title = "boost::io::containerfmt" id = "fogen.container">
            <paragraph><table cellpadding = "0">
               <tr>
                  <td rowspan = "2" valign = "top">examples: </td>
                  <td><link href = "../examples/output-2D.cpp">libs/outfmt/examples/output-2D.cpp</link></td>
               </tr>
            </table></paragraph>

            <paragraph>
               This generator function creates a <code>boost::io::container_object</code>
               object. It meets the requirements specified in section
               <d:ref section = "fogen.requirements"/>.
            </paragraph>
         </d:section><d:section title = "boost::io::rangefmt" id = "fogen.range">
            <paragraph>
               This generator function creates a <code>boost::io::range_object</code>
               object. It meets the requirements specified in section
               <d:ref section = "fogen.requirements"/>.
            </paragraph>
         </d:section>
      </d:section><d:section title = "State Information" id = "fogen.stateio">
         <paragraph><table cellpadding = "0">
            <tr>
               <td rowspan = "2" valign = "top">examples: </td>
               <td><link href = "../examples/john-torjo.cpp">libs/outfmt/examples/john-torjo.cpp</link></td>
            </tr>
         </table></paragraph>

         <d:section title = "boost::io::statefmt" id = "fogen.state">
            <paragraph>
               This generator function creates a <code>boost::io::state_object</code>
               object. It meets the requirements specified in section
               <d:ref section = "fo.generator"/>, but has slightly different semantics.
            </paragraph>

            <c:code indent = "true">
               <c:line>statefmt&lt; StateObject, bool pre &gt;()</c:line>
            </c:code>
            <paragraph>
               This version takes a state object and specifies whether the state object
               is outputted before (<code>pre = true</code>) or after
               (<code>pre = false</code>) the format object hosted by
               <code>boost::io::state_object</code>.
            </paragraph>

            <c:code indent = "true">
               <c:line>statefmtex&lt; FormatType, StateObject, bool pre &gt;()</c:line>
            </c:code>
            <paragraph>
               This version allows the user to specify the format type used by the
               format objects.
            </paragraph>

            <c:code indent = "true">
               <c:line>statefmt&lt; StateObject, bool pre &gt;( const Outputter &amp; o )</c:line>
            </c:code>
            <paragraph>
               This version controls the format object used to format the data type.
            </paragraph>
         </d:section>
      </d:section>
   </d:section><d:section title = "Future Directions" id = "future.future">
      <d:section title = "Tutorials" id = "future.tutorial">
         <paragraph><list>
            <li>
               How to create a Format Object to support a new data type.
            </li><li>
               How to create a Format Object Adaptor to leverage formatting.
            </li><li>
               How to extend the type deduction mechanism to support a new type within the
               automatic type decuction system.
            </li>
         </list></paragraph>
      </d:section><d:section title = "Position/Context Information" id = "future.context">
         <paragraph>
            Add support for context information, including the length of the sub-list being
            outputted and the current position within that sub-list. Other information may
            be added at a future date.
         </paragraph><paragraph>
            How would this interact with <code>boost::io::state_object</code>?
         </paragraph>
      </d:section><d:section title = "Additional Format Objects" id = "future.fo">
         <paragraph>
            first_object: format p.first <i>only</i>; second_object: format p.second <i>only</i>.
         </paragraph>
      </d:section><d:section title = "Advanced Data Types" id = "future.advtype">
         <paragraph>
            Support for non-sequential types, e.g. trees and graphs.
         </paragraph>
      </d:section><d:section title = "Input/Serialization" id = "future.serialize">
         <paragraph>
            Complete support for serialization and reading in from an input stream.
         </paragraph>
      </d:section>
   </d:section><d:section title = "Acknowledgements" id = "ack.ack">
      <paragraph>
         This library was designed and implemented by Reece H. Dunn.
      </paragraph><paragraph>
         The output functors were based on a comment in the "IO for STL containers" thread on the
         boost developers mailing list.
      </paragraph><paragraph>
         Special thanks to:
         <list type = "[#]">
            <li title = "Martin Henson">
               For giving me a reason to create the library in the first place!
            </li><li title = "Paul A. Bristow">
               For his comments and suggestions, especially getting me to think about supporting
               nD constructs :-). 
            </li><li title = "Terje Sletteb&#xF8;">
               For his feedback on standard/boost issues in my code.
            </li><li title = "Gennadiy Rozental">
               For issues relating to the documentation.
            </li><li title = "John Torjo">
               For feedback, ideas and comments, especially for getting me to consider format
               object deduction :-).
            </li><li title = "Jonathan Turkanis">
               For his excellent work on revamping the format object/type deduction system,
               help porting the library to broken compilers (VC6), Intel 7.1 support and
               much more!
            </li><li title = "Pavel Vozenilek">
               For feedback and comments about my library and the documentation.
            </li>
         </list>
      </paragraph>
   </d:section>
</d:document>
