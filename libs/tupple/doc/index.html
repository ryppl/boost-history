<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
<title>The tupple library</title>
</head>

<body>

<h1>The tupple library</h1>

<p>A tuple is a collection of an arbitrary, but fixed number of elements. 
The type of each element is arbitrary, but fixed, too - "fixed" here means known at compile-time.
In other words, tuples serve as a generalization of <code>std::pair</code>
for <i>n</i> (instead of two) values.
</p>

<p>The tupple library provides tuples much as the 
<a href="http://www.boost.org/libs/tuple/doc/tuple_users_guide.html">Boost.Tuple</a> library by Jaakko J&auml;rvi.
 In addition, specialized classes for tuples of iterators and tuples of containers are defined.</p>

<p>The header files of the tupple library are generated by the C preprocessor with the help of the
<a href="http://www.boost.org/libs/preprocessor/doc/index.htm">Boost.Preprocessor</a> library
(therefore the name tu<u>pp</u>le).
Hence, it might also serve as a demonstration of the power of the Boost.Preprocessor library.

 
<h2>Table of Contents</h2>
 
<ol>
<li><a href="#Basic">The basic tuple type</a></li>
       <ul>
       <li><a href="#Construction">Tuple construction</a></li>
       <li><a href="#Access">Element access</a></li>
       <li><a href="#Assignment">Assignment and swapping</a></li>
       <li><a href="#MakeTuple"> <code>make_tuple</code> and <code>tie</code> </a></li>
        <li><a href="#RelOps">Relational operators</a></li>
        <li><a href="#Functions">Helpers for functions</a></li>
				</ul>
<li><a href="#Extension">Extension to iterators and containers</a></li>
			 <ul>			
        <li><a href="#Iterators">Tuples of iterators</a></li>
        <li><a href="#Containers">Tuples of containers</a></li>
       </ul>
<li><a href="#Differences">Differences between Tupple and Boost.tuple</a></li>				 
<li><a href="#Portability">Portability</a></li>		
<li><a href="#DesignRationale">Design rationale</a></li>
       <ul>
       <li><a href="#Preprocess">The process of creating <code>tupple.hpp</code></a></li>
       </ul>

<li><a href="#Performance">Performance</a></li>
<li><a href="#FAQ">Mini-FAQ</a></li>
<li><a href="#Acknowledgements">Acknowledgements</a></li>
</ol>


<h1><a name="Basic">The basic tuple type</a></h1>

<h2><a name="Construction">Tuple construction</a></h2>

Tupples provide the following constructors:

<ol>
		
	<li>Empty constructor:
	<code>tuple&lt;int,double&gt;()</code></li>

  <li>Element-wise constructor:
  <code>tuple&lt;int,double&gt;(42,3.1415)</code></li>

  <li>Copy construction:
  <pre>
  tuple&lt;int,double&gt; u(42,3.1415);
  tuple&lt;long,float&gt; v(u);
  </pre>
  <p>Note that corresponding element types are not required to be equal; it is just necessary for
  the former element type to be convertible to the later one (for instance, due to a constructor).
 </p> </li>

  <li>Construction out of head and tail:
  <pre>
    tuple&lt;int,double&gt; a(42,3.1415);
    tuple&lt;string,int,double&gt; b("foo",a);
  </pre></li>

</ol>


The library additionally provides a type generator <code>n_fold_tuple</code> which allows
construction of tuples where all elements are of the same type. Thus, the statement
<pre>
  n_fold_tuple&lt;int,5&gt;::type
</pre>
is esentially the same as writting
<pre>
  tuple&lt;int,int,int,int,int&gt;
</pre>


<h2><a name="Access">Element access</a></h2>

The elements of a tuple may be accessed by calling either
<pre>getN(t);</pre>
or calling the member function
<pre>t.getN();</pre>
where <code>N</code> is between 0 and <em>size of tuple-1</em>.

Depending on whether the tuple is <em>const</em> or <em>non-const</em>,
the return type is either a <em>const</em> or a <em>non-const</em> reference
to element type.

In addition there are two functions to access the first element and the 
tuple containing all but the first, respectively.
<pre>
  t.head();
</pre>
is essentially the same as calling <code>t.get0()</code>.

Each tuple type defines its own <code>tail_type</code> to be the tuple
consisting of all but the first elements, i.e.
<code>tuple&lt;T0,T1,T2,T3&gt;::tail_type</code> is <code>tuple&lt;T1,T2,T3&gt;</code>.
Accordingly, the statement
<pre>
     t.tail();
</pre>
returns a tuple of <code>t</code>'s <code>tail_type</code>, containing all but the first element.


<h2><a name="Assignment">Assignment and swapping</a></h2>

Tuples can be assigned to other tuples if each element type is assignable.
Implicit conversion is done as with the copy constructor.
<pre>
tuple&lt;int,double&gt; u(42,3.1415);
tuple&lt;long,float&gt; v;
v = u;
</pre>


<h2><a name="MakeTuple"> <code>make_tuple</code> and <code>tie</code> </a></h2>

The <code>make_tuple</code> function is intended to ease the creation of tuples
(analogous to the <code>make_pair</code> function): 

<pre>
  tuple&lt;int,double,foo&gt; u = make_tuple( 42,3.14,foo("bar") );
</pre>

The <code>tie</code> function comes in handy if one wants to extract
data back from a tuple into individual variables.  

<pre>
  int i; foo f;
  tie( i, ignore, f ) = u;
    // now i == 42 and f == foo("bar").
</pre>


<h2><a name="RelOps">Relational operators</a></h2>

Often, one needs to test tuples for equality and inequality.
 Additionally, testing for less than, greater than etc. w.r.t. 
lexicographical ordering is useful sometimes:
<pre>
  tuple&lt;int,double,foo&gt; u( 42,2.78,foo("bar") );
  tuple&lt;long,float,foo&gt; w( 42,3.14,foo("bar") );

  if( u == w ) // element-wise equality
    // do something

  if( u &lt; w ) // lexicographical ordering
    // do something different
</pre>


<h2><a name="Functions">Helpers for functions</a></h2>

Say there is a function that expects <em>three</em> separate arguments;
however, we would like to pass <em>one</em> 3-tuple to it.
For such situations, a helper function which maps one calling form to the other
comes in handy:
<pre>
  bool is_fooable( int,double,foo ); // a function taking three args
  // ...

  tuple&lt;int,double,foo&gt; u( 42,2.78,foo("bar") ); // the argument

  pointer_to_function&lt;bool,int,double,foo&gt; fooable( is_fooable );
  
  if( fooable(u) ) // calls is_fooable( get0(u),get1(u),get2(u) )
</pre>


<h1><a name="Extension">Extension to iterators and containers</a></h1>

The motivation to reimplement the <code>tuple</code> type  was that I wanted to
group <em>containers</em> and <em>iterators</em>
together in a tuple in the same manner as ``plain old data types''.
This is necessary, for instance, to generalize the implementation
of a <code>zip_view</code>, see <a href="http://www.zib.de/weiser/vtl/">VTL</a>.

The intended meaning is straight-forward:
A tuple of, say, three containers (always in the sense of STL containers
such as <code>std::vector</code>, <code>std::list</code> etc.) containing 
<code>int</code>s, <code>double</code>s,and <code>foo</code>s,
respectively, should be ``the same'' as a container which contains
<code>tuple&lt;int,double,foo&gt;</code>s as elements.

<h2><a name="Iterators">Tuples of iterators</a></h2>

<pre>
  vector&lt;int&gt; u;
  vector&lt;double&gt; v;
  vector&lt;foo&gt; w;

  // fill u, v, and w with data

  typedef container_tuple&lt; vector&lt;int&gt;,vector&lt;double&gt;,vector&lt;foo&gt; &gt; 
          my_vectors;

  my_vectors t( u,v,w );
  my_vectors::iterator it;

  for( it = t.begin(); it != t.end(); ++it )
  {
    // (*it) is of type tuple&lt;int,double,foo&gt;:
    int i = get0( *it );
    it-&gt;get1() = 3.14 * i;
  }
</pre>


<h2><a name="Containers">Tuples of containers</a></h2>


<pre>
  // u, v, and w as above
  my_vectors t( u,v,w );

  tuple&lt;int,int,int&gt; index( 1,4,3 );
  t[ index ] = make_tuple( 42,3.14,foo("bar") );
</pre>



<h2><a name="Differences">Differences between Tupple and Boost.tuple</a></h2>

Apart from additional functionality, Tupple and Boost.Tuple are almost identical
w.r.t. the interface. One small difference: 
<ul>
<li>write <code>get2()</code> instead of <code>get&lt;2&gt;()</code>to get the third element.</li>
</ul>



<h2><a name="Portability">Portability</a></h2>

<p>
The tupple library relies heavily on partial template instantiation;
thus, a relatively recent compiler is necessary.
So far, it is tested to work with with gcc 2.95.3-6 (mingw special) and 
gcc-3.2 (cygwin). 

</p>

<h3>Known issues with MSVC++</h3>

In case that there is no partial template specialization,
a special version of the tupple library is used. 

<ul>
<li>There is no type <code>tuple</code>; instead, you have to write
    <code>tuple</code><em>n</em>, where <em>n</em> is the number of elements,
    for instance <code>tuple2&lt;int,char&gt; t(42,'c');</code> etc.</li>
<li>Tuples of references won't work, so do not write something like 
    <code>tuple2&lt;int&,char&&gt;</code>. </li>
<li>Due to the lack of partial template specialization, <code>iterator_traits&lt;T&gt;</code> 
    is not available; you have to pass traits explicitly to iterator and contaienr
		tuples.</li>				
</ul>


<h1><a name="DesignRationale">Design rationale</a></h1>

Of course it might have been possible to add operators like <code>operator++</code>,
<code>operator--</code>etc. to each tuple class. 
I decided against this option. Instead, two classes, <code>iterator_tuple</code> 
and <code>container_tuple</code> representing tuples of iterators and (STL) 
containers are derived from <code>tuple</code>.

<h2><a name="Preprocess">The process of creating <code>tupple.hpp</code></a></h2>

One of the major characteristics of the tupple library is that its
source code is generated by the C preprocessor with the help of
the Boost.Preprocessor library.
This is done in two steps:

<ol>
<li><tt>gcc</tt> is called with the proper options (<tt>-E -C -P</tt>) 
    to run the preprocessor only, and to save the preprocessed output
		to a file. The result is valid code, but in barely readable messy form.
</li>
<li><tt>indent</tt> reformats the preprocessed source code, and puts the result
    in the correct directory. 
</li>
</ol>
 
For further details, have a look at this
<a href="http://www.flll.uni-linz.ac.at/staff/private/roland/tupple/tr0214.pdf">
Technical Report</a>.


<h2><a name="Performance">Performance</a></h2>

All in all, the Tupple library matches Boost.Tuple in performance. Various tests
did show a speedup of about 2-5% (which is as good as nothing). 
Compile time should also be shorter, but since this is even harder to measure, 
I can not provide any reliable data on that yet.



<h2><a name="FAQ">Mini-FAQ</a></h2>

<p><i>Q: When compiling under Linux, I get messages like "Invalid token in expression"
or "stray '\' in program". </i><br>

<i>A:</i>  Usually, this is caused by a backslash '\' within a macro definition, followed by a wrong
 (i.e. DOS-like) end-of-line character. I experienced this problem not only with <tt>tupple.hpp</tt>,
 but also with files from <tt>boost/config</tt>, such as <tt>suffix.hpp</tt>,
 <tt>posix_features.hpp</tt> etc. Saving the files as "non-DOS" fixed the problem.</p>

<p><i>Q: The test program fails.</i><br>

<i>A:</i> Test statements like
<pre>
  int a;
  BOOST_TEST(a == int());
</pre>
pass for some compilers, and fail for others. It is surprising to
see that even closely related compilers such as gcc-2.95.3 cygwin (pass)
and gcc-2.95.2 under Linux (fail) show different behaviour. Besides, I'm
not even sure whether this <i>should</i> pass or fail.</p>


<p><i>Q: I get compiler errors when using <code>operator!=()</code></i><br>

<i>A:</i> 
Some distributions of the STL define <code>operator!=()</code> (such as
SGI's STL in <tt>stl_relop.h</tt>), others don't (such as STLPort).
If you experience troubles, you should <code>#define TUPPLE_SKIP_NOT_EQUAL</code>
before including <tt>tupple.hpp</tt>.

<h2><a name="Acknowledgements">Acknowledgements</a></h2>

Some code of the Boost.tuple library  was re-used with the kind permission of
Jaakko J&auml;rvi.


<hr>

<p>Last modified 17 Dez 2002.</p>

<p>Copyright &copy; <a href="mailto:roland@flll.jku.at">Roland Richter &lt;roland@flll.jku.at&gt;</a> 2002.
Permission to copy, use, modify, sell and distribute this software
is granted provided this copyright notice appears in all copies.
This software is provided "as is" without express or implied
warranty, and with no claim as to its suitability for any purpose.</p>

</body>
</html>
