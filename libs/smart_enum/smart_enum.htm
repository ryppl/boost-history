<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <title>Header boost/smart_enum.hpp Documentation</title>
    <link rel="stylesheet" type="text/css" href="../../boost.css">
    <style type="text/css">
        body      { margin-left:1em; margin-right:2em;    }
        dt        { margin-top:2ex;                       }
        dd        { margin-top:0.5ex; text-align:justify; }
        li        { margin-top:0.5ex;                     }
        p,ol      { text-align:justify;                   }
        *.center  { text-align:center;                    }
        dl        { margin-left:3em;                      }
    </style>
  </head>
  <body>
    <h1><img style="vertical-align:middle;" src="../../c++boost.gif" alt="c++boost.gif (8819
bytes)" height="86" width="277">Header <a
href="../../boost/smart_enum.hpp">&lt;boost/smart_enum.hpp&gt;</a></h1>

    <blockquote>
      <h3 class="center">Abstract</h3>

      <p>This library provides a generic wrapper template for <code>enum</code> data types,
allowing for checked maniplation of <code>enum</code> instances. In particular, the template
classes can verify arithmetic and assignment expressions at compile-time and run-time with
neglectable overhead. All functionality is provided in the header file; there is no need to
link any binary object files to your application in order to use this library.</p>
    </blockquote>

    <hr>
    <h3>Contents</h3>
    <ul>
      <li><a href="#motivation">Motivation for <code>smart_enum</code></a></li>
      <li><a href="#overview">Overview of the components provided by the library</a></li>
      <li><a href="#sequential">Template <code>sequential_smart_enum</code></a></li>
      <li><a href="#wrapped">Template <code>wrapped_smart_enum</code></a></li>
      <li><a href="#bounded">Template <code>bounded_smart_enum</code></a></li>
      <li><a href="#smartenum">Using template <code>smart_enum</code> directly</a></li>
      <li><a href="#madness">Sheer madness with <code>boost::lambda</code></a></li>
      <li><a href="#license">License</a></li>
    </ul>
    <hr>

    <h2 id="motivation">Motivation for <code>smart_enum</code></h2>

    <p>Program writers frequently have to store <em>state</em> information in their classes,
which determines the next step in the program flow. Another frequent requirement is to denote
certain distinct values, which are grouped by some relation, using descriptive names that
suggest the value's meaning. The intuitive representation for these applications is
<code>enum</code>, which has been designed exactly for this purpose.</p>

    <p>Unfortunately, <code>enum</code> has a few shortcomings:</p>

    <ol>
      <li>An <code>enum</code> is always instantiated uninitialized. There's no way to add a
default constructor, because <code>enum</code> is a fundamental datatype.</li>

      <li>For the same reason, you cannot derive from <code>enum</code> in order to add the
required member functions to the derived class.</li>

      <li>If you want to use an <code>enum</code> in an arithmetic expression, such as
<blockquote>
          <p><code>++state</code><br>
          <code>state = BASE_STATE + 2</code><br>
          <code>state = state + 5</code><br>
          <code>state = 16</code></p>
        </blockquote>
you would have to define a whole bunch operators to get things checked at run-time. And if you
don't want to do that, you'll have to use some sort of cast to get the expressions to compile
at all because the compiler will implicitely convert the <code>enum</code> to <code>int</code>
in order to do the maths. But apparently, it cannot convert the result of the integer
expression back to <code>enum</code>.</li>
    </ol>

    <p>Solving this dilemma is not a hard problem, but it is an <em>annoying</em> problem. You
should rather concentrate on your application than to worry about missing operators.</p>

    <h2 id="overview">Overview of the components provided by the library</h2>

     <fieldset class="center"><legend>What makes a <code>smart_enum</code></legend><img src="architecture.gif" alt="UML diagram of smart_enum's
        components"></fieldset>

    <fieldset class="center"><legend>Combining <code>smart_enum</code> with a specific
<code>Incrementor</code></legend><img src="architecture-concrete.gif" alt="UML diagram of
        sequential_smart_enum"></fieldset>

    <h2 id="sequential">Template <code>sequential_smart_enum</code></h2>

    <h2 id="wrapped">Template <code>wrapped_smart_enum</code></h2>

    <h2 id="bounded">Template <code>bounded_smart_enum</code></h2>

    <h2 id="smartenum">Using template <code>smart_enum</code> directly</h2>

    <h2 id="madness">Sheer madness with <code>boost::lambda</code></h2>

    <p><a href="http://www.boost.org/libs/lambda/doc/">lambda</a></p>

    <h2 id="license">License</h2>

    <p>Copyright &copy; 2002 by <a href="mailto:simons@computer.org">Peter Simons
&lt;simons@computer.org&gt;</a>. Permission to copy, use, modify, sell and distribute this
document is granted provided this copyright notice appears in all copies. This document is
provided &quot;as is&quot; without express or implied warranty, and with no claim as to its
suitability for any purpose.</p>
  </body>
</html>

<!--
Local Variables:
mode: sgml
fill-column:95
End:
-->
