<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE header PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<header name="boost/signals/track.hpp" last-revision="$Date$">
  <using-class name="boost::signalN"/>
  <namespace name="boost">
    <namespace name="signals">
      <overloaded-function name="track">
        <signature>
          <template>
            <template-type-parameter name="T"/>
          </template>
          <type><classname>tracked_shared_ptr</classname>&lt;T&gt;</type>
          <parameter name="arg">
            <paramtype>const shared_ptr&lt;T&gt; &amp;</paramtype>
          </parameter>
        </signature>
        <signature>
          <template>
            <template-type-parameter name="T"/>
          </template>
          <type><classname>tracked_shared_ptr</classname>&lt;T&gt;</type>
          <parameter name="arg">
            <paramtype>const weak_ptr&lt;T&gt; &amp;</paramtype>
          </parameter>
        </signature>
        <signature>
          <template>
            <template-type-parameter name="T"/>
          </template>
          <type><classname>tracked</classname>&lt;T&gt;</type>
          <parameter name="tracked_ptr">
            <paramtype>const shared_ptr&lt;void&gt;&amp;</paramtype>
          </parameter>
          <parameter name="arg_value">
            <paramtype>const T &amp;</paramtype>
          </parameter>
        </signature>

        <purpose>Enables safe use of multicast callbacks.</purpose>

        <description>
          <para>The <code>track</code> functions are used to mark objects for tracking,
          so a signal can automatically disconnect any slots they are associated with
          at the appropriate time.  The signal will also insure the objects are not
          destroyed by <code>shared_ptr</code> while their associated slots are in
          mid-execution.
          </para>
          <para>An example of tracking an object when binding to one of its member functions:</para>
          <programlisting>
class myclass
{
public:
  void member_function();
  // ...
};

// ...

boost::signal&lt;void ()&gt; sig;
boost::shared_ptr&lt;myclass&gt; myobject(new myclass(/* ... */));
sig.connect(boost::bind(&amp;myclass::member_function, boost::signals::track(myobject)));

// ...
          </programlisting>
          <para>An example of tracking a function argument indirectly managed by a shared_ptr:</para>
          <programlisting>
void myfunction(const myclass &amp;arg)
{
  // ...
};

struct bunch_of_stuff
{
  // ...
  myclass myobject;
  // ...
};

// ...

boost::signal&lt;void ()&gt; sig;
boost::shared_ptr&lt;bunch_of_stuff&gt; bunch(new bunch_of_stuff);
sig.connect(boost::bind(&amp;myfunction, boost::signals::track(bunch, boost::ref(bunch->myobject))));

// ...
          </programlisting>

        </description>

        <returns><para>An tracked object suitable for passing to <code>bind</code> or directly
        to <functionname>signalN::connect</functionname>().
        The single argument forms of <code>track</code> return a <classname>tracked_shared_ptr</classname>&lt;T&gt;
        which holds a <code>weak_ptr&lt;T&gt;</code> copy of the argument.  <classname>tracked_shared_ptr</classname>&lt;T&gt;
        is derived from <classname>tracked</classname>&lt;<code>weak_ptr&lt;T&gt; &gt;</code>,
        and simply adds an implicit conversion back into shared_ptr for binding to shared_ptr arguments.  The two argument
        form of <code>track</code> returns a <classname>tracked</classname>&lt;T&gt;, which is implicitly convertible
        back into a T&amp; if T is not a reference_wrapper, or T::type&amp; if T is a reference_wrapper.
        </para></returns>
      </overloaded-function>

      <class name="tracked">
        <template>
          <template-type-parameter name="T">
          </template-type-parameter>
        </template>
        <purpose> Holds a value and a weak_ptr which tracks the value's lifetime.
        </purpose>
        <description> A <code>tracked&lt;T&gt;</code> holds a value of type T, which can be passed to <code>bind</code> or directly to <functionname>signalN::connect</functionname>(),
          and a weak_ptr which tracks the value's lifetime.  It supports reference-wrapped values obtained with <functionname>boost::ref</functionname>,
          and implict conversion back to the value's (reference-unwrapped) type.  <code>tracked</code> objects are typically
          created using the <functionname>track</functionname> convenience functions.
        </description>
        <typedef name="value_type">
          <type>T</type>
        </typedef>
        <typedef name="unwrapped_value_type">
          <type>typename <classname>unwrap_reference</classname>&lt;T&gt;::type</type>
        </typedef>
        <constructor>
          <parameter name="tracked_ptr">
            <paramtype>const shared_ptr&lt;void&gt; &amp;</paramtype>
          </parameter>
          <parameter name="value">
            <paramtype>const T &amp;</paramtype>
          </parameter>
        </constructor>
        <method-group name="conversion operators">
          <method name="operator unwrapped_value_type&amp;">
          </method>
          <method name="operator const unwrapped_value_type&amp;" cv="const">
          </method>
        </method-group>
      </class>

      <class name="tracked_shared_ptr">
        <template>
          <template-type-parameter name="T">
          </template-type-parameter>
        </template>
        <inherit access="public">
          <type><classname>tracked</classname>&lt;weak_ptr&lt;T&gt; &gt;</type>
        </inherit>
        <purpose> A <classname>tracked</classname> object which adds support for implicit conversion back
          to <code>shared_ptr</code>.
        </purpose>
        <description><para><code>tracked_shared_ptr</code> is returned by the
          single-argument form of the <functionname>track</functionname> function.  It holds a weak_ptr, and supports implicit
          conversion to shared_ptr.  This allows it to be used when binding to a function argument of type <code>shared_ptr</code>.
          </para>
        </description>
        <constructor>
          <parameter name="tracked_ptr">
            <paramtype>const weak_ptr&lt;T&gt; &amp;</paramtype>
          </parameter>
        </constructor>
        <method-group name="conversion operators">
          <method name="operator shared_ptr&lt;T&gt;" cv="const">
          </method>
        </method-group>
     </class>
    </namespace>
  </namespace>
</header>
