[/ Boost.Extension - third tutorial ]
[/ Copyright 2007 Mariano G. Consoni ]
[/ Distributed under the Boost Software License, Version 1.0. (See]
[/ accompanying file LICENSE_1_0.txt or copy at ]
[/ http://www.boost.org/LICENSE_1_0.txt) ]
[/ See http://www.boost.org/ for latest version. ]


[section:tutorial03 Tutorial 3]

This tutorial shows how to register and instantiate classes that have 
multi-argument constructors (not default constructors) in Boost.Extension. 
In the example that we will describe in this tutorial (examples/parameters) 
we create a dummy class with a constructor that have six arguments. We'll 
register this class in a factory map and then get it from the main file.

It is expected that before following this tutorial you have gone trough the 
first tutorial at least, and you are familiar with the basic use of 
Boost.Extension.


Let's start defining our class. Its constructor receives six parameters (we 
chose that number because it's the default argument limit of the library), 
each one of a different type including a class defined in the interface 
(class A) and a smart pointer to this class. It shows via stdout the received 
parameters at construction.


``
class six_parameters : public lots_of_parameters_interface
{
  public:
    six_parameters(bool b, unsigned int i, char c, std::string s, A a,
                   boost::shared_ptr<A> ptr_a) 
                   lots_of_parameters_interface(b, i, c, s, a, ptr_a)
    {
      std::cout << "Constructor called." << std::endl << std::endl;
      std::cout << "Parameters:" << std::endl;
      std::cout << "\tbool: " << b << std::endl;
      std::cout << "\tunsigned int: " << i << std::endl;
      std::cout << "\tchar: " << c << std::endl;
      std::cout << "\tstring: " << s << std::endl;
      std::cout << "\tA.i: " << a.i << std::endl;
      std::cout << "\tptr_a->i: " << ptr_a->i << std::endl;
      std::cout << std::endl;
    }

    virtual ~six_parameters(void) {}
};
``
\n
The interface that we are inheriting is just the bare minimum needed to make it
compile:

``
class A
{
  public:
    A(unsigned int i) : i(i) {}
    int i;
};


class lots_of_parameters_interface
{
  public:
    lots_of_parameters_interface(bool b, unsigned int i, char c, 
                                 std::string s, A a, 
                                 boost::shared_ptr<A> ptr_a) {}
    virtual ~lots_of_parameters_interface(void) {}
};
``
\n
Having the class defined, we should write the export function to register the 
class in the passed factory map. The point here is that the factory_map::add 
method must be set with the first type as the third argument, and with the 
second type as the fourth argument and so on.

``
extern "C" void BOOST_EXTENSION_EXPORT_DECL 
extension_export(boost::extensions::factory_map & fm)
{
  fm.get<lots_of_parameters_interface, int, bool, 
         unsigned int, char, std::string, A, 
         boost::shared_ptr<A> >()[6].set<six_parameters>();
}
``
\n
Finally, let's see how it is used in the main file.

``
int main(void)
{
  using namespace boost::extensions;

  //  Create the factory_map object - it will hold all of the available
  //  constructors. Multiple factory_maps can be constructed.
  factory_map fm;

  // load the shared library with 
  load_single_library(fm, "libParametersLib.extension", "extension_export");

  std::map<int, factory<lots_of_parameters_interface, bool, unsigned int,
                        char, std::string, A, boost::shared_ptr<A> > > &
                        factory_list = 
	fm.get<lots_of_parameters_interface, int, bool, unsigned int, char, 
         std::string, A, boost::shared_ptr<A>  >();
  if (factory_list.size() != 1) {
    std::cout << "Error - the class was not found.";
    return 1;
  }

  std::map<int, factory<lots_of_parameters_interface, bool, unsigned int,
                        char, std::string, A, boost::shared_ptr<A> > >
                        ::iterator par = factory_list.begin();
  std::auto_ptr<lots_of_parameters_interface>
    par_ptr(par->create(true, 4, 'c', "test", A(2),
                        boost::shared_ptr<A>(new A(15))));

  return 0;
}
``

Please note the following details:

* Shared library loading is exactly the same.
* When we get the factory we should specify the template parameters, as we did in the factory_map::add method.
* When we call the create method we just supply the needed arguments and just works!

\n

It is expected that at this point you can create your own classes with 
multi-argument constructors and use them via Boost.extensions without problems.

[endsect]