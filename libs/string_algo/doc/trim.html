<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

  <head>
    <title>String Algorithm Library</title>
    <meta content="Pavol Droba, mailto:droba@topmail.sk" name="author">
    <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
    <meta name="ProgId" content="FrontPage.Editor.Document">
  </head>

  <body text="#000000" bgcolor="#ffffff">

    <div align="left">
      <table border="0" width="799" height="134">
        <tr>
          <td width="288" height="134"><img id="IMG1" src="cboost.gif" align="middle" border="0" width="277" height="86"></td>
          <td width="1152" height="134">
            <h1 align="center">&nbsp;String Algorithm Library&nbsp;</h1>
            <h2 align="center">Trim</h2>
          </td>
        </tr>
      </table>
    </div>
    <ul>
      <li><a href="#trim_algorithms">Trim Algorithms</a>
        <ul>
          <li><a href="#ta_overview">Overview</a></li>
          <li><a href="#ta_description">Description</a></li>
          <li><a href="#ta_synopsis">Synopsis</a></li>
        </ul>
      </li>
      <li><a href="#predicates">Trim Predicates</a>
        <ul>
          <li><a href="#ta_description">Description</a></li>
          <li><a href="#pred_synopsis">Synopsis</a>&nbsp;&nbsp;&nbsp;</li>
        </ul>
      </li>
      <li><a href="#examples">Examples</a></li>
    </ul>
    <hr>
    <h2><a name="trim_algorithms">Trim Algorithms</a></h2>
    <h3><a name="ta_overview">Overview</a></h3>
    <p>
      Trim&nbsp;algorithms are declared in <a href="../../../boost/string_algo/trim.hpp">&lt;boost/string_algo/trim.hpp&gt;</a>
      header.<br>
      Trim algorithms are used to remove trailing and leading spaces from a
      sequence (string). Space characters are selected using a functor.
      Functions take a selection predicate as a parameter, which is used to
      determine if a charater is a space. Common predicates are provided with
      library. Algorithms are provided for iterator ranges as well as for
      sequences for convenience.
    </p>
    <h3><a name="ta_description">Description</a></h3>
    <p>
      Each algorithm removes trailing or leading spaces from the input sequence.
      <code>trim_left</code> removes leading spaces,&nbsp; <code>trim_right</code>
      removes trailing spaces and <code>trim</code> removes both. Result is
      either copied into an output iterator, a copy of the input sequence or
      applied to the input depending on the used algorithm.
    </p>
    <p>
      For predicate-based variants, <code>IsSpace</code> predicate must satisfy
      the requirements of <code>std::unary_function&lt;Input::value_type,
      bool&gt;</code>.
    </p>
    <table border="0" width="601" height="21">
    </table>
    <table border="1" height="28" width="730">
      <tr>
        <th height="30" valign="top" align="center" width="181">Function</th>
        <th height="30" width="533">Description</th>
      </tr>
      <tr>
        <td height="28" valign="top" align="center" width="181"><code>trim_left_copy_if</code></td>
        <td height="28" valign="top" align="center" width="533">Remove leading
          spaces. Copy version with <code>IsSpace</code> predicate.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="center" width="181"><code>trim_left_if</code></td>
        <td height="30" valign="top" align="center" width="533">Remove leading
          spaces. In-place version with <code>IsSpace</code> predicate.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="center" width="181"><code>trim_left_copy</code></td>
        <td height="28" valign="top" align="center" width="533">Remove leading
          spaces. Copy version.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="center" width="181"><code>trim_left</code></td>
        <td height="30" valign="top" align="center" width="533">Remove leading
          spaces. In-place version .</td>
      </tr>
      <tr>
        <td height="28" valign="top" align="center" width="181"><code>trim_right_copy_if</code></td>
        <td height="28" valign="top" align="center" width="533">Remove trailing
          spaces. Copy version with <code>IsSpace</code> predicate.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="center" width="181"><code>trim_right_if</code></td>
        <td height="30" valign="top" align="center" width="533">Remove trailing
          spaces. In-place version with <code>IsSpace</code> predicate.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="center" width="181"><code>trim_right_copy</code></td>
        <td height="28" valign="top" align="center" width="533">Remove trailing
          spaces. Copy version.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="center" width="181"><code>trim_right</code></td>
        <td height="30" valign="top" align="center" width="533">Remove trailing
          spaces. In-place version .</td>
      </tr>
      <tr>
        <td height="28" valign="top" align="center" width="181"><code>trim_copy_if</code></td>
        <td height="28" valign="top" align="center" width="533">Remove trailing
          and leading spaces. Copy version with <code>IsSpace</code> predicate.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="center" width="181"><code>trim_if</code></td>
        <td height="30" valign="top" align="center" width="533">Remove trailing
          and leading spaces. In-place version with <code>IsSpace</code>
          predicate.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="center" width="181"><code>trim_copy</code></td>
        <td height="28" valign="top" align="center" width="533">Remove trailing
          and leading spaces. Copy version.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="center" width="181"><code>trim</code></td>
        <td height="30" valign="top" align="center" width="533">Remove trailing
          and leading spaces. In-place version .</td>
      </tr>
    </table>
    <h3><a name="ta_synopsis">Synopsis</a></h3>
    <p>
      Iterator based variant. Function returns an output operator pointing just
      after last inserted character.
    </p>
    <pre><b>namespace</b> boost {

    <b>template</b>&lt; <b>typename</b> ForwardIteratorT, <b>typename</b> OutputIteratorT, <b>typename</b> PredicateT &gt;
    OutputIteratorT trim_left_copy_if( 
        OutputIteratorT Output,
        ForwardIteratorT InBegin,
        ForwardIteratorT InEnd,
        PredicateT IsSpace );

    <b>template</b>&lt; <b>typename</b> ForwardIteratorT, <b>typename</b> OutputIteratorT, <b>typename</b> PredicateT &gt;
    OutputIteratorT trim_right_copy_if( 
        OutputIteratorT Output,
        ForwardIteratorT InBegin,
        ForwardIteratorT InEnd,
        PredicateT IsSpace );

    <b>template</b>&lt; <b>typename</b> ForwardIteratorT, <b>typename</b> OutputIteratorT, <b>typename</b> PredicateT &gt;
    OutputIteratorT trim_copy_if( 
        OutputIteratorT Output,
        ForwardIteratorT InBegin,
        ForwardIteratorT InEnd,
        PredicateT IsSpace );
}</pre>
    <p>
      Sequence version with copy semantic. Returns a new sequence which is a
      trimmed copy of the input sequence
    </p>
    <pre> <b>namespace</b> boost {

    <b>template</b>&lt; <b>typename</b> SeqT, <b>typename</b> PredicateT &gt;
    SeqT trim_left_copy_if( <b>const</b> SeqT&amp; Input, PredicateT IsSpace );

    <b>template</b>&lt; <b>typename</b> SeqT, <b>typename</b> PredicateT &gt;
    SeqT trim_right_copy_if( <b>const</b> SeqT&amp; Input, PredicateT IsSpace );

    <b>template</b>&lt; <b>typename</b> SeqT, <b>typename</b> PredicateT &gt;
    SeqT trim_copy_if( <b>const</b> SeqT&amp; Input, PredicateT IsSpace );
}</pre>
    <p>
      Sequence, in-place versions. Returns a reference to the input sequence.
    </p>
    <pre><b>namespace</b> boost {
 
    <b>template</b>&lt; <b>typename</b> SeqT, <b>typename</b> PredicateT &gt;
    SeqT&amp; trim_left_if( SeqT&amp; Input, PredicateT IsSpace );

    <b>template</b>&lt; <b>typename</b> SeqT, <b>typename</b> PredicateT &gt;
    SeqT&amp; trim_right_if( SeqT&amp; Input, PredicateT IsSpace );

    <b>template</b>&lt; <b>typename</b> SeqT, <b>typename</b> PredicateT &gt;
    SeqT&amp; trim_if( SeqT&amp; Input, PredicateT IsSpace );
}</pre>
    <p>
      Shortcut versions for regular space ( <code>create_isspace()</code> is
      used to instantiate <code>isclassified</code> functor ).
    </p>
    <pre><b>namespace</b> boost {

    <b>template</b>&lt; <b>typename</b> SeqT &gt;
    SeqT trim_left_copy( <b>const</b> SeqT&amp; Input, <b>const</b> std::locale&amp; Loc=std::locale() );

    <b>template</b>&lt; <b>typename</b> SeqT &gt;
    SeqT&amp; trim_left( SeqT&amp; Input, <b>const</b> std::locale&amp; Loc=std::locale() );

    <b>template</b>&lt; <b>typename</b> SeqT &gt;
    SeqT trim_right_copy( <b>const</b> SeqT&amp; Input, <b>const</b> std::locale&amp; Loc=std::locale() );

    <b>template</b>&lt; <b>typename</b> SeqT &gt;
    SeqT&amp; trim_right( SeqT&amp; Input, <b>const</b> std::locale&amp; Loc=std::locale() );

    <b>template</b>&lt; <b>typename</b> SeqT &gt;
    SeqT trim_copy( <b>const</b> SeqT&amp; Input, <b>const</b> std::locale&amp; Loc=std::locale() );

    <b>template</b>&lt; <b>typename</b> SeqT &gt;
    SeqT&amp; trim( SeqT&amp; Input, <b>const</b> std::locale&amp; Loc=std::locale() );
}</pre>
    <p>
      Parameters:
    </p>
    <div align="left">
      <table border="1" width="574" height="1">
        <tr>
          <td width="418" height="31" valign="top"><code><b>typename</b>
            OutputIteratorT</code></td>
          <td width="728" height="31" valign="top">An output iterator type</td>
        </tr>
        <tr>
          <td width="443" height="31" valign="top"><code><b>typename</b>
            ForwardIteratorT</code></td>
          <td width="703" height="31" valign="top">Forward iterator delimiting
            the input</td>
        </tr>
        <tr>
          <td width="418" height="31" valign="top"><code><b>typename</b> SeqT</code></td>
          <td width="728" height="31" valign="top">A sequence type (must satisfy
            the <a href="http://www.boost.org/libs/concept_check/reference.htm#container-concepts">ContainerConcept</a>)</td>
        </tr>
        <tr>
          <td width="418" height="31" valign="top"><code><b>typename</b>
            PredicateT</code></td>
          <td width="728" height="31" valign="top">An unary predicate type</td>
        </tr>
        <tr>
          <td width="418" height="31" valign="top"><code>OutputIteratorT Output</code></td>
          <td width="728" height="31" valign="top">Output iterator for the
            result. The result of the operation will be sent to this iterator.</td>
        </tr>
        <tr>
          <td width="418" height="31" valign="top"><code>ForwardIteratorT Begin</code></td>
          <td width="728" height="31" valign="top">Begin of an input sequence</td>
        </tr>
        <tr>
          <td width="418" height="31" valign="top"><code>ForwardIteratorT End</code></td>
          <td width="728" height="31" valign="top">End of an input sequence</td>
        </tr>
        <tr>
          <td width="418" height="31" valign="top"><code><b>const</b> SeqT&amp;
            Input</code></td>
          <td width="728" height="31" valign="top">An input sequence (const)</td>
        </tr>
        <tr>
          <td width="418" height="31" valign="top"><code>SeqT&amp; Input</code></td>
          <td width="728" height="31" valign="top">An input sequence (mutable)</td>
        </tr>
        <tr>
          <td width="418" height="31" valign="top"><code>PredicateT IsSpace</code></td>
          <td width="728" height="31" valign="top">Space selection predicate (
            an unary predicate ).</td>
        </tr>
        <tr>
          <td width="418" height="31" valign="top"><code><b>const</b>
            std::locale&amp; Loc</code></td>
          <td width="728" height="31" valign="top">An instance of locales which
            will be used for conversion</td>
        </tr>
      </table>
    </div>
    <hr>
    <h2><a name="predicates">Trim Predicates</a></h2>
    <h3><b><a name="pred_description">Description</a></b></h3>
    <p>
      Library contains some useful predicates which can be used with trim
      algorithms. Trim predicates are provided in the form of generators. This
      approach is more convenient for user and hides implementation details.
    </p>
    <p>
      Table shows the functionality of provided functors.
    </p>
    <div align="left">
      <table border="1" height="28" width="814">
        <tr>
          <th height="30" valign="top" align="center" width="101">Predicate</th>
          <th height="30" width="237">Description</th>
          <th height="30" width="162">Underlying functor</th>
          <th height="30" width="290">Example</th>
        </tr>
        <tr>
          <td height="28" valign="top" align="center" width="101"><code>is_classified</code>&nbsp;</td>
          <td height="28" valign="top" align="center" width="237">Match any
            character matching a character class defined by Type parameter and
            locale.</td>
          <td height="28" valign="top" align="center" width="162"><code>is_classifiedF&lt;CharT&gt;</code></td>
          <td height="28" valign="top" align="center" width="290"><code>isclassified(std::ctype_base::digit)<br>
            </code>Creates a functor, that matches all digits.</td>
        </tr>
        <tr>
          <td height="30" valign="top" align="center" width="101"><code>is_space</code></td>
          <td height="30" valign="top" align="center" width="237">Match a space.
            Instance of <code>isclassified</code> for <code>std::ctype_base::space</code>
            type</td>
          <td height="30" valign="top" align="center" width="162"><code>is_classifiedF&lt;CharT&gt;</code></td>
          <td height="30" valign="top" align="center" width="290"><code>isspace()</code><br>
            Creates a functor that matches all spaces.</td>
        </tr>
        <tr>
          <td height="30" valign="top" align="center" width="101"><code>is_from</code></td>
          <td height="30" valign="top" align="center" width="237">Match any
            character from the input sequence</td>
          <td height="30" valign="top" align="center" width="162"><code>is_fromF&lt;SeqT&gt;</code></td>
          <td height="30" valign="top" align="center" width="290"><code>isfrom(string(&quot;abc&quot;))<br>
            </code>Creates a functor which matches any of the characters a,b,c.</td>
        </tr>
      </table>
    </div>
    <h3><a name="pred_synopsis">Synopsis</a></h3>
    <pre><b>namespace</b> boost {

    <b>template</b>&lt; <b>typename</b> CharT &gt;
    string_algo::detail::is_classifiedF&lt;CharT&gt; 
    is_classified( std::ctype_base::mask Type, <b>const</b> std::locale&amp; Loc=std::locale() );

    <b>template</b>&lt; <b>typename</b> CharT &gt;
    string_algo::detail::is_classifiedF&lt;CharT&gt; 
    is_space( <b>const</b> std::locale&amp; Loc=std::locale() );

    <b>template</b>&lt; <b>typename</b> SeqT &gt;
    string_algo::detail::is_fromF&lt;SeqT&gt; is_from( <b>const</b> SeqT&amp; Seq );
}</pre>
    <p>
      Parameters:
    </p>
    <table border="1" width="574" height="1">
      <tr>
        <td width="418" height="31" valign="top"><code>std::ctype_base::mask
          Type</code></td>
        <td width="728" height="31" valign="top">A bit mask identifying a
          matching character class. Can be any combination of
          std::ctype_base::mask constants.</td>
      </tr>
      <tr>
        <td width="418" height="31" valign="top"><code><b>const</b> SeqT&amp;
          Seq</code></td>
        <td width="728" height="31" valign="top">Members of this sequence define
          a set of matching characters.</td>
      </tr>
      <tr>
        <td width="418" height="31" valign="top"><code><b>const</b>
          std::locale&amp; Loc</code></td>
        <td width="728" height="31" valign="top">An instance of locales which
          will be used by a predicate</td>
      </tr>
    </table>
    <h2><a name="examples">Examples</a></h2>
    <p>
      The following example shows basic usage of trim algorithms. More examples
      can be found in the library tests in <a href="../test/trim_test.cpp">&lt;libs/string_algo/test/trim_test.cpp&gt;</a>.
    </p>
    <pre>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;boost/string_algo/trim.hpp&gt;

using namespace std;
using namespace boost;

void trim_example()
{
    cout &lt;&lt; &quot;* Trim Example *&quot; &lt;&lt; endl &lt;&lt; endl;

    string str1(&quot;     1x x x x1     &quot;);
    string str2(&quot;&lt;&gt;trim&lt;&gt;&quot;);
    string str3(&quot;123abs343&quot;);

    cout &lt;&lt; &quot;trim_left copy of str1: &quot; &lt;&lt; &quot;\&quot;&quot; &lt;&lt; trim_left_copy( str1 ) &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;

    trim_right( str1 );
    cout &lt;&lt; &quot;trim_right on str1: &quot; &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str1 &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;

    cout 
        &lt;&lt; &quot;trimmed copy of str4 ( space='&lt;&gt;' ): &quot; 
        &lt;&lt; &quot;\&quot;&quot;&lt;&lt; trim_copy_if( str2, is_from( string(&quot;&lt;&gt;&quot;) ) ) &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
    
    cout 
        &lt;&lt; &quot;trimmed copy of str5 ( space=digit ): &quot; 
        &lt;&lt; &quot;\&quot;&quot; &lt;&lt; trim_copy_if( str3, is_classified&lt;char&gt;(ctype_base::digit) ) &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;

    cout &lt;&lt; endl;
}</pre>
    <hr>
    <p>
      (C) Copyright Pavol Droba 2003. Permission to copy, use, modify, sell and
      distribute this software is granted provided this copyright notice appears
      in all copies. This software is provided &quot;as is&quot; without express
      or implied warranty, and with no claim as to its suitability for any
      purpose.
    </p>

  </body>

</html>
