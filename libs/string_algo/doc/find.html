<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

  <head>
    <meta http-equiv="Content-Language" content="en-gb">
    <meta name="author" content="Pavol Droba, mailto:droba@topmail.sk">
    <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
    <meta name="ProgId" content="FrontPage.Editor.Document">
    <title>String Algorithm Library</title>
  </head>

  <body text="#000000" bgcolor="#ffffff">

    <p>
      <!--webbot bot="Navigation" s-type="arrows" s-orientation="horizontal"
      s-rendering="text" b-include-home="TRUE" b-include-up="TRUE" u-page
      s-target startspan --><nobr>[&nbsp;<a href="predicate.html">Back</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="index.html">Home</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="replace.html">Next</a>&nbsp;]</nobr><!--webbot bot="Navigation" endspan i-checksum="15186" -->
    </p>
    <hr>
    <div align="left">
      <table border="0" width="799" height="134">
        <tr>
          <td width="288" height="134"><img id="IMG1" src="cboost.gif" align="middle" border="0" width="277" height="86"></td>
          <td width="1152" height="134">
            <h1 align="center">&nbsp;String Algorithm Library&nbsp;</h1>
            <h2 align="center">Find</h2>
          </td>
        </tr>
      </table>
    </div>
    <ul>
      <li><a href="#find_algorithms">Find Algorithms</a>
        <ul>
          <li><a href="#overview">Overview</a></li>
          <li><a href="#fa_description">Description</a></li>
          <li><a href="#fa_synopsis">Synopsis</a>&nbsp;&nbsp;&nbsp;&nbsp;</li>
          <li><a href="#ua_examples">Examples</a></li>
        </ul>
      </li>
      <li><a href="#iterator_range">iterator_range class</a>
        <ul>
          <li><a href="#iter_description">Description</a></li>
          <li><a href="#iter_synopsis">Synopsis</a></li>
        </ul>
      </li>
      <li><a href="#rationale">Rationale</a>
        <ul>
          <li><a href="#rational_usability">Usability</a></li>
          <li><a href="#rationale_efficiency">Efficiency considerations</a></li>
        </ul>
      </li>
    </ul>
    <hr>
    <h2><a name="find_algorithms">Find Algorithms</a></h2>
    <h3><a name="overview">Overview</a></h3>
    <p>
      The find algorithms are used to search for a substring matching a specific
      criteria. The result is given as a pair of iterators (represented by an
      instance of <code><a href="#iterator_range">iterator_range</a></code>)
      pointing into the input sequence. The matching criteria is specific for
      each algorithm. The library includes searching for first, last and n-th
      occurrence of a substring as well as regular expression matching.
    </p>
    <h3><a name="fa_description">Description</a></h3>
    <p>
      The regular variants are included in <a href="../../../boost/string_algo/find.hpp">&lt;boost/string_algo/find.hpp&gt;</a>
      header and the regex variants are declared in <a href="../../../boost/string_algo/regex.hpp">&lt;boost/string_algo/regex.hpp&gt;</a>
      header.<br>
      All find algorithms are returning an instance of <code>iterator_range</code>
      as a result. It contains a pair of iterators delimiting the result
      pointing into the input sequence. If a match is not found, result contains
      a pair of iterators pointing at the end of the input sequence <code>&lt;Input.end(),Input.end()&gt;</code>
      .
    <p>
      For algorithms taking a sequence as an input, constness of the input
      defines the result of the find algorithm. For const input, a <code>const_iterator</code>
      and for non-const input an <code>iterator</code> is used. Choice is
      implemented by <code>input_policy</code> class (defined in&nbsp; <a href="../../../boost/string_algo/traits.hpp">&lt;boost/string_algo/traits.hpp&gt;</a>).
    </p>
    <table border="1" height="28" width="566">
      <tr>
        <th height="30" valign="top" align="left" width="143">Function</th>
        <th height="30" width="407" align="left">Description</th>
      </tr>
      <tr>
        <td height="28" valign="top" align="left" width="143"><code><a name="find_first">find_first</a></code></td>
        <td height="28" valign="top" align="left" width="407">Find the first
          occurrence of a substring in the input range.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="left" width="143"><code><a name="find_last">find_last</a></code></td>
        <td height="30" valign="top" align="left" width="407">Find the last
          occurrence of a substring.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="left" width="143"><code><a name="find_nth">find_nth</a></code></td>
        <td height="28" valign="top" align="left" width="407">Find the n-th
          occurrence of a substring.<br>
          Position is 0-based.</td>
      </tr>
      <tr>
        <td height="30" valign="top" align="left" width="143"><code><a name="find_regex">find_regex</a></code></td>
        <td height="30" valign="top" align="left" width="407">Find a first
          substring matching a given regex.</td>
      </tr>
    </table>
    <h3><a name="fa_synopsis">Synopsis</a></h3>
    <p>
      Iterator based variants:
    </p>
    <pre><b>namespace</b> boost {

    <b>template</b>&lt; <b>typename</b> ForwardIterator1T, <b>typename</b> ForwardIterator2T &gt;
    <b>inline</b> iterator_range&lt;ForwardIterator1T&gt;
    <a href="#find_first">find_first</a>( 
        ForwardIterator1T Begin, 
        ForwardIterator1T End, 
        ForwardIterator2T SearchBegin,
        ForwardIterator2T SearchEnd );

    <b>template</b>&lt; <b>typename</b> ForwardIterator1T, <b>typename</b> ForwardIterator2T &gt;
    <b>inline</b> iterator_range&lt;ForwardIterator1T&gt;
    <a href="#find_last">find_last</a>( 
        ForwardIterator1T Begin, 
        ForwardIterator1T End, 
        ForwardIterator2T SearchBegin,
        ForwardIterator2T SearchEnd );

    <b>template</b>&lt; <b>typename</b> ForwardIterator1T, <b>typename</b> ForwardIterator2T &gt;
    <b>inline</b> iterator_range&lt;ForwardIterator1T&gt;
    <a href="#find_nth">find_nth</a>( 
        ForwardIterator1T Begin, 
        ForwardIterator1T End, 
        ForwardIterator2T SearchBegin,
        ForwardIterator2T SearchEnd,
        <b>unsigned</b> <b>int</b> Nth );

    <b>template</b>&lt; 
        <b>typename</b> ForwardIterator1T, 
        <b>typename</b> CharT, 
        <b>typename</b> RegexTraitsT, <b>typename</b> RegexAllocatorT&gt;
    <b>inline</b> iterator_range&lt;ForwardIterator1T&gt;
    <a href="#find_regex">find_regex</a>( 
        ForwardIterator1T Begin, 
        ForwardIterator1T End, 
        <b>const</b> reg_expression&lt;CharT, RegexTraitsT, RegexAllocatorT&gt;&amp; Rx,
        <b>unsigned</b> <b>int</b> MatchFlags=match_default );
}</pre>
    <p>
      Sequence based variants:
    </p>
    <pre> <b>namespace</b> boost {

    <b>template</b>&lt;<b>typename</b> InputT, <b>typename</b> SearchT&gt;
    <b>inline</b> iterator_range&lt;<b>typename</b> string_algo::input_policy&lt;InputT&gt;::iterator_type&gt;
    <a href="#find_first">find_first</a>( 
	InputT&amp; Input, 
        <b>const</b> SearchT&amp; Search );

    <b>template</b>&lt;<b>typename</b> InputT, <b>typename</b> SearchT&gt;
    <b>inline</b> iterator_range&lt;<b>typename</b> string_algo::input_policy&lt;InputT&gt;::iterator_type&gt;
    <a href="#find_last">find_last</a>( 
	InputT&amp; Input, 
        <b>const</b> SearchT&amp; Search );

    <b>template</b>&lt;<b>typename</b> InputT, <b>typename</b> SearchT&gt;
    <b>inline</b> iterator_range&lt;<b>typename</b> string_algo::input_policy&lt;InputT&gt;::iterator_type&gt;
    <a href="#find_nth">find_nth</a>( 
	InputT&amp; Input, 
        <b>const</b> SearchT&amp; Search,
	<b>unsigned</b> <b>int</b> Nth );</pre>
    <pre>    <b>template</b>&lt; 
        <b>typename</b> InputT, 
        <b>typename</b> CharT, 
        <b>typename</b> RegexTraitsT, <b>typename</b> RegexAllocatorT&gt;
    <b>inline</b> iterator_range&lt;<b>typename</b> string_algo::input_policy&lt;InputT&gt;::iterator_type&gt;
    <a href="#find_regex">find_regex</a>( 
        InputT&amp; Input, 
        <b>const</b> reg_expression&lt;CharT, RegexTraitsT, RegexAllocatorT&gt;&amp; Rx,
        <b>unsigned</b> <b>int</b> MatchFlags=match_default );
}</pre>
    <p>
      Parameters:
    </p>
    <table border="1" width="574" height="1">
      <tr>
        <td width="443" height="31" valign="top"><code><b>typename</b>
          ForwardIterator1T</code></td>
        <td width="703" height="31" valign="top">Forward iterator delimiting the
          input</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code><b>typename</b>
          ForwardIterator2T</code></td>
        <td width="703" height="31" valign="top">Forward iterator delimiting the
          search sequence</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code><b>typename</b> InputT</code></td>
        <td width="703" height="31" valign="top">Input sequence type (must
          satisfy the <a href="http://www.boost.org/libs/concept_check/reference.htm#container-concepts">ContainerConcept</a>)</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code><b>typename </b>SearchT</code></td>
        <td width="703" height="31" valign="top">Search sequence type (must
          satisfy the <a href="http://www.boost.org/libs/concept_check/reference.htm#container-concepts">ContainerConcept</a>)</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code>ForwardIterator1T Begin</code></td>
        <td width="703" height="31" valign="top">Begin of an input sequence</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code>ForwardIterator1T End</code></td>
        <td width="703" height="31" valign="top">End of an input sequence</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code>ForwardIterator2T</code><code>
          SearchBegin</code></td>
        <td width="703" height="31" valign="top">Begin of a search sequence</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code>ForwardIterator2T</code><code>
          SearchEnd</code></td>
        <td width="703" height="31" valign="top">End of a search sequence</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code>InputT&amp; Input</code></td>
        <td width="703" height="31" valign="top">An input sequence</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code><b>const</b> SearchT&amp;
          Search</code></td>
        <td width="703" height="31" valign="top">A search sequence</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code><b>unsigned</b> <b>int</b>
          Nth</code></td>
        <td width="703" height="31" valign="top">A number specifying which match
          is to be searched for.</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code><b>const</b>
          reg_expression&lt;CharT, RegexTraitsT, RegexAllocatorT&gt;&amp; Rx</code></td>
        <td width="703" height="31" valign="top">Regular expression used for
          searching. See <a href="http://www.boost.org/libs/regex/index.htm">Regex++
          documentation</a> for deails.</td>
      </tr>
      <tr>
        <td width="443" height="31" valign="top"><code><b>unsigned</b> <b>int</b>
          MatchFlags=match_default</code></td>
        <td width="703" height="31" valign="top">Match flags defining some
          properties of search. See <a href="http://www.boost.org/libs/regex/index.htm">Regex++
          documentation</a> for deails. algorithm.</td>
      </tr>
    </table>
    <h3><a name="ua_examples">Examples</a></h3>
    <p>
      Following example shows basic usage of predicate algorithms. More examples
      can be found in the library tests in <a href="../test/find_test.cpp">&lt;libs/string_algo/test/find_test.cpp&gt;</a>.
    </p>
    <pre>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;boost/string_algo/conv.hpp&gt;
#include &lt;boost/string_algo/find.hpp&gt;

using namespace std;
using namespace boost;

void find_example()
{  
    cout &lt;&lt; &quot;* Find Example *&quot; &lt;&lt; endl &lt;&lt; endl;

    string str1(&quot;abc___cde___efg&quot;);

    // find &quot;cde&quot; substring
    iterator_range&lt;string::iterator&gt; range=find_first( str1, string(&quot;cde&quot;) );

    // convert a substring to upper case 
    // note that iterator range can be directly passed to the algorithm
    toupper( range );

    cout &lt;&lt; &quot;str1 with upper-cased part matching cde: &quot; &lt;&lt; str1 &lt;&lt; endl;</pre>
    <pre>    cout &lt;&lt; endl;
}</pre>
    <hr>
    <h2><a name="iterator_range">Iterator_range class</a></h2>
    <h3><a name="iter_description">Description</a></h3>
    <p>
      <code>iterator_range</code> class is declared in <a href="../../../boost/string_algo/trim.hpp">&lt;boost/string_algo/iterator_range.hpp&gt;</a>
      header.<br>
      Many algorithms working with sequences take a pair of iterators,
      delimiting a working range, as an arguments. <code>iterator_range</code>
      class is an encapsulation of a range identified by a pair of iterators. It
      provides a subset of container ( see <a href="http://www.boost.org/libs/concept_check/reference.htm#container-concepts">ContainerConcept</a>
      )&nbsp; interface, so it is possible to pass an instance to an algorithm
      requiring a sequence as an input.&nbsp;
    </p>
    <h3><a name="iter_synopsis">Synopsis</a></h3>
    <pre><b>namespace</b> boost {

    <b>template</b>&lt; <b>typename</b> IteratorT &gt; 
    <b>class</b> iterator_range 
    {
    <b>public</b>:
        <b>typedef</b> iterator_range&lt;IteratorT&gt; type;
        <b>typedef</b> <b>typename</b> boost::detail::
            iterator_traits&lt;IteratorT&gt;::value_type value_type;
        <b>typedef</b> <b>typename</b> boost::detail::
            iterator_traits&lt;IteratorT&gt;::reference reference;
        <b>typedef</b> typename boost::detail::
            iterator_traits&lt;IteratorT&gt;::difference_type difference_type;
        <b>typedef</b> IteratorT const_iterator;
        <b>typedef</b> IteratorT iterator;</pre>
    <pre>        // Constructors
        iterator_range();
        iterator_range( iterator Begin, iterator End );
        iterator_range( <b>const</b> std::pair&lt;IteratorT,IteratorT&gt;&amp; Range );
        iterator_range( <b>const</b> iterator_range&amp; Other );
        <b>template</b>&lt; <b>typename</b> OtherItT &gt;
            iterator_range( <b>const</b> iterator_range&lt;OtherItT&gt;&amp; Other );

        // Assignment
        iterator_range&amp; operator=( <b>const</b> iterator_range&amp; Other );
        <b>template</b>&lt; <b>typename</b> OtherItT &gt;
            iterator_range&amp; operator=( <b>const</b> iterator_range&lt;OtherItT&gt;&amp; Other );

	// Comparison
        <b>template</b>&lt;<b>typename</b> OtherItT&gt; 
            <b>bool</b> <b>operator</b>==( <b>const</b> iterator_range&lt;OtherItT&gt;&amp; Other );
        <b>template</b>&lt;<b>typename</b> OtherItT&gt; 
            <b>bool</b> <b>operator</b>!=( <b>const</b> iterator_range&lt;OtherItT&gt;&amp; Other );

        // Access
	IteratorT begin() <b>const</b>;
        IteratorT end() <b>const</b>;
        <b>bool</b> empty() <b>const</b>;
        difference_type size() <b>const</b>;
    };
}</pre>
    <p>
      Class members:
    </p>
    <table border="1" width="742" height="1">
      <tr>
        <td width="644" height="31" valign="top"><code><b>typename</b> IteratorT</code></td>
        <td width="670" height="31" valign="top">An iterator type, to be
          contained by an&nbsp; <code>iteratator_range </code>class</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>type</code></td>
        <td width="670" height="31" valign="top">Self type</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>value_type</code></td>
        <td width="670" height="31" valign="top"><code>value_type</code> of the
          contained iterator</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>difference_type</code></td>
        <td width="670" height="31" valign="top"><code>difference_type</code> of
          the container iterator</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>const_iterator</code></td>
        <td width="670" height="31" valign="top"><code>const_iterator</code>
          type</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>iterator</code></td>
        <td width="670" height="31" valign="top"><code>iterator</code> type</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>iterator_range()</code></td>
        <td width="670" height="31" valign="top">Default constructor</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>iterator_range(<br>
          &nbsp;&nbsp;&nbsp; iterator Begin, iterator End);</code></td>
        <td width="670" height="31" valign="top">Constructor from a pair of
          iterators</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>iterator_range(<b><br>
          &nbsp; const</b> std::pair&lt;IteratorT,IteratorT&gt;&amp; Range);</code></td>
        <td width="670" height="31" valign="top">Construction from <code>std::pair&lt;&gt;.
          </code>Useful when interoperating with some STL algoritms.</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>iterator_range( <b>const</b>
          iterator_range&amp; Other );<br>
          <b>template</b>&lt;<b>typename</b> OtherItT&gt;<br>
          &nbsp;&nbsp;&nbsp; iterator_range(<b><br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</b>
          iterator_range&lt;OtherItT&gt;&amp; Other);</code></td>
        <td width="670" height="31" valign="top">Copy constructors. Templated to
          make possible a conversion between const_iterator and iterator types</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>iterator_range&amp;
          operator=(<br>
          &nbsp;&nbsp;&nbsp; <b>const</b> iterator_range&amp; Other);<br>
          <b>template</b>&lt; <b>typename</b> OtherItT &gt;<br>
          &nbsp;&nbsp;&nbsp; iterator_range&amp; operator=(<b><br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</b>
          iterator_range&lt;OtherItT&gt;&amp; Other);</code></td>
        <td width="670" height="31" valign="top">Assignment. Templated to make
          possible a conversion between const_iterator and iterator types</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code><b>bool</b> <b>operator</b>==(<br>
          &nbsp; <b>const</b> iterator_range&lt;OtherItT&gt;&amp; Other)<b><br>
          bool</b> <b>operator</b>!=(<br>
          &nbsp; <b>const</b> iterator_range&lt;OtherItT&gt;&amp; Other)</code></td>
        <td width="670" height="31" valign="top">Comparison operators.</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>IteratorT begin() <b>const</b></code></td>
        <td width="670" height="31" valign="top">Returns first iterator from the
          range</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>IteratorT end() <b>const</b></code></td>
        <td width="670" height="31" valign="top">Returns second iterator from
          the range</td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code><b>bool</b> empty() <b>const</b></code></td>
        <td width="670" height="31" valign="top">Check if the range is empty.<br>
          <code>begin()==end()</code></td>
      </tr>
      <tr>
        <td width="644" height="31" valign="top"><code>difference_type size() <b>const</b></code></td>
        <td width="670" height="31" valign="top">Returns the distance between
          iterators.<br>
          <code>std::distance(begin(), end())</code></td>
      </tr>
    </table>
    <hr>
    <h2><a name="rationale">Rationale</a></h2>
    <h3><a name="rational_usability">Usability</a></h3>
    <p>
      Find algorithms have similar functionality to of <code>std::search</code>
      algorithm. They provide different interface which is more suitable for
      common string operations.
    </p>
    <p>
      Instead of returning just the start of matching subsequence they return a
      range, which is more convinient. This feature also allows a partitioning
      of&nbsp; the input sequence into three parts: prefix, substring and
      suffix.&nbsp;<br>
      <br>
      Besides of the iterator-based variant, there are also variants which
      accept a container as an input. It is more convinient to write&nbsp; <code>find_first(
      str1, str2 )</code> then <code>find_first( str1.begin(), str1.end(),
      str2.begin(), str2.end() )</code>
    </p>
    <p>
      Another difference is an addition of various searching methods besides <code>find_first</code>,
      including <code>find_regex</code>.
    </p>
    <h3><a name="rationale_efficiency">Efficiency considerations</a></h3>
    <p>
      Currently the library contains only naive implementation of find algoritms
      with complexity O(n * m) where n is the size of the input sequence and m
      is the size of the seach sequence. There are algorithms with complexity
      O(n), but for smaller sequence a contant overhead is rather big. For small
      m &lt;&lt; n current implementation provides acceptable efficiency. Even
      C++ standard defines a required complexity for search algorithm only O(n *
      m).
    </p>
    <p>
      It is possible that feature version of library will contain also algoritms
      with linear complexity as an option.
    </p>
    <hr>
    <p>
      (C) Copyright Pavol Droba 2003. Permission to copy, use, modify, sell and
      distribute this software is granted provided this copyright notice appears
      in all copies. This software is provided &quot;as is&quot; without express
      or implied warranty, and with no claim as to its suitability for any
      purpose.
    </p>

  </body>

</html>
