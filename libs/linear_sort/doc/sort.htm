<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.2.20 i686) [Netscape]">
   <title>Linear Sort Library</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<h1>
<img SRC="c++boost.gif" ALT="C++ Boost" height=86 width=277>Boost Linear
Sort Library</h1>
<a NAME="Synopsis"></a>Synopsis
<pre>#include <a href="property_map.htm">&lt;boost/linear_sort/property_map.hpp>
</a>#include <a href="counting_sort.htm">&lt;boost/linear_sort/counting_sort.hpp>
</a>#include <a href="radix_sort.htm">&lt;boost/linear_sort/radix_sort.hpp>
</a>#include <a href="block_sort.htm">&lt;boost/linear_sort/block_sort.hpp></a></pre>

<pre>namespace boost {

&nbsp; // straight versions
&nbsp; template &lt;class RandomAccessIterator>
&nbsp; void sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator>
&nbsp; void sort_copy&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator>
&nbsp; void indirect_sort(RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result);

&nbsp; // predicate versions
&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class BinaryPredicate>
&nbsp; void sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BinaryPredicate compare);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class BinaryPredicate>
&nbsp; void sort_copy&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BinaryPredicate compare);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class BinaryPredicate>
&nbsp; void indirect_sort(RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BinaryPredicate compare);

} // namespace boost</pre>

<h3>
<a NAME="Algorithms"></a>Algorithms</h3>
All the template parameters have name which reflect the concept they should
model, except for <tt>OutputRandomAccessIterator</tt>. The name <tt>OutputRandomAccessIterator</tt>
reflects the fact that the output is a mutable random access iterator of
different type than the input's <tt>RandomAccessIterator</tt>. Unlike output
iterators, it has a value type. Like output iterators, we would like to
guarantee that each iterator in the output range is written to only once
(but this could be in any order). Unfortunately, this conflicts with efficiency.
If this were a requirement, then indeed there would be no need for sort_copy,
as it would be equivalent to sort (in place) followed by copy.
<p>There are three algorithms. <tt>Sort</tt> has the same interface as
in the C++ STL, and does not require extra memory (that is, it may use
extra memory to speed up the algorithm, but does not rely on it; specifically,
this is achieved by using a temporary buffer). It simply reorders the elements
of the range so that they are in sorted order.
<p><tt>Sort_copy</tt> is an extension which takes a range and outputs the
sorted range at the location given by <tt>result</tt>. The value type of
result has to assignable from the input. Interestingly, we don't require
that it be the same, that is, we allow sort_copy to cast the input into
a different type. This may provide a mechanism for various interesting
side-effects. Unlike the <tt>_copy</tt> algorithms, <tt>sort_copy</tt>
may reorder the input range (this depends on which algorithm is used internally).
<p>Indirect_sort (which should really be called indirect_sort_copy, except
that indirect_sort in that case would make no sense) is a variant in which
the output random access iterator has a value type which is the same (or
assignable from) the input <tt>RandomAccessIterator</tt>. It should be
preferred to sort or sort_copy when copying an object is much more expensive
than copying an iterator referencing this object. Indirect sort could easily
be achieved by first copying the range of input iterators into the output,
then sorting with a comparison object that performs one extra level of
indirection.
<h3>
<a NAME="Examples"></a>Examples</h3>
The first example illustrates the various ways to sort an sequence of integers:
<pre>&nbsp; using namespace std;
&nbsp; size_t array_size = 1000000; // one million elements</pre>

<pre>&nbsp; // Example with vector of integers (4 bytes
&nbsp; vector&lt; int > v(array_size), w(array_size, 0);
&nbsp; generate(v.begin(), v.end(), rand());</pre>

<pre>&nbsp; // Sort vector of integers
&nbsp; copy(v.begin(), v.end(), w.begin());
&nbsp; boost::sort(w.begin(), w.end());</pre>

<pre>&nbsp; // Copy sort vector of integers, should yield same result
&nbsp; boost::sort_copy(v.begin(), v.end(), w.begin());</pre>
The second example takes a sequence of arrays. We choose to use <tt>boost::array</tt>
instead of the builtin array types because it plays better with some implementations
of <tt>std::sort</tt> (especially the SGI STL):
<pre>&nbsp; // Example with vector of arrays (unsigned char [4])
&nbsp; typedef boost::array&lt;unsigned char,4> array_t;
&nbsp; vector&lt; array_t > va(array_size/4), wa(array_size/4, 0);</pre>

<pre>&nbsp; // Fill up vector of arrays
&nbsp; for (iterator it = va.begin(); it != va.end(); ++it)
&nbsp;&nbsp;&nbsp; for (unsigned i = 0; i &lt; 4; ++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*it)[i] = (unsigned char) rand();</pre>

<pre>&nbsp; // Sort vector of arrays
&nbsp; copy(va.begin(), va.end(), wa.begin());
&nbsp; boost::sort(wa.begin(), wa.end());</pre>

<pre>&nbsp; // Copy sort vector of integers, should yield same result
&nbsp; boost::sort_copy(va.begin(), va.end(), wa.begin());</pre>
Finally, assume we have a collection of records from a database and wish
to sort them by age.
<br>&nbsp;
<p>
<hr>
<table>
<tr VALIGN=TOP>
<td NOWRAP>Copyright &copy; 2002</td>

<td>Herve Bronnimann, Polytechnic University.</td>
</tr>
</table>

</body>
</html>
