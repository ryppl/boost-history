<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.2.20 i686) [Netscape]">
   <title>Linear Sort Library</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<h1>
<img SRC="c++boost.gif" ALT="C++ Boost" height=86 width=277><a NAME="sec:linear_sort"></a>Boost
Linear Sort Library</h1>

<ol>
<li>
<a href="#Introduction">Introduction</a></li>

<li>
<a href="#Algorithms">Algorithms</a></li>

<li>
<a href="#Examples">Examples</a></li>

<li>
<a href="#Rationale">Rationale</a></li>

<li>
<a href="#Performance">Performance</a></li>

<li>
<a href="#History">History</a></li>

<li>
<a href="#Acknowledgements">Acknowledgements</a></li>

<li>
<a href="#Notes">Notes to Implementors</a></li>
</ol>

<h3>
<a NAME="Introduction"></a>Introduction</h3>
The Boost Linear Sort Library is a library that provides faster sorting
algorithms than usually offered by the STL sort algorithm. The linear time
sorting algorithms come in mainly three flavors: counting sort, radix sort,
and block sort. <a href="counting_sort.htm">Counting sort</a> applies to
types which have a small range (typically one byte). <a href="radix_sort.htm">Radix
sort</a> is effective for slightly larger type (up to four bytes) but not
much larger (for instance array types). <a href="block_sort.htm">Block
sort</a> requires a bit more temporary memory than radix sort, but is usually
more efficient since it performs always as few comparisons as the sort
with lexicographical compare.
<p>All these algorithms are provided in three interfaces: normal (just
like with <tt>std::sort</tt>, the input range is reordered but this does
not mean that only swaps are performed), <tt>..._copy</tt> (the sorted
range is placed in a separate location by means of a random-access output
iterator whose value type is the same as that of the input iterator), and
<tt>indirect_...</tt>
(same as copy but the output iterator's value type is the input iterator;
hence the output consists of a sequence of iterators which point to the
elements in order).
<p>In addition to these specialized algorithms, the library offers <a href="sort.htm">three
general algorithms</a> which have the same interface as the STL, but try
to dispatch to the above algorithms whenever this yields increased performance.
If no appropriate specialization is found, the STL algorithms are used
<h3>
<a NAME="Algorithms"></a>Algorithms</h3>
The library is accessible by including one single header <a href="sort.htm">&lt;boost/linear_sort.hpp></a>.
In addition, for users who only require a single algorithm, there are four
headers which can be included separately:
<blockquote>
<li>
<a href="property_map.htm">&lt;boost/linear_sort/property_map.hpp></a>
provides the property maps <tt>linear_sort_identity_property_map</tt>,
<tt>nth_radix_property_map</tt>,
<tt>nth_element_property_map</tt>,
<tt>dereference_property_map</tt>,
as well as a comparison object adaptor
<tt>linear_sort_property_map_cmp</tt>.</li>

<li>
<a href="couting_sort.htm">&lt;boost/linear_sort/couting_sort.hpp></a>
provides the algorithms <tt>counting_sort</tt>, <tt>counting_sort_copy</tt>,
and <tt>indirect_counting_sort</tt>.</li>

<li>
<a href="radix_sort.htm">&lt;boost/linear_sort/radix_sort.hpp></a> provides
<tt>radix_sort</tt>,
<tt>radix_sort_copy</tt>,
and <tt>indirect_radix_sort</tt>.</li>

<li>
<a href="block_sort.htm">&lt;boost/linear_sort/block_sort.hpp></a> provides
<tt>block_sort</tt>,
<tt>block_sort_copy</tt>,
and <tt>indirect_block_sort</tt>.</li>
</blockquote>

<h3>
<a NAME="Examples"></a>Examples</h3>
The first example illustrates the various ways to sort an sequence of integers:
<pre>&nbsp; using namespace std;
&nbsp; size_t array_size = 1000000; // one million elements</pre>

<pre>&nbsp; // Example with vector of integers (4 bytes
&nbsp; vector&lt; int > v(array_size), w(array_size, 0);
&nbsp; generate(v.begin(), v.end(), rand());</pre>

<pre>&nbsp; // Sort vector of integers
&nbsp; copy(v.begin(), v.end(), w.begin());
&nbsp; boost::sort(w.begin(), w.end());</pre>

<pre>&nbsp; // Copy sort vector of integers, should yield same result
&nbsp; boost::sort_copy(v.begin(), v.end(), w.begin());</pre>

<pre>&nbsp; // Radix sort vector of integers (forces implementation of sort)
&nbsp; copy(v.begin(), v.end(), w.begin());
&nbsp; boost::radix_sort(w.begin(), w.end());</pre>

<pre>&nbsp; // Same result, a tad faster, no extra memory allocation
&nbsp; boost::radix_sort_copy(v.begin(), v.end(), w.begin());</pre>
The second example takes a sequence of arrays. We choose to use <tt>boost::array</tt>
instead of the builtin array types because it plays better with some implementations
of <tt>std::sort</tt> (especially the SGI STL):
<pre>&nbsp; // Example with vector of arrays (unsigned char [4])
&nbsp; typedef boost::array&lt;unsigned char,4> array_t;
&nbsp; vector&lt; array_t > va(array_size/4), wa(array_size/4, 0);</pre>

<pre>&nbsp; // Fill up vector of arrays
&nbsp; for (iterator it = va.begin(); it != va.end(); ++it)
&nbsp;&nbsp;&nbsp; for (unsigned i = 0; i &lt; 4; ++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*it)[i] = (unsigned char) rand();</pre>

<pre>&nbsp; // Sort vector of arrays
&nbsp; copy(va.begin(), va.end(), wa.begin());
&nbsp; boost::sort(wa.begin(), wa.end());</pre>

<pre>&nbsp; // Copy sort vector of integers, should yield same result
&nbsp; boost::sort_copy(va.begin(), va.end(), wa.begin());</pre>

<pre>&nbsp; // Radix sort vector of integers (forces implementation of sort)
&nbsp; copy(va.begin(), va.end(), wa.begin());
&nbsp; boost::radix_sort(wa.begin(), wa.end());</pre>

<pre>&nbsp; // Same result, a tad faster, no memory allocation
&nbsp; boost::radix_sort_copy(va.begin(), va.end(), wa.begin());</pre>

<pre>&nbsp; // Sorting along second element of array (index 1)
&nbsp; boost::nth_element_property_map&lt;array_t,unsigned char> projection(1);
&nbsp; boost::counting_sort(va.begin(), va.end(), projection);</pre>

<h3>
<a NAME="Rationale"></a>Rationale</h3>
The standard offers no sort_copy algorithm, since it argues that it is
just as easy to use copy into the output range and then perform sort. I
regret that decision, because it prevents the standard library algorithm
implementers to do counting sort for an array of shorts, for instance.
The reason is that this algorithm is inherently not in place, and requires
separate buffers for input and output. It is, however, significantly more
efficient that the usual comparison-based sort. That's why I decided to
provide sort_copy.
<p>For similar reasons, it is advantageous to have indirect_sort, as opposed
to simply initializing an array of pointers and sorting it. The main reason
to use indirect_sort is when copying the objects is expensive. (Imagine
sorting an array of student records by, say, grade or age.) In this case,
the only copies performed is of pointers to the objects. Also, in case
of shorting a very small type (suitable for counting sort) indirect_sort
outputs the pointers directly.
<h3>
<a NAME="Performance"></a>A note on performance</h3>
I started this project with the idea that radix sort would be faster than
the sort function of the STL for usual types (integers, floats, doubles).
In fact, it's not quite clear which is faster for sizes up to a few millions.
The big payoff is when sorting a container of records on a few keys (by
radix sort). Otherwise, radix sort is not that fast because it makes copies
of the output for every radix. There needs to be further optimization of
this. Also block sort might be more efficient than radix sort.
<h3>
<a NAME="Acknowledgements"></a>Acknowledgements</h3>
The library started as a final project in my class CS903 (C++ STL and Algorithm
Libraries).&nbsp; Thanks to my CS903 student Peter Koo for starting on
this project. After Peter Koo finished his project, I started to experiment
and see if I could get the same interface as <tt>std::sort</tt>. The main
motivation for the linear sorting library was to see if it is possible
to beat a carefully crafted implementation of <tt>std::sort</tt> for the
builtin types, which usually is comparison-based and hence performs Omega(n
log n) comparisons. This led me to provide the peroperty maps, reimplement
counting and radix sort, and experiment with block sorting.
<h3>
<a NAME="Notes"></a>Notes to Implementors</h3>
Copying a property map should be inexpensive since they are often passed
by value.
<br>
<hr>
<table>
<tr VALIGN=TOP>
<td NOWRAP>Copyright &copy; 2002</td>

<td>Herve Bronnimann, Polytechnic University.</td>
</tr>
</table>

</body>
</html>
