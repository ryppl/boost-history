<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.2.20 i686) [Netscape]">
   <title>Linear Sort Library</title>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<h1>
<img SRC="c++boost.gif" ALT="C++ Boost" height=86 width=277>Boost Linear
Sort Library</h1>

<h1>
Radix Sort</h1>
<a NAME="Synopsis"></a>Synopsis
<pre>#include <a href="property_map.htm">&lt;boost/linear_sort/property_map.hpp></a></pre>

<pre>namespace boost {

&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( unsigned char );
&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( signed char );
&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( unsigned short );
&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( signed short );
&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( unsigned int );
&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( signed int );
&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( unsigned long );
&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( signed long );
&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( float );
&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( double );
&nbsp; BOOST_DECLARE_RADIX_SORT_TYPE( long double );

&nbsp; BOOST_DECLARE_RADIX_SORT_TEMPLATE_1_2( class T, std::size_t N , T[N] );
#ifdef BOOST_ARRAY_HPP
&nbsp; BOOST_DECLARE_RADIX_SORT_TEMPLATE_2( class T, std::size_t N , ::boost::array&lt;T,N>&nbsp; );
#endif

&nbsp; // straight versions
&nbsp; template &lt;class RandomAccessIterator>
&nbsp; void radix_sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last);

&nbsp; template &lt;class RandomAccessIterator,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator>
&nbsp; void radix_sort_copy&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator>
&nbsp; void indirect_radix_sort(RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result);

&nbsp; // predicate versions
&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class BinaryPredicate>
&nbsp; void radix_sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BinaryPredicate compare)

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class BinaryPredicate>
&nbsp; void radix_sort_copy&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BinaryPredicate compare);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class BinaryPredicate>
&nbsp; void indirect_radix_sort(RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BinaryPredicate compare);

} // namespace boost</pre>

<h3>
<a NAME="Algorithms"></a>Algorithms</h3>
The basic radix sort algorithm is radix_sort, as explained e.g. in <a href="http://theory.lcs.mit.edu/~clr/">Introduction
to Algorithms (Cormen Leiserson, Rivest, Stein, 2nd Edition)</a>. The number
of radices is deduced from the value type of the iterator, or in the second
case, from the value type of the projection map. Radix sort uses an extra
buffer, while radix_sort_copy uses both the input and the output. Both
algorithms copy back and forth between the two buffers (and perform an
extra copy if the number of radices is odd for radix_sort_copy, or even
for radix_sort).
<p>Radix sort is recursive, that is, if trying to sort an array of integers,
it performs a pass on each component, and within each integer, it also
performs 4 passes of counting sort (or 2 if short is chosen as the base
type, but I am having problem debugging this).
<p>The macro BOOST_DECLARE_RADIX_SORT_TYPE is used to declare what types
should be usable by counting_sort. If the type is a template, then useBOOST_DECLARE_RADIX_SORT_TEMPLATE_N
instead (with _N being _2 if there are two template parameters, or _3,
_4). The BOOST_DECLARE_RADIX_SORT_TEMPLATE_1_2 is used only for declaring
builtin arrays (in that case, the class name does not contain a comma,
which reduces the number of arguments of the macro).
<p>The default is as specified above, but the user may add more types.
If <tt>&lt;boost/array.hpp></tt> is already included, then <tt>boost::array
</tt>is
also supported. Among the types that should be supported are
<tt>boost::tuple</tt>,
standard containers (but there are some issues if the size is shorter than
the number of radices), and std::string (same issues).
<h3>
Implementation notes</h3>
Radix sort is usually about as efficient as std::sort, but can easily be
worse when the number of radices is large (hence many passes are needed).
There are a few optimizations which have not been tried yet: don't do a
copy if all values are identical during a radix pass; also try to compute
the counters in a single pass instead of within each pass (requires an
internal version of couting_sort which does this); try to choose radix
base (char or short) depending on the number of elements in the range.
<h3>
<a NAME="Examples"></a>Examples</h3>
The first example illustrates the various ways to sort an sequence of integers:
<pre>&nbsp; using namespace std;
&nbsp; size_t array_size = 1000000; // one million elements</pre>

<pre>&nbsp; // Example with vector of integers (could use float, double, etc.)
&nbsp; vector&lt; integer > v(array_size), w(array_size, 0);
&nbsp; generate(v.begin(), v.end(), rand());</pre>

<pre>&nbsp; // Sort vector of integers (needs a temporary buffer, otherwise use std::sort)
&nbsp; copy(v.begin(), v.end(), w.begin());
&nbsp; boost::radix_sort(w.begin(), w.end());</pre>

<pre>&nbsp; // Copy sort vector, should yield same result (but no temporary buffer)
&nbsp; boost::radix_sort_copy(v.begin(), v.end(), w.begin());</pre>
The second example takes a sequence of arrays. We choose to use <tt>boost::array</tt>
instead of the builtin array types because it plays better with some implementations
of <tt>std::sort</tt> (especially the SGI STL):
<pre>&nbsp; // Example with vector of arrays (unsigned char [4])
&nbsp; typedef boost::array&lt;unsigned char,4> array_t;
&nbsp; vector&lt; array_t > va(array_size/4), wa(array_size/4, 0);</pre>

<pre>&nbsp; // Fill up vector of arrays
&nbsp; for (iterator it = va.begin(); it != va.end(); ++it)
&nbsp;&nbsp;&nbsp; for (unsigned i = 0; i &lt; 4; ++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*it)[i] = (unsigned char) rand();</pre>

<pre>&nbsp; // Sort vector of arrays (will use temporary buffer)
&nbsp; copy(va.begin(), va.end(), wa.begin());
&nbsp; boost::radix_sort(wa.begin(), wa.end());</pre>

<pre>&nbsp; // Copy sort vector of arrays, should yield same result (no temporary buffer)
&nbsp; boost::radix_sort_copy(va.begin(), va.end(), wa.begin());</pre>

<hr>
<table>
<tr VALIGN=TOP>
<td NOWRAP>Copyright &copy; 2002</td>

<td>Herve Bronnimann, Polytechnic University.</td>
</tr>
</table>

</body>
</html>
