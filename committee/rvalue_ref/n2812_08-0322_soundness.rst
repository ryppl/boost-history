===================================================================
 A Safety Problem with RValue References (and what to do about it)
===================================================================

:Author: David Abrahams, Doug Gregor
:Contact: dave@boostpro.com, doug.gregor@gmail.com
:organization: `BoostPro Computing`_, Apple Computer
:date: 2008-12-05

:Number: n2812=08-0322

.. _`BoostPro Computing`: http://www.boostpro.com

.. contents:: index

-----------------
 Working Section
-----------------

Outline
=======

* Description of problem
* Proposed fix
* Impact of fix
* Implementation Experience
* Pro/con arguments?

Status of This Document
=======================

Currently aggregating comments from a long discussion thread starting
Sept. 19 2008 and just trying to make sure all the important material
is at hand.  We will incorporate this material in the main text next.

Miscellaneous Remarks and Notes
===============================

I've tried to bold-ify what I think are the essential points below

* Peter 
  Dimov:

    I think that we don't need idiom 2 [where we want to modify the
    argument regardless of whether it turns out to be an rvalue] that
    much. If we're going to change && to not bind to lvalues, the
    **principled approach would be to omit the &&& at all**. Yes, idiom 2
    does have its uses, but it also has shown an ability to bite us
    **(issue 884)**.

    I also note that **making && bind only to rvalues probably settles
    the question of whether auto&& should apply the deduction rule** -
    it wouldn't work for lvalues if it did not.

    We'll need some additional wording to **keep std::move working**;
    it binds an rvalue reference to an lvalue.

    **I find the original motivating example (where the
    CopyConstructible concept requirement causes the const& overload
    to be dropped) much better, because it represents neither a
    mistake nor an oversight.**

    The std::move implementation takes advantage of the fact that T&&
    can bind to an lvalue t. The binding can be made explicit, via
    static_cast, but **a blank prohibition could render even that
    illegal.**

    FWIW, **the && change does not affect the three overload free
    swap. It only affects the single &&-taking member swap.**

    Also FWIW, and IMHO, swapping with an rvalue is an anti-idiomatic
    way to express move assignment. **If people feel the need to use
    swap in this way, there's something wrong with the move assignment
    operator for the type.**


* The first version of the paper mentioned back_insert_iterator and
  how the simple workaround for a problem prevents using it with
  initializer lists, something Doug apparently understood.  Worth
  mentioning?

* There was a vote in LWG to roll all swap functions back to the
  single (T&,T&) form because of issue 884.  However, for bureaucratic
  reasons I'm not sure if that vote had any legal force, so we may
  need to do something about it.


-----------------
 Written Section
-----------------

Synopsis
========

This paper describes a safety problem with rvalue references.  The underlying
issue has been known for some time, but recently-discovered examples have made
its seriousness much more apparent.  We also propose a solution to the problem.

Example
=======

Consider::

  template <class T>
  void assign(queue<T>& dest, std::vector<T> const& src); // #1: copy src into dest

  std::vector<int> x;
  queue<int> q;

  assign(q, x);                                    // case A: copy from lvalue
  assign(q, std::vector<int>(10));                 // case B: copy from rvalue


The Move/Copy Overload Idiom
============================

Case B above can be optimized using move semantics.  The idea is to
transfer ownership of the vector's contents into ``q`` instead of
allocating new memory and making a copy.  We can do that in case B
because the vector is an unnamed temporary and thus inaccessible and
invisible to the rest of the program.  If we steal from an rvalue,
nobody can know the difference: that's the key to move semantics.

To add move semantics, we add an ``assign`` overload version that
takes its second parameter by rvalue reference::

  template <class T>
  void assign(queue<T>& dest, std::vector<T>&& src); // #2: move from src into dest

This idiom relies on the presence of *both* overloads.  Overload #2
makes it move, but overload #1 makes it safe.  Without overload
#1, assign will move from lvalues, silently turning a logically
non-mutating operation into a mutating one.

How Move-Only Types Work
========================

A movable but non-copyable argument type follows the same binding pattern as
std::vector<int> does: rvalue arguments, which can be safely moved from, select
overload #2::

  queue<move_only_type> q2;
  assign(q2, vector<move_only_type>());

As before, lvalue arguments select overload #1::

  vector<move_only_type> y;
  assign(q2, y);

However, since the argument type is noncopyable, the body of #1 fails
compilation (as desired) when it attempts to make a copy.

The Problem
===========

The problem is that the lvalue/rvalue overload set doesn't degrade safely.  If
overload #1 is removed from consideration, overload #2 will match both rvalues
and lvalues, moving silently from all mutable arguments.

When Will That Happen? 
======================

There are a number of possible reasons for such a removal, but simple programmer
blunders may be the most likely causes.  For example, an errant finger might hit
the delete key when overload #1 is selected.  

Some mistakes are not nearly so obvious.  For example, suppose we want the
ability to control allocation when we know the source container is going to be
copied.  We might modify overload #1 as follows::

  // #1 with optional allocator
  template <class T>
  void assign(queue<T>& dest, Cont const& src, 
              typename Cont::allocator_type = typename Cont::allocator_type());


.. Warning:: The **above is still wrong** because of the deduction
   rule!!  The rest of the document **still needs to be fixed** so
   that we're not using a bare ``Cont`` argument!!

For all container types that provide a suitable nested allocator_type,
all is well. However, if the container type does not provide a nested
allocator_type, SFINAE eliminates overload #1, causing overload #2 to
silently move from lvalues.

Adding Concept Constraints
==========================

To use our assign function in a constrained context, we'll need to add
concept constraints for the operations performed in the function body::

  template <class Cont>
  requires CopyAssignable<Cont>
  void assign(queue<Cont>& dest, Cont const& src);  #1

  template <class Cont>
  requires MoveAssignable<Cont>
  void assign(queue<Cont>& dest, Cont&& src);       #2

Passing an argument that doesn't meet the CopyAssignable constraint causes
overload #1 to be removed via SFINAE.  In other words, *any* move-only argument,
even an lvalue, will select overload #2... and silently move from lvalues.


Why This Happens
================

There is no precedent in const-correct code for a non-mutating call to become
mutating when an overload is removed from the set.  So why does it happen here?

In C++03 overload sets where only one overload mutates data (see
set<T>::operator[]), the mutating operation always binds less-liberally to
arguments than the non-mutating operation.  Non-const operations never attract
const arguments.  Rvalue references, however, *will* attract lvalues.

.. Admonition:: Doug Writes

  I fear that this paragraph is only understood by the people CC'd on
  this e-mail. In fact, I would probably remove this entire
  subsection.  It *could* be a discussion of the philosophy that
  parameters should only permit arguments that are "safe", and that
  the presence of additional overloads is never a safe way to control
  what arguments a certain parameter permits. C++03 followed this
  philosophy, but rvalue references did not.


Proposed Solution
=================

Because an rvalue reference in a function signature is used as a signal that we
can move, lvalues must not be allowed to bind to rvalue references.  

.. Admonition:: Doug Writes

  Most readers will need more dots connected for them: it means that
  overload #2 can never be called with an lvalue, regardless of
  whether #1 is present or not. As noted before, users can certainly
  explicitly call std::move to force moving from an lvalue.

Note: this change does not impact perfect forwarding.

  template <class T>
  void f(T&& x) { ... forward<T>(x) ... }

When an lvalue of type U is passed to f, T is deduced as U&, and since U& && is
U&, the actual reference being bound is an lvalue reference.

Impact
======

The existing definition of std::move takes advantage of the current liberal
binding rule, so we'd need to add an overload to support lvalues:

.. Admonition:: Doug Sez

  ::

  > On Sep 24, 2008, at 2:06 PM, David Abrahams wrote:
  >> on Wed Sep 24 2008, Doug Gregor <dgregor-AT-osl.iu.edu> wrote:
  >>> That's
  >>>
  >>> 	template <class T> T&& move(T& t) { return static_cast<T&&>(t); }
  >>>
  >>> without concepts and
  >>>
  >>> 	template <RvalueOf T> RvalueOf<T>::type move(T& t) 
  >>>     { return static_cast<RvalueOf<T>::type>(t); }
  >>>
  >>> with concepts, IIUC.
  >>
  >> Hmm, if we change the argument above to T&&, couldn't we write move
  >> with just this single function?
  >
  > Oh, right. Be sure to put the remove_reference back into the non-
  > concepts version. I momentally forgot about the T&& deduction rule.

We'd also need to decide whether it makes sense to preserve the new
functionality supporting rvalue streams.  If so, all the streaming
operators that were changed for C++0x to take an rvalue reference
first argument would need a second overload.  If not, we should revert
these operators to their original definitions.

.. Admonition:: Doug Sez:

  *I* know this paragraph means, but most readers won't. Please show
  the use of && in the declaration of operator<<, and how it affects
  user code.

  Also, we've changed the &'s to &&'s in a lot of member swap()s
  throughout the library. Those will need to revert back, or be
  overloaded with & and && versions.

  Plus, the new Iterator concept is affected by this change. It'll
  need another overload::

          reference operator*(Iter&);

  to handle dereferencing lvalues.

