<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>Rvalue References and Exception Safety</title>
</head>

<body>
<h1>Rvalue References and Exception Safety</h1>

<p>Authors: Douglas Gregor, David Abrahams<br>
Contact: doug.gregor@gmail.com, dave@boostpro.com<br>
Organization: Apple, BoostPro Computing<br>
Date: 2009-03-07<br>
Number: D2855=09-0045</p>

<h2 id="intro">Introduction</h2>

<p>This paper describes a problem with rvalue references that
compromises the exception safety guarantees made by the Standard
Library. In particular, well-formed C++03 programs, when compiled with
the C++0x Standard Library, can no longer rely on the strong exception
safety guarantee provided by certain standard library containers. This silent
change in behavior makes it nearly impossible to use these containers in applications that must recover from exceptions thrown by
the library. In this paper, we characterize the problem itself and
outline a potential solution that extends the language and modifies
the library.</p>

<h2 id="review">Review of Exception Safety Guarantees in the
Library</h2>

<p>Within the library, we characterize the behavior of a function with
respect to exceptions based on the guarantees that the implementation
must provide if an exception is thrown. These guarantees describe the
state of the program once a thrown exception has unwound the stack
past the point of that function. We recognize three levels of exception
safety guarantees for a given library function:

<dl>
  <dt>Basic exception guarantee</dt>
  <dd>The invariants of the component are preserved, and no resources are leaked.</dd>

  <dt>Strong exception guarantee</dt>
  <dd>The operation has either completed successfully or thrown an exception, leaving the program state exactly as it was before the operation started.</dd>

  <dt>No-throw guarantee</dt>
  <dd>The operation will not throw an exception.</dd>
</dl>

<p>The Standard Library provides at least the basic exception
guarantee throughout, which has not changed with the introduction of
rvalue references. Some functions of the library provide the strong
exception guarantee, such as insertion in most containers
(23.1.1p10).</p>

<h2 id="problem">The Problem</h2>

<p>The problem addressed by this paper is two-fold. First, for some
functions that are specified with the strong exception guarantee, it
is not possible to implement the strong exception guarantee if there
exist any move constructors that throw exceptions. Second, although the C++0x standard library prohibits the use of move constructors in certain places, the C++0x Standard Library itself may provide move constructors that can throw exceptions.

<h3 id="throwing-move-constructor">The Problem With Throwing Move Constructors</h3>

<p>As an example,
we consider <code>vector</code>'s <code>push_back</code> operation,
e.g.,</p>

<pre>
vec.push_back(x);
</pre>

<p>In the call to <code>push_back</code>, if the size of the
<code>vector</code> is the same as it's capacity, we will have to
allocate more storage for the <code>vector</code>. In this case, we
first allocate more storage and then "move" the contents from the old
storage into the new storage. Finally, we copy the new element into
the new storage and, if everything has succeeded, free the old
storage. The reallocation routine looks something like this:</p>

<pre>
T* reallocate(T *old_ptr, size_t old_capacity) {
  // #1: allocate new storage
  T* new_ptr = (T*)malloc(sizeof(T) * old_capacity * 2);
  if (new_ptr == NULL)
    throw std::bad_alloc();

  // #2: try to move the elements to the new storage
  unsigned i = 0;
  try {
    // #2a: construct each element in the new storage from the corresponding
    // element in the old storage, treating the old elements as rvalues
    for (; i &lt; old_capacity; ++i)
      new (new_ptr + i) T(std::move(old_ptr[i])); // "move" operation
  } catch (...) {
    // #2b: destroy the copies and deallocate the new storage
    for (unsigned v = 0; v &lt; i; ++v)
      new_ptr[v]-&gt;~T();
    free(new_ptr);
    throw;
  }

  // #3: free the old storage
  for (i = 0; i &lt; old_capacity; ++i)
    old_ptr[i]-&gt;~T();
  free(old_ptr);
  return new_ptr;
}
</pre>

<p>For this discussion we are interested in section #2, which handles the movement of values from the old storage to the new storage. The use of <code>std::move</code> treats the elements in the old storage as rvalues, enabling a move constructor (if available) or falling back to a copy constructor (if no move constructor is available) with the same syntax.</p>

<p>Consider reallocation of the vector when the type stored in the vector provides only a copy constructor (and no move constructor), as shown below. Here, we copy elements from the old storage (top) to the new storage (bottom).</p>

<table border="0">
  <tr>
    <td>
      <table border="1">
        <tr>
          <td>a</td><td>b</td><td>c</td><td>d</td>
          <td>e</td><td>f</td><td>g</td><td>h</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td>
      <table border="0">
        <tr>
          <td>&darr;</td><td>&darr;</td><td>&darr;</td><td>&darr;</td>
          <td>&darr;</td><td></td><td></td><td></td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td>
      <table border="1">
        <tr>
          <td>a</td><td>b</td><td>c</td><td>d</td>
          <td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td>
        </tr>
      </table>
    </td>
  </tr>
</table>

<p>While copying the fifth element (<code>e</code>) the copy constructor throws an exception. At this point, we can still recover, since the old storage still contains the original (unmodified) data. Thus, the recovery code (section #2b) destroys the elements in the new storage and then frees the new storage, providing the strong exception safety guarantee.</p>

<p>When the type stored in the vector provides a move constructor, each of the values is moved from the old storage into the new storage, potentially mutating the values in the old storage. The notion is shown below, half-way through the reallocation:</p>

<table border="0">
  <tr>
    <td>
      <table border="1">
        <tr>
          <td>?</td><td>?</td><td>?</td><td>?</td>
          <td>e</td><td>f</td><td>g</td><td>h</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td>
      <table border="0">
        <tr>
          <td>&dArr;</td><td>&dArr;</td><td>&dArr;</td><td>&dArr;</td>
          <td>&dArr;</td><td></td><td></td><td></td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <td>
      <table border="1">
        <tr>
          <td>a</td><td>b</td><td>c</td><td>d</td>
          <td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td>
        </tr>
      </table>
    </td>
  </tr>
</table>

<p>When the element's move constructor cannot throw, the reallocation is guaranteed to succeed, since no operations after the initial memory allocation can throw.</p>

<p>However, if the element's move constructor can throw an exception (say, while moving the value <code>e</code>), we are left with a problem: neither the old storage nor the new storage captures the vector's state prior to initiating the reallocation. And, since we're recovering from an exception, we don't have the ability to move elements back from the new storage to the old storage, because their move constructors could throw in the process. Hence, the best we can do is maintain the basic guarantee, where no resources are leaked but the first four values in the vector have indeterminate values. Hence, it is not possible to provide the strong exception safety guarantee for vector's <code>push_back</code> in the presence of a throwing move constructor.</p>

<h3 "strong-except-model">A Model of Strong Exception Safety</h3>
<p>Stepping back from this specific instance, we can formulate a simple model for achieving the strong exception-safety guarantee. In this model, we take the set of operations that we need to perform in our routine and partition them into two sets: those operations that perform nonreversible modifications (such as moving a value from one place to another) and those operations that can throw exceptions. Providing strong exception safety means placing any operations that can throw exceptions (memory allocation, copying, etc.) before any operations that perform nonrevisible modifications (moving a value, destroying an object, freeing memory).</p>

<p>Reconsidering <code>vector</code> reallocation in terms of this model, we see that, if we ignore throwing move constructors, the implementation of <code>reallocate</code> performs all of its possibly-throwing routines up front: we allocate memory, then copy (which may throw) or move (which won't throw), then we complete the operation. Either way, at some point within the routine we have committed to only using operations that can no longer throw, such as deallocating memory or destroying already-constructed objects.</p>

<p>The problem with a throwing move operation is that it fits into
both partitions. It can throw exceptions (obviously) and it is also a
non-reversible modification, because (1) moving is permitted to transfer resources and (2) there is no non-throwing operation to reverse the transfer of resources.</p>

<p>Based on this model, prohibiting the use of types that have
throwing move constructors appears to solve the problem, and it does
help somewhat. One immediate problem with this approach (which is already used by vector's <code>push_back</code> specification, among other things) is that it places the burden of ensuring that all move constructors are non-throwing on the user, without providing the user with any tools to determine whether this requirement is actually met.</p>

<h3 id="throwing-pair">Throwing Move Constructors in the Standard Library</h3>

<p>So, how easy is it to violate the requirement that move constructors not throw exceptions? It turns out to be surprisingly easy, and in fact existing, well-formed C++03 programs will violate this requirement when compiled with the C++0x Standard Library because the standard library itself creates throwing move constructors. As an example, consider a simple <code>Matrix</code> type that stores its values on the heap:</p>

<pre>
class Matrix {
  double *data;
  unsigned rows, cols;

public:
  Matrix(const Matrix&amp; other) : rows(other.rows), cols(other.cols) {
    data = new double [rows * cols];
    // copy data...
  }
};
</pre>

<p>The <code>Matrix</code> type has a copy constructor that can throw an exception, but it has no move constructors. A <code>vector</code> of <code>Matrix</code> values is certainly well-formed and its <code>push_back</code> provides the strong exception safety guarantee. This is true both in C++03 and in C++0x.</p>

<p>Next, we compose a <code>std::string</code> with a <code>Matrix</code> using <code>std::pair</code>:</p>

<pre>
typedef std::pair&lt;std::string, Matrix&gt; NamedMatrix;
</pre>

<p>Consider <code>std::pair</code>'s move constructor, which will look something like this (simplified!):</p>

<pre>
template&lt;typename T, typename U&gt;
struct pair {
  pair(pair&amp;&mp; other)
    : first(std::move(other.first)), second(std::move(other.second)) { }

  T first;
  U second;
};
</pre>

<p>Here, the <code>pair</code>'s <code>first</code> data member is an <code>std::string</code>, which has a non-throwing move constructor that modifies its source value. The <code>pair</code>'s <code>second</code> data member is a <code>Matrix</code>, which has a throwing copy constructor but no move constructor. When we compose these two types, we end up with a type---<code>std::pair&lt;std::string, Matrix&gt;</code>---that merges their behaviors. This <code>pair</code>'s move constructor performs a non-reversible modification on the <code>first</code> member of the pair (moving the resources of the <code>std::string</code>) and then performs a potentially-throwing copy construction on the <code>second</code> member of the pair (copying the <code>Matrix</code>). Thus, we have composed two well-behaved types, one from the library and one from user code, into a type that violates the prohibition on throwing move constructors. Moreover, this problem affects valid C++03 code, which will silently invoke undefined behavior when compiled with a C++0x Standard Library </p>

<h2 id="solution">Proposed Solution</h2>

<p>The problematic throwing move constructor in our example comes from the aggregation of two well-formed types, so we focus our attention on the <code>pair</code> move constructor. In particular, given the prohibition on move constructors that may throw exceptions, <code>pair</code> should only declare a move constructor when it is guaranteed that the underlying move operations for the types it aggregates are both non-throwing. Using concept syntax, one might imagine that such a constructor would be written as:</p>

<pre>
  requires NothrowMoveConstructible&lt;T&gt; &amp;&amp; NothrowMoveConstructible&lt;U&gt;
    pair(pair&amp;&mp; other)
      : first(std::move(other.first)), second(std::move(other.second)) { }
</pre>

<p>In this case, <code>pair</code> will only provide a move constructor when that move constructor is guaranteed to be non-throwing. Therefore, <code>std::pair&lt;std::string, Matrix&gt;</code> will not provide a move constructor and reallocating a <code>vector</code> of these pairs will use the copy constructor, maintaining the strong exception safety guarantee. Naturally, <code>pair</code> is not the only type whose move constructor is effected: any standard library and user type that aggregates other values, including tuples and containers, will need similarly-constrained move constructors.</p>

<p>At present, there is no good way to write the <code>NothrowMoveConstructible</code> concept. FIXME: pick up here


TODO: ban 

<p>At present, we have no way to detect whether either of these
conditions hold. We copy constructors do not modify the values of 
We therefore propose to ban the definition of move
constructors and move assignment operators that throw
exceptions. We can then be sure that if we are invoking a move
constructor, it does not throw; that copy constructors preserve the
original value of the source element is already assumed in C++ and
need not be addressed separately.</p>

<p>Banning move constructors and move assignment operators that throw
exceptions is not a straightforward matter. For example, a blanket
library requirement that prohibits types with a throwing move
constructor from being used with the library would be ineffective, for
several reasons:</p>

<ol>
  <li><i>Users will accidentally violate this requirement</i>. Without
  any kind of compiler checking that move constructors and move
  assignment operators don't throw exceptions, it is far too easy for
  a user to forget that a certain operation used within the move
  constructor or move assignment operator may throw an exception,
  silently and accidentally breaking the guarantee. Exception
  specifications do not help this situation, because they are neither
  statically checked nor widely used.</li>

  <li><i>The library will violate this requirement</i>. Certain
  library classes like <code>pair</code> and </code>tuple</code>
  aggregate several kinds of data and provide move constructors. For
  example, <code>std::pair</code> has the following move constructor:
  <pre>
template&lt;class U, class V&gt; 
  requires Constructible&lt;T1, RvalueOf&lt;U&gt;::type&gt; &amp;&amp;
           Constructible&lt;T2, RvalueOf&lt;V&gt;::type&gt; 
  pair(pair&lt;U, V&gt;&amp;&amp; p)
    : first(std::move(p.first)), second(std::move(p.second)) { }
  </pre>

  This move constructor is necessary to make types like
  <code>std::pair&lt;std::string, std::string&gt;</code>
  move-constructible (for optimization purposes) and to make move-only
  types like <code>std::unique_ptr</code> usable within
  <code>std::pair</code>. However, certain combinations of
  <code>pair</code> template arguments will cause this move
  constructor to both be destructive and to potentially throw
  exceptions. For example, consider <code>std::pair&lt;std::string,
  Matrix&gt;</code>. Here, <code>std::pair</code>'s move constructor
  will move (destructively) the <code>std::string first</code> and
  then will copy <code>Matrix second</code>. Thus, the move operation
  is both destructive and can throw exceptions, which makes it
  impossible for <code>std::vector</code>'s <code>push_back</code>
  operation to provide the strong exception safety guarantee. 
  (FIXME: it's far easier to understand this problem here than it was
  at the beginning of the document. We need to structure this better!).
</ol>

<p>The solution for <code>pair</code>'s move constructor is to only
enable move construction when both <code>T1</code> and <code>T2</code>
have non-throwing move constructors. For example, we could change the
signature of <code>pair</code>'s move constructor to:</p>

<pre>
template&lt;class U, class V&gt; 
  requires NothrowMoveConstructible&lt;T1, U&gt; &amp;&amp;
           NothrowMoveConstructible&lt;T2, V&gt; 
  pair(pair&lt;U, V&gt;&amp;&amp; p)
    : first(std::move(p.first)), second(std::move(p.second)) { }
</pre>

<p>The <code>NothrowMoveConstructible</code> concept, in this case,
expresses the same semantics as the previous
<code>Constructible</code> requirement, e.g.,<p>

<pre>
concept NothrowMoveConstructible&lt;typename T, typename U = T&gt; {
  requires RvalueOf&lt;U&gt; &amp;&amp; Constructible&lt;T, RvalueOf&lt;U&gt;::type&gt;;
}
</pre>

<p>The important aspect of this concept is that it is not an
<code>auto</code> concept, so clients are required to "opt in" by
explicitly stating, via a concept map, that they provide a
non-throwing move constructor. The library would provide concept maps
for its own types, e.g.</p>

<pre>
concept_map NothrowMoveConstructible&lt;string&gt; { }
</pre>

<p>Some of these concept maps will, naturally, be conditional on their
inputs. For example, <code>pair</code>'s concept map can be expressed
as follows:</p>

<pre>
template&lt;typename T1, typename T2, typename U, typename V>
  requires NothrowMoveConstructible&lt;T1, U&gt; &amp;&amp; NothrowMoveConstructible&lt;T2, V&gt;
  concept_map NothrowMoveConstructible&lt;pair&lt;T1, T2&gt;, pair&lt;U, V&gt;&gt; { }
</pre>

<p>If diligently applied throughout the library and user code,
<code>NothrowMoveConstructible</code> permits the safe use of
move semantics within the library, retaining the strong exception
safety guarantee.</p>

<p>The danger with a library-only solution is that it is far too easy
for users of the language to accidentally write a move constructor
that can throw exceptions, and a single class or class template that
makes such a mistake compromises the exception safety guarantees of
the library. The concepts system cannot protect the user from such a
mistake, because there is no way to statically determine whether a
function can throw exceptions. Even if concepts could prevent such an
error in the library, non-templated and unconstrained templates would
still be susceptible to this class of errors. To address these
problems, we propose to introduce language facilities that allow the
nothrow guarantee to be declared for functions, statically enforced by
the compiler, and queried by concepts.</p>

<h3 id="noexcept">The <code>noexcept</code> Specifier</h3>

<p>We propose the addition of a new declaration specifier,
<code>noexcept</code>, that indicates that the function it applies to
does not throw any exceptions. The <code>noexcept</code> specifier can
only be applied to function declarators, e.g.,</p>

<pre>
noexcept int printf(const char* format, ...); // okay: printf does not throw exceptions.
noexcept int (*funcptr)(const char*, ...); // okay: pointer to a function that does not throw exceptions
noexcept int x; // error: not a function declarator
</pre>

<p>The <code>noexcept</code> specifier differs from an empty exception
specification (spelled <code>throw()</code>) in two important
ways. First, a <code>noexcept</code> function is ill-formed if it (or
any function it calls) may throw an exception, e.g.,</p>

<pre>
noexcept int foo(int);
int bar(int);
noexcept void wibble(int x, int y) {
  x = foo(x); // okay: foo can not throw any exceptions
  y = bar(y); // error: bar() could throw an exception

  try {
    y = bar(y); 
  } catch (...) {
    y = 0;
  } // okay: all exceptions that could be thrown have been captured
}
</pre>

<p>Second, the presence or absence of the <code>noexcept</code>
specifier is part of a function type. Thus, the types of the function
pointers <code>fp1</code> and <code>fp2</code>, shown below, are
distinct:</p>

<pre>
noexcept int (*fp1)(int); // okay: pointer to a function that does not throw exceptions
int (*fp2)(int); // okay: pointer to a function that may throw exceptions
</pre>

<p>There is an implicit conversion from pointers and references to <code>noexcept</code> pointers to their potentially-throwing equivalents. For example:</p>

<pre>
noexcept int f(int);
int g(int);

noexcept int (*fp1)(int) = &amp;f; // okay: exact match
int (*fp2)(int) = &amp;g; // okay: exact match
int (*fp3)(int) = &amp;f; // okay: conversion from pointer to <code>noexcept</code> function to a pointer to a non-<code>noexcept</code> function
noexcept int (*fp4)(int) = &amp;g; // error: no conversion from a pointer to a throwing function type to a pointer to a non-throwing function type
</pre>

<p>In many ways, <code>noexcept</code> provides the behavior that
users expect from <code>throw()</code>. That exception specifications
are not statically checked is a <a
 href="http://www.gotw.ca/publications/mill22.htm">constant source of
confusion</a>, especially for programmers who have used the similar
(statically-checked) facilities in Java. Moreover, exception
specifications have a poorly-defined role in the C++ type system,
because they can only be used in very limited ways.</p>

<p>Functions cannot be overloaded based on <code>noexcept</code>
alone. For example, the following code is ill-formed:</p>

<pre>
noexcept void f() { } // #1
void f() { } // #2: redefinition of #1
</pre>

<h3 id"noexcept-concepts"><code>noexcept</code> in concepts</h3>

<p>The <code>noexcept</code> specifier can be used on associated
functions within concepts, allowing one to detect whether a particular
operation is guaranteed not to throw exceptions. For example:

<pre>
auto concept NothrowMoveConstructible&lt;typename T, typename U = T&gt; {
  requires RvalueOf&lt;U&gt;;
  noexcept T::T(RvalueOf&lt;U&gt;::type);
}
</pre>

<p>This new, <code>noexcept</code> formulation of the
<code>NothrowMoveConstructible</code> concept has two benefits over
the previous formulation. First, since the <code>noexcept</code>
property is statically checked, there is no potential for users to
accidentally claim that no exceptions will be thrown from their move
constructors. Second, since we have strong static checking for the
no-throw policy, we have made this an <code>auto</code> concept, so
that users need not write concept maps for this low-level
concept.</p>

<h3 id="movedefault">Default Implementations of Move Construction and Assignment</h3>
NOTE: The move constructor generated for closure types will need to be fixed, too.

<h3 id="library">Library Changes</h3>
<h4 id="concepts">Moving and Copying Concepts</h4>
<h4 id="aggregate">Move Constructors</h4>

<h2 id="alternatives">Alternative Solutions</h2>
<h3 id="libraryonly">Library-only Solution</h3>
<h3 id="syntax">Alternative Syntax</h3>
<p>Yes, we thought of these. No, we don't care to discuss them.</p>

<hr>
<address></address>
<!-- hhmts start --> Last modified: Sun Mar 22 18:28:39 PDT 2009 <!-- hhmts end -->
</body> </html>
