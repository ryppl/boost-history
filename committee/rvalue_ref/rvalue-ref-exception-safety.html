<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>Rvalue References and Exception Safety</title>
</head>

<body>
<h1>Rvalue References and Exception Safety</h1>

<p>Authors: Douglas Gregor, David Abrahams<br>
Contact: doug.gregor@gmail.com, dave@boostpro.com<br>
Organization: Apple, BoostPro Computing<br>
Date: 2009-03-07<br>
Number: D2855=09-0045</p>

<h2 id="intro">Introduction</h2>

<p>This paper describes a problem with rvalue references that
compromises the exception safety guarantees made by the Standard
Library. In particular, well-formed C++03 programs, when compiled with
the C++0x Standard Library, can no longer rely on the strong exception
safety guarantee provided by standard library containers. This silent
change in behavior makes it nearly impossible to use the Standard
Library in applications that must recover from exceptions thrown by
the library. In this paper, we characterize the problem itself and
outline a potential solution that extends the language and modifies
the library.</p>

<h2 id="review">Review of Exception Safety Guarantees in the
Library</h2>

<p>Within the library, we characterize the behavior of a function with
respect to exceptions based on the guarantees that the implementation
must provide if an exception is thrown. These guarantees describe the
state of the program once a thrown exception has unwound the stack
past the point of that function. We recognize two levels of exception
safety guarantees for a given library function:

<dl>
  <dt>Basic exception guarantee</dt>
  <dd>No resources are leaked and all of the arguments to the function
  are left in a consistent, destructible state.</dd>

  <dt>Strong exception guarantee</dt>
  <dd>No resources are leaked and all arguments to the function are
  left in the same state they were prior to invocation of the
  function. Therefore, the state of the program after exiting the
  function (via the exception) is the same as if the function were
  never called.</dd>
</dl>

<p>The Standard Library provides at least the basic exception
guarantee throughout, which has not changed with the introduction of
rvalue references. Some functions of the library provide the strong
exception guarantee, such as insertion in most containers
(23.1.1p10).</p>

<h2 id="problem">The Problem</h2>

<p>The fundamental problem addressed by this paper is that, for some
functions that are specified with the strong exception guarantee that
have also been extended with rvalue references, it is no longer
possible to implement the strong exception guarantee. As an example,
we consider <code>vector</code>'s <code>push_back</code> operation,
e.g.,</p>

<pre>
class Matrix {
  double *data;
  unsigned rows, cols;

public:
  Matrix(const Matrix&amp; other) : rows(other.rows), cols(other.cols) {
    data = new double [rows * cols];
    // copy data...
  }
};

typedef std::pair&lt;std::string, Matrix&gt; NamedMatrix;

void AddMatrix(std::vector&lt;NamedMatrix&gt;&amp; Named, const NamedMatrix &amp;M) {
  Named.push_back(M);
}
</pre>

<p>In the call to <code>push_back</code>, if the size of the
<code>vector</code> is the same as it's capacity, we will have to
allocate more storage for the <code>vector</code>. In this case, we
first allocate more storage and then copy the contents from the old
storage into the new storage. Finally, we copy the new element into
the new storage and, if everything has succeeded, free the old
storage.</p>

<p>During this reallocation and insertion process, there are many
opportunities to exhaust the available memory, including the
allocation of new storage for the <code>vector</code>, the allocation
of memory while copying the <code>NamedMatrix</code> values from the
old storage to the new storage, and the allocation of memory while
copying the new <code>NamedMatrix</code> into the new storage. In
C++03, the <code>push_back</code> operation can recover from an
exception thrown from any of these places merely by destroying the
copies in and then freeing the new storage, since the old storage
remains intact. Therefore, <code>vector</code>'s
<code>push_back</code> can provide the strong exception safety
guarantee.</p>

<p>With the introduction of move semantics (via rvalue references) in
C++0x, the situation is complicated. To eliminate the need for
extraneous copies (thereby improving performance) and to support the
use of move-only types (like <code>std::unique_ptr</code>), the
elements of the <code>vector</code> are moved from the old storage to
the new storage. For C++03 types that only have a copy constructor
(and no move constructor), the "move" operation actually performs a
copy, so the C++0x library provides the same semantics as in
C++03. For a type with a non-throwing move constructor (like
<code>std::unique_ptr</code> or <code>std::string</code>), moving data
from the old storage to the new storage will not throw any exceptions,
and the implementation can still easily cope with exceptions thrown
either when allocating the new storage (the old storage is still
valid) or when copying the final element into the new storage (the new
storage is still valid). Therefore, neither of these classes of types
cause a problem for the strong exception guarantee.</p>

<p>The <code>NamedMatrix</code> type, however, is neither here nor
there. It is a <code>std::pair</code>, which means that it has a move
constructor. However, this move constructor moves from its
<code>first</code> subobject (the <code>std::string</code>) but copies
from its <code>second</code> subobject (the <code>Matrix</code>),
which means that it is both destructive (it modifies the source) and
that it may throw an exception. During reallocation, after some
elements have been move from the old storage to the new storage, the
<code>Matrix</code> copy constructor may throw while moving an
element. In this case, we are left in a state from which we cannot
recover, where some elements are stored in the old storage and other
elements are in the new storage. We cannot move the elements from the
new storage back into the old storage, since doing so might throw
another exception and cause us to terminate. Nor can we continue
moving elements into the new storage, since we've already triggered an
exception. The implementation could still provide the basic guarantee
by, for example, truncating the <code>vector</code>, but it cannot
roll back to its state prior to the <code>push_back</code> call.</p>
  
<h2 id="solution">Proposed Solution</h2>

<p>In our motivating example, we saw that the <code>push_back</code>
function can provide the strong exception safety guarantee when one of
two conditions holds:</p>

<ol>
  <li>Moving an element from the old storage to the new storage is
  guaranteed not to throw, or</li>
  <li>Copying an element from the old storage to the new storage is
  guaranteed not to change the value of the original element.</li>
</ol>

<p>At present, we have no way to detect whether either of these
conditions hold. We therefore propose to ban the definition of move
constructors and move assignment operators that throw
exceptions. We can then be sure that if we are invoking a move
constructor, it does not throw; that copy constructors preserve the
original value of the source element is already assumed in C++ and
need not be addressed separately.</p>

<p>Banning move constructors and move assignment operators that throw
exceptions is not a straightforward matter. For example, a blanket
library requirement that prohibits types with a throwing move
constructor from being used with the library would be ineffective, for
several reasons:</p>

<ol>
  <li><i>Users will accidentally violate this requirement</i>. Without
  any kind of compiler checking that move constructors and move
  assignment operators don't throw exceptions, it is far too easy for
  a user to forget that a certain operation used within the move
  constructor or move assignment operator may throw an exception,
  silently and accidentally breaking the guarantee. Exception
  specifications do not help this situation, because they are neither
  statically checked nor widely used.</li>

  <li><i>The library will violate this requirement</i>. Certain
  library classes like <code>pair</code> and </code>tuple</code>
  aggregate several kinds of data and provide move constructors. For
  example, <code>std::pair</code> has the following move constructor:
  <pre>
template&lt;class U, class V&gt; 
  requires Constructible&lt;T1, RvalueOf&lt;U&gt;::type&gt; &amp;&amp;
           Constructible&lt;T2, RvalueOf&lt;V&gt;::type&gt; 
  pair(pair&lt;U, V&gt;&amp;&amp; p)
    : first(std::move(p.first)), second(std::move(p.second)) { }
  </pre>

  This move constructor is necessary to make types like
  <code>std::pair&lt;std::string, std::string&gt;</code>
  move-constructible (for optimization purposes) and to make move-only
  types like <code>std::unique_ptr</code> usable within
  <code>std::pair</code>. However, certain combinations of
  <code>pair</code> template arguments will cause this move
  constructor to both be destructive and to potentially throw
  exceptions. For example, consider <code>std::pair&lt;std::string,
  Matrix&gt;</code>. Here, <code>std::pair</code>'s move constructor
  will move (destructively) the <code>std::string first</code> and
  then will copy <code>Matrix second</code>. Thus, the move operation
  is both destructive and can throw exceptions, which makes it
  impossible for <code>std::vector</code>'s <code>push_back</code>
  operation to provide the strong exception safety guarantee. 
  (FIXME: it's far easier to understand this problem here than it was
  at the beginning of the document. We need to structure this better!).
</ol>

<p>The solution for <code>pair</code>'s move constructor is to only
enable move construction when both <code>T1</code> and <code>T2</code>
have non-throwing move constructors. For example, we could change the
signature of <code>pair</code>'s move constructor to:</p>

<pre>
template&lt;class U, class V&gt; 
  requires NothrowMoveConstructible&lt;T1, U&gt; &amp;&amp;
           NothrowMoveConstructible&lt;T2, V&gt; 
  pair(pair&lt;U, V&gt;&amp;&amp; p)
    : first(std::move(p.first)), second(std::move(p.second)) { }
</pre>

<p>The <code>NothrowMoveConstructible</code> concept, in this case,
expresses the same semantics as the previous
<code>Constructible</code> requirement, e.g.,<p>

<pre>
concept NothrowMoveConstructible&lt;typename T, typename U = T&gt; {
  requires RvalueOf&lt;U&gt; &amp;&amp; Constructible&lt;T, RvalueOf&lt;U&gt;::type&gt;;
}
</pre>

<p>The important aspect of this concept is that it is not an
<code>auto</code> concept, so clients are required to "opt in" by
explicitly stating, via a concept map, that they provide a
non-throwing move constructor. The library would provide concept maps
for its own types, e.g.</p>

<pre>
concept_map NothrowMoveConstructible&lt;string&gt; { }
</pre>

<p>Some of these concept maps will, naturally, be conditional on their
inputs. For example, <code>pair</code>'s concept map can be expressed
as follows:</p>

<pre>
template&lt;typename T1, typename T2, typename U, typename V>
  requires NothrowMoveConstructible&lt;T1, U&gt; &amp;&amp; NothrowMoveConstructible&lt;T2, V&gt;
  concept_map NothrowMoveConstructible&lt;pair&lt;T1, T2&gt;, pair&lt;U, V&gt;&gt; { }
</pre>

<p>If diligently applied throughout the library and user code,
<code>NothrowMoveConstructible</code> permits the safe use of
move semantics within the library, retaining the strong exception
safety guarantee.</p>

<p>The danger with a library-only solution is that it is far too easy
for users of the language to accidentally write a move constructor
that can throw exceptions, and a single class or class template that
makes such a mistake compromises the exception safety guarantees of
the library. The concepts system cannot protect the user from such a
mistake, because there is no way to statically determine whether a
function can throw exceptions. Even if concepts could prevent such an
error in the library, non-templated and unconstrained templates would
still be susceptible to this class of errors. To address these
problems, we propose to introduce language facilities that allow the
nothrow guarantee to be declared for functions, statically enforced by
the compiler, and queried by concepts.</p>

<h3 id="noexcept">The <code>noexcept</code> Specifier</h3>

<p>We propose the addition of a new declaration specifier,
<code>noexcept</code>, that indicates that the function it applies to
does not throw any exceptions. The <code>noexcept</code> specifier can
only be applied to function declarators, e.g.,</p>

<pre>
noexcept int printf(const char* format, ...); // okay: printf does not throw exceptions.
noexcept int (*funcptr)(const char*, ...); // okay: pointer to a function that does not throw exceptions
noexcept int x; // error: not a function declarator
</pre>

<p>The <code>noexcept</code> specifier differs from an empty exception
specification (spelled <code>throw()</code>) in two important
ways. First, a <code>noexcept</code> function is ill-formed if it (or
any function it calls) may throw an exception, e.g.,</p>

<pre>
noexcept int foo(int);
int bar(int);
noexcept void wibble(int x, int y) {
  x = foo(x); // okay: foo can not throw any exceptions
  y = bar(y); // error: bar() could throw an exception

  try {
    y = bar(y); 
  } catch (...) {
    y = 0;
  } // okay: all exceptions that could be thrown have been captured
}
</pre>

<p>Second, the presence or absence of the <code>noexcept</code>
specifier is part of a function type. Thus, the types of the function
pointers <code>fp1</code> and <code>fp2</code>, shown below, are
distinct:</p>

<pre>
noexcept int (*fp1)(int); // okay: pointer to a function that does not throw exceptions
int (*fp2)(int); // okay: pointer to a function that may throw exceptions
</pre>

<p>There is an implicit conversion from pointers and references to <code>noexcept</code> pointers to their potentially-throwing equivalents. For example:</p>

<pre>
noexcept int f(int);
int g(int);

noexcept int (*fp1)(int) = &amp;f; // okay: exact match
int (*fp2)(int) = &amp;g; // okay: exact match
int (*fp3)(int) = &amp;f; // okay: conversion from pointer to <code>noexcept</code> function to a pointer to a non-<code>noexcept</code> function
noexcept int (*fp4)(int) = &amp;g; // error: no conversion from a pointer to a throwing function type to a pointer to a non-throwing function type
</pre>

<p>In many ways, <code>noexcept</code> provides the behavior that
users expect from <code>throw()</code>. That exception specifications
are not statically checked is a <a
 href="http://www.gotw.ca/publications/mill22.htm">constant source of
confusion</a>, especially for programmers who have used the similar
(statically-checked) facilities in Java. Moreover, exception
specifications have a poorly-defined role in the C++ type system,
because they can only be used in very limited ways.</p>

<p>Functions cannot be overloaded based on <code>noexcept</code>
alone. For example, the following code is ill-formed:</p>

<pre>
noexcept void f() { } // #1
void f() { } // #2: redefinition of #1
</pre>

<h3 id"noexcept-concepts"><code>noexcept</code> in concepts</h3>

<p>The <code>noexcept</code> specifier can be used on associated
functions within concepts, allowing one to detect whether a particular
operation is guaranteed not to throw exceptions. For example:

<pre>
auto concept NothrowMoveConstructible&lt;typename T, typename U = T&gt; {
  requires RvalueOf&lt;U&gt; &amp;&amp;;
  noexcept T::T(RvalueOf&lt;U&gt;::type);
}
</pre>

<p>This new, <code>noexcept</code> formulation of the
<code>NothrowMoveConstructible</code> concept has two benefits over
the previous formulation. First, since the <code>noexcept</code>
property is statically checked, there is no potential for users to
accidentally claim that no exceptions will be thrown from their move
constructors. Second, since we have strong static checking for the
no-throw policy, we have made this an <code>auto</code> concept, so
that users need not write concept maps for this low-level
concept.</p>

<h3 id="noexceptmove">Move Construction and Assignment Requires
<code>noexcept</code></h3>


<h3 id="movedefault">Default Implementations of Move Construction and Assignment</h3>
NOTE: The move constructor generated for closure types will need to be fixed, too.

<h3 id="library">Library Changes</h3>
<h4 id="concepts">Moving and Copying Concepts</h4>
<h4 id="aggregate">Move Constructors</h4>

<h2 id="alternatives">Alternative Solutions</h2>
<h3 id="libraryonly">Library-only Solution</h3>
<h3 id="syntax">Alternative Syntax</h3>
<p>Yes, we thought of these. No, we don't care to discuss them.</p>

<hr>
<address></address>
<!-- hhmts start --> Last modified: Fri Mar 20 08:02:32 PDT 2009 <!-- hhmts end -->
</body> </html>
