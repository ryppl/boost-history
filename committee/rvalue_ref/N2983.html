<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Allowing Move Constructors to Throw</title>
<meta name="author" content="David Abrahams, Rani Sharoni" />
<meta name="organization" content="BoostPro Computing" />
<meta name="date" content="2009-10-14" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@python.org
:Date: $Date: 2006-05-21 16:44:42 -0400 (Sun, 21 May 2006) $
:Revision: $Revision: 4564 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  /* margin-bottom: 0.5em */
  margin: 0 0 0 22px; }

/* Uncomment (and remove this text!) to get bold-faced definition list terms*/
dl.docutils dt {
  font-weight: bold; 
  margin: 2em 0 0 22px;
  line-height: 1.8em;
   }


div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em;
  margin-left: 22px; }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  /* margin-left: 1.5em; */
  margin-left: 22px; }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  /*margin-top: 0.5em ;
  margin-bottom: 0.5em;*/
  margin: 0 0 0 22px; }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

.ins {background-color:#A0FFA0;border-bottom: 1px solid black}
.del {background-color:#FFA0A0;text-decoration:line-through}

.grammar { padding: 0 }

.sub {
	position: relative;
	bottom: -0.5em;
	font-size: 0.8em;
}

</style>
</head>
<body>
<div class="document" id="allowing-move-constructors-to-throw">
<h1 class="title">Allowing Move Constructors to Throw</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>David Abrahams, Rani Sharoni</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first reference external" href="mailto:dave&#64;boostpro.com">dave&#64;boostpro.com</a>, <a class="last reference external" href="mailto:rani_sharoni&#64;hotmail.com">rani_sharoni&#64;hotmail.com</a></td></tr>
<tr><th class="docinfo-name">Organization:</th>
<td><a class="first last reference external" href="http://www.boostpro.com">BoostPro Computing</a></td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2009-10-14</td></tr>
<tr class="field"><th class="docinfo-name">Number:</th><td class="field-body">D2983=09-0173</td>
</tr>
</tbody>
</table>
<!-- build HTML with:

rst2html.py - -footnote-references=superscript \
  - -stylesheet-path=./rst.css - -embed-stylesheet N2983-throwing-move.rst \
  N2983.html -->
<div class="contents topic" id="index">
<p class="topic-title first">index</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id6">Introduction</a></li>
<li><a class="reference internal" href="#motivation" id="id7">Motivation</a></li>
<li><a class="reference internal" href="#solution" id="id8">Solution</a></li>
<li><a class="reference internal" href="#implementing-std-move-if-noexcept" id="id9">Implementing <tt class="docutils literal"><span class="pre">std::move_if_noexcept</span></tt></a></li>
<li><a class="reference internal" href="#an-optimization-hint" id="id10">An Optimization Hint</a></li>
<li><a class="reference internal" href="#interactions-with-other-proposals" id="id11">Interactions with Other Proposals</a></li>
<li><a class="reference internal" href="#existing-practice" id="id12">Existing Practice</a></li>
<li><a class="reference internal" href="#low-hanging-fruit" id="id13">Low-Hanging Fruit</a><ul>
<li><a class="reference internal" href="#implicit-noexcept-true-for-destructors" id="id14">Implicit <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> for Destructors</a></li>
<li><a class="reference internal" href="#operator-noexcept-expression" id="id15">operator <tt class="docutils literal"><span class="pre">noexcept(</span></tt><em>expression</em><tt class="docutils literal"><span class="pre">)</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#proposed-changes-to-standard-wording" id="id16">Proposed Changes to Standard Wording</a><ul>
<li><a class="reference internal" href="#exception-specifications-except-spec" id="id17">15.4 Exception specifications [except.spec]</a></li>
<li><a class="reference internal" href="#utility-components-utility" id="id18">20.3 Utility components [utility]</a></li>
<li><a class="reference internal" href="#forward-move-helpers-forward" id="id19">20.3.2 forward/move helpers [forward]</a></li>
<li><a class="reference internal" href="#header-type-traits-synopsis-meta-type-synop" id="id20">20.6.2 Header <tt class="docutils literal"><span class="pre">&lt;type_traits&gt;</span></tt> synopsis [meta.type.synop]</a></li>
<li><a class="reference internal" href="#type-properties-meta-unary-prop" id="id21">20.6.4.3 Type properties [meta.unary.prop]</a></li>
<li><a class="reference internal" href="#deque-modifiers-deque-modifiers" id="id22">23.3.2.3 deque modifiers [deque.modifiers]</a></li>
<li><a class="reference internal" href="#vector-capacity-vector-capacity" id="id23">23.3.6.2 vector capacity [vector.capacity]</a></li>
<li><a class="reference internal" href="#vector-modifiers-vector-modifiers" id="id24">23.3.6.4 vector modifiers [vector.modifiers]</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id6">Introduction</a></h1>
<p>In <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2855.html">N2855</a>, Doug Gregor and Dave Abrahams discussed a problematic
interaction between move constructors, templates, and certain standard
library member functions.  To date, attempts to solve the problem
(including <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2855.html">N2855</a> itself) have taken one basic approach: <em>ban throwing
move constructors, and be sure never to generate one</em>.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id7">Motivation</a></h1>
<p>Consider, for a moment, the actual magnitude of the problem we're
addressing: it's a backward-compatibility/code evolution issue that
only arises when <em>all</em> these conditions are satisfied:</p>
<ul class="simple">
<li>An existing operation today gives the strong guarantee</li>
<li>The operation is being <em>move-enabled</em> (altered to use move operations)</li>
<li>An existing type that the operation manipulates acquires a move constructor</li>
<li>That move constructor can throw</li>
<li>The particular move-enabled operation can only offer the basic
guarantee if a move constructor throws<a class="footnote-reference" href="#x" id="id1"><sup>2</sup></a></li>
</ul>
<p>In light of the extremely narrow set of circumstances under which the
problem can arise, it seems rather heavy-handed to ban throwing move
constructors altogether:</p>
<ul class="simple">
<li>It can be a hard rule for users to follow.</li>
<li>It hobbles the optimization potential of move constructors, because
efficient move constructors that might throw (but almost never will)
can't be generated or written.</li>
<li>It adds another &quot;Gotcha&quot; that people have to worry about.</li>
<li>It places tight restrictions on the order of code evolution: one
cannot move-enable a class until all its sub-objects have been
move-enabled.</li>
<li>It forces the weakening of class invariants for some move-enabled
classes: if move construction is not allowed to throw, the invariant
must include a resource-less state in which we can leave the source
object.</li>
<li>In some cases class maintainers may need to choose between
move-enabling their class and maintaining its current guarantees to
users.  For example, Dinkumware's list implementation currently
derives QOI benefits from having no resource-less state—“begin” and
“end” iterators maintain their relationships even after lists are
swapped.  If throwing move constructors were banned, that would no
longer be possible.</li>
<li>When it is necessary to manually write a move constructor for a
templated class, it would in many cases require either expert-level
metaprogramming skill or the addition of a language feature, just
for move constructors, whose only purpose is in solving this
particular problem.<a class="footnote-reference" href="#attribute" id="id2"><sup>1</sup></a></li>
</ul>
</div>
<div class="section" id="solution">
<h1><a class="toc-backref" href="#id8">Solution</a></h1>
<p>Fortunately, there is a better way.  Instead of imposing this burden
on every class author, we can deal with the issue more selectively in
the operation being move-enabled.  There, we know whether a throwing
move can disturb existing guarantees.  We propose that instead of
using <tt class="docutils literal"><span class="pre">std::move(x)</span></tt> in those cases, thus granting permission for
the compiler to use <em>any</em> available move constructor, maintainers of
these particular operations should use <tt class="docutils literal"><span class="pre">std::move_if_noexcept(x)</span></tt>, which
grants permission move <em>unless</em> it could throw and the type is
copyable.  Unless <tt class="docutils literal"><span class="pre">x</span></tt> is a move-only type, or is known to have a
nonthrowing move constructor, the operation would fall back to copying
<tt class="docutils literal"><span class="pre">x</span></tt>, just as though <tt class="docutils literal"><span class="pre">x</span></tt> had never acquired a move constructor at
all.</p>
<p>For example, <tt class="docutils literal"><span class="pre">std::pair</span></tt>'s move constructor, were it to be written
out manually, could remain as it was before this issue was
discovered:</p>
<pre class="literal-block">
template &lt;class First2, Second2&gt;
pair( pair&lt;First2,Second2&gt;&amp;&amp; rhs )
  : first( move(rhs.first) ),
    second( move(rhs.second) )
{}
</pre>
<p>However, <tt class="docutils literal"><span class="pre">std::vector::reserve</span></tt> could be move-enabled this way:<a class="footnote-reference" href="#default-construct-swap" id="id3"><sup>5</sup></a></p>
<pre class="literal-block">
void reserve(size_type n)
{
    if (n &gt; this-&gt;capacity())
    {
        pointer new_begin = this-&gt;allocate( n );
        size_type s = this-&gt;size(), i = 0;
        try
        {
            for (;i &lt; s; ++i)
                 new ((void*)(new_begin + i)) value_type( <strong>std::move_if_noexcept(</strong> (*this)[i]) <strong>)</strong> );
        }
        catch(...)
        {
            for (;i &gt; 0; --i)                 // clean up new elements
               (new_begin + i)-&gt;~value_type();

            this-&gt;deallocate( new_begin );    // release storage
            throw;
        }
        // -------- irreversible mutation starts here -----------
        this-&gt;deallocate( this-&gt;begin_ );
        this-&gt;begin_ = new_begin;
        this-&gt;end_ = new_begin + s;
        this-&gt;cap_ = new_begin + n;
    }
}
</pre>
<p>We stress again that the use of <tt class="docutils literal"><span class="pre">std::move_if_noexcept</span></tt> as opposed to
<tt class="docutils literal"><span class="pre">move</span></tt> would only be necessary under an <em>extremely</em> limited set of
circumstances.  In particular, it would never be required in new code,
which could simply give a <em>conditional</em> strong guarantee, e.g. “if an
exception is thrown other than by <tt class="docutils literal"><span class="pre">T</span></tt>'s move constructor, there
are no effects.”  We recommend that approach as best practice for new
code.</p>
</div>
<div class="section" id="implementing-std-move-if-noexcept">
<h1><a class="toc-backref" href="#id9">Implementing <tt class="docutils literal"><span class="pre">std::move_if_noexcept</span></tt></a></h1>
<p>One possible implementation of <tt class="docutils literal"><span class="pre">std::move_if_noexcept</span></tt> might be:</p>
<pre class="literal-block">
template &lt;class T&gt;
typename conditional&lt;
    !nothrow_move_constructible&lt;T&gt;::value
    &amp;&amp; has_copy_constructor&lt;T&gt;::value,
    T const&amp;,
    T&amp;&amp;
&gt;::type
move_if_noexcept(T&amp; x)
{
    return std::move(x);
}
</pre>
<p>We propose that <tt class="docutils literal"><span class="pre">nothrow_move_constructible&lt;T&gt;</span></tt> be a conservative
trait very much like <tt class="docutils literal"><span class="pre">has_nothrow_copy_constructor&lt;T&gt;</span></tt> from the
current working draft; it would be identical to the proposed
<tt class="docutils literal"><span class="pre">is_nothrow_constructible&lt;T,T&amp;&amp;&gt;</span></tt> from <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2953.html">N2953</a>.  In other words, it
returns <tt class="docutils literal"><span class="pre">true</span></tt> only when it can prove the move constructor doesn't
throw, and is <em>allowed</em> to return <tt class="docutils literal"><span class="pre">false</span></tt> even when the move
constructor can throw.</p>
</div>
<div class="section" id="an-optimization-hint">
<h1><a class="toc-backref" href="#id10">An Optimization Hint</a></h1>
<p>To help the library deduce the correct result for these traits, we
propose to add a new kind of exception-specification, spelled:</p>
<pre class="literal-block">
noexcept( <em>integral constant expression</em> )
</pre>
<p>The only impact of such an exception-specification is this: if a
function decorated with <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> throws an exception, the
behavior is undefined.<a class="footnote-reference" href="#no-diagnostic" id="id4"><sup>3</sup></a> That effect is sufficient to
allow these <em>xxx</em><tt class="docutils literal"><span class="pre">_nothrow_</span></tt><em>xxx</em> traits to report <tt class="docutils literal"><span class="pre">true</span></tt> for
any operation decorated with <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt>.  Class maintainers could
label their move constructors <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> to indicate non-throwing
behavior, and the library is permitted to take advantage of that
labelling if it can be detected (via “compiler magic”).</p>
<p>Note that the usefulness of <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> as an optimization hint
goes way beyond the narrow case introduced by <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2855.html">N2855</a>.  In fact, it
goes beyond move construction: when the compiler can detect
non-throwing operations with certainty, it can optimize away a great
deal of code and/or data that is devoted to exception handling.  Some
compilers already do that for <tt class="docutils literal"><span class="pre">throw()</span></tt> specifications, but since
those incur the overhead of an implicit try/catch block to handle
unexpected exceptions, the benefits are limited.</p>
<p>The advantage of the integral constant expression parameter is that
one can easily offer accurate hints in templated move constructors.
For example, <tt class="docutils literal"><span class="pre">std::pair</span></tt>'s converting move constructor could be
written as follows:</p>
<pre class="literal-block">
template &lt;class First2, Second2&gt;
pair( pair&lt;First2,Second2&gt;&amp;&amp; rhs )
      <strong>throw( !is_nothrow_constructible&lt;First,First2&amp;&amp;&gt;::value
             || !is_nothrow_constructible&lt;Second,Second2&amp;&amp;&gt;::value )</strong><a class="footnote-reference" href="#is-nothrow-constructible" id="id5"><sup>4</sup></a>
  : first( move(rhs.first) ),
    second( move(rhs.second) )
{}
</pre>
<p>Although the above is reminiscent of the <tt class="docutils literal"><span class="pre">enable_if</span></tt> clause that would
be <em>required</em> if there is a ban on throwing move constructors, the
exception specification above is entirely optional; its presence or
absence doesn't affect the correctness of a move constructor.</p>
</div>
<div class="section" id="interactions-with-other-proposals">
<h1><a class="toc-backref" href="#id11">Interactions with Other Proposals</a></h1>
<p>The generation of default move constructors, first proposed by Bjarne
Stroustrup in <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2904.pdf">N2904</a>, and again by Bjarne Stroustrup and Lawrence
Crowl in <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2953.html">N2953</a>, is harmonious with our proposal.  For example, since
throwing move constructors are allowed, default move constructors will
be generated in more cases, with performance benefits if <em>any</em>
subobjects have been move-enabled.</p>
<p>As a matter of QOI, a default move constructor would probably gain an
exception specification whose boolean constant parameter is computed
from the results of has_nothrow_move on all subobjects, but, being a
matter of QOI, that doesn't have any effect on standard text.</p>
<p>The proposed <tt class="docutils literal"><span class="pre">[[nothrow]]</span></tt> attribute is just a less-powerful version
of this feature.  In particular, it can't express the hint shown for
<tt class="docutils literal"><span class="pre">pair</span></tt>'s move constructor above.  We suggest it be dropped.</p>
</div>
<div class="section" id="existing-practice">
<h1><a class="toc-backref" href="#id12">Existing Practice</a></h1>
<p>The Microsoft compiler has always treated empty
exception-specifications as though they have the same meaning we
propose for <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt>.  That is, Microsoft omits the
standard-mandated runtime behavior if the function throws, and it
performs optimizations based on the assumption that the function
doesn't throw.  This interpretation of <tt class="docutils literal"><span class="pre">throw()</span></tt> has proven to be
successful in practice and is regarded by many as superior to the one
in the standard.  Standardizing <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> gives everyone access
to this optimization tool.</p>
</div>
<div class="section" id="low-hanging-fruit">
<h1><a class="toc-backref" href="#id13">Low-Hanging Fruit</a></h1>
<p>There are a couple of additional features we think the committee
should consider if this proposal is accepted.</p>
<div class="section" id="implicit-noexcept-true-for-destructors">
<h2><a class="toc-backref" href="#id14">Implicit <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> for Destructors</a></h2>
<p>So few destructors can throw exceptions that the default
exception-specification for destructors could be changed from nothing
(i.e. <tt class="docutils literal"><span class="pre">noexcept(false)</span></tt>) to <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> with only a tiny amount of code
breakage.  Such code is already very dangerous, and where used
properly, ought to be a well-known “caution area” that is reasonably
easily migrated.</p>
</div>
<div class="section" id="operator-noexcept-expression">
<h2><a class="toc-backref" href="#id15">operator <tt class="docutils literal"><span class="pre">noexcept(</span></tt><em>expression</em><tt class="docutils literal"><span class="pre">)</span></tt></a></h2>
<p>It seems that <tt class="docutils literal"><span class="pre">has_nothrow_</span></tt><em>xxx</em> traits are proliferating (and
not just in this proposal).  Once we have <tt class="docutils literal"><span class="pre">throw(</span></tt><em>bool-constant-expr</em><tt class="docutils literal"><span class="pre">)</span></tt> available to make the information
available, it makes sense to generalize the traits into an operator
similar to <tt class="docutils literal"><span class="pre">sizeof</span></tt> and <tt class="docutils literal"><span class="pre">typeof</span></tt> that can give us answers about
<em>any</em> expression.</p>
</div>
</div>
<div class="section" id="proposed-changes-to-standard-wording">
<h1><a class="toc-backref" href="#id16">Proposed Changes to Standard Wording</a></h1>
<div class="section" id="exception-specifications-except-spec">
<h2><a class="toc-backref" href="#id17">15.4 Exception specifications [except.spec]</a></h2>
<p>Change paragraph 1 as follows:</p>
<blockquote>
<p>1 A function declaration lists exceptions that its function might directly
or indirectly throw by using an exception-specification as a suffix of its
declarator.</p>
<blockquote>
<p><span class="raw-html"><p><em>
exception-specification:
<blockquote class="grammar">
<span class="ins">dynamic-exception-specification</span>
<br />
<span class="ins">noexcept-specification</span>
</blockquote>
<em></p></span></p>
<p><span class="raw-html"><p><span class="ins">
<em>dynamic-exception-specification:</em>
</span>
<blockquote>
<code>throw (</code> <em>type-id-list<span class="sub">opt</span></em> <code>)</code>
</blockquote>
</em>
</p></span></p>
<p><span class="raw-html"><p><em>
type-id-list:
<blockquote>
type-id ...<span class="sub">opt</span><br />
type-id-list, type-id ...<span class="sub">opt</span>
</blockquote>
<em>
</p></span></p>
<p><span class="raw-html"><p>
<span class="ins"><em>noexcept-specification:</em></span>
<blockquote>
<span class="ins"><code>noexcept (</code> <em>constant-expression<span class="sub">opt</span></em> <code>)</code></span>
</blockquote>
</em>
</p></span></p>
</blockquote>
</blockquote>
<p>Add these paragraphs:</p>
<blockquote>
<p><span class="raw-html"><span class="ins">15 In a noexcept-specification, the
constant-expression, if supplied, shall be a constant expression
(5.19) that can be contextually converted to <code>bool</code>
(Clause 4).</span></span></p>
<p><span class="raw-html"><span class="ins">16 If a function with the
noexcept-specification <code>noexcept(true)</code> throws an
exception, the behavior is undefined.  The exception-specification
<code>noexcept(true)</code> is in all other respects equivalent to
<code>throw()</code>.  The exception-specification
<code>noexcept(false)</code> is equivalent to omitting the exception
specification altogether.</span></span></p>
<p><span class="raw-html"><span class="ins">17 <code>noexcept()</code> is
equivalent to <code>noexcept(true)</code>.</span></span></p>
</blockquote>
</div>
<div class="section" id="utility-components-utility">
<h2><a class="toc-backref" href="#id18">20.3 Utility components [utility]</a></h2>
<p>Change Header <tt class="docutils literal"><span class="pre">&lt;utility&gt;</span></tt> synopsis as follows:</p>
<pre class="literal-block">
// 20.3.2, forward/move:
template &lt;class T&gt; struct identity;
template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp;);
template &lt;class T&gt; typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp;);
<span class="ins">template &lt;class T&gt; typename conditional&lt;
  !nothrow_move_constructible&lt;T&gt;::value &amp;&amp; has_copy_constructor&lt;T&gt;::value,
  T const&amp;, T&amp;&amp;&gt;::type move_if_noexcept(T&amp; x);</span>
</pre>
</div>
<div class="section" id="forward-move-helpers-forward">
<h2><a class="toc-backref" href="#id19">20.3.2 forward/move helpers [forward]</a></h2>
<p>Append the following:</p>
<blockquote>
<pre class="literal-block">
<span class="ins">template &lt;class T&gt; typename conditional&lt;
  !nothrow_move_constructible&lt;T&gt;::value &amp;&amp; has_copy_constructor&lt;T&gt;::value,
  T const&amp;, T&amp;&amp;&gt;::type move_if_noexcept(T&amp; x);</span>
</pre>
<p><span class="raw-html"><span class="ins">10 <em>Returns:</em> <code>std::move(t)</code></span></span></p>
</blockquote>
</div>
<div class="section" id="header-type-traits-synopsis-meta-type-synop">
<h2><a class="toc-backref" href="#id20">20.6.2 Header <tt class="docutils literal"><span class="pre">&lt;type_traits&gt;</span></tt> synopsis [meta.type.synop]</a></h2>
<pre class="literal-block">
template &lt;class T&gt; struct has_nothrow_assign;
<span class="ins">template &lt;class T&gt; struct has_move_constructor;
template &lt;class T&gt; struct nothrow_move_constructible;

template &lt;class T&gt; struct has_move_assign;
template &lt;class T&gt; struct nothrow_move_assignable;

template &lt;class T&gt; struct has_copy_constructor;
template &lt;class T&gt; struct has_default_constructor;
template &lt;class T&gt; struct has_copy_assign;</span>

template &lt;class T&gt; struct has_virtual_destructor;
</pre>
</div>
<div class="section" id="type-properties-meta-unary-prop">
<h2><a class="toc-backref" href="#id21">20.6.4.3 Type properties [meta.unary.prop]</a></h2>
<p>Add entries to table 43:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="34%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Template</th>
<th class="head">Condition</th>
<th class="head">Preconditions</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span> <span class="pre">has_move_constructor;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> has a move constructor
(17.3.14).</td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span>
<span class="pre">nothrow_move_constructible;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">noexcept(</span> <span class="pre">T(</span> <span class="pre">make&lt;T&gt;()</span> <span class="pre">)</span> <span class="pre">)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span> <span class="pre">has_move_assign;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> has a move assignment
operator (17.3.13).</td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span>
<span class="pre">nothrow_move_assignable;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">noexcept(</span> <span class="pre">*(T*)0</span> <span class="pre">=</span> <span class="pre">make&lt;T&gt;</span> <span class="pre">)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span> <span class="pre">has_copy_constructor;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> has a copy constructor
(12.8).</td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type, an
array of unknown bound, or
(possibly cv-qualified) <tt class="docutils literal"><span class="pre">void.</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span>
<span class="pre">has_default_constructor;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> has a default constructor
(12.1).</td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type, an
array of unknown bound, or
(possibly cv-qualified) <tt class="docutils literal"><span class="pre">void.</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span> <span class="pre">has_copy_assign;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> has a copy assignment
operator (12.8).</td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type, an
array of unknown bound, or
(possibly cv-qualified) <tt class="docutils literal"><span class="pre">void</span></tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="deque-modifiers-deque-modifiers">
<h2><a class="toc-backref" href="#id22">23.3.2.3 deque modifiers [deque.modifiers]</a></h2>
<p>Context:</p>
<pre class="literal-block">
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
void insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;;
   void insert(const_iterator position, ;
               InputIterator first, InputIterator last);

template &lt;class... Args&gt; void emplace_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_front(const T&amp; x);
void push_front(T&amp;&amp; x);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);`
</pre>
<p>Change Paragraph 2 as follows:</p>
<blockquote>
2 Remarks: If an exception is thrown other than by the copy
constructor<span class="ins">, move constructor, move assignment operator</span> or
assignment operator of <tt class="docutils literal"><span class="pre">T</span></tt> there are no effects.  <span class="raw-html"><span
class="ins">If an exception is thrown by the move constructor of a
non-CopyConstructible <code>T</code>, the effects are
unspecified.</span></span></blockquote>
<hr class="docutils" />
<p>Context:</p>
<pre class="literal-block">
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
</pre>
<p>Change paragraph 6 as follows:</p>
<blockquote>
6 Throws: Nothing unless an exception is thrown by the copy constructor,
<span class="ins">move constructor, move assignment operator</span>
or assignment operator of <tt class="docutils literal"><span class="pre">T</span></tt>.</blockquote>
</div>
<div class="section" id="vector-capacity-vector-capacity">
<h2><a class="toc-backref" href="#id23">23.3.6.2 vector capacity [vector.capacity]</a></h2>
<p>Context:</p>
<pre class="literal-block">
void reserve(size_type n);
</pre>
<p>Remove paragraph 2:</p>
<blockquote>
<span class="del">2 Requires: If value_type has a move constructor, that
constructor shall not throw any exceptions.</span></blockquote>
<p>Change paragraph 3 as follows:</p>
<blockquote>
<span class="del">3</span><span class="ins">2</span> Effects: A directive that informs a vector of a planned change in
size, so that it can manage the storage allocation
accordingly. After <tt class="docutils literal"><span class="pre">reserve()</span></tt>, <tt class="docutils literal"><span class="pre">capacity()</span></tt> is greater or
equal to the argument of reserve if reallocation happens; and
equal to the previous value of <tt class="docutils literal"><span class="pre">capacity()</span></tt> otherwise.
Reallocation happens at this point if and only if the current
capacity is less than the argument of <tt class="docutils literal"><span class="pre">reserve()</span></tt>. If an
exception is thrown <span class="raw-html"><span class="ins">other than by the
move constructor of a non-CopyConstructible <code>T</code></span> there
are no effects.</blockquote>
<hr class="docutils" />
<p>Context:</p>
<pre class="literal-block">
void resize(size_type sz, const T&amp; c);
</pre>
<p>Change paragraph 13 to say:</p>
<blockquote>
If an exception is thrown <span class="raw-html"><span class="ins">other than
by the move constructor of a non-CopyConstructible
<code>T</code></span></span> there are no effects.</blockquote>
</div>
<div class="section" id="vector-modifiers-vector-modifiers">
<h2><a class="toc-backref" href="#id24">23.3.6.4 vector modifiers [vector.modifiers]</a></h2>
<p>Change the section as follows:</p>
<blockquote>
<pre class="literal-block">
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
void insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  void insert(const_iterator position, InputIterator first, InputIterator last);
template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</pre>
<p><span class="del">1 Requires: If value_type has a move constructor, that constructor shall
not throw any exceptions.</span></p>
<p><span class="del">2</span><span class="ins">1</span> Remarks: Causes reallocation if the new size is
greater than the old capacity. If no reallocation happens, all the
iterators and references before the insertion point remain valid.
If an exception is thrown other than by the copy constructor
<span class="ins">move constructor, move assignment operator,</span> or assignment
operator of <tt class="docutils literal"><span class="pre">T</span></tt> or by any InputIterator operation there are no
effects.  <span class="raw-html"><span class="ins">if an exception is thrown by
the move constructor of a non-CopyConstructible <code>T</code>, the
effects are unspecified.</span></p>
<p><span class="del">3</span><span class="ins">2</span> Complexity: The complexity is linear in the number
of elements inserted plus the distance to the end of the vector.</p>
</blockquote>
<p><strong>Note to proposal reader:</strong> The strong guarantee of <tt class="docutils literal"><span class="pre">push_back</span></tt> for
CopyConstructible <tt class="docutils literal"><span class="pre">T</span></tt>s is maintained by virtue of 23.2.1
[container.requirements.general] paragraph 11.</p>
<hr class="docutils" />
<p>Context:</p>
<pre class="literal-block">
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
</pre>
<p>Change paragraph 6 as follows:</p>
<blockquote>
6 Throws: Nothing unless an exception is thrown by the copy
constructor, <span class="ins">move constructor, move assignment operator</span>, or
assignment operator of <tt class="docutils literal"><span class="pre">T</span></tt>.</blockquote>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="attribute" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>In Frankfurt, Dave proposed that we use the attribute
syntax <tt class="docutils literal"><span class="pre">[[moves(subobj1,subobj2)]]</span></tt> for this purpose.  Aside from
being controversial, it's a wart regardless of the syntax used,
adding a whole new mechanism just for move constructors but useless
elsewhere.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="x" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[2]</a></td><td>Many move-enabled operations can give the strong guarantee
regardless of whether move construction throws.  One example is
<tt class="docutils literal"><span class="pre">std::list&lt;T&gt;::push_back</span></tt>.  This issue affects only the narrow
subset of operations that need to make <em>multiple</em> explicit moves
from locations observable by the caller.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="no-diagnostic" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>In particular, we are not proposing to mandate
static checking: a <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> function can call a <tt class="docutils literal"><span class="pre">noexcept(false)</span></tt>
function without causing the program to become ill-formed or
generating a diagnostic.  Generating a diagnostic in such cases
can, of course, be implemented by any compiler as a matter of QOI.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="is-nothrow-constructible" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>See <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2953.html">N2953</a> for a definition of
<tt class="docutils literal"><span class="pre">is_nothrow_constructible</span></tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="default-construct-swap" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[5]</a></td><td>Actually <tt class="docutils literal"><span class="pre">reserve</span></tt> and other such
operations can be optimized even for a type without non-throwing
move constructors but with a default constructor and a non-throwing
swap, by first default-constructing elements in the new array and
swapping each element into place.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
