<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>Allowing Move Constructors to Throw</title>
<meta name="author" content="David Abrahams, Rani Sharoni, Doug Gregor" />
<meta name="organization" content="BoostPro Computing" />
<meta name="date" content="2009-10-14" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@python.org
:Date: $Date: 2006-05-21 16:44:42 -0400 (Sun, 21 May 2006) $
:Revision: $Revision: 4564 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  /* margin-bottom: 0.5em */
  margin: 0 0 0 22px; }

/* Uncomment (and remove this text!) to get bold-faced definition list terms*/
dl.docutils dt {
  font-weight: bold; 
  margin: 2em 0 0 22px;
  line-height: 1.8em;
   }


div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em;
  margin-left: 22px; }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  /* margin-left: 1.5em; */
  margin-left: 22px; }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  /*margin-top: 0.5em ;
  margin-bottom: 0.5em;*/
  margin: 0 0 0 22px; }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

.ins {background-color:#A0FFA0;text-decoration:underline}
.del {background-color:#FFA0A0;text-decoration:line-through}

.grammar { padding: 0 }

.sub {
	position: relative;
	bottom: -0.5em;
	font-size: 0.8em;
}

</style>
</head>
<body>
<div class="document" id="allowing-move-constructors-to-throw">
<h1 class="title">Allowing Move Constructors to Throw</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>David Abrahams, Rani Sharoni, Doug Gregor</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first reference external" href="mailto:dave&#64;boostpro.com">dave&#64;boostpro.com</a>, <a class="reference external" href="mailto:rani_sharoni&#64;hotmail.com">rani_sharoni&#64;hotmail.com</a>, <a class="last reference external" href="mailto:doug.gregor&#64;gmail.com">doug.gregor&#64;gmail.com</a></td></tr>
<tr><th class="docinfo-name">Organization:</th>
<td><a class="first last reference external" href="http://www.boostpro.com">BoostPro Computing</a></td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2009-10-14</td></tr>
<tr class="field"><th class="docinfo-name">Number:</th><td class="field-body">D2983=09-0173</td>
</tr>
</tbody>
</table>
<!-- build HTML with:

rst2html.py - -footnote-references=superscript \
  - -stylesheet-path=./rst.css - -embed-stylesheet N2983-throwing-move.rst \
  N2983.html -->
<div class="contents topic" id="index">
<p class="topic-title first">index</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id7">Introduction</a></li>
<li><a class="reference internal" href="#motivation" id="id8">Motivation</a></li>
<li><a class="reference internal" href="#solution" id="id9">Solution</a></li>
<li><a class="reference internal" href="#implementing-std-move-if-noexcept" id="id10">Implementing <tt class="docutils literal"><span class="pre">std::move_if_noexcept</span></tt></a></li>
<li><a class="reference internal" href="#an-optimization-hint" id="id11">An Optimization Hint</a></li>
<li><a class="reference internal" href="#operator-noexcept-expression" id="id12">operator <tt class="docutils literal"><span class="pre">noexcept(</span></tt><em>expression</em><tt class="docutils literal"><span class="pre">)</span></tt></a></li>
<li><a class="reference internal" href="#interactions-with-other-proposals" id="id13">Interactions with Other Proposals</a></li>
<li><a class="reference internal" href="#existing-practice" id="id14">Existing Practice</a></li>
<li><a class="reference internal" href="#implicit-noexcept-true-for-destructors" id="id15">Implicit <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> for Destructors</a></li>
<li><a class="reference internal" href="#proposed-changes-to-standard-wording" id="id16">Proposed Changes to Standard Wording</a><ul>
<li><a class="reference internal" href="#keywords-lex-key" id="id17">2.12 Keywords [lex.key]</a></li>
<li><a class="reference internal" href="#allocation-functions-basic-stc-dynamic-allocation" id="id18">3.7.4.1 Allocation functions [basic.stc.dynamic.allocation]</a></li>
<li><a class="reference internal" href="#unary-expressions-expr-unary" id="id19">5.3 Unary expressions [expr.unary]</a></li>
<li><a class="reference internal" href="#new-expr-new" id="id20">5.3.4 New [expr.new]</a></li>
<li><a class="reference internal" href="#noexcept-operator-expr-unary-noexcept" id="id21">5.3.7 noexcept operator [expr.unary.noexcept]</a></li>
<li><a class="reference internal" href="#variadic-templates-temp-variadic" id="id22">14.6.3 Variadic templates [temp.variadic]</a></li>
<li><a class="reference internal" href="#type-dependent-expressions-temp-dep-expr" id="id23">14.7.2.2 Type-dependent expressions [temp.dep.expr]</a></li>
<li><a class="reference internal" href="#value-dependent-expressions-temp-dep-constexpr" id="id24">14.7.2.3 Value-dependent expressions [temp.dep.constexpr]</a></li>
<li><a class="reference internal" href="#exception-specifications-except-spec" id="id25">15.4 Exception specifications [except.spec]</a></li>
<li><a class="reference internal" href="#type-unexpected-handler-unexpected-handler" id="id26">18.8.2.2 Type unexpected_handler [unexpected.handler]</a></li>
<li><a class="reference internal" href="#utility-components-utility" id="id27">20.3 Utility components [utility]</a></li>
<li><a class="reference internal" href="#forward-move-helpers-forward" id="id28">20.3.2 forward/move helpers [forward]</a></li>
<li><a class="reference internal" href="#header-type-traits-synopsis-meta-type-synop" id="id29">20.6.2 Header <tt class="docutils literal"><span class="pre">&lt;type_traits&gt;</span></tt> synopsis [meta.type.synop]</a></li>
<li><a class="reference internal" href="#type-properties-meta-unary-prop" id="id30">20.6.4.3 Type properties [meta.unary.prop]</a></li>
<li><a class="reference internal" href="#deque-modifiers-deque-modifiers" id="id31">23.3.2.3 deque modifiers [deque.modifiers]</a></li>
<li><a class="reference internal" href="#vector-capacity-vector-capacity" id="id32">23.3.6.2 vector capacity [vector.capacity]</a></li>
<li><a class="reference internal" href="#vector-modifiers-vector-modifiers" id="id33">23.3.6.4 vector modifiers [vector.modifiers]</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id7">Introduction</a></h1>
<p>In <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2855.html">N2855</a>, Doug Gregor and Dave Abrahams discussed a problematic
interaction between move constructors, templates, and certain standard
library member functions.  To date, attempts to solve the problem
(including <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2855.html">N2855</a> itself) have taken one basic approach: <em>ban throwing
move constructors, and be sure never to generate one</em>.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id8">Motivation</a></h1>
<p>Consider, for a moment, the actual magnitude of the problem we're
addressing: it's a backward-compatibility/code evolution issue that
only arises when <em>all</em> these conditions are satisfied:</p>
<ul class="simple">
<li>An existing operation today gives the strong guarantee</li>
<li>The operation is being <em>move-enabled</em> (altered to use move operations)</li>
<li>An existing type that the operation manipulates acquires a move constructor</li>
<li>That move constructor can throw</li>
<li>The particular move-enabled operation can only offer the basic
guarantee if a move constructor throws<a class="footnote-reference" href="#x" id="id1"><sup>2</sup></a></li>
</ul>
<p>In light of the extremely narrow set of circumstances under which the
problem can arise, it seems rather heavy-handed to ban throwing move
constructors altogether:</p>
<ul class="simple">
<li>It can be a hard rule for users to follow.</li>
<li>It hobbles the optimization potential of move constructors, because
efficient move constructors that might throw (but almost never will)
can't be generated or written.</li>
<li>It adds another &quot;Gotcha&quot; that people have to worry about.</li>
<li>It places tight restrictions on the order of code evolution: one
cannot move-enable a class until all its sub-objects have been
move-enabled.</li>
<li>It forces the weakening of class invariants for some move-enabled
classes: if move construction is not allowed to throw, the invariant
must include a resource-less state in which we can leave the source
object.</li>
<li>In some cases class maintainers may need to choose between
move-enabling their class and maintaining its current guarantees to
users.  For example, Dinkumware's list implementation currently
derives QOI benefits from having no resource-less state—“begin” and
“end” iterators maintain their relationships even after lists are
swapped.  If throwing move constructors were banned, that would no
longer be possible.</li>
<li>When it is necessary to manually write a move constructor for a
templated class, it would in many cases require either expert-level
metaprogramming skill or the addition of a language feature, just
for move constructors, whose only purpose is in solving this
particular problem.<a class="footnote-reference" href="#attribute" id="id2"><sup>1</sup></a></li>
</ul>
</div>
<div class="section" id="solution">
<h1><a class="toc-backref" href="#id9">Solution</a></h1>
<p>Fortunately, there is a better way.  Instead of imposing this burden
on every class author, we can deal with the issue more selectively in
the operation being move-enabled.  There, we know whether a throwing
move can disturb existing guarantees.  We propose that instead of
using <tt class="docutils literal"><span class="pre">std::move(x)</span></tt> in those cases, thus granting permission for
the compiler to use <em>any</em> available move constructor, maintainers of
these particular operations should use <tt class="docutils literal"><span class="pre">std::move_if_noexcept(x)</span></tt>, which
grants permission move <em>unless</em> it could throw and the type is
copyable.  Unless <tt class="docutils literal"><span class="pre">x</span></tt> is a move-only type, or is known to have a
nonthrowing move constructor, the operation would fall back to copying
<tt class="docutils literal"><span class="pre">x</span></tt>, just as though <tt class="docutils literal"><span class="pre">x</span></tt> had never acquired a move constructor at
all.</p>
<p>For example, <tt class="docutils literal"><span class="pre">std::pair</span></tt>'s move constructor, were it to be written
out manually, could remain as it was before this issue was
discovered:</p>
<pre class="literal-block">
template &lt;class First2, Second2&gt;
pair( pair&lt;First2,Second2&gt;&amp;&amp; rhs )
  : first( move(rhs.first) ),
    second( move(rhs.second) )
{}
</pre>
<p>However, <tt class="docutils literal"><span class="pre">std::vector::reserve</span></tt> could be move-enabled this way:<a class="footnote-reference" href="#default-construct-swap" id="id3"><sup>5</sup></a></p>
<pre class="literal-block">
void reserve(size_type n)
{
    if (n &gt; this-&gt;capacity())
    {
        pointer new_begin = this-&gt;allocate( n );
        size_type s = this-&gt;size(), i = 0;
        try
        {
            for (;i &lt; s; ++i)
                 new ((void*)(new_begin + i)) value_type( <strong>std::move_if_noexcept(</strong> (*this)[i]) <strong>)</strong> );
        }
        catch(...)
        {
            for (;i &gt; 0; --i)                 // clean up new elements
               (new_begin + i)-&gt;~value_type();

            this-&gt;deallocate( new_begin );    // release storage
            throw;
        }
        // -------- irreversible mutation starts here -----------
        this-&gt;deallocate( this-&gt;begin_ );
        this-&gt;begin_ = new_begin;
        this-&gt;end_ = new_begin + s;
        this-&gt;cap_ = new_begin + n;
    }
}
</pre>
<p>We stress again that the use of <tt class="docutils literal"><span class="pre">std::move_if_noexcept</span></tt> as opposed to
<tt class="docutils literal"><span class="pre">move</span></tt> would only be necessary under an <em>extremely</em> limited set of
circumstances.  In particular, it would never be required in new code,
which could simply give a <em>conditional</em> strong guarantee, e.g. “if an
exception is thrown other than by <tt class="docutils literal"><span class="pre">T</span></tt>'s move constructor, there
are no effects.”  We recommend that approach as best practice for new
code.</p>
</div>
<div class="section" id="implementing-std-move-if-noexcept">
<h1><a class="toc-backref" href="#id10">Implementing <tt class="docutils literal"><span class="pre">std::move_if_noexcept</span></tt></a></h1>
<p>One possible implementation of <tt class="docutils literal"><span class="pre">std::move_if_noexcept</span></tt> might be:</p>
<pre class="literal-block">
template &lt;class T&gt;
typename conditional&lt;
    !nothrow_move_constructible&lt;T&gt;::value
    &amp;&amp; has_copy_constructor&lt;T&gt;::value,
    T const&amp;,
    T&amp;&amp;
&gt;::type
move_if_noexcept(T&amp; x)
{
    return std::move(x);
}
</pre>
<p>We propose that <tt class="docutils literal"><span class="pre">nothrow_move_constructible&lt;T&gt;</span></tt> be a conservative
trait very much like <tt class="docutils literal"><span class="pre">has_nothrow_copy_constructor&lt;T&gt;</span></tt> from the
current working draft; it would be identical to the proposed
<tt class="docutils literal"><span class="pre">is_nothrow_constructible&lt;T,T&amp;&amp;&gt;</span></tt> from <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2953.html">N2953</a>.  In other words, it
returns <tt class="docutils literal"><span class="pre">true</span></tt> only when it can prove the move constructor doesn't
throw, and is <em>allowed</em> to return <tt class="docutils literal"><span class="pre">false</span></tt> even when the move
constructor can throw.</p>
</div>
<div class="section" id="an-optimization-hint">
<h1><a class="toc-backref" href="#id11">An Optimization Hint</a></h1>
<p>To help the library deduce the correct result for these traits, we
propose to add a new kind of exception-specification, spelled:</p>
<pre class="literal-block">
noexcept( <em>integral constant expression</em> )
</pre>
<p>The only impact of such an exception-specification is this: if a
function decorated with <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> throws an exception, the
behavior is undefined.<a class="footnote-reference" href="#no-diagnostic" id="id4"><sup>3</sup></a> That effect is sufficient to
allow these <em>xxx</em><tt class="docutils literal"><span class="pre">_nothrow_</span></tt><em>xxx</em> traits to report <tt class="docutils literal"><span class="pre">true</span></tt> for
any operation decorated with <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt>.  Class maintainers could
label their move constructors <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> to indicate non-throwing
behavior, and the library is permitted to take advantage of that
labelling if it can be detected (via “compiler magic”).</p>
<p>Note that the usefulness of <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> as an optimization hint
goes way beyond the narrow case introduced by <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2855.html">N2855</a>.  In fact, it
goes beyond move construction: when the compiler can detect
non-throwing operations with certainty, it can optimize away a great
deal of code and/or data that is devoted to exception handling.  Some
compilers already do that for <tt class="docutils literal"><span class="pre">throw()</span></tt> specifications, but since
those incur the overhead of an implicit try/catch block to handle
unexpected exceptions, the benefits are limited.</p>
<p>The advantage of the integral constant expression parameter is that
one can easily offer accurate hints in templated move constructors.
For example, <tt class="docutils literal"><span class="pre">std::pair</span></tt>'s converting move constructor could be
written as follows:</p>
<pre class="literal-block">
template &lt;class First2, Second2&gt;
pair( pair&lt;First2,Second2&gt;&amp;&amp; rhs )
      <strong>noexcept( is_nothrow_constructible&lt;First,First2&amp;&amp;&gt;::value
                  &amp;&amp; is_nothrow_constructible&lt;Second,Second2&amp;&amp;&gt;::value )</strong><a class="footnote-reference" href="#is-nothrow-constructible" id="id5"><sup>4</sup></a>
  : first( move(rhs.first) ),
    second( move(rhs.second) )
{}
</pre>
<p>Although the above is reminiscent of the <tt class="docutils literal"><span class="pre">enable_if</span></tt> clause that would
be <em>required</em> if there is a ban on throwing move constructors, the
exception specification above is entirely optional; its presence or
absence doesn't affect the correctness of a move constructor.</p>
</div>
<div class="section" id="operator-noexcept-expression">
<h1><a class="toc-backref" href="#id12">operator <tt class="docutils literal"><span class="pre">noexcept(</span></tt><em>expression</em><tt class="docutils literal"><span class="pre">)</span></tt></a></h1>
<p>It seems that <tt class="docutils literal"><span class="pre">has_nothrow_</span></tt><em>xxx</em> traits are proliferating (and
not just in this proposal).  Once we have <tt class="docutils literal"><span class="pre">noexcept(</span></tt><em>bool-constant-expr</em><tt class="docutils literal"><span class="pre">)</span></tt> available to make the information
available, it makes sense to generalize the traits into an operator
similar to <tt class="docutils literal"><span class="pre">sizeof</span></tt> and <tt class="docutils literal"><span class="pre">typeof</span></tt> that can give us answers about
<em>any</em> expression.</p>
</div>
<div class="section" id="interactions-with-other-proposals">
<h1><a class="toc-backref" href="#id13">Interactions with Other Proposals</a></h1>
<p>The generation of default move constructors, first proposed by Bjarne
Stroustrup in <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2904.pdf">N2904</a>, and again by Bjarne Stroustrup and Lawrence
Crowl in <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2953.html">N2953</a>, is harmonious with our proposal.  For example, since
throwing move constructors are allowed, default move constructors will
be generated in more cases, with performance benefits if <em>any</em>
subobjects have been move-enabled.</p>
<p>As a matter of QOI, a default move constructor would probably gain an
exception specification whose boolean constant parameter is computed
from the results of has_nothrow_move on all subobjects, but, being a
matter of QOI, that doesn't have any effect on standard text.</p>
<p>The proposed <tt class="docutils literal"><span class="pre">[[nothrow]]</span></tt> attribute is just a less-powerful version
of this feature.  In particular, it can't express the hint shown for
<tt class="docutils literal"><span class="pre">pair</span></tt>'s move constructor above.  We suggest it be dropped.</p>
</div>
<div class="section" id="existing-practice">
<h1><a class="toc-backref" href="#id14">Existing Practice</a></h1>
<p>The Microsoft compiler has always treated empty
exception-specifications as though they have the same meaning we
propose for <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt>.  That is, Microsoft omits the
standard-mandated runtime behavior if the function throws, and it
performs optimizations based on the assumption that the function
doesn't throw.  This interpretation of <tt class="docutils literal"><span class="pre">throw()</span></tt> has proven to be
successful in practice and is regarded by many as superior to the one
in the standard.  Standardizing <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> gives everyone access
to this optimization tool.</p>
</div>
<div class="section" id="implicit-noexcept-true-for-destructors">
<h1><a class="toc-backref" href="#id15">Implicit <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> for Destructors</a></h1>
<p>So few destructors can throw exceptions that the default
exception-specification for destructors could be changed from nothing
(i.e. <tt class="docutils literal"><span class="pre">noexcept(false)</span></tt>) to <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> with only a tiny
amount of code breakage.  Such code is already very dangerous, and
where used properly, ought to be a well-known “caution area” that is
reasonably easily migrated.  However, we don't think this change would
be appropriate for C++0x at this late date, so we're not proposing it.</p>
</div>
<div class="section" id="proposed-changes-to-standard-wording">
<h1><a class="toc-backref" href="#id16">Proposed Changes to Standard Wording</a></h1>
<div class="section" id="keywords-lex-key">
<h2><a class="toc-backref" href="#id17">2.12 Keywords [lex.key]</a></h2>
<p>Add the new <tt class="docutils literal"><span class="pre">noexcept</span></tt> keyword to Table 3 - Keywords.</p>
</div>
<div class="section" id="allocation-functions-basic-stc-dynamic-allocation">
<h2><a class="toc-backref" href="#id18">3.7.4.1 Allocation functions [basic.stc.dynamic.allocation]</a></h2>
<p>Modify paragraph 3 as follows:</p>
<blockquote>
3 An allocation function that fails to allocate storage can invoke the currently installed new-handler function (18.6.2.3), if any. [ <em>Note</em>: A program-supplied allocation function can obtain the address of the currently installed new_handler using the <tt class="docutils literal"><span class="pre">std::set_new_handler</span></tt> function (18.6.2.4). -- <em>end note</em> ] If an allocation function declared with an empty <em>exception-specification</em> (15.4), <span class="del">throw(),</span> fails to allocate storage, it shall return a null pointer. Any other allocation function that fails to allocate storage shall indicate failure only by throwing an exception of a type that would match a handler (15.3) of type <tt class="docutils literal"><span class="pre">std::bad_alloc</span></tt> (18.6.2.1).</blockquote>
</div>
<div class="section" id="unary-expressions-expr-unary">
<h2><a class="toc-backref" href="#id19">5.3 Unary expressions [expr.unary]</a></h2>
<p>Modify the grammar in paragraph 1 as follows:</p>
<blockquote>
<p>1 Expressions with unary operators group right-to-left.</p>
<pre class="literal-block">
unary-expression:
  postfix-expression
  ++ cast-expression
  -- cast-expression
  unary-operator cast-expression
  sizeof unary-expression
  sizeof ( type-id )
  sizeof ... ( identifier )
  alignof ( type-id )
  new-expression
  delete-expression
  <span class="raw-html"><span class="ins"><i>noexcept-expression</i></span></span>
</pre>
</blockquote>
</div>
<div class="section" id="new-expr-new">
<h2><a class="toc-backref" href="#id20">5.3.4 New [expr.new]</a></h2>
<p>Modify paragraph 13 as follows:</p>
<blockquote>
13 [Note: unless an allocation function is declared with an empty exception-specification (15.4), <span class="del">throw(),</span> it indicates failure to allocate storage by throwing a <tt class="docutils literal"><span class="pre">std::bad_alloc</span></tt> exception (Clause 15, 18.6.2.1); it returns a non-null pointer otherwise. If the allocation function is declared with an empty <em>exception-specification</em>, <span class="del">throw(),</span> it returns null to indicate failure to allocate storage and a non-null pointer otherwise. -- <em>end note</em>] If the allocation function returns null, initialization shall not be done, the deallocation function shall not be called, and the value of the new-expression shall be null.</blockquote>
</div>
<div class="section" id="noexcept-operator-expr-unary-noexcept">
<h2><a class="toc-backref" href="#id21">5.3.7 noexcept operator [expr.unary.noexcept]</a></h2>
<p>(Add this new section)</p>
<blockquote>
<p>1 <span class="ins">The noexcept operator determines whether the evaluation of its operand, which is an unevaluated operand (Clause 5), can throw an exception ([except.throw]).</span></p>
<pre class="literal-block">
<span class="raw-html"><span class="ins"><i>noexcept-expression</i></span></span>
  <span class="raw-html"><span class="ins">noexcept ( <i>expression</i> )</span></span>
</pre>
<p>2 <span class="raw-html"><span class="ins">The result of the <code>noexcept</code> operator is a constant of type <code>bool</code>.</span></span></p>
<p>3 <span class="raw-html"><span class="ins">The result of the <code>noexcept</code> operator is <code>false</code> if in an evaluated context the <i>expression</i> would contain</span></span></p>
<ul class="simple">
<li><span class="raw-html"><span class="ins">a potentially evaluated call</span><a class="footnote-reference" href="#implicit-call" id="id6"><sup>6</sup></a> <span class="raw-html"><span class="ins">to a function, member function, function pointer, or member function pointer that does not have an empty <i>exception-specification</i> ([except.spec]),</span></span></li>
<li><span class="raw-html"><span class="ins">a potentially evaluated <i>throw-expression</i> ([except.throw]),</span></span></li>
<li><span class="raw-html"><span class="ins">a potentially evaluated <code>dynamic_cast</code> expression ([expr.dynamic.cast]) that requires a run-time check, or</span></span></li>
<li><span class="raw-html"><span class="ins">a potentially evaluated <code>typeid</code> expression ([expr.typeid]) applied to an expression whose type is a polymorphic class type ([class.virtual]).</span></span></li>
</ul>
<p><span class="ins">Otherwise, the result is true.</span></p>
</blockquote>
</div>
<div class="section" id="variadic-templates-temp-variadic">
<h2><a class="toc-backref" href="#id22">14.6.3 Variadic templates [temp.variadic]</a></h2>
<p>Modify the fifth bullet of paragraph 4 as follows:</p>
<blockquote>
<p>4 A <em>pack expansion</em> is a sequence of tokens that names one or more parameter packs, followed by an ellipsis. The sequence of tokens is called the <em>pattern of the expansion</em>; its syntax depends on the context in which the expansion occurs. Pack expansions can occur in the following contexts:</p>
<blockquote>
<ul class="simple">
<li>In <span class="raw-html">a<span class="del">n</span> <i><span class="ins">dynamic-</span>exception-specification</i></span> (15.4); the pattern is a <em>type-id</em>.</li>
</ul>
</blockquote>
</blockquote>
</div>
<div class="section" id="type-dependent-expressions-temp-dep-expr">
<h2><a class="toc-backref" href="#id23">14.7.2.2 Type-dependent expressions [temp.dep.expr]</a></h2>
<p>Add the following case to the list in paragraph 4:</p>
<blockquote>
<p>4 Expressions of the following forms are never type-dependent (because the type of the expression cannot be dependent):</p>
<pre class="literal-block">
<span class="raw-html"><span class="ins">noexcept ( <i>expression</i> )</span></span>
</pre>
</blockquote>
</div>
<div class="section" id="value-dependent-expressions-temp-dep-constexpr">
<h2><a class="toc-backref" href="#id24">14.7.2.3 Value-dependent expressions [temp.dep.constexpr]</a></h2>
<p>Modify paragraph 2 as follows:</p>
<blockquote>
<p>2 Expressions of the following form are value-dependent if the <em>unary-expression</em> <span class="raw-html"><span class="ins">or <i>expression</i></span></span> is type-dependent or the <em>type-id</em> is dependent:</p>
<pre class="literal-block">
sizeof <em>unary-expression</em>
sizeof ( <em>type-id</em> )
alignof ( <em>type-id</em> )
<span class="raw-html"><span class="ins">noexcept ( <i>expression</i> )</span></span>
</pre>
</blockquote>
</div>
<div class="section" id="exception-specifications-except-spec">
<h2><a class="toc-backref" href="#id25">15.4 Exception specifications [except.spec]</a></h2>
<p>Change the following paragraphs as follows:</p>
<blockquote>
<p>1 A function declaration lists exceptions that its function might directly
or indirectly throw by using an <em>exception-specification</em> as a suffix of its
declarator.</p>
<blockquote>
<p><span class="raw-html"><p><em>
exception-specification:
<blockquote class="grammar">
<span class="ins">dynamic-exception-specification</span>
<br />
<span class="ins">noexcept-specification</span>
</blockquote>
</em></p></span></p>
<p><span class="raw-html"><p><span class="ins">
<em>dynamic-exception-specification:</em>
</span>
<blockquote>
<code>throw (</code> <em>type-id-list<span class="sub">opt</span></em> <code>)</code>
</blockquote>
</p></span></p>
<p><span class="raw-html"><p><em>
type-id-list:
<blockquote>
type-id ...<span class="sub">opt</span><br />
type-id-list, type-id ...<span class="sub">opt</span>
</blockquote>
</em>
</p></span></p>
<p><span class="raw-html"><p>
<span class="ins"><em>noexcept-specification:</em></span>
<blockquote>
<span class="ins"><code>noexcept (</code> <em>constant-expression<span class="sub">opt</span></em> <code>)</code></span>
</blockquote>
</p></span></p>
<p><span class="raw-html"><span class="ins">In a <i>noexcept-specification</i>, the
<i>constant-expression</i>, if supplied, shall be a constant expression
([expr.const]) that is contextually converted to <code>bool</code>
([conv] Clause 4). In what follows, a <i>noexcept-specification</i>
<code>noexcept()</code> is equivalent to <code>noexcept(true)</code>.</span></span></p>
</blockquote>
<p>7 A function is said to <em>allow</em> an exception of type <tt class="docutils literal"><span class="pre">E</span></tt> if its <span class="raw-html"><i><span class="ins">dynamic-</span>exception-specification</i></span> contains a type <tt class="docutils literal"><span class="pre">T</span></tt> for which a handler of type <tt class="docutils literal"><span class="pre">T</span></tt> would be a match (15.3) for an exception of type <tt class="docutils literal"><span class="pre">E</span></tt>.</p>
<!-- comment :raw-html:`<span class="ins">, if its <i>noexcept-specification</i> is <code>noexcept(false)</code>, or if the function has no <i>exception-specification</i>`. -->
<p>11 A function with no <em>exception-specification</em> <span class="raw-html"><span class="ins">, or with an <i>exception-specification</i> of the form <code>noexcept(<i>constant-expression</i>)</code> where the <i>constant-expression</i> is <code>false</code>,</span></span> allows all exceptions. <span class="raw-html"><span class="ins">An <i>exception-specification</i> is <i>empty</i> if it is of the form <code>throw()</code>, <code>noexcept()</code>, or <code>noexcept(<i>constant-expression</i>)</code> where the <i>constant-expression</i> is <code>true</code>.</span></span> A function with an empty <em>exception-specification</em> <span class="raw-html"><span class="del">, <code>throw()</code>,</span></span> does not allow any exceptions.</p>
<p>14 In <span class="raw-html">a<span class="del">n</span> <i><span class="ins">dynamic-</span>exception-specification</i>,</span> a <em>type-id</em> followed by an ellipsis is a pack expansion (14.6.3).</p>
</blockquote>
<p>Add the following new paragraph:</p>
<blockquote>
<span class="raw-html"><span class="ins">15 If a function with a
<i>noexcept-specification</i> whose <i>constant-expression</i>
yields <code>true</code> throws an exception, the behavior is
undefined.  The <i>exception-specification</i> whose
<i>constant-expression</i> yields <code>true</code> is in all
other respects equivalent to the <i>exception-specification</i>
<code>throw()</code>.  The <i>exception-specification</i> whose
<i>constant-expression</i> yields <code>false</code> is equivalent
to omitting the <i>exception-specification</i> altogether.</span></span></blockquote>
<!-- comment

17.6.4.10 Restrictions on exception handling [res.on.exception.handling]
========================================================================

Modify footnote 192 (the first footnote in paragraph 2) as follows:

  192) That is, the C library functions can all be treated as if they have :del:`a throw()` :ins:`an empty` exception-specification. This allows implementations to make performance optimizations based on the absence of exceptions at runtime. -->
</div>
<div class="section" id="type-unexpected-handler-unexpected-handler">
<h2><a class="toc-backref" href="#id26">18.8.2.2 Type unexpected_handler [unexpected.handler]</a></h2>
<p>Modify paragraph 1 as follows:</p>
<blockquote>
1 The type of a handler function to be called by <tt class="docutils literal"><span class="pre">unexpected()</span></tt> when a function attempts to throw an exception not listed in its <span class="raw-html"><i><span class="ins">dynamic-</span>exception-specification</i>.</span></blockquote>
</div>
<div class="section" id="utility-components-utility">
<h2><a class="toc-backref" href="#id27">20.3 Utility components [utility]</a></h2>
<p>Change Header <tt class="docutils literal"><span class="pre">&lt;utility&gt;</span></tt> synopsis as follows:</p>
<pre class="literal-block">
// 20.3.2, forward/move:
template &lt;class T&gt; struct identity;
template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp;);
template &lt;class T&gt; typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp;);
<span class="ins">template &lt;class T&gt; typename conditional&lt;
  !nothrow_move_constructible&lt;T&gt;::value &amp;&amp; has_copy_constructor&lt;T&gt;::value,
  T const&amp;, T&amp;&amp;&gt;::type move_if_noexcept(T&amp; x);</span>
</pre>
</div>
<div class="section" id="forward-move-helpers-forward">
<h2><a class="toc-backref" href="#id28">20.3.2 forward/move helpers [forward]</a></h2>
<p>Append the following:</p>
<blockquote>
<pre class="literal-block">
<span class="ins">template &lt;class T&gt; typename conditional&lt;
  !nothrow_move_constructible&lt;T&gt;::value &amp;&amp; has_copy_constructor&lt;T&gt;::value,
  T const&amp;, T&amp;&amp;&gt;::type move_if_noexcept(T&amp; x);</span>
</pre>
<p><span class="raw-html"><span class="ins">10 <em>Returns:</em> <code>std::move(t)</code></span></span></p>
</blockquote>
</div>
<div class="section" id="header-type-traits-synopsis-meta-type-synop">
<h2><a class="toc-backref" href="#id29">20.6.2 Header <tt class="docutils literal"><span class="pre">&lt;type_traits&gt;</span></tt> synopsis [meta.type.synop]</a></h2>
<pre class="literal-block">
template &lt;class T&gt; struct has_nothrow_assign;
<span class="ins">template &lt;class T&gt; struct has_move_constructor;
template &lt;class T&gt; struct nothrow_move_constructible;

template &lt;class T&gt; struct has_move_assign;
template &lt;class T&gt; struct nothrow_move_assignable;

template &lt;class T&gt; struct has_copy_constructor;
template &lt;class T&gt; struct has_default_constructor;
template &lt;class T&gt; struct has_copy_assign;</span>

template &lt;class T&gt; struct has_virtual_destructor;
</pre>
</div>
<div class="section" id="type-properties-meta-unary-prop">
<h2><a class="toc-backref" href="#id30">20.6.4.3 Type properties [meta.unary.prop]</a></h2>
<p>Add entries to table 43:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="34%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Template</th>
<th class="head">Condition</th>
<th class="head">Preconditions</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span> <span class="pre">has_move_constructor;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> has a move constructor
(17.3.14).</td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span>
<span class="pre">nothrow_move_constructible;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">noexcept(</span> <span class="pre">T(</span> <span class="pre">make&lt;T&gt;()</span> <span class="pre">)</span> <span class="pre">)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span> <span class="pre">has_move_assign;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> has a move assignment
operator (17.3.13).</td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span>
<span class="pre">nothrow_move_assignable;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">noexcept(</span> <span class="pre">*(T*)0</span> <span class="pre">=</span> <span class="pre">make&lt;T&gt;</span> <span class="pre">)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span> <span class="pre">has_copy_constructor;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> has a copy constructor
(12.8).</td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type, an
array of unknown bound, or
(possibly cv-qualified) <tt class="docutils literal"><span class="pre">void.</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span>
<span class="pre">has_default_constructor;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> has a default constructor
(12.1).</td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type, an
array of unknown bound, or
(possibly cv-qualified) <tt class="docutils literal"><span class="pre">void.</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;class</span> <span class="pre">T&gt;</span>
<span class="pre">struct</span> <span class="pre">has_copy_assign;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> has a copy assignment
operator (12.8).</td>
<td><tt class="docutils literal"><span class="pre">T</span></tt> shall be a complete type, an
array of unknown bound, or
(possibly cv-qualified) <tt class="docutils literal"><span class="pre">void</span></tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="deque-modifiers-deque-modifiers">
<h2><a class="toc-backref" href="#id31">23.3.2.3 deque modifiers [deque.modifiers]</a></h2>
<p>Context:</p>
<pre class="literal-block">
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
void insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;;
   void insert(const_iterator position, ;
               InputIterator first, InputIterator last);

template &lt;class... Args&gt; void emplace_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_front(const T&amp; x);
void push_front(T&amp;&amp; x);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);`
</pre>
<p>Change Paragraph 2 as follows:</p>
<blockquote>
2 Remarks: If an exception is thrown other than by the copy
constructor<span class="ins">, move constructor, move assignment operator</span> or
assignment operator of <tt class="docutils literal"><span class="pre">T</span></tt> there are no effects.  <span class="raw-html"><span
class="ins">If an exception is thrown by the move constructor of a
non-CopyConstructible <code>T</code>, the effects are
unspecified.</span></span></blockquote>
<hr class="docutils" />
<p>Context:</p>
<pre class="literal-block">
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
</pre>
<p>Change paragraph 6 as follows:</p>
<blockquote>
6 Throws: Nothing unless an exception is thrown by the copy constructor,
<span class="ins">move constructor, move assignment operator</span>
or assignment operator of <tt class="docutils literal"><span class="pre">T</span></tt>.</blockquote>
</div>
<div class="section" id="vector-capacity-vector-capacity">
<h2><a class="toc-backref" href="#id32">23.3.6.2 vector capacity [vector.capacity]</a></h2>
<p>Context:</p>
<pre class="literal-block">
void reserve(size_type n);
</pre>
<p>Remove paragraph 2:</p>
<blockquote>
<span class="del">2 Requires: If value_type has a move constructor, that
constructor shall not throw any exceptions.</span></blockquote>
<p>Change paragraph 3 as follows:</p>
<blockquote>
<span class="del">3</span><span class="ins">2</span> Effects: A directive that informs a vector of a
planned change in size, so that it can manage the storage
allocation accordingly. After <tt class="docutils literal"><span class="pre">reserve()</span></tt>, <tt class="docutils literal"><span class="pre">capacity()</span></tt> is
greater or equal to the argument of reserve if reallocation
happens; and equal to the previous value of <tt class="docutils literal"><span class="pre">capacity()</span></tt>
otherwise.  Reallocation happens at this point if and only if the
current capacity is less than the argument of <tt class="docutils literal"><span class="pre">reserve()</span></tt>. If an
exception is thrown <span class="raw-html"><span class="ins">other than by the
move constructor of a non-CopyConstructible <code>T</code></span> there
are no effects.</blockquote>
<hr class="docutils" />
<p>Context:</p>
<pre class="literal-block">
void resize(size_type sz, const T&amp; c);
</pre>
<p>Change paragraph 13 to say:</p>
<blockquote>
If an exception is thrown <span class="raw-html"><span class="ins">other than
by the move constructor of a non-CopyConstructible
<code>T</code></span></span> there are no effects.</blockquote>
</div>
<div class="section" id="vector-modifiers-vector-modifiers">
<h2><a class="toc-backref" href="#id33">23.3.6.4 vector modifiers [vector.modifiers]</a></h2>
<p>Change the section as follows:</p>
<blockquote>
<pre class="literal-block">
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
void insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
  void insert(const_iterator position, InputIterator first, InputIterator last);
template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</pre>
<p><span class="del">1 Requires: If value_type has a move constructor, that constructor shall
not throw any exceptions.</span></p>
<p><span class="del">2</span><span class="ins">1</span> Remarks: Causes reallocation if the new size is
greater than the old capacity. If no reallocation happens, all the
iterators and references before the insertion point remain valid.
If an exception is thrown other than by the copy constructor
<span class="ins">move constructor, move assignment operator,</span> or assignment
operator of <tt class="docutils literal"><span class="pre">T</span></tt> or by any InputIterator operation there are no
effects.  <span class="raw-html"><span class="ins">if an exception is thrown by
the move constructor of a non-CopyConstructible <code>T</code>, the
effects are unspecified.</span></p>
<p><span class="del">3</span><span class="ins">2</span> Complexity: The complexity is linear in the number
of elements inserted plus the distance to the end of the vector.</p>
</blockquote>
<p><strong>Note to proposal reader:</strong> The strong guarantee of <tt class="docutils literal"><span class="pre">push_back</span></tt> for
CopyConstructible <tt class="docutils literal"><span class="pre">T</span></tt>s is maintained by virtue of 23.2.1
[container.requirements.general] paragraph 11.</p>
<hr class="docutils" />
<p>Context:</p>
<pre class="literal-block">
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
</pre>
<p>Change paragraph 6 as follows:</p>
<blockquote>
6 Throws: Nothing unless an exception is thrown by the copy
constructor, <span class="ins">move constructor, move assignment operator</span>, or
assignment operator of <tt class="docutils literal"><span class="pre">T</span></tt>.</blockquote>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="attribute" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>In Frankfurt, Dave proposed that we use the attribute
syntax <tt class="docutils literal"><span class="pre">[[moves(subobj1,subobj2)]]</span></tt> for this purpose.  Aside from
being controversial, it's a wart regardless of the syntax used,
adding a whole new mechanism just for move constructors but useless
elsewhere.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="x" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[2]</a></td><td>Many move-enabled operations can give the strong guarantee
regardless of whether move construction throws.  One example is
<tt class="docutils literal"><span class="pre">std::list&lt;T&gt;::push_back</span></tt>.  This issue affects only the narrow
subset of operations that need to make <em>multiple</em> explicit moves
from locations observable by the caller.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="no-diagnostic" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>In particular, we are not proposing to mandate
static checking: a <tt class="docutils literal"><span class="pre">noexcept(true)</span></tt> function can call a <tt class="docutils literal"><span class="pre">noexcept(false)</span></tt>
function without causing the program to become ill-formed or
generating a diagnostic.  Generating a diagnostic in such cases
can, of course, be implemented by any compiler as a matter of QOI.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="is-nothrow-constructible" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>See <a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2953.html">N2953</a> for a definition of
<tt class="docutils literal"><span class="pre">is_nothrow_constructible</span></tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="default-construct-swap" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[5]</a></td><td>Actually <tt class="docutils literal"><span class="pre">reserve</span></tt> and other such
operations can be optimized even for a type without non-throwing
move constructors but with a default constructor and a non-throwing
swap, by first default-constructing elements in the new array and
swapping each element into place.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="implicit-call" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td><span class="raw-html"><span class="ins">This includes implicit calls, e.g., the call to an allocation function in a <i>new-expression</i>.</span></span></td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
