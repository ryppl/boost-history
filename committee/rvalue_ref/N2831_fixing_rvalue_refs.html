<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>Fixing a Safety Problem with Rvalue References: Proposed Wording</title>
<style type="text/css">
p {text-align:justify}
li {text-align:justify}
ins {background-color:#A0FFA0}
del {background-color:#FFA0A0}

div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

</style>
</head>

<body>
<center><h1>Fixing a Safety Problem with Rvalue References: Proposed Wording</h1></center>

<p>Authors: Douglas Gregor, David Abrahams<br>
Contact: doug.gregor@gmail.com, dave@boostpro.com<br>
Organization: Apple, BoostPro Computing<br>
Date: 2009-02-07<br>
Number: D2831=09-0021<br>
Revises: N2812=08-0322</p>

<ul>
  <li><a href="#intro">Introduction</a></li>
  <li><a href="#problem">The Problem</a></li>
  <li><a href="#changes">Proposed Changes</a></li>
  <li><a href="#implementation">Implementation Experience</a></li>
  <li><a href="#wording">Proposed Wording</a>
  <ul>
    <li><a href="#5.2.9">5.2.9 Static cast [expr.static.cast]</a></li>
    <li><a href="#8.5.3">8.5.3 References [dcl.init.ref]</a></li>
    <li><a href="#13.3.3.2">13.3.3.2 Ranking implicit conversion sequences [over.ics.rank]</a></li>
    <li><a href="#20.1.1">20.1.1 Type transformations [concept.transform]</a></li>
    <li><a href="#20.1.2">20.1.2 Type classifications [concept.classify]</a></li>
    <li><a href="#20.1.3">20.1.3 Operator concepts [concept.operator]</a></li>
    <li><a href="#20.2.2">20.2.2 forward/move helpers [forward]</a></li>
    <li><a href="#20.2.3">20.2.3 Pairs [pairs]</a></li>
    <li><a href="#20.4.2.6">20.4.2.6 Tuple swap [tuple.swap]</a></li>
    <li><a href="#20.4.2.7">20.4.2.7 Tuple specialized algorithms [tuple.special]</a></li>
    <li><a href="#20.6.16.2.2">20.6.16.2.2 function modifiers [func.wrap.func.mod]</a></li>
    <li><a href="#20.7.12.2.5">20.7.12.2.5 unique_ptr modifiers [unique.ptr.single.modifiers]</a></li>
    <li><a href="#20.7.12.4">20.7.12.4 unique_ptr specialized algorithms
[unique.ptr.special]</a></li>
    <li><a href="#20.7.13.2.4">20.7.13.2.4 shared_ptr modifiers [util.smartptr.shared.mod]</a></li>
    <li><a href="#20.7.13.2.9">20.7.13.2.9 shared_ptr specialized algorithms
[util.smartptr.shared.spec]</a></li>
    <li><a href="#string::swap">21.3.6.8 basic_string::swap [string::swap]</a></li>
    <li><a href="#string.special">21.3.8.8 swap [string.special]</a></li>
    <li><a href="#string.io">21.3.8.9 Inserters and extractors [string.io]</a></li>
    <li><a href="#deque">23.2.2 Class template deque [deque]</a></li>
    <li><a href="#deque.special">23.2.2.4 deque specialized algorithms [deque.special]</a></li>
    <li><a href="#forwardlist">23.2.3 Class template forward_list [forwardlist]</a></li>
    <li><a href="#forwardlist.spec">23.2.3.6 forward_list specialized algorithms [forwardlist.spec]</a></li>
    <li><a href="#list">23.2.4 Class template list [list]</a></li>
    <li><a href="#list.special">23.2.4.5 list specialized algorithms [list.special]</a></li>
    <li><a href="#queue.defn">23.2.5.1.1 queue definition [queue.defn]</a></li>
    <li><a href="#queue.special">23.2.5.1.3 queue specialized algorithms [queue.special]</a></li>
<li><a href="#priority.queue">23.2.5.2 Class template priority_queue [priority.queue]</a></li>
<li><a href="#priqueue.special">23.2.5.2.3 priority_queue specialized algorithms [priqueue.special]</a></li> 
<li><a href="#stack.defn">23.2.5.3.1 stack definition [stack.defn]</a></li>
<li><a href="#stack.special">23.2.5.3.3 stack specialized algorithms [stack.special]</a></li>
<li><a href="#vector">23.2.6 Class template vector [vector]</a></li>
<li><a href="#vector.capacity">23.2.6.2 vector capacity [vector.capacity]</a></li>
<li><a href="#vector.special">23.2.6.5 vector specialized algorithms [vector.special]</a></li>
<li><a href="#vector.bool">23.2.7 Class vector&lt;bool&gt; [vector.bool]</a></li>
<li><a href="#map">23.3.1 Class template map [map]</a></li>
<li><a href="#map.special">23.3.1.5 map specialized algorithms [map.special]</a></li>
<li><a href="#multimap">23.3.2 Class template multimap [multimap]</a></li>
<li><a href="#multimap.special">23.3.2.4 multimap specialized algorithms [multimap.special]</a></li>
<li><a href="#set">23.3.3 Class template set [set]</a></li>
<li><a href="#set.special">23.3.3.2 set specialized algorithms [set.special]</a></li>
<li><a href="#multiset">23.3.4 Class template multiset [multiset]</a></li>
<li><a href="#multiset.special">23.3.4.2 multiset specialized algorithms [multiset.special]</a></li>
<li><a href="#unord.map">23.4.1 Class template unordered_map [unord.map]</a></li>
<li><a href="#unord.map.swap">23.4.1.3 unordered_map swap [unord.map.swap]</a></li>
<li><a href="#unord.multimap">23.4.2 Class template unordered_multimap [unord.multimap]</a></li>
<li><a href="#unord.multimap.swap">23.4.2.2 unordered_multimap swap [unord.multimap.swap]</a></li>
<li><a href="#unord.set">23.4.3 Class template unordered_set [unord.set]</a></li>
<li><a href="#unord.set.swap">23.4.3.2 unordered_set swap [unord.set.swap]</a></li>
<li><a href="#unord.multiset">23.4.4 Class template unordered_multiset [unord.multiset]</a></li>
<li><a href="#unord.multiset.swap">23.4.4.2 unordered_multiset swap [unord.multiset.swap]</a></li>
<li><a href="#iterator.iterators">24.1.1 Iterator [iterator.iterators]</a></li>
<li><a href="#move.iter.op.star">24.4.3.2.4 move_iterator::operator* [move.iter.op.star]</a></li>
<li><a href="#move.iter.op.index">24.4.3.2.12 move_iterator::operator[] [move.iter.op.index]</a></li>
<li><a href="#template.valarray">26.5.2 Class template valarray [template.valarray]</a></li>
<li><a href="#valarray.members">26.5.2.7 valarray member functions [valarray.members]</a></li>
<li><a href="#valarray.special">26.5.3.4 valarray specialized algorithms [valarray.special]</a></li>
<li><a href="#ios">27.4.4 Class template basic_ios [ios]</a></li>
<li><a href="#basic.ios.members">27.4.4.2 Member functions [basic.ios.members]</a></li>
<li><a href="#streambuf">27.5.2 Class template basic_streambuf<charT,traits> [streambuf]</a></li>
<li><a href="#streambuf.assign">27.5.2.3.1 Assignment [streambuf.assign]</a></li>
<li><a href="#iostream.format">27.6 Formatting and manipulators [iostream.format]</a></li>
<li><a href="#input.streams">27.6.1 Input streams [input.streams]</a></li>
<li><a href="#istream">27.6.1.1 Class template basic_istream [istream]</a></li>
<li><a href="#istream.assign">27.6.1.1.2 Class basic_istream assign and swap [istream.assign]</a></li>
<li><a href="#istream::extrators">27.6.1.2.3 basic_istream::operator&gt;&gt; [istream::extractors]</a></li>
<li><a href="#iostreamclass">27.6.1.5 Class template basic_iostream [iostreamclass]</a></li>
<li><a href="#iostream.assign">27.6.1.5.3 basic_iostream assign and swap [iostream.assign]</a></li>
<li><a href="#istream.rvalue">27.6.1.6 Rvalue stream extraction [istream.rvalue]</a></li>
<li><a href="#output.streams">27.6.2 Output streams [output.streams]</a></li>
<li><a href="#ostream">27.6.2.1 Class template basic_ostream [ostream]</a></li>
<li><a href="#ostream.assign">27.6.2.3 Class basic_ostream assign and swap [ostream.assign]</a></li>
<li><a href="#ostream.inserters.character">27.6.2.6.4 Character inserter function templates [ostream.inserters.character]</a></li>
<li><a href="#ostream.rvalue">27.6.2.9 Rvalue stream insertion [ostream.rvalue]</a></li>
<li><a href="#stringbuf">27.7.1 Class template basic_stringbuf [stringbuf]</a></li>
<li><a href="#stringbuf.assign">27.7.1.2 Assign and swap [stringbuf.assign]</a></li>
<li><a href="#istringstream">27.7.2 Class template basic_istringstream [istringstream]</a></li>
<li><a href="#istringstream.assign">27.7.2.2 Assign and swap [istringstream.assign]</a></li>
<li><a href="#ostringstream">27.7.3 Class template basic_ostringstream [ostringstream]</a></li>
<li><a href="#ostringstream.assign">27.7.3.2 Assign and swap [ostringstream.assign]</a></li>
<li><a href="#stringstream">27.7.4 Class template basic_stringstream [stringstream]</a></li>
<li><a href="#stringstream.assign">27.7.4.2 Assign and swap [stringstream.assign]</a></li>
<li><a href="#filebuf">27.8.1.1 Class template basic_filebuf [filebuf]</a></li>
<li><a href="#filebuf.assign">27.8.1.3 Assign and swap [filebuf.assign]</a></li>
<li><a href="#ifstream">27.8.1.6 Class template basic_ifstream [ifstream]</a></li>
<li><a href="#ifstream.assign">27.8.1.8 Assign and swap [ifstream.assign]</a></li>
<li><a href="#ofstream">27.8.1.10 Class template basic_ofstream [ofstream]</a></li>
<li><a href="#ofstream.assign">27.8.1.12 Assign and swap [ofstream.assign]</a></li>
<li><a href="#fstream">27.8.1.14 Class template basic_fstream [fstream]</a></li>
<li><a href="#fstream.assign">27.8.1.16 Assign and swap [fstream.assign]</a></li>
<li><a href="#thread.thread.class">30.2.1 Class thread [thread.thread.class]</a></li>
<li><a href="#thread.thread.id">30.2.1.1 Class thread::id [thread.thread.id]</a></li>
<li><a href="#thread.thread.member">30.2.1.5 thread members [thread.thread.member]</a></li>
<li><a href="#thread.thread.algorithm">30.2.1.7 thread specialized algorithms [thread.thread.algorithm]</a></li>
<li><a href="#thread.lock.unique">30.3.3.2 Class template unique_lock [thread.lock.unique]</a></li>
<li><a href="#thread.lock.unique.mod">30.3.3.2.3 unique_lock modifiers [thread.lock.unique.mod]</a></li>
<li><a href="#futures.task">30.5.8 Class template packaged_task [futures.task]</a></li>
    </ul>
  </li>
</ul>

<a name="intro"></a><h2>Introduction</h2>
<p><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2812.html">N2812=08-0322</a> describes a safety problem with rvalue references that can cause unintentional modification of lvalues. The problem is summarized below; however, please read N2812 for a comprehensive discussion of the motivation behind this change. This paper provides proposed wording that fixes the safety problem in both the language and in the library.<p>

<a name="problem"></a><h2>The Problem</h2>

<p>Rvalue references violate a principle which we refer to as the Principle of Type-Safe Overloading, which we express as:<p>

<div class="admonition-principle-of-type-safe-overloading-pto admonition">
<p class="first admonition-title">Principle of Type-safe Overloading</p>
<p class="last">Every function must be type-safe in isolation, <em>without regard to how it has been overloaded.</em></p>
</div>

<p>Specifically, in the common use of rvalue references to provide
overloads for both copy and move semantics, rvalue references rely on
overloading behavior to provide type safety. For example, consider <code>std::list</code>'s <code>push_back</code> operation:</p>

<pre>
template&lt;typename T&gt;
class list {
public:
   void push_back(const value_type&amp; x); // #1
   void push_back(value_type&amp;&amp; x); // #2
};
</pre>

<p>Now, when we call <code>push_back</code> with an lvalue of a type that is movable but not copyable (here, <code>std::unique_ptr</code>), we see the use of overloading to ensure type-safety. For example:</p>

<pre>
void do_push_back(std::list&lt;std::unique_ptr&lt;int&gt;&gt; &amp;l, std::unique_ptr&lt;int&gt; x) {
  l.push_back(x); // error: selects #1, which fails to instantiate
}
</pre>

<p>Here, overload resolution must select between the two overloads. Overload #1 is viable, since the lvalue reference to const can bind to an lvalue. Overload #2 is also viable, since an rvalue reference can bind to an lvalue. Overload resolution then selects #1 (the copying version of <code>push_back</code>).
Later, the instantiation of #1 will fail, because <code>std::unique_ptr</code>s are non-copyable types.<p>

<p>The end result of this process is as desired: the <code>do_push_back</code> operation attempted to pass an lvalue to an operation (<code>push_back</code>) that (conceptually) does not modify its input argument, but since the argument type does not support copying, we receive an error from the compiler. To avoid the error, we would need to explicitly say that the argument should be treated as an rvalue or provide a temporary.</p>

<p>Despite the desirable result, the mechanism used to ensure that we receive a compilation error in this example is brittle. In particular, if for some reason overload #1 is not viable, then call <code>l.push_back(x)</code> will resolve to #2, and silently steal resources from an lvalue. How could overload #1 become non-viable? One possibility is the use of concepts:</p>

<pre>
   <b>requires CopyConstructible&lt;value_type&gt;</b> void push_back(const value_type&amp; x); // #1
   <b>requires MoveConstructible&lt;value_type&gt;</b> void push_back(value_type&amp;&amp; x); // #2
</pre>

<p>Here, the fact that <code>value_type</code> is not <code>CopyConstructible</code> means that overload #1 is automatically non-viable (in fact, it doesn't even exist in the class template specialization <code>std::list&lt;std::unique_ptr&lt;int&gt;&gt;</code>), Therefore, with concepts, the call <code>l.push_back(x)</code> type-checks and selects #2, silently moving from lvalues.</p>

<p>The fundamental problem in this example is that overload #2 is violating the principle of type-safe overloading, because overload #2 <i>in isolation</i> is not safe: it silently steals resources from lvalues. The attempted fix for the problem, where we add additional overloads, will fail any time that those overloads can become non-viable in the overload sets. Simple uses of concepts expose this problem with rvalue references, but they aren't the only triggers: the issue can crop up due to any kind of template argument deduction failure.</p>

<p>This proposal eliminates the binding of rvalue references to lvalues, so that rvalue references adhere to the principle of type-safe overloading. For additional motivation and a discussion of alternatives that have been proposed, please refer to <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2812.html">N2812=08-0322</a>.</p>

<a name="changes"></a><h2>Proposed Changes</h2>
<p>The language itself required relatively few changes, specifically:</p>

<ul>
  <li>Rvalue references can no longer bind to lvalues.</li>
  <li>One can explicitly <code>static_cast</code> an lvalue to an rvalue without creating a temporary.</li>
</ul>

<p>The library changes are more extensive. However, most of the changes are specification changes that provide the same user-visible behavior while adhering to the new semantics of rvalue references. To achieve this goal, we:</p>

<ul>
  <li>Modified the signatures and implementations of <code>std::forward</code> and <code>std::move</code> to provide the same user interface under the new reference-binding rules.</li>

  <li>Added the concepts <code>LvalueReference</code> and <code>RvalueReference</code>; the former is required for <code>std::forward</code>, the latter for consistency.</li>

  <li>Reverted the rvalue-reference changes to <code>swap</code> functions throughout the library, removing rvalue-reference overloads and using lvalue references for the arguments to <code>swap</code>. This addresses library issue <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#884">884</a> and follows the guidance of an informal vote of the LWG to remove these functions.</li>

  <li>Added missing <code>Swappable</code> requirements to <code>tuple</code>'s <code>swap</code>.</li>

  <li>Added an additional <code>operator*</code> associated function to the <code>Iterator</code> and <code>HasDereference</code> concepts to permit dereferencing lvalue iterators.</li>

  <li>Changed the input and output streaming operators back to their C++03 versions by using lvalue references for the stream argument rather than rvalue references. </li>

  <li>Added new <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> overloads that accept an rvalue stream and forward that stream (as an lvalue) to the appropriate operator, so that the C++0x library still supports the use of rvalue streams throughout.<li>
  
  <li>Split the two <code>getline</code> functions into four functions to support both lvalue and rvalue streams.</li>
</ul>

<a name="implementation"></a><h2>Implementation Experience</h2>

<p>We have produced an implementation of the proposed solution in the
GNU C++ compiler, which is available as a <a
 href="http://gcc.gnu.org/ml/gcc-patches/2008-10/msg00436.html">patch
against GCC 4.3.2</a>. The actual implementation of the language
change is trivial---we merely check whether the binding computed would
bind an lvalue to an rvalue reference, and reject the binding in this
case. The changes to the standard library are slightly more involved
due to the large number of changes. We do not anticipate that this
change will have any significant impact on compilers or standard
library implementations. The GCC implementation required a day's
effort to update both the language and the library, although more
effort would certainly be required to update the test cases associated
with this feature.</p>

<a name="wording"></a><h2>Proposed Wording</h2>

<a name="5.2.9"></a><h3>5.2.9 Static cast [expr.static.cast]</h3>
<p>Add the following new paragraph after paragraph 2</p>
<ol start="3">
  <li><ins>A value of type "cv1 T2" can be cast to type "rvalue reference to cv2 T1" if "cv1 T1" is reference-compatible with "cv2 T2" (8.5.3). If T1 is a base class of T2, a program that necessitates such a cast is ill-formed if T1 is an inaccessible (Clause 11) or ambiguous (10.2) base class of T2.</ins></li>
</ol>

<a name="8.5.3"></a><h3>8.5.3 References [dcl.init.ref]</h3>
<p>Modify paragraph 5 as follows:</p>
<ol start="5">
  <li>A reference to type "cv1 T1" is initialized by an expression of
  type "cv2 T2" as follows:
  <ul>
    <li>If <ins>the reference is an lvalue reference and</ins> the
    initializer expression
      <ul>
        <li>is an lvalue (but is not a bit-field), and "cv1 T1" is reference-compatible with "cv2 T2," or</li>
        <li>has a class type (i.e., T2 is a class type) and can be implicitly converted to an lvalue of type "cv3 T3," where "cv1 T1" is reference-compatible with "cv3 T3" (this conversion is selected by enumerating the applicable conversion functions (13.3.1.6) and choosing the best one through overload resolution (13.3)), then the reference is bound directly to the initializer expression lvalue in the first case, and the reference is bound to the lvalue result of the conversion in the second case. In these cases the reference is said to bind directly to the initializer expression. [ <i>Note</i>: the usual lvalue-to-rvalue (4.1), array-to-pointer 
(4.2), and function-to-pointer (4.3) standard conversions are not needed, and therefore are suppressed, when such direct bindings to lvalues are done. -- <i>end note</i> ] 
[ <i>Example</i>: 
<pre>double d = 2.0; 
double&amp; rd = d; // rd refers to d 
const double&amp; rcd = d; // rcd refers to d 
struct A { }; 
struct B : A { } b; 
A&amp; ra = b; // ra refers to A subobject in b 
const A&amp; rca = b; // rca refers to A subobject in b </pre>
        -- <i>end example</i> ]</li>
      </ul>
    </li>
  <li>Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be const), or shall be an rvalue reference. [ <i>Example</i>: <pre>
double&amp; rd2 = 2.0; // error: not an lvalue and reference not const 
int i = 2; 
double&amp; rd3 = i; // error: type mismatch and reference not const 
double&amp;&amp; rd4 = i; // OK: reference bound to temporary double </pre>
-- <i>end example</i> ]
  <ul>
    <li>If the initializer expression is an rvalue, with T2 a class type, and "cv1 T1" is reference-compatible with "cv2 T2," the reference is bound to the object represented by the rvalue (see 3.10) or to a sub-object within that object. [ <i>Example</i>: <pre>
struct A { }; 
struct B : A { } b; 
extern B f(); 
const A&amp; rca = f(); // Bound to the A subobject of the B rvalue. 
A&amp;&amp; rcb = f(); // Same as above </pre>
-- <i>end example</i> ]</li>
    <li>If the initializer expression is an rvalue, with T2 an array type, and "cv1 T1" is reference-compatible with "cv2 T2," the reference is bound to the object represented by the rvalue (see 3.10).</li>
    <li>Otherwise, <ins>if the reference is an lvalue reference or if
    "cv1 T1" is not reference-compatible with "cv2 T2",</ins> a temporary of type "cv1 T1" is created and initialized from the initializer expression using the rules for a non-reference copy initialization (8.5). The reference is then bound to the temporary. If T1 is reference-related to T2, cv1 must be the same cv-qualification as, or greater cv-qualification than, cv2 ; otherwise, the program is ill-formed. [ <i>Example</i>: <pre>
const double&amp; rcd2 = 2; // rcd2 refers to temporary with value 2.0 
double&amp;&amp; rcd3 = 2; // rcd3 refers to temporary with value 2.0 
const volatile int cvi = 1; 
const int&amp; r = cvi; // error: type qualifiers dropped </pre>
-- <i>end example</i> ]</ul></li>
  </li>
</ol>  

<a name="13.3.3.2"></a><h3>13.3.3.2 Ranking implicit conversion sequences [over.ics.rank]</h3>
<p>Modify paragraph 3 as follows</p>
<ol start="3">
  <li>Two implicit conversion sequences of the same form are
  indistinguishable conversion sequences unless one of the following
  rules applies:
  <ul>
    <li>Standard conversion sequence S1 is a better conversion
    sequence than standard conversion sequence S2 if
    <ul>
      <li>S1 is a proper subsequence of S2 (comparing the conversion
      sequences in the canonical form defined by 13.3.3.1.1, excluding
      any Lvalue Transformation; the identity conversion sequence is
      considered to be a subsequence of any non-identity conversion
      sequence) or, if not that, </li>
      <li>the rank of S1 is better than the rank of S2, or S1 and S2
      have the same rank and are distinguishable by the rules in the
      paragraph below, or, if not that,</li>
      <li>S1 and S2 differ only in their qualification conversion and yield similar types T1 and T2 (4.4), respectively, and the cv-qualification signature of type T1 is a proper subset of the cv-qualification signature of type T2, and S1 is not the deprecated string literal array-to-pointer conversion (4.2). 
[ <i>Example</i>: <pre>
int f(const int *); 
int f(int *); 
int i; 
int j = f(&amp;i); // calls f(int*) </pre>
-- <i>end example</i> ] or, if not that, </li>
      <li>S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier , and <del>either S1 binds an lvalue reference to an lvalue and S2 binds an rvalue reference or</del> S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference.
[ <i>Example</i>: <pre>
int i; 
int f(); 
int g(const int&amp;); 
int g(const int&amp;&amp;); 
int j = g(i); // calls g(const int&amp;) 
int k = g(f()); // calls g(const int&amp;&amp;)

struct A { 
  A&amp; operator&lt;&lt;(int); 
  void p() &amp;; 
  void p() &amp;&amp;; 
}; 
A&amp; operator&lt;&lt;(A&amp;&amp;, char); 
A() &lt;&lt; 1; // calls A::operator&lt;&lt;(int) 
A() &lt;&lt; 'c'; // calls operator&lt;&lt;(A&amp;&amp;, char) 
A a; 
a &lt;&lt; 1; // calls A::operator&lt;&lt;(int) 
a &lt;&lt; 'c'; // calls <del>operator&lt;&lt;(A&amp;&amp;, char)</del><ins>A::operator&lt;&lt;(int)</ins>
A().p(); // calls A::p()&amp;&amp; 
a.p(); // calls A::p()&amp; </pre> 
-- <i>end example</i> ] or, if not that, </li>
    <li>...</li>
    </ul></li>
  </ul></li>
</ol>

<a name="20.1.1"></a><h3>20.1.1 Type transformations [concept.transform]</h3>
<p>Modify the <code>RvalueOf</code> concept as follows:</p>

<pre>
auto concept RvalueOf&lt;typename T&gt; { 
  typename type = T&amp;&amp;; 
  requires <ins>Explicitly</ins>Convertible&lt;T&amp;, type&gt; &amp;&amp; Convertible&lt;T&amp;&amp;, type&gt;; 
} 
</pre>

<p>Add the following new section</p>
<a name="20.1.2"></a><h3><ins>20.1.2 Type classifications [concept.classify]</ins></h3>
<ol>
  <li><ins>The concepts in 20.1.2 provide simple type classifications that
  can be used within constrained templates.</ins></li>
  <li><ins>A program shall not provide concept maps for any concept in
  20.1.2</ins></li>
</ol>
<pre>
  <ins>concept LvalueReference&lt;typename T&gt; { }</ins>
  <ins>template&lt;typename T&gt; concept_map LvalueReference&lt;T&amp;&gt; { }</ins>
</pre>
<ol start="3">
  <li><ins><i>Note</i>: determines whether a given type is an lvalue
  reference type.</ins></li>
</ol>
<pre>
  <ins>concept RvalueReference&lt;typename T&gt; { }</ins>
  <ins>template&lt;typename T&gt; concept_map RvalueReference&lt;T&amp;&amp;&gt; { }</ins>
</pre>
<ol start="4">
  <li><ins><i>Note</i>: determines whether a given type is an rvalue
  reference type.</ins></li>
</ol>

<a name="20.1.3"></a><h3>20.1.3 Operator concepts [concept.operator]</h3>
<p>Modify the <code>HasDereference</code> concept as follows:</p>

<pre>
auto concept HasDereference&lt;typename T&gt; { 
  typename result_type; 
  <ins>result_type operator*(T&amp;);</ins>
  result_type operator*(T&amp;&amp;); 
}
</pre>

<p>Modify the <code>HasSubscript</code> concept as follows:</p>
<pre>
auto concept HasSubscript&lt;typename T, typename U&gt; { 
  typename result_type; 
  <ins>result_type operator[](T&amp;, const U&amp;);</ins>
  result_type operator[](T&amp;&amp;, const U&amp;); 
}
</pre>

<p>Modify the <code>Callable</code> concept as follows:</p>
<pre>
auto concept Callable&lt;typename F, typename... Args&gt; { 
  typename result_type; 
  <ins>result_type operator()(F&amp;, Args...);</ins>
  result_type operator()(F&amp;&amp;, Args...); 
}
</pre>

<a name="20.2.2"></a><h3>20.2.2 forward/move helpers [forward]</h3>
<p>Change the definitions of <code>forward</code> and
<code>move</code> as follows:</p>

<pre>
  template &lt;IdentityOf T&gt; <ins>requires !LvalueReference&lt;T&gt;</ins>
    T&amp;&amp; forward(IdentityOf&lt;T&gt;::type&amp; t); 
  <ins>template &lt;IdentityOf T&gt; requires LvalueReference&lt;T&gt;</ins>
    <ins>T&amp;  forward(IdentityOf&lt;T&gt;::type&amp; t);</ins>

</pre>

<ol start="2">
  <li>[ <i>Note</i>: The use of IdentityOf in forward forces users to explicitly specify the template parameter. This is necessary to get the correct forwarding semantics. -- <i>end note</i> ]</li>
  <li><i>Returns</i>: <ins><code>static_cast&lt;T&amp;&amp;&gt;(t)</code>
  or </ins><code>t</code><ins>, respectively</ins>.</li>
</ol>

<pre>
  template &lt;RvalueOf T&gt; RvalueOf&lt;T&gt;::type move(T&amp;&amp; t);
</pre>
<ol start="6">
  <li><i>Returns</i>: <code><ins>static_cast&lt;RvalueOf&lt;T&gt;::type&gt;(</ins>t<ins>)</ins></code></li>
</ol>

<a name="20.2.3"></a><h3>20.2.3 Pairs [pairs]</h3>
<p>Update the declaration of pair's <code>swap</code> as follows:</p>

<pre>
  requires Swappable&lt;T1&gt; &amp;&amp; Swappable&lt;T2&gt; void swap(pair&amp;<del>&amp;</del> p);
</pre>
<ol start="17">
  <li><i>Effects</i>: Swaps first with p.first and second with p.second.</li>
</ol>

<pre>
  template&lt;class T1, class T2&gt; 
    requires Swappable&lt;T1&gt; &amp;&amp; Swappable&lt;T2&gt; 
    void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y); 
  <del>template&lt;class T1, class T2&gt;</del>
    <del>requires Swappable&lt;T1&gt; &amp;&amp; Swappable&lt;T2&gt;</del>
    <del>void swap(pair&lt;T1, T2&gt;&amp;&amp; x, pair&lt;T1, T2&gt;&amp; y);</del>
  <del>template&lt;class T1, class T2&gt;</del>
    <del>requires Swappable&lt;T1&gt; &amp;&amp; Swappable&lt;T2&gt;</del>
    <del>void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp;&amp; y);</del>
</pre>
<ol start="20">
  <li><i>Effects</i>: <code>x.swap(y)</code></li>
</ol>

<a name="20.4.2.6"></a><h3>20.4.2.6 Tuple swap [tuple.swap]</h3>
<p>Change the declaration of tuple's <code>swap</code> as follows:</p>

<pre>
  <ins>requires Swappable&lt;Types&gt;...</ins> void swap(tuple&amp;<del>&amp;</del> rhs);
</pre>

<ol>
  <li><del><i>Requires</i>: each type in Types shall be Swappable.</del></li>
</ol>

<a name="20.4.2.7"></a><h3>20.4.2.7 Tuple specialized algorithms [tuple.special]</h3>
<p>Change the declaration of tuple's <code>swap</code> as follows:</p>

<pre>
template &lt;class... Types&gt;
  <ins>requires Swappable&lt;Types&gt;...</ins>
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y); 
<del>template &lt;class... Types&gt;</del>
  <del>void swap(tuple&lt;Types...&gt;&amp;&amp; x, tuple&lt;Types...&gt;&amp; y);</del>
<del>template &lt;class... Types&gt;</del>
  <del>void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp;&amp; y);</del>
</pre>
<ol>
  <li><i>Effects</i>: <code>x.swap(y)</code></li>
</ol>

<a name="20.6.16.2.2"></a><h3>20.6.16.2.2 function modifiers [func.wrap.func.mod]</h3>
<p>Change the declaration of function's <code>swap</code> as
follows:</p>

<pre>
void swap(function&amp;<del>&amp;</del> other); 
</pre>
<ol>
  <li><i>Effects</i>: interchanges the targets of <code>*this</code> and other. </li>
  <li><i>Throws</i>: nothing. </li>
</ol>

<a name="20.7.12.2.5"></a><h3>20.7.12.2.5 unique_ptr modifiers [unique.ptr.single.modifiers]</h3>
<p>Change the declaration of unique_ptr's <code>swap</code> as
follows:</p>

<pre>
  void swap(unique_ptr&amp;<del>&amp;</del> u);
</pre>
<ol start="8">
<li><i>Requires</i>: The deleter D shall be Swappable and shall not throw an exception under swap.</li>
<li><i>Effects</i>: The stored pointers of this and u are exchanged. The stored deleters are swap'd (un-qualified).</li>
<li><i>Throws</i>: nothing.</li>
</ol>

<a name="20.7.12.4"></a><h3>20.7.12.4 unique_ptr specialized algorithms
[unique.ptr.special]</h3>
<p>Change the declaration of unique_ptr's <code>swap</code> as
follows:</p>

<pre>
template &lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y); 
<del>template &lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp;&amp; x, unique_ptr&lt;T, D&gt;&amp; y);</del> 
<del>template &lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y);</del>
</pre>
<ol>
  <li>Effects: Calls <code>x.swap(y)</code>.</li>
</ol>

<a name="20.7.13.2.4"></a><h3>20.7.13.2.4 shared_ptr modifiers [util.smartptr.shared.mod]</h3>
<p>Change the declaration of shared_ptr's <code>swap</code> as
follows:</p>

<pre>
void swap(shared_ptr&amp;<del>&amp;</del> r);
</pre>
<ol>
  <li><i>Effects</i>: Exchanges the contents of <code>*this</code> and <code>r</code>.</li> 
  <li><i>Throws</i>: nothing.</li>
</ol>

<a name="20.7.13.2.9"></a><h3>20.7.13.2.9 shared_ptr specialized algorithms
[util.smartptr.shared.spec]</h3>
<p>Change the declaration of shared_ptr's <code>swap</code> as
follows:</p>

<pre>
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b); 
<del>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp;&amp; a, shared_ptr&lt;T&gt;&amp; b);</del>
<del>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp;&amp; b);</del>
</pre>
<ol>
  <li><i>Effects</i>: Equivalent to <code>a.swap(b)</code>.</li>
  <li><i>Throws</i>: nothing.</li>
</ol>

<a name="string::swap"></a><h3>21.3.6.8 basic_string::swap [string::swap]</h3>
<p>Change the declaration of basic_string's <code>swap</code> as follows:</p>

<pre>
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp;<del>&amp;</del> s);
</pre>

<ol>
  <li><i>Throws</i>: Nothing.</li>
  <li><i>Postcondition</i>: <code>*this</code> contains the same sequence of characters that was in s, s contains the same sequence of characters that was in <code>*this</code>.</li>
  <li><i>Complexity</i>: constant time.</li>
</ol>

<a name="string.special"></a><h3>21.3.8.8 swap [string.special]</h3>
<p>Change the declaration of basic_string's <code>swap</code> as follows:</p>

<pre>
template&lt;class charT, class traits, class Allocator&gt; 
  void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; lhs, 
            basic_string&lt;charT,traits,Allocator&gt;&amp; rhs); 
<del>template&lt;class charT, class traits, class Allocator&gt;</del>
  <del>void swap(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs,</del>
            <del>basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);</del>
<del>template&lt;class charT, class traits, class Allocator&gt;</del>
  <del>void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; lhs,</del>
            <del>basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);</del>
</pre>
<ol>
  <li><i>Effects</i>: <code>lhs.swap(rhs);</code></li>
</ol>

<a name="string.io"></a><h3>21.3.8.9 Inserters and extractors [string.io]</h3>
<p>Change the declaration of basic_string's <code>operator&gt;&gt;</code> as follows:</p>

<pre>
template&lt;class charT, class traits, class Allocator&gt; 
  basic_istream&lt;charT,traits&gt;&amp; 
   operator&gt;&gt;(basic_istream&lt;charT,traits&gt;&amp;<del>&amp;</del> is, 
              basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre>

<p>Change the declaration of basic_string's <code>operator&lt;&lt;</code> as follows:</p>

<pre>
template&lt;class charT, class traits, class Allocator&gt; 
  basic_ostream&lt;charT, traits&gt;&amp; 
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;<del>&amp;</del> os, 
               const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre>

<p>Add a second declaration of basic_string's <code>getline</code> prior to paragraph 7 as follows:</p>

<pre>
<ins>template&lt;class charT, class traits, class Allocator&gt;</ins>
  <ins>basic_istream&lt;charT,traits&gt;&amp;</ins>
    <ins>getline(basic_istream&lt;charT,traits&gt;&amp; is,</ins>
            <ins>basic_string&lt;charT,traits,Allocator&gt;&amp; str,</ins>
            <ins>charT delim);</ins>
template&lt;class charT, class traits, class Allocator&gt; 
  basic_istream&lt;charT,traits&gt;&amp; 
    getline(basic_istream&lt;charT,traits&gt;&amp;&amp; is, 
            basic_string&lt;charT,traits,Allocator&gt;&amp; str, 
            charT delim);
</pre>

<p>Add a second declaration of basic_string's <code>getline</code> prior to paragraph 11 as follows:</p>

<pre>
<ins>template&lt;class charT, class traits, class Allocator&gt;</ins>
  <ins>basic_istream&lt;charT,traits&gt;&amp;</ins>
    <ins>getline(basic_istream&lt;charT,traits&gt;&amp; is,</ins>
            <ins>basic_string&lt;charT,traits,Allocator&gt;&amp; str);</ins>
template&lt;class charT, class traits, class Allocator&gt; 
  basic_istream&lt;charT,traits&gt;&amp; 
    getline(basic_istream&lt;charT,traits&gt;&amp;&amp; is, 
            basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre>

<a name="deque"></a><h3>23.2.2 Class template deque [deque]</h3>
<p>Change the declaration of deque's <code>swap</code> as follows:</p>

<pre>
void swap(deque&lt;T,Alloc&gt;&amp;<del>&amp;</del>); 
</pre>

<a name="deque.special"></a><h3>23.2.2.4 deque specialized algorithms [deque.special]</h3>
<p>Change the declaration of deque's <code>swap</code> as follows:</p>

<pre>
template &lt;ValueType T, class Alloc&gt; 
  void swap(deque&lt;T,Alloc&gt;&amp; x, deque&lt;T,Alloc&gt;&amp; y); 
<del>template &lt;ValueType T, class Alloc&gt;</del>
  <del>void swap(deque&lt;T,Alloc&gt;&amp;&amp; x, deque&lt;T,Alloc&gt;&amp; y);</del>
<del>template &lt;ValueType T, class Alloc&gt;</del>
  <del>void swap(deque&lt;T,Alloc&gt;&amp; x, deque&lt;T,Alloc&gt;&amp;&amp; y);</del>
</pre>
<ol>
  <li><i>Effects</i>: <code>x.swap(y);</code></li>
</ol>

<a name="forwardlist"></a><h3>23.2.3 Class template forward_list [forwardlist]</h3>
<p>Change the declaration of forward_list's <code>swap</code> as follows:</p>

<pre>
void swap(forward_list&lt;T,Alloc&gt;&amp;<del>&amp;</del>); 
</pre>

<a name="forwardlist.spec"></a><h3>23.2.3.6 forward_list specialized algorithms
[forwardlist.spec]</h3>
<p>Change the declaration of forward_list's <code>swap</code> as follows:</p>

<pre>
template &lt;ValueType T, class Alloc&gt; 
  void swap(forward_list&lt;T,Alloc&gt;&amp; x, forward_list&lt;T,Alloc&gt;&amp; y); 
<del>template &lt;ValueType T, class Alloc&gt;</del>
  <del>void swap(forward_list&lt;T,Alloc&gt;&amp;&amp; x, forward_list&lt;T,Alloc&gt;&amp; y);</del>
<del>template &lt;ValueType T, class Alloc&gt;</del>
  <del>void swap(forward_list&lt;T,Alloc&gt;&amp; x, forward_list&lt;T,Alloc&gt;&amp;&amp; y);</del>
</pre>
<ol>
  <li><i>Effects</i>: x.swap(y) </li>
</ol>

<a name="list"></a><h3>23.2.4 Class template list [list]</h3>
<p>Change the declaration of list's <code>swap</code> as follows:</p>

<pre>
  void swap(list&lt;T,Alloc&gt;&amp;<del>&amp;</del>); 
</pre>

<a name="list.special"></a><h3>23.2.4.5 list specialized algorithms [list.special]</h3>
<p>Change the declaration of list's <code>swap</code> as follows:</p>

<pre>
template &lt;ValueType T, class Alloc&gt; 
  void swap(list&lt;T,Alloc&gt;&amp; x, list&lt;T,Alloc&gt;&amp; y);
<del>template &lt;ValueType T, class Alloc&gt;</del>
  <del>void swap(list&lt;T,Alloc&gt;&amp;&amp; x, list&lt;T,Alloc&gt;&amp; y);</del>
<del>template &lt;ValueType T, class Alloc&gt;</del>
  <del>void swap(list&lt;T,Alloc&gt;&amp; x, list&lt;T,Alloc&gt;&amp;&amp; y);</del>
</pre>
<ol>
  <li><i>Effects:</i> x.swap(y); </li>
</ol>

<a name="queue.defn"></a><h3>23.2.5.1.1 queue definition [queue.defn]</h3>
<p>Change the definition of queue's <code>swap</code> as follows:</p>

<pre>
  void swap(queue&amp;<del>&amp;</del> q) { swap(c, q.c); }
</pre>

<a name="queue.special"></a><h3>23.2.5.1.3 queue specialized algorithms [queue.special]</h3>
<p>Change the declaration of queue's <code>swap</code> as follows:</p>

<pre>
template &lt;ObjectType T, Swappable Cont&gt; 
  void swap(queue&lt;T, Cont&gt;&amp; x, queue&lt;T, Cont&gt;&amp; y); 
<del>template &lt;ObjectType T, Swappable Cont&gt;</del>
  <del>void swap(queue&lt;T, Cont&gt;&amp;&amp; x, queue&lt;T, Cont&gt;&amp; y);</del>
<del>template &lt;ObjectType T, Swappable Cont&gt;</del> 
  <del>void swap(queue&lt;T, Cont&gt;&amp; x, queue&lt;T, Cont&gt;&amp;&amp; y);</del>
</pre>

<ol>
  <li><i>Effects</i>: x.swap(y).</li>
</ol>

<a name="priority.queue"></a><h3>23.2.5.2 Class template priority_queue [priority.queue]</h3>
<p>Change the declaration of priority_queue's <code>swap</code> as follows:</p>

<pre>
requires Swappable&lt;Cont&gt;
  void swap(priority_queue&amp;<del>&amp;</del>); 
</pre>

<a name="priqueue.special"></a><h3>23.2.5.2.3 priority_queue specialized algorithms [priqueue.special]</h3> 
<p>Change the declaration of priority_queue's <code>swap</code> as follows:</p>

<pre>
template &lt;class T, Swappable Cont, Swappable Compare&gt; 
  void swap(priority_queue&lt;T, Cont, Compare&gt;&amp; x, priority_queue&lt;T, Cont, Compare&gt;&amp; y); 
<del>template &lt;class T, Swappable Cont, Swappable Compare&gt;</del>
  <del>void swap(priority_queue&lt;T, Cont, Compare&gt;&amp;&amp; x, priority_queue&lt;T, Cont, Compare&gt;&amp; y);</del>
<del>template &lt;class T, Swappable Cont, Swappable Compare&gt;</del>
  <del>void swap(priority_queue&lt;T, Cont, Compare&gt;&amp; x, priority_queue&lt;T, Cont, Compare&gt;&amp;&amp; y);</del>
</pre>

<ol>
  <li><i>Effects</i>: x.swap(y).</li>
</ol>

<a name="stack.defn"></a><h3>23.2.5.3.1 stack definition [stack.defn]</h3>
<p>Change the definition of stack's <code>swap</code> as follows:</p>

<pre>
requires Swappable&lt;Cont&gt;
  void swap(stack&amp;<del>&amp;</del> s) { swap(c, s.c); } 
</pre>

<a name="stack.special"></a><h3>23.2.5.3.3 stack specialized algorithms [stack.special]</h3>

<pre>
template &lt;ObjectType T, Swappable Cont&gt; 
  void swap(stack&lt;T, Cont&gt;&amp; x, stack&lt;T, Cont&gt;&amp; y); 
<del>template &lt;ObjectType T, Swappable Cont&gt;</del>
  <del>void swap(stack&lt;T, Cont&gt;&amp;&amp; x, stack&lt;T, Cont&gt;&amp; y);</del> 
<del>template &lt;ObjectType T, Swappable Cont&gt;</del> 
  <del>void swap(stack&lt;T, Cont&gt;&amp; x, stack&lt;T, Cont&gt;&amp;&amp; y);</del>
</pre>
<ol>
  <li><i>Effects</i>: x.swap(y).</li>
</ol>

<a name="vector"></a><h3>23.2.6 Class template vector [vector]</h3>
<p>Change the declaration of vector's <code>swap</code> as follows:</p>

<pre>
  void swap(vector&lt;T,Alloc&gt;&amp;<del>&amp;</del>); 
</pre>

<a name="vector.capacity"></a><h3>23.2.6.2 vector capacity [vector.capacity]</h3>
<p>Modify the declaration of vector's <code>swap</code> prior to paragraph 8 as follows:</p>

<pre>
  void swap(vector&lt;T,Alloc&gt;&amp;<del>&amp;</del>); 
</pre>

<a name="vector.special"></a><h3>23.2.6.5 vector specialized algorithms [vector.special]</h3>
<p>Change the declaration of vector's <code>swap</code> as follows:</p>

<pre>
template &lt;ValueType T, class Alloc&gt; 
  void swap(vector&lt;T,Alloc&gt;&amp; x, vector&lt;T,Alloc&gt;&amp; y); 
<del>template &lt;ValueType T, class Alloc&gt;</del>
  <del>void swap(vector&lt;T,Alloc&gt;&amp;&amp; x, vector&lt;T,Alloc&gt;&amp;</del> y); 
<del>template &lt;ValueType T, class Alloc&gt;</del>
  <del>void swap(vector&lt;T,Alloc&gt;&amp; x, vector&lt;T,Alloc&gt;&amp;&amp; y);</del>
</pre>

<ol>
  <li>Effects: x.swap(y);</li>
</ol>

<a name="vector.bool"></a><h3>23.2.7 Class vector&lt;bool&gt; [vector.bool]</h3>
<p>Change the declaration of vector&lt;bool&gt;'s <code>swap</code> as follows:</p>

<pre>
void swap(vector&lt;bool,Alloc&gt;&amp;<del>&amp;</del>);
</pre>

<a name="map"></a><h3>23.3.1 Class template map [map]</h3>
<p>Change the declaration of map's <code>swap</code> as follows:</p>

<pre>
void swap(map&lt;Key,T,Compare,Alloc&gt;&amp;<del>&amp;</del>);
</pre>

<a name="map.special"></a><h3>23.3.1.5 map specialized algorithms [map.special]</h3>
<p>Remove map's <code>swap</code> algorithms that operate on rvalue references:</p>

<pre>
template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt; 
  void swap(map&lt;Key,T,Compare,Alloc&gt;&amp; x, 
            map&lt;Key,T,Compare,Alloc&gt;&amp; y); 
<del>template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt;</del>
  <del>void swap(map&lt;Key,T,Compare,Alloc&gt;&amp;&amp; x,</del>
            <del>map&lt;Key,T,Compare,Alloc&gt;&amp; y);</del> 
<del>template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt;</del> 
  <del>void swap(map&lt;Key,T,Compare,Alloc&gt;&amp; x,</del>
            <del>map&lt;Key,T,Compare,Alloc&gt;&amp;&amp; y);</del>
</pre>

<a name="multimap"></a><h3>23.3.2 Class template multimap [multimap]</h3>
<p>Change the declaration of multimap's <code>swap</code> as follows:</p>

<pre>
void swap(multimap&lt;Key,T,Compare,Alloc&gt;&amp;<del>&amp;</del>);
</pre>

<a name="multimap.special"></a><h3>23.3.2.4 multimap specialized algorithms [multimap.special]</h3>
<p>Remove multimap's <code>swap</code> algorithms that operate on rvalue references:</p>

<pre>
template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt; 
  void swap(multimap&lt;Key,T,Compare,Alloc&gt;&amp; x, 
            multimap&lt;Key,T,Compare,Alloc&gt;&amp; y); 
<del>template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt;</del>
  <del>void swap(multimap&lt;Key,T,Compare,Alloc&gt;&amp;&amp; x,</del>
            <del>multimap&lt;Key,T,Compare,Alloc&gt;&amp; y);</del> 
<del>template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt;</del> 
  <del>void swap(multimap&lt;Key,T,Compare,Alloc&gt;&amp; x,</del>
            <del>multimap&lt;Key,T,Compare,Alloc&gt;&amp;&amp; y);</del>
</pre>

<a name="set"></a><h3>23.3.3 Class template set [set]</h3>
<p>Change the declaration of set's <code>swap</code> as follows:</p>

<pre>
void swap(set&lt;Key,T,Compare,Alloc&gt;&amp;<del>&amp;</del>);
</pre>

<a name="set.special"></a><h3>23.3.3.2 set specialized algorithms [set.special]</h3>
<p>Remove set's <code>swap</code> algorithms that operate on rvalue references:</p>

<pre>
template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt; 
  void swap(set&lt;Key,T,Compare,Alloc&gt;&amp; x, 
            set&lt;Key,T,Compare,Alloc&gt;&amp; y); 
<del>template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt;</del>
  <del>void swap(set&lt;Key,T,Compare,Alloc&gt;&amp;&amp; x,</del>
            <del>set&lt;Key,T,Compare,Alloc&gt;&amp; y);</del> 
<del>template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt;</del> 
  <del>void swap(set&lt;Key,T,Compare,Alloc&gt;&amp; x,</del>
            <del>set&lt;Key,T,Compare,Alloc&gt;&amp;&amp; y);</del>
</pre>

<a name="multiset"></a><h3>23.3.4 Class template multiset [multiset]</h3>
<p>Change the declaration of multiset's <code>swap</code> as follows:</p>

<pre>
void swap(multiset&lt;Key,T,Compare,Alloc&gt;&amp;<del>&amp;</del>);
</pre>

<a name="multiset.special"></a><h3>23.3.4.2 multiset specialized algorithms [multiset.special]</h3>
<p>Remove multiset's <code>swap</code> algorithms that operate on rvalue references:</p>

<pre>
template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt; 
  void swap(multiset&lt;Key,T,Compare,Alloc&gt;&amp; x, 
            multiset&lt;Key,T,Compare,Alloc&gt;&amp; y); 
<del>template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt;</del>
  <del>void swap(multiset&lt;Key,T,Compare,Alloc&gt;&amp;&amp; x,</del>
            <del>multiset&lt;Key,T,Compare,Alloc&gt;&amp; y);</del> 
<del>template &lt;ValueType Key, ValueType T, class Compare, class Alloc&gt;</del> 
  <del>void swap(multiset&lt;Key,T,Compare,Alloc&gt;&amp; x,</del>
            <del>multiset&lt;Key,T,Compare,Alloc&gt;&amp;&amp; y);</del>
</pre>

<a name="unord.map"></a><h3>23.4.1 Class template unordered_map [unord.map]</h3>
<p>Change the declaration of unordered_map's <code>swap</code> as follows:</p>

<pre>
  void swap(unordered_map&amp;<del>&amp;</del>);
</pre>

<a name="unord.map.swap"></a><h3>23.4.1.3 unordered_map swap [unord.map.swap]</h3>
<p>Remove unordered_map's <code>swap</code> algorithms that operate on rvalue references:</p>

<pre>
template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y); 
<del>template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt;</del>
  <del>void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,</del> 
            <del>unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</del> 
<del>template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt;</del> 
  <del>void swap(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x,</del> 
            <del>unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</del> 
</pre>

<a name="unord.multimap"></a><h3>23.4.2 Class template unordered_multimap [unord.multimap]</h3>
<p>Change the declaration of unordered_multimap's <code>swap</code> as follows:</p>

<pre>
  void swap(unordered_multimap&amp;<del>&amp;</del>);
</pre>

<a name="unord.multimap.swap"></a><h3>23.4.2.2 unordered_multimap swap [unord.multimap.swap]</h3>
<p>Remove unordered_multimap's <code>swap</code> algorithms that operate on rvalue references:</p>

<pre>
template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y); 
<del>template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt;</del>
  <del>void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,</del> 
            <del>unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</del> 
<del>template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt;</del> 
  <del>void swap(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x,</del> 
            <del>unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</del> 
</pre>

<a name="unord.set"></a><h3>23.4.3 Class template unordered_set [unord.set]</h3>
<p>Change the declaration of unordered_set's <code>swap</code> as follows:</p>

<pre>
  void swap(unordered_set&amp;<del>&amp;</del>);
</pre>

<a name="unord.set.swap"></a><h3>23.4.3.2 unordered_set swap [unord.set.swap]</h3>
<p>Remove unordered_set's <code>swap</code> algorithms that operate on rvalue references:</p>

<pre>
template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y); 
<del>template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt;</del>
  <del>void swap(unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,</del> 
            <del>unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</del> 
<del>template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt;</del> 
  <del>void swap(unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x,</del> 
            <del>unordered_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</del> 
</pre>

<a name="unord.multiset"></a><h3>23.4.4 Class template unordered_multiset [unord.multiset]</h3>
<p>Change the declaration of unordered_multiset's <code>swap</code> as follows:</p>

<pre>
  void swap(unordered_multiset&amp;<del>&amp;</del>);
</pre>

<a name="unord.multiset.swap"></a><h3>23.4.4.2 unordered_multiset swap [unord.multiset.swap]</h3>
<p>Remove unordered_multiset's <code>swap</code> algorithms that operate on rvalue references:</p>

<pre>
template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt; 
  void swap(unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x, 
            unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y); 
<del>template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt;</del>
  <del>void swap(unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,</del> 
            <del>unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; y);</del> 
<del>template &lt;ValueType Key, ValueType T, class Hash, class Pred, class Alloc&gt;</del> 
  <del>void swap(unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp;&amp; x,</del> 
            <del>unordered_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);</del> 
</pre>

<a name="iterator.iterators"></a><h3>24.1.1 Iterator [iterator.iterators]</h3>
<p>Change the iterator concept as follows:</p>
<pre>
concept Iterator&lt;typename X&gt; : Semiregular&lt;X&gt; { 
  MoveConstructible reference = typename X::reference; 
  MoveConstructible postincrement_result; 
  requires HasDereference&lt;postincrement_result&gt;; 
  <ins>reference operator*(X&amp;);</ins>
  reference operator*(X&amp;&amp;); 
  X&amp; operator++(X&amp;); 
  postincrement_result operator++(X&amp;, int); 
}
</pre>

<a name="move.iter.op.star"></a><h3>24.4.3.2.4 move_iterator::operator* [move.iter.op.star]</h3>

<pre>
reference operator*() const;
</pre>

<ol>
  <li><i>Returns</i>: <code><ins>std::move(</ins>*current<ins>)</ins></code><del>, implicitly converted to an rvalue reference</del>.</li>
</ol>

<a name="move.iter.op.index"></a><h3>24.4.3.2.12 move_iterator::operator[] [move.iter.op.index]</h3>

<pre>
requires RandomAccessIterator<Iter> 
  unspecified operator[](difference_type n) const;
</pre>

<ol>
  <li><i>Returns</i>: <code><ins>std::move(</ins>current[n]<ins>)</ins></code><del>, implicitly converted to an rvalue reference</del>.</li>
</ol>

<a name="template.valarray"></a><h3>26.5.2 Class template valarray [template.valarray]</h3>
<p>Change the declaration of valarray's <code>swap</code> as follows:</p>

<pre>
  void swap(valarray&amp;<del>&amp;</del>); 
</pre>

<a name="valarray.members"></a><h3>26.5.2.7 valarray member functions [valarray.members]</h3>
<p>Change the declaration of valarray's <code>swap</code> as follows:</p>

<pre>
  void swap(valarray&amp;<del>&amp;</del>); 
</pre>

<a name="valarray.special"></a><h3>26.5.3.4 valarray specialized algorithms [valarray.special]</h3>
<p>Remove valarray's <code>swap</code> specialized algorithms that use rvalue references as follows:</p>

<pre>
template &lt;class T&gt; void swap(valarray&lt;T&gt;&amp; x, valarray&lt;T&gt;&amp; y); 
<del>template &lt;class T&gt; void swap(valarray&lt;T&gt;&amp;&amp; x, valarray&lt;T&gt;&amp; y);</del>
<del>template &lt;class T&gt; void swap(valarray&lt;T&gt;&amp; x, valarray&lt;T&gt;&amp;&amp; y);</del>
</pre>

<a name="ios"></a><h3>27.4.4 Class template basic_ios [ios]</h3>
<p>Change the declaration of basic_ios's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_ios&amp;<del>&amp;</del> rhs);
</pre>

<a name="basic.ios.members"></a><h3>27.4.4.2 Member functions [basic.ios.members]</h3>
<p>Modify the declaration of basic_ios's <code>swap</code> prior to paragraph 21 as follows:</p>

<pre>
  void swap(basic_ios&amp;<del>&amp;</del> rhs);
</pre>

<a name="streambuf"></a><h3>27.5.2 Class template basic_streambuf<charT,traits> [streambuf]</h3>
<p>Change the declaration of basic_streambuf's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_streambuf&amp;<del>&amp;</del> rhs);
</pre>

<a name="streambuf.assign"></a><h3>27.5.2.3.1 Assignment [streambuf.assign]</h3>
<p>Change the declaration of basic_streambuf's <code>swap</code> before paragraph 4 as follows:</p>

<pre>
  void swap(basic_streambuf&amp;<del>&amp;</del> rhs);
</pre>

<a name="iostream.format"></a><h3>27.6 Formatting and manipulators [iostream.format]</h3>
<p>Modify the header <code>&lt;istream&gt;</code> synopsis as follows:</p>

<pre>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
    class basic_istream; 

  typedef basic_istream&lt;char&gt; istream; 
  typedef basic_istream&lt;wchar_t&gt; wistream; 
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt; 
    class basic_iostream; 
  typedef basic_iostream&lt;char&gt; iostream; 
  typedef basic_iostream&lt;wchar_t&gt; wiostream;

  template &lt;class charT, class traits&gt; 
    basic_istream&lt;charT,traits&gt;&amp; ws(basic_istream&lt;charT,traits&gt;&amp; is);

  <ins>template&lt;typename charT, typename traits, typename T&gt;</ins>
    <ins>basic_istream&lt;charT, traits&gt;&amp;</ins>
    <ins>operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp;&amp; is, T&amp; x);</ins>
}
</pre>

<p>Modify the header <code>&lt;ostream&gt;</code> synopsis as follows:</p>

<pre>
namespace std { 
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt; 
    class basic_ostream; 
  typedef basic_ostream&lt;char&gt; ostream; 
  typedef basic_ostream&lt;wchar_t&gt; wostream;

  template &lt;class charT, class traits&gt; 
    basic_ostream&lt;charT,traits&gt;&amp; endl(basic_ostream&lt;charT,traits&gt;&amp; os); 
  template &lt;class charT, class traits&gt; 
    basic_ostream&lt;charT,traits&gt;&amp; ends(basic_ostream&lt;charT,traits&gt;&amp; os); 
  template &lt;class charT, class traits&gt; 
    basic_ostream&lt;charT,traits&gt;&amp; flush(basic_ostream&lt;charT,traits&gt;&amp; os); 

  <ins>template&lt;typename charT, typename traits, typename T&gt;</ins>
    <ins>basic_ostream&lt;charT, traits&gt;&amp;</ins>
    <ins>operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os, const T&amp; x);</ins>
}
</pre>

<a name="input.streams"></a><h3>27.6.1 Input streams [input.streams]</h3>
<ol>
  <li>The header <code>&lt;istream&gt;</code> defines two types and a function signature that control input from a stream buffer <ins>along with a function template that performs extraction from stream rvalues</ins>.</li>
</ol>

<a name="istream"></a><h3>27.6.1.1 Class template basic_istream [istream]</h3>
<p>Change the declaration of basic_istream's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_istream&amp;<del>&amp;</del> rhs);
</pre>

<a name="istream.assign"></a><h3>27.6.1.1.2 Class basic_istream assign and swap [istream.assign]</h3>
<p>Change the declaration of basic_istream's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_istream&amp;<del>&amp;</del> rhs);
</pre>

<p>Remove the rvalue-reference overloads of basic_istream's <code>swap</code> as follows:</p>

<pre>
template &lt;class charT, class traits&gt; 
  void swap(basic_istream&lt;charT, traits&gt;&amp; x, basic_istream&lt;charT, traits&gt;&amp; y); 
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_istream&lt;charT, traits&gt;&amp;&amp; x, basic_istream&lt;charT, traits&gt;&amp; y);</del>
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_istream&lt;charT, traits&gt;&amp; x, basic_istream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre>

<a name="istream::extrators"></a><h3>27.6.1.2.3 basic_istream::operator&gt;&gt; [istream::extractors]</h3>
<p>Change the declarations of basic_istream's <code>operator&gt;&gt;</code> prior to paragraph 7 as follows:</p>

<pre>
template&lt;class charT, class traits&gt; 
  basic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;charT,traits&gt;&amp;<del>&amp;</del> in, 
                                          charT* s); 
template&lt;class traits&gt; 
  basic_istream&lt;char,traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char,traits&gt;&amp;<del>&amp;</del> in, 
                                         unsigned char* s); 
template&lt;class traits&gt; 
  basic_istream&lt;char,traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char,traits&gt;&amp;<del>&amp;</del> in,
                                         signed char* s);
</pre>

<p>Change the declarations of basic_istream's <code>operator&gt;&gt;</code> prior to paragraph 12 as follows:</p>

<pre>
template&lt;class charT, class traits&gt; 
  basic_istream&lt;charT,traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;charT,traits&gt;&amp;<del>&amp;</del> in, 
                                          charT&amp; c); 
template&lt;class traits&gt; 
  basic_istream&lt;char,traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char,traits&gt;&amp;<del>&amp;</del> in, 
                                         unsigned char&amp; c); 
template&lt;class traits&gt; 
  basic_istream&lt;char,traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char,traits&gt;&amp;<del>&amp;</del> in, 
                                         signed char&amp; c); 
</pre>

<a name="iostreamclass"></a><h3>27.6.1.5 Class template basic_iostream [iostreamclass]</h3>
<p>Change the declaration of basic_iostream's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_iostream&amp;<del>&amp;</del> rhs);
</pre>

<a name="iostream.assign"></a><h3>27.6.1.5.3 basic_iostream assign and swap [iostream.assign]</h3>
<p>Change the declaration of basic_iostream's <code>swap</code> prior to paragraph 2 as follows:</p>

<pre>
  void swap(basic_iostream&amp;<del>&amp;</del> rhs);
</pre>

<p>Change the declaration of basic_iostream's <code>swap</code> prior to paragraph 4 as follows:</p>

<pre>
template &lt;class charT, class traits&gt; 
  void swap(basic_iostream&lt;charT, traits&gt;&amp; x, basic_iostream&lt;charT, traits&gt;&amp; y); 
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_iostream&lt;charT, traits&gt;&amp;&amp; x, basic_iostream&lt;charT, traits&gt;&amp; y);</del> 
<del>template &lt;class charT, class traits&gt;</del> 
  <del>void swap(basic_iostream&lt;charT, traits&gt;&amp; x, basic_iostream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre>

<p>Add the following new section:</p>

<a name="istream.rvalue"></a><h3><ins> 27.6.1.6 Rvalue stream extraction [istream.rvalue]</ins></h3>
<pre>
<ins>template&lt;typename charT, typename traits, typename T&gt;</ins>
  <ins>basic_istream&lt;charT, traits&gt;&amp;</ins>
  <ins>operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp;&amp; is, T&amp; x);</ins>
</pre>

<ol>
  <li><ins><i>Effects</i>: <code>is &gt;&gt; x</code></ins></li>
  <li><ins><i>Returns</i>: <code>is</code></ins></li>
</ol>

<a name="output.streams"></a><h3>27.6.2 Output streams [output.streams]</h3>
<ol>
  <li>The header <code>&lt;ostream&gt;</code> defines a type and several function signatures that control output to a stream buffer <ins>along with a function template that performs insertion into stream rvalues</ins>.</li>
</ol>

<a name="ostream"></a><h3>27.6.2.1 Class template basic_ostream [ostream]</h3>
<p>Change the declaration of basic_ostream's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_ostream&amp;<del>&amp;</del> rhs);
</pre>

<a name="ostream.assign"></a><h3>27.6.2.3 Class basic_ostream assign and swap [ostream.assign]</h3>
<p>Change the declaration of basic_ostream's <code>swap</code> prior to paragraph 3 as follows:</p>

<pre>
  void swap(basic_ostream&amp;<del>&amp;</del> rhs);
</pre>

<p>Change the declaration of basic_ostream's <code>swap</code> prior to paragraph 4 as follows:</p>

<pre>
template &lt;class charT, class traits&gt; 
  void swap(basic_ostream&lt;charT, traits&gt;&amp; x, basic_ostream&lt;charT, traits&gt;&amp; y); 
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_ostream&lt;charT, traits&gt;&amp;&amp; x, basic_ostream&lt;charT, traits&gt;&amp; y);</del>
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_ostream&lt;charT, traits&gt;&amp; x, basic_ostream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre>

<a name="ostream.inserters.character"></a><h3>27.6.2.6.4 Character inserter function templates [ostream.inserters.character]</h3>
<p>Remove the rvalue-reference overloads of <code>basic_ostream</code>'s inserter function templates prior to paragraph 1 as follows:</p>

<pre>
template&lt;class charT, class traits&gt; 
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out, 
                                          charT c); 
<del>template&lt;class charT, class traits&gt;</del>
  <del>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;&amp; out,</del>
                                          <del>charT c);</del>
template&lt;class charT, class traits&gt; 
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out, 
                                          char c);
<del>template&lt;class charT, class traits&gt; </del>
  <del>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;&amp; out,</del>
                                          <del>char c);</del>
// specialization 
template&lt;class traits&gt; 
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out, 
                                          char c); 
<del>template&lt;class traits&gt;</del>
  <del>basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;&amp; out,</del>
                                          <del>char c);</del>
// signed and unsigned 
template&lt;class traits&gt; 
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out, 
                                          signed char c); 
<del>template&lt;class traits&gt;</del>
  <del>basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;&amp; out,</del>
                                          <del>signed char c);</del>
template&lt;class traits&gt; 
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out, 
un                                          signed char c); 
<del>template&lt;class traits&gt;</del>
  <del>basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;&amp; out,</del>
                                          <del>unsigned char c);</del>
</pre>

<p>Remove the rvalue-reference overloads of <code>basic_ostream</code>'s inserter function templates prior to paragraph 3 as follows:</p>

<pre>
template&lt;class charT, class traits&gt; 
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out, 
                                          const charT* s); 
<del>template&lt;class charT, class traits&gt;</del>
  <del>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;&amp; out,</del>
                                          <del>const charT* s);</del>
template&lt;class charT, class traits&gt; 
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out, 
                                          const char* s); 
<del>template&lt;class charT, class traits&gt;</del>
  <del>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;&amp; out,</del>
                                          <del>const char* s);</del>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out, 
                                          const char* s); 
<del>template&lt;class traits&gt;</del>
  <del>basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;&amp; out,</del>
                                          <del>const char* s);</del>
template&lt;class traits&gt; 
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out, 
                                          const signed char* s); 
<del>template&lt;class traits&gt;</del>
  <del>basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;&amp; out,</del>
                                          <del>const signed char* s);</del>
template&lt;class traits&gt; 
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out, 
                                          const unsigned char* s); 
<del>template&lt;class traits&gt;</del>
  <del>basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;&amp; out,</del>
                                          <del>const unsigned char* s);</del>
</pre>

<a name="ostream.rvalue"></a><h3><ins> 27.6.2.9 Rvalue stream insertion [ostream.rvalue]</ins></h3>
<pre>
<ins>template&lt;typename charT, typename traits, typename T&gt;</ins>
  <ins>basic_ostream&lt;charT, traits&gt;&amp;</ins>
  <ins>operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os, const T&amp; x);</ins>
</pre>

<ol>
  <li><ins><i>Effects</i>: <code>os &lt;&lt; x</code></ins></li>
  <li><ins><i>Returns</i>: <code>os</code></ins></li>
</ol>

<a name="stringbuf"></a><h3>27.7.1 Class template basic_stringbuf [stringbuf]</h3>
<p>Change the declaration of basic_stringbuf's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_stringbuf&amp;<del>&amp;</del> rhs);
</pre>

<a name="stringbuf.assign"></a><h3>27.7.1.2 Assign and swap [stringbuf.assign]</h3>
<p>Change the declaration of basic_stringbuf's <code>swap</code> prior to paragraph 3 as follows:</p>

<pre>
  void swap(basic_stringbuf&amp;<del>&amp;</del> rhs);
</pre>

<p>Change the declaration of basic_stringbuf's <code>swap</code> prior to paragraph 4 as follows:</p>

<pre>
template &lt;class charT, class traits, class Allocator&gt; 
  void swap(basic_stringbuf&lt;charT, traits, Allocator&gt;&amp; x, 
            basic_stringbuf&lt;charT, traits, Allocator&gt;&amp; y); 
<del>template &lt;class charT, class traits, class Allocator&gt;</del>
  <del>void swap(basic_stringbuf&lt;charT, traits, Allocator&gt;&amp;&amp; x,</del>
            <del>basic_stringbuf&lt;charT, traits, Allocator&gt;&amp; y);</del>
<del>template &lt;class charT, class traits, class Allocator&gt;</del>
  <del>void swap(basic_stringbuf&lt;charT, traits, Allocator&gt;&amp; x,</del>
            <del>basic_stringbuf&lt;charT, traits, Allocator&gt;&amp;&amp; y);</del>
</pre>

<a name="istringstream"></a><h3>27.7.2 Class template basic_istringstream [istringstream]</h3>
<p>Change the declaration of basic_istringstream's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_istringstream&amp;<del>&amp;</del> rhs);
</pre>

<a name="istringstream.assign"></a><h3>27.7.2.2 Assign and swap [istringstream.assign]</h3>

<p>Change the declaration of basic_istringstream's <code>swap</code> prior to paragraph 3 as follows:</p>

<pre>
  void swap(basic_istringstream&amp;<del>&amp;</del> rhs);
</pre>

<p>Change the declaration of basic_istringstream's <code>swap</code> prior to paragraph 4 as follows:</p>

<pre>
template &lt;class charT, class traits, class Allocator&gt; 
  void swap(basic_istringstream&lt;charT, traits, Allocator&gt;&amp; x, 
            basic_istringstream&lt;charT, traits, Allocator&gt;&amp; y); 
<del>template &lt;class charT, class traits, class Allocator&gt;</del>
  <del>void swap(basic_istringstream&lt;charT, traits, Allocator&gt;&amp;&amp; x,</del>
            <del>basic_istringstream&lt;charT, traits, Allocator&gt;&amp; y);</del>
<del>template &lt;class charT, class traits, class Allocator&gt;</del>
  <del>void swap(basic_istringstream&lt;charT, traits, Allocator&gt;&amp; x,</del>
            <del>basic_istringstream&lt;charT, traits, Allocator&gt;&amp;&amp; y);</del>
</pre>

<a name="ostringstream"></a><h3>27.7.3 Class template basic_ostringstream [ostringstream]</h3>
<p>Change the declaration of basic_ostringstream's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_ostringstream&amp;<del>&amp;</del> rhs);
</pre>

<a name="ostringstream.assign"></a><h3>27.7.3.2 Assign and swap [ostringstream.assign]</h3>

<p>Change the declaration of basic_ostringstream's <code>swap</code> prior to paragraph 3 as follows:</p>

<pre>
  void swap(basic_ostringstream&amp;<del>&amp;</del> rhs);
</pre>

<p>Change the declaration of basic_ostringstream's <code>swap</code> prior to paragraph 4 as follows:</p>

<pre>
template &lt;class charT, class traits, class Allocator&gt; 
  void swap(basic_ostringstream&lt;charT, traits, Allocator&gt;&amp; x, 
            basic_ostringstream&lt;charT, traits, Allocator&gt;&amp; y); 
<del>template &lt;class charT, class traits, class Allocator&gt;</del>
  <del>void swap(basic_ostringstream&lt;charT, traits, Allocator&gt;&amp;&amp; x,</del>
            <del>basic_ostringstream&lt;charT, traits, Allocator&gt;&amp; y);</del>
<del>template &lt;class charT, class traits, class Allocator&gt;</del>
  <del>void swap(basic_ostringstream&lt;charT, traits, Allocator&gt;&amp; x,</del>
            <del>basic_ostringstream&lt;charT, traits, Allocator&gt;&amp;&amp; y);</del>
</pre>

<a name="stringstream"></a><h3>27.7.4 Class template basic_stringstream [stringstream]</h3>
<p>Change the declaration of basic_stringstream's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_stringstream&amp;<del>&amp;</del> rhs);
</pre>

<a name="stringstream.assign"></a><h3>27.7.4.2 Assign and swap [stringstream.assign]</h3>

<p>Change the declaration of basic_stringstream's <code>swap</code> prior to paragraph 3 as follows:</p>

<pre>
  void swap(basic_stringstream&amp;<del>&amp;</del> rhs);
</pre>

<p>Change the declaration of basic_stringstream's <code>swap</code> prior to paragraph 4 as follows:</p>

<pre>
template &lt;class charT, class traits, class Allocator&gt; 
  void swap(basic_stringstream&lt;charT, traits, Allocator&gt;&amp; x, 
            basic_stringstream&lt;charT, traits, Allocator&gt;&amp; y); 
<del>template &lt;class charT, class traits, class Allocator&gt;</del>
  <del>void swap(basic_stringstream&lt;charT, traits, Allocator&gt;&amp;&amp; x,</del>
            <del>basic_stringstream&lt;charT, traits, Allocator&gt;&amp; y);</del>
<del>template &lt;class charT, class traits, class Allocator&gt;</del>
  <del>void swap(basic_stringstream&lt;charT, traits, Allocator&gt;&amp; x,</del>
            <del>basic_stringstream&lt;charT, traits, Allocator&gt;&amp;&amp; y);</del>
</pre>

<a name="filebuf"></a><h3>27.8.1.1 Class template basic_filebuf [filebuf]</h3>
<p>Change the declaration of basic_filebuf's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_filebuf&amp;<del>&amp;</del> rhs);
</pre>

<a name="filebuf.assign"></a><h3>27.8.1.3 Assign and swap [filebuf.assign]</h3>
<p>Change the declaration of basic_filebuf's <code>swap</code> prior to paragraph 3 as follows:</p>

<pre>
  void swap(basic_filebuf&amp;<del>&amp;</del> rhs);
</pre>

<p>Change the declaration of basic_filebuf's <code>swap</code> prior to paragraph 4 as follows:</p>

<pre>
template &lt;class charT, class traits&gt; 
  void swap(basic_filebuf&lt;charT, traits&gt;&amp; x, 
            basic_filebuf&lt;charT, traits&gt;&amp; y); 
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_filebuf&lt;charT, traits&gt;&amp;&amp; x,</del>
            <del>basic_filebuf&lt;charT, traits&gt;&amp; y);</del>
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_filebuf&lt;charT, traits&gt;&amp; x,</del>
            <del>basic_filebuf&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre>

<a name="ifstream"></a><h3>27.8.1.6 Class template basic_ifstream [ifstream]</h3>
<p>Change the declaration of basic_ifstream's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_ifstream&amp;<del>&amp;</del> rhs);
</pre>

<a name="ifstream.assign"></a><h3>27.8.1.8 Assign and swap [ifstream.assign]</h3>
<p>Change the declaration of basic_ifstream's <code>swap</code> prior to paragraph 3 as follows:</p>

<pre>
  void swap(basic_ifstream&amp;<del>&amp;</del> rhs);
</pre>

<p>Change the declaration of basic_ifstream's <code>swap</code> prior to paragraph 4 as follows:</p>

<pre>
template &lt;class charT, class traits&gt; 
  void swap(basic_ifstream&lt;charT, traits&gt;&amp; x, 
            basic_ifstream&lt;charT, traits&gt;&amp; y); 
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_ifstream&lt;charT, traits&gt;&amp;&amp; x,</del>
            <del>basic_ifstream&lt;charT, traits&gt;&amp; y);</del>
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_ifstream&lt;charT, traits&gt;&amp; x,</del>
            <del>basic_ifstream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre>

<a name="ofstream"></a><h3>27.8.1.10 Class template basic_ofstream [ofstream]</h3>
<p>Change the declaration of basic_ofstream's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_ofstream&amp;<del>&amp;</del> rhs);
</pre>

<a name="ofstream.assign"></a><h3>27.8.1.12 Assign and swap [ofstream.assign]</h3>
<p>Change the declaration of basic_ofstream's <code>swap</code> prior to paragraph 3 as follows:</p>

<pre>
  void swap(basic_ofstream&amp;<del>&amp;</del> rhs);
</pre>

<p>Change the declaration of basic_ofstream's <code>swap</code> prior to paragraph 4 as follows:</p>

<pre>
template &lt;class charT, class traits&gt; 
  void swap(basic_ofstream&lt;charT, traits&gt;&amp; x, 
            basic_ofstream&lt;charT, traits&gt;&amp; y); 
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_ofstream&lt;charT, traits&gt;&amp;&amp; x,</del>
            <del>basic_ofstream&lt;charT, traits&gt;&amp; y);</del>
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_ofstream&lt;charT, traits&gt;&amp; x,</del>
            <del>basic_ofstream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre>

<a name="fstream"></a><h3>27.8.1.14 Class template basic_fstream [fstream]</h3>
<p>Change the declaration of basic_fstream's <code>swap</code> as follows:</p>

<pre>
  void swap(basic_fstream&amp;<del>&amp;</del> rhs);
</pre>

<a name="fstream.assign"></a><h3>27.8.1.16 Assign and swap [fstream.assign]</h3>
<p>Change the declaration of basic_fstream's <code>swap</code> prior to paragraph 3 as follows:</p>

<pre>
  void swap(basic_fstream&amp;<del>&amp;</del> rhs);
</pre>

<p>Change the declaration of basic_fstream's <code>swap</code> prior to paragraph 4 as follows:</p>

<pre>
template &lt;class charT, class traits&gt; 
  void swap(basic_fstream&lt;charT, traits&gt;&amp; x, 
            basic_fstream&lt;charT, traits&gt;&amp; y); 
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_fstream&lt;charT, traits&gt;&amp;&amp; x,</del>
            <del>basic_fstream&lt;charT, traits&gt;&amp; y);</del>
<del>template &lt;class charT, class traits&gt;</del>
  <del>void swap(basic_fstream&lt;charT, traits&gt;&amp; x,</del>
            <del>basic_fstream&lt;charT, traits&gt;&amp;&amp; y);</del>
</pre>

<a name="thread.thread.class"></a><h3>30.2.1 Class thread [thread.thread.class]</h3>
<p>Change the declaration of thread's <code>swap</code> as follows:</p>

<pre>
  void swap(thread&amp;<del>&amp;</del>);
</pre>

<a name="thread.thread.id"></a><h3>30.2.1.1 Class thread::id [thread.thread.id]</h3>
<p>Change the declaration of thread's <code>operator&lt;&lt;</code> prior to paragraph 18 as follows:</p>

<pre>
template&lt;class charT, class traits&gt; 
  basic_ostream&lt;charT, traits&gt;&amp; 
  operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;<del>&amp;</del> out, thread::id id); 
</pre>

<a name="thread.thread.member"></a><h3>30.2.1.5 thread members [thread.thread.member]</h3>
<p>Change the declaration of thread's <code>swap</code> as follows:</p>

<pre>
  void swap(thread&amp;<del>&amp;</del>);
</pre>

<a name="thread.thread.algorithm"></a><h3>30.2.1.7 thread specialized algorithms [thread.thread.algorithm]</h3>
<p>Remove the rvalue-reference overloads of thread's <code>swap</code> as follows:</p>

<pre>
void swap(thread&amp; x, thread&amp; y); 
<del>void swap(thread&amp;&amp; x, thread&amp; y);</del>
<del>void swap(thread&amp; x, thread&amp;&amp; y);</del>
</pre>

<a name="thread.lock.unique"></a><h3>30.3.3.2 Class template unique_lock [thread.lock.unique]</h3>
<p>Change the declaration of unique_lock's <code>swap</code> as follows:</p>

<pre>
  void swap(unique_lock&amp;<del>&amp;</del> u);
</pre>

<a name="thread.lock.unique.mod"></a><h3>30.3.3.2.3 unique_lock modifiers [thread.lock.unique.mod]</h3>
<p>Change the declaration of unique_lock's <code>swap</code> as follows:</p>

<pre>
  void swap(unique_lock&amp;<del>&amp;</del> u);
</pre>

<p>Remove the rvalue-reference overloads of unique_ptr's <code>swap</code> as follows:</p>

<pre>
template &lt;class Mutex&gt; 
  void swap(unique_lock&lt;Mutex&gt;&amp; x, unique_lock&lt;Mutex&gt;&amp; y); 
<del>template &lt;class Mutex&gt;</del> 
  <del>void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp; y);</del> 
<del>template &lt;class Mutex&gt;</del> 
  <del>void swap(unique_lock&lt;Mutex&gt;&amp; x, unique_lock&lt;Mutex&gt;&amp;&amp; y);</del> 
</pre>

<a name="futures.task"></a><h3>30.5.8 Class template packaged_task [futures.task]</h3>
<p>Change the declaration of packaged_task's <code>swap</code> as follows:</p>

<pre>
  void swap(packaged_task&amp;<del>&amp;</del> other);
</pre>

<hr>
<address></address>
<!-- hhmts start --> Last modified: Sun Feb  8 19:59:34 PST 2009 <!-- hhmts end -->
</body> </html>
