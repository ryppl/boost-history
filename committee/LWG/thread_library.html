<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/transitional.dtd">
<html lang="en">
<head>


<meta http-equiv="content-type" content="text/html; charset=US-ASCII">
<title>Thread Working Draft 16</title>

<style type="text/css">
	h1	{ text-align: center; }
	p	{ text-align: justify; }
	address	{ text-align: right; }
	li	{ text-align: justify; }
	dt	{ font-style: italic; }
	ins	{ background-color:#FFFFA0; }
	del	{ background-color:#FFFFA0; }
	table	{ border-collapse: collapse;
		  margin-left: auto; margin-right: auto; }
	th	{ padding: 3px 10px 3px 10px;
		  border: 1px solid; }
	td	{ padding: 3px 10px 3px 10px;
		  border: 1px solid; }
</style>
</head>

<body>

<address>
Document number: NXXXX=07-XXXX<br>
<br>
<a href="mailto:hinnant@twcny.rr.com">Howard E. Hinnant</a>,
<a href="mailto:Lawrence@Crowl.org">Lawrence Crowl</a>,
<a href="mailto:jeff@crystalclearsoftware.com">Jeff Garland</a>,
<a href="mailto:public@alisdairm.net">Alisdair Meredith</a>,
<a href="mailto:chris@kohlhoff.com">Chris Kohlhoff</a>,
<a href="mailto:dietmar_kuehl@yahoo.com">Dietmar K&uuml;hl</a>,
<a href="mailto:ncm@cantrip.org">Nathan Myers</a>,
<a href="mailto:prem.rao@hp.com">PremAnand M Rao</a>,
<a href="mailto:nick@usenix.org">Nick Stoughton</a>,
<a href="mailto:bdawes@acm.org">Beman Dawes</a>,
<a href="mailto:anthony@justsoftwaresolutions.co.uk">Anthony Williams</a>
<br>
2007-10-11
</address>

<h1>Multi-threading Library for Standard C++</h1>

<h2>Contents</h2>

<p>
<br><a href="#Introduction">Introduction</a>
<br><a href="#utilities">Chapter 20&nbsp;&nbsp; General utilities library [utilities]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#function.objects">20.5 Function objects [function.objects]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#unord.hash">20.5.15 Class template <code>hash</code> [unord.hash]</a>
<br><a href="#thread">Chapter 30&nbsp;&nbsp; Multi-threading library [thread]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads">30.1 Threads [thread.threads]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.class">30.1.1 Class thread [thread.threads.class]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.types">30.1.1.1 <code>thread</code> types [thread.threads.types]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.id">30.1.1.1.1 Class <code>thread::id</code> [thread.threads.id]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.constr">30.1.1.2 <code>thread</code> constructors [thread.threads.constr]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.destr">30.1.1.3 <code>thread</code> destructor [thread.threads.destr]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.assign">30.1.1.4 <code>thread</code> assignment [thread.threads.assign]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.member">30.1.1.5 <code>thread</code> members [thread.threads.member]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.static">30.1.1.6 <code>thread</code> static members [thread.threads.static]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.algorithm">30.1.1.7 <code>thread</code> specialized algorithms [thread.threads.algorithm]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.this">30.1.2 Namespace <code>this_thread</code> [thread.threads.this]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.onceflag">30.1.3 <code>struct once_flag</code> [thread.threads.onceflag]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.threads.callonce">30.1.4 <code>non-member function call_once</code> [thread.threads.callonce]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.mutex">30.2 Mutexs and locks [thread.mutex]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.mutex.concept">30.2.1 Mutex concepts [thread.mutex.concept]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.mutex.class">30.2.1.1 Class mutex [thread.mutex.class]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.mutex.recursive">30.2.1.2 Class recursive_mutex [thread.mutex.recursive]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.timed.concept">30.2.2 Timed Mutex concept [thread.timed.concept]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.timed.class">30.2.2.1 Class timed_mutex [thread.timed.class]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.timed.recursive">30.2.2.2 Class recursive_timed_mutex [thread.timed.recursive]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.lock.concept">30.2.3 Locks [thread.lock.concept]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.lock.guard">30.2.3.1 Class lock_guard [thread.lock.guard]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.lock.unique">30.2.3.2 Class unique_lock [thread.lock.unique]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.lock.algorithm">30.2.3 Generic Locking Algorithms [thread.lock.algorithm]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.condition">30.3 Condition variables [thread.condition]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.condvar">30.3.1 Class condition_variable [thread.condvar]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#thread.condvarany">30.3.2 Class condition_variable_any [thread.condvarany]</a>
<br><a href="#time">Chapter 31&nbsp;&nbsp; Date Time Library [time]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time.system">31.1 Class system_time [time.system]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time.getsystem">31.2 Function get_system_time [time.getsystem]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time.duration">31.3 Common Duration Functions [time.duration]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time.nanoseconds">31.4 Class nanoseconds [time.nanoseconds]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time.microseconds">31.5 Class microseconds [time.microseconds]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time.milliseconds">31.6 Class milliseconds [time.milliseconds]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time.seconds">31.7 Class seconds [time.seconds]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time.minutes">31.8 Class minutes [time.minutes]</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#time.hours">31.9 Class hours [time.hours]</a>
<br><a href="#References">References</a>
<br><a href="#Acknowledgments">Acknowledgments</a>
</p>

<h2><a name="Introduction">Introduction</a></h2>

<p>
This is a revision of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html">N2320</a>
which removes cancellation/interruption and changes condition variables
per the suggestions in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html">N2406</a>.
This is the course of a action
requested by the combined LWG/Concurrency working groups
at the Kona meeting.
</p>

<h2><a name="utilities">Chapter 20&nbsp;&nbsp; General utilities library [utilities]</a></h2>

<h3><a name="function.objects">20.5 Function objects [function.objects]</a></h3>

<p>
<i>Modify paragraph 2 as follows:</i>
</p>

<blockquote>
<p>
<b>Header <code>functional</code> synopsis</b>
</p>

<pre><code>
namespace std {
    ...
    <i>// Hash function specializations</i>
    ...
    <ins>struct hash&lt;std::thread::id&gt;; //should not be in this header file ?</ins>
}
</code></pre>
</blockquote>

<h3><a name="unord.hash">20.5.15 Class template <code>hash</code> [unord.hash]</a></h3>

<p>
<i>Modify paragraph 1 as follows:</i>

<blockquote>
<p>
The unordered associative containers defined in clause 23.4 use
specializations
of <code>hash</code> as the default hash function.
This class template
is only
required to be instantiable for integer types (3.9.1), floating point
types
(3.9.1), pointer types (8.3.1), and <code>std::string</code>,
<code>std::u16string</code>, <code>std::u32string</code>,
<del>and</del>
<code>std::wstring</code><ins>, and
<code>std::thread::id</code></ins>.
</p>
</blockquote>

<h2><a name="thread">Chapter 30&nbsp;&nbsp; Multi-threading library [thread]</a></h2>

<p>
The following subclauses describe components to create and manage threads
([<i>Reference
to the new section from N2429 to be inserted between 1.9 and 1.10, titled
"Multi-threaded executions and data races"</i>]),
perform mutual exclusion and locking, and communicate
between threads.
</p>

<table width="100%">
  <tbody><tr>
    <th width="50%">Subclause</th>
    <th width="50%">Header(s)</th>
  </tr>
  <tr>
    <td width="50%"><a href="#ThreadsWording">Threads</a></td>
    <td width="50%"><code>&lt;thread&gt;</code></td>
  </tr>
  <tr>
    <td width="50%"><a href="#MutexsLocksWording">Mutexs and locks</a></td>
    <td width="50%"><code>&lt;mutex&gt;</code></td>
  </tr>
  <tr>
    <td width="50%"><a href="#ConditionVariablesWording">Condition variables</a></td>
    <td width="50%"><code>&lt;cond_var&gt;</code></td>
  </tr>
</tbody></table>

<p>
Throughout this clause, the names of template parameters are used to express
type requirements.
The requirements for Duration parameters are specified in [<i>reference
to date-time library clause]</i>.
If a parameter is Predicate, <code>operator()</code>
applied to the actual template argument
shall return a value that is convertible
to <code>bool</code>.
</p>

<p>
Implementations of functions described in this clause are permitted to call
operating system or other low-level applications program interfaces (API's).
Some functions
described in this clause
are specified to throw exceptions of type <code>system_error</code>
([syserr.syserr]).
Such exceptions shall be thrown when one of these operating
system or other low-level API calls result in an error.
</p>

<p>
The <code>error_category</code> ([syserr.errcat.overview])
of the <code>error_code</code>
reported by such an exception's <code>code()</code>
member function is implementation-defined.
[<i>Note:</i>
The category is
typically <code>system_category</code> ([syserr.errcat.overview])
since these error
codes usually originate from
the underlying operating system application program
interface (API).
&mdash;<i>end note</i>]
</p>

<p>
Several classes described in this clause have members <code>
native_handle_type</code> and <code>native_handle</code>.
The presence of these
members and their semantics is implementation defined.
[<i>Note:</i>
These
members allow implementations to provide access to implementation details.
Their
names are specified to facilitate portable compile-time detection.
Actual use of
these members is inherently non-portable.
&mdash;<i>end note</i>]
</p>

<h3><a name="thread.threads">30.1 Threads [thread.threads]</a></h3>

<p>
<b>&lt;thread&gt; synopsis</b>
</p>

<blockquote>
<pre><code>
namespace std {

class thread;

void swap(thread&amp;  x, thread&amp;  y);
void swap(thread&amp;&amp; x, thread&amp;  y);
void swap(thread&amp;  x, thread&amp;&amp; y);

namespace this_thread
{
    thread::id get_id();

    void yield();
    template &lt;class Duration&gt;
        void sleep(const Duration&amp; rel_t);

}  // this_thread

struct once_flag
{
    constexpr once_flag();

    once_flag(const once_flag&amp;) = delete;
    once_flag&amp; operator=(const once_flag&amp;) = delete;
};

template&lt;class Callable, class ...Args&gt;
void call_once(once_flag&amp; flag, Callable func, Args&amp;&amp;... args);

}  // std
</code></pre>
</blockquote>

<h4><a name="thread.threads.class">30.1.1 Class thread [thread.threads.class]</a></h4>

<p>
An object of class <code>thread</code> represents and manages a thread.
It provides a mechanism to create a new thread,
for the current thread to wait for
completion of a thread,
and to perform other operations to manage and query the state of the thread.
</p>

<blockquote>
<pre><code>
class thread
{
public:
    // <i>types:</i>
    class id;
    typedef <i>implementation-defined</i> native_handle_type; <i>// See [frontmatter]</i>

    // <i>construct/copy/destroy:</i>
    thread();
    template &lt;class F, class ...Args&gt; explicit thread(F f, Args&amp;&amp;... args);
    ~thread();
    thread(const thread&amp;) = delete;
    thread(thread&amp;&amp;);
    thread&amp; operator=(const thread&amp;) = delete;
    thread&amp; operator=(thread&amp;&amp;);

    // <i>members:</i>
    void swap(thread&amp;&amp;);
    bool joinable() const;
    void join();
    void detach();
    id get_id() const;
    native_handle_type native_handle(); <i>// See [frontmatter]</i>

    // <i>static members:</i>
    static unsigned hardware_concurrency();
};
</code></pre>
</blockquote>

<p>
Class <code>thread</code> and class <code>thread::id</code>
shall be standard-layout
classes (chapter 9 [class]).
</p>

<h5><a name="thread.threads.types">30.1.1.1 <code>thread</code> types [thread.threads.types]</a></h5>

<h6><a name="thread.threads.id">30.1.1.1.1 Class <code>thread::id</code> [thread.threads.id]</a></h6>

<blockquote>
<pre><code>
class thread::id
{
public:
    id();
};

bool operator==(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
bool operator!=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
bool operator&lt;(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
bool operator&lt;=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
bool operator&gt;(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
bool operator&gt;=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);

template&lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, const thread::id&amp; id);

</code></pre>
</blockquote>

<p>
Objects of type <code>thread::id</code> represent the identity of threads.
Each
joinable thread has a unique identity.
All non-joinable threads share the same
identity, and this identify is different from that of any joinable thread.
</p>

<p>
[<i>Note:</i>
Relational operators allows <code>thread::id</code> objects
to be used as keys in associative containers.
&mdash;<i>end note</i>]
</p>

<pre><code>
id();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs an object of type <code>id</code>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>

<dt>Postcondition:</dt>
<dd>
Represents the non-joinable identity.
</dd>
</dl>

<pre><code>
bool operator==(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
If
<code><i>x</i></code> and <code><i>y</i></code> represent the same identity,
returns <code>true</code>.
Otherwise returns <code>false</code>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator!=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
<code>!(<i>x</i> == <i>y</i>)</code>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator&lt;(const thread::id&amp; x, const thread::id&amp; y);
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
a value such that <code>operator&lt;</code>
is a total ordering as described in [alg.sorting].
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator&lt;=(const thread::id&amp; x, const thread::id&amp; y);
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
<code>!(y &lt; x)</code>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator&gt;(const thread::id&amp; x, const thread::id&amp; y);
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
<code>y &lt; x</code>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator&gt;=(const thread::id&amp; x, const thread::id&amp; y);
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
<code>!(x &lt; y)</code>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, const thread::id&amp; id);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Inserts an unspecified text representation of the <code>thread::id</code> into
the stream <code>out</code>.
</dd>

<dt>Returns:</dt>
<dd>
<code>out</code>.
</dd>
</dl>

<h5><a name="thread.threads.constr">30.1.1.2 <code>thread</code> constructors [thread.threads.constr]</a></h5>

<pre><code>
thread();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs a <code>thread</code> object that does not represent an
actual thread.
</dd>

<dt>Postconditions:</dt>
<dd>
<pre><code>
get_id() == thread::id()
&amp;&amp; joinable() == false
</code></pre>

<p>
[<i>Note:</i>
This is also the state of a <code>thread</code>
object after <code>detach</code> or <code>join</code> is successfully called.
&mdash;<i>end note</i>]
</p>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template &lt;class F, class ...Args&gt; explicit thread(F f, Args&amp;&amp;... args);
</code></pre>

<dl>
<dt>Requires:</dt>
<dd>
<code>F</code> is a callable type [func.def].
If <code>f</code> is an lvalue, <code>F</code>
is <code>CopyConstructible</code>.
If <code>f</code> is an rvalue,
<code>F</code> is <code>MoveConstructible</code>.
<b>[Crowl: Is this enforced by code?]</b>
</dd>

<dt>Effects:</dt>
<dd>
Constructs an object of type <code>thread</code>
and executes <code><i>INVOKE</i>(f, t1, t2, ..., tN)</code>
in a new thread, where <code>t1, t2,
..., tN</code> are the values in <code>args...</code>.
Any return value from <code>f</code> is ignored.
If <code>f</code> terminates with an uncaught
exception, <code>std::terminate()</code> shall be called.
</dd>

<dt>Postconditions:</dt>
<dd>
<pre><code>
get_id() != thread::id()
&amp;&amp; joinable() == true
</code></pre>

<p>
<code>*this</code> represents the newly started thread.
</p>
</dd>

<dt>Throws:</dt>
<dd>
<code>system_error</code> if unable to  start the new thread.
</dd>
</dl>

<pre><code>
thread(thread&amp;&amp; <i>x</i>);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs an object of type <code>thread</code> from <code><i>x</i></code>.
</dd>

<dt>Postcondition:</dt>
<dd>
<code><i>x</i>.joinable()</code> is <code>false</code>.
<code><i>x</i>.get_id() == thread().get_id().joinable()</code>
returns the value of <code><i>x</i>.joinable()</code>
prior to the start of construction.
<code>get_id()</code> returns the value of <code><i>x</i>.get_id()</code>
prior to the
start of construction.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h5><a name="thread.threads.destr">30.1.1.3 <code>thread</code> destructor [thread.threads.destr]</a></h5>

<pre><code>
~thread();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
If <code>joinable()</code> then <code>detach()</code>,
otherwise no effects.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h5><a name="thread.threads.assign">30.1.1.4 <code>thread</code> assignment [thread.threads.assign]</a></h5>

<pre><code>
thread&amp; operator=(thread&amp;&amp; <i>x</i>);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
If <code>this</code> currently represents a <code>joinable</code> thread object,
calls
<code>detach()</code>.
Then assigns the state of <code><i>x</i></code> to <code>*this</code>
and sets <code><i>x</i></code> to a default constructed state.
</dd>

<dt>Postcondition:</dt>
<dd>
<code><i>x</i>.joinable()</code> is <code>false</code>.
<code><i>x</i>.get_id() == thread().get_id().joinable()</code> returns the
value of <code><i>x</i>.joinable()</code> prior to the
assignment.
<code>get_id()</code> returns the value of <code><i>x</i>.get_id()</code>
prior to the
assignment.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h5><a name="thread.threads.member">30.1.1.5 <code>thread</code> members [thread.threads.member]</a></h5>

<pre><code>
void swap(thread&amp;&amp; <i>x</i>);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Swaps the state of <code>*this</code> and <code><i>x</i></code>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool joinable() const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
<code>get_id() != id()</code>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
void join();
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
<code>joinable()</code> is <code>true</code>.
</dd>

<dt>Effects:</dt>
<dd>
The current thread blocks until the thread
represented by <code>*this</code> completes.
<b>[Crowl: I.e. upon completion the thread does on a release
on a memory location that the joiner does an acquire on.
I.e. there is a happens before relationship.]</b>
</dd>

<dt>Postcondition:</dt>
<dd>
After a normal return of <code>join()</code>,
<code>joinable()</code> is <code>false</code>.
If <code>join()</code> throws an exception, the thread represented by
<code>*this</code> remains <code>joinable</code>.
</dd>

<dt>Throws:</dt>
<dd>
<code>system_error</code> when an error condition occurs.
The
possible error conditions are implementation defined.
</dd>
</dl>

<pre><code>
void detach();
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
<code>joinable()</code> is <code>true</code>.
</dd>

<dt>Effects:</dt>
<dd>
The thread represented by
<code>*this</code> continues execution.
When the thread represented by
<code>*this</code> ends execution it shall release any owned resources.
<b>[Crowl: The programmer shall or the implementation shall?
Which resources?]</b>
</dd>

<dt>Postcondition:</dt>
<dd>
<code>joinable()</code> is <code>false</code>.
<code>*this</code>
does not represent a thread.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
id get_id() const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
<code>this_thread::get_id()f</code>or the thread
represented by
<code>*this.</code>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h5><a name="thread.threads.static">30.1.1.6 <code>thread</code> static members [thread.threads.static]</a></h5>

<pre><code>
unsigned hardware_concurrency();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
The number of threads that can reasonably be expected to
execute concurrently.
[<i>Note:</i>
This value should only be considered to be a hint.
&mdash;<i>end note</i>]
If this value is not computable or well defined a
return value of 1 is recommended, but not required.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h5><a name="thread.threads.algorithm">30.1.1.7 <code>thread</code> specialized algorithms [thread.threads.algorithm]</a></h5>

<pre><code>
void swap(thread&amp;  x, thread&amp;  y);
void swap(thread&amp;&amp; x, thread&amp;  y);
void swap(thread&amp;  x, thread&amp;&amp; y);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
<code>x.swap(y)</code>.
</dd>
</dl>



<h4><a name="thread.threads.this">30.1.2 Namespace <code>this_thread</code> [thread.threads.this]</a></h4>

<blockquote>
<pre><code>
namespace this_thread {

thread::id get_id();

void yield();
template &lt;class Duration&gt;
    void sleep(const Duration&amp; rel_t);

}  // this_thread
</code></pre>
</blockquote>

<pre><code>
thread::id this_thread::get_id();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
If the current thread is joinable,
returns an object of type <code>thread::id</code>
that uniquely identifies the current thread
and does not compare equal to a default constructed <code>thread::id</code>,
else returns
a default constructed <code>thread::id</code>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
void yield();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Offers the operating system the opportunity to schedule another thread.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template &lt;class Duration&gt;
    void sleep(const Duration&amp; rel_t);
</code></pre>

<dl>
<dt>Requires:</dt>
<dd>
<code>Duration</code>
shall be explicitly convertible to <code>nanoseconds</code>.
</dd>

<dt>Effects:</dt>
<dd>
The current thread blocks for at least the amount of time specified.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h4><a name="thread.threads.onceflag">30.1.3 <code>struct once_flag</code> [thread.threads.onceflag]</a></h4>

<p>
Objects of class <code>once_flag</code> are opaque data structures that allow
<code>call_once</code> to initialize data without causing a data race or
deadlock.
</p>

<pre><code>
constexpr once_flag();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs a object of type
<code>once_flag</code>.
</dd>

<dt>Postcondition:</dt>
<dd>
Internal state is set to indicate to an invocation
of <code>call_once</code> with this <code>once_flag</code> as its initial
argument that no function has been called.
</dd>
</dl>


<h4><a name="thread.threads.callonce">30.1.4 <code>non-member function call_once</code> [thread.threads.callonce]</a></h4>

<pre><code>
template&lt;class Callable, class Args...&gt;
void call_once(once_flag&amp; flag, Callable func, Args&amp;&amp;... args);
</code></pre>

<dl>
<dt>Requires:</dt>
<dd>
If <code>func</code> is an lvalue, Callable
is
<code>CopyConstructible</code>.
If <code>func</code> is an rvalue, Callable is
<code>MoveConstructible</code>.
Copying or moving (as appropriate) shall have no side effects,
and the effect of calling the
copy shall be equivalent to calling the original.
</dd>

<dt>Effects:</dt>
<dd>
The argument <code>func</code> (or a copy thereof) is called exactly once
for the <code>once_flag</code> object specified by <code>flag</code>,
as-if by invoking
<code>func(args)</code>,<code> </code>even if <code>call_once</code> is
called multiple times for the same <code>once_flag</code> object.
If multiple
calls to <code>call_once</code> with the same <code>once_flag</code> object
occur in separate threads, only one
thread shall call <code>func</code>,
and none shall proceed until the call to <code>func</code> has completed.
<b>[Crowl: I.e. the return of <code>func</code> happens before
the return of <code>call_once</code>.]</b>
If the invocation of <code>func</code> results in an exception being thrown,
the exception is propagated to the caller and the effects are as-if this
invocation of <code>call_once</code> did not occur.
</dd>

<dt>Throws:</dt>
<dd>
<code>system_error</code> or any exception propagated from <code>func</code>.
</dd>

<dt>Thread safety:</dt>
<dd>
<p>
Access to the same <code>once_flag</code> object by
calls to <code>call_once</code> from different threads shall
not result in a data race or deadlock.
<b>[Crowl: The implementation shall not introduce these.]</b>
</p>

<p>
[<i>Example:</i>
</p>

<blockquote>
<pre><code>
std::once_flag flag;

void init();

void f()
{
    std::call_once(flag,init);
}

struct initializer
{
    void operator()();
};

void g()
{
    static std::once_flag flag2;
    std::call_once(flag2,initializer());
}
</code></pre>
</blockquote>

<p>
&mdash;<i>end example</i>]
</p>
</dd>
</dl>

<h3><a name="thread.mutex">30.2 Mutexs and locks [thread.mutex]</a></h3>

<p>
<b>&lt;mutex&gt; synopsis</b>
</p>

<blockquote>
<pre><code>
namespace std {

struct mutex;
struct recursive_mutex;
struct timed_mutex;
struct recursive_timed_mutex;

struct defer_lock_t;
struct try_to_lock_t;
struct adopt_lock_t;

extern const defer_lock_t  defer_lock;
extern const try_to_lock_t try_to_lock;
extern const adopt_lock_t  adopt_lock;

class lock_error;

template &lt;class Mutex&gt; class lock_guard;
template &lt;class Mutex&gt; class unique_lock;

template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);

template &lt;class L1, class L2, class ...L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
template &lt;class L1, class L2, class ...L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);

}  // std
</code></pre>
</blockquote>

<h4><a name="thread.mutex.concept">30.2.1 Mutex concepts [thread.mutex.concept]</a></h4>

<p>
Mutex objects provide synchronization operations to avoid data races.
A
mutex object supports mutual exclusion between threads by
limiting its ownership to a single thread.
A thread  obtains ownership of a mutex object by calling <code>lock()</code>
and relinquishes ownership by calling <code>unlock()</code>.
The
thread that calls <code>lock()</code> for a mutex object shall
call <code>unlock()</code>.
Mutexes may be either recursive or
non-recursive.
The syntax is the same for both recursive and
non-recursive mutexes, but the semantics differ for the member functions
as described below.
</p>

<p>
A mutex type
shall be <code>DefaultConstructible</code> and <code>Destructible</code>.
If initialization
of a mutex type fails,
an exception of type <code>system_error</code> shall be thrown.
A mutex type is neither copyable
nor movable.
A mutex type shall have the following member functions:
</p>

<pre><code>
void lock();
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
For non-recursive mutexes the current thread shall not own the mutex.
</dd>

<dt>Effects:</dt>
<dd>
The current thread will block until the mutex is not owned by another thread.
<b>[Crowl: I.e. happens before?]</b>
Upon successful completion, the current thread owns the mutex.
</dd>

<dt>Throws:</dt>
<dd>
<code>system_error</code> when an error condition occurs.
The
possible error conditions are implementation defined.
</dd>

<dt>Thread safety:</dt>
<dd>
This is an acquire operation.
</dd>
</dl>

<pre><code>
bool try_lock();
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
For non-recursive mutexes the current thread shall not own the mutex.
</dd>

<dt>Effects:</dt>
<dd>
If ownership can be obtained without blocking,
then an attempt is made to obtain ownership.
If ownership is not obtained,
there is no effect and <code>try_lock()</code> immediately returns.
[<i>Note:</i>
It is expected that <code>try_lock()</code> almost
always obtains ownership if the lock is available,
but it is not guaranteed that it always does so.
Since a failed <code>try_lock()</code> is not an acquire operation [1.10],
the resulting memory visibility rules are weak enough
that they would render such a guarantee essentially useless.
And such a guarantee would preclude potentially interesting
<code>try_lock()</code> implementations based on <code>compare_swap</code>.
&mdash;<i>end note</i>]
</dd>

<dt>Returns:</dt>
<dd>
<code>true</code> if ownership was obtained, otherwise <code>false</code>.
</dd>

<dt>Thread safety:</dt>
<dd>
This is an acquire operation if <code>try_lock</code> returns <code>true</code>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
void unlock();
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
The current thread shall own the mutex.
</dd>

<dt>Effects:</dt>
<dd>
For a non-recursive mutex ownership is released.
For a recursive mutex
<code>unlock()</code> must be called
the same number of times which the mutex was locked
(via either <code>lock()</code> or <code>try_lock()</code>
or by any other locking function) before ownership is released.
</dd>

<dt>Thread safety:</dt>
<dd>
This is a release operation.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h5><a name="thread.mutex.class">30.2.1.1 Class mutex [thread.mutex.class]</a></h5>

<blockquote>
<pre><code>
namespace std {

struct mutex
{
public:
    mutex();
    ~mutex();

    mutex(const mutex&amp;) = delete;
    mutex&amp; operator=(const mutex&amp;) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</code></pre>
</blockquote>

<p>
The class <code>mutex</code> provides a non-recursive mutex type
which satisfies all of the Mutex requirements.
It shall be a standard-layout class (chapter 9 [class]).
</p>

<h5><a name="thread.mutex.recursive">30.2.1.2 Class recursive_mutex [thread.mutex.recursive]</a></h5>

<blockquote>
<pre><code>
namespace std {

struct recursive_mutex
{
public:
    recursive_mutex();
    ~recursive_mutex();

    recursive_mutex(const recursive_mutex&amp;) = delete;
    recursive_mutex&amp; operator=(const recursive_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</code></pre>
</blockquote>

<p>
The class <code>recursive_mutex</code> provides a recursive mutex type
which satisfies all of the Mutex requirements.
It shall be a standard-layout class (chapter 9 [class]).
</p>

<h4><a name="thread.timed.concept">30.2.2 Timed Mutex concept [thread.timed.concept]</a></h4>

<p>
To meet the requirements of the Timed Mutex concept,
types are required to meet the requirements of the Mutex concept
and to provide the member function <code>timed_lock</code>.
</p>

<pre><code>
template &lt;class Duration&gt;
    bool timed_lock(const Duration&amp; rel_time);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
For non-recursive mutexes the current thread shall not own
the mutex.
<b>[Crowl: Roundup here instead of under various locks.]</b>
</dd>

<dt>Effects:</dt>
<dd>
The function attempts to obtain ownership of the mutex
within the specified time.
If the indicated time is less than or equal to <code>0</code>,
the function still attempts to obtain ownership without
blocking (as if by calling <code>try_lock()</code>).
If the function returns within the specified time duration,
it shall have obtained ownership.
[<i>Note:</i>
As with <code>try_lock()</code>,
there is no guarantee that ownership will be obtained
if the lock is available,
but implementations are expected to make a strong effort to do so.
&mdash;<i>end note</i>]
</dd>

<dt>Returns:</dt>
<dd>
<code>true</code> if ownership was obtained, otherwise <code>false</code>.
</dd>

<dt>Thread safety:</dt>
<dd>
This is a synchronization operation.
<b>[Crowl: on the memory locations of the lock.]</b>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h5><a name="thread.timed.class">30.2.2.1 Class timed_mutex [thread.timed.class]</a></h5>

<blockquote>
<pre><code>
namespace std {

struct timed_mutex
{
public:
    timed_mutex();
    ~timed_mutex();

    timed_mutex(const timed_mutex&amp;) = delete;
    timed_mutex&amp; operator=(const timed_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    template &lt;class Duration&gt;
        bool timed_lock(const Duration&amp; rel_time);
    void unlock();

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</code></pre>
</blockquote>

<p>
The class <code>timed_mutex</code> provides a non-recursive mutex type
that satisfies all of the Timed Mutex requirements.
It shall be a standard-layout class (chapter 9 [class]).
</p>

<h5><a name="thread.timed.recursive">30.2.2.2 Class recursive_timed_mutex [thread.timed.recursive]</a></h5>

<blockquote>
<pre><code>
namespace std {

struct recursive_timed_mutex
{
public:
    recursive_timed_mutex();
    ~recursive_timed_mutex();

    recursive_timed_mutex(const recursive_timed_mutex&amp;) = delete;
    recursive_timed_mutex&amp; operator=(const recursive_timed_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    template &lt;class Duration&gt;
        bool timed_lock(const Duration&amp; rel_time);
    void unlock();

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</code></pre>
</blockquote>

<p>
The class <code>recursive_timed_mutex</code> provides a recursive mutex type
that satisfies all of the Timed Mutex requirements.
It shall be a standard-layout class (chapter 9 [class]).
</p>

<h4><a name="thread.lock.concept">30.2.3 Locks [thread.lock.concept]</a></h4>

<p>
Locks are objects that hold a reference to a mutex
and unlock the mutex during the lock's destruction
(such as when leaving block scope).
The locks do not manage the lifetime of the mutex they
reference, but only the ownership status of that mutex.
[<i>Note:</i>
Locks are intended to ease the burden
of unlocking the mutex under both normal and exceptional circumstances.
&mdash;<i>end note</i>]
</p>

<p>
Some locks may take tag types
which describe what should be done with the mutex in the lock's
constructor.
</p>

<blockquote>
<pre><code>
struct defer_lock_t  {};
struct try_to_lock_t {};
struct adopt_lock_t  {};

extern const defer_lock_t   defer_lock;
extern const try_to_lock_t  try_to_lock;
extern const adopt_lock_t   adopt_lock;
</code></pre>
</blockquote>

<p>
An exception class <code>lock_error</code>
derives from <code>exception</code> and is used to indicate
improper usage of locks
such as locking a mutex that the lock already owns, or unlocking a mutex
that the lock does not own.
</p>

<blockquote>
<pre><code>
class lock_error
    : public std::exception
{
public:
    virtual const char* what() const throw();
};
</code></pre>
</blockquote>

<h5><a name="thread.lock.guard">30.2.3.1 Class lock_guard [thread.lock.guard]</a></h5>

<blockquote>
<pre><code>
namespace std {

template &lt;class Mutex&gt;
class lock_guard
{
public:
    typedef Mutex mutex_type;

    explicit lock_guard(mutex_type&amp; m);
    lock_guard(mutex_type&amp; m, adopt_lock_t);
    ~lock_guard();

    lock_guard(lock_guard const&amp;) = delete;
    lock_guard&amp; operator=(lock_guard const&amp;) = delete;
};

}  // std
</code></pre>
</blockquote>

<p>
<code>lock_guard</code>
is used to control the ownership of a mutex within a single scope.
An invariant of the <code>lock_guard</code> object
is that it maintains the ownership of the
mutex throughout the <code>lock_guard</code>'s lifetime.
Mutex ownership can not be deferred
or transferred away from the <code>lock_guard</code>.
</p>

<pre><code>
explicit lock_guard(mutex_type&amp; m);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
If <code>mutex_type</code> is not a recursive mutex,  the current thread
does not own the mutex.
The lifetime of <code><i>m</i></code> includes the lifetime
of the <code>lock_guard</code> object.
</dd>

<dt>Effects:</dt>
<dd>
Stores a reference to <code><i>m</i></code>
and calls <code><i>m</i>.lock()</code>.
<b>[Crowl: An acquire specification is not necessary because of m.lock().]</b>
</dd>
</dl>

<pre><code>
lock_guard(mutex_type&amp; m, adopt_lock_t);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
The current thread has ownership of the mutex <code><i>m</i></code>.
The lifetime of <code><i>m</i></code> includes the lifetime of the <code>
lock_guard</code> object.
</dd>

<dt>Effects:</dt>
<dd>
Stores a reference to <code><i>m</i></code>
and performs no other operation on it.
</dd>
</dl>

<pre><code>
~lock_guard();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
<code><i>m</i>.unlock()</code>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h5><a name="thread.lock.unique">30.2.3.2 Class unique_lock [thread.lock.unique]</a></h5>

<blockquote>
<pre><code>
namespace std {

template &lt;class Mutex&gt;
class unique_lock
{
public:
    typedef Mutex mutex_type;

    unique_lock();
    explicit unique_lock(mutex_type&amp; m);
    unique_lock(mutex_type&amp; m, defer_lock_t);
    unique_lock(mutex_type&amp; m, try_to_lock_t);
    unique_lock(mutex_type&amp; m, adopt_lock_t);
    ~unique_lock();

    unique_lock(unique_lock const&amp;) = delete;
    unique_lock&amp; operator=(unique_lock const&amp;) = delete;

    unique_lock(unique_lock&amp;&amp; u);
    unique_lock&amp; operator=(unique_lock&amp;&amp; u);

    void lock();
    bool try_lock();

    template &lt;class Duration&gt;
        bool timed_lock(const Duration&amp; rel_t);
    bool timed_lock(const system_time&amp; abs_time);

    void unlock();

    bool owns_lock() const;
    operator <var>unspecified-bool-type</var> () const;
    mutex_type* mutex() const;

    void swap(unique_lock&amp;&amp; u);
    mutex_type* release();
};

template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);

}  // std
</code></pre>
</blockquote>

<p>
<code>unique_lock</code>
is used to control the ownership of a mutex within one or more scopes.
Mutex ownership
can be deferred or transferred away from the <code>unique_lock</code>.
An object of type
<code>unique_lock</code> is not copyable but is movable.
</p>

<pre><code>
unique_lock();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs an object of type <code>unique_lock</code>.
</dd>

<dt>Postconditions:</dt>
<dd>

<pre><code>
mutex() == 0
owns_lock() == false
</code></pre>
</dd>
</dl>

<pre><code>
explicit unique_lock(mutex_type&amp; m);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
If <code>mutex_type</code> is not a recursive mutex,  the current thread
does not own the mutex.
The lifetime of <code><i>m</i></code> includes the lifetime
of the <code>unique_lock</code> object.
</dd>

<dt>Effects:</dt>
<dd>
Stores a reference to <code><i>m</i></code>
and calls <code><i>m</i>.lock()</code>.
</dd>

<dt>Postconditions:</dt>
<dd>
<pre><code>
mutex() == &amp;m
owns_lock() == true
</code></pre>
</dd>
</dl>

<pre><code>
unique_lock(mutex_type&amp; m, defer_lock_t);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
If <code>mutex_type</code> is not a recursive mutex,  the current thread
does not own the mutex.
The lifetime of <code><i>m</i></code> includes the lifetime of the <code>
unique_lock</code> object.
</dd>

<dt>Effects:</dt>
<dd>
Stores a reference to <code><i>m</i></code>
and performs no other operation on it.
</dd>

<dt>Postconditions:</dt>
<dd>
<pre><code>
mutex() == &amp;m
owns_lock() == false
</code></pre>
</dd>
</dl>

<pre><code>
unique_lock(mutex_type&amp; m, try_to_lock_t);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
If <code>mutex_type</code> is not a recursive mutex, then the current thread
does not own the mutex.
The lifetime of <code><i>m</i></code> includes the lifetime of the <code>
unique_lock</code> object.
</dd>

<dt>Effects:</dt>
<dd>
Stores a reference to <code><i>m</i></code>
and calls <code><i>m</i>.try_lock()</code>.
</dd>

<dt>Postconditions:</dt>
<dd>
<pre><code>
mutex() == &amp;m
owns_lock() == <i>The result of the call to</i> <i>m</i>.try_lock()
</code></pre>
</dd>
</dl>

<pre><code>
unique_lock(mutex_type&amp; m, adopt_lock_t);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
The current thread has ownership of the mutex <code><i>m</i></code>.
The lifetime of <code><i>m</i></code> includes the lifetime of the <code>
unique_lock</code> object.
</dd>

<dt>Effects:</dt>
<dd>
Stores a reference to <code><i>m</i></code>
and performs no other operation on it.
</dd>

<dt>Postconditions:</dt>
<dd>
<pre><code>
mutex() == &amp;m
owns_lock() == true
</code></pre>
</dd>
</dl>

<pre><code>
~unique_lock();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
If <code>owns_lock()</code>
calls <code>unlock()</code> on the referenced mutex.
Otherwise there are no effects.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
unique_lock(unique_lock&amp;&amp; u);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Transfers mutex ownership (if any) from <code>u</code> to <code>this</code>.
</dd>

<dt>Postconditions:</dt>
<dd>
<pre><code>
mutex() == <i>The value of</i> u.mutex() <i>prior to the construction</i>.
owns_lock() == <i>The value of</i> u.owns_lock() <i>prior to the construction</i>.
u.mutex() == 0
u.owns_lock() == false
</code></pre>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
unique_lock&amp; operator=(unique_lock&amp;&amp; u);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
If <code>owns_lock()</code> calls <code>unlock()</code>, and then
transfers mutex ownership (if any) from <code>u</code> to <code>this</code>.
</dd>

<dt>Postconditions:</dt>
<dd>
<pre><code>
mutex() == <i>The value of</i> u.mutex() <i>prior to the construction</i>.
owns_lock() == <i>The value of</i> u.owns_lock() <i>prior to the construction</i>.
u.mutex() == 0
u.owns_lock() == false
</code></pre>
</dd>

<dt>Throws:</dt>
<dd>
<p>
Nothing.
</p>

<p>
[<i>Note:</i>
With a recursive mutex it is possible that both
<code>this</code> and <code>u</code> own the same mutex before the assignment.
In this case, <code>this</code> will own the mutex after the assignment (and
<code>u</code> will not), but the mutex's lock count will be decremented by
one.
&mdash;<i>end note</i>]
</p>
</dd>
</dl>

<pre><code>
void lock();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Calls <code>lock()</code> on the referenced mutex.
</dd>

<dt>Postcondition:</dt>
<dd>
<code>owns_lock() == true</code>.
</dd>

<dt>Throws:</dt>
<dd>
<code>lock_error</code>,
if on entry <code>owns_lock()</code> is <code>true</code>.
</dd>
</dl>

<pre><code>
bool try_lock();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Calls <code>try_lock()</code> on the referenced mutex.
</dd>

<dt>Returns:</dt>
<dd>
The result of the call to <code>try_lock()</code> on the referenced mutex.
</dd>

<dt>Postcondition:</dt>
<dd>
<code>owns_lock() == </code>The result
of the call to <code>try_lock()</code> on the referenced mutex.
</dd>

<dt>Throws:</dt>
<dd>
<code>lock_error</code>,
if on entry <code>owns_lock()</code> is <code>true</code>.
</dd>
</dl>

<pre><code>
template &lt;class Duration&gt;
   bool timed_lock(const Duration&amp; rel_t);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Calls <code>timed_lock(rel_t)</code> on the referenced mutex.
If the resolution of Duration is greater <b>[Crowl: less]</b> than
the native
resolution the time is rounded up to the nearest native resolution.
</dd>

<dt>Returns:</dt>
<dd>
The result of the call to <code>timed_lock(rel_t)</code>
on the referenced mutex.
</dd>

<dt>Postcondition:</dt>
<dd>
<code>owns_lock() == </code>The result
of the call to <code>timed_lock(rel_t)</code> on the referenced mutex.
</dd>

<dt>Throws:</dt>
<dd>
<code>lock_error</code>,
if on entry <code>owns_lock()</code> is <code>true</code>.
</dd>
</dl>

<pre><code>
void unlock();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Calls <code>unlock()</code> on the referenced mutex.
</dd>

<dt>Postcondition:</dt>
<dd>
<code>owns_lock() == false</code>.
</dd>

<dt>Throws:</dt>
<dd>
<code>lock_error</code>,
if on entry <code>owns_lock()</code> is <code>false</code>.
</dd>
</dl>

<pre><code>
bool owns_lock() const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>this</code> owns a lock on a referenced mutex,
else <code>false</code>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator <var>unspecified-bool-type</var> () const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
Non-null if <code>owns_lock()</code> would return <code>true</code>,
else returns null.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
mutex_type* mutex() const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
A pointer to the referenced mutex, or null if there is no referenced mutex.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
void swap(unique_lock&amp;&amp; u);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Swaps state with <code>u</code>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
mutex_type* release();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
A pointer to the referenced mutex, or null if there is no referenced mutex.
</dd>

<dt>Postconditions:</dt>
<dd>
<pre><code>
mutex() == 0
owns_lock() == false
</code></pre>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
<code>x.swap(y)</code>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h4><a name="thread.lock.algorithm">30.2.3 Generic Locking Algorithms [thread.lock.algorithm]</a></h4>

<pre><code>
template &lt;class L1, class L2, class ...L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
</code></pre>

<dl>
<dt>Requires:</dt>
<dd>
<p>
Each template parameter type must supply the following member functions
with semantics
corresponding to the Mutex concept,
except that <code>try_lock</code> is allowed to throw an
exception.
[<i>Note:</i>
The <code>unique_lock</code> class template meets these requirements
when suitable instantiated.
&mdash;<i>end note</i>]
</p>

<blockquote>
<pre><code>
bool try_lock();
void unlock();
</code></pre>
</blockquote>
</dd>

<dt>Effects:</dt>
<dd>
The functions attempts to lock all arguments
without blocking by calling <code>try_lock()</code>
on each of them.
If any argument can not be locked,
then all arguments which have already been locked will
be unlocked.
On return, either all arguments will be locked, or none of them will be locked.
If an
exception is thrown by a call to <code>try_lock()</code>, there are no effects.
</dd>

<dt>Returns:</dt>
<dd>
If all arguments were successfully locked, returns <code>-1</code>.
Otherwise returns a 0-based index
value indicating
which argument failed to lock.
</dd>
</dl>

<pre><code>
template &lt;class L1, class L2, class ...L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);
</code></pre>

<dl>
<dt>Requires:</dt>
<dd>
<p>
Each template parameter type must supply the following member functions
with semantics
corresponding to the Mutex concept,
except that <code>try_lock</code> is allowed to
throw an exception
[<i>Note:</i>
The <code>unique_lock</code> class template meets these requirements
when suitable instantiated.
&mdash;<i>end note</i>]
</p>

<blockquote>
<pre><code>
void lock();
bool try_lock();
void unlock();
</code></pre>
</blockquote>
</dd>

<dt>Effects:</dt>
<dd>
All arguments are locked with an algorithm that avoids deadlock.
If an exception is thrown
by a call to <code>lock()</code> or <code>try_lock()</code>,
there are no effects.
</dd>
</dl>

<h3><a name="thread.condition">30.3 Condition variables [thread.condition]</a></h3>

<p>
<b>&lt;condition_variable&gt; synopsis</b>
</p>

<blockquote>
<pre><code>
namespace std {

class condition_variable;
class condition_variable_any;

}  // std
</code></pre>
</blockquote>

<h4><a name="thread.condvar">30.3.1 Class condition_variable [thread.condvar]</a></h4>

<p>
An object of class <code>condition_variable</code>
is a synchronization primitive
used to cause a thread to wait until notified by some other
thread that some condition is met, or a UTC[(?)] time is reached.
</p>

<blockquote>
<pre><code>
namespace std {

class condition_variable
{
public:

    condition_variable();
    ~condition_variable();

    condition_variable(const condition_variable&amp;) = delete;
    condition_variable&amp; operator=(const condition_variable&amp;) = delete;

    void notify_one();
    void notify_all();
    void wait(unique_lock&lt;mutex&gt;&amp; lock);
    template &lt;class Predicate&gt;
        void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
    bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time);
    template &lt;class Predicate&gt;
        bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time, Predicate pred);

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</code></pre>
</blockquote>

<pre><code>
condition_variable();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs an object of class <code>condition_variable</code>.
</dd>
</dl>

<pre><code>
~condition_variable();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Destroys the object.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
void notify_one();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
<p>
If any threads are blocked waiting for <code>*this</code>,
unblocks at least one those threads.
<b>[Crowl: Is any lock released?]</b>
</p>

<p>
<b>[Crowl: Needs to say release operation.]</b>
</p>
</dd>

<dt>Thread safety:</dt>
<dd>
Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions
of the same <code>condition_variable</code>
object from different threads shall not result in data
races or deadlocks.
</dd>
</dl>

<pre><code>
void notify_all();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Unblock all threads that are blocked waiting for <code>*this</code>.
<b>[Crowl: Needs to say release operation.]</b>
</dd>

<dt>Thread safety:</dt>
<dd>
Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions
of the same <code>condition_variable</code>
object from different threads shall not result in data
races or deadlocks.
</dd>
</dl>

<pre><code>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
<p>
<code>lock</code> is locked by the current thread, and
either:</p>

<ul>
<li>
No other thread is waiting on this <code>condition_variable</code> object, or
</li>
<li>
The execution of the <code>mutex</code> member function
on the <code>lock</code>
objects supplied in the calls to <code>wait</code> or <code>timed_wait</code>
in
all the threads currently waiting on this <code>condition_variable</code> object
would return the same value as <code>lock-&gt;mutex()</code>
for this call to <code>wait</code>.
</li>
</ul>
</dd>

<dt>Effects:</dt>
<dd>
Atomically blocks and releases the lock on
<code>lock</code>.
If the <code>wait</code> throws an exception, <code>lock</code> will be
locked as the exception propagates.
The current thread may
unblock and return even in the absence of a notification.
<b>[Crowl: Needs to say acquire operation.]</b>
</dd>

<dt>Postcondition:</dt>
<dd>
<code>lock</code> is locked by the current
thread.
</dd>

<dt>Throws:</dt>
<dd>
???
[<i>Comment:</i>
See issue 26.
&mdash;<i>end comment</i>]
</dd>

<dt>Thread safety:</dt>
<dd>
Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions
of the same <code>condition_variable</code>
object from different threads shall not result in data
races or deadlocks.
</dd>
</dl>

<pre><code>
template &lt;class Predicate&gt;
    void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
<p>
While <code>pred()</code> returns <code>false</code>
calls <code>wait(lock)</code>.
</p>

<p>
[<i>Note:</i>
Does not block if <code>pred()</code> is initially <code>true</code>.
&mdash;<i>end note</i>]
</p>
</dd>
</dl>

<pre><code>
bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
The <code>lock</code> is locked by the current thread.
No
other thread is waiting on this <code>condition_variable</code> object
unless <code>lock</code>
refers to, the same underlying <code>mutex</code> object.
</dd>

<dt>Effects:</dt>
<dd>
Atomically blocks and releases the lock on
<code>lock</code>.
If the <code>timed_wait</code> should throw an exception for
any reason, <code>lock</code> will be locked as the exception propagates
out.
If the absolute time specified by <code>abs_time</code> passes (that
is, system time equals or exceeds <code>abs_time</code>) before the
<code>condition_variable</code> is notified,
or if the absolute time specified by
<code>abs_time</code> has already been passed at the time of the call, then
<code>false</code> is returned.
This thread shall unblock when
another thread  issues a notification to this blocked thread.
The current
thread may unblock and return even in the absence of a
notification.
</dd>

<dt>Postcondition:</dt>
<dd>
<code>lock</code> is locked by the current
thread.
</dd>

<dt>Returns:</dt>
<dd>
<code>true</code> if the call to <code>timed_wait</code> is notified prior
to the indicated timeout,
otherwise returns <code>false</code>.
</dd>

<dt>Throws:</dt>
<dd>
???
[<i>Comment:</i>
See issue 26.
&mdash;<i>end comment</i>]
</dd>

<dt>Thread safety:</dt>
<dd>
Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions
of the same <code>condition_variable</code>
object from different threads shall not result in data
races or deadlocks.
<b>[Crowl: Needs to say acquire operation.
Too much about other operations here.]</b>
</dd>
</dl>

<pre><code>
template &lt;class Predicate&gt;
    bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time, Predicate pred);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
<p>
As if:
</p>

<blockquote>
<pre><code>
while (!pred())
{
    if (!timed_wait(lock, abs_time))
        return pred();
}
return true;
</code></pre>
</blockquote>
</dd>

<dt>Returns:</dt>
<dd>
<p>
<code>pred()</code>.
</p>

<p>
[<i>Note:</i>
There is no blocking if <code>pred()</code> is initially <code>true</code>,
even
if the timeout has already expired.
The return value indicates whether the predicate
evaluates to <code>true</code>,
regardless of whether the timeout was triggered.
&mdash;<i>end note</i>]
</p>
</dd>
</dl>

<p>
<code>condition_variable</code>
shall be a standard-layout class (chapter 9 [class]).
</p>

<h4><a name="thread.condvarany">30.3.2 Class condition_variable_any [thread.condvarany]</a></h4>

<p>
An object of class <code>condition_variable_any</code>
is a synchronization primitive
used to cause a thread to wait until notified by some other
thread that some condition is met, or a UTC[(?)] time is reached.
</p>

<p>
The <code>Lock</code> type must support member functions <code>lock</code>
and <code>unlock</code> with the semantics of the mutex concept.
All of the standard mutex types
meet this requirement.
</p>

<blockquote>
<pre><code>
namespace std {

class condition_variable_any
{
public:
    condition_variable_any();
    ~condition_variable_any();

    condition_variable_any(const condition_variable_any&amp;) = delete;
    condition_variable_any&amp; operator=(const condition_variable_any&amp;) = delete;

    void notify_one();
    void notify_all();
    template &lt;class Lock&gt;
        void wait(Lock&amp; lock);
    template &lt;class Lock, class Predicate&gt;
        void wait(Lock&amp; lock, Predicate pred);
    template &lt;class Lock&gt;
        bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time);
    template &lt;class Lock, class Predicate&gt;
        bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time, Predicate pred);

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</code></pre>
</blockquote>

<pre><code>
condition_variable_any();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs an object of class <code>condition_variable_any</code>.
</dd>
</dl>

<pre><code>
~condition_variable_any();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Destroys the object.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
void notify_one();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
If any threads are blocked waiting for <code>*this</code>,
unblocks at least one those threads.
</dd>

<dt>Thread safety:</dt>
<dd>
Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions
of the same <code>condition_variable_any</code>
object from different threads shall not result in data
races or deadlocks.
</dd>
</dl>

<pre><code>
void notify_all();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Unblock all threads  of execution
that are blocked waiting for <code>*this</code>.
</dd>

<dt>Thread safety:</dt>
<dd>
Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions
of the same <code>condition_variable_any</code>
object from different threads shall not result in data
races or deadlocks.
</dd>
</dl>

<pre><code>
void wait(Lock&amp; lock);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
<code>lock</code> is locked by the current thread.
If
<code>Lock</code> supports recursive locking, the lock count is one.
No
other thread is waiting on this <code>condition_variable_any</code> object
unless <code>lock</code>
is, or refers to, the same underlying mutex object.
</dd>

<dt>Effects:</dt>
<dd>
Atomically blocks and releases the lock on
<code>lock</code>.
If the <code>wait</code> should throw an exception for any
reason, <code>lock</code> will be locked as the exception propagates.
This thread shall unblock when another thread issues a
notification to this blocked thread.
The current thread may
unblock and return even in the absence of a notification.
</dd>

<dt>Postcondition:</dt>
<dd>
<code>lock</code> is locked by the current
thread.
</dd>

<dt>Throws:</dt>
<dd>
<code>system_error</code> when an error condition occurs.
The
possible error conditions are implementation defined.
</dd>

<dt>Thread safety:</dt>
<dd>
Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions
of the same <code>condition_variable_any</code>
object from different threads shall not result in data
races or deadlocks.
</dd>
</dl>

<pre><code>
template &lt;class Predicate&gt;
    void wait(lock_type&amp; lock, Predicate pred);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
<p>
While <code>pred()</code> returns <code>false</code>,
calls <code>wait(lock)</code>.
</p>

<p>
[<i>Note:</i>
There is no blocking if <code>pred()</code> is initially <code>true</code>.
&mdash;<i>end note</i>]
</p>
</dd>
</dl>

<pre><code>
bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time);
</code></pre>

<dl>
<dt>Precondition:</dt>
<dd>
The <code>lock</code> is locked by the current thread.
If
<code>Lock</code> supports recursive locking, the lock count is one.
No
other thread is waiting on this <code>condition_variable_any</code> object
unless <code>lock</code>
is, or refers to, the same underlying mutex object.
</dd>

<dt>Effects:</dt>
<dd>
Atomically blocks and releases the lock on
<code>lock</code>.
If the <code>timed_wait</code> should throw an exception for
any reason, <code>lock</code> will be locked as the exception propagates
out.
If the absolute time specified by <code>abs_time</code> passes (that
is, system time equals or exceeds <code>abs_time</code>) before the
<code>condition_variable_any</code> is notified,
or if the absolute time specified by
<code>abs_time</code> has already been passed at the time of the call, then
<code>false</code> is returned.
This thread shall unblock when
another thread issues a notification to this blocked thread.
The current
thread may unblock and return even in the absence of a
notification.
</dd>

<dt>Postcondition:</dt>
<dd>
<code>lock</code> is locked by the current
thread.
</dd>

<dt>Returns:</dt>
<dd>
<code>true</code> if the call to <code>timed_wait</code> is notified prior
to the indicated timeout,
otherwise returns <code>false</code>.
</dd>

<dt>Throws:</dt>
<dd>
<code>system_error</code> when an error condition occurs.
The
possible error conditions are implementation defined.
</dd>

<dt>Thread safety:</dt>
<dd>
Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions
of the same <code>condition_variable_any</code>
object from different threads shall not result in data
races or deadlocks.
</dd>
</dl>

<pre><code>
template &lt;class _Predicate&gt;
    bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time, Predicate pred);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
<p>
As if:
</p>

<blockquote>
<pre><code>
while (!pred())
{
    if (!timed_wait(lock, abs_time))
        return pred();
}
return true;
</code></pre>
</blockquote>
</dd>

<dt>Returns:</dt>
<dd>
<p>
<code>pred()</code>.
</p>

<p>
[<i>Note:</i>
There is no blocking if <code>pred()</code> is initially <code>true</code>,
even
if the timeout has already expired.
The return value indicates whether the predicate
evaluates to <code>true</code>,
regardless of whether the timeout was triggered.
&mdash;<i>end note</i>]
</p>
</dd>
</dl>

<h2><a name="time">Chapter 31&nbsp;&nbsp; Date Time Library [time]</a></h2>

<p>
This clause
describes components for determining and manipulating temporal values.
A <i>time point</i> represents a dimensionless instant
in the time continuum.
A <i>time duration</i> represents a length of time
unattached to any time point.
Time points and time durations have a
<i>resolution</i> which is their smallest representable time duration.
Time points
have an <i>epoch</i> or start of a given time scale.
For time_t the epoch is
1970-01-01 00:00:00.

<p>
Throughout this clause, the names of template parameters are used to express
type requirements.
[<i>Comment:</i>
Define Duration, RhsDuration.
&mdash;<i>end comment</i>]
</p>


<p>
<b>Header &lt;date_time&gt; Synopsis</b>
</p>

<blockquote>
<pre><code>
namespace std {

//duration types
class hours;
class minutes;
class seconds;
class milliseconds;
class microseconds;
class nanoseconds;

//timepoint
class system_time;

//functions
system_time get_system_time();

} //std
</code></pre>
</blockquote>

<h3><a name="time.system">31.1 Class system_time [time.system]</a></h3>

<p>
The class <code>system_time</code> provides a time point
that represents the current
Coordinated Universal Time, known as UTC, time.
<code>system_time</code>
shall provide an epoch time of 1970-01-01 00:00:00.000000000
and a maximum time value of at least epoch time + 292 years.
</p>

<p>
class <code>system_time</code> shall be EqualityComparable, LessThanComparable,
CopyConstructable, DefaultConstructable, and Assignable.
</p>

<blockquote>
<pre><code>
class system_time
{
public:

    system_time();
    system_time(time_t, nanoseconds ns);
    ~system_time();

    time_t seconds_since_epoch() const;
    nanoseconds nanoseconds_since_epoch() const;

    //traits
    typedef 'implementation defined' tick_type;
    static tick_type ticks_per_second();
    static tick_type seconds_per_tick();
    static bool is_subsecond();

    //comparison functions
    bool operator==(const system_time&amp; rhs) const;
    bool operator!=(const system_time&amp; rhs) const;
    bool operator&gt;(const system_time&amp; rhs) const;
    bool operator&gt;=(const system_time&amp; rhs) const;
    bool operator&lt;(const system_time&amp; rhs) const;
    bool operator&lt;=(const system_time&amp; rhs) const;

    //arithmetic functions
    nanoseconds operator-(const system_time&amp; rhs) const

    template&lt;typename Duration&gt;
    system_time operator+(const Duration&amp; td) const;

    template&lt;typename Duration&gt;
    system_time&amp; operator+=(const Duration&amp; td);

    template&lt;typename Duration&gt;
    system_time operator-(const Duration&amp; td) const;

    template&lt;typename Duration&gt;
    system_time&amp; operator-=(const Duration&amp; td)

};
</code></pre>
</blockquote>

<p>
[<i>Note:</i>
292 years represents the number of nanoseconds
that can be represented in a signed 64 bit integer.
&mdash;<i>end note</i>]
</p>

<pre><code>
system_time();
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs a system_time
object representing the epoch time point 1970-01-01 00:00:00.000000000
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
system_time(time_t secs, nanoseconds ns);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Construct<u>s</u> a utc
time object representing the time point
that is secs + 1,000,000,000*ns after the epoch.
</dd>

<dt>Remarks:</dt>
<dd>
If the total nanoseconds &gt; 1 second the seconds are
incremented appropriately.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
time_t seconds_since_epoch() const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
The count of seconds since 1970-01-01 00:00:00.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
nanoseconds nanoseconds_since_epoch() const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
The count of <u>nano</u>seconds
since 1970-01-01 00:00:00.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type ticks_per_second();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
1000000000
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type seconds_per_tick();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
0
</dd>

<dt>Remarks:</dt>
<dd>
Since this is a subsecond type it returns 0 for seconds_per_tick.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static bool is_subsecond();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
true.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator==(const system_time&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if
the <u>time
represented by *this is equal to the time represented by rhs</u>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator!=(const system_time&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if the <u>time represented by *this is not equal to the time represented
by rhs</u>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator&gt;(const system_time&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if time <u>represented by
*this is greater than the time represented by rhs</u>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator&gt;=(const system_time&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if time <u>represented
by *this is greater or equal than the time represented by rhs</u>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator&lt;(const system_time&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if time <u>represented by *this
is less than the time represented by rhs</u>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
bool operator&lt;=(const system_time&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if time <u>represented by *this
is less or equal than the time represented by rhs</u>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
nanoseconds operator-(const system_time&amp; rhs) const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
<u>
The difference in nanoseconds between the time represented by *this and the
time represented by rhs.</u>
</dd>

<dt>Remarks:</dt>
<dd>
If rhs is greater the result will be a negative nanosecond.
count.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename Duration&gt;
system_time operator+(const Duration&amp; td) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
The duration converted to nanosecond resolution
and added to the time <u>represented by *this</u>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename Duration&gt;
system_time&amp; operator+=(const Duration&amp; td);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Convert the duration to nanosecond resolution add to nanoseconds
to the time represented by *this.
</dd>

<dt>Returns:</dt>
<dd>
Modified value of this.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename Duration&gt;
system_time operator-(const Duration&amp; td) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
The duration converted to nanosecond resolution
and subtracted from the time <u>represented by *this</u>.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename Duration&gt;
system_time&amp; operator-=(const Duration&amp; td)
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Convert the duration to nanosecond resolution subtract and
from the time represented by *this.
</dd>

<dt>Returns:</dt>
<dd>
Modified value of this.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>


<h3><a name="time.getsystem">31.2 Function get_system_time [time.getsystem]</a></h3>

<p>
The function <code>get_system_time</code>
provides access to the system clock at a
resolution up to nanoseconds.
The actual resolution may vary from platform to platform.
</p>

<blockquote>
<pre><code>
system_time get_system_time();
</code></pre>
</blockquote>


<p>
[<i>Comment (not for inclusion in WP):</i>
<i>Typical personal computer platforms currently achieve microsecond level
resolution from calls to the clock.
The <a href="http://www.boost.org/libs/date_time/index.html" target="_top">Boost Date-Time Library</a>
has a class that portably implements the proposed interface,
but it uses different C-level interfaces depending on the operating
system.</i>
&mdash;<i>end comment</i>]
</p>

<h3><a name="time.duration">31.3 Common Duration Functions [time.duration]</a></h3>

<p>
The following functions are common functions to all durations types.
These
functions provide the basis
for durations to be EqualityComparable, LessThanComparable
as well arithmetic operations.
</p>

<p>
In the following text duration_type refers to the containing duration type.
</p>

<p>
All duration types are EqualityComparable, LessThanComparable,
CopyConstructable, DefaultConstructable, and Assignable for duration
objects of the same type.
</p>

<blockquote>
<pre><code>
class Duration {

    //comparison operators
    template&lt;typename RhsDuration&gt;
    bool operator&lt;  (const RhsDuration&amp;) const;

    template&lt;typename RhsDuration&gt;
    bool operator&lt;= (const RhsDuration&amp;) const;

    template&lt;typename RhsDuration&gt;
    bool operator&gt;  (const RhsDuration&amp;) const;

    template&lt;typename RhsDuration&gt;
    bool operator&gt;= (const RhsDuration&amp;) const;

    template&lt;typename RhsDuration&gt;
    bool operator== (const RhsDuration&amp;) const;

    template&lt;typename RhsDuration&gt;
    bool operator!= (const RhsDuration&amp;) const;


    //sign inversion
    Duration operator-() const

    //arithmetic operations
    template&lt;typename RhsDuration&gt;
    Duration operator- (const RhsDuration&amp; d) const

    template&lt;typename RhsDuration&gt;
    Duration operator-=(const RhsDuration&amp; d)

    template&lt;typename RhsDuration&gt;
    Duration operator+ (const RhsDuration&amp; d) const

    template&lt;typename RhsDuration&gt;
    Duration operator+=(const RhsDuration&amp; d)

    Duration operator/ (int divisor) const
    Duration operator/=(int divisor)
    Duration operator* (int rhs) const
    Duration operator*=(int divisor)

    tick_type get_count() const

}
</code></pre>
</blockquote>

<pre><code>
template&lt;typename RhsDuration&gt;
bool operator==(const RhsDuration&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if rhs duration is greater.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename RhsDuration&gt;
bool operator!=(const RhsDuration&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if rhs is not the same time.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename RhsDuration&gt;
bool operator&gt;(const RhsDuration&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if the rhs duration is larger.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename RhsDuration&gt;
bool operator&gt;=(const RhsDuration&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if greater or equal than the rhs duration.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename RhsDuration&gt;
bool operator&lt;(const RhsDuration&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if less than the rhs duration.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename RhsDuration&gt;
bool operator&lt;=(const RhsDuration&amp; rhs) const;
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
True if less or equal to the rhs duration.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
<i>//sign inversion</i>
Duration operator-() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
Negated value of the duration.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
<i>//arithmetic operations</i>
template&lt;typename RhsDuration&gt;
Duration operator- (const RhsDuration&amp; d) const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
A duration value equal to this-rhs_duration.
</dd>

<dt>Remarks:</dt>
<dd>
This will fail to compile if the
RhsDuration is
of higher resolution.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename RhsDuration&gt;
Duration operator-=(const RhsDuration&amp; d)
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Modifies to value equal to this-rhs_duration.
</dd>

<dt>Returns:</dt>
<dd>
<p>
this
</p>

<p>
<em>Remarks: This will fail to compiler if the
RhsDuration is
of higher resolution.</em>
</p>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename RhsDuration&gt;
Duration operator+ (const RhsDuration&amp; d) const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
<p>
Duration equal to this+rhs_duration.
</p>

<p>
<em>Remarks: This will fail to compiler if the
RhsDuration is
of higher resolution.</em>
</p>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
template&lt;typename RhsDuration&gt;
Duration operator+=(const RhsDuration&amp; d)
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Modifies to value equal to this+rhs_duration.
</dd>

<dt>Returns:</dt>
<dd>
<p>
this
</p>

<p>
<em>Remarks: This will fail to compiler if the
RhsDuration is
of higher resolution.</em>
</p>
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
Duration operator/ (int divisor) const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
Duration with value equal to this/divisor according to
integer arithmetic rules.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
Duration operator/=(int divisor)
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Change value of this by this/divisor according to integer
arithmetic rules.
</dd>

<dt>Returns:</dt>
<dd>
this
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
Duration operator* (int rhs) const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
Duration with value equal to this*rhs
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
Duration operator*=(int rhs)
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Modifies to value equal to this*rhs.
</dd>

<dt>Returns:</dt>
<dd>
this
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
tick_type get_count() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
The count at the resolution of the time duration
type.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h3><a name="time.nanoseconds">31.4 Class nanoseconds [time.nanoseconds]</a></h3>

<p>
Objects of class <code>nanoseconds</code> can be used to represent a count of nanoseconds.
</p>

<blockquote>
<pre><code>
class nanoseconds
{
public:

    nanoseconds(long long=0);
    nanoseconds(const nanoseconds&amp; rhs);
    ~nanoseconds();

    //traits information
    static tick_type ticks_per_second();
    static tick_type seconds_per_tick();
    static bool is_subsecond();
    typedef <b><i>implementation-defined</i></b> tick_type;

    //+ common functions

};
</code></pre>
</blockquote>

<pre><code>
nanoseconds(long long=0);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs an object with a count of nanoseconds - default
is zero.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
nanoseconds(const nanoseconds&amp; rhs);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Copy construction.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type ticks_per_second();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
1000000000
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type seconds_per_tick();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
0
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static bool is_subsecond();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
true
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h3><a name="time.microseconds">31.5 Class microseconds [time.microseconds]</a></h3>

<p>
Objects of class <code>microseconds</code>
can be used to represent a count of microseconds.
</p>

<blockquote>
<pre><code>
class microseconds
{
public:

    microseconds(long long=0);
    microseconds(const microseconds&amp; rhs);
    ~microseconds();

    //conversions
    operator nanoseconds() const

    //traits information
    static tick_type ticks_per_second();
    static tick_type seconds_per_tick();
    static bool is_subsecond();
    typedef <b><i>implementation-defined</i></b> tick_type;

    //+ common functions

};

</code></pre>
</blockquote>

<pre><code>
microseconds(long long=0);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs an object with a count of microseconds - default
is zero.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
microseconds(const microseconds&amp; rhs);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Copy construction.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
<i>//conversions</i>
operator nanoseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
microsecond count converted to nanoseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type ticks_per_second();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
1000000
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type seconds_per_tick();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
0
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static bool is_subsecond();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
true
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h3><a name="time.milliseconds">31.6 Class milliseconds [time.milliseconds]</a></h3>

<p>
Objects of class <code>milliseconds</code>
can be used to represent a count of milliseconds.
</p>

<blockquote>
<pre><code>
class milliseconds
{
public:
    milliseconds(long long=0);
    milliseconds(const milliseconds&amp; rhs);
    ~milliseconds();

    //conversions
    operator nanoseconds() const;
    operator microseconds() const;

    //traits information
    static tick_type ticks_per_second();
    static tick_type seconds_per_tick();
    static bool is_subsecond();
    typedef <b><i>implementation-defined</i></b> tick_type;

    //+ common functions
};
</code></pre>
</blockquote>

<pre><code>
milliseconds(long long=0);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Constructs an object with a count of milliseconds - default
is zero.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
milliseconds(const milliseconds&amp; rhs);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Copy construction.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator nanoseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
millisecond count converted to nanoseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator microseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
millisecond count converted to microseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type ticks_per_second();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
1000
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type seconds_per_tick();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
0
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static bool is_subsecond();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
true
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h3><a name="time.seconds">31.7 Class seconds [time.seconds]</a></h3>

<p>
Objects of class <code>seconds</code>
can be used to represent a count of seconds.
</p>

<blockquote>
<pre><code>
class  seconds
{
public:
    seconds(long long s=0);
    seconds(const seconds&amp; rhs);
    ~seconds();

    //conversions
    operator nanoseconds() const
    operator microseconds() const
    operator milliseconds() const

    //traits information
    static tick_type ticks_per_second();
    static tick_type seconds_per_tick();
    static bool is_subsecond();
    typedef <b><i>implementation-defined</i></b> tick_type;

    //+ common functions

};
</code></pre>
</blockquote>

<pre><code>
seconds(long long=0);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Construct<u>s</u> a<u>n object with a</u> count of seconds - default is
zero.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
seconds(const seconds&amp; rhs);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Copy construction.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator nanoseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
second count converted to nanoseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator microseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
second count converted to microseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator milliseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
second count converted to milliseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type ticks_per_second();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
1
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type seconds_per_tick();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
1
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static bool is_subsecond();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
false
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h3><a name="time.minutes">31.8 Class minutes [time.minutes]</a></h3>

<p>
Objects of class <code>minutes</code>
can be used to represent a count of minutes.
</p>

<blockquote>
<pre><code>
class  minutes
{
public:
    minutes(long long s=0);
    minutes(const minutes&amp; rhs);
    ~minutes();

    //conversions
    operator nanoseconds() const
    operator microseconds() const
    operator milliseconds() const
    operator seconds() const

    //traits information
    static tick_type ticks_per_second();
    static tick_type seconds_per_tick();
    static bool is_subsecond();
    typedef <b><i>implementation-defined</i></b> tick_type;

    //+ common functions

};
</code></pre>
</blockquote>

<pre><code>
minutes(long long=0);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Construct<u>s</u> a<u>n object with a</u> count of minutes - default is
zero.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
minutes(const minutes&amp; rhs);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Copy construction.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator nanoseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
minute count converted to nanoseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator microseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
minute count converted to microseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator milliseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
minute count converted to milliseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator seconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
minute count converted to seconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type ticks_per_second();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
0
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type seconds_per_tick();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
60
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static bool is_subsecond();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
false
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h3><a name="time.hours">31.9 Class hours [time.hours]</a></h3>

<p>
Objects of class <code>hours</code>
can be used to represent a count of hours.
</p>

<blockquote>
<pre><code>
class  hours
{
public:
    hours(long long s=0);
    hours(const hours&amp; rhs);
    ~hours();

    //conversions
    operator nanoseconds() const
    operator microseconds() const
    operator milliseconds() const
    operator seconds() const
    operator minutes() const

    //traits information
    static tick_type ticks_per_second();
    static tick_type seconds_per_tick();
    static bool is_subsecond();
    typedef <b><i>implementation-defined</i></b> tick_type;

    //+ common functions

};
</code></pre>
</blockquote>

<pre><code>
hours(long long=0);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Construct<u>s</u> a<u>n object with a</u> count of hours - default is zero.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
hours(const hours&amp; rhs);
</code></pre>

<dl>
<dt>Effects:</dt>
<dd>
Copy construction.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator nanoseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
hour count converted to nanoseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator microseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
hour count converted to microseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator milliseconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
hour count converted to milliseconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator seconds() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
hour count converted to seconds
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
operator minutes() const
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
hour count converted to seconds.
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type ticks_per_second();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
0
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static tick_type seconds_per_tick();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
3600
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<pre><code>
static bool is_subsecond();
</code></pre>

<dl>
<dt>Returns:</dt>
<dd>
false
</dd>

<dt>Throws:</dt>
<dd>
Nothing.
</dd>
</dl>

<h2><a name="References">References</a></h2>

<ul>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1682.html">
  N1682</a>, A Multi-threading Library for Standard C++, Pete Becker.
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1815.html">
  N1815</a>, ISO C++ Strategic Plan for Multithreading, Lawrence Crowl.
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1883.pdf">
  N1883</a>, Preliminary Threading Library Proposal for TR2, Kevlin Henney.
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1907.html">
  N1907</a>, A Multi-threading Library for Standard C++, Revision 1 Pete Becker
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2043.html">
  N2043</a>, Simplifying And Extending Mutex and Scoped Lock Types For C++
  Multi-Threading Library, Ion Gazta&ntilde;aga
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2090.html">
  N2090</a>, A Threading API for C++, Peter Dimov
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2094.html">
  N2094</a>, Multithreading API for C++0X - A Layered Approach, Howard Hinnant
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2139.html">
  N2139</a>, Thoughts on a Thread Library for C++, Anthony Williams
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2178.html">
  N2178</a>, Proposed Text for Chapter 30, Thread Support Library, Peter Dimov
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html">
  N2184</a>, Thread Launching for C++0X, Howard Hinnant
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2285.html">
  N2285</a>, A Multi-threading Library for Standard C++, Revision 2, Pete Becker
</li>
<li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2411.html">
  N2411</a>, Proposal for Date-Time Types in C++0x To Support Threading APIs v2, Jeff Garland
</li>
<li>
  <a href="http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=40874">
  ISO 8601: 2004</a>Data elements and interchange formats -- Information interchange -- Representation of dates and times
</li>
</ul>


<h2><a name="Acknowledgments">Acknowledgments</a></h2>

<p>
The overall design of this threading library is based on William Kempf's
Boost.Thread Library,
as refined by literally hundreds of other Boost users and
contributors.
Dinkumware and Metrowerks (now Freescale) implementations of
Boost.Thread, developed respectively by Pete Becker and Howard Hinnant,
created
further existing practice.
Proposals by Pete Becker, Peter Dimov, Ion Gazta&ntilde;aga,
and Anthony Williams were also influential.
Peter, Ion, and Anthony also
contributed numerous critiques, suggestions, and comments on the current
proposal, as did other members of an ad hoc threads working group.
Jeff Garland
contributed the date time portions of the proposal based on the Boost.DateTime
Library and his TR2 proposals.
</p>

</body>
</html>
