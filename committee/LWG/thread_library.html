<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<title>thread</title>
	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {background-color:#FFFFA0}
	del {background-color:#FFFFA0}
        .comment        { color: #800000; }
    span.underline
    {
        text-decoration: underline;
    }

    span.strikethrough
    {
        text-decoration: line-through;
    }
	</style>
</head>
<body>

<address align=right>
Document number: in progress<br>
<br>
<a href="mailto:hinnant@twcny.rr.com">Howard E. Hinnant</a>, 
<a href="mailto:jeff@crystalclearsoftware.com">Jeff Garland</a>,  
<a href="mailto:public@alisdairm.net">Alisdair Meredith</a>
<br>
2007-10-03
</address>
<hr>
<h1 align=center>Multi-threading Library for Standard C++</h1>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Thread">Thread</a>
</li>
<li><a href="#Mutex">Mutex</a>
	<ul>
	<li><a href="#MutexExamples">Mutex Rationale and Examples</a>
		<ul>
		<li><a href="#MutexConcept">Mutex concepts</a></li>
		<li><a href="#MutexTime">Time Issues</a></li>
		</ul>
	</li>
	<li><a href="#LockExamples">Lock Rationale and Examples</a></li>
	<li><a href="#LockAlgoExamples">Generic Locking Algorithm Rationale and Examples</a></li>
	</ul>
</li>
<li><a href="#Condition">Condition Variables</a>
	<ul>
	<li><a href="#ConditionExamples">Condition Rationale and Examples</a>
		<ul>
		<li><a href="#ConditionFlex">Condition Variable Flexibility</a></li>
		</ul>
	</li>
	</ul>
</li>
<li><a href="#ProposedWording">Proposed Wording</a><ul>
	<li><a href="#ThreadsWording">Threads Proposed Wording</a></li>
	<li><a href="#MutexsLocksWording">Mutexes and Locks Proposed Wording</a></li>
<li><a href="#ConditionVariablesWording">Condition Variables Proposed Wording</a></li>
<li><a href="#DateTime">Date Time Proposed Wording</a></li>
</ul>

</li>
<li><a href="#References">References</a></li>
<li><a href="#Acknowledgments">Acknowledgments</a></li>
</ul>

<h2><a name="Introduction"></a>Introduction</h2>

<p>
This is a revision of 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html">N2320</a>
which removes cancellation/interruption and changes condition variables per the suggestions in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html">N2406</a>.
This is the course of a action requested by the combined LWG/Concurrency working groups
at the Kona meeting.
</p>

<h1><a name="ProposedWording">Proposed wording</a></h1>

<hr>

<h2>Chapter 30&nbsp;&nbsp; Multi-threading library</h2>

<hr>

<p>
This clause describes components that C++ programs may use to create and manage multi-threaded programs.</p>

<p>
The following subclauses describe components to create and manage 
<i>threads of execution</i> [intro.execution? (N2334)], perform mutual exclusion and locking, and communicate 
between threads of execution.</p>

<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
  <tr>
    <td width="50%" align="center"><b>Subclause</b></td>
    <td width="50%" align="center"><b>Header(s)</b></td>
  </tr>
  <tr>
    <td width="50%"><a href="#ThreadsWording">Threads</a></td>
    <td width="50%"><code>&lt;thread&gt;</code></td>
  </tr>
  <tr>
    <td width="50%"><a href="#MutexsLocksWording">Mutexs and locks</a></td>
    <td width="50%"><code>&lt;mutex&gt;</code></td>
  </tr>
  <tr>
    <td width="50%"><a href="#ConditionVariablesWording">Condition variables</a></td>
    <td width="50%"><code>&lt;cond_var&gt;</code></td>
  </tr>
</table>

<p>
Some functions 
described in this clause are specified to throw exceptions of type <tt>system_error</tt>
([syserr.syserr]). The <tt>error_category</tt> ([syserr.errcat.overview]) 
of the <tt>error_code</tt> reported by such exceptions <tt>code()</tt> 
member function is implementation-defined.  [<i>Note:</i> The category is 
typically <tt>native_category</tt> ([syserr.errcat.overview]) since these error 
codes usually originate from the underlying operating system application program 
interface (API). <i>-- end note</i>]
</p>

<h3>
<a name="ThreadsWording">Threads</a></h3>

<p>
<b>&lt;thread&gt; synopsis</b>
</p>

<blockquote><pre>namespace std {

class thread;

void swap(thread&amp;  x, thread&amp;  y);
void swap(thread&amp;&amp; x, thread&amp;  y);
void swap(thread&amp;  x, thread&amp;&amp; y);

class thread::id;
bool operator==(const thread::id&amp; x, const thread::id&amp; y);
bool operator!=(const thread::id&amp; x, const thread::id&amp; y);

template&lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, const thread::id&amp; id);

namespace this_thread
{
    thread::id get_id();
    
    void yield();
    template &lt;class ElapsedTime&gt;
        void sleep(const ElapsedTime&amp; rel_t);

}  // this_thread

struct once_flag
{
    constexpr once_flag();

    once_flag(const once_flag&amp;) = delete;
    once_flag&amp; operator=(const once_flag&amp;) = delete;
};

template&lt;class Callable, class ...Args&gt;
void call_once(once_flag&amp; flag, Callable func, Args&amp;&amp;... args);

}  // std
</pre></blockquote>

<h4>Class thread</h4>

<p>
An object of class <code>thread</code> launches a new thread of execution, 
and provides mechanisms for the current thread of execution to wait for 
completion of the launched thread, and perform other operations to manage and query the thread's 
state.
</p>

<blockquote><pre>class thread
{
public:
    thread();
    template &lt;class F, class ...Args&gt; explicit thread(F f, Args&amp;&amp;... args);
    ~thread();

    thread(const thread&amp;) = delete;
    thread&amp; operator=(const thread&amp;) = delete;

    thread(thread&amp;&amp;);
    thread&amp; operator=(thread&amp;&amp;);

    void swap(thread&amp;&amp;);

    bool joinable() const;
    void join();
    void detach();

    class id
    {
    public:
        id();
        friend bool operator==(const id&amp; <i>x</i>, const id&amp; <i>y</i>);
        friend bool operator!=(const id&amp; <i>x</i>, const id&amp; <i>y</i>);
        friend bool operator&lt;(const id&amp; <i>x</i>, const id&amp; <i>y</i>);
        friend bool operator&lt;=(const id&amp; <i>x</i>, const id&amp; <i>y</i>);
        friend bool operator&gt;(const id&amp; <i>x</i>, const id&amp; <i>y</i>);
        friend bool operator&gt;=(const id&amp; <i>x</i>, const id&amp; <i>y</i>);
    };

    id get_id() const;

    typedef <i>implementation-defined</i> native_handle_type;
    native_handle_type native_handle();

    static unsigned hardware_concurrency();
};
</pre></blockquote>

<p>
Class <tt>thread</tt> and class <tt>thread::id</tt> shall be standard-layout 
types ([?]).
</p>

<blockquote>
<pre>thread();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs a <tt>thread</tt> object not attached to any thread
of execution.  [<i>Note:</i> This is the state of a <tt>thread</tt>
object after <tt>detach</tt> or <tt>join</tt> is successfully called. <i>-- end note</i>]
</p>
<p>
<i>Postconditions:</i>
</p>
<blockquote><pre>get_id() == thread::id()
&amp;&amp; joinable() == false
</pre></blockquote>
<p>
<i>Remarks:</i> <tt>get_id()</tt> returns an identity that refers to
<i>not any thread</i>.  This identity compares equal to other
non-<tt>join</tt>able <tt>thread</tt>s, and compares not equal to all
other <tt>join</tt>able <tt>thread</tt>s.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>
template &lt;class F, class ...Args&gt; explicit thread(F f, Args&amp;&amp;... args);
</pre>

<blockquote>
<p>
<i>Requires:</i>  <tt>F</tt> is a callable type [func.def].  If <tt>f</tt> is an lvalue, <tt>F</tt> must be <tt>CopyConstructible</tt>.
If <tt>f</tt> is an rvalue, <tt>F</tt> must only be <tt>MoveConstructible</tt>.
</p>
<p>
<i>Effects:</i> Constructs an object of type <tt>thread</tt> and executes <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> 
in a new thread of execution, where <tt>t1, t2, 
..., tN</tt> are the values in <tt>args...</tt>.  Any return value from <tt>f</tt> is ignored.  If <tt>f</tt> terminates with an uncaught
exception, <tt>std::terminate()</tt> shall be called.
</p>
<p>
<i>Postconditions:</i>
</p>
<blockquote><pre>get_id() != thread::id()
&amp;&amp; joinable() == true
</pre>
<p><code>*this</code> represents the newly started thread of execution.</p>
</blockquote>
<p>
<i>Throws:</i> <tt>system_error</tt> if unable to  start the new thread of execution.
</p>
</blockquote>
</blockquote>

<blockquote><pre>~thread()
</pre>

<blockquote>
<p>
<i>Effects:</i> If <tt>joinable()</tt> then <tt>join()</tt>,
otherwise no effects.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>thread(thread&amp;&amp; <i>x</i>)
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <tt>thread</tt> from <tt><i>x</i></tt>.  
</p>
<p>
<i>Postconditions:</i>  <tt><i>x</i>.joinable()</tt> is <tt>false</tt>. 
<tt><i>x</i>.get_id() == thread().get_id()</tt>. <tt>joinable()</tt>
returns the value of <tt><i>x</i>.joinable()</tt> prior to the start of construction.
<tt>get_id()</tt> returns the value of <tt><i>x</i>.get_id()</tt> prior to the 
start of construction.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>thread&amp; operator=(thread&amp;&amp; <i>x</i>)
</pre>

<blockquote>
<p>
<i>Effects:</i> If <tt>this</tt> currently refers to a <tt>joinable</tt> thread, calls
<ins><tt>join()</tt></ins>.  Then assigns the state of <tt><i>x</i></tt> to <tt>*this</tt>
and sets <tt><i>x</i></tt> to a default constructed state.
</p>
<p>
<i>Postconditions:</i>  <tt><i>x</i>.joinable()</tt> is <tt>false</tt>. 
<tt><i>x</i>.get_id() == thread().get_id()</tt>. <tt>joinable()</tt> returns the 
value of <tt><i>x</i>.joinable()</tt> prior to the
assignment.
<tt>get_id()</tt> returns the value of <tt><i>x</i>.get_id()</tt> prior to the
assignment.
</p>
<p>
<del><i>Throws:</i> Nothing.</del>
</p>
</blockquote>
</blockquote>

<blockquote><pre>void swap(thread&amp;&amp; <i>x</i>)
</pre>

<blockquote>
<p>
<i>Effects:</i> Swaps the state of <tt>*this</tt> and <tt><i>x</i></tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>bool joinable() const
</pre>

<blockquote>
<p>
<i>Returns:</i> <tt>get_id() != id()</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>void join()
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <tt>joinable()</tt> is <tt>true</tt>.
</p>
<p>
<i>Effects:</i> The current thread of execution blocks until the thread of execution 
represented by <code>*this</code> completes.</p>
<p>
<i>Postconditions:</i> After a normal return of <tt>join()</tt>,
<tt>joinable()</tt> is <tt>false</tt>. If <tt>join()</tt> throws an exception, the thread of execution represented by
<tt>*this</tt> remains <tt>joinable</tt>.
</p>

<p>
<i>Throws:</i> May throw <tt>system_error</tt>.
</p>
</blockquote>
</blockquote>

<blockquote><pre>void detach()
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <tt>joinable()</tt> is <tt>true</tt>.
</p>
<p>
<i>Effects:</i> The thread of execution represented by
<tt>*this</tt> continues execution.  When the thread of execution represented by
<tt>*this</tt> ends execution it shall release any owned resources.
</p>
<p>
<i>Postconditions:</i> <tt>joinable()</tt> is <tt>false</tt>. <tt>*this</tt> 
does not represent a thread of execution.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>id get_id() const
</pre>

<blockquote>
<p>
<i>Returns:</i> A <tt>thread::id</tt> which refers to the thread of execution 
represented by
<tt>*this</tt>.  If this
<tt>thread</tt> is not <tt>joinable()</tt> returns a default constructed <tt>id</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>native_handle_type native_handle()
</pre>

<blockquote>
<p>
<i>Returns:</i> An implementation defined type representing the underlying OS thread handle.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>unsigned hardware_concurrency()
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of threads that can reasonably be expected to
execute concurrently. <i>[Note:</i> This value should only be considered to be a hint.
<i>--end note]</i> If this value is not computable or well defined a
return value of 1 is recommended, but not required.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void swap(thread&amp;  x, thread&amp;  y);
void swap(thread&amp;&amp; x, thread&amp;  y);
void swap(thread&amp;  x, thread&amp;&amp; y);
</pre>
<blockquote>
<p>
<i>Effects:</i> <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>

<blockquote><pre>template&lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, const thread::id&amp; id);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of the <tt>thread::id</tt> into
the stream <tt>out</tt>.
</p>
<p>
<i>Returns:</i> <tt>out</tt>.
</p>
</blockquote>
</blockquote>

<h5>Class <tt>thread::id</tt></h5>

<p>
<tt>id</tt> is a nested class of <tt>thread</tt> which represents the identity of
a thread of execution.
</p>

<blockquote><pre>id()
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <tt>id</tt> which compares
equal to other default constructed <tt>id</tt> objects.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>bool operator==(const id&amp; <i>x</i>, const id&amp; <i>y</i>)
</pre>

<blockquote>
<p>
<i>Returns:</i> If <tt><i>x</i></tt> and <tt><i>y</i></tt> both represent
<i>not any thread</i>, then returns <tt>true</tt>.  Otherwise if
<tt><i>x</i></tt> and <tt><i>y</i></tt> represent the same thread of execution, then
returns <tt>true</tt>.  Otherwise returns <tt>false</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>bool operator!=(const id&amp; <i>x</i>, const id&amp; <i>y</i>)
</pre>

<blockquote>
<p>
<i>Returns:</i> <tt>!(<i>x</i> == <i>y</i>)</tt>
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>


<blockquote>
<pre>bool operator&lt;(const id&amp; x, const id&amp; y)
</pre>

<blockquote>
<p>
<i>Returns:</i> Provides an ordering for all objects of type <code>id</code>, such that
objects of type <code>id</code> can be used as a key in Associate Containers.
For two objects of type <code>id</code>,
<code>x</code> and <code>y</code>, if
<code>x == y</code> returns <code>true</code>, both <code>x &lt; y</code> and <code>y &lt; x</code> shall return
<code>false</code>. Otherwise, precisely one of <code>x &lt; y</code> and <code>y &lt; x</code> shall return
<code>true</code>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool operator&lt;=(const id&amp; x, const id&amp; y)
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>!(y &lt; x)</tt> </p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool operator&gt;(const id&amp; x, const id&amp; y)
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>y &lt; x</tt> </p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool operator&gt;=(const id&amp; x, const id&amp; y)
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>!(x &lt; y)</tt> </p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4>Namespace <tt>this_thread</tt></h4>

<blockquote><pre>namespace this_thread
{
    thread::id get_id();
    
    void yield();
    template &lt;class ElapsedTime&gt;
        void sleep(const ElapsedTime&amp; rel_t);

}  // this_thread
</pre></blockquote>

<blockquote><pre>thread::id this_thread::get_id()
</pre>

<blockquote>
<p>
<i>Returns:</i> Returns the <tt>id</tt> of the current thread.  The return shall not be
equal to a default constructed <tt>thread::id</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>void yield()
</pre>

<blockquote>
<p>
<i>Effects:</i>  Offers the operating system the chance to schedule another thread.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>template &lt;class ElapsedTime&gt;
    void sleep(const ElapsedTime&amp; rel_t)
</pre>

<blockquote>
<p>
<i>Requires:</i> <tt>ElapsedTime</tt> shall be explicitly convertible to <tt>nanoseconds</tt>.
</p>
<p>
<i>Effects:</i>  The current thread of execution blocks for at least the amount of time specified.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4><code>struct once_flag</code></h4>

<blockquote>

<p>Objects of class <code>once_flag</code> are opaque data structures that allow
<code>call_once</code> to initialize data without causing a data race or 
deadlock.</p>

<pre>constexpr once_flag();</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs a object of type
<code>once_flag</code>.</p>
<p>
<i>Postcondition:</i> Internal state is set to indicate to an invocation 
of <code>call_once</code> with this <code>once_flag</code> as its initial 
argument that no function has been called.</p>
</blockquote>
</blockquote>


<h4><code>non-member function call_once</code></h4>

<blockquote>

<pre>template&lt;class Callable, class Args...&gt;
void call_once(once_flag&amp; flag, Callable func, Args... args);
</pre>

    <blockquote>

    <p><i>Requires:</i> If the <code>Callable</code> argument <code>func</code> is an lvalue, <code>F</code> 
    is
    <code>CopyConstructible</code>. Otherwise, <code>func</code> is an rvalue, <code>
    and F</code> is
    <code>MoveConstructible</code>. Copying or moving (as appropriate) shall have no side effects, and the effect of calling the
    copy shall be equivalent to calling the original.</p>

    <p><i>Effects:</i> The argument <code>func</code> (or a copy thereof) is called exactly once 
    for the <code>once_flag</code> object specified by <code>flag</code>, as-if by invoking
    <code>func(args)</code>,<code> </code>even if <code>call_once</code> is 
    called multiple times for the same <code>once_flag</code> object. If multiple
    calls to <code>call_once</code> with the same <code>once_flag</code> object 
    occur in separate threads of execution, only one
    thread shall call <code>func</code>, and none of the threads shall proceed until the call to <code>func</code> has completed. 
    If the invocation of <code>func</code> results in an exception being thrown, 
    the exception is propagated to the caller and the effects are as-if this 
    invocation of&nbsp;<code>call_once</code> did not occur.</p>

    <p><i>Throws:</i> <code>system_error</code> or any exception propagated from <code>func</code>.</p>

    <p><i>Thread safety:</i> Access to the same <code>once_flag</code> object by 
    calls to <code>call_once</code> from different threads of execution shall 
    not result in a data race or deadlock.</p>

<p>[<i>Examples:</i></p>
<blockquote><pre>std::once_flag flag;

void init();

void f()
{
    std::call_once(flag,init);
}

struct initializer
{
    void operator()();
};

void g()
{
    static std::once_flag flag2;
    std::call_once(flag2,initializer());
}
</pre></blockquote>

<p><i>-- end example]</i></p>
</blockquote>
</blockquote>

<h3>
<a name="MutexsLocksWording">Mutexs and locks</a></h3>

<p>
<b>&lt;mutex&gt; synopsis</b>
</p>

<blockquote><pre>namespace std {

struct static_mutex;
struct mutex;
struct recursive_mutex;
struct timed_mutex;
struct recursive_timed_mutex;

struct defer_lock_t;
struct try_to_lock_t;
struct adopt_lock_t;

extern const defer_lock_t  defer_lock;
extern const try_to_lock_t try_to_lock;
extern const adopt_lock_t  adopt_lock;

class lock_error;

template &lt;class Mutex&gt; class scoped_lock;
template &lt;class Mutex&gt; class unique_lock;

template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);

template &lt;class L1, class L2, class ...L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
template &lt;class L1, class L2, class ...L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);

}  // std
</pre></blockquote>

<h3>Mutex concepts</h3>

<p>
Objects of the mutex types enforce mutual exclusion between threads of execution 
by limiting ownership of a mutex object to a single thread of execution.  A 
thread of execution gets ownership of a mutex object by calling <tt>lock()</tt> and
relinquishes ownership by calling <tt>unlock()</tt>.  Ownership can not
be transferred from one thread of execution to another.  The same 
thread of execution that calls
<tt>lock()</tt> for a mutex object must call <tt>unlock() f</tt>or the object.  Mutexes can be either recursive
or non-recursive.  The syntax is the same for both recursive and non-recursive
mutexes, but the semantics for the member functions differs as described below.
</p>

<p>
Each mutex type shall be default constructible and destructible.  If the default construction
of the Mutex type fails, an exception of type <tt>system_error</tt> shall be thrown.  The destructor
of the Mutex type shall not throw an exception.
Mutex types are neither copyable
nor movable.  Each mutex type shall have the following member functions:
</p>

<blockquote>
<pre>void lock();
</pre>
<blockquote>
<p>
<i>Precondition:</i> For non-recursive mutexes the current thread of execution shall not own the mutex.
</p>
<p>
<i>Effects:</i> The current thread of execution will block until the mutex is not owned by another thread of execution.
Upon successful completion, the current thread of execution owns the mutex.
</p>
<p>
<i>Throws:</i>  <tt>system_error</tt>.
</p>
<p>
<i>Thread safety:</i> Calls from different threads of execution to <tt>lock</tt>, <tt>try_lock</tt>,
and <tt>unlock</tt> functions on an object of a mutex type shall not result in data races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool try_lock();
</pre>
<blockquote>
<p>
<i>Precondition:</i> For non-recursive mutexes the current thread of execution shall not own the mutex.
</p>
<p>
<i>Effects:</i> If ownership can be obtained without blocking, then ownership is obtained,
else there is no effect and <tt>try_lock()</tt> immediately returns.
</p>
<p>
<i>Returns:</i> <tt>true</tt> if ownership was obtained, otherwise <tt>false</tt>.
</p>
<p>
<i>Thread safety:</i> Calls from different threads of execution to <tt>lock</tt>, <tt>try_lock</tt>,
and <tt>unlock</tt> functions on an object of a mutex type shall not result in data races or deadlocks.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void unlock();
</pre>
<blockquote>
<p>
<i>Precondition:</i> The current thread of execution shall own the mutex.
</p>
<p>
<i>Effects:</i> For a non-recursive mutex ownership is released.  For a recursive mutex
<tt>unlock()</tt> must be called the same number of times which the mutex was locked
(via either <tt>lock()</tt> or <tt>try_lock()</tt> or by any other locking function) before ownership is released.
</p>
<p>
<i>Thread safety:</i> Calls from different threads of execution to <tt>lock</tt>, 
and <tt>try_lock</tt> functions on an object of a mutex type shall not result in data races or deadlocks.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<p>
If and only if the mutex type is internally represented by a single data structure
which can be passed to operating system specific interfaces, then there shall be a nested 
implementation-defined typedef <tt>native_handle_type</tt> that is an alias to this native type if it is copyable,
otherwise if the native type is not copyable, is a pointer to this native type. 
The implementation shall document whether or not the <tt>native_handle_type</tt> 
typedef is present.
</p>

<p>
If the nested typedef <tt>native_handle_type</tt> exists, then there
also shall be a member function <tt>native_handle()</tt> which returns a handle 
to this internal data structure. <i>[Example:</i>
</p>

<blockquote><pre>class mutex
{
    pthread_mutex_t m;
public:
    typedef pthread_mutex_t* native_handle_type;
    native_handle_type native_handle() {return &amp;m;}
    ...
};
</pre>
<p><i>--end example]</i></p>
</blockquote>

<p>
If there is no single operating system specific data structure which implements
the mutex type, then neither the nested type <tt>native_handle_type</tt> nor the
member function <tt>native_handle()</tt> shall not be present.  <i>[Example:</i> 
if a <tt>recursive_mutex</tt> is implemented with both a <tt>pthread_mutex_t</tt>
and a separate lock count, then there will be no <tt>native_handle_type</tt>. <i>
--end example]</i>
</p>

<p>
Implementations may supply additional implementation defined constructors
which allow further customization as afforded by the implementation
or its environment.
</p>

<h4>Class static_mutex</h4>

<blockquote class="note">
<p>
The class <tt>static_mutex</tt> is based on a new language feature <tt>constexpr</tt>
which is not yet in the working draft, nor do we have field experience with it.  Should
this language feature fail to deliver the static initialization behavior desired, we
recommend removing <tt>static_mutex</tt> from the working paper.
</p>
</blockquote>

<blockquote><pre>namespace std {

struct static_mutex
{
public:
    constexpr static_mutex();
    ~static_mutex();

    static_mutex(const static_mutex&amp;) = delete;
    static_mutex&amp; operator=(const static_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef unspecified native_handle_type;  // conditionally present.  example: pthread_mutex_t*
    native_handle_type native_handle();      // conditionally present
};

}  // std
</pre></blockquote>

<p>
The class <code>static_mutex</code> is a non-recursive mutex. It shall be a standard-layout type ([?]),
and does not require dynamic initialization.  The default constructor,
if dynamically initialized, shall not throw an exception.
</p>

<h4>Class mutex</h4>

<blockquote><pre>namespace std {

struct mutex
{
public:
    mutex();
    ~mutex();

    mutex(const mutex&amp;) = delete;
    mutex&amp; operator=(const mutex&amp;) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef unspecified native_handle_type;  // conditionally present.  example: pthread_mutex_t*
    native_handle_type native_handle();      // conditionally present
};

}  // std
</pre></blockquote>

<p>
The class <tt>mutex</tt> is a non-recursive mutex which satisfies all of the Mutex requirements.
It shall be a standard-layout type ([?]).
</p>

<h4>Class recursive_mutex</h4>

<blockquote><pre>namespace std {

struct recursive_mutex
{
public:
    recursive_mutex();
    ~recursive_mutex();

    recursive_mutex(const recursive_mutex&amp;) = delete;
    recursive_mutex&amp; operator=(const recursive_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef unspecified native_handle_type;  // conditionally present.  example: pthread_mutex_t*
    native_handle_type native_handle();      // conditionally present
};

}  // std
</pre></blockquote>

<p>
The class <tt>recursive_mutex</tt> shall be a recursive mutex which satisfies all of the Mutex requirements.
It shall be a standard-layout type ([?]).
</p>

<h3>Timed Mutexes</h3>

<p>
Types that meet the requirements of the Timed Mutex concept also meet the requirements of the Mutex concept
and add a single member function:
</p>

<blockquote>
<pre>template &lt;class ElapsedTime&gt;
    bool timed_lock(const ElapsedTime&amp; rel_time);
</pre>
<blockquote>
<p>
<i>Precondition:</i> For non-recursive mutexes the current thread of execution shall not own the mutex.
The type <tt>ElapsedTime</tt> shall be explicitly convertible to <tt>nanoseconds</tt>.
</p>
<p>
<i>Effects:</i> The function attempts to obtain ownership of the mutex within the specified time.
If the indicated time is less than or equal to <tt>0</tt>, the function still attempts to obtain ownership without
blocking (as if by calling <tt>try_lock()</tt>).  If the function returns within the specified
time duration, it shall have obtained ownership.
</p>
<p>
<i>Returns:</i> <tt>true</tt> if ownership was obtained, otherwise <tt>false</tt>.
</p>
<p>
<i>Thread safety:</i> Calls to this member function from different 
threads of execution shall not result in data races or deadlocks.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4>Class timed_mutex</h4>

<blockquote><pre>namespace std {

struct timed_mutex
{
public:
    timed_mutex();
    ~timed_mutex();

    timed_mutex(const timed_mutex&amp;) = delete;
    timed_mutex&amp; operator=(const timed_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    template &lt;class ElapsedTime&gt;
        bool timed_lock(const ElapsedTime&amp; rel_time);
    void unlock();

    typedef unspecified native_handle_type;  // conditionally present.  example: pthread_mutex_t*
    native_handle_type native_handle();      // conditionally present
};

}  // std
</pre></blockquote>

<p>
The class <tt>timed_mutex</tt> is a non-recursive mutex that satisfies all of the Timed Mutex requirements.
It shall be a standard-layout type ([?]).
</p>

<h4>Class recursive_timed_mutex</h4>

<blockquote><pre>namespace std {

struct recursive_timed_mutex
{
public:
    recursive_timed_mutex();
    ~recursive_timed_mutex();

    recursive_timed_mutex(const recursive_timed_mutex&amp;) = delete;
    recursive_timed_mutex&amp; operator=(const recursive_timed_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    template &lt;class ElapsedTime&gt;
        bool timed_lock(const ElapsedTime&amp; rel_time);
    void unlock();

    typedef unspecified native_handle_type;  // conditionally present.  example: pthread_mutex_t*
    native_handle_type native_handle();      // conditionally present
};

}  // std
</pre></blockquote>

<p>
The class <tt>recursive_timed_mutex</tt> shall be a recursive mutex that satisfies all of the Timed Mutex requirements.
It shall be a standard-layout type ([?]).
</p>

<h3>Locks</h3>

<p>
Locks are objects that hold a reference to a mutex and unlock the mutex during the lock's destruction
(such as when leaving block scope).  The locks do not manage the lifetime of the mutex they
reference, but only the ownership status of that mutex.  <i>[Note: </i>Locks are intended to ease the burden
of unlocking the mutex under both normal and exceptional circumstances.<i> --end 
note]</i></p>

<p>
Some locks may take tag types which describe what should be done with the mutex in the lock's
constructor.
</p>

<blockquote><pre>
struct defer_lock_t  {};
struct try_to_lock_t {};
struct adopt_lock_t  {};

extern const defer_lock_t   defer_lock;
extern const try_to_lock_t  try_to_lock;
extern const adopt_lock_t   adopt_lock;
</pre></blockquote>

<p>
An exception class <tt>lock_error</tt> derives from <tt>exception</tt> and is used to indicate
improper usage of locks such as locking a mutex that the lock already owns, or unlocking a mutex
that the lock does not own.
</p>

<blockquote><pre>class lock_error
    : public std::exception
{
public:
    virtual const char* what() const throw();
};
</pre></blockquote>

<h4>Class scoped_lock</h4>

<blockquote><pre>namespace std {

template &lt;class Mutex&gt;
class scoped_lock
{
public:
    typedef Mutex mutex_type;

    explicit scoped_lock(mutex_type&amp; m);
    scoped_lock(mutex_type&amp; m, adopt_lock_t);
    ~scoped_lock();

    scoped_lock(scoped_lock const&amp;) = delete;
    scoped_lock&amp; operator=(scoped_lock const&amp;) = delete;

    constexpr bool owns() const;  <ins>Remove?</ins>
};

}  // std
</pre></blockquote>

<p>
<tt>scoped_lock</tt> is used to control the ownership of a mutex within a single scope.
An invariant of the <tt>scoped_lock</tt> object is that it maintains the ownership of the
mutex throughout the <tt>scoped_lock</tt>'s lifetime.  Mutex ownership can not be deferred
or transferred away from the <tt>scoped_lock</tt>.
</p>

<blockquote>
<pre>explicit scoped_lock(mutex_type&amp; m);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <tt>mutex_type</tt> is not a recursive mutex,  the current thread of execution
does not own the mutex.  The lifetime of <tt><i>m</i></tt> is greater than the lifetime
of the <code>scoped_lock</code> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and calls <tt><i>m</i>.lock()</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>scoped_lock(mutex_type&amp; m, adopt_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> The current thread of execution has ownership of the mutex <tt><i>m</i></tt>.
The lifetime of <tt><i>m</i></tt> is greater than the lifetime of the <code>
scoped_lock</code> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and performs no other operation on it.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>~scoped_lock();
</pre>
<blockquote>
<p>
<i>Effects:</i> <tt><i>m</i>.unlock()</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>


<blockquote>
<pre>constexpr bool owns() const;
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>true</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4>Class unique_lock</h4>

<blockquote><pre>namespace std {

template &lt;class Mutex&gt;
class unique_lock
{
public:
    typedef Mutex mutex_type;

    unique_lock();
    explicit unique_lock(mutex_type&amp; m);
    unique_lock(mutex_type&amp; m, defer_lock_t);
    unique_lock(mutex_type&amp; m, try_to_lock_t);
    unique_lock(mutex_type&amp; m, adopt_lock_t);
    ~unique_lock();

    unique_lock(unique_lock const&amp;) = delete;
    unique_lock&amp; operator=(unique_lock const&amp;) = delete;

    unique_lock(unique_lock&amp;&amp; u);
    unique_lock&amp; operator=(unique_lock&amp;&amp; u);

    void lock();
    bool try_lock();
    template &lt;class ElapsedTime&gt;
        bool timed_lock(const ElapsedTime&amp; rel_t);
    void unlock();

    bool owns() const;
    operator unspecified-bool-type () const;
    mutex_type* mutex() const;

    void swap(unique_lock&amp;&amp; u);
    mutex_type* release();
};

template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);

}  // std
</pre></blockquote>

<p>
<tt>unique_lock</tt> is used to control the ownership of a mutex within one or more scopes.
Mutex ownership can be deferred or transferred away from the <tt>unique_lock</tt>. 
An object of type
<tt>unique_lock</tt> is not copyable but is movable.
</p>

<blockquote>
<pre>unique_lock();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <tt>unique_lock</tt>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == 0
owns() == false
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>explicit unique_lock(mutex_type&amp; m);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <tt>mutex_type</tt> is not a recursive mutex,  the current thread of execution
does not own the mutex.  The lifetime of <tt><i>m</i></tt> is greater than the lifetime
of the <tt>unique_lock</tt> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and calls <tt><i>m</i>.lock()</tt>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns() == true
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(mutex_type&amp; m, defer_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <tt>mutex_type</tt> is not a recursive mutex,  the current thread of execution
does not own the mutex. 
The lifetime of <tt><i>m</i></tt> is greater than the lifetime of the <tt>
unique_lock</tt> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and performs no other operation on it.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns() == false
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(mutex_type&amp; m, try_to_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <tt>mutex_type</tt> is not a recursive mutex, then the current thread of execution
does not own the mutex. 
The lifetime of <tt><i>m</i></tt> is greater than the lifetime of the <tt>
unique_lock</tt> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and calls <tt><i>m</i>.try_lock()</tt>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns() == <i>The result of the call to</i> <i>m</i>.try_lock()
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(mutex_type&amp; m, adopt_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> The current thread of execution has ownership of the mutex <tt><i>m</i></tt>. 
The lifetime of <tt><i>m</i></tt> is greater than the lifetime of the <tt>
unique_lock</tt> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and performs no other operation on it.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns() == true
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>~unique_lock();
</pre>
<blockquote>
<p>
<i>Effects:</i> If <tt>owns()</tt> calls <tt>unlock()</tt> on the referenced mutex.
Otherwise there are no effects.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(unique_lock&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i> Transfers mutex ownership (if any) from <tt>u</tt> to <tt>this</tt>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == <i>The value of</i> u.mutex() <i>prior to the construction</i>.
owns() == <i>The value of</i> u.owns() <i>prior to the construction</i>.
u.mutex() == 0
u.owns() == false
</pre></blockquote>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock&amp; operator=(unique_lock&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i>  If <tt>owns()</tt> calls <tt>unlock()</tt>, and then
transfers mutex ownership (if any) from <tt>u</tt> to <tt>this</tt>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == <i>The value of</i> u.mutex() <i>prior to the construction</i>.
owns() == <i>The value of</i> u.owns() <i>prior to the construction</i>.
u.mutex() == 0
u.owns() == false
</pre></blockquote>
<p>
<i>Throws:</i> Nothing.
</p>
<p>
<i>Note:</i> With a recursive mutex it is possible that both
<tt>this</tt> and <tt>u</tt> own the same mutex before the assignment.
In this case, <tt>this</tt> will own the mutex after the assignment (and
<tt>u</tt> will not), but the mutex's lock count will be decremented by
one.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void lock();
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <tt>lock()</tt> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <tt>owns() == true</tt>.
</p>
<p>
<i>Throws:</i> <tt>lock_error</tt>, if on entry <tt>owns()</tt> is <tt>true</tt>.</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool try_lock();
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <tt>try_lock()</tt> on the referenced mutex.
</p>
<p>
<i>Returns:</i>  The result of the call to <tt>try_lock()</tt> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <tt>owns() == </tt>The result of the call to <tt>try_lock()</tt> on the referenced mutex.
</p>
<p>
<i>Throws:</i> <tt>lock_error</tt>, if on entry <tt>owns()</tt> is <tt>true</tt>.<tt> </tt>
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class ElapsedTime&gt;
   bool timed_lock(const ElapsedTime&amp; rel_t);
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <tt>timed_lock(rel_t)</tt> on the referenced mutex.
</p>
<p>
<i>Returns:</i>  The result of the call to <tt>timed_lock(rel_t)</tt> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <tt>owns() == </tt>The result of the call to <tt>timed_lock(rel_t)</tt> on the referenced mutex.
</p>
<p>
<i>Throws:</i> <tt>lock_error</tt>, if on entry <tt>owns()</tt> is <tt>true</tt>.</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void unlock();
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <tt>void unlock()</tt> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <tt>owns() == false</tt>.
</p>
<p>
<i>Throws:</i> <tt>lock_error</tt>, if on entry <tt>owns()</tt> is <tt>false</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool owns() const;
</pre>
<blockquote>
<p>
<i>Returns:</i>  <tt>true</tt> if <tt>this</tt> owns a lock on a referenced mutex, else <tt>false</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>operator unspecified-bool-type () const;
</pre>
<blockquote>
<p>
<i>Returns:</i>  Non-null if <tt>owns()</tt> would return <tt>true</tt>, else returns null.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>mutex_type* mutex() const;
</pre>
<blockquote>
<p>
<i>Returns:</i>  A pointer to the referenced mutex, or null if there is no referenced mutex.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void swap(unique_lock&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i>  Swaps state with <tt>u</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>mutex_type* release();
</pre>
<blockquote>
<p>
<i>Returns:</i>  A pointer to the referenced mutex, or null if there is no referenced mutex.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == 0
owns() == false
</pre></blockquote>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);
</pre>
<blockquote>
<p>
<i>Effects:</i>  <tt>x.swap(y)</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h3>Generic Locking Algorithms</h3>

<blockquote>
<pre>template &lt;class L1, class L2, class ...L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
<p>
<i>Requires:</i>  Each template parameter type must supply the following member functions with semantics
corresponding to the Mutex concept, except that <tt>try_lock</tt> is allowed to throw an
exception. <i>[Note:</i> The <tt>unique_lock</tt> class template meets these requirements 
when suitable instantiated. <i>--end note]</i></p>
<blockquote><pre>bool try_lock();
void unlock();
</pre></blockquote>
<p>
<i>Effects:</i> The functions attempts to lock all arguments without blocking by calling <tt>try_lock()</tt>
on each of them.  If any argument can not be locked, then all arguments which have already been locked will
be unlocked.  On return, either all arguments will be locked, or none of them will be locked.  If an
exception is thrown by a call to <tt>try_lock()</tt>, there are no effects.
</p>
<p>
<i>Returns:</i> If all arguments were successfully locked, returns <code>-1</code>.  Otherwise returns a 0-based index 
value indicating
which argument failed to lock.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class L1, class L2, class ...L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
<p>
<i>Requires:</i>  Each template parameter type must supply the following member functions with semantics
corresponding to the Mutex concept, except that <tt>try_lock</tt> is allowed to 
throw an exception <i>[Note:</i> The <tt>unique_lock</tt> class template meets these requirements 
when suitable instantiated. <i>--end note]</i></p>
<blockquote><pre>void lock();
bool try_lock();
void unlock();
</pre></blockquote>
<p>
<i>Effects:</i> All arguments are locked with an algorithm that avoids deadlock.
If an exception is thrown by a call to <tt>lock()</tt> or <tt>try_lock()</tt>, there are no effects.
</p>
</blockquote>
</blockquote>

<h3><a name="ConditionVariablesWording">Condition variables</a></h3>

<b>&lt;cond_var&gt; synopsis</b>

<blockquote><pre>namespace std {

class cond_var;
class gen_cond_var;

}  // std
</pre></blockquote>

<h4>Class cond_var</h4>

<p>
An object of class <tt>cond_var</tt> is a synchronization primitive 
used to cause a thread of execution to wait until notified by some other 
thread of execution that some condition is met, or a UTC[(?)] time is reached.
</p>

<blockquote><pre>namespace std {

class cond_var
{
public:
    cond_var();
    ~cond_var();

    cond_var(const cond_var&amp;) = delete;
    cond_var&amp; operator=(const cond_var&amp;) = delete;

    void notify_one();
    void notify_all();
    void wait(unique_lock&lt;mutex&gt;&amp; lock);
    template &lt;class Predicate&gt;
        void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
    bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const utc_time&amp; abs_time);
    template &lt;class Predicate&gt;
        bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const utc_time&amp; abs_time, Predicate pred);
};

}  // std
</pre></blockquote>

<blockquote>
<pre>cond_var();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>cond_var</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>~cond_var();
</pre>
<blockquote>
<p>
<i>Effects:</i> Destroys the object.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_one();
</pre>
<blockquote>
<p>
<i>Effects:</i> If any threads of execution are blocked waiting for <code>*this</code>, 
unblocks at least one those threads.</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_all();
</pre>
<blockquote>
<p>
<i>Effects:</i> Unblock all threads that are blocked waiting for <code>*this</code>.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
<p>
<i>Precondition:</i> <tt>lock</tt> is locked by the current thread of execution.  No
other thread of execution is waiting on this <tt>cond_var</tt> object unless <tt>lock</tt>
refers to the same underlying <tt>mutex</tt> object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<tt>lock</tt>. If the <tt>wait</tt> should throw an exception for any
reason, <tt>lock</tt> will be locked as the exception propagates out. 
This thread of execution shall unblock when another thread issues a
notification to this blocked thread. The current thread of execution may
unblock and return even in the absence of a notification.
</p>
<p>
<i>Postcondition:</i> <tt>lock</tt> is locked by the current 
thread of execution.</p>
<p>
<i>Throws:</i> May throw <tt>system_error</tt> if a precondition is not met.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Predicate&gt;
    void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> While <tt>pred()</tt> returns <tt>false</tt> calls <tt>wait(lock)</tt>.
</p>
<p>
<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>.
</p>
</blockquote>
</blockquote>


<blockquote>
<pre>bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const utc_time&amp; abs_time);
</pre>
<blockquote>
<p>
<i>Precondition:</i>  The <tt>lock</tt> is locked by the current thread of execution.  No
other thread of execution is waiting on this <tt>cond_var</tt> object unless <tt>lock</tt>
refers to, the same underlying <tt>mutex</tt> object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<tt>lock</tt>. If the <tt>timed_wait</tt> should throw an exception for
any reason, <tt>lock</tt> will be locked as the exception propagates
out.  If the absolute time specified by <tt>abs_time</tt> passes (that
is, system time equals or exceeds <tt>abs_time</tt>) before the
<tt>condition</tt> is notified, or if the absolute time specified by
<tt>abs_time</tt> has already been passed at the time of the call, then
<tt>false</tt> is returned. This thread of execution shall unblock when
another thread issues a notification to this blocked thread. The current
thread of execution may unblock and return even in the absence of a
notification.
</p>
<p>
<i>Postcondition:</i> <tt>lock</tt> is locked by the current 
thread of execution.</p>
<p>
<i>Returns:</i> <tt>true</tt> if the call to <tt>timed_wait</tt> is notified prior
to the indicated timeout,
otherwise returns <tt>false</tt>.
</p>
<p>
<i>Throws:</i> May throw <tt>system_error</tt> if a precondition is not met.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class _Predicate&gt;
    bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const utc_time&amp; abs_time, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> As if:
</p>
<blockquote><pre>while (!pred())
{
    if (!timed_wait(lock, abs_time))
        return pred();
}
return true;
</pre></blockquote>
<p>
<i>Returns:</i> <tt>pred()</tt>.
</p>
<p>
<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>, even
if the timeout has already expired.  The return value indicates whether the predicate
evaluates to <tt>true</tt>, regardless of whether the timeout was triggered.
</p>
</blockquote>
</blockquote>

<p>
<tt>cond_var</tt> shall be a standard-layout type ([?]).
</p>

<h4>Class gen_cond_var</h4>

<p>
An object of class <tt>gen_cond_var</tt> is a synchronization primitive 
used to cause a thread of execution to wait until notified by some other 
thread of execution that some condition is met, or a UTC[(?)] time is reached.
</p>

<p>
The <tt>Lock</tt> type must support member functions <tt>lock</tt>
and <tt>unlock</tt> with the semantics of the mutex concept.  All of the standard mutex types
meet this requirement.
</p>

<blockquote><pre>namespace std {

class gen_cond_var
{
public:
    gen_cond_var();
    ~gen_cond_var();

    gen_cond_var(const gen_cond_var&amp;) = delete;
    gen_cond_var&amp; operator=(const gen_cond_var&amp;) = delete;

    void notify_one();
    void notify_all();
    template &lt;class Lock&gt;
        void wait(Lock&amp; lock);
    template &lt;class Lock, class Predicate&gt;
        void wait(Lock&amp; lock, Predicate pred);
    template &lt;class Lock&gt;
        bool timed_wait(Lock&amp; lock, const utc_time&amp; abs_time);
    template &lt;class Lock, class Predicate&gt;
        bool timed_wait(Lock&amp; lock, const utc_time&amp; abs_time, Predicate pred);
};

}  // std
</pre></blockquote>

<blockquote>
<pre>gen_cond_var();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>gen_cond_var</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>~gen_cond_var();
</pre>
<blockquote>
<p>
<i>Effects:</i> Destroys the object.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_one();
</pre>
<blockquote>
<p>
<i>Effects:</i> If any threads of execution are blocked waiting for <code>*this</code>, 
unblocks at least one those threads.</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_all();
</pre>
<blockquote>
<p>
<i>Effects:</i> Unblock all threads that are blocked waiting for <code>*this</code>.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void wait(Lock&amp; lock);
</pre>
<blockquote>
<p>
<i>Precondition:</i> <tt>lock</tt> is locked by the current thread of execution.  If
<tt>Lock</tt> supports recursive locking, the lock count is one.  No
other thread of execution is waiting on this <tt>gen_cond_var</tt> object unless <tt>lock</tt>
is, or refers to, the same underlying mutex object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<tt>lock</tt>. If the <tt>wait</tt> should throw an exception for any
reason, <tt>lock</tt> will be locked as the exception propagates out. 
This thread of execution shall unblock when another thread issues a
notification to this blocked thread. The current thread of execution may
unblock and return even in the absence of a notification.
</p>
<p>
<i>Postcondition:</i> <tt>lock</tt> is locked by the current 
thread of execution.</p>
<p>
<i>Throws:</i> May throw <tt>system_error</tt>.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Predicate&gt;
    void wait(lock_type&amp; lock, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> While <tt>pred()</tt> returns <tt>false</tt>, calls <tt>wait(lock)</tt>.
</p>
<p>
<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>.
</p>
</blockquote>
</blockquote>


<blockquote>
<pre>bool timed_wait(Lock&amp; lock, const utc_time&amp; abs_time);
</pre>
<blockquote>
<p>
<i>Precondition:</i>  The <tt>lock</tt> is locked by the current thread of execution.  If
<tt>Lock</tt> supports recursive locking, the lock count is one.  No
other thread of execution is waiting on this <tt>gen_cond_var</tt> object unless <tt>lock</tt>
is, or refers to, the same underlying mutex object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<tt>lock</tt>. If the <tt>timed_wait</tt> should throw an exception for
any reason, <tt>lock</tt> will be locked as the exception propagates
out.  If the absolute time specified by <tt>abs_time</tt> passes (that
is, system time equals or exceeds <tt>abs_time</tt>) before the
<tt>condition</tt> is notified, or if the absolute time specified by
<tt>abs_time</tt> has already been passed at the time of the call, then
<tt>false</tt> is returned. This thread of execution shall unblock when
another thread issues a notification to this blocked thread. The current
thread of execution may unblock and return even in the absence of a
notification.
</p>
<p>
<i>Postcondition:</i> <tt>lock</tt> is locked by the current 
thread of execution.</p>
<p>
<i>Returns:</i> <tt>true</tt> if the call to <tt>timed_wait</tt> is notified prior
to the indicated timeout,
otherwise returns <tt>false</tt>.
</p>
<p>
<i>Throws:</i> May throw <tt>system_error</tt>.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class _Predicate&gt;
    bool timed_wait(Lock&amp; lock, const utc_time&amp; abs_time, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> As if:
</p>
<blockquote><pre>while (!pred())
{
    if (!timed_wait(lock, abs_time))
        return pred();
}
return true;
</pre></blockquote>
<p>
<i>Returns:</i> <tt>pred()</tt>.
</p>
<p>
<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>, even
if the timeout has already expired.  The return value indicates whether the predicate
evaluates to <tt>true</tt>, regardless of whether the timeout was triggered.
</p>
</blockquote>
</blockquote>


<hr>


<h2><a name="DateTime"></a>Chapter ?&nbsp;&nbsp; Date Time Library</h2>

<hr>



<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.header__date_time__synopsis"></a>
Header &lt;date_time&gt; Synopsis</h3></div></div></div>

<blockquote><pre>
namespace std 
{

  //duration types
  class    hours;
  class    minutes;
  class    seconds;
  class    milliseconds;
  class    microseconds;
  class    nanoseconds;

  //timepoint   
  class utc_time;

  template<class time_type>
  class hiresolution_clock;
} //std
</pre></blockquote>

</div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_utc_time"></a>class utc_time</h3></div></div></div>

<blockquote><pre>
class utc_time 
{
 public:

  utc_time(); //epoch
  utc_time(time_t, nanoseconds ns);
  ~utc_time();

  time_t seconds_since_epoch() const;
  nanoseconds nanoseconds_since_epoch() const;

  //traits 
  typedef 'implementation defined' tick_type;
  static tick_type ticks_per_second();
  static tick_type seconds_per_tick();
  static bool is_subsecond();

  //comparison functions
  bool operator==(const utc_time&amp; rhs) const;
  bool operator!=(const utc_time&amp; rhs) const;
  bool operator&gt;(const utc_time&amp; rhs) const;
  bool operator&gt;=(const utc_time&amp; rhs) const;
  bool operator&lt;(const utc_time&amp; rhs) const;
  bool operator&lt;=(const utc_time&amp; rhs) const;

  //arithmetic functions
  nanoseconds operator-(const utc_time&amp; rhs) const

  template&lt;typename time_duration_type&gt;
  utc_time operator+(const time_duration_type&amp; td) const;

  template&lt;typename time_duration_type&gt;
  utc_time&amp; operator+=(const time_duration_type&amp; td);

  template&lt;typename time_duration_type&gt;
  utc_time operator-(const time_duration_type&amp; td) const;

  template&lt;typename time_duration_type&gt;
  utc_time&amp; operator-=(const time_duration_type&amp; td) 

};
</pre></blockquote>
<p>
        The class utc_time provides a timepoint that represents the current UTC time.
        utc_time <span class="strikethrough">must</span><span class="underline">shall</span>
        provide a<span class="underline">n epoch time</span><span class="strikethrough">minimum range</span> of 1970-01-01 00:00:00.000000000
        <span class="underline">and a maximum time value of at least epoch time
        + 292 years</span>.
      </p>

<blockquote class="note">
<p>
<h3 class="title">Note</h3><p>
          292 years represents the number of nanoseconds that can be represented 
         in a signed 64 bit integer.
</p></blockquote>

<pre class="programlisting">
<span class="identifier">utc_time</span><span class="special">();</span><span class="comment">//epoch
</span></pre><p>
        <span class="emphasis"><em>Effects: Construct<span class="underline">s</span> a utc_time
        <span class="underline">object</span> representing the epoch time
        point 1970-01-01 00:00:00.000000000</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">utc_time</span><span class="special">(</span><span class="identifier">time_t</span> <span class="identifier">secs</span><span class="special">,</span> <span class="identifier">nanoseconds</span> <span class="identifier">ns</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Construct<span class="underline">s</span> a utc
        time <span class="underline">object </span><span class="strikethrough">where</span><span class="underline"> representing the time point that is secs + 1,000,000,000*ns
              seconds after the epoch</span><span class="strikethrough"> represents
        seconds since 1970-01-01 00:00:00.000000000 and nanoseconds provides an additional
        nanosecond offset</span></em></span>
      </p><p>
        <span class="emphasis"><em>Remarks: If the total nanoseconds &gt; 1 second the seconds are
        incremented appropriately</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><p>
        <span class="strikethrough">~utc_time(); </span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Effects: Destroys the time point.</em></span></span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Throws: Nothing</em></span></span>
      </p><pre class="programlisting">
<span class="identifier">time_t</span> <span class="identifier">seconds_since_epoch</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns the count of seconds since 1970-01-01 00:00:00.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">nanoseconds</span> <span class="identifier">nanoseconds_since_epoch</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns the count of <span class="underline">nano</span>seconds
        since 1970-01-01 00:00:00.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns 1000000000</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns 0</em></span>
      </p><p>
        <span class="emphasis"><em>Remarks: Since this is a subsecond type it returns 0 for seconds_per_tick</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: true.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">utc_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if <span class="strikethrough">rhs is</span>
        the <span class="strikethrough">same time</span><span class="underline">time
        represented by *this is equal to the time represented by rhs</span>.
        </em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span><span class="keyword">const</span> <span class="identifier">utc_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if <span class="strikethrough">rhs is
        not</span> the <span class="strikethrough">same time</span><span class="underline">time represented by *this is not equal to the time represented
        by rhs</span></em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;(</span><span class="keyword">const</span> <span class="identifier">utc_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if time <span class="strikethrough">is
        greater than rhs time</span><span class="underline">represented by
        *this is greater than the time represented by rhs</span>.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;=(</span><span class="keyword">const</span> <span class="identifier">utc_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if time<span class="strikethrough">is
        greater or equal than rhs time</span><span class="underline">represented
        by *this is greater or equal than the time represented by rhs</span>.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;(</span><span class="keyword">const</span> <span class="identifier">utc_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if time <span class="strikethrough">is
        less than rhs time</span><span class="underline">represented by *this
        is less than the time represented by rhs</span>.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;=(</span><span class="keyword">const</span> <span class="identifier">utc_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if time <span class="strikethrough">is
        less than rhs time</span><span class="underline">represented by *this
        is less or equal than the time represented by rhs</span>.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">nanoseconds</span> <span class="keyword">operator</span><span class="special">-(</span><span class="keyword">const</span> <span class="identifier">utc_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: <span class="strikethrough">Returns the difference
        between two times in a nanosecond count.</span> <span class="underline">Returns
        the difference in nanoseconds between the time represented by *this and the
        time represented by rhs.</span> </em></span>
      </p><p>
        <span class="emphasis"><em>Remarks: If rhs is greater the result will be a negative nanosecond
        count.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">time_duration_type</span><span class="special">&gt;</span>
<span class="identifier">utc_time</span> <span class="keyword">operator</span><span class="special">+(</span><span class="keyword">const</span> <span class="identifier">time_duration_type</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns the duration converted to nanosecond resolution
        and added to the time <span class="underline">represented by *this</span>.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">time_duration_type</span><span class="special">&gt;</span>
<span class="identifier">utc_time</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">+=(</span><span class="keyword">const</span> <span class="identifier">time_duration_type</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Convert the duration to nanosecond resolution add to nanoseconds
        to the time <span class="underline">represented by *this</span>.</em></span>
      </p><p>
        <span class="emphasis"><em>Returns: Modified value of this.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">time_duration_type</span><span class="special">&gt;</span>
<span class="identifier">utc_time</span> <span class="keyword">operator</span><span class="special">-(</span><span class="keyword">const</span> <span class="identifier">time_duration_type</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns the duration converted to nanosecond resolution
        and subtracted from the time <span class="underline">represented by *this</span>.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">time_duration_type</span><span class="special">&gt;</span>
<span class="identifier">utc_time</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">-=(</span><span class="keyword">const</span> <span class="identifier">time_duration_type</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">)</span> 
</pre><p>
        <span class="emphasis"><em>Effects: Convert the duration to nanosecond resolution subtract
        from the time <span class="underline">represented by *this</span>
        and return *this.</em></span>
      </p><p>
        <span class="emphasis"><em>Returns: Modified value of this.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p></div>



<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.template_class_hiresolution_clock"></a>template class hiresolution_clock</h3></div></div></div>

<blockquote><pre>

template&lt;class time_type&gt;
class hiresolution_clock
{
public:
  static time_type universal_time();
  static tick_type ticks_per_second();
};

</pre></blockquote>


<p>
        The hiresolution_clock provides access to the operating system clock at a
        resolution up to nanoseconds. The actual resolution <span class="strikethrough">will</span><span class="underline"> may</span> vary from platform to platform. <span class="underline">The time_type parameter provides compatibility for user
        defined time types as specified in the TR2 proposal.</span>
      </p>
<blockquote class="note">
<p>
<h3 class="title">Note</h3><p>
    Typical personal computer platforms currently achieve microsecond level
    resolution from calls to the clock. The <a href="http://www.boost.org/libs/date_time/index.html" target="_top">Boost Date-Time Library</a> has a class that portably implements the proposed
    interface, but it uses different C-level interfaces depending on the operating
    system.
        </p></blockquote>
<pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">time_type</span> <span class="identifier">universal_time</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: <span class="strikethrough">The Current UTC time -
        equivalent of time_t with fractional sections.</span> <span class="underline">An
        object of time_type that represents the current UTC time as measured from
        the computer clock.</span> </em></span>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          <span class="underline">universal_time is the equivalent of the iso
          C time call, but with a higher resolution as defined by the platform.</span>
        </p></div><p>
        <span class="emphasis"><em>Remarks: Function is thread-safe on platforms supporting threading.
        <span class="strikethrough">Successive</span><span class="underline"> Every</span>
        call<span class="strikethrough">s</span> to this function will <span class="strikethrough">produce </span><span class="underline">return</span>
        a<span class="strikethrough">nd</span><span class="underline"> value
        that is</span> equal or greater <span class="strikethrough">time value
        in all cases</span><span class="underline">than the value returned
        by any previous call</span>.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><p>
        <span class="underline">static tick_type ticks_per_second();</span>
      </p><p>
        <span class="underline"><span class="emphasis"><em>Returns: The number of ticks in one
        second provided by the clock implementation.</em></span></span>
      </p><p>
        <span class="underline"><span class="emphasis"><em>Throws: Nothing</em></span></span>
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.common_duration_functions"></a>Common Duration Functions</h3></div></div></div><p>
        The following functions are common functions to all durations types. These
        functions provide the basis for durations to be EqualityComparable, LessThanComparable
        as well as the usual arithmetic operations.
      </p><p>
        In the following text duration_type refers to the containing duration type.
      </p>

<blockquote><pre>
class duration_type { //where duration_type== nanoseconds, microseconds, etc

    //comparison operators
    template&lt;typename rhs_duration_type&gt;
    bool operator&lt;  (const rhs_duration_type&amp;) const;

    template&lt;typename rhs_duration_type&gt;
    bool operator&lt;= (const rhs_duration_type&amp;) const;

    template&lt;typename rhs_duration_type&gt;
    bool operator&gt;  (const rhs_duration_type&amp;) const;

    template&lt;typename rhs_duration_type&gt;
    bool operator&gt;= (const rhs_duration_type&amp;) const;

    template&lt;typename rhs_duration_type&gt;
    bool operator== (const rhs_duration_type&amp;) const;

    template&lt;typename rhs_duration_type&gt;
    bool operator!= (const rhs_duration_type&amp;) const;


    //sign inversion
    duration_type operator-() const

    //arithmetic operations
    template&lt;typename rhs_duration_type&gt;
    duration_type operator- (const rhs_duration_type&amp; d) const

    template&lt;typename rhs_duration_type&gt;
    duration_type operator-=(const rhs_duration_type&amp; d)

    template&lt;typename rhs_duration_type&gt;
    duration_type operator+ (const rhs_duration_type&amp; d) const

    template&lt;typename rhs_duration_type&gt;
    duration_type operator+=(const rhs_duration_type&amp; d)

    duration_type operator/ (int divisor) const
    duration_type operator/=(int divisor) 
    duration_type operator* (int rhs) const
    duration_type operator*=(int divisor) 

    tick_type get_count() const 

}
</pre></blockquote>
<p>
        The following details each of these functions.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">rhs_duration_type</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">rhs_duration_type</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if rhs duration is greater.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">rhs_duration_type</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span><span class="keyword">const</span> <span class="identifier">rhs_duration_type</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if rhs is not the same time.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">rhs_duration_type</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;(</span><span class="keyword">const</span> <span class="identifier">rhs_duration_type</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if the rhs duration is larger.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">rhs_duration_type</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;=(</span><span class="keyword">const</span> <span class="identifier">rhs_duration_type</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if greater or equal than the rhs duration.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">rhs_duration_type</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;(</span><span class="keyword">const</span> <span class="identifier">rhs_duration_type</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if less than the rhs duration.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">rhs_duration_type</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;=(</span><span class="keyword">const</span> <span class="identifier">rhs_duration_type</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <span class="emphasis"><em>Returns: Returns true if less or equal to the rhs duration.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="comment">//sign inversion
</span><span class="identifier">duration_type</span> <span class="keyword">operator</span><span class="special">-()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: Negated value of the duration.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="comment">//arithmetic operations
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">rhs_duration_type</span><span class="special">&gt;</span>
<span class="identifier">duration_type</span> <span class="keyword">operator</span><span class="special">-</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">rhs_duration_type</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: A duration value equal to this-rhs_duration.</em></span>
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the rhs_duration_type is
        of higher resolution.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">rhs_duration_type</span><span class="special">&gt;</span>
<span class="identifier">duration_type</span> <span class="keyword">operator</span><span class="special">-=(</span><span class="keyword">const</span> <span class="identifier">rhs_duration_type</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span>
</pre><p>
        <span class="emphasis"><em>Effects: Modifies to value equal to this-rhs_duration. </em></span>
      </p><p>
        <span class="emphasis"><em>Returns: this </em></span>
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the rhs_duration_type is
        of higher resolution.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">rhs_duration_type</span><span class="special">&gt;</span>
<span class="identifier">duration_type</span> <span class="keyword">operator</span><span class="special">+</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">rhs_duration_type</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: Duration equal to this+rhs_duration. </em></span>
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the rhs_duration_type is
        of higher resolution.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">rhs_duration_type</span><span class="special">&gt;</span>
<span class="identifier">duration_type</span> <span class="keyword">operator</span><span class="special">+=(</span><span class="keyword">const</span> <span class="identifier">rhs_duration_type</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span>
</pre><p>
        <span class="emphasis"><em>Effects: Modifies to value equal to this+rhs_duration. </em></span>
      </p><p>
        <span class="emphasis"><em>Returns: this </em></span>
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the rhs_duration_type is
        of higher resolution.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">duration_type</span> <span class="keyword">operator</span><span class="special">/</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">divisor</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: Duration with value equal to this/divisor according to
        integer arithmetic rules.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">duration_type</span> <span class="keyword">operator</span><span class="special">/=(</span><span class="keyword">int</span> <span class="identifier">divisor</span><span class="special">)</span> 
</pre><p>
        <span class="emphasis"><em>Effects: Change value of this by this/divisor according to integer
        arithmetic rules.</em></span>
      </p><p>
        <span class="emphasis"><em>Returns: this </em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">duration_type</span> <span class="keyword">operator</span><span class="special">*</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: Duration with value equal to this*rhs </em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">duration_type</span> <span class="keyword">operator</span><span class="special">*=(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">)</span> 
</pre><p>
        <span class="emphasis"><em>Effects: Modifies to value equal to this*rhs. </em></span>
      </p><p>
        <span class="emphasis"><em>Returns: this </em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">tick_type</span> <span class="identifier">get_count</span><span class="special">()</span> <span class="keyword">const</span> 
</pre><p>
        <span class="emphasis"><em>Returns: Returns the count at the resolution of the time duration
        type.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_nanoseconds"></a>class nanoseconds</h3></div></div></div>


<blockquote><pre>
class nanoseconds 
{
 public:

   nanoseconds(long long=0);
   nanoseconds(const nanoseconds& rhs);
   ~nanoseconds();

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef 'implementation-defined' tick_type;

   //+ common functions

};
</pre></blockquote>
<p>
        Class nanoseconds represents a count of nanoseconds.
      </p><pre class="programlisting">
<span class="identifier">nanoseconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of nanoseconds - default
        is zero.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">nanoseconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">nanoseconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Copy construction.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><p>
        <span class="strikethrough">~nanoseconds();</span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Effects: Destruct count.</em></span></span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Throws: Nothing</em></span></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 1000000000</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 0</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: true</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_microseconds"></a>class microseconds</h3></div></div></div>

<blockquote><pre>
class microseconds 
{
 public:

   microseconds(long long=0);
   microseconds(const microseconds&amp; rhs);
   ~microseconds();

   //conversions
   operator nanoseconds() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef 'implementation-defined' tick_type;

   //+ common functions

};

</pre></blockquote>
<p>
        Class microseconds represents a count of microseconds.
      </p><pre class="programlisting">
<span class="identifier">microseconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of microseconds - default
        is zero.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">microseconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">microseconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Copy construction.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><p>
        <span class="strikethrough">~microseconds();</span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Effects: Destruct count.</em></span></span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Throws: Nothing</em></span></span>
      </p><pre class="programlisting">
<span class="comment">//conversions
</span><span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: microsecond count converted to nanoseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 1000000</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 0</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: true</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_milliseconds"></a>class milliseconds</h3></div></div></div>


<blockquote><pre>
class milliseconds
{
 public:
   milliseconds(long long=0);
   milliseconds(const milliseconds&amp; rhs);
   ~milliseconds();

   //conversions
   operator nanoseconds() const;
   operator microseconds() const;

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef 'implementation-defined' tick_type;

   //+ common functions
};
</pre></blockquote>
<p>
        Class milliseconds represents a count of milliseconds.
      </p><pre class="programlisting">
<span class="identifier">milliseconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of milliseconds - default
        is zero.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">milliseconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">milliseconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Copy construction.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><p>
        <span class="strikethrough">~milliseconds();</span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Effects: Destruct count.</em></span></span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Throws: Nothing</em></span></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: millisecond count converted to nanoseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: millisecond count converted to microseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 1000</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 0</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: true</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_seconds"></a>class seconds</h3></div></div></div>


<blockquote><pre>
class  seconds 
{ 
 public:
   seconds(long long s=0);
   seconds(const seconds&amp; rhs);
   ~seconds();

   //conversions
   operator nanoseconds() const
   operator microseconds() const
   operator milliseconds() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef 'implementation-defined' tick_type;

   //+ common functions

};
</pre></blockquote>
<p>
        Class seconds represents a count of seconds.
      </p><pre class="programlisting">
<span class="identifier">seconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of seconds - default is
        zero.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">seconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">seconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Copy construction.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><p>
        <span class="strikethrough">~seconds(); </span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Effects: Destruct count.</em></span></span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Throws: Nothing</em></span></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: second count converted to nanoseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: second count converted to microseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">milliseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: second count converted to milliseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 1</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 1</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: false</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_minutes"></a>class minutes</h3></div></div></div>



<blockquote><pre>
class  minutes 
{
 public:
   minutes(long long s=0);
   minutes(const minutes&amp; rhs);
   ~minutes();

   //conversions
   operator nanoseconds() const
   operator microseconds() const
   operator milliseconds() const
   operator seconds() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef 'implementation-defined' tick_type;

   //+ common functions

};
</pre></blockquote>
<p>
        Class minutes represents a count of minutes.
      </p><pre class="programlisting">
<span class="identifier">minutes</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of minutes - default is
        zero.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">minutes</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">minutes</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Copy construction.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><p>
        <span class="strikethrough">~minutes(); </span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Effects: Destruct count.</em></span></span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Throws: Nothing</em></span></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: minute count converted to nanoseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: minute count converted to microseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">milliseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: minute count converted to milliseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">seconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: minute count converted to seconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 0</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 60</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: false</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_hours"></a>class hours</h3></div></div></div>


<blockquote><pre>
class  hours 
{
 public:
   hours(long long s=0);
   hours(const hours&amp; rhs);
   ~hours();

   //conversions
   operator nanoseconds() const
   operator microseconds() const
   operator milliseconds() const
   operator seconds() const
   operator minutes() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef 'implementation-defined' tick_type;

   //+ common functions

};
</pre></blockquote>


<p>
        Class hours represents a count of hours.
      </p><pre class="programlisting">
<span class="identifier">hours</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of hours - default is zero.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="identifier">hours</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">hours</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <span class="emphasis"><em>Effects: Copy construction.</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><p>
        <span class="strikethrough">~hours(); </span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Effects: Destruct count.</em></span></span>
      </p><p>
        <span class="strikethrough"><span class="emphasis"><em>Throws: Nothing</em></span></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: hour count converted to nanoseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: hour count converted to microseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">milliseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: hour count converted to milliseconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">seconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: hour count converted to seconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">minutes</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <span class="emphasis"><em>Returns: hour count converted to seconds</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 0</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: 3600</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <span class="emphasis"><em>Returns: false</em></span>
      </p><p>
        <span class="emphasis"><em>Throws: Nothing</em></span>
      </p>



<h2><a name="References">References</a></h2>
<ul>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1682.html">
  N1682</a>, A Multi-threading Library for Standard C++, Pete Becker.</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1815.html">
  N1815</a>, ISO C++ Strategic Plan for Multithreading, Lawrence Crowl.</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1883.pdf">
  N1883</a>, Preliminary Threading Library Proposal for TR2, Kevlin Henney.</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1907.html">
  N1907</a>, A Multi-threading Library for Standard C++, Revision 1 Pete Becker</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2043.html">
  N2043</a>, Simplifying And Extending Mutex and Scoped Lock Types For C++ 
  Multi-Threading Library, Ion Gazta&ntilde;aga</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2090.html">
  N2090</a>, A Threading API for C++, Peter Dimov</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2094.html">
  N2094</a>, Multithreading API for C++0X - A Layered Approach, Howard Hinnant</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2139.html">
  N2139</a>, Thoughts on a Thread Library for C++, Anthony Williams</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2178.html">
  N2178</a>, Proposed Text for Chapter 30, Thread Support Library, Peter Dimov</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html">
  N2184</a>, Thread Launching for C++0X, Howard Hinnant</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2285.html">
  N2285</a>, A Multi-threading Library for Standard C++, Revision 2, Pete Becker</li>
</ul>


<h2><a name="Acknowledgments"></a>Acknowledgments</h2>

<p>
The overall design of this threading library is based on William Kempf's 
Boost.Thread Library, as refined by literally hundreds of other Boost users and 
contributors. Dinkumware and Metrowerks (now Freescale) implementations of 
Boost.Thread, developed respectively by Pete Becker and Howard Hinnant, created 
further existing practice. Proposals by Pete Becker, Peter Dimov, Ion Gazta&ntilde;aga, 
and Anthony Williams were also influential. Peter, Ion, and Anthony also 
contributed numerous critiques, suggestions, and comments on the current 
proposal, as did other members of an ad hoc threads working group.
</p>

</body>
</html>