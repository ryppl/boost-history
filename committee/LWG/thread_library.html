<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/transitional.dtd">
<html lang="en"><head>


	<meta http-equiv="content-type" content="text/html; charset=utf-8"><title>Thread Working Draft 16</title>
	
	<style type="text/css">
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {background-color:#FFFFA0}
	del {background-color:#FFFFA0}
        .comment        { color: #800000; }
    span.underline
    {
//        text-decoration: underline;
    }

    span.strikethrough
    {
        text-decoration: line-through;
    }
    span.remove
    {
        text-decoration: line-through;
        color: red;
        display: inline;
    }
    span.insert
    {
	background-color:#FFFFA0;
        color: green;
        display: inline;
    }
	</style></head><body>

<address style="text-align: right">
Document number: NXXXX=07-XXXX<br>
<br>
<a href="mailto:hinnant@twcny.rr.com">Howard E. Hinnant</a>, 
<a href="mailto:Lawrence@Crowl.org">Lawrence Crowl</a>,
<a href="mailto:jeff@crystalclearsoftware.com">Jeff Garland</a>,  
<a href="mailto:public@alisdairm.net">Alisdair Meredith</a>,
<a href="mailto:chris@kohlhoff.com">Chris Kohlhoff</a>,
<a href="mailto:dietmar_kuehl@yahoo.com">Dietmar K&uuml;hl</a>,
<a href="mailto:ncm@cantrip.org">Nathan Myers</a>,
<a href="mailto:prem.rao@hp.com">PremAnand M Rao</a>,
<a href="mailto:nick@usenix.org">Nick Stoughton</a>,
<a href="mailto:bdawes@acm.org">Beman Dawes</a>,
<a href="mailto:anthony@justsoftwaresolutions.co.uk">Anthony Williams</a>
<br>
2007-10-11
</address>
<hr>
<h1 style="text-align:center">Multi-threading Library for Standard C++</h1>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#ProposedWording">Proposed Wording</a><ul>
	<li><a href="#ThreadsWording">Threads Proposed Wording</a></li>
	<li><a href="#MutexsLocksWording">Mutexes and Locks Proposed Wording</a></li>
<li><a href="#ConditionVariablesWording">Condition Variables Proposed Wording</a></li>
<li><a href="#DateTime">Date Time Proposed Wording</a></li>
</ul>

</li>
<li><a href="#References">References</a></li>
<li><a href="#Acknowledgments">Acknowledgments</a></li>
</ul>

<h2><a name="Introduction"></a>Introduction</h2>

<p>
This is a revision of 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html">N2320</a>
which removes cancellation/interruption and changes condition variables per the suggestions in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html">N2406</a>.
This is the course of a action requested by the combined LWG/Concurrency working groups
at the Kona meeting.
</p>

<h1><a name="ProposedWording">Proposed wording</a></h1>

<hr>

<h3>20.5 Function objects [function.objects]</h3>

<p>
<i>Modify paragraph 2 as follows:</i>
</p>

<blockquote>
 <p><b>Header <code>functional</code> synopsis</b></p>

 <pre> namespace std {
   ...
   <i>// Hash function specializations</i>
   ...
   <ins class="diff modified">struct hash&lt;std::thread::id&gt;; //should not be in this header file ?</ins>
 }
 </pre>
</blockquote>

<h3>20.5.15 Class template <code>hash</code> [unord.hash]</h3>

<p><i>Modify paragraph 1 as follows:</i>

<blockquote>
<p>The unordered associative containers defined in clause 23.4 use
specializations
of <code>hash</code> as the default hash function. This class template
is only
required to be instantiable for integer types (3.9.1), floating point
types
(3.9.1), pointer types (8.3.1), and <code>std::string</code>,
<code>std::u16string</code>, <code>std::u32string</code>,
<del class="diff modified">and</del>
<code>std::wstring</code><ins class="diff modified">, and
<code>std::thread::id</code></ins>.</p>
</blockquote>

<hr>

<h2>Chapter 30&nbsp;&nbsp; Multi-threading library</h2>

<hr>

<p>
The following subclauses describe components to create and manage threads ([<i>Reference 
to the new section from N2429 to be inserted between 1.9 and 1.10, titled 
&quot;Multi-threaded executions and data races&quot;</i>]), perform mutual exclusion and locking, and communicate 
between threads.</p>

<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="100%">
  <tbody><tr>
    <td align="center" width="50%"><b>Subclause</b></td>
    <td align="center" width="50%"><b>Header(s)</b></td>
  </tr>
  <tr>
    <td width="50%"><a href="#ThreadsWording">Threads</a></td>
    <td width="50%"><code>&lt;thread&gt;</code></td>
  </tr>
  <tr>
    <td width="50%"><a href="#MutexsLocksWording">Mutexs and locks</a></td>
    <td width="50%"><code>&lt;mutex&gt;</code></td>
  </tr>
  <tr>
    <td width="50%"><a href="#ConditionVariablesWording">Condition variables</a></td>
    <td width="50%"><code>&lt;cond_var&gt;</code></td>
  </tr>
</tbody></table>

<p>
Throughout this clause, the names of template parameters are used to express 
type requirements. The requirements for Duration parameters are specified in [<i>reference 
to date-time library clause]</i>. If a parameter is Predicate, <code>operator()</code> 
applied to the actual template argument shall return a value that is convertible 
to <code>bool</code>.</p>

<p>
Implementations of functions described in this clause are permitted to call 
operating system or other low-level applications program interfaces (API&#39;s). Some functions 
described in this clause are specified to throw exceptions of type <code>system_error</code>
([syserr.syserr]). Such exceptions shall be thrown when one of these operating 
system or other low-level API calls result in an error.</p>

<p>
The <code>error_category</code> ([syserr.errcat.overview]) 
of the <code>error_code</code> reported by such an exception&#39;s <code>code()</code> 
member function is implementation-defined.  [<i>Note:</i> The category is 
typically <code>system_category</code> ([syserr.errcat.overview]) since these error 
codes usually originate from the underlying operating system application program 
interface (API). <i>-- end note</i>]
</p>

<p>Several classes described in this clause have members <code>
native_handle_type</code> and <code>native_handle</code>. The presence of these 
members and their semantics is implementation defined. [<i>Note:</i> These 
members allow implementations to provide access to implementation details. Their 
names are specified to facilitate portable compile-time detection. Actual use of 
these members is inherently non-portable. <i>--end note</i>]</p>

<h3>
<a name="ThreadsWording">Threads</a></h3>

<p>
<b>&lt;thread&gt; synopsis</b>
</p>

<blockquote><pre>namespace std {

class thread;

void swap(thread&amp;  x, thread&amp;  y);
void swap(thread&amp;&amp; x, thread&amp;  y);
void swap(thread&amp;  x, thread&amp;&amp; y);

namespace this_thread
{
    thread::id get_id();
    
    void yield();
    template &lt;class Duration&gt;
        void sleep(const Duration&amp; rel_t);

}  // this_thread

struct once_flag
{
    constexpr once_flag();

    once_flag(const once_flag&amp;) = delete;
    once_flag&amp; operator=(const once_flag&amp;) = delete;
};

template&lt;class Callable, class ...Args&gt;
void call_once(once_flag&amp; flag, Callable func, Args&amp;&amp;... args);

}  // std
</pre></blockquote>

<h4>Class thread</h4>

<p>
An object of class <code>thread</code> represents and manages a thread.
It provides a mechanism to create a new thread,
for the current thread to wait for 
completion of a thread, and to perform other operations to manage and query the state of the thread.
</p>

<blockquote><pre>class thread
{
public:
    // <i>types:</i>
    class id;
    typedef <i>implementation-defined</i> native_handle_type; <i>// See [frontmatter]</i>

    // <i>construct/copy/destroy:</i>
    thread();
    template &lt;class F, class ...Args&gt; explicit thread(F f, Args&amp;&amp;... args);
    ~thread();
    thread(const thread&amp;) = delete;
    thread(thread&amp;&amp;);
    thread&amp; operator=(const thread&amp;) = delete;
    thread&amp; operator=(thread&amp;&amp;);

    // <i>members:</i>
    void swap(thread&amp;&amp;);
    bool joinable() const;
    void join();
    void detach();
    id get_id() const;
    native_handle_type native_handle(); <i>// See [frontmatter]</i>

    // <i>static members:</i>
    static unsigned hardware_concurrency();
};
</pre></blockquote>

<p>
Class <code>thread</code> and class <code>thread::id</code> shall be standard-layout 
classes (chapter 9 [class]).  
</p>

<h5><code>thread</code> types</h5>
<h6>Class <code>thread::id</code></h6>
<pre>    class thread::id
    {
    public:
        id();
    };

    bool operator==(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
    bool operator!=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
    bool operator&lt;(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
    bool operator&lt;=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
    bool operator&gt;(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
    bool operator&gt;=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);

    template&lt;class charT, class traits&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, const thread::id&amp; id);

</pre>
<p> Objects of type <code>thread::id</code> represent the identity of threads. Each 
joinable thread has a unique identity. All non-joinable threads share the same 
identity, and this identify is different from that of any joinable thread.</p>

<p>
[<i>Note:</i> Relational operators allows <code>thread::id</code> objects to be used as keys in associative containers.<i> --end note</i>]
</p>

<blockquote><pre>id();
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>id</code>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
<p>
<i>Postcondition:</i> Represents the non-joinable identity.</p>
</blockquote>
</blockquote>

<blockquote><pre>bool operator==(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
</pre>

<blockquote>
<p>
<i>Returns:</i> If
<code><i>x</i></code> and <code><i>y</i></code> represent the same identity,
returns <code>true</code>.  Otherwise returns <code>false</code>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>bool operator!=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(<i>x</i> == <i>y</i>)</code>
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>


<blockquote>
<pre>bool operator&lt;(const thread::id&amp; x, const thread::id&amp; y);
</pre>

<blockquote>
<p>
<i>Returns:</i> a value such that <code>operator&lt;</code> is a total ordering as described in [alg.sorting].
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool operator&lt;=(const thread::id&amp; x, const thread::id&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code> </p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool operator&gt;(const thread::id&amp; x, const thread::id&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code> </p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool operator&gt;=(const thread::id&amp; x, const thread::id&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code> </p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>template&lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, const thread::id&amp; id);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of the <code>thread::id</code> into
the stream <code>out</code>.
</p>
<p>
<i>Returns:</i> <code>out</code>.
</p>
</blockquote>
</blockquote>

<h5><code>thread</code> constructors</h5>
<blockquote>
<pre>thread();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs a <code>thread</code> object that does not represent an 
actual thread.
</p>
<p>
<i>Postconditions:</i>
</p>
<blockquote><pre>get_id() == thread::id()
&amp;&amp; joinable() == false
</pre>
<p>
[<i>Note:</i> This is also the state of a <code>thread</code>
object after <code>detach</code> or <code>join</code> is successfully called. <i>-- end note</i>]</p>
</blockquote>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>template &lt;class F, class ...Args&gt; explicit thread(F f, Args&amp;&amp;... args);
</pre>

<blockquote>
<p>
<i>Requires:</i>  <code>F</code> is a callable type [func.def].  If <code>f</code> is an lvalue, <code>F</code> 
is <code>CopyConstructible</code>.
If <code>f</code> is an rvalue, <code>F</code> is <code>MoveConstructible</code>.
<b>[Crowl: Is this enforced by code?]</b>
</p>
<p>
<i>Effects:</i> Constructs an object of type <code>thread</code> and executes <code><i>INVOKE</i>(f, t1, t2, ..., tN)</code> 
in a new thread, where <code>t1, t2, 
..., tN</code> are the values in <code>args...</code>.
Any return value from <code>f</code> is ignored.
If <code>f</code> terminates with an uncaught
exception, <code>std::terminate()</code> shall be called.
</p>
<p>
<i>Postconditions:</i>
</p>
<blockquote><pre>get_id() != thread::id()
&amp;&amp; joinable() == true
</pre>
<p><code>*this</code> represents the newly started thread.</p>
</blockquote>
<p>
<i>Throws:</i> <code>system_error</code> if unable to  start the new thread.
</p>
</blockquote>
</blockquote>

<blockquote><pre>thread(thread&amp;&amp; <i>x</i>);
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>thread</code> from <code><i>x</i></code>.  
</p>
<p>
<i>Postconditions:</i>  <code><i>x</i>.joinable()</code> is <code>false</code>. 
<code><i>x</i>.get_id() == thread().get_id()</code>. <code>joinable()</code>
returns the value of <code><i>x</i>.joinable()</code> prior to the start of construction.
<code>get_id()</code> returns the value of <code><i>x</i>.get_id()</code> prior to the 
start of construction.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h5><code>thread</code> destructor</h5>
<blockquote><pre>~thread();
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>joinable()</code> then <code>detach()</code>,
otherwise no effects.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h5><code>thread</code> assignment</h5>
<blockquote><pre>thread&amp; operator=(thread&amp;&amp; <i>x</i>);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>this</code> currently represents a <code>joinable</code> thread object, calls
<code>detach()</code>.  Then assigns the state of <code><i>x</i></code> to <code>*this</code>
and sets <code><i>x</i></code> to a default constructed state.
</p>
<p>
<i>Postconditions:</i>  <code><i>x</i>.joinable()</code> is <code>false</code>. 
<code><i>x</i>.get_id() == thread().get_id()</code>. <code>joinable()</code> returns the 
value of <code><i>x</i>.joinable()</code> prior to the
assignment.
<code>get_id()</code> returns the value of <code><i>x</i>.get_id()</code> prior to the
assignment.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h5><code>thread</code> members</h5>
<blockquote><pre>void swap(thread&amp;&amp; <i>x</i>);
</pre>

<blockquote>
<p>
<i>Effects:</i> Swaps the state of <code>*this</code> and <code><i>x</i></code>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>bool joinable() const;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>get_id() != id()</code>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>void join();
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <code>joinable()</code> is <code>true</code>.
</p>
<p>
<i>Effects:</i> The current thread blocks until the thread 
represented by <code>*this</code> completes.
<b>[Crowl: I.e. upon completion the thread does on a release
on a memory location that the joiner does an acquire on.
I.e. there is a happens before relationship.]</b>
</p>
<p>
<i>Postconditions:</i> After a normal return of <code>join()</code>,
<code>joinable()</code> is <code>false</code>. If <code>join()</code> throws an exception, the thread represented by
<code>*this</code> remains <code>joinable</code>.
</p>

<p>
<i>Throws:</i> <code>system_error</code> when an error condition occurs. The 
possible error conditions are implementation defined.&nbsp;
</p>
</blockquote>
</blockquote>

<blockquote><pre>void detach();
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <code>joinable()</code> is <code>true</code>.
</p>
<p>
<i>Effects:</i> The thread represented by
<code>*this</code> continues execution.  When the thread represented by
<code>*this</code> ends execution it shall release any owned resources.
<b>[Crowl: The programmer shall or the implementation shall?
Which resources?]</b>
</p>
<p>
<i>Postconditions:</i> <code>joinable()</code> is <code>false</code>. <code>*this</code> 
does not represent a thread.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>id get_id() const;
</pre>

<blockquote>
<p>
<i>Returns:</i>
<code>this_thread::get_id()f</code>or the thread 
represented by
<code>*this.</code></p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h5><code>thread</code> static members</h5>
<blockquote><pre>unsigned hardware_concurrency();
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of threads that can reasonably be expected to
execute concurrently. <i>[Note:</i> This value should only be considered to be a hint.
<i>--end note]</i> If this value is not computable or well defined a
return value of 1 is recommended, but not required.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h5><code>thread</code> specialized algorithms</h5>
<blockquote>
<pre>void swap(thread&amp;  x, thread&amp;  y);
void swap(thread&amp;&amp; x, thread&amp;  y);
void swap(thread&amp;  x, thread&amp;&amp; y);
</pre>
<blockquote>
<p>
<i>Effects:</i> <code>x.swap(y)</code>.
</p>
</blockquote>
</blockquote>



<h4>Namespace <code>this_thread</code></h4>

<blockquote><pre>namespace this_thread
{
    thread::id get_id();
    
    void yield();
    template &lt;class Duration&gt;
        void sleep(const Duration&amp; rel_t);

}  // this_thread
</pre></blockquote>

<blockquote><pre>thread::id this_thread::get_id();
</pre>

<blockquote>
<p>
<i>Returns:</i> If the current thread is joinable, returns an object of type <code>thread::id</code> that uniquely identifies the current thread 
and does not compare equal to a default constructed <code>thread::id</code>, else returns 
a default constructed <code>thread::id</code></p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>void yield();
</pre>

<blockquote>
<p>
<i>Effects:</i>  Offers the operating system the opportunity to schedule another thread.</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>template &lt;class Duration&gt;
    void sleep(const Duration&amp; rel_t);
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>Duration</code> shall be explicitly convertible to <code>nanoseconds</code>.
</p>
<p>
<i>Effects:</i>  The current thread blocks for at least the amount of time specified.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4><code>struct once_flag</code></h4>

<blockquote>

<p>Objects of class <code>once_flag</code> are opaque data structures that allow
<code>call_once</code> to initialize data without causing a data race or 
deadlock.</p>

<pre>constexpr once_flag();</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs a object of type
<code>once_flag</code>.</p>
<p>
<i>Postcondition:</i> Internal state is set to indicate to an invocation 
of <code>call_once</code> with this <code>once_flag</code> as its initial 
argument that no function has been called.</p>
</blockquote>
</blockquote>


<h4><code>non-member function call_once</code></h4>

<blockquote>

<pre>template&lt;class Callable, class Args...&gt;
void call_once(once_flag&amp; flag, Callable func, Args&amp;&amp;... args);
</pre>

    <blockquote>

    <p><i>Requires:</i> If <code>func</code> is an lvalue, Callable 
    is
    <code>CopyConstructible</code>. If <code>func</code> is an rvalue, Callable is
    <code>MoveConstructible</code>. Copying or moving (as appropriate) shall have no side effects, and the effect of calling the
    copy shall be equivalent to calling the original.</p>

    <p><i>Effects:</i> The argument <code>func</code> (or a copy thereof) is called exactly once 
    for the <code>once_flag</code> object specified by <code>flag</code>, as-if by invoking
    <code>func(args)</code>,<code> </code>even if <code>call_once</code> is 
    called multiple times for the same <code>once_flag</code> object. If multiple
    calls to <code>call_once</code> with the same <code>once_flag</code> object 
    occur in separate threads, only one
    thread shall call <code>func</code>, and none shall proceed until the call to <code>func</code> has completed. 
<b>[Crowl: I.e. the return of <code>func</code> happens before
the return of <code>call_once</code>.]</b>
    If the invocation of <code>func</code> results in an exception being thrown, 
    the exception is propagated to the caller and the effects are as-if this 
    invocation of&nbsp;<code>call_once</code> did not occur.</p>

    <p><i>Throws:</i> <code>system_error</code> or any exception propagated from <code>func</code>.</p>

    <p><i>Thread safety:</i> Access to the same <code>once_flag</code> object by 
    calls to <code>call_once</code> from different threads shall 
    not result in a data race or deadlock.
<b>[Crowl: The implementation shall not introduce these.]</b>
</p>

<p>[<i>Examples:</i></p>
<blockquote><pre>std::once_flag flag;

void init();

void f()
{
    std::call_once(flag,init);
}

struct initializer
{
    void operator()();
};

void g()
{
    static std::once_flag flag2;
    std::call_once(flag2,initializer());
}
</pre></blockquote>

<p><i>-- end example]</i></p>
</blockquote>
</blockquote>

<h3>
<a name="MutexsLocksWording">Mutexs and locks</a></h3>

<p>
<b>&lt;mutex&gt; synopsis</b>
</p>

<blockquote><pre>namespace std {

struct mutex;
struct recursive_mutex;
struct timed_mutex;
struct recursive_timed_mutex;

struct defer_lock_t;
struct try_to_lock_t;
struct adopt_lock_t;

extern const defer_lock_t  defer_lock;
extern const try_to_lock_t try_to_lock;
extern const adopt_lock_t  adopt_lock;

class lock_error;

template &lt;class Mutex&gt; class lock_guard;
template &lt;class Mutex&gt; class unique_lock;

template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);

template &lt;class L1, class L2, class ...L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
template &lt;class L1, class L2, class ...L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);

}  // std
</pre></blockquote>

<h3>Mutex concepts</h3>

<p>
Mutex objects provide synchronization operations to avoid data races. A
mutex object supports mutual exclusion between threads by
limiting its ownership to a single thread.  A thread  obtains ownership of a mutex object by calling <code>lock()</code>
and relinquishes ownership by calling <code>unlock()</code>.  The 
thread that calls <code>lock()</code> for a mutex object shall
call <code>unlock()</code>.  Mutexes may be either recursive or
non-recursive.  The syntax is the same for both recursive and
non-recursive mutexes, but the semantics differ for the member functions
as described below.
</p>

<p>
A mutex type shall be <code>DefaultConstructible</code> and <code>Destructible</code>.  If initialization
of a mutex type fails, an exception of type <code>system_error</code> shall be thrown.  
A mutex type is neither copyable
nor movable.  A mutex type shall have the following member functions:
</p>

<blockquote>
<pre>void lock();
</pre>
<blockquote>
<p>
<i>Precondition:</i> For non-recursive mutexes the current thread shall not own the mutex.
</p>
<p>
<i>Effects:</i> The current thread will block until the mutex is not owned by another thread.
<b>[Crowl: I.e. happens before?]</b>
Upon successful completion, the current thread owns the mutex.
</p>
<p>
<i>Throws:</i> <code>system_error</code> when an error condition occurs. The 
possible error conditions are implementation defined.</p>
<p>
<i>Thread safety:</i> This is an acquire operation.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool try_lock();
</pre>
<blockquote>
<p>
<i>Precondition:</i> For non-recursive mutexes the current thread shall not own the mutex.
</p>
<p>
<i>Effects:</i>
If ownership can be obtained without blocking,
then an attempt is made to obtain ownership.
If ownership is not obtained,
there is no effect and <code>try_lock()</code> immediately returns.
[<i>Note:</i> It is expected that <code>try_lock()</code> almost
always obtains ownership if the lock is available,
but it is not guaranteed that it always does so.
Since a failed <code>try_lock()</code> is not an acquire operation [1.10],
the resulting memory visibility rules are weak enough
that they would render such a guarantee essentially useless.
And such a guarantee would preclude potentially interesting
<code>try_lock()</code> implementations based on <code>compare_swap</code>.
&mdash; <i>end note</i>]

</p>
<p>
<i>Returns:</i> <code>true</code> if ownership was obtained, otherwise <code>false</code>.
</p>
<p>
<i>Thread safety:</i>  This is an acquire operation if <code>try_lock</code> returns <code>true</code>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void unlock();
</pre>
<blockquote>
<p>
<i>Precondition:</i> The current thread shall own the mutex.
</p>
<p>
<i>Effects:</i> For a non-recursive mutex ownership is released.  For a recursive mutex
<code>unlock()</code> must be called the same number of times which the mutex was locked
(via either <code>lock()</code> or <code>try_lock()</code> or by any other locking function) before ownership is released.
</p>
<p>
<i>Thread safety:</i>  This is a release operation.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4>Class mutex</h4>

<blockquote><pre>namespace std {

struct mutex
{
public:
    mutex();
    ~mutex();

    mutex(const mutex&amp;) = delete;
    mutex&amp; operator=(const mutex&amp;) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</pre></blockquote>

<p>
The class <code>mutex</code> provides a non-recursive mutex type which satisfies all of the Mutex requirements.
It shall be a standard-layout class (chapter 9 [class]).
</p>

<h4>Class recursive_mutex</h4>

<blockquote><pre>namespace std {

struct recursive_mutex
{
public:
    recursive_mutex();
    ~recursive_mutex();

    recursive_mutex(const recursive_mutex&amp;) = delete;
    recursive_mutex&amp; operator=(const recursive_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</pre></blockquote>

<p>
The class <code>recursive_mutex</code> provides a recursive mutex type which satisfies all of the Mutex requirements.
It shall be a standard-layout class (chapter 9 [class]).
</p>

<h3>Timed Mutex concept</h3>

<p>
To meet the requirements of the Timed Mutex concept, types are required to meet the requirements of the Mutex concept 
and to provide the member function <code>timed_lock</code>.</p>

<blockquote>
<pre>template &lt;class Duration&gt;
    bool timed_lock(const Duration&amp; rel_time);
</pre>
<blockquote>
<p>
<i>Precondition:</i> For non-recursive mutexes the current thread shall not own 
the mutex. .
<b>[Crowl: Roundup here instead of under various locks.]</b>
</p>
<p>
<i>Effects:</i>
The function attempts to obtain ownership of the mutex
within the specified time.
If the indicated time is less than or equal to <code>0</code>,
the function still attempts to obtain ownership without
blocking (as if by calling <code>try_lock()</code>).
If the function returns within the specified time duration,
it shall have obtained ownership.
[<i>Note:</i>
As with <code>try_lock()</code>,
there is no guarantee that ownership will be obtained
if the lock is available,
but implementations are expected to make a strong effort to do so.
&mdash; <i>end note</i>]
</p>
<p>
<i>Returns:</i> <code>true</code> if ownership was obtained, otherwise <code>false</code>.
</p>
<p>
<i>Thread safety:</i>  This is a synchronization operation.
<b>[Crowl: on the memory locations of the lock.]</b>
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4>Class timed_mutex</h4>

<blockquote><pre>namespace std {

struct timed_mutex
{
public:
    timed_mutex();
    ~timed_mutex();

    timed_mutex(const timed_mutex&amp;) = delete;
    timed_mutex&amp; operator=(const timed_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    template &lt;class Duration&gt;
        bool timed_lock(const Duration&amp; rel_time);
    void unlock();

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</pre></blockquote>

<p>
The class <code>timed_mutex</code> provides a non-recursive mutex type that satisfies all of the Timed Mutex requirements.
It shall be a standard-layout class (chapter 9 [class]).
</p>

<h4>Class recursive_timed_mutex</h4>

<blockquote><pre>namespace std {

struct recursive_timed_mutex
{
public:
    recursive_timed_mutex();
    ~recursive_timed_mutex();

    recursive_timed_mutex(const recursive_timed_mutex&amp;) = delete;
    recursive_timed_mutex&amp; operator=(const recursive_timed_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    template &lt;class Duration&gt;
        bool timed_lock(const Duration&amp; rel_time);
    void unlock();

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</pre></blockquote>

<p>
The class <code>recursive_timed_mutex</code> provides a recursive mutex type that satisfies all of the Timed Mutex requirements.
It shall be a standard-layout class (chapter 9 [class]).
</p>

<h3>Locks</h3>

<p>
Locks are objects that hold a reference to a mutex and unlock the mutex during the lock's destruction
(such as when leaving block scope).  The locks do not manage the lifetime of the mutex they
reference, but only the ownership status of that mutex.  <i>[Note: </i>Locks are intended to ease the burden
of unlocking the mutex under both normal and exceptional circumstances.<i> --end 
note]</i></p>

<p>
Some locks may take tag types which describe what should be done with the mutex in the lock's
constructor.
</p>

<blockquote><pre>struct defer_lock_t  {};
struct try_to_lock_t {};
struct adopt_lock_t  {};

extern const defer_lock_t   defer_lock;
extern const try_to_lock_t  try_to_lock;
extern const adopt_lock_t   adopt_lock;
</pre></blockquote>

<p>
An exception class <code>lock_error</code> derives from <code>exception</code> and is used to indicate
improper usage of locks such as locking a mutex that the lock already owns, or unlocking a mutex
that the lock does not own.
</p>

<blockquote><pre>class lock_error
    : public std::exception
{
public:
    virtual const char* what() const throw();
};
</pre></blockquote>

<h4>Class lock_guard</h4>

<blockquote><pre>namespace std {

template &lt;class Mutex&gt;
class lock_guard
{
public:
    typedef Mutex mutex_type;

    explicit lock_guard(mutex_type&amp; m);
    lock_guard(mutex_type&amp; m, adopt_lock_t);
    ~lock_guard();

    lock_guard(lock_guard const&amp;) = delete;
    lock_guard&amp; operator=(lock_guard const&amp;) = delete;
};

}  // std
</pre></blockquote>

<p>
<code>lock_guard</code> is used to control the ownership of a mutex within a single scope.
An invariant of the <code>lock_guard</code> object is that it maintains the ownership of the
mutex throughout the <code>lock_guard</code>'s lifetime.  Mutex ownership can not be deferred
or transferred away from the <code>lock_guard</code>.
</p>

<blockquote>
<pre>explicit lock_guard(mutex_type&amp; m);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <code>mutex_type</code> is not a recursive mutex,  the current thread
does not own the mutex.  The lifetime of <code><i>m</i></code> includes the lifetime
of the <code>lock_guard</code> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <code><i>m</i></code> and calls <code><i>m</i>.lock()</code>.
<b>[Crowl: An acquire specification is not necessary because of m.lock().]</b>
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>lock_guard(mutex_type&amp; m, adopt_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> The current thread has ownership of the mutex <code><i>m</i></code>.
The lifetime of <code><i>m</i></code> includes the lifetime of the <code>
lock_guard</code> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <code><i>m</i></code> and performs no other operation on it.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>~lock_guard();
</pre>
<blockquote>
<p>
<i>Effects:</i> <code><i>m</i>.unlock()</code>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4>Class unique_lock</h4>

<blockquote><pre>namespace std {

template &lt;class Mutex&gt;
class unique_lock
{
public:
    typedef Mutex mutex_type;

    unique_lock();
    explicit unique_lock(mutex_type&amp; m);
    unique_lock(mutex_type&amp; m, defer_lock_t);
    unique_lock(mutex_type&amp; m, try_to_lock_t);
    unique_lock(mutex_type&amp; m, adopt_lock_t);
    ~unique_lock();

    unique_lock(unique_lock const&amp;) = delete;
    unique_lock&amp; operator=(unique_lock const&amp;) = delete;

    unique_lock(unique_lock&amp;&amp; u);
    unique_lock&amp; operator=(unique_lock&amp;&amp; u);

    void lock();
    bool try_lock();

    template &lt;class Duration&gt;
        bool timed_lock(const Duration&amp; rel_t);
    bool timed_lock(const system_time&amp; abs_time);

    void unlock();

    bool owns_lock() const;
    operator <var>unspecified-bool-type</var> () const;
    mutex_type* mutex() const;

    void swap(unique_lock&amp;&amp; u);
    mutex_type* release();
};

template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);

}  // std
</pre></blockquote>

<p>
<code>unique_lock</code> is used to control the ownership of a mutex within one or more scopes.
Mutex ownership can be deferred or transferred away from the <code>unique_lock</code>. 
An object of type
<code>unique_lock</code> is not copyable but is movable.
</p>

<blockquote>
<pre>unique_lock();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>unique_lock</code>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == 0
owns_lock() == false
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>explicit unique_lock(mutex_type&amp; m);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <code>mutex_type</code> is not a recursive mutex,  the current thread
does not own the mutex.  The lifetime of <code><i>m</i></code> includes the lifetime
of the <code>unique_lock</code> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <code><i>m</i></code> and calls <code><i>m</i>.lock()</code>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns_lock() == true
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(mutex_type&amp; m, defer_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <code>mutex_type</code> is not a recursive mutex,  the current thread
does not own the mutex. 
The lifetime of <code><i>m</i></code> includes the lifetime of the <code>
unique_lock</code> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <code><i>m</i></code> and performs no other operation on it.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns_lock() == false
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(mutex_type&amp; m, try_to_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <code>mutex_type</code> is not a recursive mutex, then the current thread
does not own the mutex. 
The lifetime of <code><i>m</i></code> includes the lifetime of the <code>
unique_lock</code> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <code><i>m</i></code> and calls <code><i>m</i>.try_lock()</code>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns_lock() == <i>The result of the call to</i> <i>m</i>.try_lock()
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(mutex_type&amp; m, adopt_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> The current thread has ownership of the mutex <code><i>m</i></code>. 
The lifetime of <code><i>m</i></code> includes the lifetime of the <code>
unique_lock</code> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <code><i>m</i></code> and performs no other operation on it.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns_lock() == true
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>~unique_lock();
</pre>
<blockquote>
<p>
<i>Effects:</i> If <code>owns_lock()</code> calls <code>unlock()</code> on the referenced mutex.
Otherwise there are no effects.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(unique_lock&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i> Transfers mutex ownership (if any) from <code>u</code> to <code>this</code>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == <i>The value of</i> u.mutex() <i>prior to the construction</i>.
owns_lock() == <i>The value of</i> u.owns_lock() <i>prior to the construction</i>.
u.mutex() == 0
u.owns_lock() == false
</pre></blockquote>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock&amp; operator=(unique_lock&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i>  If <code>owns_lock()</code> calls <code>unlock()</code>, and then
transfers mutex ownership (if any) from <code>u</code> to <code>this</code>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == <i>The value of</i> u.mutex() <i>prior to the construction</i>.
owns_lock() == <i>The value of</i> u.owns_lock() <i>prior to the construction</i>.
u.mutex() == 0
u.owns_lock() == false
</pre></blockquote>
<p>
<i>Throws:</i> Nothing.
</p>
<p>
<i>Note:</i> With a recursive mutex it is possible that both
<code>this</code> and <code>u</code> own the same mutex before the assignment.
In this case, <code>this</code> will own the mutex after the assignment (and
<code>u</code> will not), but the mutex's lock count will be decremented by
one.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void lock();
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <code>lock()</code> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <code>owns_lock() == true</code>.
</p>
<p>
<i>Throws:</i> <code>lock_error</code>, if on entry <code>owns_lock()</code> is <code>true</code>.</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool try_lock();
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <code>try_lock()</code> on the referenced mutex.
</p>
<p>
<i>Returns:</i>  The result of the call to <code>try_lock()</code> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <code>owns_lock() == </code>The result of the call to <code>try_lock()</code> on the referenced mutex.
</p>
<p>
<i>Throws:</i> <code>lock_error</code>, if on entry <code>owns_lock()</code> is <code>true</code>.<code> </code>
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Duration&gt;
   bool timed_lock(const Duration&amp; rel_t);
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <code>timed_lock(rel_t)</code> on the referenced mutex. 
		 If the resolution of Duration is greater <b>[Crowl: less]</b> than the native 
                 resolution the time is rounded up to the nearest native resolution.
</p>
<p>
<i>Returns:</i>  The result of the call to <code>timed_lock(rel_t)</code> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <code>owns_lock() == </code>The result of the call to <code>timed_lock(rel_t)</code> on the referenced mutex.
</p>
<p>
<i>Throws:</i> <code>lock_error</code>, if on entry <code>owns_lock()</code> is <code>true</code>.</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void unlock();
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <code>unlock()</code> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <code>owns_lock() == false</code>.
</p>
<p>
<i>Throws:</i> <code>lock_error</code>, if on entry <code>owns_lock()</code> is <code>false</code>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool owns_lock() const;
</pre>
<blockquote>
<p>
<i>Returns:</i>  <code>true</code> if <code>this</code> owns a lock on a referenced mutex, else <code>false</code>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>operator <var>unspecified-bool-type</var> () const;
</pre>
<blockquote>
<p>
<i>Returns:</i>  Non-null if <code>owns_lock()</code> would return <code>true</code>, else returns null.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>mutex_type* mutex() const;
</pre>
<blockquote>
<p>
<i>Returns:</i>  A pointer to the referenced mutex, or null if there is no referenced mutex.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void swap(unique_lock&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i>  Swaps state with <code>u</code>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>mutex_type* release();
</pre>
<blockquote>
<p>
<i>Returns:</i>  A pointer to the referenced mutex, or null if there is no referenced mutex.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == 0
owns_lock() == false
</pre></blockquote>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);
</pre>
<blockquote>
<p>
<i>Effects:</i>  <code>x.swap(y)</code>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h3>Generic Locking Algorithms</h3>

<blockquote>
<pre>template &lt;class L1, class L2, class ...L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
<p>
<i>Requires:</i>  Each template parameter type must supply the following member functions with semantics
corresponding to the Mutex concept, except that <code>try_lock</code> is allowed to throw an
exception. <i>[Note:</i> The <code>unique_lock</code> class template meets these requirements 
when suitable instantiated. <i>--end note]</i></p>
<blockquote><pre>bool try_lock();
void unlock();
</pre></blockquote>
<p>
<i>Effects:</i> The functions attempts to lock all arguments without blocking by calling <code>try_lock()</code>
on each of them.  If any argument can not be locked, then all arguments which have already been locked will
be unlocked.  On return, either all arguments will be locked, or none of them will be locked.  If an
exception is thrown by a call to <code>try_lock()</code>, there are no effects.
</p>
<p>
<i>Returns:</i> If all arguments were successfully locked, returns <code>-1</code>.  Otherwise returns a 0-based index 
value indicating
which argument failed to lock.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class L1, class L2, class ...L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
<p>
<i>Requires:</i>  Each template parameter type must supply the following member functions with semantics
corresponding to the Mutex concept, except that <code>try_lock</code> is allowed to 
throw an exception <i>[Note:</i> The <code>unique_lock</code> class template meets these requirements 
when suitable instantiated. <i>--end note]</i></p>
<blockquote><pre>void lock();
bool try_lock();
void unlock();
</pre></blockquote>
<p>
<i>Effects:</i> All arguments are locked with an algorithm that avoids deadlock.
If an exception is thrown by a call to <code>lock()</code> or <code>try_lock()</code>, there are no effects.
</p>
</blockquote>
</blockquote>

<h3><a name="ConditionVariablesWording">Condition variables</a></h3>

<p><b>&lt;condition_variable&gt; synopsis</b></p>

<blockquote><pre>namespace std {

class condition_variable;
class condition_variable_any;

}  // std
</pre></blockquote>

<h4>Class condition_variable</h4>

<p>
An object of class <code>condition_variable</code> is a synchronization primitive 
used to cause a thread to wait until notified by some other 
thread that some condition is met, or a UTC[(?)] time is reached.
</p>

<blockquote><pre>namespace std {

class condition_variable
{
public:
    
    condition_variable();
    ~condition_variable();

    condition_variable(const condition_variable&amp;) = delete;
    condition_variable&amp; operator=(const condition_variable&amp;) = delete;

    void notify_one();
    void notify_all();
    void wait(unique_lock&lt;mutex&gt;&amp; lock);
    template &lt;class Predicate&gt;
        void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
    bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time);
    template &lt;class Predicate&gt;
        bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time, Predicate pred);

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</pre></blockquote>

<blockquote>
<pre>condition_variable();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <code>condition_variable</code>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>~condition_variable();
</pre>
<blockquote>
<p>
<i>Effects:</i> Destroys the object.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_one();
</pre>
<blockquote>
<p>
<i>Effects:</i> If any threads are blocked waiting for <code>*this</code>, 
unblocks at least one those threads.
<b>[Crowl: Is any lock released?]</b></p>
<p><b>[Crowl: Needs to say release operation.]</b>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <code>condition_variable</code>
object from different threads shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_all();
</pre>
<blockquote>
<p>
<i>Effects:</i> Unblock all threads that are blocked waiting for <code>*this</code>.
<b>[Crowl: Needs to say release operation.]</b>
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <code>condition_variable</code>
object from different threads shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
<p>
<i>Precondition:</i> <code>lock</code> is locked by the current thread.  No
other thread is waiting on this <code>condition_variable</code> object unless <code>lock</code>
refers to the same underlying <code>mutex</code> object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<code>lock</code>. If the <code>wait</code> throws an exception, <code>lock</code> will be 
locked as the exception propagates. The current thread may
unblock and return even in the absence of a notification.
<b>[Crowl: Needs to say acquire operation.]</b>
</p>
<p>
<i>Postcondition:</i> <code>lock</code> is locked by the current 
thread.</p>
<p>
<i>Throws:</i> <span style="font-style: italic; background-color: #FFFF00">??? 
See issue 26</span></p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <code>condition_variable</code>
object from different threads shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Predicate&gt;
    void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> While <code>pred()</code> returns <code>false</code> calls <code>wait(lock)</code>.
</p>
<p>
<i>[Note:</i> Does not block if <code>pred()</code> is initially <code>true</code>. <i>
--end note</i>]</p>
</blockquote>
</blockquote>


<blockquote>
<pre>bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time);
</pre>
<blockquote>
<p>
<i>Precondition:</i>  The <code>lock</code> is locked by the current thread.  No
other thread is waiting on this <code>condition_variable</code> object unless <code>lock</code>
refers to, the same underlying <code>mutex</code> object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<code>lock</code>. If the <code>timed_wait</code> should throw an exception for
any reason, <code>lock</code> will be locked as the exception propagates
out.  If the absolute time specified by <code>abs_time</code> passes (that
is, system time equals or exceeds <code>abs_time</code>) before the
<code>condition_variable</code> is notified, or if the absolute time specified by
<code>abs_time</code> has already been passed at the time of the call, then
<code>false</code> is returned. This thread shall unblock when
another thread  issues a notification to this blocked thread. The current
thread may unblock and return even in the absence of a
notification.
</p>
<p>
<i>Postcondition:</i> <code>lock</code> is locked by the current 
thread.</p>
<p>
<i>Returns:</i> <code>true</code> if the call to <code>timed_wait</code> is notified prior
to the indicated timeout,
otherwise returns <code>false</code>.
</p>
<p>
<i>Throws:</i> <span style="font-style: italic; background-color: #FFFF00">??? 
See issue 26</span></p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <code>condition_variable</code>
object from different threads shall not result in data
races or deadlocks.
<b>[Crowl: Needs to say acquire operation.
Too much about other operations here.]</b>
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Predicate&gt;
    bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> As if:
</p>
<blockquote><pre>while (!pred())
{
    if (!timed_wait(lock, abs_time))
        return pred();
}
return true;
</pre></blockquote>
<p>
<i>Returns:</i> <code>pred()</code>.
</p>
<p>
<i>Note:</i> There is no blocking if <code>pred()</code> is initially <code>true</code>, even
if the timeout has already expired.  The return value indicates whether the predicate
evaluates to <code>true</code>, regardless of whether the timeout was triggered.
</p>
</blockquote>
</blockquote>


<p>
<code>condition_variable</code> shall be a standard-layout class (chapter 9 [class]).
</p>

<h4>Class condition_variable_any</h4>

<p>
An object of class <code>condition_variable_any</code> is a synchronization primitive 
used to cause a thread to wait until notified by some other 
thread that some condition is met, or a UTC[(?)] time is reached.
</p>

<p>
The <code>Lock</code> type must support member functions <code>lock</code>
and <code>unlock</code> with the semantics of the mutex concept.  All of the standard mutex types
meet this requirement.
</p>

<blockquote><pre>namespace std {

class condition_variable_any
{
public:
    condition_variable_any();
    ~condition_variable_any();

    condition_variable_any(const condition_variable_any&amp;) = delete;
    condition_variable_any&amp; operator=(const condition_variable_any&amp;) = delete;

    void notify_one();
    void notify_all();
    template &lt;class Lock&gt;
        void wait(Lock&amp; lock);
    template &lt;class Lock, class Predicate&gt;
        void wait(Lock&amp; lock, Predicate pred);
    template &lt;class Lock&gt;
        bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time);
    template &lt;class Lock, class Predicate&gt;
        bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time, Predicate pred);

    typedef <i>implemenation-defined</i> native_handle_type;  <i>// See [frontmatter]</i>
    native_handle_type native_handle();      <i>          // See [frontmatter]</i>
};

}  // std
</pre></blockquote>

<blockquote>
<pre>condition_variable_any();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <code>condition_variable_any</code>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>~condition_variable_any();
</pre>
<blockquote>
<p>
<i>Effects:</i> Destroys the object.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_one();
</pre>
<blockquote>
<p>
<i>Effects:</i> If any threads are blocked waiting for <code>*this</code>, 
unblocks at least one those threads.</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <code>condition_variable_any</code>
object from different threads shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_all();
</pre>
<blockquote>
<p>
<i>Effects:</i> Unblock all threads  of execution that are blocked waiting for <code>*this</code>.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <code>condition_variable_any</code>
object from different threads shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void wait(Lock&amp; lock);
</pre>
<blockquote>
<p>
<i>Precondition:</i> <code>lock</code> is locked by the current thread.  If
<code>Lock</code> supports recursive locking, the lock count is one.  No
other thread is waiting on this <code>condition_variable_any</code> object unless <code>lock</code>
is, or refers to, the same underlying mutex object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<code>lock</code>. If the <code>wait</code> should throw an exception for any
reason, <code>lock</code> will be locked as the exception propagates. 
This thread shall unblock when another thread issues a
notification to this blocked thread. The current thread may
unblock and return even in the absence of a notification.
</p>
<p>
<i>Postcondition:</i> <code>lock</code> is locked by the current 
thread.</p>
<p>
<i>Throws:</i> <code>system_error</code> when an error condition occurs. The 
possible error conditions are implementation defined.&nbsp;&nbsp;
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <code>condition_variable_any</code>
object from different threads shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Predicate&gt;
    void wait(lock_type&amp; lock, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> While <code>pred()</code> returns <code>false</code>, calls <code>wait(lock)</code>.
</p>
<p>
<i>Note:</i> There is no blocking if <code>pred()</code> is initially <code>true</code>.
</p>
</blockquote>
</blockquote>


<blockquote>
<pre>bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time);
</pre>
<blockquote>
<p>
<i>Precondition:</i>  The <code>lock</code> is locked by the current thread.  If
<code>Lock</code> supports recursive locking, the lock count is one.  No
other thread is waiting on this <code>condition_variable_any</code> object unless <code>lock</code>
is, or refers to, the same underlying mutex object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<code>lock</code>. If the <code>timed_wait</code> should throw an exception for
any reason, <code>lock</code> will be locked as the exception propagates
out.  If the absolute time specified by <code>abs_time</code> passes (that
is, system time equals or exceeds <code>abs_time</code>) before the
<code>condition_variable_any</code> is notified, or if the absolute time specified by
<code>abs_time</code> has already been passed at the time of the call, then
<code>false</code> is returned. This thread shall unblock when
another thread issues a notification to this blocked thread. The current
thread may unblock and return even in the absence of a
notification.
</p>
<p>
<i>Postcondition:</i> <code>lock</code> is locked by the current 
thread.</p>
<p>
<i>Returns:</i> <code>true</code> if the call to <code>timed_wait</code> is notified prior
to the indicated timeout,
otherwise returns <code>false</code>.
</p>
<p>
<i>Throws:</i> <code>system_error</code> when an error condition occurs. The 
possible error conditions are implementation defined.&nbsp;&nbsp;
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <code>condition_variable_any</code>
object from different threads shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class _Predicate&gt;
    bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> As if:
</p>
<blockquote><pre>while (!pred())
{
    if (!timed_wait(lock, abs_time))
        return pred();
}
return true;
</pre></blockquote>
<p>
<i>Returns:</i> <code>pred()</code>.
</p>
<p>
<i>Note:</i> There is no blocking if <code>pred()</code> is initially <code>true</code>, even
if the timeout has already expired.  The return value indicates whether the predicate
evaluates to <code>true</code>, regardless of whether the timeout was triggered.
</p>
</blockquote>
</blockquote>

<hr>


<h2><a name="DateTime"></a>Chapter ?&nbsp;&nbsp; Date Time Library</h2>

<hr>
<p> This clause describes components for determining and manipulating temporal values.
 A <i>time point</i> represents a dimensionless instant 
 in the time continuum. A <i>time duration</i> represents a length of time 
 unattached to any time point. Time points and time durations have a 
 <i>resolution</i> which is their smallest representable time duration.  Time points
 have an <i>epoch</i> or start of a given time scale. For time_t the epoch is 
 1970-01-01 00:00:00.


 <p>Throughout this clause, the names of template parameters are used to express 
 type requirements. <span style="background-color: #FFFF00">Define Duration, 
 RhsDuration</span></p>


<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.header__date_time__synopsis"></a>
Header &lt;date_time&gt; Synopsis</h3></div></div></div>

<blockquote><pre>namespace std 
{

  //duration types
  class    hours;
  class    minutes;
  class    seconds;
  class    milliseconds;
  class    microseconds;
  class    nanoseconds;

  //timepoint   
  class system_time;

  //functions
  system_time get_system_time();

} //std
</pre></blockquote>

</div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_utc_time"></a>class system_time</h3></div></div></div>


<p>
        The class <code>system_time</code> provides a time point that represents the current
        Coordinated Universal Time, known as UTC, time.
        <code>system_time</code> shall provide an epoch time of 1970-01-01 00:00:00.000000000
        and a maximum time value of at least epoch time + 292 years.
</p><p>
        class <code>system_time</code> shall be EqualityComparable, LessThanComparable, 
        CopyConstructable, DefaultConstructable, and Assignable.
</p>


<blockquote><pre>class system_time 
{
 public:

  system_time();
  system_time(time_t, nanoseconds ns);
  ~system_time();

  time_t seconds_since_epoch() const;
  nanoseconds nanoseconds_since_epoch() const;

  //traits 
  typedef 'implementation defined' tick_type;
  static tick_type ticks_per_second();
  static tick_type seconds_per_tick();
  static bool is_subsecond();

  //comparison functions
  bool operator==(const system_time&amp; rhs) const;
  bool operator!=(const system_time&amp; rhs) const;
  bool operator&gt;(const system_time&amp; rhs) const;
  bool operator&gt;=(const system_time&amp; rhs) const;
  bool operator&lt;(const system_time&amp; rhs) const;
  bool operator&lt;=(const system_time&amp; rhs) const;

  //arithmetic functions
  nanoseconds operator-(const system_time&amp; rhs) const

  template&lt;typename Duration&gt;
  system_time operator+(const Duration&amp; td) const;

  template&lt;typename Duration&gt;
  system_time&amp; operator+=(const Duration&amp; td);

  template&lt;typename Duration&gt;
  system_time operator-(const Duration&amp; td) const;

  template&lt;typename Duration&gt;
  system_time&amp; operator-=(const Duration&amp; td) 

};
</pre></blockquote>

<blockquote class="note">
<p>
<h3 class="title">Note</h3><p>
          292 years represents the number of nanoseconds that can be represented 
         in a signed 64 bit integer.
</p></blockquote>

<pre class="programlisting"><span class="identifier">system_time</span><span class="special">();</span></pre><p>
        <i>Effects:</i> Constructs a system_time
        object representing the epoch time point 1970-01-01 00:00:00.000000000
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">system_time</span><span class="special">(</span><span class="identifier">time_t</span> <span class="identifier">secs</span><span class="special">,</span> <span class="identifier">nanoseconds</span> <span class="identifier">ns</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Construct<span class="underline">s</span> a utc
        time object representing the time point that is secs + 1,000,000,000*ns after the epoch.
      </p><p>
        <i>Remarks:</i> If the total nanoseconds &gt; 1 second the seconds are
        incremented appropriately.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting"><span class="identifier">time_t</span> <span class="identifier">seconds_since_epoch</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> The count of seconds since 1970-01-01 00:00:00.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">nanoseconds</span> <span class="identifier">nanoseconds_since_epoch</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> The count of <span class="underline">nano</span>seconds
        since 1970-01-01 00:00:00.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1000000000
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Remarks:</i> Since this is a subsecond type it returns 0 for seconds_per_tick.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> true.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if 
        the <span class="underline">time
        represented by *this is equal to the time represented by rhs</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if the <span class="underline">time represented by *this is not equal to the time represented
        by rhs</span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if time <span class="underline">represented by
        *this is greater than the time represented by rhs</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;=(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if time <span class="underline">represented
        by *this is greater or equal than the time represented by rhs</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if time <span class="underline">represented by *this
        is less than the time represented by rhs</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;=(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if time <span class="underline">represented by *this
        is less or equal than the time represented by rhs</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">nanoseconds</span> <span class="keyword">operator</span><span class="special">-(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i>  <span class="underline">
        The difference in nanoseconds between the time represented by *this and the
        time represented by rhs.</span>
      </p><p>
        <i>Remarks:</i> If rhs is greater the result will be a negative nanosecond.
        count.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">system_time</span> <span class="keyword">operator</span><span class="special">+(</span><span class="keyword">const</span> <span class="identifier">Duration</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> The duration converted to nanosecond resolution
        and added to the time <span class="underline">represented by *this</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">system_time</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">+=(</span><span class="keyword">const</span> <span class="identifier">Duration</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Convert the duration to nanosecond resolution add to nanoseconds
        to the time represented by *this.
      </p><p>
        <i>Returns:</i> Modified value of this.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">system_time</span> <span class="keyword">operator</span><span class="special">-(</span><span class="keyword">const</span> <span class="identifier">Duration</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> The duration converted to nanosecond resolution
        and subtracted from the time <span class="underline">represented by *this</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">system_time</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">-=(</span><span class="keyword">const</span> <span class="identifier">Duration</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">)</span> 
</pre><p>
        <i>Effects:</i> Convert the duration to nanosecond resolution subtract and
        from the time represented by *this.
      </p><p>
        <i>Returns:</i> Modified value of this.
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>


<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.template_class_hiresolution_clock"></a>function get_system_time</h3></div></div></div>

<p>
        The function <code>get_system_time</code> provides access to the system clock at a
        resolution up to nanoseconds. The actual resolution may vary from platform to platform. 
</p>


<blockquote><pre>  system_time get_system_time();
</pre></blockquote>


<blockquote class="note">
<h3 class="title">Comment (not for inclusion in WP)</h3><p>
    <i>Typical personal computer platforms currently achieve microsecond level
    resolution from calls to the clock. The <a href="http://www.boost.org/libs/date_time/index.html" target="_top">Boost Date-Time Library</a> has a class that portably implements the proposed
    interface, but it uses different C-level interfaces depending on the operating
    system.</i>
        </p></blockquote>
</div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.common_duration_functions"></a>Common Duration Functions</h3></div></div></div>

<p>
        The following functions are common functions to all durations types. These
        functions provide the basis for durations to be EqualityComparable, LessThanComparable
        as well arithmetic operations.
      </p><p>
        In the following text duration_type refers to the containing duration type.
      </p>
<p>
        All duration types are EqualityComparable, LessThanComparable, 
        CopyConstructable, DefaultConstructable, and Assignable for duration
        objects of the same type. 
</p>


<blockquote><pre>class Duration { 

    //comparison operators
    template&lt;typename RhsDuration&gt;
    bool operator&lt;  (const RhsDuration&amp;) const;

    template&lt;typename RhsDuration&gt;
    bool operator&lt;= (const RhsDuration&amp;) const;

    template&lt;typename RhsDuration&gt;
    bool operator&gt;  (const RhsDuration&amp;) const;

    template&lt;typename RhsDuration&gt;
    bool operator&gt;= (const RhsDuration&amp;) const;

    template&lt;typename RhsDuration&gt;
    bool operator== (const RhsDuration&amp;) const;

    template&lt;typename RhsDuration&gt;
    bool operator!= (const RhsDuration&amp;) const;


    //sign inversion
    Duration operator-() const

    //arithmetic operations
    template&lt;typename RhsDuration&gt;
    Duration operator- (const RhsDuration&amp; d) const

    template&lt;typename RhsDuration&gt;
    Duration operator-=(const RhsDuration&amp; d)

    template&lt;typename RhsDuration&gt;
    Duration operator+ (const RhsDuration&amp; d) const

    template&lt;typename RhsDuration&gt;
    Duration operator+=(const RhsDuration&amp; d)

    Duration operator/ (int divisor) const
    Duration operator/=(int divisor) 
    Duration operator* (int rhs) const
    Duration operator*=(int divisor) 

    tick_type get_count() const 

}
</pre></blockquote>
<p>
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">RhsDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if rhs duration is greater.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span><span class="keyword">const</span> <span class="identifier">RhsDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if rhs is not the same time.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;(</span><span class="keyword">const</span> <span class="identifier">RhsDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if the rhs duration is larger.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;=(</span><span class="keyword">const</span> <span class="identifier">RhsDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if greater or equal than the rhs duration.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;(</span><span class="keyword">const</span> <span class="identifier">RhsDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if less than the rhs duration.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;=(</span><span class="keyword">const</span> <span class="identifier">RhsDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if less or equal to the rhs duration.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="comment">//sign inversion
</span><span class="identifier">Duration</span> <span class="keyword">operator</span><span class="special">-()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> Negated value of the duration.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="comment">//arithmetic operations
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsDuration</span><span class="special">&gt;</span>
<span class="identifier">Duration</span> <span class="keyword">operator</span><span class="special">-</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">RhsDuration</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> A duration value equal to this-rhs_duration.
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the 
        RhsDuration is
        of higher resolution.</em></span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsDuration</span><span class="special">&gt;</span>
<span class="identifier">Duration</span> <span class="keyword">operator</span><span class="special">-=(</span><span class="keyword">const</span> <span class="identifier">RhsDuration</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span>
</pre><p>
        <i>Effects:</i> Modifies to value equal to this-rhs_duration. 
      </p><p>
        <i>Returns:</i> this 
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the 
        RhsDuration is
        of higher resolution.</em></span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsDuration</span><span class="special">&gt;</span>
<span class="identifier">Duration</span> <span class="keyword">operator</span><span class="special">+</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">RhsDuration</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> Duration equal to this+rhs_duration.
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the 
        RhsDuration is
        of higher resolution.</em></span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsDuration</span><span class="special">&gt;</span>
<span class="identifier">Duration</span> <span class="keyword">operator</span><span class="special">+=(</span><span class="keyword">const</span> <span class="identifier">RhsDuration</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span>
</pre><p>
        <i>Effects:</i> Modifies to value equal to this+rhs_duration. 
      </p><p>
        <i>Returns:</i> this 
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the 
        RhsDuration is
        of higher resolution.</em></span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">Duration</span> <span class="keyword">operator</span><span class="special">/</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">divisor</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> Duration with value equal to this/divisor according to
        integer arithmetic rules.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">Duration</span> <span class="keyword">operator</span><span class="special">/=(</span><span class="keyword">int</span> <span class="identifier">divisor</span><span class="special">)</span> 
</pre><p>
        <i>Effects:</i> Change value of this by this/divisor according to integer
        arithmetic rules.
      </p><p>
        <i>Returns:</i> this 
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">Duration</span> <span class="keyword">operator</span><span class="special">*</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> Duration with value equal to this*rhs 
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">Duration</span> <span class="keyword">operator</span><span class="special">*=(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">)</span> 
</pre><p>
        <i>Effects:</i> Modifies to value equal to this*rhs. 
      </p><p>
        <i>Returns:</i> this 
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">tick_type</span> <span class="identifier">get_count</span><span class="special">()</span> <span class="keyword">const</span> 
</pre><p>
        <i>Returns:</i> The count at the resolution of the time duration
        type.
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_nanoseconds"></a>class nanoseconds</h3></div></div></div>

<p>
Objects of class <code>nanoseconds</code> can be used to represent a count of nanoseconds.
</p>

<blockquote><pre>class nanoseconds 
{
 public:

   nanoseconds(long long=0);
   nanoseconds(const nanoseconds& rhs);
   ~nanoseconds();

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions

};
</pre></blockquote>

<pre class="programlisting"><span class="identifier">nanoseconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Constructs an object with a count of nanoseconds - default
        is zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">nanoseconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">nanoseconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1000000000
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> true
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_microseconds"></a>class microseconds</h3></div></div></div>

<p>
Objects of class <code>microseconds</code> can be used to represent a count of microseconds.
</p>

<blockquote><pre>class microseconds 
{
 public:

   microseconds(long long=0);
   microseconds(const microseconds&amp; rhs);
   ~microseconds();

   //conversions
   operator nanoseconds() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions

};

</pre></blockquote>

<pre class="programlisting"><span class="identifier">microseconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Constructs an object with a count of microseconds - default
        is zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">microseconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">microseconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting"><span class="comment">//conversions
</span><span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> microsecond count converted to nanoseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1000000
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> true
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_milliseconds"></a>class milliseconds</h3></div></div></div>


<p>
Objects of class <code>milliseconds</code> can be used to represent a count of milliseconds.
</p>

<blockquote><pre>class milliseconds
{
 public:
   milliseconds(long long=0);
   milliseconds(const milliseconds&amp; rhs);
   ~milliseconds();

   //conversions
   operator nanoseconds() const;
   operator microseconds() const;

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions
};
</pre></blockquote>

<pre class="programlisting"><span class="identifier">milliseconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Constructs an object with a count of milliseconds - default
        is zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">milliseconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">milliseconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> millisecond count converted to nanoseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> millisecond count converted to microseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1000
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> true
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_seconds"></a>class seconds</h3></div></div></div>

<p>
Objects of class <code>seconds</code> can be used to represent a count of seconds.
</p>

<blockquote><pre>class  seconds 
{ 
 public:
   seconds(long long s=0);
   seconds(const seconds&amp; rhs);
   ~seconds();

   //conversions
   operator nanoseconds() const
   operator microseconds() const
   operator milliseconds() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions

};
</pre></blockquote>

<pre class="programlisting"><span class="identifier">seconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of seconds - default is
        zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">seconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">seconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> second count converted to nanoseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> second count converted to microseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">milliseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> second count converted to milliseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> false
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_minutes"></a>class minutes</h3></div></div></div>


<p>
Objects of class <code>minutes</code> can be used to represent a count of minutes.
</p>

<blockquote><pre>class  minutes 
{
 public:
   minutes(long long s=0);
   minutes(const minutes&amp; rhs);
   ~minutes();

   //conversions
   operator nanoseconds() const
   operator microseconds() const
   operator milliseconds() const
   operator seconds() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions

};
</pre></blockquote>
<pre class="programlisting"><span class="identifier">minutes</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of minutes - default is
        zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">minutes</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">minutes</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> minute count converted to nanoseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> minute count converted to microseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">milliseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> minute count converted to milliseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">seconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> minute count converted to seconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 60
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> false
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_hours"></a>class hours</h3></div></div></div>

<p>
Objects of class <code>hours</code> can be used to represent a count of hours.
</p>

<blockquote><pre>class  hours 
{
 public:
   hours(long long s=0);
   hours(const hours&amp; rhs);
   ~hours();

   //conversions
   operator nanoseconds() const
   operator microseconds() const
   operator milliseconds() const
   operator seconds() const
   operator minutes() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions

};
</pre></blockquote>


<pre class="programlisting"><span class="identifier">hours</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of hours - default is zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="identifier">hours</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">hours</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> hour count converted to nanoseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> hour count converted to microseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">milliseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> hour count converted to milliseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">seconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> hour count converted to seconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">minutes</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns: </i> hour count converted to seconds.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 3600
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> false
      </p><p>
        <i>Throws:</i> Nothing.
      </p>
</div>

<h2><a name="References">References</a></h2>
<ul>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1682.html">
  N1682</a>, A Multi-threading Library for Standard C++, Pete Becker.</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1815.html">
  N1815</a>, ISO C++ Strategic Plan for Multithreading, Lawrence Crowl.</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1883.pdf">
  N1883</a>, Preliminary Threading Library Proposal for TR2, Kevlin Henney.</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1907.html">
  N1907</a>, A Multi-threading Library for Standard C++, Revision 1 Pete Becker</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2043.html">
  N2043</a>, Simplifying And Extending Mutex and Scoped Lock Types For C++ 
  Multi-Threading Library, Ion Gazta&ntilde;aga</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2090.html">
  N2090</a>, A Threading API for C++, Peter Dimov</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2094.html">
  N2094</a>, Multithreading API for C++0X - A Layered Approach, Howard Hinnant</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2139.html">
  N2139</a>, Thoughts on a Thread Library for C++, Anthony Williams</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2178.html">
  N2178</a>, Proposed Text for Chapter 30, Thread Support Library, Peter Dimov</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html">
  N2184</a>, Thread Launching for C++0X, Howard Hinnant</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2285.html">
  N2285</a>, A Multi-threading Library for Standard C++, Revision 2, Pete Becker</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2411.html">
  N2411</a>, Proposal for Date-Time Types in C++0x To Support Threading APIs v2, Jeff Garland</li>
  <li>
  <a href="http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=40874">
  ISO 8601: 2004</a>Data elements and interchange formats -- Information interchange -- Representation of dates and times</li>


</ul>


<h2><a name="Acknowledgments"></a>Acknowledgments</h2>

<p>
The overall design of this threading library is based on William Kempf's 
Boost.Thread Library, as refined by literally hundreds of other Boost users and 
contributors. Dinkumware and Metrowerks (now Freescale) implementations of 
Boost.Thread, developed respectively by Pete Becker and Howard Hinnant, created 
further existing practice. Proposals by Pete Becker, Peter Dimov, Ion Gazta&ntilde;aga, 
and Anthony Williams were also influential. Peter, Ion, and Anthony also 
contributed numerous critiques, suggestions, and comments on the current 
proposal, as did other members of an ad hoc threads working group. Jeff Garland 
contributed the date time portions of the proposal based on the Boost.DateTime 
Library and his TR2 proposals.
</p>

</body></html>
