<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en"><head>


	<meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>Thread Working Draft 13</title>
	
	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {background-color:#FFFFA0}
	del {background-color:#FFFFA0}
        .comment        { color: #800000; }
    span.underline
    {
//        text-decoration: underline;
    }

    span.strikethrough
    {
        text-decoration: line-through;
    }
    span.remove
    {
        text-decoration: line-through;
        color: red;
        display: inline;
    }
    span.insert
    {
	background-color:#FFFFA0;
        color: green;
        display: inline;
    }
	</style></head><body>

<address align="right">
Document number: N2447=07-0317<br/>
<br/>
<a href="mailto:hinnant@twcny.rr.com">Howard E. Hinnant</a>, 
<a href="mailto:jeff@crystalclearsoftware.com">Jeff Garland</a>,  
<a href="mailto:public@alisdairm.net">Alisdair Meredith</a>,
<a href="mailto:chris@kohlhoff.com">Chris Kohlhoff</a>,
<a href="mailto:dietmar_kuehl@yahoo.com">Dietmar K&uuml;hl</a>,
<a href="mailto:ncm@cantrip.org">Nathan Myers</a>,
<a href="mailto:prem.rao@hp.com">PremAnand M Rao</a>,
<a href="mailto:nick@usenix.org">Nick Stoughton</a>
<br/>
2007-10-04
</address>
<hr/>
<h1 align="center">Multi-threading Library for Standard C++</h1>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#ProposedWording">Proposed Wording</a><ul>
	<li><a href="#ThreadsWording">Threads Proposed Wording</a></li>
	<li><a href="#MutexsLocksWording">Mutexes and Locks Proposed Wording</a></li>
<li><a href="#ConditionVariablesWording">Condition Variables Proposed Wording</a></li>
<li><a href="#DateTime">Date Time Proposed Wording</a></li>
</ul>

</li>
<li><a href="#References">References</a></li>
<li><a href="#Acknowledgments">Acknowledgments</a></li>
</ul>

<h2><a name="Introduction"></a>Introduction</h2>

<p>
This is a revision of 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html">N2320</a>
which removes cancellation/interruption and changes condition variables per the suggestions in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2406.html">N2406</a>.
This is the course of a action requested by the combined LWG/Concurrency working groups
at the Kona meeting.
</p>

<h1><a name="ProposedWording">Proposed wording</a></h1>

<hr/>

<h3>20.5 Function objects [function.objects]</h3>

<p>
<i>Modify paragraph 2 as follows:</i>
</p>

<blockquote>
 <p><b>Header <code>functional</code> synopsis</b></p>

 <pre>
 namespace std {
   ...
   <i>// Hash function specializations</i>
   ...
   <ins class="diff modified">struct hash&lt;std::thread::id&gt;; //should not be in this header file ?</ins>
 }
 </pre>
</blockquote>

<h3>20.5.15 Class template <code>hash</code> [unord.hash]</h3>

<i>Modify paragraph 1 as follows:</i>

<blockquote>
The unordered associative containers defined in clause 23.4 use
specializations
of <code>hash</code> as the default hash function. This class template
is only
required to be instantiable for integer types (3.9.1), floating point
types
(3.9.1), pointer types (8.3.1), and <code>std::string</code>,
<code>std::u16string</code>, <code>std::u32string</code>,<del
class="diff modified">
and</del> <code>std::wstring</code><ins class="diff modified">, and
<code>std::thread::id</code></ins>.
</blockquote>

<hr/>

<h2>Chapter 30&nbsp;&nbsp; Multi-threading library</h2>

<hr/>

<p>
The following subclauses describe components to create and manage 
<i>threads of execution</i> [intro.execution? (N2334)], perform mutual exclusion and locking, and communicate 
between threads of execution.</p>

<table style="border-collapse: collapse;" border="1" bordercolor="#111111" cellpadding="5" cellspacing="0" width="100%">
  <tbody><tr>
    <td align="center" width="50%"><b>Subclause</b></td>
    <td align="center" width="50%"><b>Header(s)</b></td>
  </tr>
  <tr>
    <td width="50%"><a href="#ThreadsWording">Threads</a></td>
    <td width="50%"><code>&lt;thread&gt;</code></td>
  </tr>
  <tr>
    <td width="50%"><a href="#MutexsLocksWording">Mutexs and locks</a></td>
    <td width="50%"><code>&lt;mutex&gt;</code></td>
  </tr>
  <tr>
    <td width="50%"><a href="#ConditionVariablesWording">Condition variables</a></td>
    <td width="50%"><code>&lt;cond_var&gt;</code></td>
  </tr>
</tbody></table>

<p>
Some functions 
described in this clause are specified to throw exceptions of type <tt>system_error</tt>
([syserr.syserr]). The <tt>error_category</tt> ([syserr.errcat.overview]) 
of the <tt>error_code</tt> reported by such exceptions <tt>code()</tt> 
member function is implementation-defined.  [<i>Note:</i> The category is 
typically <tt>native_category</tt> ([syserr.errcat.overview]) since these error 
codes usually originate from the underlying operating system application program 
interface (API). <i>-- end note</i>]
</p>

<h3>
<a name="ThreadsWording">Threads</a></h3>

<p>
<b>&lt;thread&gt; synopsis</b>
</p>

<blockquote><pre>namespace std {

class thread;

void swap(thread&amp;  x, thread&amp;  y);
void swap(thread&amp;&amp; x, thread&amp;  y);
void swap(thread&amp;  x, thread&amp;&amp; y);

namespace this_thread
{
    thread::id get_id();
    
    void yield();
    template &lt;class TimeDuration&gt;
        void sleep(const TimeDuration&amp; rel_t);

}  // this_thread

struct once_flag
{
    constexpr once_flag();

    once_flag(const once_flag&amp;) = delete;
    once_flag&amp; operator=(const once_flag&amp;) = delete;
};

template&lt;class Callable, class ...Args&gt;
void call_once(once_flag&amp; flag, Callable func, Args&amp;&amp;... args);

}  // std
</pre></blockquote>

<h4>Class thread</h4>

<p>
An object of class <code>thread</code> manages a thread of execution.
It provides a mechanism to create a new thread of execution,
for the current thread of execution to wait for 
completion of a thread of execution, and to perform other operations to manage and query the state of the thread of execution.
</p>

<blockquote><pre>class thread
{
public:
    // <i>types:</i>
    class id;
    typedef <i>implementation-defined</i> native_handle_type;

    // <i>construct/copy/destroy:</i>
    thread();
    template &lt;class F, class ...Args&gt; explicit thread(F f, Args&amp;&amp;... args);
    ~thread();
    thread(const thread&amp;) = delete;
    thread(thread&amp;&amp;);
    thread&amp; operator=(const thread&amp;) = delete;
    thread&amp; operator=(thread&amp;&amp;);

    // <i>members:</i>
    void swap(thread&amp;&amp;);
    bool joinable() const;
    void join();
    void detach();
    id get_id() const;
    native_handle_type native_handle();

    // <i>static members:</i>
    static unsigned hardware_concurrency();
};
</pre></blockquote>

<p>
Class <tt>thread</tt> and class <tt>thread::id</tt> shall be standard-layout 
types ([?]).  
</p>

<p>
If and only if the <tt>thread</tt> type is internally represented by a single data structure which can be passed to operating system specific interfaces, there shall be a nested implementation-defined typedef <tt>native_handle_type</tt> that is an alias to this native type if it is copyable.  Otherwise, if the native type is not copyable, it is a pointer to this native type.  The implementation shall document whether the <tt>native_handle_type</tt> typedef is present.
</p>

<p>
If the nested typedef <tt>native_handle_type</tt> exists, then there
also shall be a member function <tt>native_handle()</tt> which returns the
underlying representation.
</p>

<h5><tt>thread</tt> types</h5>
<h6>Class <tt>thread::id</tt></h6>
<pre>
    class thread::id
    {
    public:
        id();
    };

    bool operator==(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
    bool operator!=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
    bool operator&lt;(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
    bool operator&lt;=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
    bool operator&gt;(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
    bool operator&gt;=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);

    template&lt;class charT, class traits&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, const thread::id&amp; id);

</pre>
<p> Objects of type <tt>thread::id</tt> uniquely identify threads of execution.</p>

<blockquote><pre>id();
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <tt>id</tt> which compares
equal to other default constructed <tt>id</tt> objects.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>bool operator==(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
</pre>

<blockquote>
<p>
<i>Returns:</i> If neither <tt><i>x</i></tt> nor <tt><i>y</i></tt> identifies
a thread of execution, returns <tt>true</tt>.  Otherwise if
<tt><i>x</i></tt> and <tt><i>y</i></tt> identify the same thread of execution,
returns <tt>true</tt>.  Otherwise returns <tt>false</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>bool operator!=(const thread::id&amp; <i>x</i>, const thread::id&amp; <i>y</i>);
</pre>

<blockquote>
<p>
<i>Returns:</i> <tt>!(<i>x</i> == <i>y</i>)</tt>
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>


<blockquote>
<pre>bool operator&lt;(const thread::id&amp; x, const thread::id&amp; y);
</pre>

<blockquote>
<p>
<i>Returns:</i> a value such that <tt>operator&lt;</tt> is a total ordering as described in [alg.sorting].
</p>
<p>
[<i>Note:</i> Defining a comparison operator allows <tt>thread::id</tt> objects to be used as keys in associative containers.<i> --end note</i>]
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool operator&lt;=(const thread::id&amp; x, const thread::id&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>!(y &lt; x)</tt> </p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool operator&gt;(const thread::id&amp; x, const thread::id&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>y &lt; x</tt> </p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool operator&gt;=(const thread::id&amp; x, const thread::id&amp; y);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>!(x &lt; y)</tt> </p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>template&lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt; (basic_ostream&lt;charT, traits&gt;&amp;&amp; out, const thread::id&amp; id);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of the <tt>thread::id</tt> into
the stream <tt>out</tt>.
</p>
<p>
<i>Returns:</i> <tt>out</tt>.
</p>
</blockquote>
</blockquote>

<h5><tt>thread</tt> constructors</h5>
<blockquote>
<pre>thread();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs a <tt>thread</tt> object not attached to any thread
of execution.  [<i>Note:</i> This is the state of a <tt>thread</tt>
object after <tt>detach</tt> or <tt>join</tt> is successfully called. <i>-- end note</i>]
</p>
<p>
<i>Postconditions:</i>
</p>
<blockquote><pre>get_id() == thread::id()
&amp;&amp; joinable() == false
</pre></blockquote>
<p>
<i>Remarks:</i> <tt>get_id()</tt> returns an identity that refers to
<i>not any thread</i>.  This identity compares equal to other
non-<tt>join</tt>able <tt>thread</tt>s, and compares not equal to all
other <tt>join</tt>able <tt>thread</tt>s.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>template &lt;class F, class ...Args&gt; explicit thread(F f, Args&amp;&amp;... args);
</pre>

<blockquote>
<p>
<i>Requires:</i>  <tt>F</tt> is a callable type [func.def].  If <tt>f</tt> is an lvalue, <tt>F</tt> must be <tt>CopyConstructible</tt>.
If <tt>f</tt> is an rvalue, <tt>F</tt> must only be <tt>MoveConstructible</tt>.
</p>
<p>
<i>Effects:</i> Constructs an object of type <tt>thread</tt> and executes <tt><i>INVOKE</i>(f, t1, t2, ..., tN)</tt> 
in a new thread of execution, where <tt>t1, t2, 
..., tN</tt> are the values in <tt>args...</tt>.  Any return value from <tt>f</tt> is ignored.  If <tt>f</tt> terminates with an uncaught
exception, <tt>std::terminate()</tt> shall be called.
</p>
<p>
<i>Postconditions:</i>
</p>
<blockquote><pre>get_id() != thread::id()
&amp;&amp; joinable() == true
</pre>
<p><code>*this</code> represents the newly started thread of execution.</p>
</blockquote>
<p>
<i>Throws:</i> <tt>system_error</tt> if unable to  start the new thread of execution.
</p>
</blockquote>
</blockquote>

<blockquote><pre>thread(thread&amp;&amp; <i>x</i>);
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <tt>thread</tt> from <tt><i>x</i></tt>.  
</p>
<p>
<i>Postconditions:</i>  <tt><i>x</i>.joinable()</tt> is <tt>false</tt>. 
<tt><i>x</i>.get_id() == thread().get_id()</tt>. <tt>joinable()</tt>
returns the value of <tt><i>x</i>.joinable()</tt> prior to the start of construction.
<tt>get_id()</tt> returns the value of <tt><i>x</i>.get_id()</tt> prior to the 
start of construction.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h5><tt>thread</tt> destructor</h5>
<blockquote><pre>~thread();
</pre>

<blockquote>
<p>
<i>Effects:</i> If <tt>joinable()</tt> then <tt>detach()</tt>,
otherwise no effects.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h5><tt>thread</tt> assignment</h5>
<blockquote><pre>thread&amp; operator=(thread&amp;&amp; <i>x</i>);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <tt>this</tt> currently refers to a <tt>joinable</tt> thread object, calls
<tt>detach()</tt>.  Then assigns the state of <tt><i>x</i></tt> to <tt>*this</tt>
and sets <tt><i>x</i></tt> to a default constructed state.
</p>
<p>
<i>Postconditions:</i>  <tt><i>x</i>.joinable()</tt> is <tt>false</tt>. 
<tt><i>x</i>.get_id() == thread().get_id()</tt>. <tt>joinable()</tt> returns the 
value of <tt><i>x</i>.joinable()</tt> prior to the
assignment.
<tt>get_id()</tt> returns the value of <tt><i>x</i>.get_id()</tt> prior to the
assignment.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h5><tt>thread</tt> members</h5>
<blockquote><pre>void swap(thread&amp;&amp; <i>x</i>);
</pre>

<blockquote>
<p>
<i>Effects:</i> Swaps the state of <tt>*this</tt> and <tt><i>x</i></tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>bool joinable() const;
</pre>

<blockquote>
<p>
<i>Returns:</i> <tt>get_id() != id()</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>void join();
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <tt>joinable()</tt> is <tt>true</tt>.
</p>
<p>
<i>Effects:</i> The current thread of execution blocks until the thread of execution 
represented by <code>*this</code> completes.</p>
<p>
<i>Postconditions:</i> After a normal return of <tt>join()</tt>,
<tt>joinable()</tt> is <tt>false</tt>. If <tt>join()</tt> throws an exception, the thread of execution represented by
<tt>*this</tt> remains <tt>joinable</tt>.
</p>

<p>
<i>Throws:</i> May throw <tt>system_error</tt>.
</p>
</blockquote>
</blockquote>

<blockquote><pre>void detach();
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <tt>joinable()</tt> is <tt>true</tt>.
</p>
<p>
<i>Effects:</i> The thread of execution represented by
<tt>*this</tt> continues execution.  When the thread of execution represented by
<tt>*this</tt> ends execution it shall release any owned resources.
</p>
<p>
<i>Postconditions:</i> <tt>joinable()</tt> is <tt>false</tt>. <tt>*this</tt> 
does not represent a thread of execution.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>id get_id() const;
</pre>

<blockquote>
<p>
<i>Returns:</i> An object of type <tt>thread::id</tt> which identifies the thread of execution 
represented by
<tt>*this</tt>.  If this
<tt>thread</tt> is not <tt>joinable()</tt> returns a default constructed <tt>thread::id</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>native_handle_type native_handle();
</pre>

<blockquote>
<p>
<i>Returns:</i> The underlying representation of the thread object.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h5><tt>thread</tt> static members</h5>
<blockquote><pre>unsigned hardware_concurrency();
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of threads of execution that can reasonably be expected to
execute concurrently. <i>[Note:</i> This value should only be considered to be a hint.
<i>--end note]</i> If this value is not computable or well defined a
return value of 1 is recommended, but not required.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h5><tt>thread</tt> specialized algorithms</h5>
<blockquote>
<pre>void swap(thread&amp;  x, thread&amp;  y);
void swap(thread&amp;&amp; x, thread&amp;  y);
void swap(thread&amp;  x, thread&amp;&amp; y);
</pre>
<blockquote>
<p>
<i>Effects:</i> <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>



<h4>Namespace <tt>this_thread</tt></h4>

<blockquote><pre>namespace this_thread
{
    thread::id get_id();
    
    void yield();
    template &lt;class TimeDuration&gt;
        void sleep(const TimeDuration&amp; rel_t);

}  // this_thread
</pre></blockquote>

<blockquote><pre>thread::id this_thread::get_id();
</pre>

<blockquote>
<p>
<i>Returns:</i> Returns an object of type <tt>thread::id</tt> that uniquely identifies the current thread of execution. The object returned shall not compare equal to a default constructed <tt>thread::id</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>void yield();
</pre>

<blockquote>
<p>
<i>Effects:</i>  Offers the operating system the opportunity to schedule another thread of execution.</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote><pre>template &lt;class TimeDuration&gt;
    void sleep(const TimeDuration&amp; rel_t);
</pre>

<blockquote>
<p>
<i>Requires:</i> <tt>TimeDuration</tt> shall be explicitly convertible to <tt>nanoseconds</tt>.
</p>
<p>
<i>Effects:</i>  The current thread of execution blocks for at least the amount of time specified.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4><code>struct once_flag</code></h4>

<blockquote>

<p>Objects of class <code>once_flag</code> are opaque data structures that allow
<code>call_once</code> to initialize data without causing a data race or 
deadlock.</p>

<pre>constexpr once_flag();</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs a object of type
<code>once_flag</code>.</p>
<p>
<i>Postcondition:</i> Internal state is set to indicate to an invocation 
of <code>call_once</code> with this <code>once_flag</code> as its initial 
argument that no function has been called.</p>
</blockquote>
</blockquote>


<h4><code>non-member function call_once</code></h4>

<blockquote>

<pre>template&lt;class Callable, class Args...&gt;
void call_once(once_flag&amp; flag, Callable func, Args&amp;&amp;... args);
</pre>

    <blockquote>

    <p><i>Requires:</i> If the <code>Callable</code> argument <code>func</code> is an lvalue, <code>F</code> 
    is
    <code>CopyConstructible</code>. Otherwise, <code>func</code> is an rvalue, <code>
    and F</code> is
    <code>MoveConstructible</code>. Copying or moving (as appropriate) shall have no side effects, and the effect of calling the
    copy shall be equivalent to calling the original.</p>

    <p><i>Effects:</i> The argument <code>func</code> (or a copy thereof) is called exactly once 
    for the <code>once_flag</code> object specified by <code>flag</code>, as-if by invoking
    <code>func(args)</code>,<code> </code>even if <code>call_once</code> is 
    called multiple times for the same <code>once_flag</code> object. If multiple
    calls to <code>call_once</code> with the same <code>once_flag</code> object 
    occur in separate threads of execution, only one
    thread of execution shall call <code>func</code>, and none shall proceed until the call to <code>func</code> has completed. 
    If the invocation of <code>func</code> results in an exception being thrown, 
    the exception is propagated to the caller and the effects are as-if this 
    invocation of&nbsp;<code>call_once</code> did not occur.</p>

    <p><i>Throws:</i> <code>system_error</code> or any exception propagated from <code>func</code>.</p>

    <p><i>Thread safety:</i> Access to the same <code>once_flag</code> object by 
    calls to <code>call_once</code> from different threads of execution shall 
    not result in a data race or deadlock.</p>

<p>[<i>Examples:</i></p>
<blockquote><pre>std::once_flag flag;

void init();

void f()
{
    std::call_once(flag,init);
}

struct initializer
{
    void operator()();
};

void g()
{
    static std::once_flag flag2;
    std::call_once(flag2,initializer());
}
</pre></blockquote>

<p><i>-- end example]</i></p>
</blockquote>
</blockquote>

<h3>
<a name="MutexsLocksWording">Mutexs and locks</a></h3>

<p>
<b>&lt;mutex&gt; synopsis</b>
</p>

<blockquote><pre>namespace std {

struct mutex;
struct recursive_mutex;
struct timed_mutex;
struct recursive_timed_mutex;

struct defer_lock_t;
struct try_to_lock_t;
struct adopt_lock_t;

extern const defer_lock_t  defer_lock;
extern const try_to_lock_t try_to_lock;
extern const adopt_lock_t  adopt_lock;

class lock_error;

template &lt;class Mutex&gt; class lock_guard;
template &lt;class Mutex&gt; class unique_lock;

template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);

template &lt;class L1, class L2, class ...L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
template &lt;class L1, class L2, class ...L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);

}  // std
</pre></blockquote>

<h3>Mutex concepts</h3>

<p>
Mutex objects provide synchronization operations to avoid data races. A
mutex object supports mutual exclusion between threads of execution by
limiting its ownership to a single thread of execution.  A thread of
execution obtains ownership of a mutex object by calling <tt>lock()</tt>
and relinquishes ownership by calling <tt>unlock()</tt>.  The 
thread of execution that calls <tt>lock()</tt> for a mutex object shall
call <tt>unlock()</tt>.  Mutexes may be either recursive or
non-recursive.  The syntax is the same for both recursive and
non-recursive mutexes, but the semantics differ for the member functions
as described below.
</p>

<p>
A mutex type shall be <tt>DefaultConstructible</tt> and <tt>Destructible</tt>.  If initialization
of a mutex type fails, an exception of type <tt>system_error</tt> shall be thrown.  The destructor
of a mutex type shall not exit by an exception.
A mutex type is neither copyable
nor movable.  A mutex type shall have the following member functions:
</p>

<blockquote>
<pre>void lock();
</pre>
<blockquote>
<p>
<i>Precondition:</i> For non-recursive mutexes the current thread of execution shall not own the mutex.
</p>
<p>
<i>Effects:</i> The current thread of execution will block until the mutex is not owned by another thread of execution.
Upon successful completion, the current thread of execution owns the mutex.
</p>
<p>
<i>Throws:</i>  <tt>system_error</tt>.
</p>
<p>
<i>Thread safety:</i> This is an acquire operation.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool try_lock();
</pre>
<blockquote>
<p>
<i>Precondition:</i> For non-recursive mutexes the current thread of execution shall not own the mutex.
</p>
<p>
<i>Effects:</i> If ownership can be obtained without blocking, then ownership is obtained,
else there is no effect and <tt>try_lock()</tt> immediately returns.
</p>
<p>
<i>Returns:</i> <tt>true</tt> if ownership was obtained, otherwise <tt>false</tt>.
</p>
<p>
<i>Thread safety:</i>  This is an acquire operation if <tt>try_lock</tt> returns <tt>true</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void unlock();
</pre>
<blockquote>
<p>
<i>Precondition:</i> The current thread of execution shall own the mutex.
</p>
<p>
<i>Effects:</i> For a non-recursive mutex ownership is released.  For a recursive mutex
<tt>unlock()</tt> must be called the same number of times which the mutex was locked
(via either <tt>lock()</tt> or <tt>try_lock()</tt> or by any other locking function) before ownership is released.
</p>
<p>
<i>Thread safety:</i>  This is a release operation.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<p>
If and only if the mutex type is internally represented by a single data structure
which can be passed to operating system specific interfaces, then there shall be a nested 
implementation-defined typedef <tt>native_handle_type</tt> that is an alias to this native type if it is copyable,
otherwise if the native type is not copyable, is a pointer to this native type. 
The implementation shall document whether the <tt>native_handle_type</tt> 
typedef is present.
</p>

<p>
If the nested typedef <tt>native_handle_type</tt> exists, then there
also shall be a member function <tt>native_handle()</tt> which returns <tt>
native_handle_type</tt>. <i>[Example:</i>
</p>

<blockquote><pre>class mutex
{
    pthread_mutex_t m;
public:
    typedef pthread_mutex_t* native_handle_type;
    native_handle_type native_handle() {return &amp;m;}
    ...
};
</pre>
<p><i>--end example]</i></p>
</blockquote>

<p>
If there is no single operating system specific data structure which implements
the mutex type, then neither the nested type <tt>native_handle_type</tt> nor the
member function <tt>native_handle()</tt> shall not be present.  <i>[Example:</i> 
if a <tt>recursive_mutex</tt> is implemented with both a <tt>pthread_mutex_t</tt>
and a separate lock count, then there will be no <tt>native_handle_type</tt>. <i>
--end example]</i>
</p>

<p>
Implementations may supply additional implementation defined constructors
which allow further customization as afforded by the implementation
or its environment.
</p>

<h4>Class mutex</h4>

<blockquote><pre>namespace std {

struct mutex
{
public:
    mutex();
    ~mutex();

    mutex(const mutex&amp;) = delete;
    mutex&amp; operator=(const mutex&amp;) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef unspecified native_handle_type;  // conditionally present.  example: pthread_mutex_t*
    native_handle_type native_handle();      // conditionally present
};

}  // std
</pre></blockquote>

<p>
The class <tt>mutex</tt> is a non-recursive mutex which satisfies all of the Mutex requirements.
It shall be a standard-layout type ([?]).
</p>

<h4>Class recursive_mutex</h4>

<blockquote><pre>namespace std {

struct recursive_mutex
{
public:
    recursive_mutex();
    ~recursive_mutex();

    recursive_mutex(const recursive_mutex&amp;) = delete;
    recursive_mutex&amp; operator=(const recursive_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef unspecified native_handle_type;  // conditionally present.  example: pthread_mutex_t*
    native_handle_type native_handle();      // conditionally present
};

}  // std
</pre></blockquote>

<p>
The class <tt>recursive_mutex</tt> shall be a recursive mutex which satisfies all of the Mutex requirements.
It shall be a standard-layout type ([?]).
</p>

<h3>Timed Mutexes</h3>

<p>
Types that meet the requirements of the Timed Mutex concept also meet the requirements of the Mutex concept
and add a single member function:
</p>

<blockquote>
<pre>template &lt;class TimeDuration&gt;
    bool timed_lock(const TimeDuration&amp; rel_time);
</pre>
<blockquote>
<p>
<i>Precondition:</i> For non-recursive mutexes the current thread of execution shall not own the mutex.
The type <tt>TimeDuration</tt> provides resolution information (ticks_per_second) that allows conversion 
of the specified value into the native time resolution.
</p>
<p>
<i>Effects:</i> The function attempts to obtain ownership of the mutex within the specified time.
If the indicated time is less than or equal to <tt>0</tt>, the function still attempts to obtain ownership without
blocking (as if by calling <tt>try_lock()</tt>).  If the function returns within the specified
time duration, it shall have obtained ownership.
</p>
<p>
<i>Returns:</i> <tt>true</tt> if ownership was obtained, otherwise <tt>false</tt>.
</p>
<p>
<i>Thread safety:</i>  This is a synchronization operation.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4>Class timed_mutex</h4>

<blockquote><pre>namespace std {

struct timed_mutex
{
public:
    timed_mutex();
    ~timed_mutex();

    timed_mutex(const timed_mutex&amp;) = delete;
    timed_mutex&amp; operator=(const timed_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    template &lt;class TimeDuration&gt;
        bool timed_lock(const TimeDuration&amp; rel_time);
    void unlock();

    typedef unspecified native_handle_type;  // conditionally present.  example: pthread_mutex_t*
    native_handle_type native_handle();      // conditionally present
};

}  // std
</pre></blockquote>

<p>
The class <tt>timed_mutex</tt> is a non-recursive mutex that satisfies all of the Timed Mutex requirements.
It shall be a standard-layout type ([?]).
</p>

<h4>Class recursive_timed_mutex</h4>

<blockquote><pre>namespace std {

struct recursive_timed_mutex
{
public:
    recursive_timed_mutex();
    ~recursive_timed_mutex();

    recursive_timed_mutex(const recursive_timed_mutex&amp;) = delete;
    recursive_timed_mutex&amp; operator=(const recursive_timed_mutex&amp;) = delete;

    void lock();
    bool try_lock();
    template &lt;class TimeDuration&gt;
        bool timed_lock(const TimeDuration&amp; rel_time);
    void unlock();

    typedef unspecified native_handle_type;  // conditionally present.  example: pthread_mutex_t*
    native_handle_type native_handle();      // conditionally present
};

}  // std
</pre></blockquote>

<p>
The class <tt>recursive_timed_mutex</tt> shall be a recursive mutex that satisfies all of the Timed Mutex requirements.
It shall be a standard-layout type ([?]).
</p>

<h3>Locks</h3>

<p>
Locks are objects that hold a reference to a mutex and unlock the mutex during the lock's destruction
(such as when leaving block scope).  The locks do not manage the lifetime of the mutex they
reference, but only the ownership status of that mutex.  <i>[Note: </i>Locks are intended to ease the burden
of unlocking the mutex under both normal and exceptional circumstances.<i> --end 
note]</i></p>

<p>
Some locks may take tag types which describe what should be done with the mutex in the lock's
constructor.
</p>

<blockquote><pre>struct defer_lock_t  {};
struct try_to_lock_t {};
struct adopt_lock_t  {};

extern const defer_lock_t   defer_lock;
extern const try_to_lock_t  try_to_lock;
extern const adopt_lock_t   adopt_lock;
</pre></blockquote>

<p>
An exception class <tt>lock_error</tt> derives from <tt>exception</tt> and is used to indicate
improper usage of locks such as locking a mutex that the lock already owns, or unlocking a mutex
that the lock does not own.
</p>

<blockquote><pre>class lock_error
    : public std::exception
{
public:
    virtual const char* what() const throw();
};
</pre></blockquote>

<h4>Class lock_guard</h4>

<blockquote><pre>namespace std {

template &lt;class Mutex&gt;
class lock_guard
{
public:
    typedef Mutex mutex_type;

    explicit lock_guard(mutex_type&amp; m);
    lock_guard(mutex_type&amp; m, adopt_lock_t);
    ~lock_guard();

    lock_guard(lock_guard const&amp;) = delete;
    lock_guard&amp; operator=(lock_guard const&amp;) = delete;
};

}  // std
</pre></blockquote>

<p>
<tt>lock_guard</tt> is used to control the ownership of a mutex within a single scope.
An invariant of the <tt>lock_guard</tt> object is that it maintains the ownership of the
mutex throughout the <tt>lock_guard</tt>'s lifetime.  Mutex ownership can not be deferred
or transferred away from the <tt>lock_guard</tt>.
</p>

<blockquote>
<pre>explicit lock_guard(mutex_type&amp; m);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <tt>mutex_type</tt> is not a recursive mutex,  the current thread of execution
does not own the mutex.  The lifetime of <tt><i>m</i></tt> is greater than the lifetime
of the <code>lock_guard</code> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and calls <tt><i>m</i>.lock()</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>lock_guard(mutex_type&amp; m, adopt_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> The current thread of execution has ownership of the mutex <tt><i>m</i></tt>.
The lifetime of <tt><i>m</i></tt> is greater than the lifetime of the <code>
lock_guard</code> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and performs no other operation on it.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>~lock_guard();
</pre>
<blockquote>
<p>
<i>Effects:</i> <tt><i>m</i>.unlock()</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h4>Class unique_lock</h4>

<blockquote><pre>namespace std {

template &lt;class Mutex&gt;
class unique_lock
{
public:
    typedef Mutex mutex_type;

    unique_lock();
    explicit unique_lock(mutex_type&amp; m);
    unique_lock(mutex_type&amp; m, defer_lock_t);
    unique_lock(mutex_type&amp; m, try_to_lock_t);
    unique_lock(mutex_type&amp; m, adopt_lock_t);
    ~unique_lock();

    unique_lock(unique_lock const&amp;) = delete;
    unique_lock&amp; operator=(unique_lock const&amp;) = delete;

    unique_lock(unique_lock&amp;&amp; u);
    unique_lock&amp; operator=(unique_lock&amp;&amp; u);

    void lock();
    bool try_lock();

    template &lt;class TimeDuration&gt;
        bool timed_lock(const TimeDuration&amp; rel_t);
    bool timed_lock(const system_time&amp; abs_time);

    void unlock();

    bool owns_lock() const;
    operator unspecified-bool-type () const;
    mutex_type* mutex() const;

    void swap(unique_lock&amp;&amp; u);
    mutex_type* release();
};

template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);

}  // std
</pre></blockquote>

<p>
<tt>unique_lock</tt> is used to control the ownership of a mutex within one or more scopes.
Mutex ownership can be deferred or transferred away from the <tt>unique_lock</tt>. 
An object of type
<tt>unique_lock</tt> is not copyable but is movable.
</p>

<blockquote>
<pre>unique_lock();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <tt>unique_lock</tt>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == 0
owns_lock() == false
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>explicit unique_lock(mutex_type&amp; m);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <tt>mutex_type</tt> is not a recursive mutex,  the current thread of execution
does not own the mutex.  The lifetime of <tt><i>m</i></tt> is greater than the lifetime
of the <tt>unique_lock</tt> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and calls <tt><i>m</i>.lock()</tt>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns_lock() == true
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(mutex_type&amp; m, defer_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <tt>mutex_type</tt> is not a recursive mutex,  the current thread of execution
does not own the mutex. 
The lifetime of <tt><i>m</i></tt> is greater than the lifetime of the <tt>
unique_lock</tt> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and performs no other operation on it.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns_lock() == false
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(mutex_type&amp; m, try_to_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> If <tt>mutex_type</tt> is not a recursive mutex, then the current thread of execution
does not own the mutex. 
The lifetime of <tt><i>m</i></tt> is greater than the lifetime of the <tt>
unique_lock</tt> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and calls <tt><i>m</i>.try_lock()</tt>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns_lock() == <i>The result of the call to</i> <i>m</i>.try_lock()
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(mutex_type&amp; m, adopt_lock_t);
</pre>
<blockquote>
<p>
<i>Precondition:</i> The current thread of execution has ownership of the mutex <tt><i>m</i></tt>. 
The lifetime of <tt><i>m</i></tt> is greater than the lifetime of the <tt>
unique_lock</tt> object.
</p>
<p>
<i>Effects:</i> Stores a reference to <tt><i>m</i></tt> and performs no other operation on it.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == &amp;m
owns_lock() == true
</pre></blockquote>
</blockquote>
</blockquote>

<blockquote>
<pre>~unique_lock();
</pre>
<blockquote>
<p>
<i>Effects:</i> If <tt>owns_lock()</tt> calls <tt>unlock()</tt> on the referenced mutex.
Otherwise there are no effects.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock(unique_lock&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i> Transfers mutex ownership (if any) from <tt>u</tt> to <tt>this</tt>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == <i>The value of</i> u.mutex() <i>prior to the construction</i>.
owns_lock() == <i>The value of</i> u.owns_lock() <i>prior to the construction</i>.
u.mutex() == 0
u.owns_lock() == false
</pre></blockquote>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>unique_lock&amp; operator=(unique_lock&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i>  If <tt>owns_lock()</tt> calls <tt>unlock()</tt>, and then
transfers mutex ownership (if any) from <tt>u</tt> to <tt>this</tt>.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == <i>The value of</i> u.mutex() <i>prior to the construction</i>.
owns_lock() == <i>The value of</i> u.owns_lock() <i>prior to the construction</i>.
u.mutex() == 0
u.owns_lock() == false
</pre></blockquote>
<p>
<i>Throws:</i> Nothing.
</p>
<p>
<i>Note:</i> With a recursive mutex it is possible that both
<tt>this</tt> and <tt>u</tt> own the same mutex before the assignment.
In this case, <tt>this</tt> will own the mutex after the assignment (and
<tt>u</tt> will not), but the mutex's lock count will be decremented by
one.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void lock();
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <tt>lock()</tt> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <tt>owns_lock() == true</tt>.
</p>
<p>
<i>Throws:</i> <tt>lock_error</tt>, if on entry <tt>owns_lock()</tt> is <tt>true</tt>.</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool try_lock();
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <tt>try_lock()</tt> on the referenced mutex.
</p>
<p>
<i>Returns:</i>  The result of the call to <tt>try_lock()</tt> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <tt>owns_lock() == </tt>The result of the call to <tt>try_lock()</tt> on the referenced mutex.
</p>
<p>
<i>Throws:</i> <tt>lock_error</tt>, if on entry <tt>owns_lock()</tt> is <tt>true</tt>.<tt> </tt>
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class TimeDuration&gt;
   bool timed_lock(const TimeDuration&amp; rel_t);
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <tt>timed_lock(rel_t)</tt> on the referenced mutex. 
                 If the resolution of TimeDuration is greater than the native 
                 resolution the time is rounded up to the nearest native resolution.
</p>
<p>
<i>Returns:</i>  The result of the call to <tt>timed_lock(rel_t)</tt> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <tt>owns_lock() == </tt>The result of the call to <tt>timed_lock(rel_t)</tt> on the referenced mutex.
</p>
<p>
<i>Throws:</i> <tt>lock_error</tt>, if on entry <tt>owns_lock()</tt> is <tt>true</tt>.</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void unlock();
</pre>
<blockquote>
<p>
<i>Effects:</i>  Calls <tt>void unlock()</tt> on the referenced mutex.
</p>
<p>
<i>Postcondition:</i> <tt>owns_lock() == false</tt>.
</p>
<p>
<i>Throws:</i> <tt>lock_error</tt>, if on entry <tt>owns_lock()</tt> is <tt>false</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool owns_lock() const;
</pre>
<blockquote>
<p>
<i>Returns:</i>  <tt>true</tt> if <tt>this</tt> owns a lock on a referenced mutex, else <tt>false</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>operator unspecified-bool-type () const;
</pre>
<blockquote>
<p>
<i>Returns:</i>  Non-null if <tt>owns_lock()</tt> would return <tt>true</tt>, else returns null.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>mutex_type* mutex() const;
</pre>
<blockquote>
<p>
<i>Returns:</i>  A pointer to the referenced mutex, or null if there is no referenced mutex.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void swap(unique_lock&amp;&amp; u);
</pre>
<blockquote>
<p>
<i>Effects:</i>  Swaps state with <tt>u</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>mutex_type* release();
</pre>
<blockquote>
<p>
<i>Returns:</i>  A pointer to the referenced mutex, or null if there is no referenced mutex.
</p>
<p>
<i>Postcondition:</i>
</p>
<blockquote><pre>mutex() == 0
owns_lock() == false
</pre></blockquote>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;&amp; x, unique_lock&lt;Mutex&gt;&amp;  y);
template &lt;class Mutex&gt; void swap(unique_lock&lt;Mutex&gt;&amp;  x, unique_lock&lt;Mutex&gt;&amp;&amp; y);
</pre>
<blockquote>
<p>
<i>Effects:</i>  <tt>x.swap(y)</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<h3>Generic Locking Algorithms</h3>

<blockquote>
<pre>template &lt;class L1, class L2, class ...L3&gt; int try_lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
<p>
<i>Requires:</i>  Each template parameter type must supply the following member functions with semantics
corresponding to the Mutex concept, except that <tt>try_lock</tt> is allowed to throw an
exception. <i>[Note:</i> The <tt>unique_lock</tt> class template meets these requirements 
when suitable instantiated. <i>--end note]</i></p>
<blockquote><pre>bool try_lock();
void unlock();
</pre></blockquote>
<p>
<i>Effects:</i> The functions attempts to lock all arguments without blocking by calling <tt>try_lock()</tt>
on each of them.  If any argument can not be locked, then all arguments which have already been locked will
be unlocked.  On return, either all arguments will be locked, or none of them will be locked.  If an
exception is thrown by a call to <tt>try_lock()</tt>, there are no effects.
</p>
<p>
<i>Returns:</i> If all arguments were successfully locked, returns <code>-1</code>.  Otherwise returns a 0-based index 
value indicating
which argument failed to lock.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class L1, class L2, class ...L3&gt; void lock(L1&amp;, L2&amp;, L3&amp;...);
</pre>
<blockquote>
<p>
<i>Requires:</i>  Each template parameter type must supply the following member functions with semantics
corresponding to the Mutex concept, except that <tt>try_lock</tt> is allowed to 
throw an exception <i>[Note:</i> The <tt>unique_lock</tt> class template meets these requirements 
when suitable instantiated. <i>--end note]</i></p>
<blockquote><pre>void lock();
bool try_lock();
void unlock();
</pre></blockquote>
<p>
<i>Effects:</i> All arguments are locked with an algorithm that avoids deadlock.
If an exception is thrown by a call to <tt>lock()</tt> or <tt>try_lock()</tt>, there are no effects.
</p>
</blockquote>
</blockquote>

<h3><a name="ConditionVariablesWording">Condition variables</a></h3>

<b>&lt;condition_variable&gt; synopsis</b>

<blockquote><pre>namespace std {

class condition_variable;
class condition_variable_any;

}  // std
</pre></blockquote>

<h4>Class condition_variable</h4>

<p>
An object of class <tt>condition_variable</tt> is a synchronization primitive 
used to cause a thread of execution to wait until notified by some other 
thread of execution that some condition is met, or a UTC[(?)] time is reached.
</p>

<p>
If and only if the condition variable type is internally represented by an object
which can be passed to operating system specific interfaces, then there shall be a 
implementation-defined member typedef <tt>native_handle_type</tt> that is an alias 
to this native type, if it is copyable, or if the native type is not copyable, 
a pointer to this native type.  The implementation shall document whether the 
<tt>native_handle_type</tt> member typedef is present.
</p>

<p>
If the nested typedef <tt>native_handle_type</tt> exists, then there
also shall be a member function <tt>native_handle()</tt> which returns the
underlying representation. 
</p>

<blockquote><pre>namespace std {

class condition_variable
{
public:
    typedef <i>implementation-defined</i> native_handle_type;
    
    condition_variable();
    ~condition_variable();

    condition_variable(const condition_variable&amp;) = delete;
    condition_variable&amp; operator=(const condition_variable&amp;) = delete;

    void notify_one();
    void notify_all();
    void wait(unique_lock&lt;mutex&gt;&amp; lock);
    template &lt;class Predicate&gt;
        void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
    bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time);
    template &lt;class Predicate&gt;
        bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time, Predicate pred);
    native_handle_type native_handle();
};

}  // std
</pre></blockquote>

<blockquote>
<pre>condition_variable();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>condition_variable</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>~condition_variable();
</pre>
<blockquote>
<p>
<i>Effects:</i> Destroys the object.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_one();
</pre>
<blockquote>
<p>
<i>Effects:</i> If any threads of execution are blocked waiting for <code>*this</code>, 
unblocks at least one those threads of execution.</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition_variable</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_all();
</pre>
<blockquote>
<p>
<i>Effects:</i> Unblock all threads of execution that are blocked waiting for <code>*this</code>.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition_variable</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
<p>
<i>Precondition:</i> <tt>lock</tt> is locked by the current thread of execution.  No
other thread of execution is waiting on this <tt>condition_variable</tt> object unless <tt>lock</tt>
refers to the same underlying <tt>mutex</tt> object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<tt>lock</tt>. If the <tt>wait</tt> should throw an exception for any
reason, <tt>lock</tt> will be locked as the exception propagates. 
This thread of execution shall unblock when another threadof execution issues a
notification to this blocked thread of execution. The current thread of execution may
unblock and return even in the absence of a notification.
</p>
<p>
<i>Postcondition:</i> <tt>lock</tt> is locked by the current 
thread of execution.</p>
<p>
<i>Throws:</i> May throw <tt>system_error</tt> if a precondition is not met.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition_variable</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Predicate&gt;
    void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> While <tt>pred()</tt> returns <tt>false</tt> calls <tt>wait(lock)</tt>.
</p>
<p>
<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>.
</p>
</blockquote>
</blockquote>


<blockquote>
<pre>bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time);
</pre>
<blockquote>
<p>
<i>Precondition:</i>  The <tt>lock</tt> is locked by the current thread of execution.  No
other thread of execution is waiting on this <tt>condition_variable</tt> object unless <tt>lock</tt>
refers to, the same underlying <tt>mutex</tt> object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<tt>lock</tt>. If the <tt>timed_wait</tt> should throw an exception for
any reason, <tt>lock</tt> will be locked as the exception propagates
out.  If the absolute time specified by <tt>abs_time</tt> passes (that
is, system time equals or exceeds <tt>abs_time</tt>) before the
<tt>condition_variable</tt> is notified, or if the absolute time specified by
<tt>abs_time</tt> has already been passed at the time of the call, then
<tt>false</tt> is returned. This thread of execution shall unblock when
another thread of execution  issues a notification to this blocked thread of execution. The current
thread of execution may unblock and return even in the absence of a
notification.
</p>
<p>
<i>Postcondition:</i> <tt>lock</tt> is locked by the current 
thread of execution.</p>
<p>
<i>Returns:</i> <tt>true</tt> if the call to <tt>timed_wait</tt> is notified prior
to the indicated timeout,
otherwise returns <tt>false</tt>.
</p>
<p>
<i>Throws:</i> May throw <tt>system_error</tt> if a precondition is not met.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition_variable</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Predicate&gt;
    bool timed_wait(unique_lock&lt;mutex&gt;&amp; lock, const system_time&amp; abs_time, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> As if:
</p>
<blockquote><pre>while (!pred())
{
    if (!timed_wait(lock, abs_time))
        return pred();
}
return true;
</pre></blockquote>
<p>
<i>Returns:</i> <tt>pred()</tt>.
</p>
<p>
<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>, even
if the timeout has already expired.  The return value indicates whether the predicate
evaluates to <tt>true</tt>, regardless of whether the timeout was triggered.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>native_handle_type native_handle();
</pre>
<blockquote>
<p>
<i>Returns:</i> the representation of the underlying object used to implement <tt>*this</tt>.
</p>
</blockquote>
</blockquote>


<p>
<tt>condition_variable</tt> shall be a standard-layout type ([?]).
</p>

<h4>Class condition_variable_any</h4>

<p>
An object of class <tt>condition_variable_any</tt> is a synchronization primitive 
used to cause a thread of execution to wait until notified by some other 
thread of execution that some condition is met, or a UTC[(?)] time is reached.
</p>

<p>
The <tt>Lock</tt> type must support member functions <tt>lock</tt>
and <tt>unlock</tt> with the semantics of the mutex concept.  All of the standard mutex types
meet this requirement.
</p>

<p>
If and only if the <tt>condition_variable_any</tt> type is internally represented by an 
an object or objects which can be passed to operating system specific interfaces, then 
there shall be a nested implementation-defined typedef <tt>native_handle_type</tt> that 
is an alias to a type providing access to the object or objects.  The type 
<tt>native_handle_type</tt> must be copyable; if the object or objects are not copyable, 
<tt>native_handle_type</tt> must be a pointer type.  The implementation shall document 
whether the <tt>native_handle_type</tt> typedef is present.
</p>

<p>
If the nested typedef <tt>native_handle_type</tt> exists, then there
also shall be a member function <tt>native_handle()</tt> which returns the
underlying representation. 
</p>

<blockquote><pre>namespace std {

class condition_variable_any
{
public:
    typedef <i>implementation-defined</i> native_handle_type;
    condition_variable_any();
    ~condition_variable_any();

    condition_variable_any(const condition_variable_any&amp;) = delete;
    condition_variable_any&amp; operator=(const condition_variable_any&amp;) = delete;

    void notify_one();
    void notify_all();
    template &lt;class Lock&gt;
        void wait(Lock&amp; lock);
    template &lt;class Lock, class Predicate&gt;
        void wait(Lock&amp; lock, Predicate pred);
    template &lt;class Lock&gt;
        bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time);
    template &lt;class Lock, class Predicate&gt;
        bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time, Predicate pred);
    native_handle_type native_handle();
};

}  // std
</pre></blockquote>

<blockquote>
<pre>condition_variable_any();
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>condition_variable_any</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>~condition_variable_any();
</pre>
<blockquote>
<p>
<i>Effects:</i> Destroys the object.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_one();
</pre>
<blockquote>
<p>
<i>Effects:</i> If any threads of execution are blocked waiting for <code>*this</code>, 
unblocks at least one those threads of execution.</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition_variable_any</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void notify_all();
</pre>
<blockquote>
<p>
<i>Effects:</i> Unblock all threads  of execution that are blocked waiting for <code>*this</code>.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition_variable_any</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>void wait(Lock&amp; lock);
</pre>
<blockquote>
<p>
<i>Precondition:</i> <tt>lock</tt> is locked by the current thread of execution.  If
<tt>Lock</tt> supports recursive locking, the lock count is one.  No
other thread of execution is waiting on this <tt>condition_variable_any</tt> object unless <tt>lock</tt>
is, or refers to, the same underlying mutex object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<tt>lock</tt>. If the <tt>wait</tt> should throw an exception for any
reason, <tt>lock</tt> will be locked as the exception propagates. 
This thread of execution shall unblock when another thread of execution issues a
notification to this blocked thread of execution. The current thread of execution may
unblock and return even in the absence of a notification.
</p>
<p>
<i>Postcondition:</i> <tt>lock</tt> is locked by the current 
thread of execution.</p>
<p>
<i>Throws:</i> May throw <tt>system_error</tt>.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition_variable_any</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class Predicate&gt;
    void wait(lock_type&amp; lock, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> While <tt>pred()</tt> returns <tt>false</tt>, calls <tt>wait(lock)</tt>.
</p>
<p>
<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>.
</p>
</blockquote>
</blockquote>


<blockquote>
<pre>bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time);
</pre>
<blockquote>
<p>
<i>Precondition:</i>  The <tt>lock</tt> is locked by the current thread of execution.  If
<tt>Lock</tt> supports recursive locking, the lock count is one.  No
other thread of execution is waiting on this <tt>condition_variable_any</tt> object unless <tt>lock</tt>
is, or refers to, the same underlying mutex object.
</p>
<p>
<i>Effects:</i> Atomically blocks and releases the lock on
<tt>lock</tt>. If the <tt>timed_wait</tt> should throw an exception for
any reason, <tt>lock</tt> will be locked as the exception propagates
out.  If the absolute time specified by <tt>abs_time</tt> passes (that
is, system time equals or exceeds <tt>abs_time</tt>) before the
<tt>condition_variable_any</tt> is notified, or if the absolute time specified by
<tt>abs_time</tt> has already been passed at the time of the call, then
<tt>false</tt> is returned. This thread of execution shall unblock when
another thread of execution issues a notification to this blocked thread of execution. The current
thread of execution may unblock and return even in the absence of a
notification.
</p>
<p>
<i>Postcondition:</i> <tt>lock</tt> is locked by the current 
thread of execution.</p>
<p>
<i>Returns:</i> <tt>true</tt> if the call to <tt>timed_wait</tt> is notified prior
to the indicated timeout,
otherwise returns <tt>false</tt>.
</p>
<p>
<i>Throws:</i> May throw <tt>system_error</tt>.
</p>
<p>
<i>Thread safety:</i> Calls to the <code>wait</code>,
<code>timed_wait</code>, <code>notify_one</code> or
<code>notify_all</code> member functions of the same <tt>condition_variable_any</tt>
object from different threads of execution shall not result in data
races or deadlocks.
</blockquote>
</blockquote>

<blockquote>
<pre>template &lt;class _Predicate&gt;
    bool timed_wait(Lock&amp; lock, const system_time&amp; abs_time, Predicate pred);
</pre>
<blockquote>
<p>
<i>Effects:</i> As if:
</p>
<blockquote><pre>while (!pred())
{
    if (!timed_wait(lock, abs_time))
        return pred();
}
return true;
</pre></blockquote>
<p>
<i>Returns:</i> <tt>pred()</tt>.
</p>
<p>
<i>Note:</i> There is no blocking if <tt>pred()</tt> is initially <tt>true</tt>, even
if the timeout has already expired.  The return value indicates whether the predicate
evaluates to <tt>true</tt>, regardless of whether the timeout was triggered.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>native_handle_type native_handle();
</pre>
<blockquote>
<p>
<i>Returns:</i> the representation of the underlying object or objects used to implement <tt>*this</tt>.
</p>
</blockquote>
</blockquote>

<hr/>


<h2><a name="DateTime"></a>Chapter ?&nbsp;&nbsp; Date Time Library</h2>

<hr/>
 This clause describes components for determining and manipulating temporal values.
 A <i>time point</i> represents a dimensionless instant 
 in the time continuum. A <i>time duration</i> represents a length of time 
 unattached to any time point. Time points and time durations have a 
 <i>resolution</i> which is their smallest representable time duration.  Time points
 have an <i>epoch</i> or start of a given time scale. For time_t the epoch is 
 1970-01-01 00:00:00.


<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.header__date_time__synopsis"></a>
Header &lt;date_time&gt; Synopsis</h3></div></div></div>

<blockquote><pre>namespace std 
{

  //duration types
  class    hours;
  class    minutes;
  class    seconds;
  class    milliseconds;
  class    microseconds;
  class    nanoseconds;

  //timepoint   
  class system_time;

  //functions
  system_time get_system_time();

} //std
</class></pre></blockquote>

</div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_utc_time"></a>class system_time</h3></div></div></div>


<p>
        The class <tt>system_time</tt> provides a time point that represents the current
        Coordinated Universal Time, known as UTC, time.
        <tt>system_time</tt> shall provide an epoch time of 1970-01-01 00:00:00.000000000
        and a maximum time value of at least epoch time + 292 years.
</p><p>
        class <tt>system_time</tt> shall be EqualityComparable, LessThanComparable, 
        CopyConstructable, DefaultConstructable, and Assignable.
</p>


<blockquote><pre>
class system_time 
{
 public:

  system_time();
  system_time(time_t, nanoseconds ns);
  ~system_time();

  time_t seconds_since_epoch() const;
  nanoseconds nanoseconds_since_epoch() const;

  //traits 
  typedef 'implementation defined' tick_type;
  static tick_type ticks_per_second();
  static tick_type seconds_per_tick();
  static bool is_subsecond();

  //comparison functions
  bool operator==(const system_time&amp; rhs) const;
  bool operator!=(const system_time&amp; rhs) const;
  bool operator&gt;(const system_time&amp; rhs) const;
  bool operator&gt;=(const system_time&amp; rhs) const;
  bool operator&lt;(const system_time&amp; rhs) const;
  bool operator&lt;=(const system_time&amp; rhs) const;

  //arithmetic functions
  nanoseconds operator-(const system_time&amp; rhs) const

  template&lt;typename TimeDuration&gt;
  system_time operator+(const TimeDuration&amp; td) const;

  template&lt;typename TimeDuration&gt;
  system_time&amp; operator+=(const TimeDuration&amp; td);

  template&lt;typename TimeDuration&gt;
  system_time operator-(const TimeDuration&amp; td) const;

  template&lt;typename TimeDuration&gt;
  system_time&amp; operator-=(const TimeDuration&amp; td) 

};
</pre></blockquote>

<blockquote class="note">
<p>
<h3 class="title">Note</h3><p>
          292 years represents the number of nanoseconds that can be represented 
         in a signed 64 bit integer.
</p></blockquote>

<pre class="programlisting">
<span class="identifier">system_time</span><span class="special">();</span></pre><p>
        <i>Effects:</i> Constructs a system_time
        object representing the epoch time point 1970-01-01 00:00:00.000000000
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">system_time</span><span class="special">(</span><span class="identifier">time_t</span> <span class="identifier">secs</span><span class="special">,</span> <span class="identifier">nanoseconds</span> <span class="identifier">ns</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Construct<span class="underline">s</span> a utc
        time object representing the time point that is secs + 1,000,000,000*ns after the epoch.
      </p><p>
        <i>Remarks:</i> If the total nanoseconds &gt; 1 second the seconds are
        incremented appropriately.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting">
<span class="identifier">time_t</span> <span class="identifier">seconds_since_epoch</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> The count of seconds since 1970-01-01 00:00:00.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">nanoseconds</span> <span class="identifier">nanoseconds_since_epoch</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> The count of <span class="underline">nano</span>seconds
        since 1970-01-01 00:00:00.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1000000000
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Remarks:</i> Since this is a subsecond type it returns 0 for seconds_per_tick.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> true.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if 
        the <span class="underline">time
        represented by *this is equal to the time represented by rhs</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if the <span class="underline">time represented by *this is not equal to the time represented
        by rhs</span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if time <span class="underline">represented by
        *this is greater than the time represented by rhs</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;=(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if time <span class="underline">represented
        by *this is greater or equal than the time represented by rhs</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if time <span class="underline">represented by *this
        is less than the time represented by rhs</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;=(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if time <span class="underline">represented by *this
        is less or equal than the time represented by rhs</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">nanoseconds</span> <span class="keyword">operator</span><span class="special">-(</span><span class="keyword">const</span> <span class="identifier">system_time</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i>  <span class="underline">
        The difference in nanoseconds between the time represented by *this and the
        time represented by rhs.</span>
      </p><p>
        <i>Remarks:</i> If rhs is greater the result will be a negative nanosecond.
        count.</em></span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
<span class="identifier">system_time</span> <span class="keyword">operator</span><span class="special">+(</span><span class="keyword">const</span> <span class="identifier">TimeDuration</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> The duration converted to nanosecond resolution
        and added to the time <span class="underline">represented by *this</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
<span class="identifier">system_time</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">+=(</span><span class="keyword">const</span> <span class="identifier">TimeDuration</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Convert the duration to nanosecond resolution add to nanoseconds
        to the time represented by *this.
      </p><p>
        <i>Returns:</i> Modified value of this.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
<span class="identifier">system_time</span> <span class="keyword">operator</span><span class="special">-(</span><span class="keyword">const</span> <span class="identifier">TimeDuration</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> The duration converted to nanosecond resolution
        and subtracted from the time <span class="underline">represented by *this</span>.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
<span class="identifier">system_time</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">-=(</span><span class="keyword">const</span> <span class="identifier">TimeDuration</span><span class="special">&amp;</span> <span class="identifier">td</span><span class="special">)</span> 
</pre><p>
        <i>Effects:</i> Convert the duration to nanosecond resolution subtract and
        from the time represented by *this.
      </p><p>
        <i>Returns:</i> Modified value of this.
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>


<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.template_class_hiresolution_clock"></a>function get_system_time</h3></div></div></div>

<p>
        The function <tt>get_system_time</tt> provides access to the system clock at a
        resolution up to nanoseconds. The actual resolution may vary from platform to platform. 
</p>


<blockquote><pre>
  system_time get_system_time();
</pre></blockquote>


<blockquote class="note">
<p>
</p><i><h3 class="title">Comment (not for inclusion in WP)</h3><p>
    Typical personal computer platforms currently achieve microsecond level
    resolution from calls to the clock. The <a href="http://www.boost.org/libs/date_time/index.html" target="_top">Boost Date-Time Library</a> has a class that portably implements the proposed
    interface, but it uses different C-level interfaces depending on the operating
    system.</i>
        </p></blockquote>


<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.common_duration_functions"></a>Common Duration Functions</h3></div></div></div>

<p>
        The following functions are common functions to all durations types. These
        functions provide the basis for durations to be EqualityComparable, LessThanComparable
        as well arithmetic operations.
      </p><p>
        In the following text duration_type refers to the containing duration type.
      </p>
<p>
        All duration types are EqualityComparable, LessThanComparable, 
        CopyConstructable, DefaultConstructable, and Assignable for duration
        objects of the same type. 
</p>


<blockquote><pre>
class TimeDuration { 

    //comparison operators
    template&lt;typename RhsTimeDuration&gt;
    bool operator&lt;  (const RhsTimeDuration&amp;) const;

    template&lt;typename RhsTimeDuration&gt;
    bool operator&lt;= (const RhsTimeDuration&amp;) const;

    template&lt;typename RhsTimeDuration&gt;
    bool operator&gt;  (const RhsTimeDuration&amp;) const;

    template&lt;typename RhsTimeDuration&gt;
    bool operator&gt;= (const RhsTimeDuration&amp;) const;

    template&lt;typename RhsTimeDuration&gt;
    bool operator== (const RhsTimeDuration&amp;) const;

    template&lt;typename RhsTimeDuration&gt;
    bool operator!= (const RhsTimeDuration&amp;) const;


    //sign inversion
    TimeDuration operator-() const

    //arithmetic operations
    template&lt;typename RhsTimeDuration&gt;
    TimeDuration operator- (const RhsTimeDuration&amp; d) const

    template&lt;typename RhsTimeDuration&gt;
    TimeDuration operator-=(const RhsTimeDuration&amp; d)

    template&lt;typename RhsTimeDuration&gt;
    TimeDuration operator+ (const RhsTimeDuration&amp; d) const

    template&lt;typename RhsTimeDuration&gt;
    TimeDuration operator+=(const RhsTimeDuration&amp; d)

    TimeDuration operator/ (int divisor) const
    TimeDuration operator/=(int divisor) 
    TimeDuration operator* (int rhs) const
    TimeDuration operator*=(int divisor) 

    tick_type get_count() const 

}
</pre></blockquote>
<p>
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsTimeDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">RhsTimeDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if rhs duration is greater.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsTimeDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span><span class="keyword">const</span> <span class="identifier">RhsTimeDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if rhs is not the same time.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsTimeDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;(</span><span class="keyword">const</span> <span class="identifier">RhsTimeDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if the rhs duration is larger.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsTimeDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&gt;=(</span><span class="keyword">const</span> <span class="identifier">RhsTimeDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if greater or equal than the rhs duration.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsTimeDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;(</span><span class="keyword">const</span> <span class="identifier">RhsTimeDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if less than the rhs duration.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsTimeDuration</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">&lt;=(</span><span class="keyword">const</span> <span class="identifier">RhsTimeDuration</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre><p>
        <i>Returns:</i> True if less or equal to the rhs duration.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="comment">//sign inversion
</span><span class="identifier">TimeDuration</span> <span class="keyword">operator</span><span class="special">-()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> Negated value of the duration.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="comment">//arithmetic operations
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsTimeDuration</span><span class="special">&gt;</span>
<span class="identifier">TimeDuration</span> <span class="keyword">operator</span><span class="special">-</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">RhsTimeDuration</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> A duration value equal to this-rhs_duration.
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the RhsTimeDuration is
        of higher resolution.</em></span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsTimeDuration</span><span class="special">&gt;</span>
<span class="identifier">TimeDuration</span> <span class="keyword">operator</span><span class="special">-=(</span><span class="keyword">const</span> <span class="identifier">RhsTimeDuration</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span>
</pre><p>
        <i>Effects:</i> Modifies to value equal to this-rhs_duration. 
      </p><p>
        <i>Returns:</i> this 
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the RhsTimeDuration is
        of higher resolution.</em></span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsTimeDuration</span><span class="special">&gt;</span>
<span class="identifier">TimeDuration</span> <span class="keyword">operator</span><span class="special">+</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">RhsTimeDuration</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> Duration equal to this+rhs_duration.
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the RhsTimeDuration is
        of higher resolution.</em></span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">RhsTimeDuration</span><span class="special">&gt;</span>
<span class="identifier">TimeDuration</span> <span class="keyword">operator</span><span class="special">+=(</span><span class="keyword">const</span> <span class="identifier">RhsTimeDuration</span><span class="special">&amp;</span> <span class="identifier">d</span><span class="special">)</span>
</pre><p>
        <i>Effects:</i> Modifies to value equal to this+rhs_duration. 
      </p><p>
        <i>Returns:</i> this 
      </p><p>
        <span class="emphasis"><em>Remarks: This will fail to compiler if the RhsTimeDuration is
        of higher resolution.</em></span>
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">TimeDuration</span> <span class="keyword">operator</span><span class="special">/</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">divisor</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> Duration with value equal to this/divisor according to
        integer arithmetic rules.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">TimeDuration</span> <span class="keyword">operator</span><span class="special">/=(</span><span class="keyword">int</span> <span class="identifier">divisor</span><span class="special">)</span> 
</pre><p>
        <i>Effects:</i> Change value of this by this/divisor according to integer
        arithmetic rules.
      </p><p>
        <i>Returns:</i> this 
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">TimeDuration</span> <span class="keyword">operator</span><span class="special">*</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> Duration with value equal to this*rhs 
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">TimeDuration</span> <span class="keyword">operator</span><span class="special">*=(</span><span class="keyword">int</span> <span class="identifier">rhs</span><span class="special">)</span> 
</pre><p>
        <i>Effects:</i> Modifies to value equal to this*rhs. 
      </p><p>
        <i>Returns:</i> this 
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">tick_type</span> <span class="identifier">get_count</span><span class="special">()</span> <span class="keyword">const</span> 
</pre><p>
        <i>Returns:</i> The count at the resolution of the time duration
        type.
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_nanoseconds"></a>class nanoseconds</h3></div></div></div>

<p>
Objects of class <tt>nanoseconds</tt> can be used to represent a count of nanoseconds.
</p>

<blockquote><pre>
class nanoseconds 
{
 public:

   nanoseconds(long long=0);
   nanoseconds(const nanoseconds& rhs);
   ~nanoseconds();

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions

};
</pre></blockquote>

<pre class="programlisting">
<span class="identifier">nanoseconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Constructs an object with a count of nanoseconds - default
        is zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">nanoseconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">nanoseconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1000000000
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> true
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_microseconds"></a>class microseconds</h3></div></div></div>

<p>
Objects of class <tt>microseconds</tt> can be used to represent a count of microseconds.
</p>

<blockquote><pre>
class microseconds 
{
 public:

   microseconds(long long=0);
   microseconds(const microseconds&amp; rhs);
   ~microseconds();

   //conversions
   operator nanoseconds() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions

};

</pre></blockquote>

<pre class="programlisting">
<span class="identifier">microseconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Constructs an object with a count of microseconds - default
        is zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">microseconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">microseconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting">
<span class="comment">//conversions
</span><span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> microsecond count converted to nanoseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1000000
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> true
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_milliseconds"></a>class milliseconds</h3></div></div></div>


<p>
Objects of class <tt>milliseconds</tt> can be used to represent a count of milliseconds.
</p>

<blockquote><pre>
class milliseconds
{
 public:
   milliseconds(long long=0);
   milliseconds(const milliseconds&amp; rhs);
   ~milliseconds();

   //conversions
   operator nanoseconds() const;
   operator microseconds() const;

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions
};
</pre></blockquote>

<pre class="programlisting">
<span class="identifier">milliseconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Constructs an object with a count of milliseconds - default
        is zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">milliseconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">milliseconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> millisecond count converted to nanoseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> millisecond count converted to microseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1000
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> true
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_seconds"></a>class seconds</h3></div></div></div>

<p>
Objects of class <tt>seconds</tt> can be used to represent a count of seconds.
</p>

<blockquote><pre>
class  seconds 
{ 
 public:
   seconds(long long s=0);
   seconds(const seconds&amp; rhs);
   ~seconds();

   //conversions
   operator nanoseconds() const
   operator microseconds() const
   operator milliseconds() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions

};
</pre></blockquote>

<pre class="programlisting">
<span class="identifier">seconds</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of seconds - default is
        zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">seconds</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">seconds</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> second count converted to nanoseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> second count converted to microseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">milliseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> second count converted to milliseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 1
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> false
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div>

<div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_minutes"></a>class minutes</h3></div></div></div>


<p>
Objects of class <tt>minutes</tt> can be used to represent a count of minutes.
</p>

<blockquote><pre>
class  minutes 
{
 public:
   minutes(long long s=0);
   minutes(const minutes&amp; rhs);
   ~minutes();

   //conversions
   operator nanoseconds() const
   operator microseconds() const
   operator milliseconds() const
   operator seconds() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions

};
</pre></blockquote>
<pre class="programlisting">
<span class="identifier">minutes</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of minutes - default is
        zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">minutes</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">minutes</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> minute count converted to nanoseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> minute count converted to microseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">milliseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> minute count converted to milliseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">seconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> minute count converted to seconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 60
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> false
      </p><p>
        <i>Throws:</i> Nothing.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="n2411_07_0271___proposal_for_date_time_types_in_c__0x_to_support_threading_apis_v2.proposed_text.class_hours"></a>class hours</h3></div></div></div>

<p>
Objects of class <tt>hours</tt> can be used to represent a count of hours.
</p>

<blockquote><pre>
class  hours 
{
 public:
   hours(long long s=0);
   hours(const hours&amp; rhs);
   ~hours();

   //conversions
   operator nanoseconds() const
   operator microseconds() const
   operator milliseconds() const
   operator seconds() const
   operator minutes() const

   //traits information
   static tick_type ticks_per_second();
   static tick_type seconds_per_tick();
   static bool is_subsecond();
   typedef <b><i>implementation-defined</i></b> tick_type;

   //+ common functions

};
</pre></blockquote>


<pre class="programlisting">
<span class="identifier">hours</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">=</span><span class="number">0</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Construct<span class="underline">s</span> a<span class="underline">n object with a</span> count of hours - default is zero.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="identifier">hours</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">hours</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">);</span>
</pre><p>
        <i>Effects:</i> Copy construction.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><p>
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">nanoseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> hour count converted to nanoseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">microseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> hour count converted to microseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">milliseconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> hour count converted to milliseconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">seconds</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns:</i> hour count converted to seconds
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">operator</span> <span class="identifier">minutes</span><span class="special">()</span> <span class="keyword">const</span>
</pre><p>
        <i>Returns: </i> hour count converted to seconds.
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">ticks_per_second</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 0
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="identifier">tick_type</span> <span class="identifier">seconds_per_tick</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> 3600
      </p><p>
        <i>Throws:</i> Nothing.
      </p><pre class="programlisting">
<span class="keyword">static</span> <span class="keyword">bool</span> <span class="identifier">is_subsecond</span><span class="special">();</span>
</pre><p>
        <i>Returns:</i> false
      </p><p>
        <i>Throws:</i> Nothing.
      </p>


<h2><a name="References">References</a></h2>
<ul>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1682.html">
  N1682</a>, A Multi-threading Library for Standard C++, Pete Becker.</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1815.html">
  N1815</a>, ISO C++ Strategic Plan for Multithreading, Lawrence Crowl.</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1883.pdf">
  N1883</a>, Preliminary Threading Library Proposal for TR2, Kevlin Henney.</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1907.html">
  N1907</a>, A Multi-threading Library for Standard C++, Revision 1 Pete Becker</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2043.html">
  N2043</a>, Simplifying And Extending Mutex and Scoped Lock Types For C++ 
  Multi-Threading Library, Ion Gaztaaga</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2090.html">
  N2090</a>, A Threading API for C++, Peter Dimov</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2094.html">
  N2094</a>, Multithreading API for C++0X - A Layered Approach, Howard Hinnant</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2139.html">
  N2139</a>, Thoughts on a Thread Library for C++, Anthony Williams</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2178.html">
  N2178</a>, Proposed Text for Chapter 30, Thread Support Library, Peter Dimov</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html">
  N2184</a>, Thread Launching for C++0X, Howard Hinnant</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2285.html">
  N2285</a>, A Multi-threading Library for Standard C++, Revision 2, Pete Becker</li>
  <li>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2411.html">
  N2411</a>, Proposal for Date-Time Types in C++0x To Support Threading APIs v2, Jeff Garland</li>
  <li>
  <a href="http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=40874">
  ISO 8601: 2004</a>Data elements and interchange formats -- Information interchange -- Representation of dates and times</li>


</ul>


<h2><a name="Acknowledgments"></a>Acknowledgments</h2>

<p>
The overall design of this threading library is based on William Kempf's 
Boost.Thread Library, as refined by literally hundreds of other Boost users and 
contributors. Dinkumware and Metrowerks (now Freescale) implementations of 
Boost.Thread, developed respectively by Pete Becker and Howard Hinnant, created 
further existing practice. Proposals by Pete Becker, Peter Dimov, Ion Gaztaaga, 
and Anthony Williams were also influential. Peter, Ion, and Anthony also 
contributed numerous critiques, suggestions, and comments on the current 
proposal, as did other members of an ad hoc threads working group. Jeff Garland 
contributed the date time portions of the proposal based on the Boost.DateTime 
Library and his TR2 proposals.
</p>

</div></body></html><ins class="diff">
</ins>
