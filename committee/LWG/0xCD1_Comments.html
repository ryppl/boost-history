<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<meta name="generator" content=
"Microsoft FrontPage 5.0">
<meta name="generator" content="Microsoft FrontPage 5.0">
<meta http-equiv="CONTENT-TYPE" content=
"text/html; charset=us-ascii">
<title>C++0x CD1 NB Comments</title>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="AUTHOR" content="dow">
<meta name="CREATED" content="20090221;19590000">
<meta name="CHANGEDBY" content=" Barry E Hedquist">
<meta name="CHANGED" content="20090222;18460000">
<meta name="DESCRIPTION" content="FORM (ISO)">
<style type="text/css">
        <!--
                @page { size: 11.69in 8.27in; margin-right: 0.59in }
                P { margin-bottom: 0.08in; direction: ltr; color: #000000; text-align: left; widows: 2; orphans: 2 }
                P.western { font-family: "Arial", sans-serif; font-size: 10pt; so-language: en-US }
                P.cjk { font-family: "Times New Roman", serif; font-size: 10pt }
                P.ctl { font-family: "Arial", sans-serif; font-size: 10pt; so-language: ar-SA }
                TT { font-family: "DejaVu Sans Mono", "Consolas", monospace }
        -->
</style>
<body lang="en-US" text="#000000" dir="ltr">
<div type="HEADER">
<table border="1" bordercolor="#000000" cellpadding="7"
cellspacing="0" style="border-collapse: collapse">
<tr valign="top">
<td>
<p>1
<td>
<p>2
<td>
<p>3
<td>
<p>4
<td>
<p>5
<td>
<p>6
<td>
<p>7
<tr valign="top">
<td>
<p><b>MB</b><sup><b>1</b></sup><b><br></b><br>
<td>
<p><b>Clause No./<br>
Subclause No./<br>
Annex<br></b>(e.g. 3.1)
<td>
<p><b>Paragraph/<br>
Figure/Table/Note<br></b>(e.g. Table 1)
<td>
<p><b>Type of com-ment</b><sup><b>2</b></sup>
<td>
<p><b>Comment (justification
for change) by the MB</b>
<td>
<p><b>Proposed change by the
MB</b>
<td>
<p lang="en-GB" align="center" style=
"margin-top: 0.07in; margin-bottom: 0.04in; page-break-inside: avoid">
<b>Disposition</b>
<p><br>
<tr valign="top">
<td>
<p>FR 1
<td>
<p>General Comment
<td>
<p><br>
<td>
<p>ge
<td>
<p style="margin-bottom: 0in">Interactions between several new features
appear obscure, and very few examples are offered to guide
understanding of the formal text on interaction between these new
additions.
<p style="margin-bottom: 0in">We worry about the complexity of the
programming model so created.
<p style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 1
<td>
<p lang="en-GB" align="left">1-16
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">ge/te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The active issues identified in WG21
N2803, C++ Standard Core Language Active Issues, must be addressed
and appropriate action taken.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
<font color="#000080"><u><a href=
"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html</a></u></font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Appropriate action would include making
changes to the CD, identifying an issue as not requiring a change
to the CD, or deferring the issue to a later point in time.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>CA-1
<td>
<p><br>
<td>
<p><br>
<td>
<p>Ge
<td>
<p>There are quite a number
of defects for the current CD recorded in SC22/WG21-N2803 and
N2806
<td>
<p>Consider these comments
and update ISO/IEC CD 14882 accordingly
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>DE-1
<td>
<p>1 through 16
<td>
<p><br>
<td>
<p>ge/te
<td>
<p>DE-1 Consider addressing a
significant part of the unresolved core language issues presented
in WG21 document N2791 "C++ Standard Core Language Active Issues,
Revision 59", available at
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2791.html
.
<td>
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>CH 2
<td>
<p>all
<td>
<p><br>
<td>
<p>te
<td>
<p>The issues on the issues
lists shall be addressed before the standard becomes final.
<td>
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 3
<td>
<p lang="en-GB" align="left">all
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">ed
<td>
<p>Latin abbreviations are
presented incorrectly.
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Italicize all Latin
abbreviations, append commas after each occurrence of <i>i.e</i>.
and <i>e.g.</i>, and remove extraneous space after each such
abbreviation.
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 3
<td>
<p>1 [intro.scope]
<td>
<p>2
<td>
<p>ed
<td>
<p>C++ is split at the end of line.
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 4
<td>
<p lang="en-GB" align="left">1.1
<td>
<p lang="en-GB" align="left">2
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left">There is a bad line break in "C++".
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK 1
<td>
<p align="justify">1.1
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left">List of
additional facilities over C has been extended with this standard,
so should be mentioned in the introductory material.
<td>
<p align="left">Add the
following to the list in 1.1p2: atomic operations concurrency
alignment control user-defined literals attributes
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 4
<td>
<p>1.2 [intro.refs]
<td>
<p>1
<td>
<p>ed
<td>
<p>Is the lack of reference to ISO/CEI
9899/AC3:2007 voluntary?
<td>
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK 2
<td>
<p align="justify">1.2
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in"><span lang="en-US">We recommend taking
the latest update to each listed standard, yet the C standard is
quite deliberately held back to the 1990 version without
comment.+</span>
<p align="left"><br>
<td>
<p align="left">... not sure
...
<td>
<p><br>
<tr valign="top">
<td>
<p>UK 3
<td>
<p align="justify">1.3.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">The
definition of an argument does not seem to cover many assumed use
cases, and we believe that is not intentional.
<td>
<p align="left" style="margin-bottom: 0in">Revise the definition of argument to answer
question such as: Are lambda-captures arguments? Are type names in
a throw-spec arguments? 'Argument' to casts, typeid, alignof,
alignas, decltype and sizeof? why in x[arg] : arg is not an
agrument, but the value forwarded to operator[]() is ? Does not
apply to operators as call-points not bounded by parenthises ?
Similar for copy initialization and conversion? what are Deduced
template 'arguments'? what are 'default arguments'? can attributes
have arguments? what about concepts, requires clauses and
concept_map instantiations? What about user-defined literals where
parens are not used?
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK 4
<td>
<p align="justify">1.3.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">This
definition is essentially worthless, as it says nothing about what
distinguished a diagnostic message from other output messages
provided by the implementation
<td>
<p align="left" style="margin-bottom: 0in">... add something about the diagnostic message
being a message issues by the implementation when translating a
program that violates the rules of the standard. ...
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 5
<td>
<p>1.3.4
[defns.dynamic.type]
<td>
<p><br>
<td>
<p>te
<td>
<p>"The dynamic type of an rvalue expression is
its static type." Is this true with rvalue references?
<td>
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 5
<td>
<p>1.3.5
<td>
<p><br>
<td>
<p>te
<td>
<p>The wording is unclear as
to whether it is the input or the implementation "that is not a
well-formed program".
<td>
<p>Reword to clarify that it
is the input that is here considered not well-formed.
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 6
<td>
<p>1.3.6
[defns.impl.defined]
<td>
<p><br>
<td>
<p>ed
<td>
<p>There is a page break between the title and the
paragraph.
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 7
<td>
<p>1.3.13
[defns.undefined]
<td>
<p><br>
<td>
<p>ed
<td>
<p>[intro.execution]/5 explicitly allows non
causal undefined behaviour,
<td>
<p>Adding it to the note outlying possible
undefined behaviours.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 6
<td>
<p lang="en-GB" align="left">1.3.14
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">ge
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Unspecified behavior does not clearly
state whether or not undefined behavior is permitted. (The standard
says that "usually, the range of possible behaviors is delineated",
but what happens if the range is not delineated? Is a crash, or
worse, allowed?)
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">Clearly state whether or not Unspecified behavior
includes undefined behavior.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 8
<td>
<p>1.4
[intro.compliance]
<td>
<p>8
<td>
<p>ed
<td>
<p>The paragraph as its stands seems to require
that violations of the ODR (which make a program ill-formed) are
required to be diagnosed if the program also uses an extension
which defines some cases of ODR.
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK 5
<td>
<p align="justify">1.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Ge
<td>
<p align="left">Missing
checklist of implementation defined behaviour (see ISO/IEC TR
10176, 4.1.1p6)
<td>
<p align="left">Provide a new
annex with the missing checklist
<td>
<p><br>
<tr valign="top">
<td>
<p>UK 6
<td>
<p align="justify">1.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Ge
<td>
<p align="left">Missing annex
describing potential incompatibility to previous edition of the
standard (see ISO/IEC TR 10176, 4.1.1p9)
<td>
<p align="left">Provide a new
annex with the missing documentation. See n2733(08-0243) for a
starting point
<td>
<p><br>
<tr valign="top">
<td>
<p>US 7
<td>
<p>1.5
<td>
<p>2
<td>
<p>ed
<td>
<p>There is no mention of
Clause 17.
<td>
<p>Include Clause 17 among
the list of Clauses that specify the Standard Library.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 8
<td>
<p>1.5
<td>
<p>2
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
The paragraph omits to
mention concepts and concept maps among its list of entities
defined in the Standard Library.
<p><br>
<td>
<p>Mention concepts and
concept maps among the list of entities.
<td>
<p><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 9
<td>
<p lang="en-GB" align="left">1.6
<td>
<p lang="en-GB" align="left">1
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The syntax description does not account
for lines that wrap.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 10
<td>
<p lang="en-GB" align="left">1.7
<td>
<p lang="en-GB" align="left">3
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left">The term thread is used before defined.
<td>
<p lang="en-GB" align="left"><font color=
"#000000">R</font>eference
1.10 [intro.multithread].
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>US 11
<td>
<p>1.7
<td>
<p>&#182; 3 last sent.
<td>
<p>ed
<td>
<p>The phrase &#8220;threads
of execution&#8221; should be accompanied by a reference to
[intro.multithread].
<td>
<p>Insert the recommended
reference.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 12
<td>
<p>1.7
<td>
<p>&#182; 3 first
sent.
<td>
<p>te
<td>
<p>A memory location is not
an object as the sentence claims.
<td>
<p>Clarify that a memory
location &#8220;holds&#8221; an object rather than that it
&#8220;is&#8221; an object.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 13
<td>
<p>1.7
<td>
<p>&#182; 3 last sent.
<td>
<p>te
<td>
<p>It is unclear what is
meant by memory locations that are "separate": are they distinct?
non-overlapping? how much "separation" is needed?
<td>
<p>Provide either a better
definition of &#8220;separate&#8221; or reword (this and subsequent
paragraphs) to avoid this term.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 14
<td>
<p>1.7
<td>
<p>&#182; 4
<td>
<p>te
<td>
<p>The phrase "no matter what
the sizes of the intervening bit-fields happen to be" contradicts
the claim of separation "by a zero-length bit-field
declaration".
<td>
<p>Delete the &#8220;no
matter&#8230;&#8221; phrase, or resolve the contradiction in a
different way.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 15
<td>
<p>1.7
<td>
<p>&#182; 5
<td>
<p>te
<td>
<p>A struct does not
&#8220;contain&#8221; memory locations.
<td>
<p>Reword so that a struct is
&#8220;held in&#8221; one or more memory locations.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 16
<td>
<p>1.9
<td>
<p><br>
<td>
<p><br>
<td>
<p>The discussion of
observable behavior in 1.9 is not consistent with the addition of
threads to the language. Volatile reads and writes and other
observable actions no longer occur in a single
"sequence&#8221;.
<td>
<p>Remove/replace various
occurrences of "sequence" in 1.9.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK 8
<td>
<p align="justify">1.9
<td>
<p align="justify">5
<td>
<p align="justify">Te
<td>
<p align="left">With parallel
execution there is no longer the idea of a single execution
sequence for a program. Instead, a program may be considered a set
of exectution sequences.
<td>
<p align="left">Update first
sentance as: A conforming implementation executing a well-formed
program shall produce the same observable behavior as one of the
possible SETS OF execution sequences of the corresponding instance
of the abstract machine CONFORMING TO THE MEMORY MODEL (1.10) with
the same program and the same input.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK 7
<td>
<p align="justify">1.9
<td>
<p align="justify">6
<td>
<p align="justify">Te
<td>
<p align="left">Does the term
'sequence' imply all reads/writes through volatile memory much be
serialized, and cannot occur in parallel on truly parallel
hardware? Allow for multiple concurrent sequences where each
sequence is constrained by this observable behaviour rule, and
multiple sequences are constrained by the memory model and
happens-before relationships defined in 1.10
<td>
<p align="left">Replace
'sequence' with 'sequences'.
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 9
<td>
<p>1.9
[intro.execution]
<td>
<p>16
<td>
<p>ed
<td>
<p>This example use int *v while the other
examples seems to use notation like int* v.
<td>
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>US 17
<td>
<p>1.10
<td>
<p>1
<td>
<p>Ge
<td>
<p lang="en-GB" align="left">This definition of &#8220;thread&#8221; is poor,
and assumes the user already knows what multi-threaded means
(probably true!). In particular, it does not deal adequately with
the concept that all threads share the same address space.
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Replace first sentence of
para 1 as follows:
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">Under a hosted implementation, a C++ program can
have more than one thread of execution (a.k.a. thread) running
concurrently. Each thread is a single flow of control within a
program. Anything whose address may be determined by a thread,
including but not limited to static objects, storage obtained via
new or by any dynamic allocator, directly addressable storage
obtained through implementation-defined functions, and automatic
variables, are accessible to all threads in the same
program.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK 9
<td>
<p align="justify">2.1
<td>
<p align="justify">2,
4
<td>
<p align="justify">Te
<td>
<p align="left">Undefined
behaviour is a drastic way to silently ignore minor issues. The
cases in this paragraph could be easily defined. In this case opt
for conditionally supported behaviour, which mandates a diagnostic
if the compiler is not prepared to handle the syntax
consistently.
<td>
<p align="left" style="margin-bottom: 0in">Replace undefined behaviour with conditionally
supported behavior. Conditional behaviour may be implementation
defined, although suggest there is a reasonable default in each
case. For creating a universal-character name, splice text to
create a universal-character. In the case of a file ending without
a newline, treat as if the newline was implictly added, with an
empty line to follow if the last character was a back-slash.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK 10
<td>
<p align="justify">2.1
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Implementation defined seems unnecessarily
burdensome for negligible gain. I am yet to see code that depended
on whether non-empty sequences of whitespace were concatenated.
Better left unspecified.
<p align="left"><br>
<td>
<p align="left">How the
compiler treats non-empty sequences of whitespace should be left
unspecified, rather than implementation-defined.
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 10
<td>
<p>2.1 [lex.phases]/5 and 2.2
[lex.charset]/3
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">[defns.multibyte] "the extended character
set."
<p style="margin-bottom: 0in">[lex.charset]/3 cited below implies that
there is an extended character set per locale.
<p style="margin-bottom: 0in">[lex.phases]/5 "Each [...]
universal-character-name [...] is converted to the corresponding
member of the execution character set"
<p style="margin-bottom: 0in">[lex.charset]/3 "The values of the members
of the execution character sets are implementation defined, and any
additional members are locale-specific."
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">Together they seem to imply that what is
locale-specific is if a value is valid or not for the current
locale, not the representation of a given universal
character.
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">This is not the behaviour of at least some
compilers I've access to which are allowing different codes for the
same abstract character in different locale. During phase 5, they
are using an implementation defined char set.
<p style="margin-bottom: 0in"><br>
<p><br>
<td>
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>11
<td>
<p align="justify">2.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">Trigraphs are
a complicated solution to an old problem, that cause more problems
than they solve in the modern environment. Unexpected trigraphs in
string literals and occasionally in comments can be very confusing
for the non-expert.
<td>
<p align="left">Deprecate the
whole of 2.3 and move it to appendix D.
<td>
<p><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>12
<td>
<p align="justify">2.4,
2.8
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">This undefined behaviour in token concatenation is
worrying and we believe hard to justify. An implementation should
either support this in a defined way, or issue a diagnosic.
Documenting existing practice should not break existing
implementations, although unconditionally requiring a diagnostic
would lead to more portable programs.
<p align="left"><br>
<td>
<p align="left">Replace
undefined behaviour with conditionally supported behaviour with
implementation defined semantics.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 18
<td>
<p>2.4
<td>
<p>&#182; 2
<td>
<p>ed
<td>
<p>The paragraph begins with
an empty line.
<td>
<p>Delete the empty
line.
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 11
<td>
<p>2.4 [lex.pptokens]
<td>
<p>3
<td>
<p>ed
<td>
<p>There are spurious empty lines.
<td>
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 12
<td>
<p>2.5 [lex.digraph] and 2.11
[lex.key]/2
<td>
<p><br>
<td>
<p>te
<td>
<p>The alternative representations are reserved as
such even in attribute. Is that what is wanted?
<td>
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>FI 2
<td>
<p>2.5
<td>
<p lang="fi-FI" style="margin-top: 0.04in">Table 2
<td>
<p>te
<td>
<p>Add eq, for spelling out
== in order to distinguish it from the assignment operator.
<td>
<p>See eq-keyword.doc,
eq-keyword.ppt
<td>
<p><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>13
<td>
<p align="justify">2.9
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left">This text is
confusing in isolation, as it implies pp-numbers do not have a
value in translation phase 4 when evaluating #if preprocessor
expressions.
<td>
<p align="left">Add a note
with a cross-refernce to 16.1 that a pp-number may briefly acquire
a value during translation phase 4 while evaluating #if
expressions.
<td>
<p><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>14
<td>
<p align="justify">2.11
<td>
<p align="justify">table
3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The table is nearly sorted, but not quite. It was
sorted in previous versions of the standard.
<p align="left"><br>
<td>
<p align="left">Sort the
table.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 1
<td>
<p>2.11
<td>
<p lang="en-GB" align="left">Table 3
<td>
<p>ed
<td>
<p>Keywords in the table are
listed disorderly. Also, a part of a frame of the table is not
drawn.
<td>
<p lang="en-GB" align="left">Sort it in alphabetical order. Complete the table
frame.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 19
<td>
<p>2.13.1
<td>
<p>Table 5, rows &#8220;l or
L&#8221; and &#8220;ll or LL&#8221;
<td>
<p>te
<td>
<p>The final entry in the
last column (&#8220;unsigned long int&#8221;) is incorrect.
<td>
<p>Replace the incorrect
entries by &#8220;unsigned long long int&#8221;.
<td>
<p><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 20
<td>
<p lang="en-GB" align="left">2.13.1, 2.13.3
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left">Long strings of digits in literals are a
continuing problem in the production and maintenance of
programs.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Adopt the 1983 technology of Ada and use
underscores to separate digits. <font size=
"2" style="font-size: 11pt"> <font color=
"#000080"><u><a href=
"http://www.google.com/url?sa=D&amp;q=http%3A%2F%2Fwww.open-std.org%2FJTC1%2FSC22%2FWG21%2Fdocs%2Fpapers%2F2007%2Fn2281.html"
target="_blank">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2281.html</a></u></font></font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>15
<td>
<p align="justify">2.13.2
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left">Inconsistency
between definition of a multicharacter literal and a wide character
literal containing multiple c-chars.
<td>
<p align="left" style="margin-bottom: 0in">Define the term multicharacter wide literal for a
wchar_t literal containing multiple elements, and specify its type
is integer (or wider)
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>16
<td>
<p align="justify">2.13.2
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left">Not
immediately clear why the question mark needs escaping. A note
would help.
<td>
<p align="left" style="margin-bottom: 0in">Add a note explaining that the ? character may
need escaping to avoid accidentally creating a trigraph.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 2
<td>
<p lang="en-GB" align="left">2.13.4
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">1<sup>st</sup><font size=
"2" style="font-size: 11pt"> paragraph, 2<sup>nd</sup> line</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left">Typo, R"..." should be R"[...]"
<td>
<p>Correct typo.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 3
<td>
<p lang="en-GB" align="left">2.13.4
<td>
<p lang="en-GB" align="left">2<sup>nd</sup><font size="2" style=
"font-size: 11pt"> paragraph</font>
<td>
<p>te
<td>
<p>We think that the
explanation of d-char-sequence is not enough.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add the following.
<ol>
<li>
<p lang="en-GB" align="left" style=
"margin-bottom: 0in; widows: 0; orphans: 0">Add the following to the explanation of
d-char-sequence, more easily to understand.</ol>
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">...prefix is a raw string literal.
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">The d-char-sequence is used as delimiter.
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">The terminating d-char-sequence of ...
<ol start="2">
<li>
<p lang="en-GB" align="left" style=
"margin-bottom: 0in; widows: 0; orphans: 0">Add the following note that there are square
brackets in r-char-sequence.</ol>
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">[Note:
<p lang="en-GB" align="left" style=
"margin-left: 0.83in; margin-bottom: 0in">char foo[] = R&#8221;<i>delimiter</i>[[a-z]
specifies a range which matches any lowercase letter from "a" to
"z".]<i>delimiter</i>&#8221;;
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">the expression statement behaves exactly the same
as
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"margin-left: 0.83in; margin-bottom: 0in">char foo[]="[a-z] specifies a range which matches
any lowercase letter from \"a\" to \"z\".";
<p lang="en-GB" align="left" style=
"text-indent: 0.69in; margin-bottom: 0in">- end note]
<p lang="en-GB" align="left" style="text-indent: 0.69in"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 4
<td>
<p lang="en-GB" align="left">2.13.4
<td>
<p lang="en-GB" align="left">3<sup>rd</sup><font size="2" style=
"font-size: 11pt"> paragraph, 1st line of example</font>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo. Lack of a necessary backslash in
the first line of the example as follows:
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">const char *p = R"[a
<p lang="en-GB" align="left" style="margin-bottom: 0in">b
<p lang="en-GB" align="left" style="margin-bottom: 0in">c]";
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">const char *p = R"[a\
<p lang="en-GB" align="left" style="margin-bottom: 0in">b
<p lang="en-GB" align="left">c]";
<td>
<p lang="en-GB" align="left">Correct typo.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 21
<td>
<p>2.13.4
<td>
<p>&#182; 3
<td>
<p>ed
<td>
<p>The paragraph, marked as a
Note, contains an embedded example not marked as such.
<td>
<p>Denote the code (and
perhaps also its commentary) as an Example.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 22
<td>
<p>2.13.4
<td>
<p>&#182; 3
<td>
<p>te
<td>
<p>The code does not have the
effect predicted by its accompanying narrative.
<td>
<p>Append a backslash to the
first line of the code.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 5
<td>
<p lang="en-GB" align="left">2.13.4
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">11<sup>th</sup><font size=
"2" style="font-size: 11pt"> paragraph, Table 7</font>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p>It is not explicit how to
combine raw-string and non-raw-string.
<td>
<p>Add rules containing
raw-string in the table 7.
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 13
<td>
<p>2.13.4 [lex.string]
<td>
<p>3
<td>
<p>ed
<td>
<p style="margin-bottom: 0in">Shouldn't the assert be
<p>assert(std::strcmp(p, "a\nb\nc") == 0);
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>17
<td>
<p align="justify">2.13.4
<td>
<p align="justify">10
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It would be preferred for attempts to modify
string literals to be diagnosable errors. This is not possible due
to the deprecated implicit conversion to pointer to null-terminated
character sequence of non-const characters. If this deprecated
conversion were remove (see other comments) then string literals
are always accessed through const types, and the compiler can
enforce the no modification rule. The only exception would be using
const_cast to cast away constness, but this is already covered
under the const_cast rules so needs no further detail here.
<p align="left"><br>
<td>
<p align="left">(asssuming
deprecated conversion to non-const array is removed or can be
turned off) Strike the sentence on undefined behaviour.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>18
<td>
<p align="justify">2.13.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The addition of static_assert (7p4) to the
language raises the need to concatenate string representations of
integral constant expressions (typically from a sizeof or alignof
expression) with narrow string literals to provide an informative
error message. There is no need to support arbitrary constant
expressions and especially not floating point values or formatting
flags. Likewise, the need is purely to support static_assert so
only narrow string literal support is required, although
generalizing to other literal types would be useful.
<p align="left"><br>
<td>
<p align="left">Define a
syntax to support string-ization of integral constant expressions
in a form eligible for string literal concatenation, 2.13.4p6.
Suggested syntax: I" integral-constant-expression ". There is no
raw variant, although it could combine with type specifier in the
same way that the R prefix does, supporting u8I, uI, UI and
LI.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>19
<td>
<p align="justify">2.13.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">The grammar
for string literal is becoming unwieldy and could easily be
refactored into the type optional specifier and the string
contents.
<td>
<p align="left" style="margin-bottom: 0in">Refactor string-literal grammar as: (note -
current Drupal view loses formatting which is vital to clearly read
the grammar) string-literal: string-literal-type-specifierOPT
string-literal-body string-literal-type-specifier: one of u8 u U L
string-literal-body: " s-char-sequenceOPT " R raw-string
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 14
<td>
<p>3 [basic]
<td>
<p>7
<td>
<p>ed
<td>
<p>"In general it is necessary to determine
whether a name denotes one of these entities before parsing the
program that contains it."
<td>
<p style="margin-bottom: 0in">Would prefer
<p style="margin-bottom: 0in">"... before continuing to parse the
program that contains it."
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
or even
<p style="margin-bottom: 0in">"... to complete the parsing of the
program that contains it."
<p>as some names denotes entities declared after
the first occurrence.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 15
<td>
<p>3 [basic]
<td>
<p>8
<td>
<p>ed
<td>
<p style="margin-bottom: 0in">/operator-function-id/,
/conversion-function-id/, /template-id/ are followed by a space and
then a "s" while usually such production names aren't followed by a
space when put in plural (see /identifier/).
<p><br>
<td>
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>20
<td>
<p align="justify">3
<td>
<p align="justify"><br>
<td>
<p align="justify">Ge
<td>
<p align="left" style="margin-bottom: 0in">Chapter 3 ("Basic concepts") provides common
definitions used in the rest of the document. Now that we have
concepts as a primary feature, the title of this chapter can be
confusing as it does not refer to the language feature but to
definitions used in the document.
<p align="left"><br>
<td>
<p align="left">Change the
title to "Basic definitions".
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>21
<td>
<p align="justify">3
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left">Concepts is
now the name of a specific feature of the language, the term now
risks confusion and ambiguity when used in the more general
sense.
<td>
<p align="left">Rename the
chapter Basic ???. THe note in p2 specifically needs similar
rewording
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>22
<td>
<p align="justify">3
<td>
<p align="justify">6
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">References are frequently considered variables,
but this definition only applies to objects.
<p align="left"><br>
<td>
<p align="left">Add "or
reference" after both uses of "object"
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>23
<td>
<p align="justify">3.1
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">alias-declarations are not definitions and should
be added to the list
<p align="left"><br>
<td>
<p align="left">Add
alias-declaration after typedef declaration.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>24
<td>
<p align="justify">3.1
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The current words suggest the declaration of a
static integral constant data member of a class cannot be a
definition. Trying to fix this wording in-place will be verbose and
risk raising more confusion than it solves, so suggest a footnote
to call out the special case
<p align="left"><br>
<td>
<p align="left">Add a
footnote attached to the static data membmer rule: *static data
member delcarations of intergral type may also be definitions if a
constant integral expression is provided for an initializer.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>25
<td>
<p align="justify">3.1
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Example is misleading as implicitly defined
default constructor uses default initialization, not value
initialization, for non-static data members. In the case of
std::String this makes no difference, but it makes a big difference
for fundamental types and pointers.
<p align="left"><br>
<td>
<p align="left">Remove the :
s() from the illustrated default constructor: struct C {
std::string s; C() { } C(const C&amp; x): s(x.s) { } C&amp;
operator=(const C&amp; x) { s = x.s; return *this; } ~C() { }
};
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>26
<td>
<p align="justify">3.2
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">THe one definition rule should cover references,
and unless the term 'variable' is extended to cover references the
list in this paragraph is incomplete.
<p align="left"><br>
<td>
<p align="left">Either
include references in the definition of 'variable' (see earlier
comment) or add reference to the list in this paragraph.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>27
<td>
<p align="justify">3.2
<td>
<p align="justify">4
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">A class type must be complete when catching
exceptions, even by reference or pointer. See 15.3.
<p align="left"><br>
<td>
<p align="left">Add "when
used in an exception-handler (15.3)" to the list.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 16
<td>
<p>3.3 [Declarative regions
and scopes.]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">The scope of function parameters is
defined, but what is the scope of template parameters?
<p><br>
<td>
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>28
<td>
<p align="justify">3.3.1
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Class templates are not classes, so we should
include this case.
<p align="left"><br>
<td>
<p align="left">ammend
"class" to "class or class template"
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK
<p>29
<td>
<p align="justify">3.3.10
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left">operators and
conversion functions do not have names, yet are susceptible to
'name hiding' within a class - indeed we rely on this for the
implicitly declared copy-assignment operator.
<td>
<p align="left" style="margin-bottom: 0in">Add the additional phrase "The declaration of an
operator or conversion function in a derived class (Clause 10)
hides the declaration of an operator or conversion function of a
base class of the same operator or type;"
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 17
<td>
<p>3.5 [Program and
linkage]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">This section does not specify whether
concept names have linkage.
<p style="margin-bottom: 0in">Do they or not? If concept names do not
have linkage, then a note is appropriate, and that would be a bit
surprising and curious. What is the rationale?
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
30
<td>
<p align="justify">3.5
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left">This
paragraph implies concepts have no linkage (do they need it?) and
that the entities behind names without linkage cannot be used in
other scopes. This maybe a bigger problem for concept maps?
<td>
<p align="left">Add a note to
clarify that concepts don't need linkage.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
31
<td>
<p align="justify">3.5
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left">What is the
linkage of names declared inside a namespace, in turn declared
inside an anonymous namespace? It is not clear why such a namespace
has no linkage, and there is no language suggesting its memmbers
should lose linkage with it, which we assume is the intended
consequence.
<td>
<p align="left">Clarify rules
for namespaces inside nested namespaces, or remove the
restriction.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 23
<td>
<p lang="en-GB" align="left">3.5
<td>
<p lang="en-GB" align="left">6
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Bad paragraph break.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 18
<td>
<p>3.5 [basic.link]
<td>
<p>6
<td>
<p>ed
<td>
<p>The paragraph number is not aligned with the
text.
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 19
<td>
<p>3.6 [Start and
termination]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">This section completely ignores the real
world and practical case of dynamically linked or loaded libraries.
In current computing environments, they are ubiquitous and they
cannot be ignored in
<p style="margin-bottom: 0in">practical C++ programs. The
Standard
<p style="margin-bottom: 0in">should address this aspect.
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
32
<td>
<p align="justify">3.6.1
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left">Do we really
want to allow: constexpr int main() { return 0; } as a valid
program?
<td>
<p align="left" style="margin-bottom: 0in">Add constexpr to the list of ill-formed things to
annotate main
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 24
<td>
<p lang="en-GB" align="left">3.6.1
<td>
<p lang="en-GB" align="left">4
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left">std::quick_exit is not referenced.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Reference std::quick_exit as well as std::exit in
saying that automatic objects are not destroyed. It should <font size=
"2" style="font-size: 11pt">
<strong>not</strong> do so in saying that calling
std::quick_exit is undefined from within destructors for static or
thread duration objects.</font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>US 25
<td>
<p>3.6.3
<td>
<p>&#182; 2 last sent.
<td>
<p>ed
<td>
<p>The parenthesized phrase,
introduced via &#8220;i.e.&#8221; is in the nature of an
example.
<td>
<p>Change &#8220;i.e.&#8221;
to &#8220;e.g.&#8221;
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 6
<td>
<p lang="en-GB" align="left">3.7.4.1
<td>
<p lang="en-GB" align="left">4<sup>th</sup><font size="2" style=
"font-size: 11pt"> paragraph, 4<sup>th</sup> line</font>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo.
<p lang="en-GB" align="left" style="margin-bottom: 0in">Lack of a comma right after
&#8220;(3.7.2)&#8221; in the sentence while there are commas after
any other recitations like &#8220;(3.7.1)&#8221;. It is just a
unification matter.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">[ Note: in particular, a global
allocation function is not called to allocate storage for objects
with static storage duration (3.7.1), for objects or references
with thread storage duration (3.7.2) for objects of type
std::type_info (5.2.8), or for the copy of an object thrown by a
throw expression (15.1). -end note ]
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"text-indent: 0.13in; margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">[ Note: in particular, a global
allocation function is not called to allocate storage for objects
with static storage duration (3.7.1), for objects or references
with thread storage duration (3.7.2), for objects of type
std::type_info (5.2.8), or for the copy of an object thrown by a
throw expression (15.1). -end note ]
<p lang="en-GB" align="left"><br>
<td>
<p>Correct typo.
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-3
<td>
<p>3.7.4.3
<td>
<p><br>
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
DE-3 It is unclear whether
the following code has well-defined behavior; none of the bullets
in the second paragraph seem to apply.
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">int&amp; i = *new
int(5);
<p lang="en-GB" align="left">delete &amp;i;
<td>
<p>Clarify that &amp;i is
considered a safely-derived pointer value.
<td>
<p><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 26
<td>
<p lang="en-GB" align="left">3.8
<td>
<p lang="en-GB" align="left">1 and 5
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left">Use of object fields during destruction is
excessively and erroneously constrained.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">See the attached document "Issues with
the C++ Standard" under Chapter 3 "Use of objects, especially from
other threads, during destruction".
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>US 27
<td>
<p>3.9
<td>
<p>&#182; 9 first
sent.
<td>
<p>ed
<td>
<p>There is a
superfluous/extraneous &#8220;and&#8221;.
<td>
<p>Delete &#8220;and&#8221;
from the phrase &#8220;and std::nullptr_t&#8221;.
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 20
<td>
<p>3.9 [Types]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">The phrase 'effective type' is defined and
used in a way that is incompatible with C99. Such a deliberate
incompatible choice of terminology is both unfortunate and
confusing, given past practice of the committee to maintain greater
compatibility with C99. We strongly suggest that the phrase
'effective type' not be used in such an incompatible way.
<p><br>
<td>
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 7
<td>
<p lang="en-GB" align="left">3.9.2
<td>
<p lang="en-GB" align="left">3<sup>rd</sup><font size="2" style=
"font-size: 11pt"> paragraph, 13<sup>th</sup> line</font>
<td>
<p>ed
<td>
<p>over-aligned type was
added as new notion. So it is preferable to add the link after
that.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add (3.11) after over-aligned type as
the link.
<p lang="en-GB" align="left">[ Note:
pointers to over-aligned types<font color="#008000">(3.11)</font><font size="2" style=
"font-size: 11pt"> have no special representation, but their
range of valid values is restricted by the extended alignment
requirement. This International Standard specifies only two ways of
obtaining such a pointer: taking the address of a valid object with
an over-aligned type<font
color="#008000">(3.11)</font>, and using one of the runtime pointer alignment
functions. An implementation may provide other means of obtaining a
valid pointer value for an over-aligned type<font color="#008000">(3.11)</font>.&#8212;end note ]</font>
<td>
<p><br>
<tr valign="top">
<td>
<p>US 28
<td>
<p>3.9.3
<td>
<p>&#182; 5 first
sent.
<td>
<p>ed
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
The closing braces of the
first two sets are preceded by extraneous space.
<p><br>
<td>
<p>Delete the extra
spaces.
<td>
<p><br>
<tr valign="top">
<td>
<p>DE 4
<td>
<p>4.2
<td>
<p>p2
<td>
<p>te
<td>
<p>DE-4 The deprecated
conversion from string literals to pointer to non-const character
types should be limited to those conversions and types of string
literals that were already present in ISO/IEC 14882:2003, or the
deprecated conversions should be removed entirely.
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Consider applying the
proposed resolution presented in core issue 693 in WG21 document
N2714 &#8220;C++ Standard Core Language Active Issues, Revision
58&#8220;, available at
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2714.html
; or remove only the conversions to "pointer to char16_t", "pointer
to char32_t" in 4.2 paragraph 2 and 15.1 paragraph 3.
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>CH 1
<td>
<p>4.9 and 5.2.9
<td>
<p><br>
<td>
<p>te
<td>
<p>With respect to the target
type, pointer to members should behave like normal pointers (least
surprise principle).
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
The standard should allow
implicit conversions from ``pointer to member of <tt>T</tt> of type <i>cv</i> <tt>D</tt>'' to ``pointer to member of
<tt>T</tt> of type <i>cv</i>
B'', where D is of class type and B is a public base of D, It
should allow explicit conversion the other way around.
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-5
<td>
<p>4.11, 5.3.1, 5.5
<td>
<p><br>
<td>
<p>te
<td>
<p>DE-5 Ref-qualification has
not been integrated with pointer-to-members.
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Review implicit conversions
(4.11), forming pointer-to-members (5.3.1), and dereferencing
pointer-to-members (5.5) for type-safety concerns in the presence
of ref-qualifiers on the member.
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
33
<td>
<p align="justify">4.13
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left">We have: "No
two signed integer types shall have the same rank ..." "the rank of
char shall equal the rank of signed char" Can we therefore deduce
that char may not be signed?
<td>
<p align="left" style="margin-bottom: 0in">Replace the first sentence with "No two signed
integer types shall have the same rank, even if they have the same
representation, except that signed char shall have the same rank as
char even if char is signed (3.9.1/1)."
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
34
<td>
<p align="justify">4.13
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">6th bullet, "the rank of char" - first letter
should be capitalised for consistency with the other bullets
<p align="left"><br>
<td>
<p align="left">The rank of
char
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
36
<td>
<p align="justify">5.1
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Primary expressions are literals, names, names
qualified by the scope resolution operator ::, and lambda
expressions. The immediately following grammar flatly contradicts
this - this and (e) are also lambda expressions.
<p align="left"><br>
<td>
<p align="left">Delete this
paragraph.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
37
<td>
<p align="justify">5.1
<td>
<p align="justify">11
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Member function templates are not member
functions, so should also be listed in the 3rd bullet
<p align="left"><br>
<td>
<p align="left">Add member
function templates to the 3rd bullet
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
38
<td>
<p align="justify">5.1
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left">this might be
useful in a few more places than it is permitted, specifically in
decltype expressions within a class. Two examples that would be
ill-formed at class scope without changes: typedef decltype( *this
) this_type; decltype( [this]{ return this-&gt;memfun(); } )
my_lambda;
<td>
<p align="left">... words to
follow ...
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 8
<td>
<p lang="en-GB" align="left">5.1
<td>
<p lang="en-GB" align="left">7<sup>th</sup><font size="2" style=
"font-size: 11pt"> paragraph, Syntax rules</font>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">In the current syntax definition, a
scope operator(::) cannot be applied to decltype, but it should be.
It would be useful in the case to obtain member type(nested-type)
from an instance as follows:
<p lang="en-GB" align="left" style="margin-bottom: 0in">vector&lt;int&gt; v;
<p lang="en-GB" align="left">decltype(v)::value_type i = 0; // int i =
0;
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add &#8220;decltype ( expression ) ::
&#8220; to nested-name-specifier syntax like below.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">nested-name-specifier:
<p lang="en-GB" align="left" style=
"text-indent: 0.13in; margin-bottom: 0in">type-name ::
<p lang="en-GB" align="left" style=
"text-indent: 0.13in; margin-bottom: 0in">namespace-name ::
<p lang="en-GB" align="left" style=
"text-indent: 0.13in; margin-bottom: 0in">nested-name-specifier identifier ::
<p lang="en-GB" align="left" style=
"text-indent: 0.13in; margin-bottom: 0in">nested-name-specifier templateopt
simple-template-id ::
<p lang="en-GB" align="left" style=
"text-indent: 0.13in; margin-bottom: 0in">nested-name-specifieropt concept-id ::
<p lang="en-GB" align="left" style=
"text-indent: 0.13in; margin-bottom: 0in">decltype ( expression ) ::
<p lang="en-GB" align="left" style="text-indent: 0.13in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 9
<td>
<p lang="en-GB" align="left">5.1.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">It would be preferable that
&#8220;&amp;&amp;&#8221; could be specified in a lambda expression
to declare move capture.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Here is an example from N2709.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;typename F&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::unique_future&lt;typename
std::result_of&lt;F()&gt;::type&gt; spawn_task(F f){
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename
std::result_of&lt;F()&gt;::type result_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">struct local_task {
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::promise&lt;result_type&gt;
promise;
<p lang="en-GB" align="left" style="margin-bottom: 0in">F func;
<p lang="en-GB" align="left" style="margin-bottom: 0in">local_task(local_task const&amp;
other)=delete;
<p lang="en-GB" align="left" style="margin-bottom: 0in">local_task(F func_):
<p lang="en-GB" align="left" style="margin-bottom: 0in">func(func_)
<p lang="en-GB" align="left" style="margin-bottom: 0in">{}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">local_task(local_task&amp;&amp;
other):
<p lang="en-GB" align="left" style="margin-bottom: 0in">promise(std::move(other.promise)),
<p lang="en-GB" align="left" style="margin-bottom: 0in">f(std::move(other.f))
<p lang="en-GB" align="left" style="margin-bottom: 0in">{}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">void operator() {
<p lang="en-GB" align="left" style="margin-bottom: 0in">try
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">promise.set_value(f());
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in">catch(...)
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">promise.set_exception(std::current_exception());
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in">};
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">local_task task(std::move(f));
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::unique_future&lt;result_type&gt;
res(task.promise.get_future());
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::thread(std::move(task));
<p lang="en-GB" align="left" style="margin-bottom: 0in">return res;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">This can be rewritten simply as follows
if move capture can be used in a lambda expression.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;typename F&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::unique_future&lt;typename
std::result_of&lt;F()&gt;::type&gt; spawn_task(F f){
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename
std::result_of&lt;F()&gt;::type result_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::promise&lt;result_type&gt;
promise;
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::unique_future&lt;result_type&gt;
res(promise.get_future());
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::thread([&amp;&amp;promise,
&amp;&amp;f]() {
<p lang="en-GB" align="left" style="margin-bottom: 0in">try
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">promise.set_value(f());
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in">catch(...)
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">promise.set_exception(std::current_exception());
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in">});
<p lang="en-GB" align="left" style="margin-bottom: 0in">return res;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add move capture in a lambda
expression.
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 10
<td>
<p lang="en-GB" align="left">5.1.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">In the current syntax definition, a
returned type of a function object cannot be obtained by using
result_of from an unnamed function object generated by a lambda
expression because it doesn&#8217;t have result type.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class F&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void foo(F f)
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef std::result_of&lt;F()&gt;::type
result; // error
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in">foo([]{});
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"margin-left: 0in; margin-bottom: 0in">If &#8220;Callable&#8221; or
&#8220;Predicate&#8221; concept is specified, a returned type can
be obtained from a function object without result_type. But it is
preferable to be able to obtain it with template.
<p lang="en-GB" align="left" style="margin-left: 0in"><br>
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add result_type to the syntax of an
unnamed function object generated by a lambda expression.
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 29
<td>
<p lang="en-GB" align="left">5.1.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The standard does not state whether or
not direct recursion of lambdas is possible.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 30
<td>
<p lang="en-GB" align="left">5.1.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in"><font
color="#000000">The standard does not clarify the meaning of</font> <font size=
"2" style="font-size: 11pt">
<code><font color="#000000">this</font></code> <font color="#000000">in lambdas. Does it mean
this lambda, or this class within which the lambda is
nested?</font></font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 31
<td>
<p lang="en-GB" align="left">5.1.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in"><font
color="#000000">The current wording does not specify how context
capturing and name resolution</font> <font size=
"2" style="font-size: 11pt">take place when the inner lambda refers to the
outer lambda's locals variables and parameters.</font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
45
<td>
<p align="justify">5.1.1
<td>
<p align="justify">para
2
<td>
<p align="justify">Te
<td>
<p align="left">Lambda is a
language feature with an apparent dependency on &lt;functional&gt;.
This increases dependency of language on library, and is
inconsistent with the definition of freestanding in
17.6.2.4.
<td>
<p align="left" style="margin-bottom: 0in">Change the text "a closure object behaves as a
function object" to "a closure object is a built-in object which
behaves as a function object"; and after "context.", insert " A
closure object may be used without any need for
&lt;functional&gt;." This makes clear what may already be implied,
namely that lambdas can be used in freestanding implementations and
don't increase dependency of language on library. (Marked as
technical comment anyway because this clarity is technically
important).
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">US 32
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">5.1.1
<td>
<p lang="en-GB" align="left">3
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The final italic "this" in the paragraph
should be a teletype "this".
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
39
<td>
<p align="justify">5.1.1
<td>
<p align="justify">11
<td>
<p align="justify">Te
<td>
<p align="left">This
paragraph lists all the special member functions for the class
representing a lambda. But it omits the destructor, which is
awkward.
<td>
<p align="left">Add "F has an
implicitly-declared destructor".
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
40
<td>
<p align="justify">5.1.1
<td>
<p align="justify">12
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">If one or more names in the effective capture set
are preceded by &amp;, the effect of invoking a closure object or a
copy after the innermost block scope of the context of the lambda
expression has been exited is undefined. That is too restrictive.
The behaviour should be undefined iff the lifetime of any of the
variables referenced has ended. This should be safe and legal;
currently it has undefined behaviour: int i;
reference_closure&lt;void ()&gt; f; if (blah) { f = [&amp;i]() { };
} if (f) f();
<p align="left"><br>
<td>
<p align="left">If one or
more names in the effective capture set are preceded by &amp;, the
effect of invoking a closure object or a copy after the lifetime of
any of the variables referenced has ended is undefined.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
41
<td>
<p align="justify">5.1.1
<td>
<p align="justify">12
<td>
<p align="justify">Te
<td>
<p align="left">For argument
dependant lookup (3.4.2) the associated namespaces for a class
include its bases, and associated namespaces of its bases.
Requiring the result of a lambda expression *to dervide from*
std::reference_closure means that ADL will look in namespace std
when the lambda capture is entirely by reference, which might have
surprising results. Also, relying on the idea of implicitly slicing
objects is uncomfortable.
<td>
<p align="left">Replace
inheritance with implicit conversion.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
42
<td>
<p align="justify">5.1.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">A lambda with
an empty capture list has identical semantics to a regular function
type. By requiring this mapping we get an efficient lambda type
with a known API that is also compatible with existing operating
system and C library functions.
<td>
<p align="left" style="margin-bottom: 0in">Add a new paragraph: "A lambda expression with an
empty capture set shall be convertible to pointer to function type
R(P), where R is the return type and P is the parameter-type-list
of the lambda expression." Additionally it might be good to (a)
allow conversion to function reference (b) allow extern "C"
function pointer types
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
43
<td>
<p align="justify">5.1.1
<td>
<p align="justify">12
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The note spells out the intent that objects from
lambda-expressions with an effective capture list of references
should be implemented as a pair of pointers. However, nothing in
the rest of 5.1.1 lifts the requirement of to declare a reference
member for each captured name, and a non-normative note is not
enough to relax that.
<p align="left"><br>
<td>
<p align="left">... provvide
exceptions in the right places ...
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
44
<td>
<p align="justify">5.1.1
<td>
<p align="justify">12
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">There is a strong similarity between a [&amp;]{}
lambda capturing a stack frame, and a [this]{} lambda binding a
member function to a class instance. The reference_closure
requirement should be extended to the second case, although we need
some syntax to create such an object that is distinct from the
existing pointer-to-member syntax. This would be a cleaner
alternative to the new std::mem_fn library component.
<p align="left"><br>
<td>
<p align="left">Extend
reference_closure requirement to cover [this] lambdas. Consider a
simple syntax for creating such bound expressions.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
46
<td>
<p align="justify">5.1.1
<td>
<p align="justify">para
12
<td>
<p align="justify">Te
<td>
<p align="left">The
requirement that a lambda meeting appropriate conditions be an
object derived from reference_closure makes lambda the language
feature dependent on &lt;functional&gt;, which increases dependency
of the language on the library and bloats the definition of
freestanding C++.
<td>
<p align="left" style="margin-bottom: 0in">Replace text "is publicly derived from" with
"shall be implemented in a manner indistinguishable from". This
places an ABI constraint on reference closures such that compiler
and library implementer have to do compatible things. But it cuts
the dependency of lambda syntax on &lt;functional&gt;.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>DE-6
<td>
<p>5.1.1, 20.7.18
<td>
<p><br>
<td>
<p>te
<td>
<p>DE-6 Some uses of lambda
expressions refer to specializations of the unconstrained class
template std::reference_closure (5.1.1). If the
lambda expression appears in a constrained context and the return
type or a parameter type for the lambda depend on a template
parameter (see 14.10), such a use is ill-formed.
<td>
<p>In 20.7.18, for the class
template std::reference_closure, require Returnable for R and VariableType for each of the ArgTypes.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>DE-7
<td>
<p>5.1.1
<td>
<p>p10
<td>
<p>ed
<td>
<p>DE-7 The note at the end
of paragraph 10 appears to be garbled.
<td>
<p>Remove "or references" in
the note.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>DE-8
<td>
<p>5.1.1
<td>
<p>p10
<td>
<p>te
<td>
<p>DE-8 The construction of
the function call operator signature is missing specifications for
the ref-qualifier and the attribute-specifier.
<td>
<p>Add bullets that say that
the ref-qualifier and the attribute-specifier are absent.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>US 33
<td>
<p>5.1.1
<td>
<p>11
<td>
<p>Ge
<td>
<p>There is no definition of
&#8220;move constructor&#8221; or &#8220;move
operation&#8221;
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Since this is the first place
the terms are used, a definition should either be added here, or a
cross reference to one.
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-9
<td>
<p>5.1.1
<td>
<p><br>
<td>
<p>te
<td>
<p>DE-9 There is not a single
example of a lambda-expression in the standard. See also core issue
720 in WG21 document N2791 "C++ Standard Core Language Active
Issues, Revision 59", available at
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2791.html
.
<td>
<p>Add a few well-chosen
examples.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
52
<td>
<p align="justify">5.2
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left">This
paragraph seens out of place, assignment expressions are covered in
5.17
<td>
<p align="left">Move p3 to
subsection 5.17
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
53
<td>
<p align="justify">5.2.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">The
definition in p1 makes no allowance for overloaded operator[] that
treats the expression as a simple function call, and does not
support the interchangability of arguments. Howver p2 relies on
this definition when describing the use of brace-init-lists inside
[].
<td>
<p align="left">Insert a new
p2 describing the changed semantics for overloaded operator[]. This
should be a note to avoid introducing normative text that could
potentially conflict with the later definiton of these
semantics.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
59
<td>
<p align="justify">5.2.2
<td>
<p align="justify">7
<td>
<p align="justify">Te
<td>
<p align="left">When there is
no parameter for a given argument, the argument is passed in such a
way that the receiving function can obtain the value of the
argument by invoking va_arg. That shouldn't apply to parameter
packs. template &lt;class ... Types&gt; void f(Types ... pack);
f(1, 2, 3);
<td>
<p align="left">Clarify that
this sentence only applies where the ellipsis is used.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
60
<td>
<p align="justify">5.2.5
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left">In the
remainder of 5.2.5, cq represents either const or the absence of
const vq represents either volatile or the absence of
volatile.
<td>
<p align="left">Add "and"
before vq
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
61
<td>
<p align="justify">5.2.5
<td>
<p align="justify">p1
<td>
<p align="justify">Ed
<td>
<p align="left">Together with
footnote 60 there may be confusion that the postfix expression is
always evaluated - even when part of an unevaluated operand. We
believe the standard does not require this, and a comment in the
existing note would be a useful clarification.
<td>
<p align="left">Clarify in
footnote 60 that this will not happen if the whole expression is an
unevaluated operand.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
62
<td>
<p align="justify">5.2.5
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left">In the final
bullet, what does 'not an lvalue' mean? Does it imply rvalue, or
are there other possible meanings? Should clauses that trigger on
rvalues pick up on this?
<td>
<p align="left">Replace 'not
an lvalue' with 'is an rvalue'.
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-10
<td>
<p>5.2.5
<td>
<p><br>
<td>
<p>te
<td>
<p>DE-10 If E1.E2 is
referring to a non-static member function, the potential
ref-qualification on E2 should be taken into account.
<td>
<p>Adjust the presentation of
the types involved as appropriate.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
63
<td>
<p align="justify">5.2.6
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left">Paragraph 2
is missing its number.
<td>
<p align="left">Add
one.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
64
<td>
<p align="justify">5.2.7
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left">A new name R
is introduced for use in paragraphs 3 and 4. But R is the same as
T.
<td>
<p align="left" style="margin-bottom: 0in">Replace R with T and replace "the required result
type (which, for convenience, will be called R in this
description)" with "T".
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
65
<td>
<p align="justify">5.2.7
<td>
<p align="justify">8
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">In the first two bullets we have "the result is a
pointer (an lvalue referring) to". But para 2 makes clear that a
dynamic_cast of an rvalue references produces a rvalue. (Can an
lvalue refer to anything anyway?)
<p align="left"><br>
<td>
<p align="left">Replace "an
lvalue referring to" with "reference", twice.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
66
<td>
<p align="justify">5.2.8
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">typeid may return "an implementation-defined class
derived from std :: type_info". The derivation must be
public.
<p align="left"><br>
<td>
<p align="left">an
implementation-defined class publicly derived from std ::
type_info
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
67
<td>
<p align="justify">5.2.9
<td>
<p align="justify">1, 2,
3
<td>
<p align="justify">Te
<td>
<p align="left">Paragraph 1
specifies when the result of static_cast is an lvalue; repeating it
is unnecessary.
<td>
<p align="left" style="margin-bottom: 0in">In para 2, delete "It is an lvalue if the type
cast to is an lvalue reference; otherwise, it is an rvalue." and
"The result is an rvalue.". In para 3, delete "The result is an
lvalue if T is an lvalue reference type (8.3.2), and an rvalue
otherwise."
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
54
<td>
<p align="justify">5.2.10
<td>
<p align="justify">3,
6
<td>
<p align="justify">Te
<td>
<p align="left">Para 3: "The
mapping performed by reinterpret_cast is implementation-defined.".
Para 6: "... the result of such a pointer conversion is
unspecified." Which is it?
<td>
<p align="left" style="margin-bottom: 0in">In para 6, replace unspecified with
implementation-defined. Alternatively, delete paragraph 3, since
individual cases are labelled appropriately.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
55
<td>
<p align="justify">5.2.10
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left">dynamic_cast
and reinterpret_cast crossreference 5.2.11 without creating an
extra note. The second half of the note is unrelated to the
crossrefernce, and would serve as well in normative text.
<td>
<p align="left" style="margin-bottom: 0in">Strike the note about definition of casting away
constness, preserve the cross-reference. The second sentance on
reintrepret_cast to its own type should move out of the note into
the normative text.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
56
<td>
<p align="justify">5.2.10
<td>
<p align="justify">5
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The notion of safely derived pointers means this
conversion may not be as safe in the revised standard as the
original. It would be good to call attention to the changed
semantics with a note.
<p align="left"><br>
<td>
<p align="left">Add: [Note:
the result of such a conversion will not be a safely-derived
pointer value (3.7.4.3) -- end note]
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
57
<td>
<p align="justify">5.2.10
<td>
<p align="justify">8
<td>
<p align="justify">Ed
<td>
<p align="left">Conditionally
supported behaviour gives a wide range or permission, so clarify
relationship between safely-derived object pointers and function
pointers in a note.
<td>
<p align="left">Add: [Note:
In such cases, the implementation shall also define whether a
safely-derived object pointer cast to a function pointer can be
safely cast back -- end note]
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
58
<td>
<p align="justify">5.2.11
<td>
<p align="justify">9
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Casting from an lvalue of type T1 to an lvalue of
type T2 using a reference cast casts away constness if a cast from
an rvalue of type &#8220;pointer to T1&#8221; to the type
&#8220;pointer to T2&#8221; casts away constness. That doesn't
cover rvalue references.
<p align="left"><br>
<td>
<p align="left">Replace
lvalue with "lvalue or rvalue" twice.
<td>
<p><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">US 34
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">5.3
<td>
<p lang="en-GB" align="left">1
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left">The list of unary operator should be in teletype
font.
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
68
<td>
<p align="justify">5.3.1
<td>
<p align="justify">2-9
<td>
<p align="justify">Te
<td>
<p align="left">All the unary
operands other than * return rvalues - but this is not
stated.
<td>
<p align="left" style="margin-bottom: 0in">Add a paragraph 1a "The following unary operators
all produce results that are rvalues."
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
69
<td>
<p align="justify">5.3.1
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">If we cannot bind references/take address of
functions in concept_maps, does that mean we cannot use generic
bind in constrained templates? Launch threads with expressions
found via concept map lookup? Hit problems creating std::function
objects? Does the problem only occur if we use qualified lookup to
explicitly name a concept map? Does it only kick in if we rely on
the implicit function implementation provided by a concept_map, so
some types will work and others won't for the same
algorithm?!
<p align="left"><br>
<td>
<p align="left">... unknown
...
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
70
<td>
<p align="justify">5.3.3
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The sizeof operator shall not be applied to ... an
enumeration type before all its enumerators have been declared We
should allow enum E : int; sizeof(E).
<p align="left"><br>
<td>
<p align="left">Change "an
enumeration type" to "an enumeration type whose underlying type is
not fixed".
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
71
<td>
<p align="justify">5.3.4
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left">The type of
an allocated object wih the type specifier auto is determined by
the rules of copy initialization, but the initialization applied
will be direct initialization. This would affect classes which
declare their copy constructor explicit, for instance. For
consistency, use the same form of initiailization for the deduction
as the new expression.
<td>
<p align="left">Replace T x =
e; with T x(e);
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
72
<td>
<p align="justify">5.3.4
<td>
<p align="justify">7
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The library headers have been carefully structured
to limit the dependencies between core language and specific
headers. The exception thrown should be catchable by a handler for
a type lised in &lt;exception&gt; header in cluase 18. This might
be accomplished by moving length_error into the &lt;exception&gt;
header, but its dependency on logic_error with its std::string
constructors suggest this is not a good idea. Prefer to pick an
existing exception instead.
<p align="left"><br>
<td>
<p align="left">Throw
std::bad_alloc instead of std::length_error.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
73
<td>
<p align="justify">5.3.4
<td>
<p align="justify">6
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">A class type with conversion operator can only be
used if the conversion type is constexpr and the class is a literal
type. Adding the single word 'literal' before class type will
clarify this.
<p align="left"><br>
<td>
<p align="left">Add 'literal'
before 'class type'
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
74
<td>
<p align="justify">5.3.4
<td>
<p align="justify">8
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">operators, like constructors and destructors, do
not have names. However, in certain circumstances they can be
treated as if they had a name, but usually the stanadard is very
clear not to actually describe their name as a distinct
property.
<p align="left"><br>
<td>
<p align="left">Change "the
allocation function&#8217;s name is operator new" to "the
allocation function is named operator new" and similarly for
operator delete.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
35
<td>
<p align="justify">5.3.4
<td>
<p align="justify">9
<td>
<p align="justify">Ed
<td>
<p align="left">Missing
period in middle of paragraph between "in the scope of T" and "If
this lookup fails"
<td>
<p align="left" style="margin-bottom: 0in">Add a period between "in the scope of T" and "If
this lookup fails"
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
75
<td>
<p align="justify">5.3.5
<td>
<p align="justify">8
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">A paragraph strarting with [Note... is easily
skipped when reading, missing the normative text at the end.
<p align="left"><br>
<td>
<p align="left">Swap order of
the note and normative text.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 21
<td>
<p>5.3.6 [Alignof
<td>
<p><br>
<td>
<p>te
<td>
<p>Should not the type of alignof-expression be of
type std::max_align_t?
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 35
<td>
<p lang="en-GB" align="left">5.8
<td>
<p lang="en-GB" align="left">2 and 3
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">There is curious spacing in the
expressions "E1 &lt;&lt;E2" and "E1 &gt;&gt;E2". This is a
formatting change since previous versions of the Standard.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
47
<td>
<p align="justify">5.14 /
5.15
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Why are the descriptions of order of evaluation of
expressions and side effects different between &amp;&amp; and ||
operators. The interaction with the memory model should be
identical, so identical words should be used to avoid accidential
inconsistencies in interpretation.
<p align="left"><br>
<td>
<p align="left">Pick one form
of wording as 'the best' and apply it in both places.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
48
<td>
<p align="justify">5.18
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The defining feature of the comma operator is the
guaranteed sequencing of two expressions. This guarantee is lost
when presented with an overloaded operator, and this change is
subtle enough to call attention to it.
<p align="left"><br>
<td>
<p align="left">Add: [Note:
There are no guarantees on the order of value computation for an
overloaded comma operator -- end note]
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
49
<td>
<p align="justify">5.19
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left">Is an
implementation permitted to reject this? constexpr int f() { return
f(); } int a[f()]; AFAICT it is well-formed; f() seems to satisfy
all the rules to make it a constant expression. I would hate
compilation to become a potentially non-terminating
experience.
<td>
<p align="left" style="margin-bottom: 0in">Add an escape clause to allow the implementation
to reject excessively deep nesting of constexpr function
evaluations. (This can possibly be a note, since it is arguable
that this point is handled by the general rule on resource limits
in 1.4/2. A sufficiently smart compiler could use tail recursion
above, meaning that it would never run out of memory given this
program though.)
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
50
<td>
<p align="justify">5.19
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left">The following
should be valid: enum E { foo = 4}; const E c = foo; int a[c]; But
currently it is not - c is not an lvalue of effective integral type
(4th bullet). (See also 7.1.6.1/2)
<td>
<p align="left" style="margin-bottom: 0in">Change "effective integral type" to "effective
integral or enumeration type" in the 4th bullet, 1st
sub-bullet.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
51
<td>
<p align="justify">5.19
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">typeid expressions can never be constant, whether
or not the operand is a polymorphic class type. The result of the
expression is a reference, and the typeinfo class that the
reference refers to is polymorphic, with a virtual destructor - it
can never be a literal type.
<p align="left"><br>
<td>
<p align="left">Strike the
words "whose operand is of a polymorphic class type" on the bullet
for typeid expressions.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
76
<td>
<p align="justify">6.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">Do we really
need two different terms that say the same thing?
<td>
<p align="left" style="margin-bottom: 0in">Pick either 'block' or 'compound statement' as the
preferred term and use it consistently throughout the
standard.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 22
<td>
<p>6.4.2 [The switch
statement]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">The constant-expression in
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">case constant-expression
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">should be allowed to be of any constant
expression of literal type for which a constexpr comparison
operator (operator&lt; and operator==) is in scope. Now that
constant expressions of other integral types are evaluated at
compile time, the restriction for case-labels is at best
artificial.
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
77
<td>
<p align="justify">6.5
<td>
<p align="justify">5
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The terms i/o operation, synchronize operation and
atomic operation have very specific meanings within the standard.
The paragraph would be much easier to understand with the terms
crossreferenced.
<p align="left"><br>
<td>
<p align="left">Profide a
cross-reference for the terms: i/o operation, synchronize operation
and atomic operation
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 11
<td>
<p lang="en-GB" align="left">6.5.4
<td>
<p lang="en-GB" align="left">1<sup>st</sup><font size="2" style=
"font-size: 11pt"> paragraph, 5<sup>th</sup> line</font>
<td>
<p>ed
<td>
<p>There is no _RangeT type
in the equivalent code to &#8220;range-base for&#8221; statement.
It existed in N2049.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add a typedef for _RangeT in the example
as follows:
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp; <u>typedef
decltype( expression ) _RangeT;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp; auto
&amp;&amp; __range = ( expression );
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp; for ( auto
__begin = std::Range&lt;_RangeT&gt;:: begin(__range),
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; __end =
std::Range&lt;_RangeT&gt;:: end(__range);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __begin != __end;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++__begin )
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for-range-declaration = *__begin;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; statement
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp; }
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
78
<td>
<p align="justify">6.5.4
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left">Including the
header &lt;iterator_concepts&gt; is far too unwieldy to enable an
important and (expected to be) frequently used syntax.
<td>
<p align="left" style="margin-bottom: 0in">Merge &lt;iterator_concepts&gt; into
&lt;concepts&gt; and change 6.5.4p2 to refer to &lt;concepts&gt;,
or make the Range concept fundamental along with the other support
concepts in 14.9.4 and strike any reference to including a
header.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
79
<td>
<p align="justify">6.5.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The definition of for (for-range-declaration :
expression) statement is expanded in terms which require a Range
concept, and the program is ill-formed if &lt;iterator_concepts&gt;
isn't included. For users, iterating through old-fashioned arrays,
this is a sledge-hammer to crack a nut and compares poorly with
other languages. It's also not possible to implement this without
adversely impacting the freestanding definition in 17.6.2.4.
<p align="left"><br>
<td>
<p align="left">When
expression is an array a of length N whose length is known at
compile time, expand range-for as 'for (... p=a, p!=a+N, p++) ...'
without requiring the Range concept or &lt;iterator_concepts&gt;.
Also, when expression is an initializer_list, expand range-for
similarly without requiring &lt;iterator_concepts&gt;.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>DE-11
<td>
<p>6.9
<td>
<p>p1
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
DE-11 A sentence in paragraph
1 reads: "Outside of a constrained context, the late-checked block
has no effect." This, at face value, specifies that the
<em>compound-statement</em> of such a late-checked block is never
executed, which appears to be unintended.
<p><br>
<td>
<p>State that such a
late-checked block has the same meaning as if the late_check keyword were absent.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
80
<td>
<p align="justify">7
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Many of the sections and major subsections open
with a sentence summarising the content. I'm not sure this is
necessary; this isn't a tutorial. The problem with these summaries
is that because they omit much of the detail, they tend to be
inaccurate. This may not matter, but I feel the document would be
improved by omitting them. There's a prime example here:
"Declarations specify how names are to be interpreted." Not true
for static_assert, an asm declaration nor an anonymous bit
field.
<p align="left"><br>
<td>
<p align="left">Strike the
first sentence.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
81
<td>
<p align="justify">7
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">String literal concatenation happens in phase 6,
before parsing, so it is legal and useful to use it for the string
literal in a static_assert. It would be useful to add a note
mentioning this.
<p align="left"><br>
<td>
<p align="left">Add a note:
Multiple adjacent string literals may be used instead of a single
/string-literal/; see [lex.phases].
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
82
<td>
<p align="justify">7
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Paragraph 2 talks about declarations that can have
nested declarations within them. It doesn't mention scoped
enumerations - but according to 7.2/11, "Each scoped enumerator is
declared in the scope of the enumeration."
<p align="left"><br>
<td>
<p align="left">Add "scoped
enumeration" to the list in the second sentence.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
83
<td>
<p align="justify">7.1
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The longest sequence of decl-specifiers that could
possibly be a type name is taken as the decl-specifier-seq of a
declaration. But many sequences of decl-specifiers cannot possibly
be a type name - eg the sequence "friend int", or "typedef
int".
<p align="left"><br>
<td>
<p align="left">Not sure. I
understand the rule, just not how to say it.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
84
<td>
<p align="justify">7.1
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The grammar includes alignment-specifier as a
production for decl-specifier, but there is no production for
alignment-specifier. I suspect this is a holdover from before
alignment was handled as an attribute.
<p align="left"><br>
<td>
<p align="left">Delete the
production (including the duplicate in A6)
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FI 3
<td>
<p>7.1
<td>
<p>[dcl.spec.auto]
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
While it&#8217;s considered
too late for this standard revision, consider loosening the
restrictions for auto specifier and making it more a mirror of a
deduced template function parameter.
<p><br>
<td>
<p>See
restricted-auto.ppt
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
85
<td>
<p align="justify">7.1.1
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">... the init-declarator-list of the declaration
shall not be empty (except for global anonymous unions, which shall
be declared static). Global here means "declared at namespace
scope". (cf 9.5/3 "Anonymous unions declared in a named namespace
or in the global namespace shall be declared static.").
<p align="left"><br>
<td>
<p align="left">Replace
"global" with "namespace scope".
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
86
<td>
<p align="justify">7.1.1
<td>
<p align="justify">2,3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The register keyword serves very little function,
offering no more than a hint that a note says is typically ignored.
It should be deprecated in this version of the standard, freeing
the reserved name up for use in a future standard, much like auto
has been re-used this time around for being similarly
useless.
<p align="left"><br>
<td>
<p align="left">Deprecate
current usage of the register keyword.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
87
<td>
<p align="justify">7.1.1
<td>
<p align="justify">1, 4,
5
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Why require two keywords, where one on its own
becomes ill-formed? thread_local should imply 'static' in this
case, and the combination of keywords should be banned rather than
required. This would also eliminate the one of two exceptions
documented in 7.1.1p1.
<p align="left"><br>
<td>
<p align="left">Drop
requirement to combine static keyword with thread_local at
block-scope inside a function definition.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 36
<td>
<p lang="en-GB" align="left">7.1.1
<td>
<p lang="en-GB" align="left">4
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The permission to use thread_local
static data members is missing.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">Add the static members as a permitted use.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 23
<td>
<p>7.1.5 [constexpr]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">'constexpr' functions should be allowed to
take const reference parameters, as long as their uses are in a
context where a constant expression may be required. For example,
the following should be allowed
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">template&lt;typename T, int N&gt;
<p style="margin-bottom: 0in">int size(const T(&amp;)[N]) { return N;
}
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">int a[] = { 41,42,43,44 };
<p style="margin-bottom: 0in">enum { v = size(a) };
<p style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 12
<td>
<p lang="en-GB" align="left">7.1.5
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
It should be allowed to
define constexpr recursively.
<p lang="en-GB" align="left" style="margin-bottom: 0in">There is an explanation in N2235,
Generalized Constant Expressions&#8212;Revision 5, as
follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"margin-left: 0.39in; margin-bottom: 0in">We (still) prohibit recursion in all its form in
constant expressions. That is not strictly necessary because an
implementation limit on recursion depth in constant expression
evaluation would save us from the possibility of the compiler
recursing forever. However, until we see a convincing use case for
recursion, we don&#8217;t propose to allow it.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Then, here are the use cases where
allowing recursion for constexpr is very useful.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Range of problem to be handled with
constexpr would become extended. For example, user defined type
(e.g. Complex type) could be placed in ROM area. But with current
specification, a function defined with constexpr cannot be called
recursively. As a side effect is not allowed in compile-time, it
cannot be implemented to repeat anything without recursion.
Although it could be implemented without recursion like func0,
func1, func2 in an example below, it is not elegant
solution.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">constexpr double func0(double x) { /*
... */}
<p lang="en-GB" align="left" style="margin-bottom: 0in">constexpr double func1(double x) { /*
call for func0 */ }
<p lang="en-GB" align="left" style="margin-bottom: 0in">constexpr double func2(double x) { /*
call for func1 */ }
<p lang="en-GB" align="left" style="margin-bottom: 0in">/* ... */
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">- Compile-time and runtime
<p lang="en-GB" align="left" style="margin-bottom: 0in">As constexpr can be also evaluated both
in compile-time and runtime, we need to discuss about both
cases.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Runtime evaluation is just to execute
it. If you eliminate constexpr keyword, it is executable as of now.
Any modern compiler may optimize tail recursion easily.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Compile-time evaluation is the same
thing as template recursion. It is necessary to support floating
point operation, but it is already possible to calculate it in
compile-time, so it&#8217;s ok.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">- Sample
<p lang="en-GB" align="left" style="margin-bottom: 0in">Here is an example to calculate a square
root using constexpr recursively.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">/*constexpr*/ double SqrtHelper(double
x, double a, int n)
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">return n == 0 ? a : SqrtHelper(x, (x / a
+ a) / 2.0, n - 1);
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">/*constexpr*/ double Sqrt(double
x)
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">return SqrtHelper(x, x, 20);
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">/*constexpr*/ double root2 = Sqrt(2.0); //
1.41421...
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Allow constexpr recursion.
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 37
<td>
<p lang="en-GB" align="left">7.1.6.1
<td>
<p lang="en-GB" align="left">1
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">There is a "Note: 3.9.3 describes how
cv-qualifiers affect object and function types." So far as I can
see, 3.9.3 CV-qualifiers only describes cv-qualifiers for objects,
cv-qualifiers for (member) functions being described in 8.3.5
Functions.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
89
<td>
<p align="justify">7.1.6.1
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The two normative sentences in this paragraph
appear to duplicate text elsewhere - but they aren't exact
duplicates, which introduces uncertainty. 1. "An object declared in
namespace scope with a const-qualified type has internal linkage
unless it is explicitly declared extern or unless it was previously
declared to have external linkage.". This nearly repeats 7.1.1/7:
"Objects declared const and not explicitly declared extern have
internal linkage." The former seems to allow more wiggle room - can
an object be "previously declared to have external linkage" without
having been "explicitly declared extern"? 2. "A variable of
non-volatile const-qualified integral or enumeration type
initialized by an integral constant expression can be used in
integral constant expressions (5.19)." This nearly duplicates
5.19/2, bullet 4, 1st sub-bullet - "[... an integaral constant
expression can use] an lvalue of effective integral type that
refers to a non-volatile const variable or static data member
initialized with constant expressions". The latter does not allow
for lvalues of enumeration type (neither scoped not unscoped
enumerations are integral types - 3.9.1/7, and note 44). This seems
to be a flaw in 5.19/2.
<p align="left"><br>
<td>
<p align="left">Make the
normative text in this section into one or more notes, with cross
references, and correct the referenced text if necessary.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
90
<td>
<p align="justify">7.1.6.2
<td>
<p align="justify">para 1 and
table 9
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The grammar in paragraph one makes
"nested-name-specifier template simple-template-id" a
simple-type-specifier, but unlike all the others it is omitted from
table 9.
<p align="left"><br>
<td>
<p align="left">Add a row to
table 9 mentioning simple-template-id and punting to clause 14 (cf
decltype(expression)).
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
91
<td>
<p align="justify">7.1.6.2
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">5.1/5 says "[A] parenthesized expression can be
used in exactly the same contexts as those where the enclosed
expression can be used, and with the same meaning, except as
otherwise indicated." When the first bullet point of this
paragraph, describing the type denoted by decltype(e), says "if e
is an id-expression ... decltype(e) is the type of the entity named
by e", 5.1/5 is not excluded, which would imply that decltype((e))
was also the type of e. But the intention appears that it should be
caught by the third bullet and treated as an lvalue expression, so
decltype((e)) should be a reference to the type of e. Conversely,
the second bullet point says "(parentheses around e are ignored)",
which is redundant because of 5.1/5.
<p align="left"><br>
<td>
<p align="left">Insert
"unparenthised" in the first bullet point - "if e is an
*unparenthised* id-expression ...". In the second bullet point,
move "(parentheses around e are ignored)" into a note.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
92
<td>
<p align="justify">7.1.6.3
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The note correctly indicates that, if T is a
template type parameter, then "friend class T;" is ill-formed. It
might be worth pointing out at the same time that the alternative
"friend T;" is now allowed - see 11.4/3.
<p align="left"><br>
<td>
<p align="left">Either strike
the note or add reference to 11.4/3 and/or mention of "friend
T;".
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
93
<td>
<p align="justify">7.1.6.3
<td>
<p align="justify">Grammar
before para 1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">In the third production, "enum ::opt
nested-name-specifieropt identifier", enum should not be in
italics; its referring to the enum keyword.
<p align="left"><br>
<td>
<p align="left">Change to
keyword font
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
94
<td>
<p align="justify">7.1.6.4
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left">The auto
type-specifier signifies that the type of an object being declared
shall be deduced from its initializer or specified explicitly at
the end of a function declarator. A function declarator does not
declare an object.
<td>
<p align="left" style="margin-bottom: 0in">The auto type-specifier signifies that the type of
an object being declared shall be deduced from its initializer or
that the return type of a function is specified explicitly at the
end of a function declarator.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
95
<td>
<p align="justify">7.1.6.4
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">(See also c++std-core-13583) This paragraph allows
auto "in the type-specifier-seq in a new-type-id (5.3.4)" (and
nowhere else not listed). Specifically, it isn't allowed in a
type-id in a new-expression. That allows "new auto (42)", but not
"new (auto)(42)". However, 5.3.4/2 suggests the latter should be
allowed "If the auto type-specifier appears in the
type-specifier-seq of a new-type-id or type-id of a new-expression
...". The inconsistency should be resolved, ideally in favour of
allowing both forms.
<p align="left"><br>
<td>
<p align="left">Change "in a
new-type-id" to "in a new-type-id or type-id in a
new-expression".
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 24
<td>
<p>7.1.6.4 [auto
specifier]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">Now that 'auto' is finally used in its
most obvious sense to state `deduce the type of this variable from
initializer', it should also be allowed in template parameter
declarations, as in
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">template&lt;auto n&gt; struct X { /*
&#8230; */ };
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">X&lt;903&gt; x;
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">X&lt;&amp;Widget::callback&gt; y;
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">instead of the current, often verbose and
cumbersome
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in"><span lang=
"fr-FR">template&lt;typename T, T n&gt; struct X { /*
&#8230;</span> <font face="Consolas, monospace">*/ };</font>
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">X&lt;int,903&gt; x;
<p style="margin-bottom: 0in">X&lt;void
(Widget::*)(),&amp;Widget::callback&gt; y;
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">We understand that 'auto' is used in
14.1/18 in a different way (for constrained template), but that
usable appears very strange syntax, unnatural and does not fit well
with the usage in this section.
<p style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 38
<td>
<p lang="en-GB" align="left">7.2
<td>
<p lang="en-GB" align="left">1
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The discussion of attribute specifiers
should be a separate paragraph.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 39
<td>
<p lang="en-GB" align="left">7.2
<td>
<p lang="en-GB" align="left">2
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The paragraph says in part "An
opaque-enum-declaration declaring an unscoped enumeration shall not
omit the enum-base." This statement implies that the base may be
omitted for scoped enumerations, which is somewhat inconsistent
with paragraph 3 and somewhat consistent with paragraph 5.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">As this implication leaves no representation, it
should be either affirmed here or the statement should be expanded.
Perhaps a note is warranted.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 13
<td>
<p lang="en-GB" align="left">7.2
<td>
<p lang="en-GB" align="left">paragraph 3
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">In the description for an unscoped
enumeration, enum-base in redeclaration must be the same underlying
type as in the 1st declaration, but it is not described explicitly,
while it is referred that all enum-bases in redeclarations must
specify the same underlying type.
<p lang="en-GB" align="left"><br>
<td>
<p>Replace the description,
"same underlying type", with "same as underlying type of (previous)
declaration."
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
96
<td>
<p align="justify">7.2
<td>
<p align="justify">7
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">enum E { }; What are the values of E? It has
neither a smallest nor largest enumerator, so paragraph 7 doesn't
help. (Paragraph 6 indicates that the underlying type is as if E
had a single enumerator with value 0, but that does not define the
values of E.)
<p align="left"><br>
<td>
<p align="left">Add a second
sentence to paragraph 7 (before "Otherwise"): "If the
enumerator-list is empty, 0 is the only value of the
enumeration."
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
97
<td>
<p align="justify">7.2
<td>
<p align="justify">9
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Missing punctuation after "blue" in: "The possible
values of an object of type color are red, yellow, green, blue
these values can be converted ..."
<p align="left"><br>
<td>
<p align="left">Add a
semicolon: "The possible values of an object of type color are red,
yellow, green, blue; these values can be converted ..."
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
98
<td>
<p align="justify">7.2
<td>
<p align="justify">5
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It would be useful to be able to determine the
underlying type of an arbitrary enumeration type. This would allow
safe casting to an integral type (especially needed for scoped
enums, which do not promote), and would allow use of
numeric_limits. In general it makes generic programming with
enumerations easier.
<p align="left"><br>
<td>
<p align="left">Add a
TransformationTrait to 20.5.6 that returns the underlying type of
an enumeration type.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
99
<td>
<p align="justify">7.2
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It is unclear whether an enumeration type is
complete after an opaque-enum-declaration. This paragraph only says
so in a note, and the general rule in 3.9/5 ("Incompletely-defined
object types ... are incomplete types") is unclear in this
situation.
<p align="left"><br>
<td>
<p align="left">Move "an
enumeration declared by an opaque-enum-declaration ... is a
complete type" from the note to normative text.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 14
<td>
<p lang="en-GB" align="left">7.3.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-left: 0.2in; text-indent: -0.2in; margin-bottom: 0in">
The description of the
behavior when a member that was defined with same name in other
namespace was referred.
<p lang="en-GB" align="left" style=
"margin-left: 0.45in; text-indent: -0.25in; margin-bottom: 0in">
- It seems that the behavior
of the following case is not defined. So we think that it is
necessary to define that.
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">namespace Q {
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">inline namespace V {
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">int g;
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">}
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">int g;
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">}
<p lang="en-GB" align="left" style=
"margin-left: 0.67in; margin-bottom: 0in">Q::g =1;// ill-fromed, Q::V::g =1;, or Q::g =
1;?
<p lang="en-GB" align="left" style=
"margin-left: 0.45in; text-indent: -0.25in; margin-bottom: 0in">
- Add that the following case
is ill-formed to more easily to understand.
<p lang="en-GB" align="left" style=
"margin-left: 0.5in; margin-bottom: 0in">namespace Q {
<p lang="en-GB" align="left" style=
"margin-left: 0.5in; margin-bottom: 0in">inline namespace V1{
<p lang="en-GB" align="left" style=
"margin-left: 0.5in; margin-bottom: 0in">int g;
<p lang="en-GB" align="left" style=
"margin-left: 0.5in; margin-bottom: 0in">}
<p lang="en-GB" align="left" style=
"margin-left: 0.5in; margin-bottom: 0in">inline namespace V2{
<p lang="en-GB" align="left" style=
"margin-left: 0.5in; margin-bottom: 0in">int g;
<p lang="en-GB" align="left" style=
"margin-left: 0.5in; margin-bottom: 0in">}
<p lang="en-GB" align="left" style=
"margin-left: 0.5in; margin-bottom: 0in">}
<p lang="en-GB" align="left" style=
"text-indent: 0.44in; margin-bottom: 0in">Q::g =1;//ill-formed
<p lang="en-GB" align="left" style="text-indent: 0.44in"><br>
<td>
<p lang="en-GB" align="left" style=
"margin-left: 0.2in; text-indent: -0.2in; margin-bottom: 0in">
Add the description of the
behavior when a member that was defined with same name in other
namespace was referred.
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
100
<td>
<p align="justify">7.3.3
<td>
<p align="justify">10 and
13
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Para 10 says "A using-declaration is a declaration
and can therefore be used repeatedly where (and only where)
multiple declarations are allowed." Para 13 says "Since a
using-declaration is a declaration, the restrictions on
declarations of the same name in the same declarative region (3.3)
also apply to using-declarations." These appear to be saying
exactly the same thing.
<p align="left"><br>
<td>
<p align="left">Delete para
10, moving its example into para 13.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
101
<td>
<p align="justify">7.3.3
<td>
<p align="justify">20
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">If a using-declaration uses the keyword typename
and specifies a dependent name (14.6.2), the name introduced by the
using-declaration is treated as a typedef-name (7.1.3). That
doesn't specify at all what the effect of using typename with a
non-dependent name is. Is it allowed? What about outside any
template? What if the name isn't a type? (14.6/4 doesn't cover
this, I think.)
<p align="left"><br>
<td>
<p align="left">Allow
typename for non-dependent names iff they refer to a type.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>DE-12
<td>
<p>7.3.3
<td>
<p>p15
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
DE-12 Overriding and hiding
of member functions named in using-declarations should consider
ref-qualifiers, because they are part of the function type.
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 25
<td>
<p>7.3.3 [The using
declaration]
<td>
<p>Paragraph 21
<td>
<p>te
<td>
<p>The syntax for concept map alias is
unnecessarily both confused and verbose.
<td>
<p style="margin-bottom: 0in">We strongly suggest simplifications,
e.g.
<p style="margin-bottom: 0in">using N1::C&lt;int&gt;;
<p style="margin-bottom: 0in">that fits well with existing constructs.
The syntactic complexity is too high for a new feature presumably
designed to support sound programming.
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
102
<td>
<p align="justify">7.3.4
<td>
<p align="justify">6
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">This paragraph says "If name lookup finds a
declaration for a name in two different namespaces, and the
declarations do not declare the same entity and do not declare
functions, the use of the name is ill-formed." But the example uses
declaration of functions, so is not covered by this
paragraph.
<p align="left"><br>
<td>
<p align="left">Move the
example to paragraph 7, and/or replace it with an appropriate
example.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 40
<td>
<p lang="en-GB" align="left">7.6
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The list of attributes is missing an attribute to
indicate that a function with a <font size=
"2" style="font-size: 11pt"> <code>throw()</code> (throws nothing) clause need
not have the <code>unexpected()</code> catch clause generated. This attribute was a
motivating example for the attribute syntax, and its omission is
surprising.</font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">Add the attribute.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 41
<td>
<p lang="en-GB" align="left">7.6
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">A common problem is unintentionally
declaring a new virtual member function instead of overriding a
base virtual member function.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">An attribute stating intent to override would
enable better diagnostics.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 26
<td>
<p>7.6 [Attributes]
<td>
<p><br>
<td>
<p>ed
<td>
<p style="margin-bottom: 0in">Are they part of object types or not? The
section does not appear to indicate that clearly.
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FI 1
<td>
<p>7.6
<td>
<p><br>
<td>
<p>te
<td>
<p>Add override-attribute for
functions in order to avoid mistakes when overriding
functions.
<td>
<p>See
override&#173;-attribute.doc, override-attribute.ppt
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 27
<td>
<p>7.6.1
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">This section specifies that no name lookup
is performed on any identifier contained in an attribute-token.
This in particular implies that, for example, it is impossible to
define a template class parameterized by its alignment. That
restriction is unacceptable.
<p style="margin-bottom: 0in">The original alignment proposal made that
useful construct possible.
<p style="margin-bottom: 0in">Furthermore paragraph 7.6.1/2 appears
contradictory with the rest of that section -- since no name lookup
is performed, how a 'type-id'is determined?
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
103
<td>
<p align="justify">7.6.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">Attributes
should support pack expansion. For example, this would be extremely
useful with the align attribute, directly supporting the (removed)
functionality of aligned_union. NOte that aligned_union was removed
as varaiant-unions were considered a complete replacement - however
this is not true for variadic templates. Adding this support to
attributes would remove the remaining need, and support similar
attributes in the future.
<td>
<p align="left">Add:
attribute... to the grammar for attribute-list Add to list in
14.5.3p4: "In an attribute-list(7.6.1); the pattern is an
attribute."
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
104
<td>
<p align="justify">7.6.1
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">It is helpful for each subclause to contain a
short paragraph introducing its intent an purpose. 7.6 has such a
paragraph, but it is nested under a more specific
subsection.
<p align="left"><br>
<td>
<p align="left">7.6.1p1
should move up one level to become 7.6p1. There grammar should
remain under 7.6.1
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
105
<td>
<p align="justify">7.6.1
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left">Allowing only
one level of namespaces in attributes seems unnecessarily
limiting.
<td>
<p align="left">To:
attribute-scoped-token: attribute-namespace :: identifier add
attribute-namespace :: attribute-scoped-token
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
106
<td>
<p align="justify">7.6.2
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Extensive use of alignment and related terms
without cross reference.
<p align="left"><br>
<td>
<p align="left">Add
cross-reference to 3.11.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 15
<td>
<p lang="en-GB" align="left">7.6.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
An abbreviation of 7.6.2
should be &#8220;[decl.attr.align]&#8221; instead of
&#8220;[dcl.align]&#8221;.<br>
Section name &#8220;[dcl.align]&#8221; is not consistent with
others, because others in 7.6 are the form of
&#8220;dcl.attr.*&#8221;. In N2761, the section name of 7.1.7 had
been changed from &#8220;[dcl.align]&#8221; to
&#8220;[dcl.attr.align]&#8221;, but in N2800 it was reverted to
&#8220;[dcl.align]&#8221; along with a change of section number,
7.1.7 to 7.6.2.
<p><br>
<td>
<p>Change "[dcl.align]" of
7.6.2 to "[decl.attr.align]".
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
107
<td>
<p align="justify">7.6.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">While undefined behaviour might be the best we can
guarantee, it would be helpful to encourage implementations to
diagnose function definitions that might execute a return.
<p align="left"><br>
<td>
<p align="left">Adda a [Note
: implementations are encouraged to issue a diagnostic where the
definition of a function marked [[noreturn]] might execute a return
statement -- end note]
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
108
<td>
<p align="justify">7.6.4
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It is unclear why no diagnostic is required for an
easily detectable violation. It is even more surprising that the
associated footnote mandates behaviour for an ill-formed
program.
<p align="left"><br>
<td>
<p align="left">Strike "no
diagnostic required" and the associated footnote.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 42
<td>
<p lang="en-GB" align="left">7.6.4
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The meaning of the <font size=
"2" style="font-size: 11pt"> <code>[[final]]</code> attribute applied to classes is inconsistent with
other languages and not desirable in its own right.</font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Modify the semantics of <font size=
"2" style="font-size: 11pt"> <code>[[final]]</code> applied to classes. See the attached paper "Issues
with the C++ Standard" under Chapter 7 "Meaning of
<code>[[final]]</code> attribute applied to classes".</font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
109
<td>
<p align="justify">7.6.5
<td>
<p align="justify">4
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The example code refers in comments to
"Compilation unit" A and B. The term should be "Translation unit"
(2/1)
<p align="left"><br>
<td>
<p align="left">Replace
"Compilation" with "Translation" in two places
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p><br>
<td>
<p align="justify"><br>
<td>
<p align="justify"><br>
<td>
<p align="justify"><br>
<td>
<p align="left"><br>
<td>
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
110
<td>
<p align="justify">7.6.5
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The code in the example (compilation unit A) has:
"foo_head[i].load(memory_order_consume)". foo_head[i] is of type
foo *, so it does not have a load member.
<p align="left"><br>
<td>
<p align="left">Change the
type of foo_head to atomic&lt;foo *&gt;[].
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 43
<td>
<p lang="en-GB" align="left">8
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">With the introduction of late-specified return
types for functions and lambda expressions, we now have three
different syntaxes for declaring functions. The <font size=
"2" style="font-size: 11pt">
<code>-&gt;</code> late declaration is used in two. The
<code>auto</code> keyword is used in one, but also used differently
in variable definitions.</font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">Some simplification is needed.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
111
<td>
<p align="justify">8.3.5
<td>
<p align="justify">13
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Example missing closing bracket in
template&lt;typename... T&gt; void f(T (* ...t)(int, int);
<p align="left"><br>
<td>
<p align="left">Add closing
bracket like this: template&lt;typename... T&gt; void f(T (*
...t)(int, int));
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 44
<td>
<p lang="en-GB" align="left">8.3.5
<td>
<p lang="en-GB" align="left">13
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">In the Example, "template void f(T (*
...t)(int, int);" is missing a close parenthesis.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">It presumably should read: "template void f(T (*
...t))(int, int);".
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="left">US 45
<td>
<p align="left">8.3.5
<td>
<p align="left">13
<td>
<p align="left">te
<td>
<p align="left" style="margin-bottom: 0in">At present, function
parameter packs can only occur at the end of a
parameter-declaration-list. This restriction unnecessarily
prohibits uses of function parameter packs in cases where template
argument deduction isn&#8217;t needed, e.g.,
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">template&lt;class...
T&gt; struct X { };
<p align="left" style="margin-bottom: 0in">template&lt;class... T1,
class... T2&gt;
<p align="left" style="margin-bottom: 0in">struct X&lt;pair&lt;T1,
T2&gt;...&gt; {
<p align="left" style="margin-bottom: 0in">void f(T1...,
T2...);
<p align="left" style="margin-bottom: 0in">};
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">More importantly, this
restriction is inconsistent with the way pack expansions are
handled. For example, this template is well-formed (but X&lt;T...,
int&gt; is a non-deduced context):
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">template&lt;class...
T&gt; void f(X&lt;T..., int&gt;);
<p align="left" style="margin-bottom: 0in"><br>
<p align="left">Therefore, the restriction that limits function
parameter packs to the end of the parameter-declaration-list should
be removed. Instead, function parameter packs not at the end of the
parameter-declaration-list should be considered non-deduced
contexts.
<td>
<p align="left" style="margin-bottom: 0in">In 8.3.5p13, remove the sentence
&#8220;<span lang="">A function parameter pack, if
present, shall occur at the end of the
parameter-declaration-list.&#8221;</span>
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in"><span lang="">In 14.8.2.1p1, replace the phrase
&#8220;For a function parameter pack&#8221; with &#8220;For a
function parameter pack that occurs at the end of a</span><font size="3"> </font><font size="3" face=
"Helvetica, sans-serif"><span lang=
""><i>parameter-declaration-list</i>&#8221;.</span></font>
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in"><span lang="">Replace the note text &#8220;A
function parameter pack can only occur at the end of a
parameter-declaration-</span>list (8.3.5).&#8221; with
&#8220;A function parameter pack that does not occur at the end of
a parameter-declaration-list is a non-deduced
context.&#8221;
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In 14.8.2.5p5, add a new
bullet: &#8220;A function parameter pack that does not occur at the
end of its parameter-declaration-list.&#8221;
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In 14.8.2.5p10, replace
&#8220;<span lang="">If</span><font size="3" face=
"Helvetica, sans-serif"> the
parameter-declaration corresponding to Pi is a function parameter
pack&#8221; with &#8220;<span lang=
"">If</span><font size="3"> the parameter-declaration corresponding to Pi
is a function parameter pack and Pi occurs at the end of the
parameter-declaration-list&#8221;.</font></font>
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">Replace<font size="3"> </font><font size="3" face=
"Helvetica, sans-serif"><span lang="">the note
text &#8220;A function parameter pack can only occur at the end of
a parameter-declaration-</span>list (8.3.5).&#8221; with
&#8220;A function parameter pack that does not occur at the end of
a parameter-declaration-list is a non-deduced
context.&#8221;</font>
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>DE-13
<td>
<p>8.4
<td>
<p>p2
<td>
<p>te
<td>
<p>DE-13 The second
paragraph, quoting the grammar for the declarator of a function
declaration, is not considering late-specified return types and
attributes.
<td>
<p>Properly quote the grammar
from 8.3.5.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>JP 16
<td>
<p lang="en-GB" align="left">8.5
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">15<sup>th</sup><font size=
"2" style="font-size: 11pt"> paragraph, 1<sup>st</sup> line</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo, duplicated "in"
<p lang="en-GB" align="left">"The initialization that occurs in in the
forms"
<td>
<p>Remove one.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p align="left">US 46
<td>
<p align="left">8.5.3
<td>
<p align="left"><br>
<td>
<p align="left">te
<td>
<p align="left" style="margin-bottom: 0in">The ability for an rvalue
reference to bind to an lvalue opens a type-safety hole that
becomes very dangerous with concepts. For example, consider
vector&#8217;s push_back operation:
<p align="left" style="margin-bottom: 0in">requires
MoveConstructible&lt;T&gt; void push_back(T&amp;&amp;);
<p align="left" style="margin-bottom: 0in">requires
CopyConstructible&lt;T&gt; void push_back(const T&amp;);
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">For a copy-constructible
T (which is also move-constructible), push_back does the right
thing. However, if T is something that is move-constructible (e.g.,
unique_ptr&lt;int&gt;), the second overload is removed from
considered (it is effectively SFINAE&#8217;d away), so only the
first overload remains. Therefore, one could accidentally call
push_back with an lvalue of type T, and push_back would silently
move from the lvalue. The same problem occurs without concepts
(albeit less frequently).
<p align="left" style="margin-bottom: 0in"><br>
<p align="left"><br>
<td>
<p align="left" style="margin-bottom: 0in">Prohibit rvalue
references from binding to lvalues.
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">Unfortunately this change
will break some current use cases of rvalue reference including the
use of rvalue streams, and of the forward function itself. To
resolve this we may want to consider three types of
references:
<p align="left" style="margin-bottom: 0in"><br>
<ol>
<li>
<p align="left" style="margin-bottom: 0in">The current
reference.
<li>
<p align="left" style="margin-bottom: 0in">A non-const reference
that only binds to rvalues.
<li>
<p align="left" style="margin-bottom: 0in">A non-const reference
that will bind to both lvalues and rvalues.</ol>
<p align="left" style="margin-bottom: 0in"><br>
<p align="left">Still another solution would be to adopt the
&#8220;deleted function&#8221; solution for all functions. This
solution is described in comment for 12.1, 12.4, 12.8, but
restricted to special functions in that comment. (See US
NN).
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 49
<td>
<p lang="en-GB" align="left">8.5.4
<td>
<p lang="en-GB" align="left">6
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left">In the Example, the comments could be
improved.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">See the attached paper "Issues with the
C++ Standard" under "Editorial Issues" and "8.5.4/6".
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
112
<td>
<p align="justify">9
<td>
<p align="justify">4-9
<td>
<p align="justify">Ge
<td>
<p align="left" style="margin-bottom: 0in">We now have concepts that should (or should not?)
map to the terms described in Clause 9 - these should be at least
referenced.
<p align="left"><br>
<td>
<p align="left">Add
appropriate forward references to 14.9.4
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
113
<td>
<p align="justify">9.4.2
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left">Mis-applied
edit from the paper n2756
<td>
<p align="left">The term
'constant-initializer' should have been struck out when replaced by
brace-or-equal-initializer. There are two occurrences in this
paragraph
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="left">US 50
<td>
<p align="left">12.1, 12.4, 12.8
<td>
<p align="left"><br>
<td>
<p align="left">te
<td>
<p align="left" style="margin-bottom: 0in">Implicitly-declared
default constructors, destructors, copy constructors, and copy
assignment operators are deleted when their definitions would be
ill-formed. However, unlike with overloading and template argument
deduction, access control is performed as part of the check for
making one of these special function deleted. This inconsistency
should be removed.
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">This change would
sacrifice some backward compatibility in favor of consistency. With
the current wording, checking that the following class
&#8216;A&#8217; is CopyConstructible would proceed without error
(it is not CopyConstructible):
<p align="left" style="margin-bottom: 0in">class A { A(const
A&amp;); };
<p align="left" style="margin-bottom: 0in">With the proposed change,
testing whether A is CopyConstructible would produce a diagnostic.
To fix the problem, the user would have to use a deleted
function:
<p align="left" style="margin-bottom: 0in">class A { A(const A&amp;)
= delete; };
<p align="left"><br>
<td>
<p align="left" style="margin-bottom: 0in">In 12.1p5, remove the phrase
&#8220;<span lang="">or inaccessible from the
implicitly-declared default</span><font size="3" face=
"Helvetica, sans-serif"> constructor&#8221;.</font>
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In 12.4p3, remove the phrase
&#8220;<span lang="">or a destructor that is
inaccessible from the implicitly-declared destructor,&#8221; and
the phrase &#8220;or a destructor that is inaccessible from
the</span><font size="3" face=
"Helvetica, sans-serif"> implicitly-declared
destructor<span lang="">&#8221;.</span></font>
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In 12.8p5, remove the phrase
&#8220;<span lang="">or inaccessible from the
implicitly-declared copy constructor&#8221; from the two places it
occurs.</span>
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In 12.8p10, remove the phrase
&#8220;<span lang="">or inaccessible from the
implicitly-declared copy assignment operator&#8221; from the two
places it occurs.</span>
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>FR 28
<td>
<p style="margin-bottom: 0in">12.6.1 [Explicit initialization]
<p><br>
<td>
<p><br>
<td>
<p>te
<td>
<p>This section, in particular the example with
`g' appears contradictory with the syntax for uniform
initialization.
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 51
<td>
<p lang="en-GB" align="left">12.6.2
<td>
<p lang="en-GB" align="left">2
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The discussion of delegating
constructors should be in its own paragraph.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
114
<td>
<p align="justify">12.6.2
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left">Despite all
the attempts to unify initialization syntax, it is still not
possible to copy-initialize base classes or non-static data
members, which means the explicit keyword cannot have a bearing
during evaluation of a constructor. A minimal addition to the
grammar, allowing an optional = between the mem-initializer-id and
braced-init-list would allow the user to choose between copy and
direct initialization
<td>
<p align="left" style="margin-bottom: 0in">Ammend the grammar for mem-initializer:
mem-initializer-id =OPT braced-init-list Extend p3 to allow for
Copy Initialization if the optional = is present: 3 The
expression-list or braced-init-list in a mem-initializer is used to
initialize the base class or non-static data member subobject
denoted by the mem-initializer-id according to the initialization
rules of 8.5 for direct-initialization, OR COPY-INITIALIZATION IF
THE OPTIONAL = IS PRESENT BETWEEN THE MEM-INITIALIZER-ID and the
BRACED-INIT-LIST. [Example:...
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>US 52
<td>
<p>13.5.8
<td>
<p>&#182; 5
<td>
<p>ed
<td>
<p>A word is
misspelled.
<td>
<p>Change &#8220;shal&#8221;
to &#8220;shall&#8221;.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
115
<td>
<p align="justify">14
<td>
<p align="justify">6-11
<td>
<p align="justify">Ge
<td>
<p align="left" style="margin-bottom: 0in">Exported templates were a great idea that is
generally understood to have failed. In the decade since the
standard was adopted, only one implementation has appeared. No
current vendors appear interested in creating another. We
tentatively suggest this makes the feature ripe for deprecation.
Our main concern with deprecation is that it might turn out that
exported constrained templates become an important compile-time
optimization, as the constraints would be checked once in the
exported definition and not in each translation unit consuming the
exported declarations.
<p align="left"><br>
<td>
<p align="left">Consider
deprecating exported templates, but no action yet. Examine
interaction with constrained templates, and see if other more
appropriate mechanism will support compile-time
optimization.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
116
<td>
<p align="justify">14
<td>
<p align="justify">6-11
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Is it possible to export a concept map template?
The current wording suggests it is possible, but it is not entirely
clear what it would mean.
<p align="left"><br>
<td>
<p align="left">Either
prohibit exporting concept map templates, or more directly address
what it means to export a concept map.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
117
<td>
<p align="justify">14
<td>
<p align="justify">2
<td>
<p align="justify">Ge
<td>
<p align="left" style="margin-bottom: 0in">It would be nice to allow template alias within a
function scope, and possibly a scoped concept map. As these affect
name lookup and resolution, rather than defining new callable code,
they are not seen to present the same problems that prevented class
and function templates in the past.
<p align="left"><br>
<td>
<p align="left">Allow
template aliases to be declared inside a function scope, and
consider scoped concept maps.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
118
<td>
<p align="justify">14
<td>
<p align="justify">6-11
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Exported templates are a complicated feature with
surprisingly little text. To make this important text more visible,
split it off into its own subclause [temp.export]
<p align="left"><br>
<td>
<p align="left">Create a new
subclause [temp.export] containing 14p6-11. Move 14p12 ahead of
this subclause.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
119
<td>
<p align="justify">14
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Does a concept map have linkage? Reading this
paragraph and 3.5 suggests a concept map template has external
linkage, but not a 'regular' concept map. Believe this is an
oversight that the linkage words were not updated to provide an
exception, rather than linkage of concept maps is intended.
<p align="left"><br>
<td>
<p align="left">Add an
exception that concept map templates have no linkage, or add
concept maps to the list of entities with linkage in 3.5
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
120
<td>
<p align="justify">14.1
<td>
<p align="justify">9
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">As this is the first time the phrase
&#8220;parameter pack&#8221; appears in Ch 14 I would like to see
the section 8.3.5 referenced here (as well as in 14.1p17).
<p align="left"><br>
<td>
<p align="left">Insert
&#8220;(8.3.5)&#8221; after &#8220;parameter pack&#8221;
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
121
<td>
<p align="justify">14.1
<td>
<p align="justify">18
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The example (that follows the normative text) has
no begin example marker
<p align="left"><br>
<td>
<p align="left">Prefix the
example code with "[ Example:"
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 29
<td>
<p style="margin-bottom: 0in">14.3 [Template arguments]
<p><br>
<td>
<p><br>
<td>
<p>te
<td>
<p>Constant expressions of any literal type should
be allowed as template arguments.
<td>
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p align="left">US 53
<td>
<p align="left">14.5.1
<td>
<p align="left">5
<td>
<p align="left">te
<td>
<p align="left" style="margin-bottom: 0in">If the requirements of a constrained member
that is a copy constructor, copy assignment operator, or destructor
are not satisfied, then that user-declared special function will
not exist. It appears that, in this case, the special function will
then be<font size="3"> </font><font size="3" face=
"Helvetica, sans-serif"><i>implicitly</i><font size="3"> defined, which is likely
to either (a) fail to compile or (b) produce a function with the
wrong semantics. For example:</font></font>
<p align="left" style="margin-bottom: 0in">template&lt;ObjectType
T&gt; class vector {
<p align="left" style="margin-bottom: 0in">T* first, last,
end;
<p align="left" style="margin-bottom: 0in">public:
<p align="left" style="margin-bottom: 0in">requires
CopyConstructible&lt;T&gt; vector(const vector&amp;);
<p align="left" style="margin-bottom: 0in">};
<p align="left" style="margin-bottom: 0in"><br>
<p align="left">If instantiated with a type that is not
CopyConstructible, vector will get an implicitly-defined copy
constructor that performs a copy of the pointers.
<td>
<p align="left" style="margin-bottom: 0in">Add to 14.5.1p5:
<p align="left">If the constrained member is a copy constructor
(12.8), destructor (12.4), or copy assignment operator and its
template requirements are not satisfied, then a copy constructor,
destructor, or copy assignment operator, respectively, with the
same signature as the constrained member (after substituting the
class template&#8217;s template arguments for its template
parameters) will be declared as a deleted function (8.4).
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
122
<td>
<p align="justify">14.5.3
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Variadic templates should be supported in axioms.
There are axioms in the library that rely on this feature, such as
the FrontEmplacement axiom in FrontEmplacementContainer
(23.1.6.1p10)
<p align="left"><br>
<td>
<p align="left">Add
clarification in p2 that function parameter packs can be used to
declare axioms, much like p1 clarifies they can be used to declare
concepts as well as templates.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>FR 30
<td>
<p>14.5.7 [Template aliases]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">When are two template alias names
equivalent?
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">E.g. given
<p style="margin-bottom: 0in">template&lt;template&lt;class&gt;
class&gt; struct X { };
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">template&lt;typename,typename&gt; struct Y
{ };
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">template&lt;typename T&gt;
<p style="margin-bottom: 0in">using Z1 = Y&lt;int,T&gt;;
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">template&lt;typename T&gt;
<p style="margin-bottom: 0in">using Z2 = Y&lt;int,T&gt;;
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">Are the types X&lt;Z1&gt; and X&lt;Z2&gt;
equivalent?
<p style="margin-bottom: 0in">We would suggest yes (since Z1&lt;T&gt;
and Z2&lt;T&gt; are the same for all T), but we do not see any
wording to that effect.
<p><br>
<td>
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>JP 17
<td>
<p lang="en-GB" align="left">14.7.2
<td>
<p lang="en-GB" align="left">2<sup>nd</sup><font size="2" style=
"font-size: 11pt"> paragraph, 15<sup>th</sup> line</font>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo.
<p lang="en-GB" align="left" style="margin-bottom: 0in">if that namespace is inline, any
namespace from its enclosing namespace set.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">if that namespace is inline, any namespace <font size=
"2" style="font-size: 11pt">
<font color=
"#339966">forming</font> its
enclosing namespace set.</font>
<p lang="en-GB" align="left"><br>
<td>
<p>Replace "from" with
"forming"
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>DE-14
<td>
<p>14.7.3
<td>
<p>p1
<td>
<p>te
<td>
<p>DE-14 The bulleted list
neither addresses "member function template of a class" nor "member
class template of a class".
<td>
<p>Add the respective
bullets.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 18
<td>
<p lang="en-GB" align="left">14.7.3
<td>
<p lang="en-GB" align="left">2<sup>nd</sup><font size="2" style=
"font-size: 11pt"> paragraph, 2<sup>nd</sup> line</font>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo,
<p lang="en-GB" align="left" style="margin-bottom: 0in">any namespace from its enclosing
namespace set
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">any namespace <font size=
"2" style="font-size: 11pt"> <font color="#339966">forming</font> its enclosing namespace set</font>
<p lang="en-GB" align="left"><br>
<td>
<p>Replace "from" with
"forming"
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 19
<td>
<p lang="en-GB" align="left">14.8.2
<td>
<p lang="en-GB" align="left">6<sup>th</sup><font size="2" style=
"font-size: 11pt"> paragraph, 1<sup>st</sup> line</font>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo, duplicated "is"
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">"At certain points in the template argument
deduction process it <u>is is</u> necessary"
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Remove one
<td>
<p><br>
<tr valign="top">
<td>
<p>US 54
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
14.9 [concept],
<p>14.10
[temp.constrained]
<td>
<p><br>
<td>
<p>ge
<td>
<p>Concepts is of course the
largest new feature in C++0x (in terms of new text inserted into
the wording), and already we have found some significant defects
with it. So far nothing devastating has been found, but more time
is needed to shake more bugs out.
<td>
<p>I propose no specific
change here.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 55
<td>
<p>14.9.1
<td>
<p>&#182; 6
<td>
<p>ed
<td>
<p>The paragraph number is in
the wrong place, causing a grammar rule to be indented more than
its fellows.
<td>
<p>Move the paragraph number
so as to follow the grammar rules, thus numbering the single
sentence, &#8220;The body of a concept &#8230; .&#8221;
<td>
<p><br>
<tr valign="top">
<td>
<p>US 56
<td>
<p>14.9.1
<td>
<p>&#182; 6
<td>
<p>ed
<td>
<p>The sentence contains two
references to 14.9.1.3 [concept.req].
<td>
<p>Change the second such
reference (at the end of the sentence) to 14.9.1.4
[concept.axiom].
<td>
<p><br>
<tr valign="top">
<td>
<p>US 57
<td>
<p>14.9.1.4
<td>
<p>&#182; 3
<td>
<p>ed
<td>
<p>A word is misplaced,
changing the intended meaning.
<td>
<p>Change &#8220;only find
&#8230; if&#8221; to &#8220;find &#8230; only if&#8221;.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 58
<td>
<p>14.9.1.4
<td>
<p>&#182; 3
<td>
<p>ed
<td>
<p>The listed phrases are not
grammatically parallel.
<td>
<p>Insert &#8220;in&#8221;
before &#8220;one&#8221; so as to obtain &#8220;... in the concept,
in one of its less refined concepts, or in an associated
requirement.&#8221;
<td>
<p><br>
<tr valign="top">
<td>
<p align="left">US 59
<td>
<p align="left">14.9.1.4
<td>
<p align="left"><br>
<td>
<p align="left">te
<td>
<p align="left">Axioms are under-specified and provide little
benefit to programmers, so they should be removed from the working
paper. The optimizations permitted by axioms (see 14.9.1.4p4-5) are
not compulsory (and, therefore, programmers cannot rely on them)
and the semantics expressed by axioms cannot be verified by any
implementation. The resulting specification has lead to great
confusion (see the reflector thread &#8220;Are floating point types
Regular?&#8221; starting with c++std-lib-22717). Given the level of
confusion and the inability to verify the correctness of axioms, it
is likely that many axioms written by programmers (including those
specified in the candidate draft) will be incorrect.
<td>
<p align="left" style="margin-bottom: 0in">Remove clause 14.9.1.4
[concept.axiom]
<p align="left" style="margin-bottom: 0in">In 2.11p1, remove
&#8220;axiom&#8221; from the list of keywords.
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In 14.5.8p7, remove
&#8220;, or if the resulting concept map fails to satisfy the
axioms of the corresponding concept&#8221;
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In 14.9.1p6, remove
axiom-definition from the list of grammar productions for
concept-member-specifier. Remove &#8220;, and axioms&#8221; from
the final sentence, and instead &#8220;and&#8221; prior to
&#8220;associated requirements&#8221; in the final sentence.
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">Remove paragraph 14 of
clause 14.9.2.
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In 14.10.1p6, remove the sentence, &#8220;When
the concept-instance-alias-def appears in the optional
requires-clause of an axiom-definition (14.9.1.4), the potential
scope of the identifier begins at its point of declaration and
terminates at the end of the
axiom-de&#64257;nition.&#8221;
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In clauses 20.2.5, 20.2.8, 23.1.6.1, 23.1.6.2,
and 24.1.4, remove the axiom-definitions and replace them with
paragraphs (denoted Requires, Postconditions, or Effects, as
appropriate) that express the intended semantics of the concepts
from which the axiom-definitions were removed.
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In 24.1.4p2, replace the
word &#8220;axiom&#8221; with &#8220;condition.&#8221;
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>FR 31
<td>
<p>14.9.1.4 [Axioms]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">This section states that an
axiom-definition defines a new semantics axiom but is unusually
vague as to what those semantics might be.
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">The use of the '==' and '!=' with
completely new semantics, unrelated to anything we have seen before
in C++ is both unwise and confusing, especially if the types
involved in the expressions happen to have operator== and
operator!= defined.
<p style="margin-bottom: 0in">We strongly suggest use
of different tokens, e.g. <font face="Consolas, monospace">&#61683;, and opposed to
this obscure usage/overload.</font>
<p style="margin-bottom: 0in">The description is very vague. How many
times is an implementation permitted to replace one expression by
another one when they have side effects?
<p><br>
<td>
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>DE-15
<td>
<p>14.9.1.4
<td>
<p><br>
<td>
<p>te
<td>
<p>DE-15 There is no
implementation experience for axioms. Use of axioms is an area of
active scientific research. It is likely that syntax changes will
become necessary to make good use of axioms; having the syntax
space already crowded is unhelpful. Axioms ought to be useful in
concepts applicable to floating-point types (such as
EqualityComparable), but IEEE floating-point types have special
values such as NaN violating the axioms.
<td>
<p>Remove section 14.9.1.4
and any reference to axioms in the rest of the proposed standard
other than the keyword reservation in section 2.11.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
123
<td>
<p align="justify">14.9.1.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">auto concepts and axioms are incompatible. An
axiom defines the semantics of an operaton or set of operations
that describes the run time behaviour. A concept describes purely
syntactic requirements at compile time. Where an auto concept will
match anything that meets the syntax requirements, there is no way
to know if the axioms will be met or not, and no way to opt out via
some kind of negative concept map.
<p align="left"><br>
<td>
<p align="left">Add a
paragraph making axioms ill-formed inside an auto concept.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK<br>
124
<p><br>
<td>
<p align="justify">14.9.1.4
<td>
<p align="justify">6
<td>
<p align="justify">Ed
<td>
<p align="left">Spelling
mistake, double-e in were.
<td>
<p align="left">weere -&gt;
were
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
125
<td>
<p align="justify">14.9.1.4
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The implicit equality comparison operator
available to axioms has no semantic. It is not clear what
expressing the condition if( a == b ) { conditional-axiom } would
mean if a and b are not truly EqualityComparable. We suspect the
intent of the 'implicit defefinition' is to support declaring the
equivalence of statements, a context where the operator will not
actually be evaluated.
<p align="left"><br>
<td>
<p align="left">Define the
semantics of the implicitly declared comparison operators, or
restrict their usage to declaring equivalence between
statements.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
126
<td>
<p align="justify">14.9.4
<td>
<p align="justify">41
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">This paragraph contains the only definition of the
underlying_type member - but it's a note, so not normative.
<p align="left"><br>
<td>
<p align="left">Move the
second sentence to the Requires clause in paragraph 42.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
127
<td>
<p align="justify">14.9.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Provide a diagram clearly showing refinement
relationship between the different support concepts. Several were
created during development of this clause and they were very
helpful.
<p align="left"><br>
<td>
<p align="left">Provide the
diagram.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
128
<td>
<p align="justify">14.9.4
<td>
<p align="justify">4
<td>
<p align="justify">Ed
<td>
<p align="left">It is
surprising for many people that non-copyable move-only types can be
used with a return statement, and so Returnable does not always
imply CopyConstructible.
<td>
<p align="left" style="margin-bottom: 0in">A non-normative note: [Note: 'move only' types
that are constructible from rvalue references may be Returnable,
but not CopyConstructible(20.1.8) - end note]
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>JP 20
<td>
<p lang="en-GB" align="left">14.9.4
<td>
<p lang="en-GB" align="left">2<sup>nd</sup><font size="2" style=
"font-size: 11pt"> paragraph</font>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-left: 0.2in; text-indent: -0.2in; margin-top: 0.04in; margin-bottom: 0.04in">
Trivially copyable type was
added in &#8220;3.9 Types&#8221;, so we think that it is necessary
to add concept to trivially copyable type like
&#8220;TriviallyCopyableType&#8221;.
<p lang="en-GB" align="left" style=
"margin-left: 0.2in; text-indent: -0.2in; margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add TriviallyCopyableType that is
trivially copyable type as concept.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
129
<td>
<p align="justify">14.10.1,
20.1.2
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It should be possible to support boolean constant
expressions as requirements without resorting to defining the True
concept in the library. Boolean expressions are very likely to be
constraints when deadline with non-type template parameters and
variadic templates, and constraints in these cases should feel just
as natural as constraints on the type system.
<p align="left"><br>
<td>
<p align="left">Remove the
True concept and library subclause 20.1.2. Provide support in
14.10.1 for boolean constant expressions as constraints. This may
involve overloading the true keyword to disambiguate but ideally
would not.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p align="left">US 60
<td>
<p align="left">14.10.1
<td>
<p align="left">1
<td>
<p align="left">te
<td>
<p align="left">The use of &amp;&amp; as the separator for a
list of requirements has shown itself to be a serious teachability
problem. The mental model behind &#8216;&amp;&amp;&#8217; treats
concepts as simple predicates, which ignores the role of concepts
in type-checking templates. The more programmers read into the
&#8216;&amp;&amp;&#8217; (and especially try to fake || with
&amp;&amp; and !), the harder it is for them to understand the role
of concept maps. Simply changing the separator to &#8216;,&#8217;
would eliminate a significant source of confusion.
<td>
<p align="left" style="margin-bottom: 0in">Replace
<p align="left" style="margin-bottom: 0in">requirement-list:
<p align="left" style="margin-bottom: 0in">requirement-list ...
[opt] &amp;&amp; requirement
<p align="left" style="margin-bottom: 0in">requirement ...
[opt]
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">with
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">requirement-list
<p align="left" style="margin-bottom: 0in">requirement-list ...[opt]
, requirement
<p align="left" style="margin-bottom: 0in">requirement ...
[opt]
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In 14.5.4p6, replace the
first sentence with:
<p align="left" style="margin-bottom: 0in">The instantiation of an
expansion produces a comma-separated list E1, E2, ..., EN, where N
is the number of elements in the pack expansion parameters.
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
130
<td>
<p align="justify">15.1
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">With the new crrent_exception API it is possible
to capture a reference to an exception that will outlive its last
active handler. That is in conflict with the sentance "When the
last remaining active handler for the exception exits by any means
other than throw; the temporary object is destroyed and the
implementation may deallocate the memory for the temporary
object;"
<p align="left"><br>
<td>
<p align="left">Update
sentence to allow for exceptions held in excpetion_ptr
objects.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
131
<td>
<p align="justify">15.3
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">A handler catching its parameter by
rvalue-reference is syntactically valid, but will never be
activated.
<p align="left"><br>
<td>
<p align="left">Disallow
handlers catching by rvalue-reference.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
132
<td>
<p align="justify">15.3
<td>
<p align="justify">16
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">There are obscure cases whrere a copy constructor
is not usually the best match to copy-initialize an object, e.g. A
converting constructor template taking arguments by non-const
reference. A footnote explaining such cases would be helpful, or
the sentance could be rewritten using copy-initialization instead
of directly calling a copy constructor.
<p align="left"><br>
<td>
<p align="left">Rewite using
copy-initialization rather than directly invoking the copy
constructor
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
133
<td>
<p align="justify">15.4
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Template aliases have the same semantics as a
typedef so should also be disallowed
<p align="left"><br>
<td>
<p align="left">add "or
alias-declaration" after "shall not appear in a typedef
declaration".
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
134
<td>
<p align="justify">15.4
<td>
<p align="justify">6
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The sentance "An exception-specification can also
include the class std::bad_exception (18.7.2.1)." is
redundant.
<p align="left"><br>
<td>
<p align="left">Either strike
the quoted sentance, or add a note explaining why it is worth
calling special attention to this class.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
135
<td>
<p align="justify">15.4
<td>
<p align="justify">8
<td>
<p align="justify">Te
<td>
<p align="left">Unclear if
std::unexpected is called before or after the function arguments
have been destroyed
<td>
<p align="left">Clarify the
sequence of calling unexpected with respect to interesting objects,
such as function arguments or partially constructed bases and
members when called from a constructor or destructor
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
136
<td>
<p align="justify">15.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Ge
<td>
<p align="left">Exception
specifications have proven close to worthless in practice, while
adding a measurable overhead to programs. The feature should be
deprecated. The one exception to the rule is the empty throw
specification which could serve a legitimate optimizing role if the
requirement to call the runtime unexpected mechanism was relaxed in
this case.
<td>
<p align="left">Move 15.4 and
the parts of 15.5 that refer to it to Appendix D. Replace 15.4 with
a simpler specification for empty throw specifications, where the
std::unexpected call is conditionally supported allowing vendors to
choose between optimizing and providing runtime checks. Ideally
require vendors to provide a mode where the runtime checks are
always disabled.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
137
<td>
<p align="justify">15.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">There is no mention of the current_exception API
which can extend the lifetime of an exception object. There should
at least be a forward reference to the library clause 18.7.5
<p align="left"><br>
<td>
<p align="left">Add another
paragraph outlining 18.7.5 and the ability of an exception_ptr to
extend the lifetime of an exception object
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
138
<td>
<p align="justify">15.5.1
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The third bullet is redundant with the first, as
it is a subset of the same conditions.
<p align="left"><br>
<td>
<p align="left">Merge the
third bullet into the first bullet as a note or example.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
139
<td>
<p align="justify">15.5.1
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">According to the first bullet it is perfectly
alright for a library function to exit by throwing an exception
during stack unwinding, This is clearly not true.
<p align="left"><br>
<td>
<p align="left">Strike the
word 'user' from the first bullet point.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
140
<td>
<p align="justify">15.5.2
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The detailed specification can fool people into
thinking an exception will automatically be translated into
bad_exception, where the default behaviour of std::unexcepted is to
immediately call std::terminate();
<p align="left"><br>
<td>
<p align="left">Add a note
highlighting the default behaviour of std::unexpected if the user
does not supply a hander-function
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
141
<td>
<p align="justify">15.6
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">This whole subclause is redundant due to 15.1p5
and 15.3p17
<p align="left"><br>
<td>
<p align="left">Strike
15.6
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
142
<td>
<p align="justify">16.3.5
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">This paragraph opens with "[ Note" but has no
corresponding "end note ]"
<p align="left"><br>
<td>
<p align="left">Add "end note
]"
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
143
<td>
<p align="justify">16.3.5
<td>
<p align="justify">7
<td>
<p align="justify">Ed
<td>
<p align="left">Example uses
#define t(x,y.z) x ## y ## z
<td>
<p align="left">Change
"x,y.z" to "x,y,z"
<td>
<p><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 2
<td>
<p lang="en-GB" align="left">17-30
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">ge/te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The active issues identified in WG21
N2806, C++ Standard Library Active Issues, must be addressed and
appropriate action taken.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
<font color="#000080"><u><a href=
"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html</a></u></font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">Appropriate action would include making changes to
the CD, identifying an issue as not requiring a change to the CD,
or deferring the issue to a later point in time.
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 2
<td>
<p>General Comment
<td>
<p>Library
<td>
<p>ge
<td>
<p>The adoption of the library `constexpr'
proposal was not reflected in the draft, despite formal WG21
committee vote.
<td>
<p>FR 2
<td>
<p>General Comment
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 61
<td>
<p lang="en-GB" align="left">17 onward
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p>The concepts core language
feature is applied to only some of the Standard Library clauses,
and even then not always consistently.
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Review all clauses of the
Standard Library, and consistently apply concept technology
wherever possible and appropriate. The proposed wording in WG21
N2781 exemplifies the necessary level of detail.
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>CA-2
<td>
<p style="margin-top: 0.04in">17 Library
<td>
<p><br>
<td>
<p>Ge
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">
&#8220;Concepts&#8221; are a
significant new addition to the language, but are not exploited
uniformly in the library as documented in CD 14882.
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Fix the standard library so that
&#8220;Concepts&#8221; are used appropriately in the
library.
<td>
<p><br>
<tr valign="top">
<td>
<p align="left">US 62
<td>
<p align="left">17-30
<td>
<p align="left"><br>
<td>
<p align="left">ge
<td>
<p align="left" style="margin-bottom: 0in">Provide concepts and
requirements clauses for all standard library templates
<p align="left"><br>
<td>
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>US 63
<td>
<p style="margin-top: 0.04in; margin-bottom: 0.04in">17-30
<p><br>
<td>
<p><br>
<td>
<p>te
<td>
<p>The behavior of the
library in the presence of threads is incompletely
specified.
<p>For example, if thread 1
assigns to X, then writes data to file f, which is read by thread
2, and then accesses variable X, is thread 2 guaranteed to be able
to see the value assigned to X by thread 1? In other words, does
the write of the data "happen before" the read?
<p>Another example: does
simultaneous access using operator at() to different characters in
the same non-const string really introduce a data race?
<td>
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-2
<td>
<p>17 through 30
<td>
<p><br>
<td>
<p>te
<td>
<p>DE-2 Marking a constructor
with "explicit" has semantics even for a constructor with zero or
several parameters: Such a constructor cannot be used with
list-initialization in a copy-initialization context, see 13.3.1.7.
The standard library apparently has not been reviewed for marking
non-single-parameter constructors as "explicit".
<td>
<p>Consider marking
zero-parameter and multi-parameter constructors "explicit" in
classes that have at least one constructor marked "explicit" and
that do not have an initializer-list constructor.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 21
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">17 Library
<p lang="en-GB" align="left" style="margin-bottom: 0in">21.2, 21.4,
<p lang="en-GB" align="left">27.2, 27.6, 27.7, 27.8.1, 28.4
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Support of char16_t/char32_t is
insufficient. The basic_xxx classes of &lt;iostream&gt;,
&lt;fstream&gt;, &lt;regex&gt;, etc. does not have typedefs for
char16_t/char32_t.
<p lang="en-GB" align="left" style="margin-top: 0.04in">Functions such as stoi, to_string in
&#8216;21.4 Numeric Conversion&#8217; does not support
char16_t/char32_t types.
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">Add commented lines corresponding to char16_t,
char32_t.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">21.2 paragraph1
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;...
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;// 21.4: numeric
conversions
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;...
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;int stoi(const
u16string&amp; str, size_t *idx = 0, int base = 10);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;long stol(const
u16string&amp; str, size_t *idx = 0, int base = 10);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;unsigned long
stoul(const u16string&amp; str, size_t *idx = 0, int base =
10);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;long long stoll(const
u16string&amp; str, size_t *idx = 0, int base = 10);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;unsigned long long
stoull(const u16string&amp; str, size_t *idx = 0, int base =
10);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;float stof(const
u16string&amp; str, size_t *idx = 0);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;double stod(const
u16string&amp; str, size_t *idx = 0);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;long double stold(const
u16string&amp; str, size_t *idx = 0);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;u16string
to_u16string(long long val);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;u16string
to_u16string(unsigned long long val);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;u16string
to_u16string(long double val);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp; int stoi(const u32string&amp;
str, size_t *idx = 0, int base = 10);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;long stol(const
u32string&amp; str, size_t *idx = 0, int base = 10);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;unsigned long
stoul(const u32string&amp; str, size_t *idx = 0, int base =
10);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;long long stoll(const
u32string&amp; str, size_t *idx = 0, int base = 10);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;unsigned long long
stoull(const u32string&amp; str, size_t *idx = 0, int base =
10);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;float stof(const
u32string&amp; str, size_t *idx = 0);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;double stod(const
u32string&amp; str, size_t *idx = 0);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;long double stold(const
u32string&amp; str, size_t *idx = 0);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;u32string
to_u32string(long long val);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;u32string
to_u32string(unsigned long long val);
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;u32string
to_u32string(long double val);
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">27.2
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;...
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ios&lt;char&gt; ios;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ios&lt;wchar_t&gt; wios;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ios&lt;char16_t&gt; u16ios;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ios&lt;char32_t&gt; u32ios;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;...
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ifstream&lt;wchar_t&gt; wifstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ofstream&lt;wchar_t&gt; wofstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_fstream&lt;wchar_t&gt; wfstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_streambuf&lt;char16_t&gt; u16streambuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_istream&lt;char16_t&gt; u16istream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ostream&lt;char16_t&gt; u16ostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_iostream&lt;char16_t&gt; u16iostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringbuf&lt;char16_t&gt; u16stringbuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_istringstream&lt;char16_t&gt; u16istringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ostringstream&lt;char16_t&gt; u16ostringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringstream&lt;char16_t&gt; u16stringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_filebuf&lt;char16_t&gt; u16filebuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ifstream&lt;char16_t&gt; u16ifstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ofstream&lt;char16_t&gt; u16ofstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_fstream&lt;char16_t&gt; u16fstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_streambuf&lt;char32_t&gt; u32streambuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_istream&lt;char32_t&gt; u32istream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ostream&lt;char32_t&gt; u32ostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_iostream&lt;char32_t&gt; u32iostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringbuf&lt;char32_t&gt; u32stringbuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_istringstream&lt;char32_t&gt; u32istringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ostringstream&lt;char32_t&gt; u32ostringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringstream&lt;char32_t&gt; u32stringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_filebuf&lt;char32_t&gt; u32filebuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ifstream&lt;char32_t&gt; u32ifstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ofstream&lt;char32_t&gt; u32ofstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
<u>&nbsp;typedef basic_fstream&lt;char32_t&gt;
u32fstream;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;...
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
state&gt; class fpos;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
fpos&lt;char_traits&lt;char&gt;::state_type&gt; streampos;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
fpos&lt;char_traits&lt;wchar_t&gt;::state_type&gt;
wstreampos;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
fpos&lt;char_traits&lt;char16_t&gt;::state_type&gt;
u16streampos;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
fpos&lt;char_traits&lt;char32_t&gt;::state_type&gt;
u32streampos;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">27.6
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_istream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_istream&lt;char&gt; istream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_istream&lt;wchar_t&gt; wistream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;<u>typedef
basic_istream&lt;char16_t&gt; u16istream;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_istream&lt;char32_t&gt; u32istream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_iostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_iostream&lt;char&gt; iostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_iostream&lt;wchar_t&gt; wiostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;<u>typedef
basic_iostream&lt;char16_t&gt; u16iostream;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_iostream&lt;char32_t&gt; u32iostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_ostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ostream&lt;char&gt; ostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ostream&lt;wchar_t&gt; wostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;<u>typedef
basic_ostream&lt;char16_t&gt; u16ostream;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ostream&lt;char32_t&gt; u32ostream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">27.7 paragraph 1
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp;&nbsp; class Allocator = allocator&lt;charT&gt;
&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_stringbuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringbuf&lt;char&gt; stringbuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringbuf&lt;wchar_t&gt; wstringbuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;<u>typedef
basic_stringbuf&lt;char16_t&gt; u16stringbuf;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringbuf&lt;char32_t&gt; u32stringbuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp;&nbsp; class Allocator = allocator&lt;charT&gt;
&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_istringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_istringstream&lt;char&gt; istringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_istringstream&lt;wchar_t&gt; wistringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;<u>typedef
basic_istringstream&lt;char16_t&gt; u16istringstream;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_istringstream&lt;char32_t&gt; u32istringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp;&nbsp; class Allocator = allocator&lt;charT&gt;
&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_ostringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ostringstream&lt;char&gt; ostringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ostringstream&lt;wchar_t&gt; wostringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;<u>typedef
basic_ostringstream&lt;char16_t&gt; u16ostringstream;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ostringstream&lt;char32_t&gt; u32ostringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;&nbsp;&nbsp;&nbsp; class Allocator = allocator&lt;charT&gt;
&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_stringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringstream&lt;char&gt; stringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringstream&lt;wchar_t&gt; wstringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringstream&lt;char16_t&gt; u16stringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_stringstream&lt;char32_t&gt; u32stringstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">27.8.1 paragraph 1
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_filebuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_filebuf&lt;char&gt; filebuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_filebuf&lt;wchar_t&gt; wfilebuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;<u>typedef
basic_filebuf&lt;char16_t&gt; u16filebuf;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_filebuf&lt;char32_t&gt; u32filebuf;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_ifstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ifstream&lt;char&gt; ifstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ifstream&lt;wchar_t&gt; wifstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;<u>typedef
basic_ifstream&lt;char16_t&gt; u16ifstream;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ifstream&lt;char32_t&gt; u32ifstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_ofstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ofstream&lt;char&gt; ofstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ofstream&lt;wchar_t&gt; wofstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;<u>typedef
basic_ofstream&lt;char16_t&gt; u16ofstream;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_ofstream&lt;char32_t&gt; u32ofstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;template &lt;class
charT, class traits = char_traits&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;class
basic_fstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_fstream&lt;char&gt; fstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_fstream&lt;wchar_t&gt; wfstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;<u>typedef
basic_fstream&lt;char16_t&gt; u16fstream;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_fstream&lt;char32_t&gt; u32fstream;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">28.4
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;...
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_regex&lt;char&gt; regex;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_regex&lt;wchar_t&gt; wregex;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_regex&lt;char16_t&gt; u16regex;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
basic_regex&lt;char32_t&gt; u32regex;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;...
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
sub_match&lt;const char*&gt; csub_match;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
sub_match&lt;const wchar_t*&gt; wcsub_match;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
sub_match&lt;const char16_t*&gt; u16csub_match;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
sub_match&lt;const char32_t*&gt; u16csub_match;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
sub_match&lt;string::const_iterator&gt; ssub_match;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
sub_match&lt;wstring::const_iterator&gt; wssub_match;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
sub_match&lt;u16string::const_iterator&gt; u16ssub_match;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
sub_match&lt;u32string::const_iterator&gt; u32ssub_match;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;...
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
match_results&lt;const char*&gt; cmatch;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
match_results&lt;const wchar_t*&gt; wcmatch;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
match_results&lt;const char16_t*&gt; u16cmatch;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
match_results&lt;const char32_t*&gt; u32cmatch;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
match_results&lt;string::const_iterator&gt; smatch;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
match_results&lt;wstring::const_iterator&gt; wsmatch;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
match_results&lt;u16string::const_iterator&gt; u16smatch;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
match_results&lt;u32string::const_iterator&gt; u32smatch;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;...
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_iterator&lt;const char*&gt; cregex_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_iterator&lt;const wchar_t*&gt; wcregex_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_iterator&lt;const cha16r_t*&gt; u16cregex_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_iterator&lt;const char32_t*&gt; u32cregex_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_iterator&lt;string::const_iterator&gt;
sregex_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_iterator&lt;wstring::const_iterator&gt;
wsregex_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_iterator&lt;u16string::const_iterator&gt;
u16sregex_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_iterator&lt;u32string::const_iterator&gt;
u32sregex_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;...
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_token_iterator&lt;const char*&gt;
cregex_token_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_token_iterator&lt;const wchar_t*&gt;
wcregex_token_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_token_iterator&lt;const char16_t*&gt;
u16cregex_token_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_token_iterator&lt;const char32_t*&gt;
u32cregex_token_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_token_iterator&lt;string::const_iterator&gt;
sregex_token_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_token_iterator&lt;wstring::const_iterator&gt;<span lang=
"zxx">&#12288;&#12288;&#12288;</span>wsregex_token_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_token_iterator&lt;u16string::const_iterator&gt;
u16sregex_token_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">
&nbsp;typedef
regex_token_iterator&lt;u32string::const_iterator&gt;<span lang=
"zxx">&#12288;</span>u32sregex_token_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
144
<td>
<p align="justify">17.1
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left">List of
contents of library should be extened to cover new clauses
<td>
<p align="left">Add "regular
expressions, atomic operations and threads"
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
145
<td>
<p align="justify">17.1
<td>
<p align="justify">6
<td>
<p align="justify">Ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in"><span lang="en-US">Summary of numeric
facilities should mention random numbers</span>
<p align="left"><br>
<td>
<p align="left">Add random
number framework to the list of library facilities
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
146
<td>
<p align="justify">17.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">Add a summary
paragraph for regular expressions
<td>
<p align="left">Add a summary
paragraph for regular expressions
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
147
<td>
<p align="justify">17.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">Add a summary
paragraph for threads
<td>
<p align="left">Add a summary
paragraph for threads
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
148
<td>
<p align="justify">17.2
<td>
<p align="justify">Table
12
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Table 12 is mentioned in and relates to section
17.2, but has been pushed down to appear directly after the title
of section 17.3 which is rather unfortunate/confusing for the
reader.
<p align="left"><br>
<td>
<p align="left">Make sure
tables are rendered in the section to which they relate.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
149
<td>
<p align="justify">17.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">For consistency with narrow-oriented and
wide-oriented streams, we should add terms for streams of Unicode
character sequences
<p align="left"><br>
<td>
<p align="left">Define
Utf16-oriented stream classes and Uft32-oriented stream classes for
streams of char16_t/char32_t values.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
150
<td>
<p align="justify">17.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">The addition
of move semantics to the language means that many library APIs
leave an object in a safely-destructible state, where no other
operations can safely be performed unless it is assigned a new
value. Library presentation would be simplified and made more
precise if we introduce a term for this state. By analogy with
singular iterators suggest the term 'singular object' or 'the
object is in a singular state'.
<td>
<p align="left" style="margin-bottom: 0in">Define 'singular state' such that an object with a
singular state can only be assigned to or safely destroyed.
Assiging a new value typically removes the singular state. Note
that objects with a singular state may not be safely copied, so you
cannot put an object into a singular state by copying another
object in a singular state. Use this new term in the postcondition
of all library APIs that move from an rvalue reference. It might
also be used to simplify the definition of singular iterator to an
iterator value with a singular state.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
151
<td>
<p align="justify">17.3.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Missing crossreference to 17.3.17
[defns.repositional.stream]
<p align="left"><br>
<td>
<p align="left">Add
cross-reference in the existing empty brackets
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
152
<td>
<p align="justify">17.3.12
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Object state is using a definition of object
(instance of a class) from outside the standard, rather than the
'region of storage' definiton in 1.8p1
<p align="left"><br>
<td>
<p align="left">Clarify terms
and usage
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
153
<td>
<p align="justify">17.3.17
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">If a repositional stream can only seek to a
position previously encountered, then an
arbitrary-positional-stream cannot satisfy this definition, as
cross-referenced in 17.3.17
<p align="left"><br>
<td>
<p align="left">Strike the
word 'only'. A note might be added to reinforce the intent
<td>
<p><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK<br>
154
<p><br>
<td>
<p align="justify">17.3.20
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">Missing
definition of a stable partition algorithm
<td>
<p align="left">Add
definition from 25.2.12p7
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
155
<td>
<p align="justify">17.3.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">Add clause 28
to list that use this definition of character
<td>
<p align="left">Add clause 28
to list that use this definition of character
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
156
<td>
<p align="justify">17.3.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Add regular expressions to set of templates using
character container type
<p align="left"><br>
<td>
<p align="left">Add regular
expressions to set of templates using character container
type
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
157
<td>
<p align="justify">17.5.2.2
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Add concepts to the ordered list of
presentation
<p align="left" style="margin-bottom: 0in"><br>
<p align="left"><br>
<td>
<p align="left">Add concepts
into the sequence
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
158
<td>
<p align="justify">17.5.2.2
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left">templates are
neither classes nor functions
<td>
<p align="left" style="margin-bottom: 0in">Replace 'classes' and 'functions' with 'classes
and class templates' and 'functions and function templates'
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
159
<td>
<p align="justify">17.5.2.4
<td>
<p align="justify">Footnote
152
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">This informative footnote was relevant in 1998,
not 2008. The term 'existing vendors' may imply something different
now
<p align="left"><br>
<td>
<p align="left">Strike the
footnote, or replace 'existing' with 'original' or similar
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
160
<td>
<p align="justify">17.5.2.4
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">requires is now a keyword with a specific meaning
related to concepts, and its use in library specifcation may be
confusing. Generally the Requires clause is used to make
requirements on the caller, not the library, so typically providing
runtime pre-conditions. Suggest a new name to refflect that. Note
that Clause 30 already seems to be written to this
convention.
<p align="left"><br>
<td>
<p align="left">Replace
'Requires' with 'Preconditions'
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
161
<td>
<p align="justify">17.5.2.4
<td>
<p align="justify">4
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">This paragraph is redundant as the definition of
the term 'handler function' is already provided in 17.3. Are we in
danger of proving two definitions of the same terms? Which is the
'controlling' definition?
<p align="left"><br>
<td>
<p align="left">Strike
17.5.2.4p4
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
162
<td>
<p align="justify">17.5.2.4
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Clause 30 makes use of a 'Synchronization'
semantic element, that frequently appears either between Effects:
and Postconditions:, or between Returns: and Throws:
<p align="left"><br>
<td>
<p align="left">Add
'Synchronization' to the list either between Effects: and
Postconditions:, or between Returns: and Throws:.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
163
<td>
<p align="justify">17.5.2.4
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Many functions are defined as "Effects: Equivalent
to a...", which seems to also define the preconditions, effects,
etc. But this is not made clear.
<p align="left"><br>
<td>
<p align="left">Introduce an
explicit "Equivalent to", which defines all of the properties of
the function.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
164
<td>
<p align="justify">17.5.3.2.1
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left">This phrasing
predates concepts. While this kind of description is still used,
the examples provided are now all concepts, and should be replaced
with appropriate examples
<td>
<p align="left" style="margin-bottom: 0in">Use better names for the examples. Ideally totally
replace the need by constraining all templates in library, so that
real concepts are all that is needed. Note if retained that
CopyConstructible is mis-spelled.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
165
<td>
<p align="justify">17.5.3.2.2, 17.5.3.2.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">constraints on bitmask and enumation types were
supposed to be tightened up as part of the motivation for the
constexpr feature - see paper n2235 for deails
<p align="left"><br>
<td>
<p align="left">Adopt wording
in line with the motivation described in N2235
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
166
<td>
<p align="justify" style="margin-bottom: 0in">17.5.3.2.4.1, 17.5.3.3
<p align="justify"><br>
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">List of
library clauses should go up to 30, not 27
<td>
<p align="left">Replace
initial refernce to ch27 with ch30
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
167
<td>
<p align="justify">17.5.3.4
Private members
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">Comment
marker in wrong place.
<td>
<p align="left" style="margin-bottom: 0in">Change: // streambuf* sb; exposition only to
streambuf* sb; // exposition only To reflect actual usage.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
168
<td>
<p align="justify">17.6.2.2
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">We should make it clear (either by note or
normatively) that namespace std may contain inline namespaces, and
that entities specified to be defined in std may in fact be defined
in one of these inline namespaces. (If we're going to use them for
versioning, eg when TR2 comes along, we're going to need
that.)
<p align="left"><br>
<td>
<p align="left">Replace
"namespace std or namespaces nested within namespace std" with
"namespace std or namespaces nested within namespace std or inline
namespaces nested directly or indirectly within namespace
std"
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
169
<td>
<p align="justify">17.6.2.2
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">This phrasing contradicts later freedom to
implement the C standard library portions in the global namespace
as well as std. (17.6.2.3p4)
<p align="left"><br>
<td>
<p align="left">Resolve
conflict in either place
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
170
<td>
<p align="justify">17.6.2.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">One of goals of C++0x is to make language easier
to teach and for 'incidental' programmers. The fine-grained headers
of the C++ library are valuable in large scale systems for managing
dependencies and optimising build times, but overcomplicated for
simple development and tutorials. Add additional headers to support
the whole library through a single include statement.
<p align="left"><br>
<td>
<p align="left">Add a new
header &lt;std&gt; that has the effect of including everything in
tables 13 and 14, except &lt;iosfwd&gt; and &lt;cassert&gt;. Add an
additional header &lt;fwd&gt; that adds all declarations from
&lt;std&gt; but no definitions.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
171
<td>
<p align="justify">17.6.2.4
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Does freestanding implementation require a full
implementation of all listed headers? The reference to abort,
at_exit and exit is confusing. Is a conforming implementation allow
to deliver partial forms of these headers? If so which ones? Are
empty versions of everything but &lt;cstdlib&gt; conforming?
<p align="left"><br>
<td>
<p align="left">Either strike
the references to abort, at_exit and exit, or clarify which headers
only require partial support.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
172
<td>
<p align="justify">17.6.2.4
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">No reference to new functions quick_exit and
at_quick_exit
<p align="left"><br>
<td>
<p align="left">Add reference
to quick_exit and at_quick_exit
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
173
<td>
<p align="justify">17.6.2.4
<td>
<p align="justify">table
15
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">&lt;initializer_list&gt; is missing from headers
required in freestanding implementations.
<p align="left"><br>
<td>
<p align="left">Add 18.8,
initializer lists, &lt;initializer_list&gt;, to the end of the
table.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 23
<td>
<p lang="en-GB" align="left">17.6.2.4
<td>
<p lang="en-GB" align="left">2<sup>nd</sup><font size="2" style=
"font-size: 11pt"> paragraph, Table 15</font>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">There is a freestanding implementation including
&lt;type_traits&gt;, &lt;array&gt;, &lt;ratio&gt;, lately added to
Table 13, C++ library headers.<br>
Programmers think them useful and hope that these headers are also
added to Table 15, C++ headers for freestanding implementations,
that shows the set of headers which a freestanding implementation
shall include at least.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add &lt;type_traits&gt;, &lt;array&gt;,
&lt;ration&gt; to Table 15.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
174
<td>
<p align="justify">17.6.3.2
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The phrasing is mildly ambiguous when using the
word 'it' to refer back to the header - an unfotunate reading might
confuse it with the translate unit, which is the subject of the
surrounding clause.
<p align="left"><br>
<td>
<p align="left">Replace 'the
first reference to any of the entities declared in that header by
the translation unit' with 'the first reference to any of the
entities that header declares in the translation unit'
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
175
<td>
<p align="justify">17.6.4.2.1
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Local types can now be used to instantiate
templates, but don't have external linkage
<p align="left"><br>
<td>
<p align="left">Remove the
reference to external linkage
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
176
<td>
<p align="justify">17.6.4.3.3
<td>
<p align="justify" style="margin-bottom: 0in">Footnote 175
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">Reference to
namespace ::std should be 17.6.4.2
<td>
<p align="left">Change
referfence from 17.6.4.3 to 17.6.4.2
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
177
<td>
<p align="justify">17.6.4.3.4
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Sentence is redundant as double underscores are
reserved in all contexts by 17.6.4.3.3
<p align="left"><br>
<td>
<p align="left">Strike the
sentence
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
178
<td>
<p align="justify">17.6.4.8
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left">The last
sentence of the third bullet "Operations on such types can report a
failure by throwing an exception unless otherwise specified" is
redundant as behaviour is already undefined.
<td>
<p align="left">Strike the
sentence
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
179
<td>
<p align="justify">17.6.4.8
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">According to the 4th bullet there is a problem if
"if any replacement function or handler function or destructor
operation throws an exception". There should be no problem throwing
exceptions so long as they are caught within the function.
<p align="left"><br>
<td>
<p align="left">Replace the
word 'throws' with 'propogates'
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 22
<td>
<p lang="en-GB" align="left">17.6.5.7
<td>
<p lang="en-GB" align="left">4<sup>th</sup><font size="2" style=
"font-size: 11pt"> paragraph, 1<sup>st</sup> line</font>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The statement below describes relation
among two or more threads using words &#8220;between
threads&#8221;:<br>
[Note: This means, for example, that implementations can&#8217;t
use a static object for internal purposes without synchronization
because it could cause a data race even in programs that do not
explicitly share objects between threads. &#8212;end note ]
<p lang="en-GB" align="left" style="margin-top: 0.04in">In such case, &#8220;among&#8221; is
preferred instead of &#8220;between&#8221;.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Change "between threads" to "among
threads".
<p lang="en-GB" align="left" style="margin-top: 0.04in">There are same cases in 17.6.1 paragraph
2, 17.6.5.7 paragraph 6, 30.1 paragraph 1, 30.3.1 paragraph 1
also.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
180
<td>
<p align="justify">17.6.5.10
<td>
<p align="justify">1,
4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It should not be possible to strengthen the
exception specification for virtual functions as this could break
user code. Note this is not a problem in practice as there are no
virtual functions with exception specifications in the current
library, other than empty throw specifications which it is not
possible to strengthen.
<p align="left"><br>
<td>
<p align="left">Add
restriction that exception specification of virtual functions
cannot be tightened.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
181
<td>
<p align="justify">17.6.5.10
<td>
<p align="justify">Footnote
186
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">This footnote is wrong. C library functions do not
have any exception specification, but might be treated as if they
had an empty throw specification
<p align="left"><br>
<td>
<p align="left">Clarify that
this note does not mean the functions are genuinely declared with
the specification, but are treated as-if.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
182
<td>
<p align="justify">17.6.5.10
<td>
<p align="justify">Footnote
188
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It is very helpful to assume all exceptions thrown
by the standard library derive from std::exception. The
'encouragement' of this note should be made normative.
<p align="left"><br>
<td>
<p align="left">Make this
footnote normative
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
184
<td>
<p align="justify">18 -&gt;
30
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The new alias-declaration syntax is generally
easier to read than a typedef declaration. This is especially true
for complex types like function pointers.
<p align="left"><br>
<td>
<p align="left">Replace all
typedef declarations in the standard library with
alias-declarations, except in the standard C library.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 24
<td>
<p lang="en-GB" align="left">18
<td>
<p lang="en-GB" align="left">2<sup>nd</sup><font size="2" style=
"font-size: 11pt"> paragraph, Table 16</font>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Subclauses are listed in Table 16
as:
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-bottom: 0in">"18.6 Type identification &#8230;"
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-bottom: 0in">"18.8 Initializer lists &#8230;"
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-top: 0.04in">"18.7 Exception handling &#8230;".
<td>
<p lang="en-GB" align="left" style=
"margin-left: 0.06in; text-indent: -0.06in; margin-bottom: 0in">
Sort them in the increasing
order<br>
"18.6 Type identification &#8230;"
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-bottom: 0in">"18.7 Exception handling &#8230;".
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-top: 0.04in; margin-bottom: 0.04in">
"18.8 Initializer lists
&#8230;"
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 25
<td>
<p lang="en-GB" align="left">18.1
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">6<sup>th</sup><font size=
"2" style="font-size: 11pt"> paragraph , last line, SEE ALSO</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">max_align_t is described in 18.1, so add
3.11 Alignment as the reference.
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add "<u>3.11, Alignment</u><font color="#000000">" to</font><font size=
"2" style="font-size: 11pt"> SEE ALSO.</font>
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 32
<td>
<p>18.2.1 [Numeric limits]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">The definition of numeric_limits&lt;&gt;
as requiring a regular type is both conceptually wrong and
operationally illogical. As we pointed before, this mistake needs
to be corrected. For example, the template can be left
unconstrained. In fact this reflects a much more general problem
with concept_maps/axioms and their interpretations. It appears that
the current text heavily leans toward experimental academic type
theory.
<p><br>
<td>
<p>We suggest that a more pragmatic approach, in
the spirit of C and C++, be taken so that calls to constrained
function templates are interpreted as assertions on *values*, not
necessarily semantics assertions on the carrier type.
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-16
<td>
<p>18.2.1
<td>
<p><br>
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
DE-16 The class template numeric_limits should not
specify the Regular concept
requirement for its template parameter, because it contains
functions returning NaN values for floating-point types; these
values violate the semantics of EqualityComparable. See also library
issue 902 in WG21 document N2794 "C++ Standard Library Active
Issues List (Revision R60)", available at
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2794.html
.
<p><br>
<td>
<p>Specify a concept
requirement with fewer constraints as appropriate, for example SemiRegular.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 26
<td>
<p lang="en-GB" align="left">18.2.1.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">numeric_limits does not use
concept.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class T&gt; class
numeric_limits&lt;const T&gt;;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class T&gt; class
numeric_limits&lt;volatile T&gt;;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class T&gt; class
numeric_limits&lt;const volatile T&gt;;
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;<u>Regular</u> T&gt; class
numeric_limits&lt;const T&gt;;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;<u>Regular</u> T&gt; class
numeric_limits&lt;volatile T&gt;;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;<u>Regular</u> T&gt; class
numeric_limits&lt;const volatile T&gt;;
<p lang="en-GB" align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-17
<td>
<p>18.2.6
<td>
<p><br>
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
DE-17 The class type_index should be removed; it
provides no additional functionality beyond providing appropriate
concept maps.
<p><br>
<td>
<p>Specify concept maps for
"const type_info *" as required by the ordered and unordered
containers and remove the class type_index.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
185
<td>
<p align="justify">18.3.1
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">There is no header &lt;stdint&gt;, it should
either be &lt;stdint.h&gt; or &lt;cstdint&gt;
<p align="left"><br>
<td>
<p align="left">Replace
&lt;stdint&gt; with &lt;cstdint&gt;
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-18
<td>
<p>18.4
<td>
<p><br>
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
DE-18 The proposed C++
standard makes a considerable number of existing programs that have
well-defined behavior according to ISO/IEC 14882:2003 have
undefined behavior without a diagnostic hint to the programmer at
all. This applies to the presence of threads and to pointer safety
(the latter was introduced to support garbage collection). In order
to avoid requiring a full code review for user code, facilities
should be present that allow the compile-time detection of the
advanced features of the proposed C++ standard. It is expected that
C++ implementations will provide a means (for example, a
command-line switch) to turn off either or both of threads and
garbage collection support, turning potentially undefined programs
into well-defined ones.<br>
<i>Note:</i> This issue is contributing significantly to Germany's
overall &#8220;no&#8221; vote.
<p><br>
<td>
<p>Consider applying the
changes proposed in WG21 document N2693 "Requirements on programs
and backwards compatibility", available at
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2693.html
.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
186
<td>
<p align="justify">18.4
<td>
<p align="justify">Footnote
221
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">What is the purpose of this comment? The standard
stream objects (cin, cerr etc.) have a peculiar lifetime that
extends beyond the program. They may never be destroyed so will not
be responsible for flushing buffers at the stated time.
<p align="left"><br>
<td>
<p align="left">Remove the
footnote
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
187
<td>
<p align="justify">18.4
<td>
<p align="justify">9
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The term "thread safe" is not defined nor used in
this context anywhere else in the standard.
<p align="left"><br>
<td>
<p align="left">Clarify the
intended meaing of "thread safe"
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
188
<td>
<p align="justify">18.4
<td>
<p align="justify">12
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The function _Exit does not appear to be defined
in this standard. Should it be added to the table of functions
included-by-reference to the C standard?
<p align="left"><br>
<td>
<p align="left">Depends on
where _Exit comes from
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
189
<td>
<p align="justify">18.4,
18.7
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">The addition
of the [[noreturn]] attribute to the language will be an important
aid for static analysis tools.
<td>
<p align="left" style="margin-bottom: 0in">The following functions should be declared in C++
with the [[noreturn]] attribute: abort exit quick_exit terminate
unexpected rethrow_exception throw_with_nested
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 27
<td>
<p lang="en-GB" align="left">18.4, 18.9, 18.7.2.2, 18.7.3.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">There are Standard library functions
that never return to the caller. They are explained so in the
Standard but not declared explicitly.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Consider to add the attribute
[[noreturn]] to such functions,
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">15.5.2 unexpected<br>
18.4: abort(), exit(), quick_exit,<br>
18.7.2.2: unexpected_handler,<br>
18.7.3.1: terminate_handler,
<p lang="en-GB" align="left" style="margin-bottom: 0in">18.7.6 rethrow_nested
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">18.7.6 throw_with_nested<br>
18.9: longjmp.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
190
<td>
<p align="justify">18.5.1
<td>
<p align="justify">various
<td>
<p align="justify">Te
<td>
<p align="left">It is not
entirely clear how the current specification acts in the presence
of a garbage collected implementation.
<td>
<p align="left" style="margin-bottom: 0in">All deallocation functions taking a pointer
parameter should have a Precondition : ptr is a safely-derived
pointer value.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
191
<td>
<p align="justify">18.5.1.1
<td>
<p align="justify">4
<td>
<p align="justify">Ed
<td>
<p align="left">According to
the second bullet, behaviour becomes undefined (for lack of a
specification) if the user has not yet called
set_new_handler.
<td>
<p align="left" style="margin-bottom: 0in">Rephrase the second bullet in terms of a new
handler being installed, and update any definition of handler
function necessary to be sure the term 'installed' is
defined.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
192
<td>
<p align="justify">18.5.1.2
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The declared signature is not compatible with the
current requirement to throw std::length_error. It is too late to
weaken the exception specification, so the only other change is to
preserve new (improved) behaviour is to throw std::bad_alloc, or
something derived from std::bad_alloc.
<p align="left"><br>
<td>
<p align="left">Fix 5.3.4p7
by required std::bad_alloc rather than std::length_error
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
193
<td>
<p align="justify">18.5.2.2
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">quick_exit has been added as a new valid way to
terminate a program in a well defined way
<p align="left"><br>
<td>
<p align="left">Change 3rd
bullet: call either abort(), exit() or quick_exit();
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
194
<td>
<p align="justify">18.6
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The inclusion of type_index and
hash&lt;type_index&gt; in &lt;typeinfo&gt; brings dependencies into
&lt;typeinfo&gt; which are inconsistent with the definition of
freestanding C++ in 17.6.2.4.
<p align="left"><br>
<td>
<p align="left">Move
type_index and hash&lt;type_index&gt; out of &lt;typeinfo&gt; and
into a new header, &lt;typeindex&gt;.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 28
<td>
<p lang="en-GB" align="left">18.6, 18.7, 19.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Errors reported by Exception classes are
of types char or std::string only. For example, std::exception is
declared with char, std::string types, therefore types
wchar_t/wstring, char16_t/u16string, or char32_t/u32string can not
be used.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Consider other types.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 29
<td>
<p lang="en-GB" align="left">18.7.6
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">throw_with_nested does not use
concept.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class T&gt; void
throw_with_nested(T&amp;&amp; t); // [[noreturn]]
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;CopyConstructible T&gt; void
throw_with_nested(T&amp;&amp; t); // [[noreturn]]
<p lang="en-GB" align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 30
<td>
<p lang="en-GB" align="left">18.7.6
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">To handle nested exceptions strictly,
error information of tree structure will be required though, the
nested_exception does not support tree structure. It is
insufficient as error handling.
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Consider nested_exception to support
tree structure.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 31
<td>
<p lang="en-GB" align="left">18.7.6
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">It is difficult to understand in which
case nested_exception is applied.
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">Consider to add a sample program which rethrows
exception.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
195
<td>
<p align="justify">18.8
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The class definition of std::initializer_list
contains concept-maps to Range which should be out of the class,
and in &lt;iterator_concepts&gt; instead. Otherwise, it's not
possible to use initializer_lists in a freestanding C++
implementation.
<p align="left"><br>
<td>
<p align="left">Delete the
two concept maps from std::initializer_list.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
196
<td>
<p align="justify">18.8.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">Concept maps
for initializer_list to Range should not be in language support
headers, but instead in iterator concepts.
<td>
<p align="left" style="margin-bottom: 0in">Remove section 18.8.3 and put it in 24.1.8.1
instead, so that the concept_maps from initializer_list to Range
are specified under Range instead of under initializer lists; also,
so that they're implemented in &lt;iterator_concepts&gt; instead of
&lt;initializer_list&gt;.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
197
<td>
<p align="justify">19
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">All the
exception classes in this clause take a std::string argument by
const reference. They should all be overloaded to accept
std::string by rvalue rerefence for an efficient move as
well.
<td>
<p align="left" style="margin-bottom: 0in">Provide a constructor for every exception class in
clause 19 accepting a std::string by rvalue reference, with the
semantics that the passed string may be moved.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 32
<td>
<p lang="en-GB" align="left">19.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Messages returned by the member function
what() of standard exception classes seem difficult to
judge.
<p lang="en-GB" align="left" style="margin-bottom: 0in">For example, following messages are
returned by what() of std::bad_alloc of existing
implementations:
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Compiler: Message returned by
what()
<p lang="en-GB" align="left" style="margin-bottom: 0in">---------------------------------------------
<p lang="en-GB" align="left" style="margin-bottom: 0in">Borland C++ 5.6.4: no named exception
thrown
<p lang="en-GB" align="left" style="margin-bottom: 0in">Visual C++ 8.0: bad allocation
<p lang="en-GB" align="left" style="margin-bottom: 0in">Code Warrior 8.0: exception
<p lang="en-GB" align="left" style="margin-bottom: 0in">g++ 3.4.4: St9exception
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">It is difficult to recognize what exception was
thrown when using those compilers except Visual C++.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Consider to add footnote that recommends
what() returns message easy to recognize what exception was
thrown.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 64
<td>
<p>19.3
<td>
<p>1
<td>
<p>Ge
<td>
<p><font color="#000000">&#8220;</font> See also: ISO C 7.1.4, 7.2, Amendment 1
4.3.<font color=
"#000000">&#8221; It is unclear why this cross reference is here.
Amendment 1 was to C89, not C99.</font>
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Delete this cross reference.
If necessary, expand the main text to include the relevant
referenced text
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 65
<td>
<p lang="en-GB" align="left">20
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left">Scoped allocators and allocator propagation traits
add a small amount of utility at the cost of a great deal of
machinery. The machinery is user visible, and it extends to library
components that don't have any obvious connection to allocators,
including basic concepts and simple components like pair and
tuple.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Sketch of proposed resolution: Eliminate
scoped allocators, replace allocator propagation traits with a
simple uniform rule (e.g. always propagate on copy and move),
remove all mention of allocators from components that don't
explicitly allocate memory (e.g. pair), and adjust container
interfaces to reflect this simplification.
<p lang="en-GB" align="left" style="margin-bottom: 0in">Components that I propose eliminating
include <font size=
"2" style="font-size: 11pt"> <font color=
"#0000FF"><span style=
"background: #ffffce">HasAllocatorType</span></font><font color=
"#000080"><u><a href=
"http://wiki.corp.google.com/twiki/bin/edit/Main/HasAllocatorType?topicparent=Main.CppStandardIssues"> ?</a></u></font>, is_scoped_allocator, allocator_propagation_map,
scoped_allocator_adaptor, and <font color="#0000FF"><span style=
"background: #ffffce">ConstructibleAsElement</span></font><font color="#000080">
<u><a href=
"http://wiki.corp.google.com/twiki/bin/edit/Main/ConstructibleAsElement?topicparent=Main.CppStandardIssues">
?</a></u></font>.</font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
198
<td>
<p align="justify">20
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">The
organization of clause 20 could be improved to better group related
items, making the standard easier to navigate.
<td>
<p align="left" style="margin-bottom: 0in">20.6.7, 20.6.8, 20.6.9 and 20.6.10 should be
grouped under a section called "operator wrappers" or similar. The
goal of all 4 subsections combined is to provide a functor for
every operator in the language. 20.6.17 class template hash should
numerically appear immediately after the operator wrappers, as they
are functors that are used in similar ways 20.6.11, 20.6.12,
20.6.13, 20.6.14, 20.6.15 are strongly related to 20.6.3, and to an
extent 20.6.2. These should all come under a subheading of
"function adapters" 20.7.1, 20.7.3, 20.7.4, 20.7.5, 20.7.6, 20.7.7
and 20.7.10 should all be grouped as subclauses under [20.7.2
Allocators] [20.7.12 unique_ptr] should be a sub-section of
[20.7.13 smart pointers] [20.7.13 smart pointers] is important
enough to have a high level bullet after [20.7 memory], suggest
renumbering as [20.8 smart pointers] [20.7.13.7 Pointer safety] is
nothing to do with smart pointers and should become its own
subclause [20.7.14 Pointer safety] [20.9 date and time functions]
should be moved under [20.8 time utilities] and retitled [20.8.6 C
Library] (as per memory management/C Library) [20.6.18
reference_closure] is fundamentally a language support feature and
should move to clause 18, see separate comment [20.6.5
reference_wrapper] should be simplified and moved into [2.2 utility
components], see separate comment [20.6.4 result_of] should be
reorganised as a type trait - see separate comment Tuples and pairs
are closely related so merge tuple and pair into the same subclause
- see more general comment on this
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
199
<td>
<p align="justify">20.1.1,
20.1.2
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The requirement that programs do not supply
concept_maps should probably be users do not supply their own
concept_map specializations. THe program will almost certainly
supply concept_maps - the standard itself supplies a specialization
for RvalueOf? references. Note that the term _program_ is defined
in 3.5p1 and makes no account of the standard library being treated
differently to user written code.
<p align="left"><br>
<td>
<p align="left">Replace the
term 'program' with 'user'.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
200
<td>
<p align="justify">20.1.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">All standard
library use expects Predicates to be CopyConstructible, and this
should be recognised easily without reatedly stating on every
use-case.
<td>
<p align="left" style="margin-bottom: 0in">Either require CopyConstructible&lt;F&gt; as part
of Predicate, or create a refined concept, StdPredicate, used
throughout the library that requires CopyConstructible as well as
Callable. Consider making (Std)Predicate SemiRegular.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
201
<td>
<p align="justify">20.1.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">The
Consistency axiom for LessThanComparable will not compile.
<td>
<p align="left" style="margin-bottom: 0in">Add a requires clause to the Consistency axiomL
requires HasLessEquals&lt;T&gt; &amp;&amp;
HasGreaterEquals&lt;T&gt;, or split the Consistency axiom into two
so that 'basic' consistency can be asserted regardless of the
&lt;=/&gt;= requirement.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 33
<td>
<p lang="en-GB" align="left">20.1.5
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">LessThanComparable and
EqualityComparable don't correspond to NaN.
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">Apply concept_map to these concepts at
FloatingPointType
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>US 66
<td>
<p>20.1.10
<td>
<p><br>
<td>
<p>te
<td>
<p>Application of the
"Regular" concept to floating-point types appears to be
controversial (see long discussion on std-lib reflector).
<td>
<p>State that the
&#8220;Regular&#8221; concept does not apply to floating-point
types.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 34
<td>
<p lang="en-GB" align="left">20.2
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">1<sup>st</sup><font size=
"2" style="font-size: 11pt"> paragraph, 4<sup>th</sup> line</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Though N2672 pointed at adding
"#include&lt;initializer_list&gt;", it isn't reflected.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">add followings
<p lang="en-GB" align="left" style="margin-top: 0.04in">#include &lt;initializer_list&gt; // for
concept_map
<td>
<p><br>
<tr valign="top">
<td>
<p>US 67
<td>
<p>20.2.1
<td>
<p>&#182; 5 first
sent.
<td>
<p>ed
<td>
<p>Some connective words are
missing.
<td>
<p>Insert
&#8220;corresponding to&#8221; before &#8220;an lvalue reference
type.&#8221;
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 35
<td>
<p lang="en-GB" align="left">20.2.3
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">6<sup>th</sup><font size=
"2" style="font-size: 11pt"> paragraph, 1<sup>st</sup> line</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo,
<p lang="en-GB" align="left">"stdforward" should be "std::forward"
<td>
<p lang="en-GB" align="left">Correct typo.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
202
<td>
<p align="justify">20.2.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The references to pair in the tuple-like access to
pair functions qualify pair with std::pair even though they are in
a namespace std block.
<p align="left"><br>
<td>
<p align="left">Remove the
std:: qualification from these references to pair.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 68
<td>
<p>20.2.12
<td>
<p>IntegralLike
<td>
<p>te/ed
<td>
<p>The code defining the
context is syntactically incorrect.
<td>
<p>Insert a comma in two
places: at the end of the third line of refinements, and at the end
of the fourth line of refinements.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
203
<td>
<p align="justify">20.3.2
<td>
<p align="justify">1-4
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The ratio_xyz types have a misplaced '}'. For
example: template &lt;class R1, class R2&gt; struct ratio_add {
typedef see below} type; ;
<p align="left"><br>
<td>
<p align="left">Move the '}'
to after the typedef: template &lt;class R1, class R2&gt; struct
ratio_add { typedef see below type; };
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 36
<td>
<p lang="en-GB" align="left">20.4.2.1
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">19<sup>th</sup><font size=
"2" style="font-size: 11pt"> paragraph, 6<sup>th</sup> line</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo.
<p lang="en-GB" align="left" style="margin-top: 0.04in">"it it" should be "it is"
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Correct typo.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
204
<td>
<p align="justify">20.5
<td>
<p align="justify">Table
41
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It is not possible to create a variant union based
on a parameter pack expansion, e.g. to implement a classic
discriminated union template.
<p align="left"><br>
<td>
<p align="left">Restore
aligned_union template that was removed by LWG issue 856.
<td>
<p><br>
<tr valign="top">
<td>
<p>US 69
<td>
<p>20.5
<td>
<p><br>
<td>
<p>ed
<td>
<p>This section, dealing with
tuple&lt;&gt;, should be in the same section as the similar utility
pair&lt;&gt;.
<td>
<p>Restructure Clause 20 so
as to bring these similar components together.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
205
<td>
<p align="justify">20.5.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">integral_constant objects should be usable in
integral-constant-expressions. The addition to the language of
literal types and the enhanced rules for constant expressions make
this possible.
<p align="left"><br>
<td>
<p align="left">Add a
constexpr conversion operator to class tempalate integral_constant:
constexpr operator value_type() { return value; }
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
206
<td>
<p align="justify">20.5.5
<td>
<p align="justify">para
4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Currently the std says: "In order to instantiate
the template is_convertible&lt;From, To&gt;, the following code
shall be well formed:" But the code shown is the requirement for
the result of is_convertible to be a true_type, not a precondition
on whether the template can be instantiated.
<p align="left"><br>
<td>
<p align="left">Change: "In
order to instantiate the template is_convertible&lt;From, To&gt;,
the following code shall be well formed:" To: "The template
is_convertible&lt;From, To&gt; inherits either directly or
indirectly from true_type if the following code is well
formed:"
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
207
<td>
<p align="justify">20.5.6.1
<td>
<p align="justify">Table
36
<td>
<p align="justify">Ed
<td>
<p align="left">suffix
"::type" is missing from the some of the examples.
<td>
<p align="left" style="margin-bottom: 0in">Change: Example:remove_const&lt;const volatile
int&gt;::type evaluates to volatile int, whereas
remove_const&lt;const int*&gt; is const int*. &#8212;end example
To: Example:remove_const&lt;const volatile int&gt;::type evaluates
to volatile int, whereas remove_const&lt;const int*&gt;::type is
const int*. &#8212;end example And change:
Example:remove_volatile&lt;const volatile int&gt;::type evaluates
to const int, whereas remove_volatile&lt;volatile int*&gt; is
volatile int*. &#8212;end example To:
Example:remove_volatile&lt;const volatile int&gt;::type evaluates
to const int, whereas remove_volatile&lt;volatile int*&gt;::type is
volatile int*. &#8212;end example And change:
Example:remove_cv&lt;const volatile int&gt;::type evaluates to int,
whereas remove_cv&lt;const volatile int*&gt; is const volatile
int*. &#8212;end example To: Example:remove_cv&lt;const volatile
int&gt;::type evaluates to int, whereas remove_cv&lt;const volatile
int*&gt;::type is const volatile int*. &#8212;end example
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 37
<td>
<p lang="en-GB" align="left">20.5.7
<td>
<p lang="en-GB" align="left">Table 41
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo.
<p lang="en-GB" align="left" style=
"text-indent: 0.19in; margin-bottom: 0in">There isn't a period at the end of enable_if's
comments.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">If B is true, the member typedef type
shall equal T; otherwise, there shall be no member typedef
type
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">If B is true, the member typedef type
shall equal T; otherwise, there shall be no member typedef
type.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add &#8221;.&#8221;
<td>
<p><br>
<tr valign="top">
<td>
<p>US 70
<td>
<p>20.6
<td>
<p><br>
<td>
<p>te
<td>
<p>Specifications now
expressed via narrative text are more accurately and clearly
expressed via executable code.
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Wherever concepts are
available that directly match this section&#8217;s type traits,
express the traits in terms of the concepts instead of via
narrative text. Where the type traits do not quite match the
corresponding concepts, bring the two into alignment so as to avoid
two nearly-identical notions.
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>US 71
<td>
<p>20.6.7
<td>
<p>Table 51, last row, column
3
<td>
<p>ed
<td>
<p>The grammar is
incorrect.
<td>
<p>Change &#8220;conversion
are&#8221; to &#8220;conversion is&#8221;.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 38
<td>
<p lang="en-GB" align="left">20.6.12.1.3
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-left: 0.19in; text-indent: -0.19in; margin-bottom: 0in">
add the move requirement for
bind's return type.<br><br>
<p lang="en-GB" align="left" style=
"margin-left: 0.19in; text-indent: -0.19in; margin-bottom: 0in">
For example, assume following
th1 and th2,
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
void f(vector&lt;int&gt; v) { }<br>
<br>
vector&lt;int&gt; v{ ... };<br>
thread th1([v]{ f(v); });<br>
thread th2(bind(f, v));<br>
<br>
When function object are set to thread, v is moved to th1's lambda
expression in a Move Constructor of lambda expression becuase th1's
lambda expression has a Move Constructor. But bind of th2's return
type doesn't have the requirement of Move, so it may not moved but
copied.
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add the requirement of move to get rid
of this useless copy.
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">And also, add the MoveConstructible as well as
CopyConstructible.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add the following requirements.<br>
"<font color="#000000">it
has a public move constructor that performs a member-wise
move."</font>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add the MoveConstructible.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 39
<td>
<p lang="en-GB" align="left">20.6.16.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">There are no requires corresponding to F
of std::function.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class F, Allocator A&gt;
function(allocator_arg_t, const A&amp;, F);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class F, Allocator A&gt;
function(allocator_arg_t, const A&amp;, F&amp;&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class F, Allocator
A&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">requires CopyConstructible&lt;F&gt;
&amp;&amp; Callable&lt;F, ArgTypes...&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">function(allocator_arg_t, const A&amp;,
F);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class F, Allocator
A&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">requires CopyConstructible&lt;F&gt;
&amp;&amp; Callable&lt;F, ArgTypes...&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">function(allocator_arg_t, const A&amp;,
F&amp;&amp;);
<p lang="en-GB" align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 40
<td>
<p lang="en-GB" align="left">20.6.16.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Thougn it's "Allocator Aloc" at other
places, it's "Allocator A" only std::function constructor template
parameter.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class F, Allocator A&gt;
function(allocator_arg_t, const A&amp;, F);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class F, Allocator A&gt;
function(allocator_arg_t, const A&amp;, F&amp;&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class F, Allocator
<u>Alloc</u>&gt; function(allocator_arg_t, const <u>Alloc</u>
&amp;, F);
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">template&lt;class F, Allocator <u>Alloc</u>&gt;
function(allocator_arg_t, const <u>Alloc</u> &amp;,
F&amp;&amp;);
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 41
<td>
<p lang="en-GB" align="left">20.6.16.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">There are no requires corresponding to R
and Args of UsesAllocator.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class R, class...
Args&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">concept_map
UsesAllocator&lt;function&lt;R(Args...)&gt;, Alloc&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef Alloc allocator_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... Args&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">concept_map
UsesAllocator&lt;function&lt;R(Args...)&gt;, Alloc&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef Alloc allocator_type;
<p lang="en-GB" align="left" style="margin-top: 0.04in">}
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 42
<td>
<p lang="en-GB" align="left">20.6.16.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">The requires are wrong.
<p lang="en-GB" align="left" style="margin-top: 0.04in">R require Returnable, and ArgTypes
requires CopyConstructible by a definition of function, then it's a
mistake to designate followings by MoveConstructible.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;MoveConstructible R,
MoveConstructible... ArgTypes&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator==(const
function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;MoveConstructible R,
MoveConstructible... ArgTypes&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator==(nullptr_t, const
function&lt;R(ArgTypes...)&gt;&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;MoveConstructible R,
MoveConstructible... ArgTypes&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator!=(const
function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;MoveConstructible R,
MoveConstructible... ArgTypes&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator!=(nullptr_t, const
function&lt;R(ArgTypes...)&gt;&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;MoveConstructible R,
MoveConstructible... ArgTypes&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void
swap(function&lt;R(ArgTypes...)&gt;&amp;,
function&lt;R(ArgTypes...)&gt;&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... ArgTypes&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator==(const
function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... ArgTypes&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator==(nullptr_t, const
function&lt;R(ArgTypes...)&gt;&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... ArgTypes&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator!=(const
function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... ArgTypes&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator!=(nullptr_t, const
function&lt;R(ArgTypes...)&gt;&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... ArgTypes&gt;
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">void swap(function&lt;R(ArgTypes...)&gt;&amp;,
function&lt;R(ArgTypes...)&gt;&amp;);
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
208
<td>
<p align="justify">20.6.17
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">std::hash should be implemented for much more of
the standard library. In particular for pair, tuple and all the
standard containers.
<p align="left"><br>
<td>
<p align="left">.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
209
<td>
<p align="justify">20.7
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">Smart
pointers cannot be used in constrained templates
<td>
<p align="left" style="margin-bottom: 0in">Provide constraints for smart pointers
<p align="left" style="margin-bottom: 0in"><br>
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
213
<td>
<p align="justify">20.7.6
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">std::allocator should be constrained to simplify
its use on constrained contexts. This library component models
allocation from free store via the new operator so choose
constraints to match. The Allocator concept allows for a wider
variety of allocators that users may choose to supply if their
allocation model does not require operator new, without impacting
the requirements of this template.
<p align="left"><br>
<td>
<p align="left">The primary
allocator template should be constrained to require
ObjectType&lt;T&gt; and FreeStoreAllocatable&lt;T&gt;. Further
operations to be constrained as required.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
214
<td>
<p align="justify">20.7.8
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">raw_storage_iterator needs constraining as an
iterator adaptor to be safely used in constrained templates
<p align="left"><br>
<td>
<p align="left">Constrain the
raw_storage_iterator template
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
210
<td>
<p align="justify">20.7.11
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">Specialized
algorithms for memory managenment need requirements to be easily
usable in constrained templates
<td>
<p align="left" style="margin-bottom: 0in">Provide constraints for all algorithms in
20.7.11
<p align="left" style="margin-bottom: 0in"><br>
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-20
<td>
<p>20.7.12
<td>
<p><br>
<td>
<p>ed
<td>
<p>DE-20 The section heading
and the first sentence use the term "template function", which is
undefined.
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Replace "template function"
by "function template".
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p align="left">US 72
<td>
<p lang="en-GB" align="left">20.7.12
<td>
<p align="left"><br>
<td>
<p align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">bind should support move-only functors
and bound arguments.
<p lang="en-GB" align="left"><br>
<td>
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>DE-21
<td>
<p>20.7.12.1.3
<td>
<p><br>
<td>
<p>te
<td>
<p>DE-21 The specification
for bind claims twice that "the values and types for the bound
arguments v1, v2, ..., vN are determined as specified below". No
such specification appears to exist.
<td>
<p>Add the missing
specification in the same section, or add a cross-reference
indicating the section where the specification appears.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
211
<td>
<p align="justify">20.7.12.2.3
<td>
<p align="justify">11
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The nullptr_t type was introduced to resolve the
null pointer literal problem. It should be used for the assignemnt
operator, as with the constructor and elsewhere through the
library.
<p align="left"><br>
<td>
<p align="left">Change
signature here and in the synopsis to: unique_ptr&amp;
operator=(nullptr_t); Strike the sentance an note before the
Effects clause.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
212
<td>
<p align="justify">20.7.13.7
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The pointer-safety API is nothing to do with smart
pointers, so does not belong in 20.7.13. In fact it is a set of
language support features are really belongs in clause 18, with the
contents declared in a header that deals with language-support of
memory management.
<p align="left"><br>
<td>
<p align="left">Move this
specification to 18.5. Move the declarations into the header
&lt;new&gt;.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>DE-22
<td>
<p>20.7.16.2
<td>
<p><br>
<td>
<p>te
<td>
<p>DE-22 The conditions for
deriving from std::unary_function and std::binary_function are
unclear: The condition would also be satisfied if ArgTypes were
std::vector&lt;T1&gt;, because it (arguably) "contains" T1.
<td>
<p>Consider stating the
conditions in normative prose instead of in comments in the class
definition. Use "consists of" instead of "contains". Consider using
"if and only if" instead of "iff".
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p align="left">US 73
<td>
<p align="left">20.7.18
<td>
<p align="left"><br>
<td>
<p align="left">te
<td>
<p align="left" style="margin-bottom: 0in">The
std::reference_closure template is redundant with std::function and
should be removed.
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">std::reference_closure is
a premature optimization that provides a limited subset of the
functionality of std::function intended to improve performance in a
narrow use case. However, the &#8220;parallel application
performance&#8221; benchmark used to motivate the inclusion of
std::reference_closure was flawed in several ways:
<ol start="3">
<li>
<p align="left" style="margin-bottom: 0in">it failed to enable a
common optimization in std::function (implemented by all vendors),
exacting a large and unrealistic penalty for copying std::function
instances, and
<li>
<p align="left" style="margin-bottom: 0in">it failed to account for
parallel scheduler overhead or realistically-sized work units, both
of which would dominate the costs measured by the benchmark in any
realistic application.</ol>
<p align="left" style="margin-left: 0.25in"><br>
<td>
<p align="left" style="margin-bottom: 0in">Remove 20.7.18
[func.referenceclosure].
<p align="left" style="margin-bottom: 0in"><br>
<p align="left">Remove 5.1.1 paragraph 12.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p align="left">US 74
<td>
<p align="left">20.8
<td>
<p align="left"><br>
<td>
<p align="left">te
<td>
<p align="left" style="margin-bottom: 0in">Scoped allocators
represent a poor trade-off for standardization, since (1)
scoped-allocator--aware containers can be implemented outside the
C++ standard library but used with its algorithms, (2) scoped
allocators only benefit a tiny proportion of the C++ community
(since few C++ programmers even use today&#8217;s allocators), and
(3) all C++ users, especially the vast majority of the C++
community that won&#8217;t ever use scoped allocators are forced to
cope with the interface complexity introduced by scoped allocators.
In essence, the larger community will suffer to support a very
small subset of the community who can already implement their own
data structures outside of the standard library. Therefore, scoped
allocators should be removed from the working paper.
<p align="left" style="margin-bottom: 0in">Some evidence of the
complexity introduced by scoped allocators:
<p align="left" style="margin-bottom: 0in">20.3.3, 20.5: large
increase in the number of pair and tuple constructors
<p align="left" style="margin-bottom: 0in">23: confusing
&#8220;AllocatableElement&#8221; requirements throughout.
<p align="left"><br>
<td>
<p align="left" style="margin-bottom: 0in">Remove support for scoped
allocators from the working paper. This includes at least the
following changes:
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">Remove 20.8.3
[allocator.element.concepts]
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">Remove 20.8.7
[allocator.adaptor]
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">Remove 20.8.10
[construct.element]
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">In Clause 23: replace
requirements naming the AllocatableElement concept with
requirements naming CopyConstructible, MoveConstructible,
DefaultConstructible, or Constructible, as appropriate.
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>US 74
<td>
<p>20.8.2.2
<td>
<p>(a) synopsis (b) after
&#182; 14
<td>
<p>te/ed
<td>
<p>A concept name is twice
misspelled.
<td>
<p>Change
&#8220;Hasconstructor&#8221; to &#8220;HasConstructor&#8221;
(twice).
<td>
<p><br>
<tr valign="top">
<td>
<p>US 75
<td>
<p>20.8.2.2
<td>
<p><br>
<td>
<p>te
<td>
<p>Allocator concepts are
incomplete
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
See paper:
http://www.halpernwightsoftware.com/WG21/n2810_allocator_defects.pdf
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 43
<td>
<p lang="en-GB" align="left">20.8.3
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo.
<p lang="en-GB" align="left" style="margin-top: 0.04in">"alloc" should be "Alloc"
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">auto concept UsesAllocator&lt;typename
T, typename Alloc&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">requires Allocator&lt;alloc&gt;;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typename allocator_type =
T::allocator_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">auto concept UsesAllocator&lt;typename
T, typename Alloc&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">requires
Allocator&lt;<u>Alloc</u>&gt;;
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">typename allocator_type =
T::allocator_type;
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
215
<td>
<p align="justify">20.8.3.3
<td>
<p align="justify">6,8
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Extra pair of {}, presumably some formatting code
gone awry : duration&amp; operator-{-}();
<p align="left"><br>
<td>
<p align="left">Remove the {}
or fix formatting
<td>
<p><br>
<tr valign="top">
<td>
<p align="left">US 77
<td>
<p align="left">20.8.4
<td>
<p align="left"><br>
<td>
<p align="left">te
<td>
<p align="left" style="margin-bottom: 0in">Allocator-specific move
and copy behavior for containers (N2525) complicates a little-used
and already-complicated portion of the standard library
(allocators), and breaks the conceptual model of move-constructor
and move-assignment operations on standard containers being
efficient operations. The extensions for allocator-specific move
and copy behavior should be removed from the working paper.
<p align="left" style="margin-bottom: 0in">With the introduction of
rvalue references, we are teaching programmers that moving from a
standard container (e.g., a vector&lt;string&gt;) is an efficient,
constant-time operation. The introduction of N2525 removed that
guarantee; depending on the behavior of four different traits
(20.8.4), the complexity of copy and move operations can be
constant or linear time. This level of customization greatly
increases the complexity of standard containers, and benefits only
a tiny fraction of the C++ community.
<p align="left"><br>
<td>
<p align="left" style="margin-bottom: 0in">Remove 20.8.4.
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">Remove 20.8.5.
<p align="left" style="margin-bottom: 0in"><br>
<p align="left">Remove all references to the facilities in
20.8.4 and 20.8.5 from clause 23.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 78
<td>
<p lang="en-GB" align="left">20.8.12, 20.8.13.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left">There is
presently no way to convert directly from a <font size="2" style=
"font-size: 11pt">
<code>shared_ptr</code> to a <code>unique_ptr</code>.</font>
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add an interface that performs the conversion. See
the attached, Issues with the C++ Standard" paper under Chapter 20,
"Conversion from <font size=
"2" style="font-size: 11pt"> <code>shared_ptr</code> to <code>unique_ptr".</code></font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="left">US 79
<td>
<p lang="en-GB" align="left">20.8.12.2.1
<td>
<p align="left"><br>
<td>
<p align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">[unique.ptr.single.ctor]/5 no longer
requires for D not to be a pointer type. &nbsp;This restriction
needs to be put back in. &nbsp;Otherwise we have a run time failure
that could have been caught at compile time:
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">unique_ptr&lt;int, void(*)(void*)&gt;
p(malloc(sizeof(int))); &nbsp;// should not compile
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">unique_ptr&lt;int, void(*)(void*)&gt;
p(malloc(sizeof(int)), free); &nbsp;// ok
<p align="left"><br>
<td>
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>JP 44
<td>
<p lang="en-GB" align="left">20.8.13.6
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The 1st parameter p and 2nd parameter v
is now shared_ptr&lt;T&gt; *.
<p lang="en-GB" align="left" style="margin-top: 0.04in">It should be shared_ptr&lt;T&gt;&amp;,
or if these are shared_ptr&lt;T&gt;* then add the "p shall not be a
null pointer" at the requires.
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Change shared_ptr&lt;T&gt;&amp; or add
the "p shall not be a null pionter" at the requires.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>JP 45
<td>
<p lang="en-GB" align="left">20.9
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Rep, Period, Clock and Duration don't
correspond to concept.
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class Rep, class Period =
ratio&lt;1&gt;&gt; class duration;
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">template &lt;class Clock, class Duration =
typename Clock::duration&gt; class time_point;
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Make concept for Rep, Period, Clock and
Duration, and fix 20.9 and wait_until and wait_for's template
parameter at 30.
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>US 80
<td>
<p>20.9.2.1
<td>
<p>Heading
<td>
<p>ed
<td>
<p>The section heading does
not describe the contents.
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Change the heading
&#8220;<span lang="en-US">is_floating_point</span>&#8221; to
&#8220;<span lang="en-US">treat_as_floating_point</span>&#8221;.
Optionally adjust the section&#8217;s label similarly.
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p align="left">US 81
<td>
<p lang="en-GB" align="left">20.9.3
<td>
<p align="left"><br>
<td>
<p align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">chrono::duration is missing the modulous
operator for both member and non-member arithmetic. This operator
is useful for finding the position of a duration within a bounded
time frame. Having it be built in to duration is safer than
requiring the client to extract and operate directly on the
duration&#8217;s representation as the latter will not enforce the
correct units of the operation.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Ex:
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">milliseconds ms(...);
<p lang="en-GB" align="left" style="margin-bottom: 0in">microseconds us(...);
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">ms % us; // microseconds
<p lang="en-GB" align="left" style="margin-bottom: 0in">us % ms; // microseconds
<p lang="en-GB" align="left" style="margin-bottom: 0in">ms % 5; // milliseconds
<p lang="en-GB" align="left" style="margin-bottom: 0in">5 % ms; // does not compile
<p lang="en-GB" align="left"><br>
<td>
<p align="left" style="margin-bottom: 0in">Add:
<p align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class Rep, class Period =
ratio&lt;1&gt;&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class duration {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p align="left" style="margin-bottom: 0in">...
<p align="left" style="margin-bottom: 0in">duration&amp;
operator%(const rep&amp;);
<p align="left" style="margin-bottom: 0in">duration&amp;
operator%(const duration&amp;);
<p align="left" style="margin-bottom: 0in">..
<p align="left" style="margin-bottom: 0in">};
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">template &lt;class Rep1,
class Period,
<p align="left" style="margin-bottom: 0in">class Rep2&gt;
<p align="left" style="margin-bottom: 0in">duration&lt;typename
common_type&lt;
<p align="left" style="margin-bottom: 0in">Rep1, Rep2&gt;::type,
Period&gt;
<p align="left" style="margin-bottom: 0in">operator%(const
duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in">template &lt;class Rep1,
class Period1,
<p align="left" style="margin-bottom: 0in">class Rep2, class
Period2&gt;
<p align="left" style="margin-bottom: 0in">typename
common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2,
Period2&gt;&gt;::type
<p align="left" style="margin-bottom: 0in">operator%(const
duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2,
Period2&gt;&amp; rhs);
<p align="left"><br>
<td>
<p align="left"><br>
<tr valign="top">
<td>
<p>US 82
<td>
<p>20.9.5.3
<td>
<p>after &#182; 1
<td>
<p>ed
<td>
<p>The code synopsis has a
minor alignment error.
<td>
<p>Align &#8220;rep&#8221;
with the other symbols defined in this synopsis.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
216
<td>
<p align="justify">21
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">All the
containers use concepts for their iterator usage, exect for
basic_string. This needs fixing.
<td>
<p align="left">Use concepts
for iterator template parameters throughout the chapter.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 46
<td>
<p lang="en-GB" align="left">21.2, 21.3
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">The basic_string does not use
concept.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The "class Alloc" is changed to
"Allocator Alloc".
<p lang="en-GB" align="left" style="margin-bottom: 0in">The "class InputIterator" is changed to
"InputIterator Iter".
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 21.3, basic_string:
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits =
char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>Allocator</u> Alloc =
allocator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class basic_string;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(const charT* lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(const charT* lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(charT lhs, const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(charT lhs,
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const charT* rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const charT* rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs, charT
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
lhs, charT rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator==(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator==(const charT* lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator==(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const charT* rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator!=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator!=(const charT* lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator!=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const charT* rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&lt; (const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&lt; (const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const charT* rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&lt; (const charT*
lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&gt; (const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&gt; (const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const charT* rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&gt; (const charT*
lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&lt;=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&lt;=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const charT* rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&lt;=(const charT*
lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&gt;=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&gt;=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const charT* rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">bool operator&gt;=(const charT*
lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 21.3.8.8: swap
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void
swap(basic_string&lt;charT,traits,Alloc&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,Alloc&gt;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void
swap(basic_string&lt;charT,traits,Alloc&gt;&amp;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,Alloc&gt;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void
swap(basic_string&lt;charT,traits,Alloc&gt;&amp; lhs,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,Alloc&gt;&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 21.3.8.9: inserters and
extractors
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_istream&lt;charT,traits&gt;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator&gt;&gt;(basic_istream&lt;charT,traits&gt;&amp;&amp;
is,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_ostream&lt;charT,
traits&gt;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">operator&lt;&lt;(basic_ostream&lt;charT,
traits&gt;&amp;&amp; os,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_istream&lt;charT,traits&gt;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">getline(basic_istream&lt;charT,traits&gt;&amp;&amp;
is,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
str,
<p lang="en-GB" align="left" style="margin-bottom: 0in">charT delim);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits,
<u>Allocator</u> <u>Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_istream&lt;charT,traits&gt;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">getline(basic_istream&lt;charT,traits&gt;&amp;&amp;
is,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 21.3 Class template
basic_string
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT, class traits =
char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>Allocator Alloc</u> =
allocator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class basic_string {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">// types:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef traits traits_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename traits::char_type
value_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef <u>Alloc</u>
allocator_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename <u>Alloc</u>::size_type
size_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename
<u>Alloc</u>::difference_type difference_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename <u>Alloc</u>::reference
reference;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename
<u>Alloc</u>::const_reference const_reference;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename <u>Alloc</u>::pointer
pointer;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename
<u>Alloc</u>::const_pointer const_pointer;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef implementation-defined iterator;
// See 23.1
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef implementation-defined
const_iterator; // See 23.1
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef
std::reverse_iterator&lt;iterator&gt; reverse_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef
std::reverse_iterator&lt;const_iterator&gt;
const_reverse_iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">static const size_type npos = -1;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 21.3.2 construct/copy/destroy:
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit basic_string(const
<u>Alloc</u>&amp; a = <u>Alloc</u>());
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string(const basic_string&amp;
str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string(basic_string&amp;&amp;
str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string(const basic_string&amp;
str, size_type pos, size_type n = npos,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const <u>Alloc</u>&amp; a =
<u>Alloc</u>());
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string(const charT* s,
<p lang="en-GB" align="left" style="margin-bottom: 0in">size_type n, const <u>Alloc</u>&amp; a =
<u>Alloc</u>());
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string(const charT* s, const
<u>Alloc</u>&amp; a = <u>Alloc</u>());
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string(size_type n, charT c, const
<u>Alloc</u>&amp; a = <u>Alloc</u>());
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;<u>InputIterator</u>
<u>Iter</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string(<u>Iter</u> begin,
<u>Iter</u> end,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const <u>Alloc</u>&amp; a =
<u>Alloc</u>());
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string(initializer_list&lt;charT&gt;, const
<u>Alloc</u>&amp; = <u>Alloc</u>());
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string(const basic_string&amp;,
const <u>Alloc</u>&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string(basic_string&amp;&amp;,
const <u>Alloc</u>&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">~basic_string();
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; operator=(const
basic_string&amp; str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp;
operator=(basic_string&amp;&amp; str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; operator=(const charT*
s);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; operator=(charT
c);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp;
operator=(initializer_list&lt;charT&gt;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 21.3.3 iterators:
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 21.3.4 capacity:
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 21.3.5 element access:
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 21.3.6 modifiers:
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; append(const
basic_string&amp; str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; append(const
basic_string&amp; str, size_type pos,
<p lang="en-GB" align="left" style="margin-bottom: 0in">size_type n);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; append(const charT* s,
size_type n);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; append(const charT*
s);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; append(size_type n,
charT c);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;<u>InputIterator</u>
<u>Iter</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; append(<u>Iter</u>
first, <u>Iter</u> last);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp;
append(initializer_list&lt;charT&gt;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">void push_back(charT c);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; assign(const
basic_string&amp; str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp;
assign(basic_string&amp;&amp; str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; assign(const
basic_string&amp; str, size_type pos,
<p lang="en-GB" align="left" style="margin-bottom: 0in">size_type n);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; assign(const charT* s,
size_type n);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; assign(const charT*
s);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; assign(size_type n,
charT c);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;<u>InputIterator</u>
<u>Iter</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; assign(<u>Iter</u>
first, <u>Iter</u> last);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp;
assign(initializer_list&lt;charT&gt;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; insert(size_type pos1,
const basic_string&amp; str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; insert(size_type pos1,
const basic_string&amp; str,
<p lang="en-GB" align="left" style="margin-bottom: 0in">size_type pos2, size_type n);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; insert(size_type pos,
const charT* s, size_type n);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; insert(size_type pos,
const charT* s);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; insert(size_type pos,
size_type n, charT c);
<p lang="en-GB" align="left" style="margin-bottom: 0in">iterator insert(const_iterator p, charT
c);
<p lang="en-GB" align="left" style="margin-bottom: 0in">void insert(const_iterator p, size_type
n, charT c);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;<u>InputIterator</u>
<u>Iter</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void insert(const_iterator p,
<u>Iter</u> first, <u>Iter</u> last);
<p lang="en-GB" align="left" style="margin-bottom: 0in">void insert(const_iterator p,
initializer_list&lt;charT&gt;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(size_type
pos1, size_type n1,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const basic_string&amp; str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(size_type
pos1, size_type n1,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const basic_string&amp; str,
<p lang="en-GB" align="left" style="margin-bottom: 0in">size_type pos2, size_type n2);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(size_type pos,
size_type n1, const charT* s,
<p lang="en-GB" align="left" style="margin-bottom: 0in">size_type n2);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(size_type pos,
size_type n1, const charT* s);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(size_type pos,
size_type n1, size_type n2,
<p lang="en-GB" align="left" style="margin-bottom: 0in">charT c);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(iterator i1,
iterator i2,
<p lang="en-GB" align="left" style="margin-bottom: 0in">const basic_string&amp; str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(iterator i1,
iterator i2, const charT* s,
<p lang="en-GB" align="left" style="margin-bottom: 0in">size_type n);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(iterator i1,
iterator i2, const charT* s);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(iterator i1,
iterator i2,
<p lang="en-GB" align="left" style="margin-bottom: 0in">size_type n, charT c);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;<u>InputIterator</u>
<u>Iter</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(iterator i1,
iterator i2,
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>Iter</u> j1, <u>Iter</u> j2);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&amp; replace(iterator,
iterator, initializer_list&lt;charT&gt;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 21.3.7 string operations:
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator</u> <u>Alloc&gt;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">struct
constructible_with_allocator_suffix&lt;
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">basic_string&lt;charT, traits, <u>Alloc</u>&gt;
&gt; : true_type { };
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 47
<td>
<p lang="en-GB" align="left">21.3
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo. Missing &#8221;&gt;&#8221;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
Allocator Alloc
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
Allocator Alloc&gt;
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Correct typo.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 48
<td>
<p lang="en-GB" align="left">21.3
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">char_traits does not use concept.
<p lang="en-GB" align="left" style="margin-bottom: 0in">For example, create CharTraits concept
and change as follows:
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class charT,
<u>CharTraits</u> traits = char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in">class Allocator = allocator&lt;charT&gt;
&gt;
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">class basic_string {
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add a concept for char_traits.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
217
<td>
<p align="justify">21.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">basic_string
refers to constructible_with_allocator_suffix, which I thought was
removed?
<td>
<p align="left" style="margin-bottom: 0in">Remove the lines: template &lt;class charT, class
traits, class Alloc struct constructible_with_allocator_suffix&lt;
basic_string&lt;charT, traits, Alloc&gt; &gt; : true_type {
};
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
218
<td>
<p align="justify">21.3.1
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The identity "&amp;*(s.begin() + n) ==
&amp;*s.begin() + n" relies on operator&amp; doing the "right
thing", which (AFAICS) there is no requirement for. See my comment
under clauses "23.2.1, 23.2.6" (p1 in both cases) - this is the
same issue, but I've created a separate comment for basic_string
because it is in a different chapter.
<p align="left"><br>
<td>
<p align="left">See my
recommendations for "23.2.1, 23.2.6".
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
219
<td>
<p align="justify">21.3.6.6
[string.replace]
<td>
<p align="justify">11
<td>
<p align="justify">Ed
<td>
<p align="left">Effects
refers to "whose first begin() - i1 elements" However i1 is greater
than begin()...
<td>
<p align="left">Effects
refers to "whose first i1 - begin() elements"
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
220
<td>
<p align="justify">21.3.8.9
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The operator&lt;&lt; for basic_string takes the
output stream by r-value reference. This is different from the same
operator for error_code (19.4.2.6), bitset (20.2.6.3), shared_ptr
(20.7.13.2.8), complex (26.3.6) and sub_match (28.4)
<p align="left"><br>
<td>
<p align="left">Use the same
reference type for the all the library types. This should be the
r-value reference. There are other places in the standard where
TR1, and new classes, did not receive an 'R-value' update.
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 33
<td>
<p>22.1.1 [locale]
<td>
<p>3
<td>
<p>ed
<td>
<p style="margin-bottom: 0in">ios_base::iostate err = 0;
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">iostate is a bitmask type and so could be
an enumeration. Probably using
<p>goodbit is the solution.
<td>
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 49
<td>
<p lang="en-GB" align="left">22.1.3.2.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">codecvt does not use concept. For
example, create CodeConvert concept and change as follows.
<p lang="en-GB" align="left" style="margin-top: 0.04in">template&lt;<u>CodeConvert</u> Codecvt,
class Elem = wchar_t&gt; class wstring_convert {
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add a concept for codecvt.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 50
<td>
<p lang="en-GB" align="left">22.1.3.2.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add custom allocator parameter to
wstring_convert, since we cannot allocate memory for strings from a
custom allocator.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class Codecvt, class Elem =
wchar_t&gt; class wstring_convert {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef std::basic_string&lt;char&gt;
byte_string;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef std::basic_string&lt;Elem&gt;
wide_string;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style=
"text-indent: 0.06in; margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class Codecvt, class Elem =
wchar_t<u>,</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>Allocator WideAllocator =
allocator&lt;Elem&gt;,</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>Allocator ByteAllocator =
allocator&lt;char&gt;</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class wstring_convert {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef std::basic_string&lt;char,
<u>char_traits&lt;char&gt;, ByteAllocator</u>&gt;
byte_string;
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">typedef std::basic_string&lt;Elem,
<u>char_traits&lt;Elem&gt;, WideAllocator</u>&gt;
wide_string;
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>FI 4
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
22.2.1.4.1
<p>22.2.1.4.2
<td>
<p><br>
<td>
<p>ed
<td>
<p><tt>to_end and to_limit are both used. Only one is
needed.</tt>
<td>
<p>Change to_limit to
to_end.
<td>
<p><br>
<tr valign="top">
<td>
<p>FI 5
<td>
<p><tt>22.2.1.4.2</tt>
<td>
<p>#3
<td>
<p>ed
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
<tt>[ Note: As a result of operations on state, it
can return ok or partial and set next == from and to_next != to.
&#8212;end note ]</tt><br><br>
<br>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
<tt>"next" should be
"from_next."</tt>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
<tt>Also, the sentence applies to all the examples,
including do_in and do_out.</tt>
<p><tt>Reasoning: When reading one element of
multibyte source data such as UTF-8, it is possible that from_next
is incremented, to_next is unaltered, state is altered and return
value is partial.<br>
When reading one element of wide character data, the output can be
several multibyte characters, so it is possible that from_next is
unaltered, to_next is advanced, state is altered and return value
is partial.</tt>
<td>
<p><tt>[ Note: As a result of operations on state,
do_in and do_out can return</tt><br>
<tt>ok or partial and set from_next
== from and/or to_next != to. &#8212;end</tt><br>
<tt>note ]</tt>
<td>
<p><br>
<tr valign="top">
<td>
<p>FI 6
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
22.2.1.5
<p>See also 22.2.1.4
(1,2,3)
<td>
<p><br>
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
<tt>codecvt_byname is only specified to work with
locale names. There is no built-in means to find a codecvt with a
character set's name. A locale and a character set are not the
same. If the user has data which is encoded in a certain character
set and she wants to create a codecvt which can convert from that
character set to another one, she must iterate through locales to
find one, or use external means (iconv, ICU's uconv). Specifying a
locale with the character set is not a suitable solution, since
there is no built-in mapping from character sets to locales. It is
only possible to inquire the character set once the locale is
known.</tt>
<p><br>
<td>
<p><tt>There should be a built-in means to find a
codecvt with a pair of character set names.</tt>
<td>
<p><br>
<tr valign="top">
<td>
<p>FI 7
<td>
<p>22.2.1.4
<td>
<p>1,2,3
<td>
<p>ed
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
The word "codeset" is used,
whereas the word "character set" is used elsewhere in the text. The
words are intended to convey the same concept, so only one should
be used (or always both together).
<p><br>
<td>
<p>Change "codeset" to
"character set."
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 51
<td>
<p lang="en-GB" align="left">22.2.5.1.1
<td>
<p lang="en-GB" align="left">7<sup>th</sup><font size="2" style=
"font-size: 11pt"> paragraph, 1<sup>st</sup> line</font>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">A parameter `end&#8217; should be
`fmtend&#8217;.<br>
get() function had two `end&#8217; parameters at N2321.
<p lang="en-GB" align="left" style="margin-bottom: 0in">iter_type get (iter_type s, iter_type
end, ios_base&amp; f, ios_base::iostate&amp; err, tm* t, const
char_type* fmt, const char_type *end) const;
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">The function prototype of get() has been corrected
at N2800, but a Requires statement still refers `end&#8217;
parameter.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">Requires: [fmt,end) shall be a valid
range.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in"><br>
<br>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Requires: [fmt,fmtend) shall be a valid
range.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 52
<td>
<p lang="en-GB" align="left">22.2.5.1, 22.2.5.2, 22.2.6.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">InputIterator does not use
concept.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">22.2.5.1
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class
InputIterator = istreambuf_iterator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class time_get : public locale::facet,
public time_base {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef InputIterator iter_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT,
<u>InputIterator InputIter</u> = istreambuf_iterator&lt;charT&gt;
&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class time_get : public locale::facet,
public time_base {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef <u>InputIter</u>
iter_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">22.2.5.2
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class
InputIterator = istreambuf_iterator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class time_get_byname : public
time_get&lt;charT, InputIterator&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef time_base::dateorder
dateorder;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef InputIterator iter_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT,
<u>InputIterator InputIter</u> = istreambuf_iterator&lt;charT&gt;
&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class time_get_byname : public
time_get&lt;charT, InputIter&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef time_base::dateorder
dateorder;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef <u>InputIter</u>
iter_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">22.2.6.1
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT,
<p lang="en-GB" align="left" style="margin-bottom: 0in">class InputIterator =
istreambuf_iterator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class money_get : public locale::facet
{
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef InputIterator iter_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT,
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>InputIterator InputIter</u> =
istreambuf_iterator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class money_get : public locale::facet
{
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef <u>InputIter</u>
iter_type;
<p lang="en-GB" align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 53
<td>
<p lang="en-GB" align="left">22.2.5.3 , 22.2.5.4
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">OutputIterator does not use
concept.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">22.2.5.3
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class
OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class time_put : public locale::facet
{
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef OutputIterator iter_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in"><span lang=
"zxx">&#12288;</span>should be
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT,
<u>OutputIterator OutputIter</u> = ostreambuf_iterator&lt;charT&gt;
&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class time_put : public locale::facet
{
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef <u>OutputIter</u>
iter_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">22.2.5.4
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class
OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class time_put_byname : public
time_put&lt;charT, OutputIterator&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef OutputIterator iter_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT,
<u>OutputIterator OutputIter</u> = ostreambuf_iterator&lt;charT&gt;
&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class time_put_byname : public
time_put&lt;charT, OutputIter&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left">typedef <u>OutputIter</u> iter_type;
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 54
<td>
<p lang="en-GB" align="left">23
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">2<sup>nd</sup><font size=
"2" style="font-size: 11pt"> paragraph, Table 79</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">There is not &lt;forward_list&gt; in
Table 79.
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add &lt;forward_list&gt; between
&lt;deque&gt; and &lt;list&gt;.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
221
<td>
<p align="justify">23
<td>
<p align="justify">Table
79
<td>
<p align="justify">Ed
<td>
<p align="left">The table is
missing the new &lt;forward_list&gt; header.
<td>
<p align="left" style="margin-bottom: 0in">Add &lt;forward_list&gt; to the table for sequence
containers. Alternative (technical) solution might be to merge
&lt;forward_list&gt; into &lt;list&gt;.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
222
<td>
<p align="justify">23
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It is not clear what purpose the Requirement
tables serve in the Containers clause. Are they the definition of a
library Container? Or simply a conventient shorthand to factor
common semantics into a single place, simplifying the description
of each subsequent container? This becomes an issue for
'containers' like array, which does not meet the
default-construct-to-empty requirement, or forward_list which does
not support the size operation. Are these components no longer
containers? Does that mean the remaining requirements don't apply?
Or are these contradictions that need fixing, despite being a clear
design decision?
<p align="left"><br>
<td>
<p align="left">Clarify all
the tables in 23.1 are there as a convenience for documentation,
rather than a strict set of requirements. Containers should be
allowed to relax specific requirements if they call attention to
them in their documentation. The introductory text for array should
be expanded to mention a default constructed array is not empty,
and forward_list introduction should mention it does not provide
the required size operation as it cannot be implemented
efficiently.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 55
<td>
<p lang="en-GB" align="left">23.1.1
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">3<sup>rd</sup><font size=
"2" style="font-size: 11pt"> paragraph, 4<sup>th</sup> line</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">It seems that &#8220;the
MinimalAllocator concep&#8221; is the typo of &#8220;the
MinimalAllocator concept&#8221;.
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Change to &#8230; models the MinimalAllocator
concep<font color=
"#339966">t</font><font size=
"2" style="font-size: 11pt">.</font>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
223
<td>
<p align="justify">23.1.1
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The library does not define the MinimalAllocator
or ScopedAllocator concepts, these were part of an earlier
Allocators proposal that was rejected.
<p align="left"><br>
<td>
<p align="left">Remove the
references to MinimalAllocator and ScopedAllocator, or add
definitions for these concepts to clause 20.7.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
224
<td>
<p align="justify">23.1.1
<td>
<p align="justify">8
<td>
<p align="justify">Te
<td>
<p align="left">This
paragraph implicitly requires all containers in clause 23 to
support allocators, which std::array does not.
<td>
<p align="left" style="margin-bottom: 0in">Add an 'unless otherwise specified' rider
somewhere in p8, or move the whole array container from clause 23
[containers] to clause 20 [utilies] to accompany bitset, pair and
tuple.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
225
<td>
<p align="justify">23.1.1
<td>
<p align="justify">Table
81
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Inconsistent words used to say the same thing.
Table 80 describes iterator/const_iterator typedef as returning an
"iterator type whose value type is T". Table 81 expresses the same
idea as an "iterator type pointing to T". Express identical ideas
with the same words to avoid accidentally introducing subtlety and
confusion
<p align="left"><br>
<td>
<p align="left">Change return
types for X::(const)_reverse_iterator to say "iterator type whose
value type is (const) T".
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
226
<td>
<p align="justify">23.1.1
<td>
<p align="justify">10
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">&lt;array&gt; must be added to this list. In
particular it doesn't satisfy: - no swap() function invalidates any
references, pointers, or iterators referring to the elements of the
containers being swapped. and probably doesn't satisfy: &#8212; no
swap() function throws an exception.
<p align="left"><br>
<td>
<p align="left">If
&lt;array&gt; remains a container, this will have to also reference
array, which will then have to say which of these points it
satisfies.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
227
<td>
<p align="justify">23.1.1
<td>
<p align="justify">Table
80
<td>
<p align="justify">Ed
<td>
<p align="left">The
post-condition for a = rv uses the word &#8220;construction&#8221;
when it means &#8220;assignment&#8221;
<td>
<p align="left" style="margin-bottom: 0in">Replace the word &#8220;construction&#8221; with
the word &#8220;assignment&#8221;
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
228
<td>
<p align="justify">23.1.1
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Line 4 contains a spelling mistake in the fragment
"MinimalAllocator concep."
<p align="left"><br>
<td>
<p align="left">Replace
"concep" with "concept"
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
229
<td>
<p align="justify">23.1.1
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left">The fragment
"A container may directly call constructors" is not technically
correct as constructors are not callable.
<td>
<p align="left" style="margin-bottom: 0in">Replace "A container may directly call
constructors and destructors for its stored objects" with something
similar to "A container may directly construct its stored objects
and call destructors for its stored objects"
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
230
<td>
<p align="justify">23.1.2
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">&#8220;implementations shall consider the following
functions to be const&#8221; - what does this mean? I don't
understand what it means by implementations considering the
functions to be const &#8211; surely they are either declared const
or not?
<p align="left"><br>
<td>
<p align="left">Clarify what
is meant and what requirements an implementation must
satisfy.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 56
<td>
<p lang="en-GB" align="left">23.1.3
<td>
<p lang="en-GB" align="left">12<sup>th</sup><font size="2" style=
"font-size: 11pt"> paragraph, Table 84</font>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">`array&#8217; is unstated in Table 84 -
Optional sequence container operations.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add `array&#8217; to Container field for
the following Expression.
<p lang="en-GB" align="left" style=
"text-indent: 0.15in; margin-bottom: 0in">a.front()
<p lang="en-GB" align="left" style=
"text-indent: 0.15in; margin-bottom: 0in">a.back()
<p lang="en-GB" align="left" style=
"text-indent: 0.15in; margin-bottom: 0in">a[n]
<p lang="en-GB" align="left" style=
"text-indent: 0.15in; margin-top: 0.04in">a.at(n)
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
231
<td>
<p align="justify">23.1.3
<td>
<p align="justify">9-11
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">These paragraphs are redundant now that Concepts
define what it means to be an Iterator and guide overload
resolution accordingly.
<p align="left"><br>
<td>
<p align="left">Strike
23.1.3p9-11. Make sure std::basic_string has constraints similar to
std::vector to meet this old guarantee.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
232
<td>
<p align="justify">23.1.3
<td>
<p align="justify">Table
84
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">match_results may follow the requirements but is
not listed a general purpose library container.
<p align="left"><br>
<td>
<p align="left">Remove
reference to match_results against a[n] operation
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
233
<td>
<p align="justify">23.1.3
<td>
<p align="justify">Table
84
<td>
<p align="justify">Te
<td>
<p align="left">Add
references to the new containers.
<td>
<p align="left" style="margin-bottom: 0in">Add reference to array to the rows for: a.front(),
a. back(), a[n] a.at(n). Add reference to forward_list to the rows
for: a.front(), a.emplace_front(args), a.push_front(t),
a.push_front(rv), a.pop_front(). Add reference to basic_string to
the row for: a.at(n).
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
234
<td>
<p align="justify">23.1.3
<td>
<p align="justify">Table
84
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Ther reference to iterator in semantics for back
should also allow for const_iterator when called on a
const-qualified container. This would be ugly to specify in the 03
standard, but is quite easy with the addition of auto in this new
standard.
<p align="left"><br>
<td>
<p align="left">Replace
iterator with auto in semantics for back: { auto tmp = a.end();
--tmp; return *tmp; }
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
235
<td>
<p align="justify">23.1.3
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left">&#8220;The
library provides three basic kinds of sequence containers: vector,
list, and deque&#8221; - text appears to be out of date re addition
of array and forward_list
<td>
<p align="left" style="margin-bottom: 0in">Change the text to read: &#8220;The library
provides five basic kinds of sequence containers: array, deque,
forward_list, list and vector&#8221;.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
236
<td>
<p align="justify">23.1.3
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">[ I've moved (1) into a separate comment because I
believe it is editorial in the simple sense, whereas (2) and (3)
are not so straight forward ] (2) &#8220;vector is the type of
sequence container that should be used by default&#8221; -- As I
understand it vector was considered first port of call because the
things it has in common with the native array make programmers
(especially those new to the container library) feel like they are
on familiar territory. However, we now have the array container, so
I think this should be recommended as the first port of call. (3)
This paragraph is actually giving guidance on the use of the
containers and should not be normative text
<p align="left"><br>
<td>
<p align="left">Remove this
paragraph
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
237
<td>
<p align="justify">23.1.3
<td>
<p align="justify">2
<td>
<p align="justify">Ed
<td>
<p align="left">vector, list,
and deque offer the programmer different complexity trade-offs and
should be used accordingly - this ignores array and
forward_list
<td>
<p align="left" style="margin-bottom: 0in">Modify the text to read: "array, deque,
forward_list, list and vector offer the programmer different
complexity trade-offs and should be used accordingly"
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
238
<td>
<p align="justify">23.1.4
<td>
<p align="justify">6
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Leaving it unspecified whether or not iterator and
const_iterator are the same type is dangerous, as user code may or
may not violate the One Definition Rule by providing overloads for
both types. It is probably too late to specify a single behaviour,
but implementors should document what to expect. Observing that
problems can be avoided by users restricting themselves to using
const_iterator, add a note to that effect.
<p align="left"><br>
<td>
<p align="left">Change
'unspecified' to 'implementation defined'. Add "[Note: As
itererator and const_iterator have identical semantics in this
case, and iterator is convertible to const_iterator, users can
avoid violating the One Definition Rule by always using
const_iterator in their function parameter lists -- end
note]
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
239
<td>
<p align="justify">23.1.4
<td>
<p align="justify">85
<td>
<p align="justify">Te
<td>
<p align="left">It is not
possible to take a move-only key out of an unordered container,
such as (multi)set or (multi)map, or the new hashed
containers.
<td>
<p align="left" style="margin-bottom: 0in">Add below a.erase(q), a.extract(q), with the
following notation: a.extract(q), Return type pair&lt;key,
iterator&gt; Extracts the element pointed to by q and erases it
from the set. Returns a pair containing the value pointed to by q
and an iterator pointing to the element immediately following q
prior to the element being erased. If no such element
exists,returns a.end().
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
240
<td>
<p align="justify">23.1.6.1
<td>
<p align="justify">12
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The axiom EmplacePushEquivalence should be
asserting the stronger contract that emplace and insert return the
same iterator value, not just iterators that dereference to the
same value. This is a similar statement that is easier to express
and should be equivalent - the idea that insert and emplace might
return iterator values that do not compare equal but point to the
same element should fail somewhere in the iterator concepts. Also,
this axiom should be renamed to reflect its connection with insert,
rather than push_front/push_back,
<p align="left"><br>
<td>
<p align="left">Remove the *
to deference the returned iterator either side of the == in the
EmplacePushEquivalence axiom, rename the axiom
EmplacementInsertionEquivalence : requires
InsertionContainer&lt;C&gt; &amp;&amp; Constructible&lt;value_type,
Args...&gt; axiom EmplacementInsertionEquivalence(C c,
const_iterator position, Args... args) { emplace(c, position,
args...) == insert(c, position, value_type(args...)); }
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 57
<td>
<p lang="en-GB" align="left">23.1.6.3
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">1<sup>st</sup><font size=
"2" style="font-size: 11pt"> paragraph, 4<sup>th</sup> line</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo, duplicated "to"
<p lang="en-GB" align="left" style="margin-top: 0.04in">"<u>to to</u> model insertion container
concepts."
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Remove one.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
241
<td>
<p align="justify">23.2.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">std::array does not have an allocator, so need to
document an exception to the requirements of 23.1.1p3
<p align="left"><br>
<td>
<p align="left">add exception
to 23.1.1p3
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
242
<td>
<p align="justify">23.2.1
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left">std::
qualification no longer needed for reverse_iterator.
<td>
<p align="left" style="margin-bottom: 0in">remove std:: qualification from
std::reverse_iterator&lt;iterator&gt; and
std::reverse_iterator&lt;const_iterator&gt;
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
243
<td>
<p align="justify">23.2.1
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Most containers, and types in general have 3
swaps: swap(T&amp;, T&amp;) swap(T&amp;&amp;, T&amp;) swap(T&amp;,
T&amp;&amp;) But array only has swap(T&amp;, T&amp;).
<p align="left"><br>
<td>
<p align="left">add the other
two swaps.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
244
<td>
<p align="justify">23.2.1,
23.2.6
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The validity of the expression &amp;a[n] ==
&amp;a[0] + n is contingent on operator&amp; doing the &#8220;right
thing&#8221; (as captured by the CopyConstructible requirements in
table 30 in C++2003). However this constraint has been lost in the
Concepts of C++0x. This applies to vector and array (it actually
applies to string also, but that's a different chapter, so I'll
file a separate comment there and cross-reference).
<p align="left"><br>
<td>
<p align="left">Define a
ContiguousStrorage and apply it to vector,array and string. The
Concept (supplied by Alisdair M) looks like this: Concept&lt;
typename C &gt; ContiguousStrorage { requires Container&lt;C&gt;;
typename value_type = C::value_type; value_type * data( C ); axiom
Contiguous { C c; true = equal_ranges( data( c), data(c) + size(c),
begin(c)); } };
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
245
<td>
<p align="justify">23.2.3
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left">The predicate
types used in special member function of forward_list should be
CopyConstructible, as per the algorithms of the same name. Note: an
alternate solution would be to require these callable concepts to
be CopyConstructible in clause 20, which would simplify the library
specification in general. See earlier comment for details, that
would render this one redundant.
<td>
<p align="left" style="margin-bottom: 0in">Add CopyConstructible requirement to the following
signatures: template &lt;Predicate&lt;auto, T&gt; Pred&gt; requires
CopyConstructible&lt;Pred&gt; void remove_if(Pred pred); template
&lt;EquivalenceRelation&lt;auto, T&gt; BinaryPredicate&gt; requires
CopyConstructible&lt;BinaryPredicate&gt; void
unique(BinaryPredicate binary_pred); template
&lt;StrictWeakOrder&lt;auto, T&gt; Compare&gt; requires
CopyConstructible&lt;Compare&gt; void
merge(forward_list&lt;T,Alloc&gt;&amp;&amp; x, Compare comp);
template &lt;StrictWeakOrder&lt;auto, T&gt; Compare&gt; requires
CopyConstructible&lt;Compare&gt; void sort(Compare comp);
<p align="left" style="margin-bottom: 0in"><br>
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 58
<td>
<p lang="en-GB" align="left">23.2.3.2
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">1<sup>st</sup><font size=
"2" style="font-size: 11pt"> line before 1<sup>st</sup> paragraph</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Unnecessary "{" exists before a word
iterator like "{iterator before_begin()".
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Remove "{"
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 59
<td>
<p lang="en-GB" align="left">23.2.4.4
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Types of the third and forth parameter
of splice() are iterator at 23.2.4.4, though types of them are
const_iterator at 23.2.4. (They are both const_iterator on
N2350)
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">void splice(const_iterator position,
list&lt;T,Allocator&gt;&amp;&amp; x, iterator i);
<p lang="en-GB" align="left" style="margin-bottom: 0in">void splice(const_iterator position,
list&lt;T,Allocator&gt;&amp;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">iterator first, iterator last);
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">void splice(const_iterator position,
list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
<p lang="en-GB" align="left" style="margin-bottom: 0in">void splice(const_iterator position,
list&lt;T,Allocator&gt;&amp;&amp; x,
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">const_iterator first, const_iterator last);
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 83
<td>
<p lang="en-GB" align="left">23.2.6.2
<td>
<p lang="en-GB" align="left">7
<td>
<p lang="en-GB" align="left">ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">"shrink_to_fint" should be
"shrink_to_fit".
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
246
<td>
<p align="justify">23.3.2.2
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The content of this sub-clause is purely trying to
describe in words the effect of the requires clauses on these
operations, now that we have Concepts. As such, the desctiption is
more confusing than the signature itself. The semantic for these
functions is adequately covered in the requirements tables in
23.1.4.
<p align="left"><br>
<td>
<p align="left">Strike
23.3.2.2 entirely. (but do NOT strike these signatures from the
class template definition!)
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
247
<td>
<p align="justify">24.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Ge
<td>
<p align="left" style="margin-bottom: 0in">Iterator concepts are not extensive enough to
merit a whole new header, and should be merged into
&lt;concpts&gt;. This is particularly important for supporting the
new for loop syntax which requires access to the Range concept. The
required header to enable this syntax shoud have a simple name,
like &lt;concepts&gt;, rather than something awkward to type like
&lt;iterator_concepts&gt;.
<p align="left"><br>
<td>
<p align="left">Move the
concepts of &lt;iterator_concepts&gt; into the &lt;concepts&gt;
header. We take no position on moving the text from Clause 24 to
Clause 20 though.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
248
<td>
<p align="justify">24.1
<td>
<p align="justify">6
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The text "so for any iterator type there is an
iterator value that points past the last element of a corresponding
container" is slightly misleading. Iterators can refer into
generalised ranges and sequences, not just containers. A broader
term than 'container' should be used.
<p align="left"><br>
<td>
<p align="left">Replace the
reference to container with a more appropriate concept
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
250
<td>
<p align="justify">24.1.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">A default
implementation should be supplied for the post-increment operator
to simplify implementation of iterators by users.
<td>
<p align="left">Copy the
Effects clause into the concept description as the default
implementation. Assumes a default value for
postincrement_result
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
251
<td>
<p align="justify">24.1.1
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The post-increment operator is dangerous for a
general InputIterator. The multi-pass guarantees that make it
meaningful are defined as part of the ForwardIterator refinement.
Any change will affect only constrained templates that have not yet
been written, so should not break existing user iterators which
remain free to add these operations. This change will also affect
the generalised OutputIterator, although there is no percieved need
for the post-increment operator in this case either.
<p align="left"><br>
<td>
<p align="left">Move
declaration of postincrement operator and postincrement_result type
from Interator concept to the ForwardIterator concept
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK<br>
252
<p><br>
<td>
<p align="justify">24.1.2
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left">istream_iterator is not a class, but a class
template
<td>
<p align="left">Change
'class' to 'class template' in the note.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
253
<td>
<p align="justify">24.1.3
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">First sentance does not make gramatical sense,
Seems to be missing the words 'if it' by comparison with similar
sentance in other subsections
<p align="left"><br>
<td>
<p align="left">Add the words
'if it' : "X satisfies the requirements of an output iterator IF IT
meets the syntactic and semantic requirements"
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
254
<td>
<p align="justify">24.1.3
<td>
<p align="justify">5
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">This postcondition for pre-increment operator
should be written as an axiom
<p align="left"><br>
<td>
<p align="left">Move the
postcondition into the concept definition as an axiom
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
255
<td>
<p align="justify">24.1.4
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">This postcondition for pre-increment operator
should be written as an axiom
<p align="left"><br>
<td>
<p align="left">Move the
postcondition into the concept definition as an axiom
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
256
<td>
<p align="justify">24.1.5
<td>
<p align="justify">3, 4,
5
<td>
<p align="justify">Te
<td>
<p align="left">The
relationship between pre- and post- decrement should be expressed
as an axiom.
<td>
<p align="left" style="margin-bottom: 0in">Move the text specification of pre/post-conditions
and behaviour into an axiom within the BidirectionalIterator
concept
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
257
<td>
<p align="justify">24.1.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">There is a reasonable default for
postdecrement_result type, which is X. X is required to be regular,
therefore CopyConstructible and a valid ResultType. Together with
the next comment this simplifies user defined iterator
implentations
<p align="left"><br>
<td>
<p align="left">Add the
default : typename postincrement_result = X;
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
258
<td>
<p align="justify">24.1.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">A default implementation should be supplied for
the post-decrement operator to simplify implementation of iterators
by users.
<p align="left"><br>
<td>
<p align="left">Copy the
Effects clause into the concept description as the default
implementation. Assumes a default value for
postincrement_result
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
259
<td>
<p align="justify">24.1.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">postdecrement_result is effectively returning a
copy of the original iterator value, so should have similar
constraints, rather than just HasDereference. If Concepts do not
support this circularity of definition suggest that concepts
feature may want a little more work
<p align="left"><br>
<td>
<p align="left">Add the
requirement: requires Iterator&lt; postdecrement_result
&gt;;
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
260
<td>
<p align="justify">24.1.5
<td>
<p align="justify">6
<td>
<p align="justify">Te
<td>
<p align="left">The effects
clause for post-decrement iterator should be available as an axiom
and a default implementation, where the compiler can make better
use of it.
<td>
<p align="left" style="margin-bottom: 0in">Move the Effects clause into the
BidirectionalIterator concept definition as an axiom, and as the
default implementation for the operation.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
249
<td>
<p lang="en-GB" align="justify"><span lang="en-US">24.1.6</span>
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The semantic for operator+= should also be
provided as a default implementation to simplify implementation of
user-defined iterators
<p align="left"><br>
<td>
<p align="left">Copy the text
from the effects clause into the RandomAccessIterator concept as
the default implementaiton.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
261
<td>
<p align="justify">24.1.6
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">To simplify user defined random access iterator
types, the subscript_reference type should default to
reference
<p align="left"><br>
<td>
<p align="left">typename
subscript_reference = reference;
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
262
<td>
<p align="justify">24.1.6
<td>
<p align="justify">3,
4
<td>
<p align="justify">Te
<td>
<p align="left">Effects and
post-conditions for operator+ are more useful if expressed as
axioms, and supplied as default implementations.
<td>
<p align="left" style="margin-bottom: 0in">Move the effects and Postcondition definitions
into the RandomAccessIterator concept and copy the code in the
specification as the default implementation of these
operations.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
263
<td>
<p align="justify">24.1.6
<td>
<p align="justify">5
<td>
<p align="justify">Te
<td>
<p align="left">This
requirement on operator-= would be better expressed as a default
implementation in the concept, with a matching axiom
<td>
<p align="left" style="margin-bottom: 0in">Move the specification for operator-= from the
returns clause into an axiom and default implementation within the
RandomAccessIterator concept
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
264
<td>
<p align="justify">24.1.6
<td>
<p align="justify">6
<td>
<p align="justify">Te
<td>
<p align="left">Effects
clauses are better expressed as axioms where possible.
<td>
<p align="left" style="margin-bottom: 0in">Move code in operator- effects clause into
RandomAccessIterator concept as both a default implementation and
an axiom
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
265
<td>
<p align="justify">24.1.6
<td>
<p align="justify">8
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">This effects clause is nonesense. It looks more
like an axiom stating equivalence, and certainly an effects clause
cannot change the state of two arguments passed by const
reference
<p align="left"><br>
<td>
<p align="left">Strike the
Effects clause
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
266
<td>
<p align="justify">24.1.6
<td>
<p align="justify">9
<td>
<p align="justify">Te
<td>
<p align="left">This sentance
should be provided as a default definition, along with a matching
axiom
<td>
<p align="left" style="margin-bottom: 0in">Move the Returns clause into the spefication for
RandomAccessIterator operator- as a default implementation. Move
the Effects clause as the matching axiom.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
267
<td>
<p align="justify">24.1.6
<td>
<p align="justify">24.1.6
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The code in the Requires clause for
RandomAccessIterator operator[] would be better expressed as an
axiom.
<p align="left"><br>
<td>
<p align="left">Rewrite the
Requires clause as an axiom in the RandomAccessIterator
concept
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
268
<td>
<p align="justify">24.1.6
<td>
<p align="justify">12
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">This note is potentialy confusing as __far enters
the syntax as a clear language extension, but the note treats it as
a regular part of the grammar. It might be better expressed using
attributes in the current wording.
<p align="left"><br>
<td>
<p align="left">Clean up the
note to either avoid using language extension, or spell out this is
a constraint to support extensions.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 60
<td>
<p lang="en-GB" align="left">24.1.8
<td>
<p lang="en-GB" align="left">1<sup>st</sup><font size="2" style=
"font-size: 11pt"> paragraph</font>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Capability of an iterator is too much
restricted by concept.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Concept of std::Range is defined
as:
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">concept Range&lt;typename T&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">InputIterator iterator;
<p lang="en-GB" align="left" style="margin-bottom: 0in">iterator begin(T&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">iterator end(T&amp;);
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">So the following code generates an
error.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;std::Range Rng&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void sort(Rng&amp; r)
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style=
"margin-left: 0.08in; text-indent: -0.08in; margin-bottom: 0in">
// error! Rng::iterator does
not satisfy requirements of a random
<p lang="en-GB" align="left" style=
"margin-left: 0.07in; text-indent: 0.08in; margin-bottom: 0in">
// access iterator.
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::sort(begin(r), end(r));
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::vector&lt;int&gt; v; //
vector::iterator is a random access iterator.
<p lang="en-GB" align="left" style="margin-bottom: 0in">sort(v);
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">This is because the concept of an
iterator of std::Range is InputIterator. For this reason, a random
access iterator loses its capability when passed to a std::Range
parameter.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">To be able to work the above code, we
need to write as follows:
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;std::Range T&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">requires
std::RandomAccessIterator&lt;T::iterator&gt; &amp;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::ShuffleIterator&lt;T::iterator&gt;
&amp;&amp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::LessThanComparable&lt;T::iterator::value_type&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void sort(T&amp; r)
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">sort(begin(r), end(r));
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::vector&lt;int&gt; v;
<p lang="en-GB" align="left" style="margin-bottom: 0in">sort(v);
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">It needs quiet a few amount of codes
like this only to recover random access capability from
InputIterator concept.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">We can write the following valid code
with Boost.Range, which is implemented with using C++03
SFINAE.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class Range&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void sort(Range&amp; r)
<p lang="en-GB" align="left" style="margin-bottom: 0in">{
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::sort(boost::begin(r),
boost::end(r));
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">std::vector&lt;int&gt; v;
<p lang="en-GB" align="left" style="margin-bottom: 0in">sort(v); // OK
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">One of the motivation to introduce concepts are
supporting template programming techniques by language directly to
eliminate hacky techniques such as tag-dispatch, SFINAE and Type
Traints. But SFINAE will be kept using because it needs quite a few
amount of codes without using SFAINAE.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add InputRange, OutputRange,
ForwardRange, BidirectionalRange and RandomAccessRange.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
269
<td>
<p align="justify">24.3
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">'decrements for negative n' seems to imply a
negative number of decrement operations, which is odd.
<p align="left"><br>
<td>
<p align="left">Need simple,
clearer wording
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
270
<td>
<p align="justify">24.3
<td>
<p align="justify">4
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The reachability constraint in p5 means that a
negavite result, implying decrements operations in p4, is not
possible
<p align="left"><br>
<td>
<p align="left">Split the two
overloads into separate descriptions, where reachability is
permitted to be in either direction for RandomAccessIterator
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
271
<td>
<p align="justify">24.3
<td>
<p align="justify">6,7
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">next/prev return an incremented iterator without
changing the value of the original iterator. However, even this may
invalidate an InputIterator. A ForwardIterator is required to
guarantee the 'multipass' property.
<p align="left"><br>
<td>
<p align="left">Replace
InputIterator constraint with FOrwardIterator in next and prev
function templates.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
272
<td>
<p align="justify">24.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">reverse_iterator and move_iterator use different
formulations for their comparison operations. move_iterator merely
requires the minimal set of operations, &lt; and ==, from its
underlying iterator and synthesizes all oprations from these two.
reverse_iterator relies on the undelying iterator to support all
comparision operations directly. In practice, move_iterator can
only be implemented this way as it must support iterator types that
are merely InputIterators, and so SemiRegular and not Regular.
However, reserse_iterator has an existing specification and any
change of semantic could change behaviour of conforming programs
today - although an iterator that yields different results for (a
&gt; b) than (b &lt; a) may fall foul of some semantic consistency
requirements, even if the syntax is met.
<p align="left"><br>
<td>
<p align="left">Rephrase the
reverse_iterator comparison operations using only operators &lt;
and ==, as per the move_iterator specification.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
274
<td>
<p align="justify">24.4,
24.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The subclauses for standard iterator adaptors
could be better organised. There are essentially 3 kinds of
iterator wrappers provided, stream iterators adapt streams and get
their own subsection. insert iterators adapt containers, and get
their own subsection but it is inserted into the middle of 24.4
Predifined iterators. reverse_iterator and move_iterator adpat
other iterators, but their presentation is split by insert
iterators
<p align="left"><br>
<td>
<p align="left">Promote
24.4.2 [insert.iterators] up one level to 24.6. Emphasize that
insert iterators adapt containers Retarget 24.4 [predef.iterators]
as iterator adapters for iterator templates that wrap other
iterators.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
275
<td>
<p align="justify">24.4.1.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The constructor template taking a single Iterator
argument will be selected for Copy Initialization instead of the
non-template constructor taking a single Iterator argument selected
by Direct Initialization.
<p align="left"><br>
<td>
<p align="left">The
reverse_iterator template constructor taking a single Iterator
argument should be explicit.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
276
<td>
<p align="justify">24.4.1.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">It is odd to have a mix of declaration stlyes for
operator+ overloads. Prefer if either all are member functions, or
all are 'free' functions.
<p align="left"><br>
<td>
<p align="left">Make the
member operators taking a difference_type argument non-member
operators
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
277
<td>
<p align="justify">24.4.1.2.1
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The default constructor default-initializes
current, rather than value-initializes. This means that when
Iterator corresponds to a trivial type, the current member is left
un-initialized, even when the user explictly requests value
intialization! At this point, it is not safe to perform any
operations on the reverse_iterator other than assign it a new value
or destroy it. Note that this does correspond to the basic
definition of a singular iterator.
<p align="left"><br>
<td>
<p align="left">i/ Specify
value initialization rather than default intialization or ii/
specify = default; rather than spell out the semantic. This will at
least allow users to select value initialization and copy the
iterator value. or iii/ Add a note to the description emphasizing
the singular nature of a value-initialized reserve iterator.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
278
<td>
<p align="justify">24.4.1.2.1
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">There is an inconsistency between the constructor
taking an iterator and the constructor template taking a
reverse_iterator where one passes by value, and the other by const
reference. The by-value form is preferred as it allows for
efficient moving when copy elision fails to kick in.
<p align="left"><br>
<td>
<p align="left">Change the
const reverse_iterator&lt;U&gt; &amp; parameter to
pass-by-value
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
279
<td>
<p align="justify">24.4.1.2.12, 24.4.3.2.12
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The reason the return type became unspecified is
LWG issue 386. This reasoning no longer applies as there are at
least two ways to get the right return type with the new language
facilities added since the previous standard.
<p align="left"><br>
<td>
<p align="left">Specify the
return type using either decltype or the Iter concept map
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
280
<td>
<p align="justify">24.4.1.2.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The presence of the second iterator value is
surprising for many readers who underestimate the size of a
reverse_iterator object. Adding the exposition only member that is
required by the semantic will reduce confusion.
<p align="left"><br>
<td>
<p align="left">Add
reverse_iterator expsoition only member tmp as a comment to class
declaration, as a private member
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
281
<td>
<p align="justify">24.4.1.2.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The current specification for return value will
always be a true pointer type, but reverse_iterator supports proxy
iterators where the pointer type may be some kind of 'smart
pointer'
<p align="left"><br>
<td>
<p align="left">Replace the
existing returns specification with a copy of the operator*
specification that returns this-&gt;tmp.operator-&gt;
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
282
<td>
<p align="justify">24.4.2.1,
24.4.2.2.2, 24.4.2.3, 24.4.2.4.2, 24.4.2.5, 24.4.2.6.2
<td>
<p align="justify">n/a
<td>
<p align="justify">Te
<td>
<p align="left">Insert
iterators of move-only types will move from lvalues
<td>
<p align="left">Add an
additional constrained overload for operator= that requires
!CopyConstructible&lt;Cont::value_type&gt; and mark it
=delete.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
283
<td>
<p align="justify">24.4.2.5,
24.4.2.6.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">postincrement
operator overloads traditionally return by value - insert_iterator
is declared as return by reference. The change is harmless in this
case, but either front/back_insert_iterator should take the
matching change for consistency, or this function should
return-by-value
<td>
<p align="left">change
operator++(int) overload to return by value, not reference. Affects
both class summary and operator definition in p
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 61
<td>
<p lang="en-GB" align="left">24.4.3.2.1
<td>
<p lang="en-GB" align="left">2<sup>nd</sup><font size="2" style=
"font-size: 11pt"> paragraph, 1<sup>st</sup> line</font>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo.
<p lang="en-GB" align="left" style="margin-top: 0.04in">"intializing" should be
"in<u>i</u>tializing"
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add "i"
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
284
<td>
<p align="justify">24.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The stream iterators need constraining with
concepts/requrires clauses.
<p align="left"><br>
<td>
<p align="left">Provide
constraints
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
285
<td>
<p align="justify">24.5.1
<td>
<p align="justify">1,2
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Much of the content of p1 and the whole of p2 is a
redundant redefinition of InputIterator. It should be
simplified
<p align="left"><br>
<td>
<p align="left">Strike p2.
Simplify p1 and add a cross-reference to the definition of
InputIterator concept.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
286
<td>
<p align="justify">24.5.1
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">To the casual reader it is not clear if it is
intended to be able to assign to istream_iterator objects.
Specifying the copy constructor but relying on the implicit
copy-assign operator is confusing.
<p align="left"><br>
<td>
<p align="left">Either
provide a similar definition to the copy-assign operator as for the
copy constructor, or strike the copy constructor
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
287
<td>
<p align="justify">24.5.1.1
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It is not clear what the intial state of an
istream_iterator should be. Is _value_ initialized by reading the
stream, or default/value initialized? If it is initialized by
reading the stream, what happens if the initialization is deferred
until first dereference, when ideally the iterator value should
have been that of an end-of-stream iterator which is not safely
dereferencable?
<p align="left"><br>
<td>
<p align="left">Specify
_value_ is initialized by reading the stream, or the iterator takes
on the end-of-stream value if the stream is empty
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
288
<td>
<p align="justify">24.5.1.1
<td>
<p align="justify">3
<td>
<p align="justify">Ed
<td>
<p align="left">The provided
specification is vacuous, offering no useful information.
<td>
<p align="left" style="margin-bottom: 0in">Either strike the specification of the copy
constructor, or simply replace it with an = default
definition.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
289
<td>
<p align="justify">24.5.1.2
<td>
<p align="justify">6
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">It is very hard to pick up the correct
specification for istream_iterator::operator== as the complete
specification requires reading two quite disconnected paragraphs,
24.5.1p3, and 24.5.1.2p6. Reading just the specifaction of the
operation itself suggests that end-of-stream iterators are
indistinguishable from 'valid' stream iterators, which is a very
dangerous misreading.
<p align="left"><br>
<td>
<p align="left">Merge
24.5.1p3, equality comparison of end-of-stream-iterators, into
24.5.1.2p6, the specification of the equality operator for
istream_iterator.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
290
<td>
<p align="justify">24.5.2
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The character type of a string delimiter for an
ostream_iterator should be const charT *, the type of the elements,
not char *, a narrow character string.
<p align="left"><br>
<td>
<p align="left">Replace char
* with const charT *
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
291
<td>
<p align="justify">24.5.2.2
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">ostream_iterator postincrement operator returns by
reference rather than by value. This may be a small efficiency
gain, but it is otherwise unconventional. Prefer
return-by-value.
<p align="left"><br>
<td>
<p align="left">ostream_iterator operator++(int);
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 34
<td>
<p>24.5.3 [istreambuf.iterator]
<td>
<p><br>
<td>
<p>ed
<td>
<p style="margin-bottom: 0in">There are two public sections, and the
content of the second one is indented with respect to the first. I
don't it should be.
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
292
<td>
<p align="justify">24.5.3
<td>
<p align="justify">1
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Prefer the use of the new nullptr constant to the
zero literal when using a null pointer in text.
<p align="left"><br>
<td>
<p align="left">Change
istreambuf_iterator(0) to istreambuf_iterator(nullptr)
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
293
<td>
<p align="justify">24.5.3
<td>
<p align="justify">2,3,4
<td>
<p align="justify">Ed
<td>
<p align="left">The listed
paragraphs redundantly redefine an input iterator, and redundancy
can be a dangerous thing in a specification. Suggest a simpler
phrasing below.
<td>
<p align="left" style="margin-bottom: 0in">2. The result of operator*() on an end of stream
is undefined. For any other iterator value a char_type value is
returned. 3. Two end of stream iterators are always equal. An end
of stream iterator is not equal to a non-end of stream iterator. 4.
As istreambuf_iterator() is an InputIterator but not a
ForwardIterator, istreambuf_iterators object can be used only for
one-pass algorithms. It is not possible to assign a character via
an input iterator.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
294
<td>
<p align="justify">24.5.3.2
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left">Implicit
converting constructors can be invoked at surprising times, so
there should always be a good reason for declaring one.
<td>
<p align="left" style="margin-bottom: 0in">Mark the two single-argument constructors take a
stream or stream buffer as explicit. The proxy constructor should
remain implicit. explicit
istreambuf_iterator(basic_istream&lt;charT,traits&gt;&amp; s)
throw(); explicit
istreambuf_iterator(basic_streambuf&lt;charT,traits&gt;* s)
throw();
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
295
<td>
<p align="justify">25
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">THere is a level of redundancy in the library
specification for many algorithms that can be eliminated with the
combination of concepts and default parameters for function
templates. Eliminating redundancy simplified specification and
reduces the risk of inttroducing accidental inconsistencies.
<p align="left"><br>
<td>
<p align="left">Adopt n2743,
or an update of that paper.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 62
<td>
<p lang="en-GB" align="left">25, 25.3.1.5, 26.3.6.5
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-left: 0.2in; text-indent: -0.2in; margin-bottom: 0in">
The return types of
is_sorted_until function and is_heap_until function are iterator.
But basically, the return type of is_xxx function is bool. And the
return type of lower_bound function and upper_bound is
iterator.
<p lang="en-GB" align="left" style=
"text-indent: 0.2in; margin-top: 0.04in; margin-bottom: 0.04in">
So we think that it is
reasonable to change those two functions.
<p lang="en-GB" align="left" style=
"text-indent: 0.2in; margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Change "is_sorted_until" to
"sorted_bound"
<p lang="en-GB" align="left" style="margin-top: 0.04in">Change "is_heap" to "heap_bound"
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
296
<td>
<p align="justify">25.1.8
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The 'Returns' of adjacent_find requires only
HasEqualTo, or a Predicate. Requiring EqualityComparable or
EquivalenceRelation seems too strong and not useful.
<p align="left"><br>
<td>
<p align="left">Change
EqualityComparable to HasEqualTo and EquivalnceRelation to
Predicate
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
297
<td>
<p align="justify">25.2.11
<td>
<p align="justify">6
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The definition of rotate_copy is very complicated.
It is equivalent to: return copy(first, middle, copy(middle, last,
result));
<p align="left"><br>
<td>
<p align="left">Change
'effects' to, returns, requires, complexity to: effects: equivalent
to: return copy(first, middle, copy(middle, last, result));
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
298
<td>
<p align="justify">25.2.13
<td>
<p align="justify">13
<td>
<p align="justify">Te
<td>
<p align="left">partition_point requires a partitioned
array
<td>
<p align="left">requires:
is_partitioned(first, last, pred) != false;
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
299
<td>
<p align="justify">25.2.2
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">Should be
consistent in style use of concepts in template parameter lists.
The auto-OutputIterator sytle used in std::copy is probably
preferred.
<td>
<p align="left">Change way
signature is declared: template&lt;InputIterator InIter,
OutputIterator&lt;auto, RvalueOf&lt;InIter::reference&gt;::type&gt;
OutIter&gt; OutIter move(InIter first, InIter last, OutIter
result);
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
300
<td>
<p align="justify">25.2.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Since publishing the original standard, we have
learned that swap is a fundamental operation, and several common
idioms rely on it - especially those related to exception safety.
As such it belongs in the common &lt;utility&gt; header rather than
the broader &lt;algorithm&gt; header, and likewise should move to
clause 20. For backwards compatiblility the algorithm header should
be required to #include &lt;utility&gt;, which would be covered in
the resolution of LWG issue 343. There are already dependencies in
&lt;algorithm&gt; on types declared in this header, so this comment
does not create a new dependency.
<p align="left"><br>
<td>
<p align="left">Move primary
swap template from &lt;algorithm&gt; into &lt;utility&gt;. Move
25.2.3 to somewhere under 20.2. Require &lt;algorithm&gt; to
#include &lt;utility&gt; to access pair and provide legacy support
for finding swap.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
301
<td>
<p align="justify">25.2.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">replace and replace_if have the requirement:
OutputIterator&lt;Iter, Iter::reference&gt; Which implies they need
to copy some values in the range the algorithm is iterating over.
This is not however the case, the only thing that happens is const
T&amp;s might be copied over existing elements (hence the
OutputIterator&lt;Iter, const T&amp;&gt;
<p align="left"><br>
<td>
<p align="left">Remove
OutputIterator&lt;Iter, Iter::reference&gt; from replace and
replace_if
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
302
<td>
<p align="justify">25.3
<td>
<p align="justify">4
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">the concept StrictWeakOrder covers the definition
of a strict weak ordering, described in paragraph 4.
<p align="left"><br>
<td>
<p align="left">Remove 4, and
mention StrictWeakOrder in paragraph 1.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
303
<td>
<p align="justify">25.3
<td>
<p align="justify">6
<td>
<p align="justify">Ed
<td>
<p align="left">This
paragraph just describes is_partitioned
<td>
<p align="left" style="margin-bottom: 0in">6 A sequence [start,finish) is partitioned with
respect to an expression f(e) if is_partitioned(start, finish, e)
!= false
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
304
<td>
<p align="justify">25.3.6
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The requires clauses of push_heap, pop_heap and
make_heap are inconsistently formatted, dispite being
identical
<p align="left"><br>
<td>
<p align="left">Format them
identically.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
305
<td>
<p align="justify">25.3.7
<td>
<p align="justify">1, 9,
17
<td>
<p align="justify">Te
<td>
<p align="left">The negative
requirement on IsSameType is a hold-over from an earlier draught
with a variadic template form of min/max algorith. It is no longer
necessary.
<td>
<p align="left">Strike the
!IsSameType&lt;T, Compare&gt; constraint on min/max/minmax
algorithms
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 84
<td>
<p lang="en-GB" align="left">26
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">ge
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Parts of the numerics chapter are not
concept enabled.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 35
<td>
<p>26.3 [Complex numbers]
<td>
<p><br>
<td>
<p>te
<td>
<p style="margin-bottom: 0in">Instantiations of the class template
complex&lt;&gt; have to be allowed for integral types, to reflect
existing practice and ISO standards (LIA-III).
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
306
<td>
<p align="justify">26.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Random number library component cannot be used in
constrained templates
<p align="left"><br>
<td>
<p align="left">Provide
constraints for the random number library
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 63
<td>
<p lang="en-GB" align="left">26.4.8.5.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">No constructor of discrete_distribution
that accepts initializer_list.
<p lang="en-GB" align="left" style="margin-bottom: 0in">discrete_distribution initialize
distribution by a given range (iterators), but temporary variable
of a container or an array is needed in the following case.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">int ar[] = {1, 2, 3};
<p lang="en-GB" align="left" style="margin-bottom: 0in">discrete_distribution&lt;&gt; dist(ar,
ar+3);
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">Other libraries also accept initializer_list, so
change discrete_distribution library to accept initializer_list
too.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add the following constructer.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><u>discrete_distribution(initializer_list&lt;result_type&gt;);</u>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 64
<td>
<p lang="en-GB" align="left">26.5.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">&#8220;valarray&lt;T&gt;&amp; operator+=
(initializer_list&lt;T&gt;);&#8221; is not defined.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add valarray&lt;T&gt;&amp; operator+=
(initializer_list&lt;T&gt;);
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
307
<td>
<p align="justify">26.7
<td>
<p align="justify">Footnote
288
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">The footnote refers to TR1, which is not a defined
term in this standard. Drop the reference to TR1, those templates
are a regular part of the standard now and how they were introduced
is no longer relevant.
<p align="left"><br>
<td>
<p align="left">Drop the
reference to TR1.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 85
<td>
<p lang="en-GB" align="left">27
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">ge
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The input/output chapter is not concept
enabled.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
308
<td>
<p align="justify">27
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in"><span lang="en-US">iostreams library
cannot be used from constrained templates</span>
<p align="left"><br>
<td>
<p align="left">Provide
constraints for the iostreams library, clause 27
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 65
<td>
<p lang="en-GB" align="left">27.4.4
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">Switch from &#8220;unspecified-bool-type&#8221;
to<span lang=
"zxx">&#12288;&#8220;</span>explicit operator bool() const&#8221;.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Replace "operator
<i>unspecified-bool-type</i>() const;" with "explicit operator
bool() const;"
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 66
<td>
<p lang="en-GB" align="left">27.4.4.3
<td>
<p lang="en-GB" align="left">1<sup>st</sup><font size="2" style=
"font-size: 11pt"> paragraph</font>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">Switch from &#8220;unspecified-bool-type&#8221;
to<span lang=
"zxx">&#12288;&#8220;</span>explicit operator bool() const&#8221;
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Replace "operator
<i>unspecified-bool-type</i>() const;" with "explicit operator
bool() const;"
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 36
<td>
<p>27.6.1.2.2
[istream.formatted.arithmetic]
<td>
<p>1, 2, and 3
<td>
<p>ed
<td>
<p style="margin-bottom: 0in">iostate err = 0;
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">iostate is a bitmask type and so could be
an enumeration. Probably using
<p style="margin-bottom: 0in">goodbit is the solution.
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>FR 37
<td>
<p>27.6.1.2.2
[istream.formatted.arithmetic]
<td>
<p>3
<td>
<p>ed
<td>
<p style="margin-bottom: 0in">else if (lval &lt;
numeric_limits&lt;int&gt;::min()
<p style="margin-bottom: 0in">|| numeric_limits&lt;int&gt;::max() &lt;
lval))
<p style="margin-bottom: 0in"><br>
<p style="margin-bottom: 0in">The parentheses aren't balanced.
<p><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 67
<td>
<p lang="en-GB" align="left">27.7.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">basic_stringbuf dose not use
concept.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Replace &#8220;class Allocator&#8221; to
&#8220;Allocator Alloc&#8221;.
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp; Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits =
char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>Allocator Alloc</u> =
allocator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class basic_stringbuf : public
basic_streambuf&lt;charT,traits&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 27.7.1.1 Constructors:
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit
basic_stringbuf(ios_base::openmode which
<p lang="en-GB" align="left" style="margin-bottom: 0in">= ios_base::in | ios_base::out);
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit basic_stringbuf
<p lang="en-GB" align="left" style="margin-bottom: 0in">(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str,
<p lang="en-GB" align="left" style="margin-bottom: 0in">ios_base::openmode which = ios_base::in
| ios_base::out);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringbuf(basic_stringbuf&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 27.7.1.3 Get and set:
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;
str() const;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void str(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; s);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">};
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_stringbuf&lt;charT,
traits, <u>Alloc</u>&gt;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringbuf&lt;charT, traits,
<u>Alloc</u>&gt;&amp; y);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_stringbuf&lt;charT,
traits, <u>Alloc</u>&gt;&amp;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringbuf&lt;charT, traits,
<u>Alloc</u>&gt;&amp; y);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_stringbuf&lt;charT,
traits, <u>Alloc</u>&gt;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringbuf&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; y);
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">}
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 68
<td>
<p lang="en-GB" align="left">27.7.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">basic_istringstream dose not use
concept.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Replace &#8220;class Allocator&#8221; to
&#8220;Allocator Alloc&#8221;.
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp; Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits =
char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>Allocator Alloc</u> =
allocator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class basic_istringstream : public
basic_istream&lt;charT,traits&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename traits::int_type
int_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename traits::pos_type
pos_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename traits::off_type
off_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef traits traits_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef <u>Alloc</u>
allocator_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 27.7.2.1 Constructors:
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit
basic_istringstream(ios_base::openmode which =
ios_base::in);
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit basic_istringstream(
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str,
<p lang="en-GB" align="left" style="margin-bottom: 0in">ios_base::openmode which =
ios_base::in);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_istringstream(basic_istringstream&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 27.7.2.2 Assign and swap:
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_istringstream&amp;
operator=(basic_istringstream&amp;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_istringstream&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 27.7.2.3 Members:
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt;*
rdbuf() const;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;
str() const;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void str(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; s);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">private:
<p lang="en-GB" align="left" style="margin-bottom: 0in">//
basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt; sb; exposition
only
<p lang="en-GB" align="left" style="margin-bottom: 0in">};
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_istringstream&lt;charT,
traits, <u>Alloc</u>&gt;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_istringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; y);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_istringstream&lt;charT,
traits, <u>Alloc</u>&gt;&amp;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_istringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; y);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_istringstream&lt;charT,
traits, <u>Alloc</u>&gt;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_istringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; y);
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 69
<td>
<p lang="en-GB" align="left">27.7.3
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">basic_ostringstream dose not use
concept.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Replace &#8220;class Allocator&#8221; to
&#8220;Allocator Alloc&#8221;.
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp; Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits =
char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>Allocator Alloc</u> =
allocator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class basic_ostringstream : public
basic_ostream&lt;charT,traits&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">// types:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename traits::int_type
int_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename traits::pos_type
pos_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename traits::off_type
off_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef traits traits_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef <u>Alloc</u>
allocator_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 27.7.3.1
Constructors/destructor:
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit
basic_ostringstream(ios_base::openmode which =
ios_base::out);
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit basic_ostringstream(
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str,
<p lang="en-GB" align="left" style="margin-bottom: 0in">ios_base::openmode which =
ios_base::out);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_ostringstream(basic_ostringstream&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 27.7.3.2 Assign/swap:
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_ostringstream&amp;
operator=(basic_ostringstream&amp;&amp; rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_ostringstream&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 27.7.3.3 Members:
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt;*
rdbuf() const;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;
str() const;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void str(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; s);
<p lang="en-GB" align="left" style="margin-bottom: 0in">private:
<p lang="en-GB" align="left" style="margin-bottom: 0in">//
basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt; sb; exposition
only
<p lang="en-GB" align="left" style="margin-bottom: 0in">};
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator</u> <font size=
"2" style="font-size: 11pt"><u>Alloc</u>&gt;</font>
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_ostringstream&lt;charT,
traits, <u>Alloc</u>&gt;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_ostringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; y);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator</u> <font size=
"2" style="font-size: 11pt"><u>Alloc</u>&gt;</font>
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_ostringstream&lt;charT,
traits, <u>Alloc</u>&gt;&amp;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_ostringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; y);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_ostringstream&lt;charT,
traits, <u>Alloc</u>&gt;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_ostringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; y);
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">}
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 71
<td>
<p lang="en-GB" align="left">27.7.3
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo.
<p lang="en-GB" align="left">"template" is missing in "class
basic_ostringstream" of the title of the chapter.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">27.7.3 Class basic_ostringstream
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left">27.7.3 Class <u>template</u>
basic_ostringstream
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 72
<td>
<p lang="en-GB" align="left">27.7.4
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">basic_stringstream dose not use
concept.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Replace "class Allocator" to "Allocator
Alloc".
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp; Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits =
char_traits&lt;charT&gt;,
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>Allocator Alloc</u> =
allocator&lt;charT&gt; &gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">class basic_stringstream
<p lang="en-GB" align="left" style="margin-bottom: 0in">: public
basic_iostream&lt;charT,traits&gt; {
<p lang="en-GB" align="left" style="margin-bottom: 0in">public:
<p lang="en-GB" align="left" style="margin-bottom: 0in">// types:
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef charT char_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename traits::int_type
int_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename traits::pos_type
pos_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef typename traits::off_type
off_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef traits traits_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">typedef <u>Alloc</u>
allocator_type;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// constructors/destructor
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit basic_stringstream(
<p lang="en-GB" align="left" style="margin-bottom: 0in">ios_base::openmode which =
ios_base::out|ios_base::in);
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit basic_stringstream(
<p lang="en-GB" align="left" style="margin-bottom: 0in">const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str,
<p lang="en-GB" align="left" style="margin-bottom: 0in">ios_base::openmode which =
ios_base::out|ios_base::in);
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringstream(basic_stringstream&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// 27.7.5.1 Assign/swap:
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_stringstream&amp;&amp;
rhs);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">// Members:
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt;*
rdbuf() const;
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_string&lt;charT,traits,<u>Alloc</u>&gt;
str() const;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void str(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str);
<p lang="en-GB" align="left" style="margin-bottom: 0in">private:
<p lang="en-GB" align="left" style="margin-bottom: 0in">// basic_stringbuf&lt;charT, traits&gt;
sb; exposition only
<p lang="en-GB" align="left" style="margin-bottom: 0in">};
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_stringstream&lt;charT,
traits, <u>Alloc</u>&gt;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; y);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator</u> <font size=
"2" style="font-size: 11pt"><u>Alloc</u>&gt;</font>
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_stringstream&lt;charT,
traits, <u>Alloc</u>&gt;&amp;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; y);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class charT, class traits,
<u>Allocator</u> <font size=
"2" style="font-size: 11pt"><u>Alloc</u>&gt;</font>
<p lang="en-GB" align="left" style="margin-bottom: 0in">void swap(basic_stringstream&lt;charT,
traits, <u>Alloc</u>&gt;&amp; x,
<p lang="en-GB" align="left" style="margin-bottom: 0in">basic_stringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; y);
<p lang="en-GB" align="left" style="margin-top: 0.04in">}
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 73
<td>
<p lang="en-GB" align="left">27.8.1.14
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">It is a problem from C++98, fstream cannot appoint
a filename of wide character string(const wchar_t and const
wstring&amp;).
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add interface corresponding to wchar_t,
char16_t and char32_t.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 86
<td>
<p lang="en-GB" align="left">28
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">ge
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The regular expressions chapter is not
concept enabled.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
309
<td>
<p align="justify">28
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Regular expressions cannot be used in constrained
templates
<p align="left"><br>
<td>
<p align="left">Provide
constraints for the regular expression library, clause 28
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
310
<td>
<p align="justify">28
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">The regex
chapter uses iterators in the old pre-concept style, it should be
changed to use concepts instead.
<td>
<p align="left">Use concepts
for iterator template arguments throughout.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
314
<td>
<p align="justify">28.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The swap overloads for regex classes are only
supplied for l-value references. Other sections of the library (eg
21 strings or 23 containers) provide two extra overloads taking an
r-value reference as the first and second argument
respectively.
<p align="left"><br>
<td>
<p align="left">Add the
missing overloads to 28.4 and the corresponding later sections in
28 for each swap function. We want to accept AMs paper which
proposes a single overload with two r-value references
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
315
<td>
<p align="justify">28.4
<td>
<p align="justify">p6
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">6 Effects: string_type str(first, last); return
use_facet&lt;collate&lt;charT&gt; &gt;(
getloc()).transform(&amp;*str.begin(), &amp;*str.end()); Is it
legal to dereference str.end() ?
<p align="left"><br>
<td>
<p align="left">Reword to
effect clause to use legal iterator dereferences
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
316
<td>
<p align="justify">28.4
ff
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The constructors for regex classes do not have an
r-value overload.
<p align="left"><br>
<td>
<p align="left">Add the
missing r-value constructors to regex classes.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
317
<td>
<p align="justify">28.8
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">basic_string
has both a constructor and an assignment operator that accepts an
initializer list, basic_regex should have the same.
<td>
<p align="left" style="margin-bottom: 0in">In the basic_regex synopsis, after:
basic_regex&amp; operator=(const charT* ptr); add: basic_regex&amp;
operator=(initializer_list&lt;charT&gt; il); And after paragraph 20
add: basic_regex&amp; operator=(initializer_list&lt;charT&gt; il);
Effects: returns assign(il.begin(), il.end());
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 74
<td>
<p lang="en-GB" align="left">28.8
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">&#8220;basic_regx &amp; operator=
(initializer_list&lt;T&gt;);&#8221; is not defined.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add basic_regx &amp; operator=
(initializer_list&lt;T&gt;);
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
318
<td>
<p align="justify">28.8.2
<td>
<p align="justify">para
22
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Constructor definition should appear with the
other constructors not after assignment ops.
<p align="left"><br>
<td>
<p align="left">Move para 22
to just after para 17.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
319
<td>
<p align="justify">28.12.2
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">It was always
expected that regex_token_iterator would be constructible from an
array literal: indeed ideally this is the prefered method of
initializing such an object. However, the best we could do in C++0x
was: template &lt;std::size_t N&gt;
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator
b, const regex_type&amp; re, const int (&amp;submatches)[N],
regex_constants::match_flag_type m =
regex_constants::match_default); Now that we have initializer_lists
we should use them to remove this particular wart.
<td>
<p align="left" style="margin-bottom: 0in">To the synopsis for regex_token_iterator, after
template &lt;std::size_t N&gt;
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator
b, const regex_type&amp; re, const int (&amp;submatches)[N],
regex_constants::match_flag_type m =
regex_constants::match_default); add
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator
b, const regex_type&amp; re, initializer_list&lt;int&gt;
submatches, regex_constants::match_flag_type m =
regex_constants::match_default); In 28.12.2.1 add the declaration:
regex_token_iterator(BidirectionalIterator a, BidirectionalIterator
b, const regex_type&amp; re, initializer_list&lt;int&gt;
submatches, regex_constants::match_flag_type m =
regex_constants::match_default); And to the end of para 3 add: The
forth constructor initializes the member subs to hold a copy of the
sequence of integer values in the range [submatches.begin(),
submatches.end()).
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 87
<td>
<p lang="en-GB" align="left">29
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">ge
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The atomics chapter is not concept
enabled. The adopted paper, N2427, did have those concepts.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
311
<td>
<p align="justify">29
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Atomic types cannot be used generically in a
constrained template
<p align="left"><br>
<td>
<p align="left">Provide
constraints for the atomics library, clause 29
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
312
<td>
<p align="justify">29
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">The contents
of the &lt;stdatomic.h&gt; header are not listed anywhere, and
&lt;cstdatomic&gt; is listed as a C99 header in chapter 17. If we
intend to use these for compatibility with a future C standard, we
should not use them now.
<td>
<p align="left">Remove
&lt;cstdatomic&gt; from the C99 headers in table 14. Add a new
header &lt;atomic&gt; to the headers in table 13. Update chapter 29
to remove reference to &lt;stdatomic.h&gt; and replace the use of
&lt;cstdatomic&gt; with &lt;atomic&gt;. If and when WG14 adds
atomic operations to C we can add corresponding headers to table 14
with a TR.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 75
<td>
<p lang="en-GB" align="left">29
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">A definition of enum or struct is the
style of C using typedef.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Change to a style of C++.
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">29.1
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>typedef</u> enum memory_order
{
<p lang="en-GB" align="left" style="margin-bottom: 0in">memory_order_relaxed,
memory_order_consume, memory_order_acquire,
<p lang="en-GB" align="left" style="margin-bottom: 0in">memory_order_release,
memory_order_acq_rel, memory_order_seq_cst
<p lang="en-GB" align="left" style="margin-bottom: 0in">} memory_order;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">enum memory_order {
<p lang="en-GB" align="left" style="margin-bottom: 0in">memory_order_relaxed,
memory_order_consume, memory_order_acquire,
<p lang="en-GB" align="left" style="margin-bottom: 0in">memory_order_release,
memory_order_acq_rel, memory_order_seq_cst
<p lang="en-GB" align="left" style="margin-bottom: 0in">};
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">29.3.1
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>typedef</u> struct atomic_bool
{
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">} atomic_bool;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">struct atomic_bool {
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">};
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>typedef</u> struct
atomic_<i>itype</i> {
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">} atomic_<i>itype</i>;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">struct atomic_<i>itype</i> {
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">};
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">29.3.2
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>typedef</u> struct atomic_address
{
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">} atomic_address;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">struct atomic_address {
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">};
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">29.5
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>typedef</u> struct atomic_flag
{
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">} atomic_flag;
<p lang="en-GB" align="left" style="margin-bottom: 0in">}
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">namespace std {
<p lang="en-GB" align="left" style="margin-bottom: 0in">struct atomic_flag {
<p lang="en-GB" align="left" style="margin-bottom: 0in">...
<p lang="en-GB" align="left" style="margin-bottom: 0in">};
<p lang="en-GB" align="left">}
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
313
<td>
<p align="justify">29.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">seq_cst
fences don't necessarily guarantee ordering
http://home.twcny.rr.com/hinnant/cpp_extensions/issues_preview/lwg-active.html#926
<td>
<p align="left" style="margin-bottom: 0in">Add a new paragraph after 29.1 [atomics.order]p5
that says For atomic operations A and B on an atomic object M,
where A and B modify M, if there are memory_order_seq_cst fences X
and Y such that A is sequenced before X, Y is sequenced before B,
and X precedes Y in S, then B occurs later than A in the
modifiction order of M.
<p align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 88
<td>
<p lang="en-GB" align="left">29.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left">The "lockfree" facilities do not tell the
programmer enough.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Expand the "lockfree" facilities. See
the attached paper "Issues with the C++ Standard" under Chapter 29,
"atomics.lockfree doesn't tell the programmer enough"
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 89
<td>
<p lang="en-GB" align="left">29.3.1
<td>
<p lang="en-GB" align="left">Table 122
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The types in the table "Atomics for
standard typedef types" should be typedefs, not classes. These
semantics are necessary for compatibility with C.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">Change the classes to typedefs.
<td>
<p lang="en-GB" align="left">Google
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 90
<td>
<p lang="en-GB" align="left">29.4
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left">Are atomic functions allowed to have non-volatile
overloads?
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Allow non-volatile overloads. See the
attached paper "Issues with the C++ Standard, under Chapter 29,
"Are atomic functions allowed to have non-volatile
overloads?"
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 91
<td>
<p lang="en-GB" align="left">29.4
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left">Whether or not a failed compare_exchange is a RMW
operation (as used in 1.10 [intro.multithread]) is unclear.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Make failing compare_exchange operations <font size=
"2" style="font-size: 11pt">
<strong>not</strong> be RMW. See the attached
paper under "atomic RMW status of failed
compare_exchange"</font>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 92
<td>
<p lang="en-GB" align="left">29.4
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">te
<td>
<p lang="en-GB" align="left">The effect of memory_order_consume with atomic RMW
operations is unclear.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Follow the lead of fences
[atomics.fences], and promote memory_order_consume to
memory_order_acquire with RMW operations.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>JP 76
<td>
<p lang="en-GB" align="left">30
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">A description for "<i>Throws:</i>
Nothing." are not unified.
<p lang="en-GB" align="left" style="margin-top: 0.04in">At the part without throw,
"<i>Throws:</i> Nothing." should be described.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Add "<i>Throws:</i> Nothing." to the
following.
<p lang="en-GB" align="left" style="margin-bottom: 0in">30.2.1.6 , 1<sup>st</sup><font size=
"2" style="font-size: 11pt"> paragraph</font>
<p lang="en-GB" align="left" style="margin-bottom: 0in">30.3.3.1 , 4<sup>th</sup><font size=
"2" style="font-size: 11pt"> paragraph</font>
<p lang="en-GB" align="left" style="margin-bottom: 0in">30.3.3.2.1 , 6<sup>th</sup><font size=
"2" style="font-size: 11pt"> paragraph</font>
<p lang="en-GB" align="left" style="margin-bottom: 0in">30.4.1 , 7<sup>th</sup><font size=
"2" style="font-size: 11pt"> and 8<sup>th</sup> paragraph</font>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">30.4.2 ,
6<sup>th</sup><font size="2" style=
"font-size: 11pt">, 7<sup>th</sup>,19<sup>th</sup>,21th and 25<sup>th</sup> paragraph</font>
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 93
<td>
<p lang="en-GB" align="left">30
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">ge
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">The thread chapter is not concept
enabled.
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK<br>
320
<p><br>
<td>
<p align="justify">30
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">Threads
library cannot be used in constrained templates
<td>
<p align="left">Provide
constraints for the threads library, clause 30
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>UK<br>
321
<td>
<p align="justify">30
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">Throughout this clause, the term Requires: is used
to introduce compile time requirements, which we expect to be
replaced with concepts and requires in code. Run-time preconditions
are introduced with the term "Preconditions:" which is not a
defined part of the library documentation structure (17.5.2.4).
However, this is exactly the direction that BSI would like to see
the organisation move, replacing Requires: clauses with
Preconditions: clasues throught the library. See comment against
clause 17 for more details.
<p align="left"><br>
<td>
<p align="left">Decument
Preconditions: paragraphs in 17.5.2.4, and use consistently through
rest of the library.
<td>
<p lang="en-GB" align="left"><br>
<tr valign="top">
<td>
<p>US 94
<td>
<p>30.1.2
<td>
<p>1
<td>
<p>te
<td>
<p>The first sentence of para
1 suggests that no other library function is permitted to call
operating system or low level APIs.
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
Rewrite para 1 as: &#8220;
<font color="#000000">Some functions described in this Clause are
specified to throw exceptions of type system_error
(</font><font color="#0000FF">19.4.5</font> <font color=
"#000000">). Such exceptions shall be thrown if a call to an
operating system or underlying API results in an error that
prevents the library function from satisfying its postconditions or
from returning a meaningful value.&#8221;</font>
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>US 95
<td>
<p>30.1.3
<td>
<p>1
<td>
<p>te
<td>
<p>&#8220;native_handle_type&#8221; is a typedef, not a
class member.
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">Several classes described in this Clause have a
member native_handle (of type native_handle_type) . The
<p lang="en-GB" align="left" style="margin-bottom: 0in">presence of this member and its
semantics is implementation defined. [ Note: This member allows
implementations to provide access to implementation details. The
name of the member and the type are specified to facilitate
portable compile-time detection. Actual use of this member or the
corresponding type is inherently non-portable. &#8212;end note
]
<p lang="en-GB" align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>US 96
<td>
<p>30.1.4
<td>
<p>2
<td>
<p>te
<td>
<p>There is no definition
here for monotonic clock.
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">Implementations should use a <i>monotonic
clock</i> to measure time for these functions. A monotonic clock
measures real time, but cannot be set, and is guaranteed to have no
negative clock jumps.
<p lang="en-GB" align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
322
<td>
<p align="justify">30.1.4
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Not all systms can provide a monotonic clock. How
are they expected to treat a _for function?
<p align="left"><br>
<td>
<p align="left">Add at least
a note explaining the intent for systems that do not support a
monotonic clock.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
323
<td>
<p align="justify">30.2.1
<td>
<p align="justify">1
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The presence of a non-explicit variadic template
constructor alongside an explicit single-argument constructor can
lead to behaviour that is not intended: the variadic constructor
will be selected for implicit conversions, defeating the purpose of
the explicit single-argument constructor. Additionally the
single-argument constructor is redundant; the variadic constructor
can provide identical functionality with one *fewer* copies if the
supplied func is an lvalue.
<p align="left"><br>
<td>
<p align="left">Mark
constructor template &lt;class F, class ...Args&gt;
thread(F&amp;&amp; f, Args&amp;&amp;... args); as explicit and
remove the single-argument constructor.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
324
<td>
<p align="justify">30.2.1.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">thread::id objects should be as useable in hashing
containers as they are in ordered associative containers.
<p align="left"><br>
<td>
<p align="left" style="margin-bottom: 0in">Add thread::id support for std::hash
<p align="left" style="margin-bottom: 0in"><br>
<p align="left" style="margin-bottom: 0in"><br>
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 77
<td>
<p lang="en-GB" align="left">30.2.1.2
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">"CopyConstructible" and "MoveConstructible" in
"<i>Requires:</i> F and each Ti in Args shall be CopyConstructible
if an lvalue and otherwise MoveConstructible." are reflected by
interface.
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Add a concept for constructor of
thread.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 78
<td>
<p lang="en-GB" align="left">30.2.1.2
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">4<sup>th</sup><font size=
"2" style="font-size: 11pt"> paragraph, 1<sup>st</sup> line</font>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">In "F and each Ti in Args", 'Ti' is not
clear.
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Replace "Ti" with "args"
<td>
<p><br>
<tr valign="top">
<td>
<p>US 97
<td>
<p>30.2.1.3
<td>
<p>1
<td>
<p>te
<td>
<p>detach-on-destruction may
result in &#8220;escaped&#8221; threads accessing objects with
bounded lifetime after the end of their lifetime.
<td>
<p>See document WG21
N2802=08-0312 written by Hans Boehm.
<td>
<p><br>
<tr valign="top">
<td>
<p lang="en-GB" align="left">US 98
<td>
<p lang="en-GB" align="left">30.2.1.3, 30.2.1.4
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left"><br>
<td>
<p lang="en-GB" align="left">The current defined behavior for the std::thread
destructor is to detach the thread. Unfortunately, this behavior
exposes programmers to tricky, hard-to-diagnose, undefined
behavior.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Change destruction behavior to undefined
behavior, with a note strongly encouraging termination. See the
attached paper "Issues with the C++ Standard" under Chapter 30,
"Implicit thread detach is harmful".
<p lang="en-GB" align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
325
<td>
<p align="justify">30.3.3
<td>
<p align="justify">2
<td>
<p align="justify">Te
<td>
<p align="left">We believe
constexpr literal values should be a more natural expression of
empty tag types than extern objects as it should improve the
compilers ability to optimize the empty object away
completely.
<td>
<p align="left" style="margin-bottom: 0in">Replace the extern declarations: extern const
defer_lock_t defer_lock; extern const try_to_lock_t try_to_lock;
extern const adopt_lock_t adopt_lock; with constexpr values
constexpr defer_lock_t defer_lock{}; constexpr try_to_lock_t
try_to_lock{}; constexpr adopt_lock_t adopt_lock{};
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
326
<td>
<p align="justify">30.3.3.2.1
<td>
<p align="justify">7
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">The precondition that the mutex is not owned by
this thread offers introduces the risk of un-necessary undefined
behaviour into the program. The only time it matters whether the
current thread owns the mutex is in the lock operation, and that
will happen subsequent to construction in this case. The lock
operation has the identical pre-condition, so there is nothing
gained by asserting that precondition earlier and denying the
program the right to get into a valid state before calling
lock.
<p align="left"><br>
<td>
<p align="left">Strike
30.3.3.2.1p7
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
327
<td>
<p align="justify">30.3.3.2.2
<td>
<p align="justify">4, 9, 14,
19
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Not clear what the specification for error
condition resource_deadlock_would_occur means. It is perfectly
possible for this thread to own the mutex without setting owns to
true on this specific lock object. It is also possible for lock
operations to succeed even if the thread does own the mutex, if the
mutex is recursive. Likewise, if the mutex is not recursive and the
mutex has been locked externally, it is not always possible to know
that this error condition should be raised, depending on the host
operating system facilities. It is possible that 'i.e.' was
supposed to be 'e.g.' and that suggests that recursive locks are
not allowed. That makes sense, as the exposition-only member owns
is boolean and not a integer to count recursive locks.
<p align="left"><br>
<td>
<p align="left">Add a
precondition !owns. Change the 'i.e.' in the error condition to be
'e.g.' to allow for this condition to propogate deadlock detection
by the host OS.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
328
<td>
<p align="justify">30.3.3.2.2
<td>
<p align="justify">20
<td>
<p align="justify">Te
<td>
<p align="left">There is a
missing precondition that owns is true, or an if(owns) test is
missing from the effect clause
<td>
<p align="left" style="margin-bottom: 0in">Add a precondition that owns == true. Add an error
condition to detect a violation, rather than yield undefined
behaviour.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
329
<td>
<p align="justify">30.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">future,
promise and packaged_task provide a framework for creating future
values, but a simple function to tie all three components together
is missing. Note that we only need a *simple* facility for C++0x.
Advanced thread pools are to be left for TR2.
<td>
<p align="left" style="margin-bottom: 0in">Provide a simple function along the lines of:
template&lt; typename F, typename ... Args &gt; requires
Callable&lt; F, Args... &gt; future&lt; Callable::result_type &gt;
async( F&amp;&amp; f, Args &amp;&amp; ... ); Semantics are similar
to creating a thread object with a packaged_task invoking f with
forward&lt;Args&gt;(args...) but details are left unspecified to
allow different scheduling and thread spawning implementations. It
is unspecified whether a task submitted to async is run on its own
thread or a thread previously used for another async task. If a
call to async succeeds, it shall be safe to wait for it from any
thread. The state of thread_local variables shall be preserved
during async calls. No two incomplete async tasks shall see the
same value of this_thread::get_id(). [Note: this effectively forces
new tasks to be run on a new thread, or a fixed-size pool with no
queue. If the library is unable to spawn a new thread or there are
no free worker threads then the async call should fail.]
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
330
<td>
<p align="justify">30.5.1
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left">30.5.1 (and
then 30.5.7) refer to a specialisation of
constructible_with_allocator_prefix&lt;&gt; However this trait is
not in the CD, so references to it should be removed.
<td>
<p align="left" style="margin-bottom: 0in">Remove the reference to
constructible_with_allocator_prefix in 30.5.1 Remove paragraph
30.5.7
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 79
<td>
<p lang="en-GB" align="left">30.5.1
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>te
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">The concept of UsesAllocator and
Allocator should be used.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class R, class
Alloc&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">struct
uses_allocator&lt;promise&lt;R&gt;, Alloc&gt;;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class R&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">struct
constructible_with_allocator_prefix&lt;promise&lt;R&gt;
&gt;;
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template&lt;class R, Allocator
Alloc&gt;
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">concept_map UsesAllocator&lt;promise&lt;R&gt;,
Alloc&gt;;
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
331
<td>
<p align="justify">30.5.3
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Not clear what it means for a public constructor
to be 'exposition only'. If the intent is purely to support the
library calling this constructor then it can be made private and
accessed through friendship. Otherwise it should be documented for
public consumption.
<p align="left"><br>
<td>
<p align="left">Declare the
constructor as private with a note about intended friendship, or
remove the exposition-only comment and document the
semantics.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
332
<td>
<p align="justify">30.5.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Ed
<td>
<p align="left" style="margin-bottom: 0in">It is not clear without reference to the original
proposal how to use a future. In particular, the only way for the
user to construct a future is via the promise API which is
documented after the presentation of future. Most library clauses
feature a small description of their components and intended use,
it would be most useful in this case.
<p align="left"><br>
<td>
<p align="left">Provide a
small introductory paragraph, docuenting intended purpose of the
future class template and the way futures can only be created via
the promise API.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
333
<td>
<p align="justify">30.5.4
<td>
<p align="justify">5
<td>
<p align="justify">Ge
<td>
<p align="left">We expect the
complicated 3-signature specifcation for future::get() to be
simplified to a single signature with a requires clause by the
application of concepts.
<td>
<p align="left">Requires
fully baked concepts for clause 30
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
334
<td>
<p align="justify">30.5.4
<td>
<p align="justify">5
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">Behaviour of get() is undefined if calling get()
while not is_ready(). The intent is that get() is a blocking call,
and will wait for the future to become ready.
<p align="left"><br>
<td>
<p align="left">Effects: If
is_ready() would return false, block on the asynchronous result
associated with *this.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
335
<td>
<p align="justify">30.5.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">std::unique_future is MoveConstructible, so you
can transfer the association with an asynchronous result from one
instance to another. However, there is no way to determine whether
or not an instance has been moved from, and therefore whether or
not it is safe to wait for it. std::promise&lt;int&gt; p;
std::unique_future&lt;int&gt; uf(p.get_future());
std::unique_future&lt;int&gt; uf2(std::move(uf)); uf.wait(); //
oops, uf has no result to wait for.
<p align="left"><br>
<td>
<p align="left">Add a
"waitable()" function to unique_future (and shared_future) akin to
std::thread::joinable(), which returns true if there is an
associated result to wait for (whether or not it is ready). Then we
can say: if(uf.waitable()) uf.wait();
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
336
<td>
<p align="justify">30.5.4
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">It is possible to transfer ownership of the
asynchronous result from one unique_future instance to another via
the move-constructor. However, it is not possible to transfer it
back, and nor is it possible to create a default-constructed
unique_future instance to use as a later move target. This unduly
limits the use of unique_future in code. Also, the lack of a
move-assignment operator restricts the use of unique_future in
containers such as std::vector - vector::insert requires
move-assignable for example.
<p align="left"><br>
<td>
<p align="left">Add a default
constructor with the semantics that it creates a unique_future with
no associated asynchronous result. Add a move-assignment operator
which transfers ownership.
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 80
<td>
<p lang="en-GB" align="left">30.5.4 , 30.5.5
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Typo, duplicated "&gt;"
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">"class Period&gt;&gt;"
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">Remove one
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
337
<td>
<p align="justify">30.5.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">shared_future should support an efficient move
constructor that can avoid unnecessary manipulation of a reference
count, much like shared_ptr
<p align="left"><br>
<td>
<p align="left">Add a move
constructor
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
338
<td>
<p align="justify">30.5.5
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">shared_future
is currently CopyConstructible, but not CopyAssignable. This is
inconsistent with shared_ptr, and will surprise users. Users will
then write work-arounds to provide this behaviour. We should
provide it simply and efficiently as part of shared_future. Note
that since the shared_future member functions for accessing the
state are all declared const, the original usage of an immutable
shared_future value that can be freely copied by multiple threads
can be retained by declaring such an instance as "const
shared_future".
<td>
<p align="left" style="margin-bottom: 0in">Remove "=delete" from the copy-assignment operator
of shared_future. Add a move-constructor
shared_future(shared_future&amp;&amp; rhs), and a move-assignment
operator shared_future&amp; operator=(shared_future&amp;&amp; rhs).
The postcondition for the copy-assignment operator is that *this
has the same associated state as rhs. The postcondition for the
move-constructor and move assignment is that *this has the same
associated as rhs had before the constructor/assignment call and
that rhs has no associated state.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
339
<td>
<p align="justify">30.5.6
<td>
<p align="justify">6,
7
<td>
<p align="justify">Te
<td>
<p align="left">Move
assignment is goiing in the wrong direction, assigning from *this
to the passed rvalue, and then returning a reference to an unusable
*this
<td>
<p align="left" style="margin-bottom: 0in">Strike 6. 7 Postcondition: associated state of
*this is the same as the associated state of rhs before the call.
rhs has no associated state.
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
340
<td>
<p align="justify">30.5.6
<td>
<p align="justify">11, 12,
13
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">There is an implied postcondition that the state
of the promise is transferred into the future leaving the promise
with no associated state. It should be spelled out.
<p align="left"><br>
<td>
<p align="left">Postcondition: *this has no associated
state.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
341
<td>
<p align="justify">30.5.6
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left">promise::swap
accepts its parameter by lvalue reference. This is inconsistent
with other types that provide a swap member function, where those
swap functions accept an rvalue reference
<td>
<p align="left">Change
promise::swap to take an rvalue reference.
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
342
<td>
<p align="justify">30.5.6
<td>
<p align="justify"><br>
<td>
<p align="justify">Te
<td>
<p align="left" style="margin-bottom: 0in">std::promise is missing a non-member overload of
swap. This is inconsistent with other types that provide a swap
member function
<p align="left"><br>
<td>
<p align="left">Add a
non-member overload void swap(promise&amp;&amp; x,promise&amp;&amp;
y){ x.swap(y); }
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
343
<td>
<p align="justify">30.5.6
<td>
<p align="justify">3
<td>
<p align="justify">Te
<td>
<p align="left">The move
constructor of a std::promise object does not need to allocate any
memory, so the move-construct-with-allocator overload of the
constructor is superfluous.
<td>
<p align="left" style="margin-bottom: 0in">Remove the constructor with the signature template
&lt;class Allocator&gt; promise(allocator_arg_t, const
Allocator&amp; a, promise&amp; rhs);
<p align="left"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>JP 81
<td>
<p lang="en-GB" align="left">30.5.8
<td>
<p lang="en-GB" align="left"><br>
<td>
<p>ed
<td>
<p lang="en-GB" align="left" style="margin-top: 0.04in">There are not requirements for F and a
concept of Allocator dose not use.
<td>
<p lang="en-GB" align="left" style="margin-bottom: 0in">Correct as follows.
<p lang="en-GB" align="left" style="margin-bottom: 0in"><br>
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class F&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit packaged_task(F f);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class F, class
Allocator&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit packaged_task(allocator_arg_t,
const Allocator&amp; a, F f);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class F&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit packaged_task(F&amp;&amp;
f);
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class F, class
Allocator&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit packaged_task(allocator_arg_t,
const Allocator&amp; a, F&amp;&amp; f);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">should be
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class F&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>requires CopyConstructible&lt;F&gt;
&amp;&amp; Callable&lt;F, ArgTypes...&gt;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit packaged_task(F f);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class F, <u>Allocator
Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>requires CopyConstructible&lt;F&gt;
&amp;&amp; Callable&lt;F, ArgTypes...&gt;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit packaged_task(allocator_arg_t,
const <u>Alloc</u>&amp; a, F f);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class F&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>requires CopyConstructible&lt;F&gt;
&amp;&amp; Callable&lt;F, ArgTypes...&gt;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in">explicit packaged_task(F&amp;&amp;
f);
<p lang="en-GB" align="left" style="margin-bottom: 0in">&nbsp;
<p lang="en-GB" align="left" style="margin-bottom: 0in">template &lt;class F, <u>Allocator
Alloc</u>&gt;
<p lang="en-GB" align="left" style="margin-bottom: 0in"><u>requires CopyConstructible&lt;F&gt;
&amp;&amp; Callable&lt;F, ArgTypes...&gt;</u>
<p lang="en-GB" align="left" style="margin-bottom: 0in">&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;
<p lang="en-GB" align="left" style=
"margin-top: 0.04in; margin-bottom: 0.04in">explicit packaged_task(allocator_arg_t, const
<u>Alloc</u>&amp; a, F&amp;&amp; f);
<p lang="en-GB" align="left" style="margin-top: 0.04in"><br>
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-23
<td>
<p>Annex B
<td>
<p>p2
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
DE-23 Recursive use of
constexpr functions appears to be permitted. Since such functions
may be required to be evaluated at compile-time, Annex B
"implementation quantities" should specify a maximum depth of
recursion.
<p><br>
<td>
<p>In Annex B, specify a
recursion depth of 256 or a larger value.
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-24
<td>
<p>Annex B
<td>
<p>p2
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
DE-24 The number of
placeholders for "bind" is implementation-defined in 20.7.12.1.4,
but no minimum is suggested in Annex B.
<p><br>
<td>
<p>Add a miminum of 10
placeholders to Annex B.
<td>
<p><br>
<tr valign="top">
<td>
<p>DE-25
<td>
<p>Annex B
<td>
<p>p2
<td>
<p>te
<td>
<p lang="en-GB" style="margin-top: 0.04in; margin-bottom: 0.04in">
DE-25 Specifying a minimum of
17 recursively nested template instantiations is too small for
practical purposes. The limit is too high to effectively limit
compiler resource usage, see
http://ubiety.uwaterloo.ca/~tveldhui/papers/2003/turing.pdf . The
conclusion is that the metric "number of recursively nested
template instantiations" is inapposite.
<p><br>
<td>
<p>Remove the bullet
"Recursively nested template instantiations [17]".
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 38
<td>
<p>C.2 [diffs.library]
<td>
<p>1
<td>
<p>ed
<td>
<p style="margin-bottom: 0in">What is ISO/IEC 1990:9899/DAM 1? My guess
is that's a typo for ISO/IEC
<p style="margin-bottom: 0in">9899/Amd.1:1995 which I'd have expected to
be referenced here (the tables
<p style="margin-bottom: 0in">make reference to things which were
introduced by Amd.1).
<p><br>
<td>
<p style="margin-bottom: 0in">One need probably a reference to the
document which introduce char16_t and
<p>char32_t in C (ISO/IEC TR
19769:2004?).
<td>
<p><br>
<tr valign="top">
<td>
<p>UK<br>
344
<td>
<p align="justify">Appendix
D
<td>
<p align="justify"><br>
<td>
<p align="justify">Ge
<td>
<p align="left">It is
desirable to allow some mechanism to support phasing out of
deprecated features in the future. Allowing compilers to implement
a mode where deprecated features are not available is a good first
step.
<td>
<p align="left">Add to the
definition of deprecated features permission for compilers to
maintain a conditionally supported mode where deprecated features
can be disabled, so long as they also default to a mode where all
deprecated features are supported.
<td>
<p><br>
<tr valign="top">
<td>
<p>FR 39
<td>
<p>Index
<td>
<p><br>
<td>
<p>ed
<td>
<p style="margin-bottom: 0in">Some definitions seem not indexed (such as
/trivially copyable/ or
<p style="margin-bottom: 0in">/sequenced before/), indexing them would
be useful (and marking specially the page -- say bold or italic --
which reference to the definition would increase the usefulness;
having a separate index of all definitions is something which could
also be considered).
<p><br>
<td>
<p><br>
<td>
<p><br>
<tr valign="top">
<td>
<p><br>
<td>
<p align="justify"><br>
<td>
<p align="justify"><br>
<td>
<p align="justify"><br>
<td>
<p align="justify"><br>
<td>
<p align="left"><br>
<td>
<p><br></table></div>