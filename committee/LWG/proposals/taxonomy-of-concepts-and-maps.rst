=======================================
A Taxonomy of Concepts and Concept Maps
=======================================

:Authors: Dave Abrahams <dave@boostpro.com> and Doug Gregor <doug.gregor@gmail.com>
:Number:  xxxx=xx-xxxx
:Date: 2009-07-01

This paper introduces a classification of concepts and concept maps
into categories that we help will support the discussion of various
proposed design changes.  We use this classification to analyze the
implications of making certain concepts ``auto``.  We hope that the
classification can be a useful basis for discussion even if no
consensus forms around our analysis.

Three Kinds of Concepts
=======================

These are the three basic categories of concepts.

Syntactic Concepts
------------------

Syntactic concepts such as ``HasPlus`` and ``Callable`` represent purely structural
information about types::

  auto concept HasPlus<typename T, typename U> { 
      typename result_type; 
      result_type operator+(const T&, const U&);
  } 

such concepts have two main uses:

1. preserving backward compatibility while constraining legacy
   templates whose requirements have been written in syntactic terms.
   For example, the C++03 definition of ``std::inner_product`` taking
   four arguments is as follows:

   ::

     template <class InputIterator1, class InputIterator2, class T> 
     T inner_product(InputIterator1 first1, InputIterator1 last1, 
                     InputIterator2 first2, T init); 

   :Effects: Computes its result by initializing the accumulator
     ``acc`` with the initial value ``init`` and then modifying it
     with ``acc = acc + (*i1) * (*i2)`` for every iterator ``i1`` in
     the range [``first``, ``last``) and iterator ``i2`` in 
     the range [``first2``, ``first2 + (last - first)``) in order. 

   :Requires: ``T`` must meet the requirements of CopyConstructible
     (20.1.3) and Assignable (23.1) types

   The ideal signature for C++0x would probably be something like:

   .. parsed-literal::

    template <**InputIterator Iter1**, **InputIterator Iter2**> 
    requires **SemiRing<Iter1::value_type>**
      && **SameType<Iter1::value_type, Iter2::value_type>**
    T inner_product(Iter1 first1, Iter1 last1, Iter2 first2, Iter1::value_type init);

   but that would add quite a few requirements, many of them subtle,
   to those implied by the C++03 specification.  In C++0x, to maintain
   the same requirements, the signature must be written using
   syntactic requirements:

   .. parsed-literal::

    template <**InputIterator Iter1**, **InputIterator Iter2**, **MoveConstructible T**> 
    requires **HasMultiply<Iter1::reference, Iter2::reference>** 
      && **HasPlus<T, HasMultiply<Iter1::reference, Iter2::reference>::result_type>** 
      && **HasAssign<T, 
          HasPlus<T, 
            HasMultiply<Iter1::reference, Iter2::reference>::result_type
          >::result_type
        >** 
    T inner_product(Iter1 first1, Iter1 last1, Iter2 first2, T init);

2. constraining components such as the operators in Boost.Lambda, whose
   sole purpose is syntax adaptation:

   .. parsed-literal::

     // The function object generated by an expression such as _1 + 42
     template <typename Lambda, typename RHS>
     struct add_right
     {
         template <typename ...Args>
            requires Callable<Lambda, Args...>
              && **HasPlus<Callable<Lambda, Args...>::result_type, RHS>**
         auto operator()(Args ...args) -> decltype(f(args...) + r)
         {
             return f(args...) + r;
         }

         add_right(Lambda r, RHS const& r)
           : f(f), r(r)

         Lambda f;
         RHS const& r;
     };

Syntactic concepts indicate nothing more than structural properties of
types, which are perfectly detectable by the compiler, and thus should
always be ``auto``.  They tend to be highly granular, so the size of
this category of concepts is bounded by the grammar of the core
language: there are only so many individual syntactic components.  

As you can see from the first example above, syntactic concepts are
often associated with generic functions whose documentation
essentially exposes implementation details, and as such their use is
discouraged.  Sean Parent has gone so far as to label them “partial
concepts,” and the committee has agreed on the ``Has``\
*SyntacticFeature* naming convention to distinguish them from concepts
with semantic implications.

Foundational Concepts
---------------------

Foundational concepts have low complexity and a single agreed-upon
syntactic structure and semantics.  This category includes concepts
like ``CopyAssignable``, that capture the usual meaning of core language
constructs; like ``SemiRing``, that reflect well-known mathematical
ideas; and like ``Swappable``, whose operations have
broadly-established syntax and conventional meaning.

Note that ``SemiRing``, mentioned above, might not quite fit the
criteria today, since there is no widely-accepted C++ syntax for
producing the additive and multiplicative identity elements.  The
usual mathematical syntaxes are “0” and “1” respectively, and a
corresponding C++ syntax should be established.  User-defined literals
and ``constexpr`` may make a suitable convention feasible.

There are a few good reasons to make foundational concepts ``auto``:

1. Because they are simple, foundational concepts can be very easy to
   model correctly, which tends to factor against the diagnostic value 
   added by an explicitly-written ``concept_map``.

2. They are often so simple that the syntactic weight of an
   explicitly-written ``concept_map`` is a significant fraction of the
   weight of the user's data type itself::

      struct case_insensitive // 67 non-whitespace characters
      {
          bool operator()(string const&, string const&);
      };

      // 46 non-whitespace characters.
      concept_map BinaryPredicate<case_insensitive> {}

   [This relative weight is mitigated somewhat by the need to actually
   *implement* the data type, and, if accepted, by the intentional mapping
   syntax proposed in N2916]

3. Because foundational concepts have a widely agreed-upon syntax and
   semantics, there's a very good chance that there are already matching
   user data types
   “out there in the wild,” likely designed with the abstract concept,
   in mind, but without specific knowledge of the C++ ``concept``.

On the other hand, syntactic properties are not an airtight criterion
by which to correctly identify foundational concepts.  This fact can
be manifested in one of two ways.

1. **Structural Aliasing**.  In c++std-lib-23956, Chris Jefferson writes:

   .. epigraph::

     I have a type I use regularly where ``operator<`` does not define a
     total ordering (but it defines a very natural operation). On
     occasion, people have given this type to ``std::sort``, and expected it
     to work, instead their program tends to crash in unpredictable ways.

     I had hoped that concepts were going to help me sort this out, but
     at the moment they do not, as there is no way to mark my type as not
     satisfying the auto concept ``LessThanComparable``.

   Chris' users have a reasonable expectation to be protected from
   such mistakes that is consistent with the C++ tradition of
   protecting against accident rather than deliberate
   circumvention. [#cpppl3e]_

2. **Semantic Refinement**.  Perhaps because they are simple, foundational
   concepts often refine other concepts having the same or similar syntactic
   structure.  For example, if we know the operation used with
   ``std::accumulate`` is ``Associative``, we can distribute the
   computation across N cores by breaking the input into N subranges,
   accumulating them, and using the operation again to combine the
   partial results:

   .. parsed-literal::

     concept **Associative<typename F, typename...Args>**
       : **Callable<F,Args...>**
     {};

     // operates serially 
     template <
         InputIterator Iter, MoveConstructible T, 
         **Callable**\ <auto, const T&, Iter::reference> BinaryOperation
     >
     requires HasAssign<T, BinaryOperation::result_type> 
           && CopyConstructible<BinaryOperation> 
     T accumulate(Iter first, Iter last, T init, BinaryOperation binary_op);

     // optimized parallel version
     template <
         ForwardIterator Iter, MoveConstructible T, 
         **Associative**\ <auto, const T&, Iter::reference> BinaryOperation
     >
     requires HasAssign<T, BinaryOperation::result_type> 
           && CopyConstructible<BinaryOperation> 
     T accumulate(Iter first, Iter last, T init, BinaryOperation binary_op);

   If ``Associative`` were declared ``auto``, even non-``Associative``
   operations would be dispatched to the parallel implementation of
   ``accumulate`` based on their callability with two arguments,
   yielding an incorrect result at runtime.  [#undefined]_ Note:
   Semantic refinements are especially common among the algebraic
   structures (see SemiRing/Ring, Group/AbelianGroup,
   BinaryOperator/SemiGroup, etc.)

We believe that for foundational concepts, the normal interpretation
of combined syntactic elements is so widespread that the convenience
of automatic conformance usually outweighs the danger of structural
aliasing.  [#delmap]_ 

However, before making any concept ``auto``, one must also take great
care to be sure it is not, and *will never be*, a refinement of
another concept with identical or very similar syntax, because
changing a concept from ``auto`` to non-``auto`` will break any code
that depended on the earlier automatic conformance.
[#explicit-refinement]_ This sort of concept hierarchy evolution is
more common than one might think.  In fact, Chris Jefferson's problem
was also a case of semantic refinement—after all, a total order *is-a*
partial order—the only difference being that Chris hadn't (yet) found
a use for overloading on this semantic difference.

Our experience shows that it takes a long time to develop widespread
agreement on syntax and semantics for new concepts, so we don't expect
new foundational concepts to proliferate quickly.  Also, with the
notable exception of algebraic structures such as ``SemiRing``, most
foundational concepts known today are already supplied by the standard
library.

Nontrivial Concepts
-------------------

Any concepts that are neither syntactic or foundational are called
*nontrivial*.  Nontrivial concepts have generally higher complexity
and usually cannot be satisfied without significant coding effort.
Examples in this category include `graph concepts`_, and the standard
iterator and container concepts.

.. _graph concepts: http://www.boost.org/doc/libs/1_39_0/libs/graph/doc/graph_concepts.html

We expect a large majority of concepts written outside the standard
library to be nontrivial, since:

a. The number of granular syntactic concepts is bounded
b. The standard library already supplies most syntactic concepts
c. The standard library already supplies many foundational concepts
d. New foundational concepts don't come along every day.

The arguments for declaring a concept ``auto`` are not nearly as
compelling in the case of nontrivial concepts as they are for
foundational ones.  Nontrivial concepts are not easy to model
correctly, so the diagnostics produced by a ``concept_map`` can be
highly valuable to the author of the data type.  Declaring a new matching
data type is a
significant job that tends to make the effort required to write a
``concept_map`` “disappear in the noise.” Finally, because they are
not simple, there is little chance of finding pre-existing data types that
meet the requirements of
newly-defined nontrivial concepts “in the wild.”

The risks of declaring a nontrivial concept ``auto`` are also less
compelling than for a foundational concept, because structural
aliasing of a complex syntactic form is so unusual.  However,
syntactic complexity doesn't seem to reduce the likelihood of eventual
semantic refinement.

Three Kinds of Concept Maps
===========================

Whether explicitly written or implicitly generated, concept maps can
be classified by their intended purpose:

Intentional Mapping
-------------------

Intentional concept maps occur when a programmer designs a class with
the goal of modeling a particular concept.  Note that this distinction
is unrelated to the choice to make a concept ``auto``.  For example, I
might design a type to model ``EqualityComparable`` or
``BidirectionalIterator``.  Because ``EqualityComparable`` is an
``auto`` concept, an intentional map may be automatically generated
when the type is passed where ``EqualityComparable`` is required.  In
the case of the non-``auto`` concept ``BidirectionalIterator``, an
intentional map must be written by the author of the data type.  We call
both maps “intentional” because they are intended by the author of the
data type.

Intentional ``concept_maps``\ s are traditionally empty, since a
programmer modeling a concept in C++03 must write the required
definitions of associated functions in class or namespace scope, and
people are accustomed to doing things that way.

In C++0x, associated functions can be written in the scope of the
``concept_map`` itself::

    template <class T, class U>
    struct pair
    {
        // Just the data, Ma'am
        T first;
        U second;
    };

    template <CopyConstructible T, CopyConstructible U>
    concept_map CopyConstructible<pair<T,U> >
    {
        pair<T,U>::pair(pair<T,U> const& rhs)
          : first(rhs.first), second(rhs.second) {}
    };

    template <DefaultConstructible T, DefaultConstructible U>
    concept_map DefaultConstructible<pair<T,U> >
    {
        pair<T,U>::pair() {}
    };

    template <Swappable T, Swappable U>
    concept_map Swappable<pair<T,U> >
    {
        void swap(pair<T,U>& lhs, pair<T,U>& rhs) 
        { 
            swap(lhs.first,rhs.first); 
            swap(lhs.second,rhs.second);
        }
    };

    …etc…

This map-centric style [#mat]_ has a number of expressive advantages
over the “traditional” approach:

* It groups the operations associated with modeling a concept
  together, within the concept map.

* It makes explicit and visible the relationship between the
  properties of the data type's template arguments and of the data type itself
  (even if the concept is ``auto``).  For example, a ``pair<T,U>`` is
  ``CopyConstructible`` if both ``T`` and ``U`` are
  ``CopyConstructible``.

* When combined with exported concept maps as proposed by
  N2918=09-0108, it can substantially reduce verbosity (even when the
  concepts are ``auto``), because the requirements associated with a
  group of such operations are not repeated.  For example, the part of
  the ``std::list`` interface needed to make it satisfy
  ``LessThanComparable`` looks like::

    template <LessThanComparable T, class A> 
      bool operator< (const list<T,A>& x, const list<T,A>& y); 
    template <LessThanComparable T, class A> 
      bool operator> (const list<T,A>& x, const list<T,A>& y); 
    template <LessThanComparable T, class A> 
      bool operator>=(const list<T,A>& x, const list<T,A>& y); 
    template <LessThanComparable T, class A> 
      bool operator<=(const list<T,A>& x, const list<T,A>& y); 

  which can be simplified, using an exported concept map, to::

    template <LessThanComparable T, class A>
    export concept_map LessThanComparable<list<T,A> >
    {
        bool operator<(const list<T,A>& x, const list<T,A>& y) { /*...*/ }
    };

  (without exported concept maps, the intended public interface would
  be unavailable except in constrained contexts)

It remains to be seen whether either of these styles, or some other
one, will be preferred in the long run, but it is worth noting that
intentional maps need not be empty.

We expect a vast majority of concept maps to be of the intentional
variety.  That expectation is strongest where nontrivial concepts are
concerned, since the likelihood of accidentally creating a type whose
syntax and semantics exactly match those of a nontrivial concept is
very low.

Post-hoc Mapping
----------------

A type is mapped to a concept *post-hoc* when the type's creator had
no specific intention to model the concept in question.  Post-hoc
mapping can happen implicitly, as when a type happens to provide the
expected syntax and semantics for an ``auto`` concept like
``EqualityComparable``, or explicitly, via a ``concept_map``.  

While most concept mapping is intentional, post-hoc mapping is still
an important feature because it allows built-in and 3rd-party types to
model both non-``auto`` concepts and ``auto`` concepts not designed
with those types in mind.  These use cases demand that the most
general syntax for ``concept_map``\ s be non-intrusive.

Adaptive Mapping
----------------

Adaptive mapping is used to fulfill a concept's requirements that
are already expressed, but in a different form.  For example, one can
use adaptive mapping to represent the edge connectivity of a graph
using the nonzero elements of a sparse matrix (a technique used in
efficiently solving systems of equations), or an iterator over
consecutive integers using an actual ``int``::

  concept_map RandomAccessIterator<int>
  {
      int const& operator*(int const& x) { return x; }
      int operator[](int const& x, std::size_t n) { return x + n; }
      // int already supplies the other operations
  };

An adaptive ``concept_map`` is always explicitly written.  Syntax
adaptation is most commonly associated with post-hoc mapping, but can
be done intentionally as part of the map-centric style.

Because they don't have syntax with widespread acceptance, post-hoc
mapping of nontrivial concepts is highly likely to be both explicit
and adaptive.

When to Use Auto or Non-Auto Concepts?
======================================

Unfortunately, with the exception of syntactic concepts, deciding
whether to make a concept ``auto`` is not cut-and-dried.
Your users may demand protection from structural aliasing and may be
willing to pay the syntactic cost of writing empty concept maps, or
they may be intolerant of empty concept maps and willing to live with
some accidental conformance.  You may be confident that you can
predict the future of your concept hierarchy and be willing to break
your users' code in case you are wrong, or you may need to ensure that
there is room to transparently evolve your refinement hierarchy.


The Full Grid
=============

This is our analysis of how these categories of concepts and mappings
combine:

+--------------------+--------------------+--------------------+--------------------+
|            Concept:|     Syntactic      |    Foundational    |     Nontrivial     |
|                    |                    |                    |                    |
|             Mapping|                    |                    |                    |
+====================+====================+====================+====================+
|            Adaptive|rare, explicit,     |rare, explicit,     |rare, explicit,     |
|                    |nonempty            |nonempty            |nonempty            |
+--------------------+--------------------+--------------------+--------------------+
|            Post-Hoc|usually implicit and|common, usually     |rare, usually       |
|                    |empty               |implicit and empty  |explicit and        |
|                    |                    |                    |nonempty            |
+--------------------+--------------------+--------------------+--------------------+
|         Intentional|moderately rare,    |very common, usually|common, usually     |
|                    |usually implicit and|implicit and empty  |explicit and empty  |
|                    |empty               |                    |                    |
+--------------------+--------------------+--------------------+--------------------+


-----

.. [#cpppl3e] Bjarne Stroustrup, *The C++ Programming Language, Special
  Edition*, section 10.2.2, page 226

.. [#mat] Thanks to Mat Marcus for describing this style, which he
  discovered during some research work done with Jaakko Jarvi
  using ConceptGCC.

.. [#delmap] A separate mechanism (such as deleted concept maps) may
   be needed to assert that a type with a common syntax does not fit
   the usual semantic assumptions.

.. [#undefined] In general, the manifestation of
   accidental conformance within a refinement hierarchy can be any form
   of undefined behavior—see the classic problem with ``InputIterator``
   and ``ForwardIterator`` as detailed in N1798_ for a particularly bad
   example.

.. _N1798: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1798.html

.. [#explicit-refinement] Although the “explicit refinement” proposal
   attempts to forbid the declaration of non-``auto`` concepts, it
   requires roughly the same risk calculus with respect to semantic
   refinement.  One can still get all the effects of an explicit
   concept; to future-proof a concept ``MyConcept`` against hierarchy
   evolution, one would have to write::

     concept Explicit <typename T> {};

     concept MyConcept : explicit Explicit
     {
         …
     };     

   
