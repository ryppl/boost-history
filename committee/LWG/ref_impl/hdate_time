// Copyright Howard Hinnant 2007. Distributed under the Boost
// Software License, Version 1.0. (see http://www.boost.org/LICENSE_1_0.txt)

// hdate_time

#ifndef _HDATE_TIME
#define _HDATE_TIME

/*

    hdate_time synopsis

    namespace std {

    class nanoseconds
    {
    public:
        typedef long long tick_type;
    
        nanoseconds(long long ns = 0);
    
        // traits information
        static const tick_type ticks_per_second = 1000000000;
        static const tick_type seconds_per_tick = 0;
        static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;
    
        // + common functions
    
        template<typename RhsDuration>
            nanoseconds& operator-=(const RhsDuration& d);
    
        template<typename RhsDuration>
            nanoseconds& operator+=(const RhsDuration& d);
    
        nanoseconds operator-() const;
    
        nanoseconds  operator/ (int divisor) const;
        nanoseconds& operator/=(int divisor);
    
        nanoseconds  operator* (int rhs) const;
        nanoseconds& operator*=(int rhs);
    
        tick_type get_count() const;
    };

    class microseconds
    {
    public:
        typedef long long tick_type;
    
        microseconds(long long us = 0);
    
        // traits information
        static const tick_type ticks_per_second = 1000000;
        static const tick_type seconds_per_tick = 0;
        static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;
    
        // conversions
        operator nanoseconds() const;
    
        // + common functions
    
        template<typename RhsDuration>
            microseconds& operator-=(const RhsDuration& d);
    
        template<typename RhsDuration>
            microseconds& operator+=(const RhsDuration& d);
    
        microseconds operator-() const;
    
        microseconds  operator/ (int divisor) const;
        microseconds& operator/=(int divisor);
    
        microseconds  operator* (int rhs) const;
        microseconds& operator*=(int rhs);
    
        tick_type get_count() const;
    };

    class milliseconds
    {
    public:
        typedef long long tick_type;
    
        milliseconds(long long ms = 0);
    
        // traits information
        static const tick_type ticks_per_second = 1000;
        static const tick_type seconds_per_tick = 0;
        static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;
    
        // conversions
        operator nanoseconds() const;
        operator microseconds() const;
    
        // + common functions
    
        template<typename RhsDuration>
            milliseconds& operator-=(const RhsDuration& d);
    
        template<typename RhsDuration>
            milliseconds& operator+=(const RhsDuration& d);
    
        milliseconds operator-() const;
    
        milliseconds  operator/ (int divisor) const;
        milliseconds& operator/=(int divisor);
    
        milliseconds  operator* (int rhs) const;
        milliseconds& operator*=(int rhs);
    
        tick_type get_count() const;
    };

    class seconds
    {
    public:
        typedef long long tick_type;
    
        seconds(long long s = 0);
    
        // traits information
        static const tick_type ticks_per_second = 1;
        static const tick_type seconds_per_tick = 1;
        static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;
    
        // conversions
        operator nanoseconds() const;
        operator microseconds() const;
        operator milliseconds() const;
    
        // + common functions
    
        template<typename RhsDuration>
            seconds& operator-=(const RhsDuration& d);
    
        template<typename RhsDuration>
            seconds& operator+=(const RhsDuration& d);
    
        seconds operator-() const;
    
        seconds  operator/ (int divisor) const;
        seconds& operator/=(int divisor);
    
        seconds  operator* (int rhs) const;
        seconds& operator*=(int rhs);
    
        tick_type get_count() const;
    };

    class minutes
    {
    public:
        typedef long tick_type;
    
        minutes(long long mn = 0);
    
        // traits information
        static const tick_type ticks_per_second = 0;
        static const tick_type seconds_per_tick = 60;
        static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;
    
        // conversions
        operator nanoseconds() const;
        operator microseconds() const;
        operator milliseconds() const;
        operator seconds() const;
    
        // + common functions
    
        template<typename RhsDuration>
            minutes& operator-=(const RhsDuration& d);
    
        template<typename RhsDuration>
            minutes& operator+=(const RhsDuration& d);
    
        minutes operator-() const;
    
        minutes  operator/ (int divisor) const;
        minutes& operator/=(int divisor);
    
        minutes  operator* (int rhs) const;
        minutes& operator*=(int rhs);
    
        tick_type get_count() const;
    };

    class hours
    {
    public:
        typedef long tick_type;
    
        hours(long long hr = 0);
    
        // traits information
        static const tick_type ticks_per_second = 0;
        static const tick_type seconds_per_tick = 3600;
        static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;
    
        // conversions
        operator nanoseconds() const;
        operator microseconds() const;
        operator milliseconds() const;
        operator seconds() const;
        operator minutes() const;
    
        // + common functions
    
        template<typename RhsDuration>
            hours& operator-=(const RhsDuration& d);
    
        template<typename RhsDuration>
            hours& operator+=(const RhsDuration& d);
    
        hours operator-() const;
    
        hours  operator/ (int divisor) const;
        hours& operator/=(int divisor);
    
        hours  operator* (int rhs) const;
        hours& operator*=(int rhs);
    
        tick_type get_count() const;
    };

    template <class LhsDuration, class RhsDuration>
      bool operator==(const LhsDuration& lhs, const RhsDuration& rhs);
    template <class LhsDuration, class RhsDuration>
      bool operator!=(const LhsDuration& lhs, const RhsDuration& rhs);

    template <class LhsDuration, class RhsDuration>
      bool operator< (const LhsDuration& lhs, const RhsDuration& rhs);
    template <class LhsDuration, class RhsDuration>
      bool operator<=(const LhsDuration& lhs, const RhsDuration& rhs);
    template <class LhsDuration, class RhsDuration>
      bool operator> (const LhsDuration& lhs, const RhsDuration& rhs);
    template <class LhsDuration, class RhsDuration>
      bool operator>=(const LhsDuration& lhs, const RhsDuration& rhs);

    template <class LhsDuration, class RhsDuration>
      <see note> operator+(const LhsDuration& lhs, const RhsDuration& rhs)
    template <class LhsDuration, class RhsDuration>
      <see note> operator-(const LhsDuration& lhs, const RhsDuration& rhs)

    class system_time
    {
    public:
        typedef long long tick_type;
    
        system_time();
        system_time(time_t secs, nanoseconds ns);
    
        time_t seconds_since_epoch() const;
        nanoseconds nanoseconds_since_epoch() const;
    
        // traits
        static const tick_type ticks_per_second = 1000000000;
        static const tick_type seconds_per_tick = 0;
        static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;
    
        // comparison functions
        bool operator==(const system_time& rhs) const;
        bool operator!=(const system_time& rhs) const;
        bool operator> (const system_time& rhs) const;
        bool operator>=(const system_time& rhs) const;
        bool operator< (const system_time& rhs) const;
        bool operator<=(const system_time& rhs) const;
    
        // arithmetic functions
        nanoseconds operator-(const system_time& rhs) const;
    
        template<typename Duration>
            system_time operator+(const Duration& td) const;
    
        template<typename Duration>
            system_time& operator+=(const Duration& td);
    
        template<typename Duration>
            system_time operator-(const Duration& td) const;
    
        template<typename Duration>
            system_time& operator-=(const Duration& td);
    
    };
    
    template<typename Duration> system_time operator+(const Duration& td, const system_time& rhs);

    system_time get_system_time();

    }
    
*/

#include <ctime>
#include <type_traits>

namespace std {

template <class T>
class __has_tick_type
{
	struct two {char x; char y;};
	template <class U> static two  test(...);
	template <class U> static char test(typename U::tick_type*);
public:
	static const bool value = sizeof(test<T>(0)) == 1;
};

template <class T, T val>
struct __member_wrapper{};

template <class T>
class __has_get_count
{
	struct two {char x; char y;};
	template <class U> static two  test(...);
	template <class U> static char test(__member_wrapper<typename U::tick_type (U::*)() const, &U::get_count>*);
public:
	static const bool value = sizeof(test<T>(0)) == 1;
};

template <class T>
class __is_duration
{
public:
	static const bool value = __has_tick_type<T>::value &&
	                          __has_get_count<T>::value &&
	                          stb::is_convertible<long long, T>::value;
};

class nanoseconds
{
public:
    typedef long long tick_type;
private:
    tick_type ns_;
public:
    nanoseconds(long long ns = 0) : ns_(ns) {}

    // traits information
    static const tick_type ticks_per_second = 1000000000;
    static const tick_type seconds_per_tick = 0;
    static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;

    // + common functions

    template<typename RhsDuration>
        nanoseconds& operator-=(const RhsDuration& d);

    template<typename RhsDuration>
        nanoseconds& operator+=(const RhsDuration& d);

    nanoseconds operator-() const {return -ns_;}

    nanoseconds  operator/ (int divisor) const {return ns_ / divisor;}
    nanoseconds& operator/=(int divisor)       {ns_ /= divisor; return *this;}

    nanoseconds  operator* (int rhs) const {return ns_ * rhs;}
    nanoseconds& operator*=(int rhs)       {ns_ *= rhs; return *this;}

    tick_type get_count() const {return ns_;}
};

class microseconds
{
public:
    typedef long long tick_type;
private:
    tick_type us_;
public:
    microseconds(long long us = 0) : us_(us) {}

    // traits information
    static const tick_type ticks_per_second = 1000000;
    static const tick_type seconds_per_tick = 0;
    static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;

    // conversions
    operator nanoseconds() const  {return us_ * 1000LL;}

    // + common functions

    template<typename RhsDuration>
        microseconds& operator-=(const RhsDuration& d);

    template<typename RhsDuration>
        microseconds& operator+=(const RhsDuration& d);

    microseconds operator-() const {return -us_;}

    microseconds  operator/ (int divisor) const {return us_ / divisor;}
    microseconds& operator/=(int divisor)       {us_ /= divisor; return *this;}

    microseconds  operator* (int rhs) const {return us_ * rhs;}
    microseconds& operator*=(int rhs)       {us_ *= rhs; return *this;}

    tick_type get_count() const {return us_;}
};

class milliseconds
{
public:
    typedef long long tick_type;
private:
    tick_type ms_;
public:
    milliseconds(long long ms = 0) : ms_(ms) {}

    // traits information
    static const tick_type ticks_per_second = 1000;
    static const tick_type seconds_per_tick = 0;
    static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;

    // conversions
    operator nanoseconds() const  {return ms_ * 1000000LL;}
    operator microseconds() const {return ms_ * 1000LL;}

    // + common functions

    template<typename RhsDuration>
        milliseconds& operator-=(const RhsDuration& d);

    template<typename RhsDuration>
        milliseconds& operator+=(const RhsDuration& d);

    milliseconds operator-() const {return -ms_;}

    milliseconds  operator/ (int divisor) const {return ms_ / divisor;}
    milliseconds& operator/=(int divisor)       {ms_ /= divisor; return *this;}

    milliseconds  operator* (int rhs) const {return ms_ * rhs;}
    milliseconds& operator*=(int rhs)       {ms_ *= rhs; return *this;}

    tick_type get_count() const {return ms_;}
};

class seconds
{
public:
    typedef long long tick_type;
private:
    tick_type s_;
public:
    seconds(long long s = 0) : s_(s) {}

    // traits information
    static const tick_type ticks_per_second = 1;
    static const tick_type seconds_per_tick = 1;
    static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;

    // conversions
    operator nanoseconds() const  {return s_ * 1000000000LL;}
    operator microseconds() const {return s_ * 1000000LL;}
    operator milliseconds() const {return s_ * 1000LL;}

    // + common functions

    template<typename RhsDuration>
        seconds& operator-=(const RhsDuration& d);

    template<typename RhsDuration>
        seconds& operator+=(const RhsDuration& d);

    seconds operator-() const {return -s_;}

    seconds  operator/ (int divisor) const {return s_ / divisor;}
    seconds& operator/=(int divisor)       {s_ /= divisor; return *this;}

    seconds  operator* (int rhs) const {return s_ * rhs;}
    seconds& operator*=(int rhs)       {s_ *= rhs; return *this;}

    tick_type get_count() const {return s_;}
};

class minutes
{
public:
    typedef long tick_type;
private:
    tick_type mn_;
public:
    minutes(long long mn = 0) : mn_(static_cast<tick_type>(mn)) {}

    // traits information
    static const tick_type ticks_per_second = 0;
    static const tick_type seconds_per_tick = 60;
    static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;

    // conversions
    operator nanoseconds() const  {return mn_ * 60000000000LL;}
    operator microseconds() const {return mn_ * 60000000LL;}
    operator milliseconds() const {return mn_ * 60000LL;}
    operator seconds() const      {return mn_ * 60LL;}

    // + common functions

    template<typename RhsDuration>
        minutes& operator-=(const RhsDuration& d);

    template<typename RhsDuration>
        minutes& operator+=(const RhsDuration& d);

    minutes operator-() const {return -mn_;}

    minutes  operator/ (int divisor) const {return mn_ / divisor;}
    minutes& operator/=(int divisor)       {mn_ /= divisor; return *this;}

    minutes  operator* (int rhs) const {return mn_ * rhs;}
    minutes& operator*=(int rhs)       {mn_ *= rhs; return *this;}

    tick_type get_count() const {return mn_;}
};

class hours
{
public:
    typedef long tick_type;
private:
    tick_type hr_;
public:
    hours(long long hr = 0) : hr_(static_cast<tick_type>(hr)) {}

    // traits information
    static const tick_type ticks_per_second = 0;
    static const tick_type seconds_per_tick = 3600;
    static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;

    // conversions
    operator nanoseconds() const  {return hr_ * 3600000000000LL;}
    operator microseconds() const {return hr_ * 3600000000LL;}
    operator milliseconds() const {return hr_ * 3600000LL;}
    operator seconds() const      {return hr_ * 3600LL;}
    operator minutes() const      {return hr_ * 60LL;}

    // + common functions

    template<typename RhsDuration>
        hours& operator-=(const RhsDuration& d);

    template<typename RhsDuration>
        hours& operator+=(const RhsDuration& d);

    hours operator-() const {return -hr_;}

    hours  operator/ (int divisor) const {return hr_ / divisor;}
    hours& operator/=(int divisor)       {hr_ /= divisor; return *this;}

    hours  operator* (int rhs) const {return hr_ * rhs;}
    hours& operator*=(int rhs)       {hr_ *= rhs; return *this;}

    tick_type get_count() const {return hr_;}
};

template <class To>
struct __make
{
    template <class Duration>
    static
    To
    from(const Duration& t)
    {
        long long r;
        if (To::Duration::is_subsecond && Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * To::ticks_per_second / Duration::ticks_per_second);
        }
        else if (!To::Duration::is_subsecond && Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() / To::ticks_per_second / Duration::ticks_per_second);
        }
        else if (To::Duration::is_subsecond && !Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * To::ticks_per_second * Duration::ticks_per_second);
        }
        else // if (!To::Duration::is_subsecond && !Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * Duration::ticks_per_second / To::ticks_per_second);
        }
        return r;
    }
};

template <>
struct __make<nanoseconds>
{
    template <class Duration>
    static
    nanoseconds
    from(const Duration& t)
    {
        long long r;
        if (Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * nanoseconds::ticks_per_second / Duration::ticks_per_second);
        }
        else // if (!Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * nanoseconds::ticks_per_second * Duration::ticks_per_second);
        }
        return r;
    }

    static
    nanoseconds
    from(const hours& t)
    {
        return t.get_count() * 3600000000000LL;
    }

    static
    nanoseconds
    from(const minutes& t)
    {
        return t.get_count() * 60000000000LL;
    }

    static
    nanoseconds
    from(const seconds& t)
    {
        return t.get_count() * 1000000000LL;
    }

    static
    nanoseconds
    from(const milliseconds& t)
    {
        return t.get_count() * 1000000LL;
    }

    static
    nanoseconds
    from(const microseconds& t)
    {
        return t.get_count() * 1000LL;
    }

    static
    nanoseconds
    from(const nanoseconds& t)
    {
        return t.get_count();
    }

};

template <>
struct __make<microseconds>
{
    template <class Duration>
    static
    microseconds
    from(const Duration& t)
    {
        long long r;
        if (Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * microseconds::ticks_per_second / Duration::ticks_per_second);
        }
        else // if (!Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * microseconds::ticks_per_second * Duration::ticks_per_second);
        }
        return r;
    }

    static
    microseconds
    from(const hours& t)
    {
        return t.get_count() * 3600000000LL;
    }

    static
    microseconds
    from(const minutes& t)
    {
        return t.get_count() * 60000000LL;
    }

    static
    microseconds
    from(const seconds& t)
    {
        return t.get_count() * 1000000LL;
    }

    static
    microseconds
    from(const milliseconds& t)
    {
        return t.get_count() * 1000LL;
    }

    static
    microseconds
    from(const microseconds& t)
    {
        return t.get_count();
    }

    static
    microseconds
    from(const nanoseconds& t)
    {
        return t.get_count() / 1000LL;
    }

};

template <>
struct __make<milliseconds>
{
    template <class Duration>
    static
    milliseconds
    from(const Duration& t)
    {
        long long r;
        if (Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * milliseconds::ticks_per_second / Duration::ticks_per_second);
        }
        else // if (!Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * milliseconds::ticks_per_second * Duration::ticks_per_second);
        }
        return r;
    }

    static
    milliseconds
    from(const hours& t)
    {
        return t.get_count() * 3600000LL;
    }

    static
    milliseconds
    from(const minutes& t)
    {
        return t.get_count() * 60000LL;
    }

    static
    milliseconds
    from(const seconds& t)
    {
        return t.get_count() * 1000LL;
    }

    static
    milliseconds
    from(const milliseconds& t)
    {
        return t.get_count();
    }

    static
    milliseconds
    from(const microseconds& t)
    {
        return t.get_count() / 1000LL;
    }

    static
    milliseconds
    from(const nanoseconds& t)
    {
        return t.get_count() / 1000000LL;
    }

};

template <>
struct __make<seconds>
{
    template <class Duration>
    static
    seconds
    from(const Duration& t)
    {
        long long r;
        if (Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() / Duration::ticks_per_second);
        }
        else // if (!Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * Duration::ticks_per_second);
        }
        return r;
    }

    static
    seconds
    from(const hours& t)
    {
        return t.get_count() * 3600LL;
    }

    static
    seconds
    from(const minutes& t)
    {
        return t.get_count() * 60LL;
    }

    static
    seconds
    from(const seconds& t)
    {
        return t.get_count();
    }

    static
    seconds
    from(const milliseconds& t)
    {
        return t.get_count() / 1000LL;
    }

    static
    seconds
    from(const microseconds& t)
    {
        return t.get_count() / 1000000LL;
    }

    static
    seconds
    from(const nanoseconds& t)
    {
        return t.get_count() / 1000000000LL;
    }

};

template <>
struct __make<minutes>
{
    template <class Duration>
    static
    minutes
    from(const Duration& t)
    {
        long long r;
        if (Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() / minutes::ticks_per_second / Duration::ticks_per_second);
        }
        else // if (!Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * Duration::ticks_per_second / minutes::ticks_per_second);
        }
        return r;
    }

    static
    minutes
    from(const hours& t)
    {
        return t.get_count() * 60LL;
    }

    static
    minutes
    from(const minutes& t)
    {
        return t.get_count();
    }

    static
    minutes
    from(const seconds& t)
    {
        return t.get_count() / 60LL;
    }

    static
    minutes
    from(const milliseconds& t)
    {
        return t.get_count() / 60000LL;
    }

    static
    minutes
    from(const microseconds& t)
    {
        return t.get_count() / 60000000LL;
    }

    static
    minutes
    from(const nanoseconds& t)
    {
        return t.get_count() / 60000000000LL;
    }

};

template <>
struct __make<hours>
{
    template <class Duration>
    static
    hours
    from(const Duration& t)
    {
        long long r;
        if (Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() / hours::ticks_per_second / Duration::ticks_per_second);
        }
        else // if (!Duration::is_subsecond)
        {
            r = static_cast<long long>(t.get_count() * Duration::ticks_per_second / hours::ticks_per_second);
        }
        return r;
    }

    static
    hours
    from(const hours& t)
    {
        return t.get_count();
    }

    static
    hours
    from(const minutes& t)
    {
        return t.get_count() / 60LL;
    }

    static
    hours
    from(const seconds& t)
    {
        return t.get_count() / 3600LL;
    }

    static
    hours
    from(const milliseconds& t)
    {
        return t.get_count() / 3600000LL;
    }

    static
    hours
    from(const microseconds& t)
    {
        return t.get_count() / 3600000000LL;
    }

    static
    hours
    from(const nanoseconds& t)
    {
        return t.get_count() / 3600000000000LL;
    }

};

template <class LhsDuration, class RhsDuration,
    bool = LhsDuration::is_subsecond, bool = RhsDuration::is_subsecond>
struct __compare_resolution  // <LhsDuration, RhsDuration, true, true>
{
    static const bool value = LhsDuration::ticks_per_second >= RhsDuration::ticks_per_second;
};

template <class LhsDuration, class RhsDuration>
struct __compare_resolution<LhsDuration, RhsDuration, true, false>
{
    static const bool value = true;
};

template <class LhsDuration, class RhsDuration>
struct __compare_resolution<LhsDuration, RhsDuration, false, true>
{
    static const bool value = false;
};

template <class LhsDuration, class RhsDuration>
struct __compare_resolution<LhsDuration, RhsDuration, false, false>
{
    static const bool value = LhsDuration::seconds_per_tick <= RhsDuration::seconds_per_tick;
};

// Duration ==

template <class LhsDuration, class RhsDuration>
inline
bool
__duration_eq(const LhsDuration& lhs, const RhsDuration& rhs, true_type)
{
    return lhs.get_count() == __make<LhsDuration>::from(rhs).get_count();
}

template <class LhsDuration, class RhsDuration>
inline
bool
__duration_eq(const LhsDuration& lhs, const RhsDuration& rhs, false_type)
{
    return __make<RhsDuration>::from(lhs).get_count() == rhs.get_count();
}

template <class LhsDuration, class RhsDuration>
inline
typename enable_if
<
    __is_duration<LhsDuration>::value &&
    __is_duration<RhsDuration>::value,
    bool
>::type
operator==(const LhsDuration& lhs, const RhsDuration& rhs)
{
    return __duration_eq(lhs, rhs, integral_constant<bool, __compare_resolution<LhsDuration, RhsDuration>::value>());
}

// Duration !=

template <class LhsDuration, class RhsDuration>
inline
typename enable_if
<
    __is_duration<LhsDuration>::value &&
    __is_duration<RhsDuration>::value,
    bool
>::type
operator!=(const LhsDuration& lhs, const RhsDuration& rhs)
{
    return !(lhs == rhs);
}

// Duration <

template <class LhsDuration, class RhsDuration>
inline
bool
__duration_lt(const LhsDuration& lhs, const RhsDuration& rhs, true_type)
{
    return lhs.get_count() < __make<LhsDuration>::from(rhs).get_count();
}

template <class LhsDuration, class RhsDuration>
inline
bool
__duration_lt(const LhsDuration& lhs, const RhsDuration& rhs, false_type)
{
    return __make<RhsDuration>::from(lhs).get_count() < rhs.get_count();
}

template <class LhsDuration, class RhsDuration>
inline
typename enable_if
<
    __is_duration<LhsDuration>::value &&
    __is_duration<RhsDuration>::value,
    bool
>::type
operator< (const LhsDuration& lhs, const RhsDuration& rhs)
{
    return __duration_lt(lhs, rhs, integral_constant<bool, __compare_resolution<LhsDuration, RhsDuration>::value>());
}

// Duration >

template <class LhsDuration, class RhsDuration>
inline
typename enable_if
<
    __is_duration<LhsDuration>::value &&
    __is_duration<RhsDuration>::value,
    bool
>::type
operator> (const LhsDuration& lhs, const RhsDuration& rhs)
{
    return rhs < lhs;
}

// Duration <=

template <class LhsDuration, class RhsDuration>
inline
typename enable_if
<
    __is_duration<LhsDuration>::value &&
    __is_duration<RhsDuration>::value,
    bool
>::type
operator<=(const LhsDuration& lhs, const RhsDuration& rhs)
{
    return !(rhs < lhs);
}

// Duration <=

template <class LhsDuration, class RhsDuration>
inline
typename enable_if
<
    __is_duration<LhsDuration>::value &&
    __is_duration<RhsDuration>::value,
    bool
>::type
operator>=(const LhsDuration& lhs, const RhsDuration& rhs)
{
    return !(lhs < rhs);
}

template<typename RhsDuration>
inline
nanoseconds& nanoseconds::operator-=(const RhsDuration& d)
    {ns_ -= __make<nanoseconds>::from(d).get_count(); return *this;}

template<typename RhsDuration>
inline
nanoseconds& nanoseconds::operator+=(const RhsDuration& d)
    {ns_ += __make<nanoseconds>::from(d).get_count(); return *this;}

template<typename RhsDuration>
inline
microseconds& microseconds::operator-=(const RhsDuration& d)
    {us_ -= __make<microseconds>::from(d).get_count(); return *this;}

template<typename RhsDuration>
inline
microseconds& microseconds::operator+=(const RhsDuration& d)
    {us_ += __make<microseconds>::from(d).get_count(); return *this;}

template<typename RhsDuration>
inline
milliseconds& milliseconds::operator-=(const RhsDuration& d)
    {ms_ -= __make<milliseconds>::from(d).get_count(); return *this;}

template<typename RhsDuration>
inline
milliseconds& milliseconds::operator+=(const RhsDuration& d)
    {ms_ += __make<milliseconds>::from(d).get_count(); return *this;}

template<typename RhsDuration>
inline
seconds& seconds::operator-=(const RhsDuration& d)
    {s_ -= __make<seconds>::from(d).get_count(); return *this;}

template<typename RhsDuration>
inline
seconds& seconds::operator+=(const RhsDuration& d)
    {s_ += __make<seconds>::from(d).get_count(); return *this;}

template<typename RhsDuration>
inline
minutes& minutes::operator-=(const RhsDuration& d)
    {mn_ -= __make<minutes>::from(d).get_count(); return *this;}


template<typename RhsDuration>
inline
minutes& minutes::operator+=(const RhsDuration& d)
    {mn_ += __make<minutes>::from(d).get_count(); return *this;}

template<typename RhsDuration>
inline
hours& hours::operator-=(const RhsDuration& d)
    {hr_ -= __make<hours>::from(d).get_count(); return *this;}

template<typename RhsDuration>
inline
hours& hours::operator+=(const RhsDuration& d)
    {hr_ += __make<hours>::from(d).get_count(); return *this;}

template <class LhsDuration, class RhsDuration, bool = __compare_resolution<LhsDuration, RhsDuration>::value>
struct __compute_promotion
{
    typedef LhsDuration type;
};

template <class LhsDuration, class RhsDuration>
struct __compute_promotion<LhsDuration, RhsDuration, false>
{
    typedef RhsDuration type;
};

template <bool, class U>
struct __short_circut_and_imp
{
    static const bool value = U::value;
};

template <class U>
struct __short_circut_and_imp<false, U>
{
    static const bool value = false;
};

template <class T, class U>
struct __short_circut_and
{
    static const bool value = __short_circut_and_imp<T::value, U>::value;
};

template <class LhsDuration, class RhsDuration, bool = __short_circut_and<__is_duration<RhsDuration>,
                                                                          __is_duration<LhsDuration>>::value>
struct __promote_duration
{
};

template <class LhsDuration, class RhsDuration>
struct __promote_duration<LhsDuration, RhsDuration, true>
{
    typedef typename __compute_promotion<LhsDuration, RhsDuration>::type type;
};

// Duration +

template <class LhsDuration, class RhsDuration>
inline
typename __promote_duration<LhsDuration, RhsDuration>::type
__duration_plus(const LhsDuration& lhs, const RhsDuration& rhs, true_type)
{
    LhsDuration r(lhs);
    r += rhs;
    return r;
}

template <class LhsDuration, class RhsDuration>
inline
typename __promote_duration<LhsDuration, RhsDuration>::type
__duration_plus(const LhsDuration& lhs, const RhsDuration& rhs, false_type)
{
    RhsDuration r(rhs);
    r += lhs;
    return r;
}

template <class LhsDuration, class RhsDuration>
inline
typename __promote_duration<LhsDuration, RhsDuration>::type
operator+(const LhsDuration& lhs, const RhsDuration& rhs)
{
    return __duration_plus(lhs, rhs, integral_constant<bool, __compare_resolution<LhsDuration, RhsDuration>::value>());
}

// Duration -

template <class LhsDuration, class RhsDuration>
inline
typename __promote_duration<LhsDuration, RhsDuration>::type
__duration_subtract(const LhsDuration& lhs, const RhsDuration& rhs, true_type)
{
    LhsDuration r(lhs);
    r -= rhs;
    return r;
}

template <class LhsDuration, class RhsDuration>
inline
typename __promote_duration<LhsDuration, RhsDuration>::type
__duration_subtract(const LhsDuration& lhs, const RhsDuration& rhs, false_type)
{
    RhsDuration r = __make<RhsDuration>::from(lhs);
    r -= rhs;
    return r;
}

template <class LhsDuration, class RhsDuration>
inline
typename __promote_duration<LhsDuration, RhsDuration>::type
operator-(const LhsDuration& lhs, const RhsDuration& rhs)
{
    return __duration_subtract(lhs, rhs, integral_constant<bool, __compare_resolution<LhsDuration, RhsDuration>::value>());
}


class system_time
{
public:
    typedef long long tick_type;
private:
    tick_type ns_;
public:

    system_time() : ns_(0) {}
    system_time(time_t secs, nanoseconds ns)
        : ns_(secs * 1000000000LL + ns.get_count()) {}

    // ~system_time() = default;

    time_t seconds_since_epoch() const { return static_cast<time_t>(ns_ / 1000000000);}
    nanoseconds nanoseconds_since_epoch() const {return static_cast<nanoseconds>(ns_);}

    // traits
    static const tick_type ticks_per_second = 1000000000;
    static const tick_type seconds_per_tick = 0;
    static const bool is_subsecond = ticks_per_second > 0 && seconds_per_tick == 0;

    // comparison functions
    bool operator==(const system_time& rhs) const {return ns_ == rhs.ns_;}
    bool operator!=(const system_time& rhs) const {return ns_ != rhs.ns_;}
    bool operator> (const system_time& rhs) const {return ns_ >  rhs.ns_;}
    bool operator>=(const system_time& rhs) const {return ns_ >= rhs.ns_;}
    bool operator< (const system_time& rhs) const {return ns_ <  rhs.ns_;}
    bool operator<=(const system_time& rhs) const {return ns_ <= rhs.ns_;}

    // arithmetic functions
    nanoseconds operator-(const system_time& rhs) const {return ns_ - rhs.ns_;}

    template<typename Duration>
        system_time operator+(const Duration& td) const {system_time t(*this); t += td; return t;}

    template<typename Duration>
        system_time& operator+=(const Duration& td) {ns_ += __make<nanoseconds>::from(td).get_count(); return *this;}

    template<typename Duration>
        system_time operator-(const Duration& td) const {system_time t(*this); t -= td; return t;}

    template<typename Duration>
    system_time& operator-=(const Duration& td) {ns_ -= __make<nanoseconds>::from(td).get_count(); return *this;}

};

template<typename Duration>
inline
typename enable_if
<
    __is_duration<Duration>::value,
    system_time
>::type
operator+(const Duration& td, const system_time& rhs)
    {system_time t(rhs); t += td; return t;}

system_time get_system_time();

}

#endif
