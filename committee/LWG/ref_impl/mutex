// Copyright Howard Hinnant 2007. Distributed under the Boost
// Software License, Version 1.0. (see http://www.boost.org/LICENSE_1_0.txt)

// mutex

#ifndef _MUTEX
#define _MUTEX

/*
    mutex synopsis

    namespace std {

    struct mutex
    {
    public:
        mutex();
        ~mutex();
    
        mutex(const mutex&) = delete;
        mutex& operator=(const mutex&) = delete;

        void lock();
        bool try_lock();
        void unlock();

        typedef unspecified native_handle_type;  // optional.  example: pthread_mutex_t*
        native_handle_type native_handle();      // optional
    };

    struct recursive_mutex
    {
    public:
        recursive_mutex();
        ~recursive_mutex();
    
        recursive_mutex(const recursive_mutex&) = delete;
        recursive_mutex& operator=(const recursive_mutex&) = delete;

        void lock();
        bool try_lock();
        void unlock();

        typedef unspecified native_handle_type;  // optional.  example: pthread_mutex_t*
        native_handle_type native_handle();      // optional
    };

    struct timed_mutex
    {
    public:
        timed_mutex();
        ~timed_mutex();
    
        timed_mutex(const timed_mutex&) = delete;
        timed_mutex& operator=(const timed_mutex&) = delete;

        void lock();
        bool try_lock();
        template <class elapsed_time>
            bool timed_lock(const elapsed_time& rel_time);
        bool timed_lock(const system_time& abs_time);
        void unlock();

        typedef unspecified native_handle_type;  // optional.  example: pthread_mutex_t*
        native_handle_type native_handle();      // optional
    };

    struct recursive_timed_mutex
    {
    public:
        recursive_timed_mutex();
        ~recursive_timed_mutex();
    
        recursive_timed_mutex(const recursive_timed_mutex&) = delete;
        recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

        void lock();
        bool try_lock();
        template <class elapsed_time>
            bool timed_lock(const elapsed_time& rel_time);
        bool timed_lock(const system_time& abs_time);
        void unlock();

        typedef unspecified native_handle_type;  // optional.  example: pthread_mutex_t*
        native_handle_type native_handle();      // optional
    };

    struct defer_lock_t  {};
    struct try_to_lock_t {};
    struct adopt_lock_t  {};
    
    extern const defer_lock_t  defer_lock;
    extern const try_to_lock_t try_to_lock;
    extern const adopt_lock_t  adopt_lock;
    
    class lock_error
        : public std::exception
    {
    public:
        virtual const char* what() const throw();
    };

    template <class Mutex>
    class lock_guard
    {
    public:
        typedef Mutex mutex_type;

        explicit lock_guard(mutex_type& m);
        lock_guard(mutex_type& m, adopt_lock_t);
        ~lock_guard();

        lock_guard(lock_guard const&) = delete;
        lock_guard& operator=(lock_guard const&) = delete;

        mutex_type* mutex() const;
    };

    template <class Mutex>
    class unique_lock
    {
    public:
        typedef Mutex mutex_type;

        unique_lock();
        explicit unique_lock(mutex_type& m);
        unique_lock(mutex_type& m, defer_lock_t);
        unique_lock(mutex_type& m, try_to_lock_t);
        unique_lock(mutex_type& m, adopt_lock_t);
        unique_lock(mutex_type& m, const system_time& abs_time);
        template <class Duration>
            unique_lock(mutex_type& m, const Duration& rel_t);
        ~unique_lock();

        unique_lock(unique_lock const&) = delete;
        unique_lock& operator=(unique_lock const&) = delete;

        unique_lock(unique_lock&& u);
        unique_lock& operator=(unique_lock&& u);

        void lock();
        bool try_lock();
        template <class Duration>
            bool timed_lock(const Duration& rel_t);
        bool timed_lock(const system_time& abs_time);
        void unlock();
    
        bool owns() const;
        operator unspecified-bool-type () const;
        mutex_type* mutex() const;
    
        void swap(unique_lock&& u);
        mutex_type* release();
    };
    
    template <class Mutex> void swap(unique_lock<Mutex>&  x, unique_lock<Mutex>&  y);
    template <class Mutex> void swap(unique_lock<Mutex>&& x, unique_lock<Mutex>&  y);
    template <class Mutex> void swap(unique_lock<Mutex>&  x, unique_lock<Mutex>&& y);

    template <class L1, class L2, class ...L3> int try_lock(L1&, L2&, L3&...);
    template <class L1, class L2, class ...L3> void lock(L1&, L2&, L3&...);

    struct once_flag
    {
        constexpr once_flag();
    
        once_flag(const once_flag&) = delete;
        once_flag& operator=(const once_flag&) = delete;
    };
    
    template<class Callable, class ...Args>
        void call_once(once_flag& flag, Callable func, Args&&... args);


    }  // std
*/

#include <mutex_base>
#include <condition_variable>
#include <hdate_time>
#include <functional>
#include <csignal>

namespace std
{

class timed_mutex
{
    mutex              mut_;
    condition_variable gate1_;
    bool               locked_;

    timed_mutex(const timed_mutex&); // = delete;
    timed_mutex& operator=(const timed_mutex&);  // = delete;
public:

    timed_mutex();
    // ~timed_mutex() = default;

    void lock();
    bool try_lock();
    template <class Duration>
        bool timed_lock(const Duration& rel_time,
                        typename enable_if<__is_duration<Duration>::value>::type* =0)
            {return timed_lock(get_system_time() + rel_time);}
    bool timed_lock(const system_time& abs_time);
    void unlock();
};

class recursive_timed_mutex
{
    mutex               mut_;
    condition_variable  gate1_;
    unsigned            state_;
    pthread_t           id_;

    recursive_timed_mutex(const recursive_timed_mutex&); // = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&);  // = delete;
public:

    recursive_timed_mutex();
    // ~recursive_timed_mutex() = default;

    void lock();
    bool try_lock();
    template <class Duration>
        bool timed_lock(const Duration& rel_time,
                        typename enable_if<__is_duration<Duration>::value>::type* =0)
            {return timed_lock(get_system_time() + rel_time);}
    bool timed_lock(const system_time& abs_time);
    void unlock();
};

// This is a variation of the Mike Burrows fast_pthread_once algorithm

// Copyright (c) 2007, Google Inc. 
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
// 	*	Redistributions of source code must retain the above copyright
// 	notice, this list of conditions and the following disclaimer.
// 	*	Redistributions in binary form must reproduce the above
// 	copyright notice, this list of conditions and the following
// 	disclaimer in the documentation and/or other materials provided with
// 	the distribution.
// 	*	Neither the name of Google Inc. nor the names
// 	of its contributors may be used to endorse or promote products
// 	derived from this software without specific prior written
// 	permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// once_flag should be a simple class with a constexpr default ctor setting a sig_atomic_t to 0
typedef sig_atomic_t once_flag;

once_flag __get_once_per_thread_epoch();
void      __set_once_per_thread_epoch(once_flag flag);
once_flag& __get_call_once_global_epoch();
extern pthread_mutex_t __call_once_mut;
extern pthread_cond_t __call_once_cv;

template <class F>
void
__call_once(once_flag& flag, F f)
{
    once_flag x = flag;
    if (x < __get_once_per_thread_epoch())
    {
        pthread_mutex_lock(&__call_once_mut);
        while (flag == once_flag(1))
            pthread_cond_wait(&__call_once_cv, &__call_once_mut);
        once_flag& global_epoch = __get_call_once_global_epoch();
        if (flag == once_flag(0))
        {
            flag = once_flag(1);
            pthread_mutex_unlock(&__call_once_mut);
            try
            {
                f();
            }
            catch (...)
            {
                pthread_mutex_lock(&__call_once_mut);
                flag = once_flag(0);
                pthread_mutex_unlock(&__call_once_mut);
                pthread_cond_broadcast(&__call_once_cv);
                throw;
            }
            pthread_mutex_lock(&__call_once_mut);
            flag = global_epoch;
            --global_epoch;
            pthread_cond_broadcast(&__call_once_cv);
        }
        __set_once_per_thread_epoch(global_epoch);
        pthread_mutex_unlock(&__call_once_mut);
    }
}

template <class F>
inline
void
call_once(once_flag& flag, F&& func)
{
    if (flag < __get_once_per_thread_epoch())
        __call_once(flag, std::forward<F>(func));
}

template<class F, class Arg0, class ...Args>
inline
void
call_once(once_flag& flag, F&& func, Arg0&& arg0, Args&&... args)
{
    if (flag < __get_once_per_thread_epoch())
        __call_once(flag, bind(std::forward<F>(func), std::forward<Arg0>(arg0), std::forward<Args>(args)...));
}

}  // std

#endif
