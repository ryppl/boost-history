// Copyright Howard Hinnant 2007. Distributed under the Boost
// Software License, Version 1.0. (see http://www.boost.org/LICENSE_1_0.txt)

// mutex_base

#ifndef _MUTEX_BASE
#define _MUTEX_BASE

#include <pthread.h>
#include <stdexcept>
#include <hdate_time>
#include <type_traits>

namespace std
{

class mutex
{
    pthread_mutex_t m_;

public:
    mutex();
    ~mutex();

    private: mutex(const mutex&); public : // = delete;
    private: mutex& operator=(const mutex&); public : // = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef pthread_mutex_t* native_handle_type;
    native_handle_type native_handle() {return &m_;}
};

class recursive_mutex
{
    pthread_mutex_t m_;

public:
    recursive_mutex();
    ~recursive_mutex();

    private: recursive_mutex(const recursive_mutex&); public : // = delete;
    private: recursive_mutex& operator=(const recursive_mutex&); public : // = delete;

    void lock();
    bool try_lock();
    void unlock();

    typedef pthread_mutex_t* native_handle_type;
    native_handle_type native_handle() {return &m_;}
};

struct defer_lock_t  {};
struct try_to_lock_t {};
struct adopt_lock_t  {};

extern const defer_lock_t  defer_lock;
extern const try_to_lock_t try_to_lock;
extern const adopt_lock_t  adopt_lock;

class lock_error
    : public std::exception
{
public:
    virtual const char* what() const throw() {return "lock_error";}
};

template <class Mutex>
class lock_guard
{
public:
    typedef Mutex mutex_type;
private:
    mutex_type& m_;

public:
    explicit lock_guard(mutex_type& m) : m_(m) {m_.lock();}
    lock_guard(mutex_type& m, adopt_lock_t) : m_(m) {}
    ~lock_guard() {m_.unlock();}

private:
    lock_guard(lock_guard const&);// = delete;
    lock_guard& operator=(lock_guard const&);// = delete;
};

template <class Mutex>
class unique_lock
{
public:
    typedef Mutex mutex_type;
private:
    mutex_type* m_;
    bool owns_lock_;

    unique_lock(unique_lock const&);// = delete;
    unique_lock& operator=(unique_lock const&);// = delete;

    struct __nat {int _;};

public:
    unique_lock()
        : m_(0),
          owns_lock_(false)
    {}

    explicit unique_lock(mutex_type& m)
        : m_(&m),
          owns_lock_(true)
    {
        m_->lock();
    }

    unique_lock(mutex_type& m, defer_lock_t)
        : m_(&m),
          owns_lock_(false)
    {}

    unique_lock(mutex_type& m, try_to_lock_t)
        : m_(&m),
          owns_lock_(m_->try_lock())
    {}

    unique_lock(mutex_type& m, adopt_lock_t)
        : m_(&m),
          owns_lock_(true)
    {}

    unique_lock(mutex_type& m, const system_time& abs_time)
        : m_(&m),
          owns_lock_(m_->timed_lock(abs_time))
    {}

    template <class Duration>
        unique_lock(mutex_type& m, const Duration& rel_t,
                    typename enable_if<__is_duration<Duration>::value>::type* = 0)
            : m_(&m),
              owns_lock_(m_->timed_lock(rel_t))
        {}

    ~unique_lock()
    {
        if (owns_lock_)
            m_->unlock();
    }

    unique_lock(unique_lock&& u)
        : m_(u.m_),
          owns_lock_(u.owns_lock_)
    {
        u.m_ = 0;
        u.owns_lock_ = false;
    }

    unique_lock& operator=(unique_lock&& u)
    {
        if (owns_lock_)
            m_->unlock();
        owns_lock_ = u.owns_lock_;
        m_ = u.m_;
        u.owns_lock_ = false;
        u.m_ = 0;
        return *this;
    }

    void lock();
    bool try_lock();
    template <class Duration>
        bool timed_lock(const Duration& rel_t,
                        typename enable_if<__is_duration<Duration>::value>::type* =0);
    bool timed_lock(const system_time& abs_time);
    void unlock();

    bool owns_lock() const {return owns_lock_;}
    operator int __nat::* () const {return owns_lock_ ? &__nat::_ : 0;}
    mutex_type* mutex() const {return m_;}

    void swap(unique_lock&& u)
    {
        mutex_type* t1 = m_;
        m_ = u.m_;
        u.m_ = t1;
        bool t2 = owns_lock_;
        owns_lock_ = u.owns_lock_;
        u.owns_lock_ = t2;
    }

    mutex_type* release()
    {
        mutex_type* r = m_;
        m_ = 0;
        owns_lock_ = false;
        return r;
    }
};

template <class Mutex>
void
unique_lock<Mutex>::lock()
{
    if (m_ == 0 || owns_lock_)
        throw lock_error();
    m_->lock();
    owns_lock_ = true;
}

template <class Mutex>
bool
unique_lock<Mutex>::try_lock()
{
    if (m_ == 0 || owns_lock_)
        throw lock_error();
    owns_lock_ = m_->try_lock();
    return owns_lock_;
}

template <class Mutex>
template <class Duration>
bool
unique_lock<Mutex>::timed_lock(const Duration& rel_t,
                               typename enable_if<__is_duration<Duration>::value>::type*)
{
    if (m_ == 0 || owns_lock_)
        throw lock_error();
    owns_lock_ = m_->timed_lock(rel_t);
    return owns_lock_;
}

template <class Mutex>
bool
unique_lock<Mutex>::timed_lock(const system_time& abs_time)
{
    if (m_ == 0 || owns_lock_)
        throw lock_error();
    owns_lock_ = m_->timed_lock(abs_time);
    return owns_lock_;
}

template <class Mutex>
void
unique_lock<Mutex>::unlock()
{
    if (!owns_lock_)
        throw lock_error();
    m_->unlock();
    owns_lock_ = false;
}

template <class Mutex> inline void swap(unique_lock<Mutex>&  x, unique_lock<Mutex>&  y) {x.swap(y);}
template <class Mutex> inline void swap(unique_lock<Mutex>&& x, unique_lock<Mutex>&  y) {x.swap(y);}
template <class Mutex> inline void swap(unique_lock<Mutex>&  x, unique_lock<Mutex>&& y) {x.swap(y);}

// returns index of failed lock or -1 on success
template <class L1, class L2>
int
try_lock(L1& l1, L2& l2)
{
    unique_lock<L1> u(l1, try_to_lock);
    if (u.owns_lock())
    {
        if (l2.try_lock())
        {
            u.release();
            return -1;
        }
        return 1;
    }
    return 0;
}

template <class L1, class L2, class ...L3>
int
try_lock(L1& l1, L2& l2, L3& l3...)
{
    unsigned r = 0;
    unique_lock<L1> u(l1, try_to_lock);
    if (u.owns_lock())
    {
        r = try_lock(l2, l3...);
        if (r == -1)
            u.release();
        else
            ++r;
    }
    return r;
}

namespace this_thread
{
inline void yield() {sched_yield();}
}

template <class L1, class L2>
void
lock(L1& l1, L2& l2)
{
    while (true)
    {
        {
        unique_lock<L1> __u1(l1);
        if (l2.try_lock())
        {
            __u1.release();
            break;
        }
        }
        std::this_thread::yield();
        {
        unique_lock<L2> __u2(l2);
        if (l1.try_lock())
        {
            __u2.release();
            break;
        }
        }
        std::this_thread::yield();
    }
}

template <class L1, class L2, class ...L3>
void
__lock_first(int __i, L1& l1, L2& l2, L3& l3...)
{
    while (true)
    {
        switch (__i)
        {
        case 0:
            {
            unique_lock<L1> __u1(l1);
            __i = try_lock(l2, l3...);
            if (__i == -1)
            {
                __u1.release();
                return;
            }
            }
            ++__i;
            std::this_thread::yield();
            break;
        case 1:
            {
            unique_lock<L2> __u2(l2);
            __i = try_lock(l3..., l1);
            if (__i == -1)
            {
                __u2.release();
                return;
            }
            }
            if (__i == sizeof...(L3))
                __i = 0;
            else
                __i += 2;
            std::this_thread::yield();
            break;
        default:
            __lock_first(__i - 2, l3..., l1, l2);
            return;
        }
    }
}

template <class L1, class L2, class ...L3>
inline
void
lock(L1& l1, L2& l2, L3& l3...)
{
    __lock_first(0, l1, l2, l3...);
}

}  // std

#endif
