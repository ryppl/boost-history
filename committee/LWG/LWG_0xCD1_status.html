<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<meta name="generator" content=
"Microsoft FrontPage 5.0">
  <meta name="generator" content="Microsoft FrontPage 5.0">
  <meta name="generator" content="Microsoft FrontPage 5.0">
  <meta http-equiv="CONTENT-TYPE" content=
  "text/html; charset=us-ascii">

  <title>LWG CD1 Status of Comments</title>
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
  <meta name="AUTHOR" content="dow">
  <meta name="CREATED" content="20090221;19590000">
  <meta name="CHANGEDBY" content=" Barry E Hedquist">
  <meta name="CHANGED" content="20090222;18460000">
  <meta name="DESCRIPTION" content="FORM (ISO)">
<style type="text/css">
  body    { font-family: sans-serif; margin: 1em; }
</style>

<h1>Library Working Group<br>
Status of CD1 National Body Comments</h1>
<p>Revised:
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %b %Y %I:%M:%S %p %Z" startspan -->10 Mar 2009 07:03:02 AM -0500<!--webbot bot="Timestamp" endspan i-checksum="41429" --></p>

<p>Disposition [Being reviewed by Editor] has been applied all Type Ed comments 
which do not have a specific response from a sub-group.</p>

<table border="1" bordercolor="#000000" cellpadding="7"
  cellspacing="0" style="border-collapse: collapse">
    
    

<tr valign="top">
<td><b>MB<br></b><br>

<td><b>Clause No./<br>
Subclause No./<br>
Annex<br></b>(e.g. 3.1)

<td><b>Para/<br>
Figure/<br>Table/<br>Note</b><td><b>Type </b>

<td><b>Comment (justification for change) by the MB</b>

<td><b>Proposed change by the MB</b>

<td><p align="center" style=
"margin-top: 0.07in; margin-bottom: 0.04in; page-break-inside: avoid">
<b>Library Work Group Notes</b><p>

    

<tr valign="top">
<td>US2

<td>17-30

<td>

<td>ge/te

<td>The
active issues identified in WG21 N2806, C++ Standard
Library Active Issues, must be addressed and appropriate
action taken.

<p>
<br>

<p>
<font color="#000080"><u><a href=
"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">
http://www.open-std.org/</a><br>
&nbsp;
<a href=
"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">
jtc1/sc22/wg21/docs/lwg-active.html</a></u></font>

<td>Appropriate action would
include making changes to the CD, identifying an issue as
not requiring a change to the CD, or deferring the issue to
a later point in time.

<td>Acknowledged

<tr valign="top">
<td>FR2

<td>General<br>
Comment

<td>Library

<td>ge

<td>The adoption of the library `constexpr' proposal was not
reflected in the draft, despite formal WG21 committee vote.

<td>FR2

<td>Editorial; sent to Pete Becker

<tr valign="top">
<td>US61

<td>17 onward

<td>

<td>te

<td>The concepts core language feature is applied to only
some of the Standard Library clauses, and even then not
always consistently.

<td>Review all
clauses of the Standard Library, and consistently apply
concept technology wherever possible and appropriate. The
proposed wording in WG21 N2781 exemplifies the necessary
level of detail.

<p>

<td>Agreed. Duplicates <a href="#CA2">CA2</a>

<tr valign="top">
<td><a name="CA2">CA2 </a>

<td>17 Library

<td>

<td>Ge

<td>
&#8220;Concepts&#8221; are a significant new addition to
the language, but are not exploited uniformly in the
library as documented in CD 14882.

<td>Fix
the standard library so that &#8220;Concepts&#8221; are
used appropriately in the library.

<td>Agreed; We intend to address this.

<tr valign="top">
<td>US62

<td>17-30

<td>

<td>ge

<td>Provide concepts
and requirements clauses for all standard library templates

<td>

<td>Agreed. Duplicates <a href="#CA2">CA2</a><br>

    

<tr valign="top">
<td>US63

<td><p style="margin-top: 0.04in; margin-bottom: 0.04in">17-30

<p>

<td>

<td>te

<td>The behavior of the library in the presence of threads
is incompletely specified.

<p>For example, if thread 1 assigns to X, then writes data
to file f, which is read by thread 2, and then accesses
variable X, is thread 2 guaranteed to be able to see the
value assigned to X by thread 1? In other words, does the
write of the data "happen before" the read?

<p>Another example: does simultaneous access using operator
at() to different characters in the same non-const string
really introduce a data race?

<td>

<td>17 SG: should go to threads group; misclassified in document<p>

    Concurrency SG: Create an issue. Hans will look into it.

<tr valign="top">
<td>DE2

<td>17 through 30

<td>

<td>te

<td>DE2 Marking a constructor with "explicit" has semantics
even for a constructor with zero or several parameters:
Such a constructor cannot be used with list-initialization
in a copy-initialization context, see 13.3.1.7. The
standard library apparently has not been reviewed for
marking non-single-parameter constructors as "explicit".

<td>Consider marking zero-parameter and multi-parameter
constructors "explicit" in classes that have at least one
constructor marked "explicit" and that do not have an
initializer-list constructor.

<td>Robert Klarer to address this one

<tr valign="top">
<td>JP21

<td>
<br>

<p>17
Library

<p>
21.2, 21.4,

<p>27.2, 27.6,<br>
&nbsp;27.7,<br>
&nbsp;27.8.1,<br>
&nbsp;28.4

<td>

<td>te

<td>
Support of char16_t/char32_t is insufficient. The basic_xxx
classes of &lt;iostream&gt;, &lt;fstream&gt;,
&lt;regex&gt;, etc. does not have typedefs for
char16_t/char32_t.

<p>
Functions such as stoi, to_string in &#8216;21.4 Numeric
Conversion&#8217; does not support char16_t/char32_t types.

<td>Add commented
lines corresponding to char16_t, char32_t.

<p>
<br>

<p>
21.2 paragraph1

<p>
&nbsp;

<p>
namespace std {

<p>
&nbsp;...

<p>
&nbsp;

<p>
&nbsp;// 21.4: numeric conversions

<p>
&nbsp;...

<p>
&nbsp;

<p>
&nbsp;int stoi(const u16string&amp; str, size_t *idx = 0,
int base = 10);

<p>
&nbsp;long stol(const u16string&amp; str, size_t *idx = 0,
int base = 10);

<p>
&nbsp;unsigned long stoul(const u16string&amp; str, size_t
*idx = 0, int base = 10);

<p>
&nbsp;long long stoll(const u16string&amp; str, size_t *idx
= 0, int base = 10);

<p>
&nbsp;unsigned long long stoull(const u16string&amp; str,
size_t *idx = 0, int base = 10);

<p>
&nbsp;float stof(const u16string&amp; str, size_t *idx =
0);

<p>
&nbsp;double stod(const u16string&amp; str, size_t *idx =
0);

<p>
&nbsp;long double stold(const u16string&amp; str, size_t
*idx = 0);

<p>
&nbsp;u16string to_u16string(long long val);

<p>
&nbsp;u16string to_u16string(unsigned long long val);

<p>
&nbsp;u16string to_u16string(long double val);

<p>
&nbsp;

<p>
&nbsp; int stoi(const u32string&amp; str, size_t *idx = 0,
int base = 10);

<p>
&nbsp;long stol(const u32string&amp; str, size_t *idx = 0,
int base = 10);

<p>
&nbsp;unsigned long stoul(const u32string&amp; str, size_t
*idx = 0, int base = 10);

<p>
&nbsp;long long stoll(const u32string&amp; str, size_t *idx
= 0, int base = 10);

<p>
&nbsp;unsigned long long stoull(const u32string&amp; str,
size_t *idx = 0, int base = 10);

<p>
&nbsp;float stof(const u32string&amp; str, size_t *idx =
0);

<p>
&nbsp;double stod(const u32string&amp; str, size_t *idx =
0);

<p>
&nbsp;long double stold(const u32string&amp; str, size_t
*idx = 0);

<p>
&nbsp;u32string to_u32string(long long val);

<p>
&nbsp;u32string to_u32string(unsigned long long val);

<p>
&nbsp;u32string to_u32string(long double val);

<p>}

<p>
<br>

<p>
27.2

<p>
&nbsp;

<p>
namespace std {

<p>
&nbsp;...

<p>
&nbsp;typedef basic_ios&lt;char&gt; ios;

<p>
&nbsp;typedef basic_ios&lt;wchar_t&gt; wios;

<p>
&nbsp;typedef basic_ios&lt;char16_t&gt; u16ios;

<p>
&nbsp;typedef basic_ios&lt;char32_t&gt; u32ios;

<p>
&nbsp;

<p>
&nbsp;...

<p>
&nbsp;typedef basic_ifstream&lt;wchar_t&gt; wifstream;

<p>
&nbsp;typedef basic_ofstream&lt;wchar_t&gt; wofstream;

<p>
&nbsp;typedef basic_fstream&lt;wchar_t&gt; wfstream;

<p>
&nbsp;

<p>
&nbsp;typedef basic_streambuf&lt;char16_t&gt; u16streambuf;

<p>
&nbsp;typedef basic_istream&lt;char16_t&gt; u16istream;

<p>
&nbsp;typedef basic_ostream&lt;char16_t&gt; u16ostream;

<p>
&nbsp;typedef basic_iostream&lt;char16_t&gt; u16iostream;

<p>
&nbsp;

<p>
&nbsp;typedef basic_stringbuf&lt;char16_t&gt; u16stringbuf;

<p>
&nbsp;typedef basic_istringstream&lt;char16_t&gt;
u16istringstream;

<p>
&nbsp;typedef basic_ostringstream&lt;char16_t&gt;
u16ostringstream;

<p>
&nbsp;typedef basic_stringstream&lt;char16_t&gt;
u16stringstream;

<p>
&nbsp;typedef basic_filebuf&lt;char16_t&gt; u16filebuf;

<p>
&nbsp;

<p>
&nbsp;typedef basic_ifstream&lt;char16_t&gt; u16ifstream;

<p>
&nbsp;typedef basic_ofstream&lt;char16_t&gt; u16ofstream;

<p>
&nbsp;typedef basic_fstream&lt;char16_t&gt; u16fstream;

<p>
&nbsp;

<p>
&nbsp;typedef basic_streambuf&lt;char32_t&gt; u32streambuf;

<p>
&nbsp;typedef basic_istream&lt;char32_t&gt; u32istream;

<p>
&nbsp;typedef basic_ostream&lt;char32_t&gt; u32ostream;

<p>
&nbsp;typedef basic_iostream&lt;char32_t&gt; u32iostream;

<p>
&nbsp;

<p>
&nbsp;typedef basic_stringbuf&lt;char32_t&gt; u32stringbuf;

<p>
&nbsp;typedef basic_istringstream&lt;char32_t&gt;
u32istringstream;

<p>
&nbsp;typedef basic_ostringstream&lt;char32_t&gt;
u32ostringstream;

<p>
&nbsp;typedef basic_stringstream&lt;char32_t&gt;
u32stringstream;

<p>
&nbsp;typedef basic_filebuf&lt;char32_t&gt; u32filebuf;

<p>
&nbsp;

<p>
&nbsp;typedef basic_ifstream&lt;char32_t&gt; u32ifstream;

<p>
&nbsp;typedef basic_ofstream&lt;char32_t&gt; u32ofstream;

<p>
<u>&nbsp;typedef basic_fstream&lt;char32_t&gt;
u32fstream;</u>

<p>
&nbsp;

<p>
&nbsp;...

<p>
&nbsp;template &lt;class state&gt; class fpos;

<p>
&nbsp;typedef
fpos&lt;char_traits&lt;char&gt;::state_type&gt; streampos;

<p>
&nbsp;typedef
fpos&lt;char_traits&lt;wchar_t&gt;::state_type&gt;
wstreampos;

<p>
&nbsp;typedef
fpos&lt;char_traits&lt;char16_t&gt;::state_type&gt;
u16streampos;

<p>
&nbsp;typedef
fpos&lt;char_traits&lt;char32_t&gt;::state_type&gt;
u32streampos;

<p>}

<p>
<br>

<p>
27.6

<p>
&nbsp;

<p>
namespace std {

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt; &gt;

<p>
&nbsp;class basic_istream;

<p>
&nbsp;typedef basic_istream&lt;char&gt; istream;

<p>
&nbsp;typedef basic_istream&lt;wchar_t&gt; wistream;

<p>
&nbsp;<u>typedef basic_istream&lt;char16_t&gt;
u16istream;</u>

<p>
&nbsp;typedef basic_istream&lt;char32_t&gt; u32istream;

<p>
&nbsp;

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt; &gt;

<p>
&nbsp;class basic_iostream;

<p>
&nbsp;typedef basic_iostream&lt;char&gt; iostream;

<p>
&nbsp;typedef basic_iostream&lt;wchar_t&gt; wiostream;

<p>
&nbsp;<u>typedef basic_iostream&lt;char16_t&gt;
u16iostream;</u>

<p>
&nbsp;typedef basic_iostream&lt;char32_t&gt; u32iostream;

<p>}

<p>
&nbsp;

<p>
namespace std {

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt; &gt;

<p>
&nbsp;class basic_ostream;

<p>
&nbsp;typedef basic_ostream&lt;char&gt; ostream;

<p>
&nbsp;typedef basic_ostream&lt;wchar_t&gt; wostream;

<p>
&nbsp;<u>typedef basic_ostream&lt;char16_t&gt;
u16ostream;</u>

<p>
&nbsp;typedef basic_ostream&lt;char32_t&gt; u32ostream;

<p>}

<p>
<br>

<p>
27.7 paragraph 1

<p>
&nbsp;

<p>
namespace std {

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt;,

<p>
&nbsp;&nbsp;&nbsp;&nbsp; class Allocator =
allocator&lt;charT&gt; &gt;

<p>
&nbsp;class basic_stringbuf;

<p>
&nbsp;

<p>
&nbsp;typedef basic_stringbuf&lt;char&gt; stringbuf;

<p>
&nbsp;typedef basic_stringbuf&lt;wchar_t&gt; wstringbuf;

<p>
&nbsp;<u>typedef basic_stringbuf&lt;char16_t&gt;
u16stringbuf;</u>

<p>
&nbsp;typedef basic_stringbuf&lt;char32_t&gt; u32stringbuf;

<p>
&nbsp;

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt;,

<p>
&nbsp;&nbsp;&nbsp;&nbsp; class Allocator =
allocator&lt;charT&gt; &gt;

<p>
&nbsp;class basic_istringstream;

<p>
&nbsp;

<p>
&nbsp;typedef basic_istringstream&lt;char&gt;
istringstream;

<p>
&nbsp;typedef basic_istringstream&lt;wchar_t&gt;
wistringstream;

<p>
&nbsp;<u>typedef basic_istringstream&lt;char16_t&gt;
u16istringstream;</u>

<p>
&nbsp;typedef basic_istringstream&lt;char32_t&gt;
u32istringstream;

<p>
&nbsp;

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt;,

<p>
&nbsp;&nbsp;&nbsp;&nbsp; class Allocator =
allocator&lt;charT&gt; &gt;

<p>
&nbsp;class basic_ostringstream;

<p>
&nbsp;

<p>
&nbsp;typedef basic_ostringstream&lt;char&gt;
ostringstream;

<p>
&nbsp;typedef basic_ostringstream&lt;wchar_t&gt;
wostringstream;

<p>
&nbsp;<u>typedef basic_ostringstream&lt;char16_t&gt;
u16ostringstream;</u>

<p>
&nbsp;typedef basic_ostringstream&lt;char32_t&gt;
u32ostringstream;

<p>
&nbsp;

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt;,

<p>
&nbsp;&nbsp;&nbsp;&nbsp; class Allocator =
allocator&lt;charT&gt; &gt;

<p>
&nbsp;class basic_stringstream;

<p>
&nbsp;

<p>
&nbsp;typedef basic_stringstream&lt;char&gt; stringstream;

<p>
&nbsp;typedef basic_stringstream&lt;wchar_t&gt;
wstringstream;

<p>
&nbsp;typedef basic_stringstream&lt;char16_t&gt;
u16stringstream;

<p>
&nbsp;typedef basic_stringstream&lt;char32_t&gt;
u32stringstream;

<p>}

<p>
<br>

<p>
27.8.1 paragraph 1

<p>
&nbsp;

<p>
namespace std {

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt; &gt;

<p>
&nbsp;class basic_filebuf;

<p>
&nbsp;typedef basic_filebuf&lt;char&gt; filebuf;

<p>
&nbsp;typedef basic_filebuf&lt;wchar_t&gt; wfilebuf;

<p>
&nbsp;<u>typedef basic_filebuf&lt;char16_t&gt;
u16filebuf;</u>

<p>
&nbsp;typedef basic_filebuf&lt;char32_t&gt; u32filebuf;

<p>
&nbsp;

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt; &gt;

<p>
&nbsp;class basic_ifstream;

<p>
&nbsp;typedef basic_ifstream&lt;char&gt; ifstream;

<p>
&nbsp;typedef basic_ifstream&lt;wchar_t&gt; wifstream;

<p>
&nbsp;<u>typedef basic_ifstream&lt;char16_t&gt;
u16ifstream;</u>

<p>
&nbsp;typedef basic_ifstream&lt;char32_t&gt; u32ifstream;

<p>
&nbsp;

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt; &gt;

<p>
&nbsp;class basic_ofstream;

<p>
&nbsp;typedef basic_ofstream&lt;char&gt; ofstream;

<p>
&nbsp;typedef basic_ofstream&lt;wchar_t&gt; wofstream;

<p>
&nbsp;<u>typedef basic_ofstream&lt;char16_t&gt;
u16ofstream;</u>

<p>
&nbsp;typedef basic_ofstream&lt;char32_t&gt; u32ofstream;

<p>
&nbsp;

<p>
&nbsp;template &lt;class charT, class traits =
char_traits&lt;charT&gt; &gt;

<p>
&nbsp;class basic_fstream;

<p>
&nbsp;typedef basic_fstream&lt;char&gt; fstream;

<p>
&nbsp;typedef basic_fstream&lt;wchar_t&gt; wfstream;

<p>
&nbsp;<u>typedef basic_fstream&lt;char16_t&gt;
u16fstream;</u>

<p>
&nbsp;typedef basic_fstream&lt;char32_t&gt; u32fstream;

<p>}

<p>
<br>

<p>
28.4

<p>
&nbsp;

<p>
namespace std {

<p>
&nbsp;...

<p>
&nbsp;typedef basic_regex&lt;char&gt; regex;

<p>
&nbsp;typedef basic_regex&lt;wchar_t&gt; wregex;

<p>
&nbsp;typedef basic_regex&lt;char16_t&gt; u16regex;

<p>
&nbsp;typedef basic_regex&lt;char32_t&gt; u32regex;

<p>
&nbsp;

<p>
&nbsp;...

<p>
&nbsp;typedef sub_match&lt;const char*&gt; csub_match;

<p>
&nbsp;typedef sub_match&lt;const wchar_t*&gt; wcsub_match;

<p>
&nbsp;typedef sub_match&lt;const char16_t*&gt;
u16csub_match;

<p>
&nbsp;typedef sub_match&lt;const char32_t*&gt;
u16csub_match;

<p>
&nbsp;typedef sub_match&lt;string::const_iterator&gt;
ssub_match;

<p>
&nbsp;typedef sub_match&lt;wstring::const_iterator&gt;
wssub_match;

<p>
&nbsp;typedef sub_match&lt;u16string::const_iterator&gt;
u16ssub_match;

<p>
&nbsp;typedef sub_match&lt;u32string::const_iterator&gt;
u32ssub_match;

<p>
&nbsp;

<p>
&nbsp;...

<p>
&nbsp;typedef match_results&lt;const char*&gt; cmatch;

<p>
&nbsp;typedef match_results&lt;const wchar_t*&gt; wcmatch;

<p>
&nbsp;typedef match_results&lt;const char16_t*&gt;
u16cmatch;

<p>
&nbsp;typedef match_results&lt;const char32_t*&gt;
u32cmatch;

<p>
&nbsp;typedef match_results&lt;string::const_iterator&gt;
smatch;

<p>
&nbsp;typedef match_results&lt;wstring::const_iterator&gt;
wsmatch;

<p>
&nbsp;typedef
match_results&lt;u16string::const_iterator&gt; u16smatch;

<p>
&nbsp;typedef
match_results&lt;u32string::const_iterator&gt; u32smatch;

<p>
&nbsp;

<p>
&nbsp;...

<p>
&nbsp;typedef regex_iterator&lt;const char*&gt;
cregex_iterator;

<p>
&nbsp;typedef regex_iterator&lt;const wchar_t*&gt;
wcregex_iterator;

<p>
&nbsp;typedef regex_iterator&lt;const cha16r_t*&gt;
u16cregex_iterator;

<p>
&nbsp;typedef regex_iterator&lt;const char32_t*&gt;
u32cregex_iterator;

<p>
&nbsp;typedef regex_iterator&lt;string::const_iterator&gt;
sregex_iterator;

<p>
&nbsp;typedef regex_iterator&lt;wstring::const_iterator&gt;
wsregex_iterator;

<p>
&nbsp;typedef
regex_iterator&lt;u16string::const_iterator&gt;
u16sregex_iterator;

<p>
&nbsp;typedef
regex_iterator&lt;u32string::const_iterator&gt;
u32sregex_iterator;

<p>
&nbsp;

<p>
&nbsp;...

<p>
&nbsp;typedef regex_token_iterator&lt;const char*&gt;
cregex_token_iterator;

<p>
&nbsp;typedef regex_token_iterator&lt;const wchar_t*&gt;
wcregex_token_iterator;

<p>
&nbsp;typedef regex_token_iterator&lt;const char16_t*&gt;
u16cregex_token_iterator;

<p>
&nbsp;typedef regex_token_iterator&lt;const char32_t*&gt;
u32cregex_token_iterator;

<p>
&nbsp;typedef
regex_token_iterator&lt;string::const_iterator&gt;
sregex_token_iterator;

<p>
&nbsp;typedef
regex_token_iterator&lt;wstring::const_iterator&gt;<span lang="zxx">
&#12288;&#12288;&#12288;</span>wsregex_token_iterator;

<p>
&nbsp;typedef
regex_token_iterator&lt;u16string::const_iterator&gt;
u16sregex_token_iterator;

<p>
&nbsp;typedef
regex_token_iterator&lt;u32string::const_iterator&gt;<span lang="zxx">
&#12288;</span>u32sregex_token_iterator;

<p>}

<td>Previously considered; we decided not to do it. We believe it is not too 
    onerous to use wbuffer_convert and wstring_convert which were added as 
    intermediaries to avoid proliferation of types.

<tr valign="top">
<td>UK144

<td>17.1

<td>2

<td>Ed

<td>List of contents of library should be
extened to cover new clauses

<td>Add "regular expressions, atomic operations
and threads"

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK145

<td>17.1

<td>6

<td>Ed

<td>
<span lang="en-US">Summary of numeric facilities should
mention random numbers</span>

<td>Add random number framework to the list of
library facilities

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK146

<td>17.1

<td>

<td>Ed

<td>Add a summary paragraph for regular
expressions

<td>Add a summary paragraph for regular
expressions

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK147

<td>17.1

<td>

<td>Ed

<td>Add a summary paragraph for threads

<td>Add a summary paragraph for threads

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK148

<td>17.2

<td>Table 12

<td>Ed

<td>Table 12 is
mentioned in and relates to section 17.2, but has been
pushed down to appear directly after the title of section
17.3 which is rather unfortunate/confusing for the reader.

<td>Make sure tables are rendered in the
section to which they relate.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK149

<td>17.3

<td>

<td>Ed

<td>For consistency
with narrow-oriented and wide-oriented streams, we should
add terms for streams of Unicode character sequences

<td>Define Utf16-oriented stream classes and
Uft32-oriented stream classes for streams of
char16_t/char32_t values.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK150

<td>17.3

<td>

<td>Ed

<td>The addition of move semantics to the
language means that many library APIs leave an object in a
safely-destructible state, where no other operations can
safely be performed unless it is assigned a new value.
Library presentation would be simplified and made more
precise if we introduce a term for this state. By analogy
with singular iterators suggest the term 'singular object'
or 'the object is in a singular state'.

<td>Define 'singular
state' such that an object with a singular state can only
be assigned to or safely destroyed. Assiging a new value
typically removes the singular state. Note that objects
with a singular state may not be safely copied, so you
cannot put an object into a singular state by copying
another object in a singular state. Use this new term in
the postcondition of all library APIs that move from an
rvalue reference. It might also be used to simplify the
definition of singular iterator to an iterator value with a
singular state.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK151

<td>17.3.1

<td>

<td>Ed

<td>Missing
crossreference to 17.3.17 [defns.repositional.stream]

<td>Add cross-reference in the existing empty
brackets

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK152

<td>17.3.12

<td>

<td>Te

<td>Object state is
using a definition of object (instance of a class) from
outside the standard, rather than the 'region of storage'
definiton in 1.8p1

<td>Clarify terms and usage

<td>we think we're removing this; Howard to create LWG issue. Howard, see [func.referenceclosure.cons]

<tr valign="top">
<td>UK153

<td>17.3.17

<td>

<td>Te

<td>If a
repositional stream can only seek to a position previously
encountered, then an arbitrary-positional-stream cannot
satisfy this definition, as cross-referenced in 17.3.17

<td>Strike the word 'only'. A note might be
added to reinforce the intent

<td>editorial; sent to Pete Becker

<tr valign="top">
<td><p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK154

<p>

<td>17.3.20

<td>

<td>Ed

<td>Missing definition of a stable partition
algorithm

<td>Add definition from 25.2.12p7

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK155

<td>17.3.3

<td>

<td>Ed

<td>Add clause 28 to list that use this
definition of character

<td>Add clause 28 to list that use this
definition of character

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK156

<td>17.3.4

<td>

<td>Ed

<td>Add regular
expressions to set of templates using character container
type

<td>Add regular expressions to set of templates
using character container type

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK157

<td>17.5.2.2

<td>3

<td>Ed

<td>Add concepts to
the ordered list of presentation

<p><br>

<td>Add concepts into the sequence

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK158

<td>17.5.2.2

<td>3

<td>Ed

<td>templates are neither classes nor functions

<td>Replace
'classes' and 'functions' with 'classes and class
templates' and 'functions and function templates'

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK159

<td>17.5.2.4

<td>Footnote 152

<td>Ed

<td>This informative
footnote was relevant in 1998, not 2008. The term 'existing
vendors' may imply something different now

<td>Strike the footnote, or replace 'existing'
with 'original' or similar

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK160

<td>17.5.2.4

<td>3

<td>Ed

<td>requires is now
a keyword with a specific meaning related to concepts, and
its use in library specifcation may be confusing. Generally
the Requires clause is used to make requirements on the
caller, not the library, so typically providing runtime
pre-conditions. Suggest a new name to refflect that. Note
that Clause 30 already seems to be written to this
convention.

<td>Replace 'Requires' with 'Preconditions'

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK161

<td>17.5.2.4

<td>4

<td>Ed

<td>This paragraph
is redundant as the definition of the term 'handler
function' is already provided in 17.3. Are we in danger of
proving two definitions of the same terms? Which is the
'controlling' definition?

<td>Strike 17.5.2.4p4

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK162

<td>17.5.2.4

<td>3

<td>Ed

<td>Clause 30 makes
use of a 'Synchronization' semantic element, that
frequently appears either between Effects: and
Postconditions:, or between Returns: and Throws:

<td>Add 'Synchronization' to the list either
between Effects: and Postconditions:, or between Returns:
and Throws:.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK163

<td>17.5.2.4

<td>3

<td>Te

<td>Many functions
are defined as "Effects: Equivalent to a...", which seems
to also define the preconditions, effects, etc. But this is
not made clear.

<td>Introduce an explicit "Equivalent to",
which defines all of the properties of the function.

<td>Tom Plum to open LWG issue; we believe this is related to 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#625">LWG625</a>

<tr valign="top">
<td>UK164

<td>17.5.3.2.1

<td>1

<td>Ed

<td>This phrasing predates concepts. While this
kind of description is still used, the examples provided
are now all concepts, and should be replaced with
appropriate examples

<td>Use better names
for the examples. Ideally totally replace the need by
constraining all templates in library, so that real
concepts are all that is needed. Note if retained that
CopyConstructible is mis-spelled.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK165

<td>17.5.3.2.2,<br>
&nbsp;17.5.3.2.3

<td>

<td>Te

<td>constraints on
bitmask and enumation types were supposed to be tightened
up as part of the motivation for the constexpr feature -
see paper n2235 for deails

<td>Adopt wording in line with the motivation
described in N2235

<td>Robert Klarer to review

<tr valign="top">
<td>UK166

<td>17.5.3.<br>
2.4.1,<br>
17.5.3.3

<td>

<td>Ed

<td>List of library clauses should go up to 30,
not 27

<td>Replace initial refernce to ch27 with ch30

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK167

<td>17.5.3.4<br>
&nbsp;Private<br>
&nbsp;members

<td>

<td>Ed

<td>Comment marker in wrong place.

<td>Change: //
streambuf* sb; exposition only to streambuf* sb; //
exposition only To reflect actual usage.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK168

<td>17.6.2.2

<td>2

<td>Te

<td>We should make
it clear (either by note or normatively) that namespace std
may contain inline namespaces, and that entities specified
to be defined in std may in fact be defined in one of these
inline namespaces. (If we're going to use them for
versioning, eg when TR2 comes along, we're going to need
that.)

<td>Replace "namespace std or namespaces nested
within namespace std" with "namespace std or namespaces
nested within namespace std or inline namespaces nested
directly or indirectly within namespace std"

<td>Howard will create issue to adopt UK words (some have reservations whether 
    it is correct)

<tr valign="top">
<td>UK169

<td>17.6.2.2

<td>

<td>Te

<td>This phrasing
contradicts later freedom to implement the C standard
library portions in the global namespace as well as std.
(17.6.2.3p4)

<td>Resolve conflict in either place

<td>Bill Plauger to open issue. If the wording is too broad we need to add an 
    exception to the standard C library.

<tr valign="top">
<td>UK170

<td>17.6.2.3

<td>

<td>Te

<td>One of goals of
C++0x is to make language easier to teach and for
'incidental' programmers. The fine-grained headers of the
C++ library are valuable in large scale systems for
managing dependencies and optimising build times, but
overcomplicated for simple development and tutorials. Add
additional headers to support the whole library through a
single include statement.

<td>Add a new header &lt;std&gt; that has the
effect of including everything in tables 13 and 14, except
&lt;iosfwd&gt; and &lt;cassert&gt;. Add an additional
header &lt;fwd&gt; that adds all declarations from
&lt;std&gt; but no definitions.

<td>Alisdair to open issue. We prefer &lt;std&gt; only.

<tr valign="top">
<td>UK171

<td>17.6.2.4

<td>3

<td>Ed

<td>Does
freestanding implementation require a full implementation
of all listed headers? The reference to abort, at_exit and
exit is confusing. Is a conforming implementation allow to
deliver partial forms of these headers? If so which ones?
Are empty versions of everything but &lt;cstdlib&gt;
conforming?

<td>Either strike the references to abort,
at_exit and exit, or clarify which headers only require
partial support.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK172

<td>17.6.2.4

<td>3

<td>Te

<td>No reference to
new functions quick_exit and at_quick_exit

<td>Add reference to quick_exit and
at_quick_exit

<td>NAD. We do not belive at_exit and at_quick_exit should be required by 
    freestanding implementations.

<tr valign="top">
<td>UK173

<td>17.6.2.4

<td>table 15

<td>Te

<td>
&lt;initializer_list&gt; is missing from headers required
in freestanding implementations.

<td>Add 18.8, initializer lists,
&lt;initializer_list&gt;, to the end of the table.

<td>LWG is interested in 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>, but we're concerned whether CWG will accept 
    language recommendations.

<tr valign="top">
<td>JP23

<td>17.6.2.4

<td>2<sup>nd</sup> <font size="2"
style="font-size: 11pt">para, Table 15</font>

<td>te

<td>There is a
freestanding implementation including &lt;type_traits&gt;,
&lt;array&gt;, &lt;ratio&gt;, lately added to Table 13, C++
library headers.<br>
Programmers think them useful and hope that these headers
are also added to Table 15, C++ headers for freestanding
implementations, that shows the set of headers which a
freestanding implementation shall include at least.

<p>
<br>

<td>Add
&lt;type_traits&gt;, &lt;array&gt;, &lt;ration&gt; to Table
15.

<td>LWG is interested in 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>, but we're concerned whether CWG will accept 
    language recommendations.<p>

    add &lt;type_traits&gt; only. Alisdair will draft an issue.

<tr valign="top">
<td>UK174

<td>17.6.3.2

<td>3

<td>Ed

<td>The phrasing is
mildly ambiguous when using the word 'it' to refer back to
the header - an unfotunate reading might confuse it with
the translate unit, which is the subject of the surrounding
clause.

<td>Replace 'the first reference to any of the
entities declared in that header by the translation unit'
with 'the first reference to any of the entities that
header declares in the translation unit'

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK175

<td>17.6.4.2.1

<td>2

<td>Te

<td>Local types can
now be used to instantiate templates, but don't have
external linkage

<td>Remove the reference to external linkage

<td>we accept the proposed solution. Martin will draft an issue.

<tr valign="top">
<td>UK176

<td>17.6.4.3.3

<td>Footnote 175

<td>Ed

<td>Reference to namespace ::std should be
17.6.4.2

<td>Change referfence from 17.6.4.3 to 17.6.4.2

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK177

<td>17.6.4.3.4

<td>3

<td>Ed

<td>Sentence is
redundant as double underscores are reserved in all
contexts by 17.6.4.3.3

<td>Strike the sentence

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK178

<td>17.6.4.8

<td>2

<td>Ed

<td>The last sentence of the third bullet
"Operations on such types can report a failure by throwing
an exception unless otherwise specified" is redundant as
behaviour is already undefined.

<td>Strike the sentence

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK179

<td>17.6.4.8

<td>2

<td>Te

<td>According to the
4th bullet there is a problem if "if any replacement
function or handler function or destructor operation throws
an exception". There should be no problem throwing
exceptions so long as they are caught within the function.

<td>Replace the word 'throws' with 'propogates'

<td>Agreed. Alisdair will draft an issue.

<tr valign="top">
<td>JP22

<td>17.6.5.7

<td>4<sup>th</sup> <font size="2"
style="font-size: 11pt">para, 1<sup>st</sup>
line</font>

<td>ed

<td>The
statement below describes relation among two or more
threads using words &#8220;between threads&#8221;:<br>
[Note: This means, for example, that implementations
can&#8217;t use a static object for internal purposes
without synchronization because it could cause a data race
even in programs that do not explicitly share objects
between threads. &#8212;end note ]

<p>In
such case, &#8220;among&#8221; is preferred instead of
&#8220;between&#8221;.

<td>
Change "between threads" to "among threads".

<p>
There are same cases in 17.6.1 paragraph 2, 17.6.5.7
paragraph 6, 30.1 paragraph 1, 30.3.1 paragraph 1 also.

<td>[Being reviewed by Editor]

<tr valign="top">
<td><a name="UK180">UK180</a>

<td>17.6.5.10

<td>1, 4

<td>Te

<td>It should not be
possible to strengthen the exception specification for
virtual functions as this could break user code. Note this
is not a problem in practice as there are no virtual
functions with exception specifications in the current
library, other than empty throw specifications which it is
not possible to strengthen.

<td>Add restriction that exception
specification of virtual functions cannot be tightened.

<td>NAD, the standard already has the desired restriction.

<tr valign="top">
<td>UK181

<td>17.6.5.10

<td>Footnote 186

<td>Te

<td>This footnote is
wrong. C library functions do not have any exception
specification, but might be treated as if they had an empty
throw specification

<td>Clarify that this note does not mean the
functions are genuinely declared with the specification,
but are treated as-if.

<td>We agree that the footnote is wrong and it will be removed. Pete will handle 
    as editorial.

<tr valign="top">
<td>UK182

<td>17.6.5.10

<td>Footnote 188

<td>Te

<td>It is very
helpful to assume all exceptions thrown by the standard
library derive from std::exception. The 'encouragement' of
this note should be made normative.

<td>Make this footnote normative

<td>NAD. We cannot mandate all standard-library functions that might use some 
    third-party library.

<tr valign="top">
<td>UK184

<td>18 -&gt; 30

<td>

<td>Ed

<td>The new
alias-declaration syntax is generally easier to read than a
typedef declaration. This is especially true for complex
types like function pointers.

<td>Replace all typedef declarations in the
standard library with alias-declarations, except in the
standard C library.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>JP24

<td>18

<td>2<sup>nd</sup> <font size="2"
style="font-size: 11pt">para, Table 16</font>

<td>ed

<td>
Subclauses are listed in Table 16 as:

<p style=
"text-indent: 0.06in; margin-bottom: 0in">"18.6 Type
identification &#8230;"

<p style=
"text-indent: 0.06in; margin-bottom: 0in">"18.8 Initializer
lists &#8230;"

<p style=
"text-indent: 0.06in; margin-top: 0.04in">"18.7 Exception
handling &#8230;".

<td><p style=
"margin-left: 0.06in; text-indent: -0.06in; margin-bottom: 0in">
Sort them in the increasing order<br>
"18.6 Type identification &#8230;"

<p style=
"text-indent: 0.06in; margin-bottom: 0in">"18.7 Exception
handling &#8230;".

<p style=
"text-indent: 0.06in; margin-top: 0.04in; margin-bottom: 0.04in">
"18.8 Initializer lists &#8230;"

<p style=
"text-indent: 0.06in; margin-top: 0.04in"><br>

<td>[Being reviewed by Editor]

<tr valign="top">
<td>JP25

<td>18.1

<td>
6<sup>th</sup> <font size="2" style=
"font-size: 11pt">para , last line, SEE ALSO</font>

<td>ed

<td>
max_align_t is described in 18.1, so add 3.11 Alignment as
the reference.

<td>Add
"<u>3.11, Alignment</u><font color="#000000">" to</font>
<font size="2" style="font-size: 11pt">SEE ALSO.</font>

<td>[Being reviewed by Editor]

<tr valign="top">
<td>FR32

<td>18.2.1<br>
&nbsp;[Numeric<br>
&nbsp;limits]

<td>

<td>te

<td>The definition of
numeric_limits&lt;&gt; as requiring a regular type is both
conceptually wrong and operationally illogical. As we
pointed before, this mistake needs to be corrected. For
example, the template can be left unconstrained. In fact
this reflects a much more general problem with
concept_maps/axioms and their interpretations. It appears
that the current text heavily leans toward experimental
academic type theory.

<p>

<td>We suggest that a more pragmatic approach, in the spirit
of C and C++, be taken so that calls to constrained
function templates are interpreted as assertions on
*values*, not necessarily semantics assertions on the
carrier type.

<td>Alisdair and Gaby will work on a resolution.

<tr valign="top">
<td>DE16

<td>18.2.1

<td>

<td>te

<td>DE16 The class
template numeric_limits should not specify the Regular
concept requirement for its template parameter, because it
contains functions returning NaN values for floating-point
types; these values violate the semantics of
EqualityComparable. See also library issue 902 in WG21
document N2794 "C++ Standard Library Active Issues List
(Revision R60)", available at
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2794.html
.

<p>

<td>Specify a concept requirement with fewer constraints as
appropriate, for example SemiRegular.

<td>Alisdair and Gaby will work on a resolution.

<tr valign="top">
<td>JP26

<td>18.2.1.1

<td>

<td>te

<td>
numeric_limits does not use concept.

<td>
Correct as follows.

<p>
<br>

<p>
template&lt;class T&gt; class numeric_limits&lt;const
T&gt;;

<p>
template&lt;class T&gt; class numeric_limits&lt;volatile
T&gt;;

<p>
template&lt;class T&gt; class numeric_limits&lt;const
volatile T&gt;;

<p>
<br>

<p>
should be

<p>
<br>

<p>
template&lt;<u>Regular</u> T&gt; class
numeric_limits&lt;const T&gt;;

<p>
template&lt;<u>Regular</u> T&gt; class
numeric_limits&lt;volatile T&gt;;

<p>
template&lt;<u>Regular</u> T&gt; class
numeric_limits&lt;const volatile T&gt;;

<td>Alisdair will work on a resolution.

<tr valign="top">
<td>DE17

<td>18.2.6

<td>

<td>te

<td>DE17 The class
type_index should be removed; it provides no additional
functionality beyond providing appropriate concept maps.

<p>

<td>Specify concept maps for "const type_info *" as required
by the ordered and unordered containers and remove the
class type_index.

<td>Doug will open an issue.

<tr valign="top">
<td>UK185

<td>18.3.1

<td>2

<td>Ed

<td>There is no
header &lt;stdint&gt;, it should either be &lt;stdint.h&gt;
or &lt;cstdint&gt;

<td>Replace &lt;stdint&gt; with &lt;cstdint&gt;

<td>[Being reviewed by Editor]

<tr valign="top">
<td>DE18

<td>18.4

<td>

<td>te

<td>DE18 The
proposed C++ standard makes a considerable number of
existing programs that have well-defined behavior according
to ISO/IEC 14882:2003 have undefined behavior without a
diagnostic hint to the programmer at all. This applies to
the presence of threads and to pointer safety (the latter
was introduced to support garbage collection). In order to
avoid requiring a full code review for user code,
facilities should be present that allow the compile-time
detection of the advanced features of the proposed C++
standard. It is expected that C++ implementations will
provide a means (for example, a command-line switch) to
turn off either or both of threads and garbage collection
support, turning potentially undefined programs into
well-defined ones.<br>
<i>Note:</i> This issue is contributing significantly to
Germany's overall &#8220;no&#8221; vote.

<p>

<td>Consider applying the changes proposed in WG21 document
N2693 "Requirements on programs and backwards
compatibility", available at
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2693.html
.

<td>Straw polls: pointer safety: 9-1-10; threading: 14-2-9. Jens will open 
    multiple issues.

<tr valign="top">
<td>UK186

<td>18.4

<td>Footnote 221

<td>Ed

<td>What is the
purpose of this comment? The standard stream objects (cin,
cerr etc.) have a peculiar lifetime that extends beyond the
program. They may never be destroyed so will not be
responsible for flushing buffers at the stated time.

<td>Remove the footnote

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK187

<td>18.4

<td>9

<td>Te

<td>The term "thread
safe" is not defined nor used in this context anywhere else
in the standard.

<td>Clarify the intended meaing of "thread
safe"

<td>Lawrence Crowl will open an issue.

<tr valign="top">
<td>UK188

<td>18.4

<td>12

<td>Te

<td>The function
_Exit does not appear to be defined in this standard.
Should it be added to the table of functions
included-by-reference to the C standard?

<td>Depends on where _Exit comes from

<td>Agreed. Bill Plauger will open an issue.

<tr valign="top">
<td>UK189

<td>18.4, 18.7

<td>

<td>Te

<td>The addition of the [[noreturn]] attribute
to the language will be an important aid for static
analysis tools.

<td>The following
functions should be declared in C++ with the [[noreturn]]
attribute: abort exit quick_exit terminate unexpected
rethrow_exception throw_with_nested

<td>Agreed. Howard will open an issue.

<tr valign="top">
<td>JP27

<td>18.4, 18.9,<br>
&nbsp;18.7.2.2,<br>
&nbsp;18.7.3.1

<td>

<td>te

<td>
There are Standard library functions that never return to
the caller. They are explained so in the Standard but not
declared explicitly.

<td>
Consider to add the attribute [[noreturn]] to such
functions,

<p>
<br>

<p>
15.5.2 unexpected<br>
18.4: abort(), exit(), quick_exit,<br>
18.7.2.2: unexpected_handler,<br>
18.7.3.1: terminate_handler,

<p>
18.7.6 rethrow_nested

<p>18.7.6
throw_with_nested<br>
18.9: longjmp.

<p>
<br>

<td>See <a href="#UK180">UK 180</a>

<tr valign="top">
<td>UK190

<td>18.5.1

<td>various

<td>Te

<td>It is not entirely clear how the current
specification acts in the presence of a garbage collected
implementation.

<td>All deallocation
functions taking a pointer parameter should have a
Precondition : ptr is a safely-derived pointer value.

<td>agreed. Alisdair will open an issue.

<tr valign="top">
<td>UK191

<td>18.5.1.1

<td>4

<td>Ed

<td>According to the second bullet, behaviour
becomes undefined (for lack of a specification) if the user
has not yet called set_new_handler.

<td>Rephrase the
second bullet in terms of a new handler being installed,
and update any definition of handler function necessary to
be sure the term 'installed' is defined.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK192

<td>18.5.1.2

<td>

<td>Te

<td>The declared
signature is not compatible with the current requirement to
throw std::length_error. It is too late to weaken the
exception specification, so the only other change is to
preserve new (improved) behaviour is to throw
std::bad_alloc, or something derived from std::bad_alloc.

<td>Fix 5.3.4p7 by required std::bad_alloc
rather than std::length_error

<td>Howard will open a CWG issue referring to N2814.

<tr valign="top">
<td>UK193

<td>18.5.2.2

<td>2

<td>Te

<td>quick_exit has
been added as a new valid way to terminate a program in a
well defined way

<td>Change 3rd bullet: call either abort(),
exit() or quick_exit();

<td>change &quot;call either abort() or exit()&quot; to terminate the program. Bill 
    Plauger will open an issue.

<tr valign="top">
<td>UK194

<td>18.6

<td>

<td>Te

<td>The inclusion of
type_index and hash&lt;type_index&gt; in &lt;typeinfo&gt;
brings dependencies into &lt;typeinfo&gt; which are
inconsistent with the definition of freestanding C++ in
17.6.2.4.

<td>Move type_index and hash&lt;type_index&gt;
out of &lt;typeinfo&gt; and into a new header,
&lt;typeindex&gt;.

<td>already handled by the free-standing paper.

<tr valign="top">
<td>JP28

<td>18.6,<br>
&nbsp;18.7,<br>
&nbsp;19.1

<td>

<td>te

<td>
Errors reported by Exception classes are of types char or
std::string only. For example, std::exception is declared
with char, std::string types, therefore types
wchar_t/wstring, char16_t/u16string, or char32_t/u32string
can not be used.

<td>
Consider other types.

<td>NAD. There is already guidance in the CD. It is the caller's responsibility 
    to internationalize MB character string.

<tr valign="top">
<td>JP29

<td>18.7.6

<td>

<td>te

<td>
throw_with_nested does not use concept.

<td>
Correct as follows.

<p>
template&lt;class T&gt; void throw_with_nested(T&amp;&amp;
t); // [[noreturn]]

<p>
<br>

<p style=
"text-indent: 0.06in; margin-bottom: 0in">should be

<p>
<br>

<p>
template&lt;CopyConstructible T&gt; void
throw_with_nested(T&amp;&amp; t); // [[noreturn]]

<td>Alisdair will open an issue.

<tr valign="top">
<td>JP30

<td>18.7.6

<td>

<td>te

<td>To
handle nested exceptions strictly, error information of
tree structure will be required though, the
nested_exception does not support tree structure. It is
insufficient as error handling.

<td>
Consider nested_exception to support tree structure.

<td>Howard will ping Bill Plauger to request more information.

<tr valign="top">
<td>JP31

<td>18.7.6

<td>

<td>te

<td>It
is difficult to understand in which case nested_exception
is applied.

<td>Consider to add
a sample program which rethrows exception.

<p>
<br>

<td>Alisdair will incorporate this in the JP29 paper.

<tr valign="top">
<td>UK195

<td>18.8

<td>

<td>Te

<td>The class
definition of std::initializer_list contains concept-maps
to Range which should be out of the class, and in
&lt;iterator_concepts&gt; instead. Otherwise, it's not
possible to use initializer_lists in a freestanding C++
implementation.

<td>Delete the two concept maps from
std::initializer_list.

<td>will be handled in connection with the free-standing paper.

<tr valign="top">
<td>UK196

<td>18.8.3

<td>

<td>Te

<td>Concept maps for initializer_list to Range
should not be in language support headers, but instead in
iterator concepts.

<td>Remove section
18.8.3 and put it in 24.1.8.1 instead, so that the
concept_maps from initializer_list to Range are specified
under Range instead of under initializer lists; also, so
that they're implemented in &lt;iterator_concepts&gt;
instead of &lt;initializer_list&gt;.

<td>will be handled in connection with the free-standing paper.

<tr valign="top">
<td>UK197

<td>19

<td>

<td>Te

<td>All the exception classes in this clause
take a std::string argument by const reference. They should
all be overloaded to accept std::string by rvalue rerefence
for an efficient move as well.

<td>Provide a
constructor for every exception class in clause 19
accepting a std::string by rvalue reference, with the
semantics that the passed string may be moved.

<td>NAD. Implementations are permitted to add the requested signature under the 
    as-if rule.

<tr valign="top">
<td>JP32

<td>19.1

<td>

<td>te

<td>
Messages returned by the member function what() of standard
exception classes seem difficult to judge.

<p>For
example, following messages are returned by what() of
std::bad_alloc of existing implementations:

<p>
<br>

<p>
Compiler: Message returned by what()

<p>
---------------------------------------------

<p>
Borland C++ 5.6.4: no named exception thrown

<p>
Visual C++ 8.0: bad allocation

<p>
Code Warrior 8.0: exception

<p>g++
3.4.4: St9exception

<p>
<br>

<p>It is difficult
to recognize what exception was thrown when using those
compilers except Visual C++.

<p>
<br>

<td>
Consider to add footnote that recommends what() returns
message easy to recognize what exception was thrown.

<td>NAD. Q of I.

<tr valign="top">
<td>US64

<td>19.3

<td>1

<td>Ge

<td><font color="#000000">&#8220;</font> See also: ISO C
7.1.4, 7.2, Amendment 1 4.3.<font color="#000000">&#8221;
It is unclear why this cross reference is here. Amendment 1
was to C89, not C99.</font>

<td>Delete this
cross reference. If necessary, expand the main text to
include the relevant referenced text

<p>

<td>We believe that this is editorial.

<tr valign="top">
<td><a name="US65">US 65</a>

<td>20

<td>

<td>te

<td>Scoped allocators and
allocator propagation traits add a small amount of utility
at the cost of a great deal of machinery. The machinery is
user visible, and it extends to library components that
don't have any obvious connection to allocators, including
basic concepts and simple components like pair and tuple.

<td>
Sketch of proposed resolution: Eliminate scoped allocators,
replace allocator propagation traits with a simple uniform
rule (e.g. always propagate on copy and move), remove all
mention of allocators from components that don't explicitly
allocate memory (e.g. pair), and adjust container
interfaces to reflect this simplification.

<p>
Components that I propose eliminating include <font size=
"2" style="font-size: 11pt"><font color=
"#0000FF"><span style=
"background: #ffffce">HasAllocatorType</span></font><font color="#000080">
<u><a href=
"http://wiki.corp.google.com/twiki/bin/edit/Main/HasAllocatorType?topicparent=Main.CppStandardIssues">
?</a></u></font>, is_scoped_allocator,
allocator_propagation_map, scoped_allocator_adaptor, and
<font color="#0000FF"><span style=
"background: #ffffce">ConstructibleAsElement</span></font><font color="#000080">
<u><a href=
"http://wiki.corp.google.com/twiki/bin/edit/Main/ConstructibleAsElement?topicparent=Main.CppStandardIssues">
?</a></u></font>.</font>

<td>The statement made in the comment was already aired prior to the last vote. 
    Without further input, the committee cannot remove a feature that was voted 
    into the draft. We will look at this comment in the light of N2829, which 
    attempts to make scoped allocators less intrusive.<p>Later: US 
65, remove scoped allocators: straw poll, 4 pro - 9 con - 3 abstain, no 
consensus for removing scoped allocators.<p>D2840: straw 
poll, this is the direction we want to go: 11 pro - 0 con - 5 abstain, 
we have consensus. Straw poll, put on format motions page for this 
meeting (pro) or review and consider at next meeting (con): 7 pro - 1 
con - many abstain, consensus for moving as formal motion at this 
meeting.<p>D2840 was renamed
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">
N2840</a> and was accepted into the WP in Summit.<br>

    

<tr valign="top">
<td><a name="UK198">UK198 </a>

<td>20

<td>

<td>Ed

<td>The organization of clause 20 could be
improved to better group related items, making the standard
easier to navigate.

<td>20.6.7, 20.6.8,
20.6.9 and 20.6.10 should be grouped under a section called
"operator wrappers" or similar. The goal of all 4
subsections combined is to provide a functor for every
operator in the language. 20.6.17 class template hash
should numerically appear immediately after the operator
wrappers, as they are functors that are used in similar
ways 20.6.11, 20.6.12, 20.6.13, 20.6.14, 20.6.15 are
strongly related to 20.6.3, and to an extent 20.6.2. These
should all come under a subheading of "function adapters"
20.7.1, 20.7.3, 20.7.4, 20.7.5, 20.7.6, 20.7.7 and 20.7.10
should all be grouped as subclauses under [20.7.2
Allocators] [20.7.12 unique_ptr] should be a sub-section of
[20.7.13 smart pointers] [20.7.13 smart pointers] is
important enough to have a high level bullet after [20.7
memory], suggest renumbering as [20.8 smart pointers]
[20.7.13.7 Pointer safety] is nothing to do with smart
pointers and should become its own subclause [20.7.14
Pointer safety] [20.9 date and time functions] should be
moved under [20.8 time utilities] and retitled [20.8.6 C
Library] (as per memory management/C Library) [20.6.18
reference_closure] is fundamentally a language support
feature and should move to clause 18, see separate comment
[20.6.5 reference_wrapper] should be simplified and moved
into [2.2 utility components], see separate comment [20.6.4 result_of] should be reorganised as a type trait - see
separate comment Tuples and pairs are closely related so
merge tuple and pair into the same subclause - see more
general comment on this

<td>Agree that this is editorial -- forward to project editor. (effective 
    duplicate of <a href="#US69">US 69</a>)

<tr valign="top">
<td>UK199

<td>20.1.1, 20.1.2

<td>2

<td>Te

<td>The requirement
that programs do not supply concept_maps should probably be
users do not supply their own concept_map specializations.
THe program will almost certainly supply concept_maps - the
standard itself supplies a specialization for RvalueOf?
references. Note that the term _program_ is defined in
3.5p1 and makes no account of the standard library being
treated differently to user written code.

<td>Replace the term 'program' with 'user'.

<td>Agree change 'program' to 'user' in clauses 20.1.1 and 20.1.2

<tr valign="top">
<td><a name="UK200">UK200</a>

<td>20.1.4

<td>

<td>Te

<td>All standard library use expects Predicates
to be CopyConstructible, and this should be recognised
easily without reatedly stating on every use-case.

<td>Either require
CopyConstructible&lt;F&gt; as part of Predicate, or create
a refined concept, StdPredicate, used throughout the
library that requires CopyConstructible as well as
Callable. Consider making (Std)Predicate SemiRegular.

<td>After further 
    discussion of UK200, we do not think adding constraints to predicates is a 
    good idea. Straw poll on UK200: status quo, 5 pro - 2 con; remove 
    copy-constructible, 3 pro - 4 con; pred must be copy-constructible, 4 pro - 
    3 con; no consensus for moving away from the status quo. <p>

    Also see UK245.

<tr valign="top">
<td>UK201

<td>20.1.5

<td>

<td>Te

<td>The Consistency axiom for
LessThanComparable will not compile.

<td>Add a requires
clause to the Consistency axiomL requires
HasLessEquals&lt;T&gt; &amp;&amp;
HasGreaterEquals&lt;T&gt;, or split the Consistency axiom
into two so that 'basic' consistency can be asserted
regardless of the &lt;=/&gt;= requirement.

<td>After consultation with the submitter, we agreed that the suggestion was in 
    error and there is nothing else to be done.

<tr valign="top">
<td>JP33

<td>20.1.5

<td>

<td>te

<td>
LessThanComparable and EqualityComparable don't correspond
to NaN.

<td>Apply
concept_map to these concepts at FloatingPointType

<p>
<br>

<td>We believe that no change is necessary, but it should be reviewed by a group 
    devoted to numeric issues. Not every possible state for a type must 
    participate in the axioms. For example, pointers are dereferenceable even if 
    some pointers (e.g. the null pointer) should not be dereferenced.

<tr valign="top">
<td>US66

<td>20.1.10

<td>

<td>te

<td>Application of the "Regular" concept to floating-point
types appears to be controversial (see long discussion on
std-lib reflector).

<td>State that the &#8220;Regular&#8221; concept does not
apply to floating-point types.

<td>Recommend that we handle the same as JP 33.

<tr valign="top">
<td>JP34

<td>20.2

<td>
1<sup>st</sup> <font size="2" style=
"font-size: 11pt">para, 4<sup>th</sup> line</font>

<td>ed

<td>
Though N2672 pointed at adding
"#include&lt;initializer_list&gt;", it isn't reflected.

<td>add
followings

<p>
#include &lt;initializer_list&gt; // for concept_map

<td>Agree that the omission of <code>#include
    <initializer_list></initializer_list>
    </code>was not agreed to in a vote and that the editor should reinstate it. 
    There is some disagreement as to whether it actually <em>should</em> be 
    there. Some believed it did not belong because we do not guarantee that one 
    header includes another anywhere else in the standard. However, the paper 
    that was voted in explicitly did make that guarantee. Removing that 
    guarantee is beyond the scope of this review.

<tr valign="top">
<td>US67

<td>20.2.1

<td>&#182; 5 first sent.

<td>ed

<td>Some connective words are missing.

<td>Insert &#8220;corresponding to&#8221; before &#8220;an
lvalue reference type.&#8221;

<td>Yes. Forward to project editor.

<tr valign="top">
<td>JP35

<td>20.2.3

<td>
6<sup>th</sup> <font size="2" style=
"font-size: 11pt">para, 1<sup>st</sup> line</font>

<td>ed

<td>
Typo,

<p>"stdforward" should be
"std::forward"

<td>Correct typo.

<td>Yes. Forward to project editor.

<tr valign="top">
<td>UK202

<td>20.2.4

<td>

<td>Ed

<td>The references
to pair in the tuple-like access to pair functions qualify
pair with std::pair even though they are in a namespace std
block.

<td>Remove the std:: qualification from these
references to pair.

<td>Yes. Forward to project editor.

<tr valign="top">
<td>US68

<td>20.2.12

<td>Integral<br>
Like

<td>te/ed

<td>The code defining the context is syntactically
incorrect.

<td>Insert a comma in two places: at the end of the third
line of refinements, and at the end of the fourth line of
refinements.

<td>Editorial. The correct section is 20.1.12, not 20.2.12. Forward to project 
    editor.

<tr valign="top">
<td>UK203

<td>20.3.2

<td>1-4

<td>Ed

<td>The ratio_xyz
types have a misplaced '}'. For example: template &lt;class
R1, class R2&gt; struct ratio_add { typedef see below}
type; ;

<td>Move the '}' to after the typedef: template
&lt;class R1, class R2&gt; struct ratio_add { typedef see
below type; };

<td>Yes. Forward to project editor.

<tr valign="top">
<td>JP36

<td>20.4.2.1

<td>
19<sup>th</sup> <font size="2" style=
"font-size: 11pt">para, 6<sup>th</sup> line</font>

<td>ed

<td>
Typo.

<p>"it
it" should be "it is"

<td>
Correct typo.

<td>Yes. Forward to project editor.

<tr valign="top">
<td>UK204

<td>20.5

    [meta.<br>
trans.<br>
other]<td>Table 41

<td>Te

<td>It is not
possible to create a variant union based on a parameter
pack expansion, e.g. to implement a classic discriminated
union template.

<td>Restore aligned_union template that was
removed by LWG issue 856.

<td>Agree. The need for aligned_union is compelling enough to reinstate.

<tr valign="top">
<td><a name="US69">US69</a>

<td>20.5

<td>

<td>ed

<td>This section, dealing with tuple&lt;&gt;, should be in
the same section as the similar utility pair&lt;&gt;.

<td>Restructure Clause 20 so as to bring these similar
components together.

<td>Editorial (effective duplicate of <a href="#UK198">UK 198</a>). Forward to project editor.

<tr valign="top">
<td>UK205

<td>20.5.3

<td>

<td>Te

<td>
integral_constant objects should be usable in
integral-constant-expressions. The addition to the language
of literal types and the enhanced rules for constant
expressions make this possible.

<td>Add a constexpr conversion operator to
class tempalate integral_constant: constexpr operator
value_type() { return value; }

<td>Agree: Add a constexpr conversion operator to class template 
    integral_constant: <code>constexpr operator value_type() { return value; }</code>

<tr valign="top">
<td>UK206

<td>20.5.5

<td>para 4

<td>Te

<td>Currently the
std says: "In order to instantiate the template
is_convertible&lt;From, To&gt;, the following code shall be
well formed:" But the code shown is the requirement for the
result of is_convertible to be a true_type, not a
precondition on whether the template can be instantiated.

<td>Change: "In order to instantiate the
template is_convertible&lt;From, To&gt;, the following code
shall be well formed:" To: "The template
is_convertible&lt;From, To&gt; inherits either directly or
indirectly from true_type if the following code is well
formed:"

<td>Agree with the proposed resolution: Section 20.5.5, Change: &quot;In order to 
    instantiate the template is_convertible&lt;From, To&gt;, the following code shall 
    be well formed:&quot; To: &quot;The template is_convertible&lt;From, To&gt; inherits either 
    directly or indirectly from true_type if the following code is well formed:&quot;

<tr valign="top">
<td>UK207

<td>20.5.6.1

<td>Table 36

<td>Ed

<td>suffix "::type" is missing from the some of
the examples.

<td>Change:
Example:remove_const&lt;const volatile int&gt;::type
evaluates to volatile int, whereas remove_const&lt;const
int*&gt; is const int*. &#8212;end example To:
Example:remove_const&lt;const volatile int&gt;::type
evaluates to volatile int, whereas remove_const&lt;const
int*&gt;::type is const int*. &#8212;end example And
change: Example:remove_volatile&lt;const volatile
int&gt;::type evaluates to const int, whereas
remove_volatile&lt;volatile int*&gt; is volatile int*.
&#8212;end example To: Example:remove_volatile&lt;const
volatile int&gt;::type evaluates to const int, whereas
remove_volatile&lt;volatile int*&gt;::type is volatile
int*. &#8212;end example And change:
Example:remove_cv&lt;const volatile int&gt;::type evaluates
to int, whereas remove_cv&lt;const volatile int*&gt; is
const volatile int*. &#8212;end example To:
Example:remove_cv&lt;const volatile int&gt;::type evaluates
to int, whereas remove_cv&lt;const volatile int*&gt;::type
is const volatile int*. &#8212;end example

<td>We tend to agree. Forward to project editor. Also recommend that the word 
    &quot;is&quot; be replaced with &quot;evaluates to&quot; in the same text.

<tr valign="top">
<td>JP37

<td>20.5.7

<td>Table 41

<td>ed

<td>
Typo.

<p style=
"text-indent: 0.19in; margin-bottom: 0in">There isn't a
period at the end of enable_if's comments.

<p>
<br>

<p>If
B is true, the member typedef type shall equal T;
otherwise, there shall be no member typedef type

<p>
<br>

<p>
should be

<p>
<br>

<p>If
B is true, the member typedef type shall equal T;
otherwise, there shall be no member typedef type.

<td>Add
&#8221;.&#8221;

<td>Agree. Forward to project editor.

<tr valign="top">
<td>US70

<td>20.5 [meta]<td>

<td>te

<td>Specifications now expressed via narrative text are more
accurately and clearly expressed via executable code.

<td>Wherever
concepts are available that directly match this
section&#8217;s type traits, express the traits in terms of
the concepts instead of via narrative text. Where the type
traits do not quite match the corresponding concepts, bring
the two into alignment so as to avoid two nearly-identical
notions.

<p>

<td>(The correct reference is section 20.5, not 20.6) We think that this is a 
    good idea, but it requires a lot of work. If someone submits a paper 
    proposing specific changes, we would be happy to review it at the next 
    meeting.

<tr valign="top">
<td>US71

<td>20.6.7 [meta.<br>
trans.<br>
other]<td>Table 51, last row, column 3

<td>ed

<td>The grammar is incorrect.

<td>Change &#8220;conversion are&#8221; to &#8220;conversion
is&#8221;.

<td>(The correct reference is section 20.5.7, table 41, last row). Agree: 
    Forward to project editor. There are several ways to fix the grammar.

<tr valign="top">
<td>DE20

<td>20.6.12 [bind]

<td>

<td>ed

<td>DE20 The section heading and the first sentence use the term 
&quot;template function&quot;, which is undefined.

<td>Replace &quot;template function&quot; 
by &quot;function template&quot;.

<p>

<td>Agree. Forward to the project editor.</tr>
    

<tr valign="top">
<td><a name="US72">US72</a>

<td>20.6.12 [func.bind.<br>
bind]<td>

<td>te

<td>
bind should support move-only functors and bound arguments.

<td>&nbsp;<td>We look forward to a paper on this topic. We recommend 
no action until a paper is available. We do think that bind would 
require further overloads to support move semantics, if indeed move 
semantics are possible.<p>Peter Dimov comments: I believe 
that what is meant here is that the CopyConstructible requirements on F 
and BoundArgs must be changed to MoveConstructible. I see no need for a 
paper.</tr>
    

<tr valign="top">
<td>JP38

<td>20.6.12.<br>
1.3 [func.<br>
bind.<br>
bind]<td>

<td>te

<td>
add the move requirement for bind's return type.<p>
For example, assume following th1 and th2,

<p>
<br>
void f(vector&lt;int&gt; v) { }<br>
<br>
vector&lt;int&gt; v{ ... };<br>
thread th1([v]{ f(v); });<br>
thread th2(bind(f, v));<br>
<br>
When function object are set to thread, v is moved to th1's
lambda expression in a Move Constructor of lambda
expression becuase th1's lambda expression has a Move
Constructor. But bind of th2's return type doesn't have the
requirement of Move, so it may not moved but copied.

<p>Add
the requirement of move to get rid of this useless copy.

<p>And also, add
the MoveConstructible as well as CopyConstructible.

<p>
<br>

<td>Add
the following requirements.<br>
"<font color="#000000">it has a public move constructor
that performs a member-wise move."</font>

<p>Add
the MoveConstructible.

<td>We were not clear about what the submitter really intended. Requiring that 
    the result of bind be <span class="twikiNewLink">MoveConstructible<a href="http://wiki.dinkumware.com/twiki/bin/edit/Wg21summit/MoveConstructible?topicparent=Wg21summit.LWGSubGroup2" rel="nofollow" title="Create this topic">?</a></span> 
    and/or <span class="twikiNewLink">CopyConstructible<a href="http://wiki.dinkumware.com/twiki/bin/edit/Wg21summit/CopyConstructible?topicparent=Wg21summit.LWGSubGroup2" rel="nofollow" title="Create this topic">?</a></span> 
    might be a start, but we would like to communicate with the submitter. 
    [NOTE: We would like to see a clarification of the wording for Returnable<t> 
    that makes it clear that move-only types can be Returnable.] </t>

<p>

    Peter Dimov comments: I believe that if <a href="#US72">US 72</a> is 
    resolved as proposed by me above, the objects returned by bind will already 
    be required to have a move constructor, otherwise bind would be unable to 
    return them when F or a type in BoundArgs is move-only.</tr>
    

<tr valign="top">
<td>DE21

<td>20.6.12.<br>
1.3 [func.bind.<br>
bind]<td>

<td>te

<td>DE21 The specification for bind claims twice that &quot;the values and 
types for the bound arguments v1, v2, ..., vN are determined as 
specified below&quot;. No such specification appears to exist.

<td>Add the missing specification in the same section, or add a 
cross-reference indicating the section where the specification appears.

<td>Agree. There are several differences (omissions) between 
N2691 [func.bind.bind] and N2800 [func.bind.bind]. Ask the project 
editor to review the changes.<br>

    </tr>
    

<tr valign="top">
<td>UK211

<td>20.6.12.<br>
2.3 [unique.<br>
ptr.<br>
single.<br>
asgn]<td>11

<td>Te

<td>The nullptr_t type was introduced to resolve the null 
pointer literal problem. It should be used for the assignemnt operator, 
as with the constructor and elsewhere through the library.

<td>Change signature here and in the synopsis to: unique_ptr&amp; 
operator=(nullptr_t); Strike the sentance an note before the Effects 
clause.

<td>Agree.<br>

    </tr>
    

<tr valign="top">
<td>UK212

<td>20.6.13.7 [util.<br>
dynamic.<br>
safety]<td>

<td>Te

<td>The pointer-safety API is nothing to do with smart 
pointers, so does not belong in 20.7.13. In fact it is a set of language 
support features are really belongs in clause 18, with the contents 
declared in a header that deals with language-support of memory 
management.

<td>Move this specification to 18.5. Move the declarations 
into the header &lt;new&gt;.

<td>Agree in principle, but not with the proposed 
resolution. We believe it belongs either a subsection of either 20 
[utilities] or 20.7 [memory] as part of the general reorganization of 
20. The declaration should stay in
<memory>. </memory>
<br>

    </tr>
    

<tr valign="top">
<td>DE22

<td>20.6.16.2 [func.<br>
wrap.<br>
func]<td>

<td>te

<td>DE22 The conditions for deriving from std::unary_function and 
std::binary_function are unclear: The condition would also be satisfied 
if ArgTypes were std::vector&lt;T1&gt;, because it (arguably) &quot;contains&quot; T1.

<td>Consider stating the conditions in normative prose instead of in 
comments in the class definition. Use &quot;consists of&quot; instead of 
&quot;contains&quot;. Consider using &quot;if and only if&quot; instead of &quot;iff&quot;.

<td>Agree. std::reference_wrapper has the same structure, 
and we suggest that std::function be presented in the same way as 
std::reference_wrapper.<br>

    </tr>
    

<tr valign="top">
<td>US73

<td>20.6.18<br>
[expr.prim.<br>
lambda], [func.<br>
reference<br>
closure]

<td>

<td>te

<td>The std::reference_closure template is redundant with 
std::function and should be removed.

<p><br>

<p>
std::reference_closure is a premature optimization that provides a 
limited subset of the functionality of std::function intended to improve 
performance in a narrow use case. However, the parallel application 
performance benchmark used to motivate the inclusion of 
std::reference_closure was flawed in several ways:

<ol start="3">
  <li>
    <p>it failed to enable a common optimization in 
    std::function (implemented by all vendors), exacting a large and 
    unrealistic penalty for copying std::function instances, and

  <li>
    <p>it failed to account for parallel scheduler overhead 
    or realistically-sized work units, both of which would dominate the 
    costs measured by the benchmark in any realistic application.
  </ol>

<p style="margin-left: 0.25in"><br>

<td>Remove 20.7.18 [func.referenceclosure].

<p><br>

<p>Remove 5.1.1 paragraph 12.

<td>This requires attention from CWG and/or EWG.<br>

    </tr>

    

<tr valign="top">
<td>JP39

<td>20.6.16.2 [func.<br>
wrap.func]<td>

<td>te

<td>
There are no requires corresponding to F of std::function.

<td>
Correct as follows.

<p>
template&lt;class F, Allocator A&gt;
function(allocator_arg_t, const A&amp;, F);

<p>
template&lt;class F, Allocator A&gt;
function(allocator_arg_t, const A&amp;, F&amp;&amp;);

<p>
<br>

<p style=
"text-indent: 0.06in; margin-bottom: 0in">should be

<p>
<br>

<p>
template&lt;class F, Allocator A&gt;

<p>
requires CopyConstructible&lt;F&gt; &amp;&amp;
Callable&lt;F, ArgTypes...&gt;

<p>
&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;

<p>
function(allocator_arg_t, const A&amp;, F);

<p>
template&lt;class F, Allocator A&gt;

<p>
requires CopyConstructible&lt;F&gt; &amp;&amp;
Callable&lt;F, ArgTypes...&gt;

<p>
&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;

<p>
function(allocator_arg_t, const A&amp;, F&amp;&amp;);

<td>Agree with one correction: CopyConstructible should be 
ConstructibleWithAllocator. New proposed resolution:
<p>Correct as follows. </p>
<pre>  template&lt;class F, Allocator A&gt;
    function(allocator_arg_t, const A&amp;, F);
  template&lt;class F, Allocator A&gt;
    function(allocator_arg_t, const A&amp;, F&amp;&amp;);
</pre>
<p>should be </p>
<pre>  template&lt;class F, Allocator A&gt;
    requires ConstructibleWithAllocator&lt;F, A&gt;
      &amp;&amp; Callable&lt;F, ArgTypes...&gt;
      &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;
 ::result_type, R&gt;
      function(allocator_arg_t, const A&amp;, F);

  template&lt;class F, Allocator A&gt;
    requires ConstructibleWithAllocator&lt;F,A&gt; 
      &amp;&amp; Callable&lt;F, ArgTypes...&gt;
      &amp;&amp; Convertible&lt;Callable&lt;F, ArgTypes...&gt;
 ::result_type, R&gt;
      function(allocator_arg_t, 
       const A&amp;, F&amp;&amp;);
</pre>
    

<tr valign="top">
<td>JP40

<td>20.6.16.2

<td>

<td>ed

<td>
Thougn it's "Allocator Aloc" at other places, it's
"Allocator A" only std::function constructor template
parameter.

<td>
Correct as follows.

<p>
template&lt;class F, Allocator A&gt;
function(allocator_arg_t, const A&amp;, F);

<p>
template&lt;class F, Allocator A&gt;
function(allocator_arg_t, const A&amp;, F&amp;&amp;);

<p>
<br>

<p style=
"text-indent: 0.06in; margin-bottom: 0in">should be

<p>
<br>

<p>
template&lt;class F, Allocator <u>Alloc</u>&gt;
function(allocator_arg_t, const <u>Alloc</u> &amp;, F);

<p>
template&lt;class F, Allocator <u>Alloc</u>&gt;
function(allocator_arg_t, const <u>Alloc</u> &amp;,
F&amp;&amp;);

<p>
<br>

<td>Agree, though minor. Forward to project editor (who may disregard).

<tr valign="top">
<td><a name="JP41">JP41</a>

<td>20.6.16.2

<td>

<td>te

<td>
There are no requires corresponding to R and Args of
UsesAllocator.

<td>
Correct as follows.

<p>
template &lt;class R, class... Args&gt;

<p>
concept_map UsesAllocator&lt;function&lt;R(Args...)&gt;,
Alloc&gt; {

<p>
typedef Alloc allocator_type;

<p>}

<p>
<br>

<p style=
"text-indent: 0.06in; margin-bottom: 0in">should be

<p>
<br>

<p>
template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... Args&gt;

<p>
concept_map UsesAllocator&lt;function&lt;R(Args...)&gt;,
Alloc&gt; {

<p>
typedef Alloc allocator_type;

<p>}

<td>This change would be redundant because function&lt;&gt; is already sufficiently 
    constrained. No actions necessary.

<tr valign="top">
<td>JP42

<td>20.6.16.2

<td>

<td>ed

<td>The requires
are wrong.

<p>R
require Returnable, and ArgTypes requires CopyConstructible
by a definition of function, then it's a mistake to
designate followings by MoveConstructible.

<td>
Correct as follows.

<p>
<br>

<p>
template &lt;MoveConstructible R, MoveConstructible...
ArgTypes&gt;

<p>
bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;,
nullptr_t);

<p>
template &lt;MoveConstructible R, MoveConstructible...
ArgTypes&gt;

<p>
bool operator==(nullptr_t, const
function&lt;R(ArgTypes...)&gt;&amp;);

<p>
template &lt;MoveConstructible R, MoveConstructible...
ArgTypes&gt;

<p>
bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;,
nullptr_t);

<p>
template &lt;MoveConstructible R, MoveConstructible...
ArgTypes&gt;

<p>
bool operator!=(nullptr_t, const
function&lt;R(ArgTypes...)&gt;&amp;);

<p>
template &lt;MoveConstructible R, MoveConstructible...
ArgTypes&gt;

<p>
void swap(function&lt;R(ArgTypes...)&gt;&amp;,
function&lt;R(ArgTypes...)&gt;&amp;);

<p>
<br>

<p style=
"text-indent: 0.06in; margin-bottom: 0in">should be

<p>
<br>

<p>
template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... ArgTypes&gt;

<p>
bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;,
nullptr_t);

<p>
template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... ArgTypes&gt;

<p>
bool operator==(nullptr_t, const
function&lt;R(ArgTypes...)&gt;&amp;);

<p>
template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... ArgTypes&gt;

<p>
bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;,
nullptr_t);

<p>
template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... ArgTypes&gt;

<p>
bool operator!=(nullptr_t, const
function&lt;R(ArgTypes...)&gt;&amp;);

<p>
template &lt;<u>Returnable</u> R,
<u>CopyConstructible</u>... ArgTypes&gt;

<p>void
swap(function&lt;R(ArgTypes...)&gt;&amp;,
function&lt;R(ArgTypes...)&gt;&amp;);

<p>
<br>

<td>As with <a href="#JP41">JP 41</a>, these constraints are redundant given that function&lt;&gt; is 
    already constrained. So we recommend changing each occurence of &quot;MoveConstructible&quot; 
    to &quot;class&quot;. Note: this issue is also present in func.wrap.func.nullptr.

<tr valign="top">
<td>UK208

<td>20.6.17

<td>1

<td>Te

<td>std::hash should
be implemented for much more of the standard library. In
particular for pair, tuple and all the standard containers. <br>

<td>.

<td>Consensus is that this is an expansion of the scope of C++0X and so we 
    recommend no action.

<tr valign="top">
<td>UK209

<td>20.7

<td>

<td>Te

<td>Smart pointers cannot be used in
constrained templates

<td>Provide
constraints for smart pointers

<p><br>

<td>We look forward to a paper on this topic. We recommend no action until a 
    paper is available. We understand that a paper is forthcoming.<p>

    Peter Dimov comments: shared_ptr&lt;T&gt; and weak_ptr&lt;T&gt; support all types T for 
    which T* is valid. In other words, a possible (partial) resolution is to 
    change class T to PointeeType T for shared_ptr, weak_ptr and possibly 
    enable_shared_from_this.<br>
&nbsp;

<tr valign="top">
<td>UK213

<td>20.7.6

<td>

<td>Te

<td>std::allocator
should be constrained to simplify its use on constrained
contexts. This library component models allocation from
free store via the new operator so choose constraints to
match. The Allocator concept allows for a wider variety of
allocators that users may choose to supply if their
allocation model does not require operator new, without
impacting the requirements of this template. <br>

<td>The primary allocator template should be
constrained to require ObjectType&lt;T&gt; and
FreeStoreAllocatable&lt;T&gt;. Further operations to be
constrained as required.

<td>[default.allocator]

    Agree as stated. A future paper will address additional related issues.

<tr valign="top">
<td>UK214

<td>20.7.8

<td>

<td>Te

<td>
raw_storage_iterator needs constraining as an iterator
adaptor to be safely used in constrained templates <br>

<td>Constrain the raw_storage_iterator template

<td>We look forward to a paper on this topic. We recommend no action until a 
    paper is available.

<tr valign="top">
<td>UK210

<td>20.7.11

<td>

<td>Te

<td>Specialized algorithms for memory
managenment need requirements to be easily usable in
constrained templates

<td>Provide
constraints for all algorithms in 20.7.11

<p><br>

<td>We look forward to a paper on this topic. We recommend no action until a 
    paper is available.

<tr valign="top">
<td>JP44

<td>20.7.13.6 [util.<br>
smartptr.<br>
shared.<br>
atomic]<td>

<td>te

<td>The
1st parameter p and 2nd parameter v is now
shared_ptr&lt;T&gt; *.

<p>It
should be shared_ptr&lt;T&gt;&amp;, or if these are
shared_ptr&lt;T&gt;* then add the "p shall not be a null
pointer" at the requires.

<td>
Change shared_ptr&lt;T&gt;&amp; or add the "p shall not be
a null pionter" at the requires.

<td>Agree. All of the 
functions need a requirement that p (or v) is a pointer to a valid 
object.<br>

    </tr>

    

<tr valign="top">
<td>US74.1

<td>20.8

<td>

<td>te

<td>Scoped
allocators represent a poor trade-off for standardization,
since (1) scoped-allocator--aware containers can be
implemented outside the C++ standard library but used with
its algorithms, (2) scoped allocators only benefit a tiny
proportion of the C++ community (since few C++ programmers
even use today&#8217;s allocators), and (3) all C++ users,
especially the vast majority of the C++ community that
won&#8217;t ever use scoped allocators are forced to cope
with the interface complexity introduced by scoped
allocators. In essence, the larger community will suffer to
support a very small subset of the community who can
already implement their own data structures outside of the
standard library. Therefore, scoped allocators should be
removed from the working paper.

<p>Some evidence of
the complexity introduced by scoped allocators:

<p>20.3.3, 20.5:
large increase in the number of pair and tuple constructors

<p>23: confusing
&#8220;AllocatableElement&#8221; requirements throughout. <br>

<td>Remove support
for scoped allocators from the working paper. This includes
at least the following changes: <br>

<p>Remove 20.8.3
[allocator.element.concepts] <br>

<p>Remove 20.8.7
[allocator.adaptor] <br>

<p>Remove 20.8.10
[construct.element] <br>

<p>In Clause 23:
replace requirements naming the AllocatableElement concept
with requirements naming CopyConstructible,
MoveConstructible, DefaultConstructible, or Constructible,
as appropriate.<br>

<td>Resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">
N2840</a>, accepted in New Jersey.<p>See <a href="#US65">US 
65</a> for detailed notes.<br>

    

<tr valign="top">
<td>US80

<td>20.8.2.1 [time.traits.<br>
is_fp]<td>Heading

<td>ed

<td>The section heading does not describe the contents.

<td>Change the
heading &#8220;<span lang=
"en-US">is_floating_point</span>&#8221; to
&#8220;<span lang=
"en-US">treat_as_floating_point</span>&#8221;. Optionally
adjust the section&#8217;s label similarly.

<p>

<td>Agree. The section name and the section label 
    ([time.traits.is_fp]) are wrong. Forward to project editor.</tr>

    

<tr valign="top">
<td>US74.2

<td>20.8.2.2 [allocator.<br>
concepts]<td>(a) syn-opsis (b) after &#182; 14

<td>te/ed

<td>A concept name is twice misspelled.

<td>Change &#8220;Hasconstructor&#8221; to
&#8220;HasConstructor&#8221; (twice).

<td>Agree. Forward to project editor.

<tr valign="top">
<td>US75

<td>20.8.2.2

<td>

<td>te

<td>Allocator concepts are incomplete

<td>See paper:
<a href="http://www.halpernwightsoftware.com/">http://www.halpernwightsoftware.com/</a><br>
&nbsp; WG21/n2810_allocator_defects.pdf

<p>

<td>

<p>

<p>

<p>

    The referenced paper, N2810, was revised into
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">
    N2840</a> and accepted in New Jersey.<p>

    Full LWG: Considered N2840 (a revision of N2829): straw poll, this is the 
    direction we want to go: 11 pro - 0 con - 5 abstain, we have consensus. 
    Straw poll, put on formal motions page for this meeting (pro) or review and 
    consider at next meeting (con): 7 pro - 1 con - many abstain, consensus for 
    moving as formal motion at this meeting. Also had strong support for 
    proposals 1, 2 and 3 in N2834 (simplify pair). Pablo will submit a paper 
    containing only those parts of N2834 in Frankfurt.

<tr valign="top">
<td>JP43

<td>20.8.3

    [allocator.<br>
element.<br>
concepts]<td>

<td>ed

<td>
Typo.

<p>
"alloc" should be "Alloc"

<td>
Correct as follows.
<br>

<p>
auto concept UsesAllocator&lt;typename T, typename
Alloc&gt; {

<p>
requires Allocator&lt;alloc&gt;;

<p>
typename allocator_type = T::allocator_type;

<p>
&nbsp;

<p>
should be

<p>&nbsp;

<p>
auto concept UsesAllocator&lt;typename T, typename
Alloc&gt; {

<p>
requires Allocator&lt;<u>Alloc</u>&gt;;

<p>typename
allocator_type = T::allocator_type;
<br>

<td>Agree. Forward to project editor.

<tr valign="top">
<td>UK215

<td>20.8.3.3

    [time.<br>
duration.<br>
arithmetic]

<td>6,8

<td>Ed

<td>Extra pair of
{}, presumably some formatting code gone awry :
duration&amp; operator-{-}();

<td>Remove the {} or fix formatting

<td>Agree. Forward to project editor.

<tr valign="top">
<td>US77

<td>20.8.4

<td>

<td>te

<td>
Allocator-specific move and copy behavior for containers
(N2525) complicates a little-used and already-complicated
portion of the standard library (allocators), and breaks
the conceptual model of move-constructor and
move-assignment operations on standard containers being
efficient operations. The extensions for allocator-specific
move and copy behavior should be removed from the working
paper.

<p>With the
introduction of rvalue references, we are teaching
programmers that moving from a standard container (e.g., a
vector&lt;string&gt;) is an efficient, constant-time
operation. The introduction of N2525 removed that
guarantee; depending on the behavior of four different
traits (20.8.4), the complexity of copy and move operations
can be constant or linear time. This level of customization
greatly increases the complexity of standard containers,
and benefits only a tiny fraction of the C++ community. <br>

<td>Remove 20.8.4.

<p><br>

<p>Remove 20.8.5.

<p><br>

<p>Remove all references to the facilities in
20.8.4 and 20.8.5 from clause 23.

<td>

<tr valign="top">
<td>US78

<td>20.8.12,<br>
20.8.13.2 [unique.<br>
ptr], [util.<br>
smartptr.<br>
shared]<td>

<td>te

<td>There is presently no way to
convert directly from a <font size="2" style=
"font-size: 11pt"><code>shared_ptr</code> to a
<code>unique_ptr</code>.</font>

<td>Add
an interface that performs the conversion. See the
attached, Issues with the C++ Standard" paper under Chapter
20, "Conversion from <font size="2" style=
"font-size: 11pt"><code>shared_ptr</code> to
<code>unique_ptr".</code></font>

<td>We look forward to 
a paper on this topic. We recommend no action until a paper is 
available. We believe that the shared pointer must use the default deleter for the conversion to succeed.<p>
Peter Dimov comments: this is basically a request for shared_ptr&lt;&gt;::release 
in disguise, with all the associated problems. Not a good idea.<br>

    

<tr valign="top">
<td>US79

<td>20.8.12.2.1 [unique.ptr.<br>
single.ctor]<td>

<td>te

<td>
[unique.ptr.single.ctor]/5 no longer requires for D not to
be a pointer type. &nbsp;This restriction needs to be put
back in. &nbsp;Otherwise we have a run time failure that
could have been caught at compile time:

<p>
<br>

<p>
unique_ptr&lt;int, void(*)(void*)&gt;
p(malloc(sizeof(int))); &nbsp;// should not compile

<p>
<br>

<p>
unique_ptr&lt;int, void(*)(void*)&gt;
p(malloc(sizeof(int)), free); &nbsp;// ok <br>

<td>

<td>Agree. The unique_ptr(pointer 
p) <em>Requires</em> clause should be the same as the unique_ptr() <em>
Requires</em> clause. Note that unique_ptr [unique.ptr] needs concepts.<br>

    

<tr valign="top">
<td>JP45

<td>20.9 [time]<td>

<td>te

<td>
Rep, Period, Clock and Duration don't correspond to
concept.

<p>
template &lt;class Rep, class Period = ratio&lt;1&gt;&gt;
class duration;

<p>template
&lt;class Clock, class Duration = typename
Clock::duration&gt; class time_point;

<p>
<br>

<td>
Make concept for Rep, Period, Clock and Duration, and fix
20.9 and wait_until and wait_for's template parameter at
30.

<td>We agree that this section needs concepts. We 
look forward to a paper on this topic. We recommend no action until a 
paper is available.<br>

    

<tr valign="top">
<td>US81

<td>20.9.3

<td>

<td>te

<td>
chrono::duration is missing the modulous operator for both
member and non-member arithmetic. This operator is useful
for finding the position of a duration within a bounded
time frame. Having it be built in to duration is safer than
requiring the client to extract and operate directly on the
duration&#8217;s representation as the latter will not
enforce the correct units of the operation.

<p>
<br>

<p>Ex:

<p>
<br>

<p>
milliseconds ms(...);

<p>
microseconds us(...);

<p>
<br>

<p>ms
% us; // microseconds

<p>us
% ms; // microseconds

<p>ms
% 5; // milliseconds

<p>5 %
ms; // does not compile

<td>Add:

<p><br>

<p>
template &lt;class Rep, class Period = ratio&lt;1&gt;&gt;

<p>
class duration {

<p>
public:

<p>...

<p>duration&amp;
operator%(const rep&amp;);

<p>duration&amp;
operator%(const duration&amp;);

<p>..

<p>};

<p><br>

<p>template
&lt;class Rep1, class Period,

<p>class Rep2&gt;

<p>
duration&lt;typename common_type&lt;

<p>Rep1,
Rep2&gt;::type, Period&gt;

<p>operator%(const
duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);

<p><br>

<p>template
&lt;class Rep1, class Period1,

<p>class Rep2,
class Period2&gt;

<p>typename
common_type&lt;duration&lt;Rep1, Period1&gt;,
duration&lt;Rep2, Period2&gt;&gt;::type

<p>operator%(const
duration&lt;Rep1, Period1&gt;&amp; lhs, const
duration&lt;Rep2, Period2&gt;&amp; rhs);

<td>[time.duration] Agree except that there is a typo in the 
proposed resolution. The member operators should be operator%=. This is 
also LWG
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#934">issue 934</a>.<br>

    

<tr valign="top">
<td>US82

<td>20.9.5.3

<td>after &#182; 1

<td>ed

<td>The code synopsis has a minor alignment error.

<td>Align &#8220;rep&#8221; with the other symbols defined
in this synopsis.

<td>[time.clock.hires] Agree. Forward to project editor.

<tr valign="top">
<td><a name="UK216">UK216</a>

<td>21

<td>

<td>Te

<td>All the containers use concepts for their
iterator usage, exect for basic_string. This needs fixing.

<td>Use concepts for iterator template
parameters throughout the chapter.

<td>NB comments to be handled by Dave Abrahams and Howard Hinnant with advice 
    from PJP: UK216 (which duplicates) <a href="#JP46">JP46</a>, <a href="#JP48">JP48</a>.
    <a href="#JP46">JP46</a> supplies extensive 
    proposed wording; start there.

<tr valign="top">
<td><a name="JP46">JP46 </a>

<td>21.2, 21.3

<td>

<td>te

<td>The
basic_string does not use concept.

<td>The
"class Alloc" is changed to "Allocator Alloc".

<p>The
"class InputIterator" is changed to "InputIterator Iter".

<p>
<br>

<p>//
21.3, basic_string:

<p>
template&lt;class charT, class traits =
char_traits&lt;charT&gt;,

<p>
<u>Allocator</u> Alloc = allocator&lt;charT&gt; &gt;

<p>
class basic_string;

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;

<p>
operator+(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

<p>
operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

<p>
operator+(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

<p>
operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
lhs,

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;

<p>
operator+(const charT* lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

<p>
operator+(const charT* lhs,

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;

<p>
operator+(charT lhs, const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

<p>
operator+(charT lhs,
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;

<p>
operator+(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const charT* rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

<p>
operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
lhs,

<p>
const charT* rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;

<p>
operator+(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
charT rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

<p>
operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
lhs, charT rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator==(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator==(const charT* lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator==(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const charT* rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator!=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator!=(const charT* lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator!=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const charT* rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&lt; (const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&lt; (const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const charT* rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&lt; (const charT* lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&gt; (const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&gt; (const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const charT* rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&gt; (const charT* lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&lt;=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&lt;=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const charT* rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&lt;=(const charT* lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&gt;=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&gt;=(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

<p>
const charT* rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
bool operator&gt;=(const charT* lhs,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
rhs);

<p>
&nbsp;

<p>//
21.3.8.8: swap

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
void swap(basic_string&lt;charT,traits,Alloc&gt;&amp; lhs,

<p>
basic_string&lt;charT,traits,Alloc&gt;&amp; rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
void swap(basic_string&lt;charT,traits,Alloc&gt;&amp;&amp;
lhs,

<p>
basic_string&lt;charT,traits,Alloc&gt;&amp; rhs);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
void swap(basic_string&lt;charT,traits,Alloc&gt;&amp; lhs,

<p>
basic_string&lt;charT,traits,Alloc&gt;&amp;&amp; rhs);

<p>
&nbsp;

<p>//
21.3.8.9: inserters and extractors

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_istream&lt;charT,traits&gt;&amp;

<p>
operator&gt;&gt;(basic_istream&lt;charT,traits&gt;&amp;&amp;
is,

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_ostream&lt;charT, traits&gt;&amp;

<p>
operator&lt;&lt;(basic_ostream&lt;charT,
traits&gt;&amp;&amp; os,

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
str);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_istream&lt;charT,traits&gt;&amp;

<p>
getline(basic_istream&lt;charT,traits&gt;&amp;&amp; is,

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str,

<p>
charT delim);

<p>
&nbsp;

<p>
template&lt;class charT, class traits, <u>Allocator</u>
<u>Alloc</u>&gt;

<p>
basic_istream&lt;charT,traits&gt;&amp;

<p>
getline(basic_istream&lt;charT,traits&gt;&amp;&amp; is,

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str);

<p>
&nbsp;

<p>
<br>

<p>//
21.3 Class template basic_string

<p>
namespace std {

<p>
template&lt;class charT, class traits =
char_traits&lt;charT&gt;,

<p>
<u>Allocator Alloc</u> = allocator&lt;charT&gt; &gt;

<p>
class basic_string {

<p>
public:

<p>//
types:

<p>
typedef traits traits_type;

<p>
typedef typename traits::char_type value_type;

<p>
typedef <u>Alloc</u> allocator_type;

<p>
typedef typename <u>Alloc</u>::size_type size_type;

<p>
typedef typename <u>Alloc</u>::difference_type
difference_type;

<p>
typedef typename <u>Alloc</u>::reference reference;

<p>
typedef typename <u>Alloc</u>::const_reference
const_reference;

<p>
typedef typename <u>Alloc</u>::pointer pointer;

<p>
typedef typename <u>Alloc</u>::const_pointer const_pointer;

<p>
typedef implementation-defined iterator; // See 23.1

<p>
typedef implementation-defined const_iterator; // See 23.1

<p>
typedef std::reverse_iterator&lt;iterator&gt;
reverse_iterator;

<p>
typedef std::reverse_iterator&lt;const_iterator&gt;
const_reverse_iterator;

<p>
static const size_type npos = -1;

<p>
&nbsp;

<p>//
21.3.2 construct/copy/destroy:

<p>
explicit basic_string(const <u>Alloc</u>&amp; a =
<u>Alloc</u>());

<p>
basic_string(const basic_string&amp; str);

<p>
basic_string(basic_string&amp;&amp; str);

<p>
basic_string(const basic_string&amp; str, size_type pos,
size_type n = npos,

<p>
const <u>Alloc</u>&amp; a = <u>Alloc</u>());

<p>
basic_string(const charT* s,

<p>
size_type n, const <u>Alloc</u>&amp; a = <u>Alloc</u>());

<p>
basic_string(const charT* s, const <u>Alloc</u>&amp; a =
<u>Alloc</u>());

<p>
basic_string(size_type n, charT c, const <u>Alloc</u>&amp;
a = <u>Alloc</u>());

<p>
template&lt;<u>InputIterator</u> <u>Iter</u>&gt;

<p>
basic_string(<u>Iter</u> begin, <u>Iter</u> end,

<p>
const <u>Alloc</u>&amp; a = <u>Alloc</u>());

<p>
basic_string(initializer_list&lt;charT&gt;, const
<u>Alloc</u>&amp; = <u>Alloc</u>());

<p>
basic_string(const basic_string&amp;, const
<u>Alloc</u>&amp;);

<p>
basic_string(basic_string&amp;&amp;, const
<u>Alloc</u>&amp;);

<p>
~basic_string();

<p>
basic_string&amp; operator=(const basic_string&amp; str);

<p>
basic_string&amp; operator=(basic_string&amp;&amp; str);

<p>
basic_string&amp; operator=(const charT* s);

<p>
basic_string&amp; operator=(charT c);

<p>
basic_string&amp; operator=(initializer_list&lt;charT&gt;);

<p>
&nbsp;

<p>//
21.3.3 iterators:

<p>...

<p>
&nbsp;

<p>//
21.3.4 capacity:

<p>...

<p>
&nbsp;

<p>//
21.3.5 element access:

<p>...

<p>
&nbsp;

<p>//
21.3.6 modifiers:

<p>...

<p>
&nbsp;

<p>
basic_string&amp; append(const basic_string&amp; str);

<p>
basic_string&amp; append(const basic_string&amp; str,
size_type pos,

<p>
size_type n);

<p>
basic_string&amp; append(const charT* s, size_type n);

<p>
basic_string&amp; append(const charT* s);

<p>
basic_string&amp; append(size_type n, charT c);

<p>
template&lt;<u>InputIterator</u> <u>Iter</u>&gt;

<p>
basic_string&amp; append(<u>Iter</u> first, <u>Iter</u>
last);

<p>
basic_string&amp; append(initializer_list&lt;charT&gt;);

<p>
void push_back(charT c);

<p>
&nbsp;

<p>
basic_string&amp; assign(const basic_string&amp; str);

<p>
basic_string&amp; assign(basic_string&amp;&amp; str);

<p>
basic_string&amp; assign(const basic_string&amp; str,
size_type pos,

<p>
size_type n);

<p>
basic_string&amp; assign(const charT* s, size_type n);

<p>
basic_string&amp; assign(const charT* s);

<p>
basic_string&amp; assign(size_type n, charT c);

<p>
template&lt;<u>InputIterator</u> <u>Iter</u>&gt;

<p>
basic_string&amp; assign(<u>Iter</u> first, <u>Iter</u>
last);

<p>
basic_string&amp; assign(initializer_list&lt;charT&gt;);

<p>
&nbsp;

<p>
basic_string&amp; insert(size_type pos1, const
basic_string&amp; str);

<p>
basic_string&amp; insert(size_type pos1, const
basic_string&amp; str,

<p>
size_type pos2, size_type n);

<p>
basic_string&amp; insert(size_type pos, const charT* s,
size_type n);

<p>
basic_string&amp; insert(size_type pos, const charT* s);

<p>
basic_string&amp; insert(size_type pos, size_type n, charT
c);

<p>
iterator insert(const_iterator p, charT c);

<p>
void insert(const_iterator p, size_type n, charT c);

<p>
template&lt;<u>InputIterator</u> <u>Iter</u>&gt;

<p>
void insert(const_iterator p, <u>Iter</u> first,
<u>Iter</u> last);

<p>
void insert(const_iterator p,
initializer_list&lt;charT&gt;);

<p>
&nbsp;

<p>...

<p>
basic_string&amp; replace(size_type pos1, size_type n1,

<p>
const basic_string&amp; str);

<p>
basic_string&amp; replace(size_type pos1, size_type n1,

<p>
const basic_string&amp; str,

<p>
size_type pos2, size_type n2);

<p>
basic_string&amp; replace(size_type pos, size_type n1,
const charT* s,

<p>
size_type n2);

<p>
basic_string&amp; replace(size_type pos, size_type n1,
const charT* s);

<p>
basic_string&amp; replace(size_type pos, size_type n1,
size_type n2,

<p>
charT c);

<p>
basic_string&amp; replace(iterator i1, iterator i2,

<p>
const basic_string&amp; str);

<p>
basic_string&amp; replace(iterator i1, iterator i2, const
charT* s,

<p>
size_type n);

<p>
basic_string&amp; replace(iterator i1, iterator i2, const
charT* s);

<p>
basic_string&amp; replace(iterator i1, iterator i2,

<p>
size_type n, charT c);

<p>
template&lt;<u>InputIterator</u> <u>Iter</u>&gt;

<p>
basic_string&amp; replace(iterator i1, iterator i2,

<p>
<u>Iter</u> j1, <u>Iter</u> j2);

<p>
basic_string&amp; replace(iterator, iterator,
initializer_list&lt;charT&gt;);

<p>
&nbsp;

<p>...

<p>
&nbsp;

<p>//
21.3.7 string operations:

<p>...

<p>
&nbsp;

<p>
template &lt;class charT, class traits, <u>Allocator</u>
<u>Alloc&gt;</u>

<p>
struct constructible_with_allocator_suffix&lt;

<p>
basic_string&lt;charT, traits, <u>Alloc</u>&gt; &gt; :
true_type { };

<p>
<br>

<td>See UK 216

<tr valign="top">
<td>JP47

<td>21.3

<td>

<td>ed

<td>
Typo. Missing &#8221;&gt;&#8221;

<p>
template &lt;class charT, class traits, Allocator Alloc

<p>
<br>

<p>
should be

<p>
<br>

<p>
template &lt;class charT, class traits, Allocator Alloc&gt;

<td>
Correct typo.

<td>

<tr valign="top">
<td><a name="JP48">JP48</a>

<td>21.3

<td>

<td>te

<td>
char_traits does not use concept.

<p>For
example, create CharTraits concept and change as follows:

<p>
<br>

<p>
template&lt;class charT, <u>CharTraits</u> traits =
char_traits&lt;charT&gt;,

<p>
class Allocator = allocator&lt;charT&gt; &gt;

<p>class
basic_string {

<p>
<br>

<td>Add
a concept for char_traits.

<td>See <a href="#UK216">UK 216</a>

<tr valign="top">
<td>UK217

<td>21.3

<td>

<td>Ed

<td>basic_string refers to
constructible_with_allocator_suffix, which I thought was
removed?

<td>Remove the
lines: template &lt;class charT, class traits, class Alloc
struct constructible_with_allocator_suffix&lt;
basic_string&lt;charT, traits, Alloc&gt; &gt; : true_type {
};

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK218

<td>21.3.1

<td>3

<td>Te

<td>The identity
"&amp;*(s.begin() + n) == &amp;*s.begin() + n" relies on
operator&amp; doing the "right thing", which (AFAICS) there
is no requirement for. See my comment under clauses
"23.2.1, 23.2.6" (p1 in both cases) - this is the same
issue, but I've created a separate comment for basic_string
because it is in a different chapter.

<td>See my recommendations for "23.2.1,
23.2.6".

<td>NAD, we think. basic_string elements have to be POD and PODs may not have 
    overloaded operator&amp;. Need to check whether this is true in light of relaxed 
    POD constraints.

<tr valign="top">
<td>UK219

<td>21.3.6.6<br>
[string.<br>
replace]

<td>11

<td>Ed

<td>Effects refers to "whose first begin() - i1
elements" However i1 is greater than begin()...

<td>Effects refers to "whose first i1 - begin()
elements"

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK220

<td>21.3.8.9

<td>

<td>Te

<td>The
operator&lt;&lt; for basic_string takes the output stream
by r-value reference. This is different from the same
operator for error_code (19.4.2.6), bitset (20.2.6.3),
shared_ptr (20.7.13.2.8), complex (26.3.6) and sub_match
(28.4)

<td>Use the same reference type for the all the
library types. This should be the r-value reference. There
are other places in the standard where TR1, and new
classes, did not receive an 'R-value' update.

<td>We did it differently for basic_string because otherwise rvalue strreaming 
    was producing confusing results with strings, but this difference will be 
    fixed by N2831 if it's accepted.

<tr valign="top">
<td>FR33

<td>22.1.1<br>
&nbsp;[locale]

<td>3

<td>ed

<td>ios_base::iostate err = 0;

<p>

<p>iostate is a bitmask type and
so could be an enumeration. Probably using

<p>goodbit is the solution.

<td>

<td>[Being reviewed by Editor]

<tr valign="top">
<td>JP49

<td>22.1.3.<br>
2.2

<td>

<td>te

<td>
codecvt does not use concept. For example, create
CodeConvert concept and change as follows.

<p>
template&lt;<u>CodeConvert</u> Codecvt, class Elem =
wchar_t&gt; class wstring_convert {

<td>Add
a concept for codecvt.

<td>to be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger

<tr valign="top">
<td>JP50

<td>22.1.3.<br>
2.2

<td>

<td>te

<td>Add
custom allocator parameter to wstring_convert, since we
cannot allocate memory for strings from a custom allocator.

<td>
Correct as follows.

<p>
template&lt;class Codecvt, class Elem = wchar_t&gt; class
wstring_convert {

<p>
public:

<p>
typedef std::basic_string&lt;char&gt; byte_string;

<p>
typedef std::basic_string&lt;Elem&gt; wide_string;

<p>
&nbsp;

<p style=
"text-indent: 0.06in; margin-bottom: 0in">should be

<p>
&nbsp;

<p>
template&lt;class Codecvt, class Elem = wchar_t<u>,</u>

<p>
<u>Allocator WideAllocator = allocator&lt;Elem&gt;,</u>

<p>
<u>Allocator ByteAllocator = allocator&lt;char&gt;</u>&gt;

<p>
class wstring_convert {

<p>
public:

<p>
typedef std::basic_string&lt;char,
<u>char_traits&lt;char&gt;, ByteAllocator</u>&gt;
byte_string;

<p>typedef
std::basic_string&lt;Elem, <u>char_traits&lt;Elem&gt;,
WideAllocator</u>&gt; wide_string;

<p>
<br>

<td>to be handled by PJ Plauger

<tr valign="top">
<td>FI4

<td>22.2.1.4.1

<p>22.2.1.4.2

<td>

<td>ed

<td><tt>to_end and to_limit are both used. Only one is
needed.</tt>

<td>Change to_limit to to_end.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>FI5

<td><tt>22.2.<br>
1.4.2</tt>

<td>#3

<td>ed

<td><tt>[ Note: As
a result of operations on state, it can return ok or
partial and set next == from and to_next != to. &#8212;end
note ]</tt><br>
<br>
<br>

<p><tt>"next"
should be "from_next."</tt>

<p><tt>Also, the
sentence applies to all the examples, including do_in and
do_out.</tt>

<p><tt>Reasoning: When reading one element of multibyte
source data such as UTF-8, it is possible that from_next is
incremented, to_next is unaltered, state is altered and
return value is partial.<br>
When reading one element of wide character data, the output
can be several multibyte characters, so it is possible that
from_next is unaltered, to_next is advanced, state is
altered and return value is partial.</tt>

<td><tt>[ Note: As a result of operations on state, do_in
and do_out can return</tt><br>
<tt>ok or partial and set from_next == from and/or to_next
!= to. &#8212;end</tt><br>
<tt>note ]</tt>

<td>[Being reviewed by Editor]

<tr valign="top">
<td>FI6

<td>22.2.1.5

<p>See also<br>
&nbsp;22.2.1.4<br>
&nbsp;(1,2,3)

<td>

<td>te

<td>
<tt>codecvt_byname is only specified to work with locale
names. There is no built-in means to find a codecvt with a
character set's name. A locale and a character set are not
the same. If the user has data which is encoded in a
certain character set and she wants to create a codecvt
which can convert from that character set to another one,
she must iterate through locales to find one, or use
external means (iconv, ICU's uconv). Specifying a locale
with the character set is not a suitable solution, since
there is no built-in mapping from character sets to
locales. It is only possible to inquire the character set
once the locale is known.</tt>

<p>

<td><tt>There should be a built-in means to find a codecvt
with a pair of character set names.</tt>

<td>Martin Sebor interested in solving this problem (also POSIX group), but 
    addressing it controversial because it's probably too late in the process 
    for what looks like a new feature.

<tr valign="top">
<td>FI7

<td>22.2.1.4

<td>1,2,3

<td>ed

<td>The word
"codeset" is used, whereas the word "character set" is used
elsewhere in the text. The words are intended to convey the
same concept, so only one should be used (or always both
together).

<p>

<td>Change "codeset" to "character set."

<td>[Being reviewed by Editor]

<tr valign="top">
<td>JP51

<td>22.2.5.1.1

<td>7<sup>th</sup> <font size="2"
style="font-size: 11pt">para, 1<sup>st</sup>
line</font>

<td>ed

<td>A
parameter `end&#8217; should be `fmtend&#8217;.<br>
get() function had two `end&#8217; parameters at N2321.

<p>
iter_type get (iter_type s, iter_type end, ios_base&amp; f,
ios_base::iostate&amp; err, tm* t, const char_type* fmt,
const char_type *end) const;

<p>The function
prototype of get() has been corrected at N2800, but a
Requires statement still refers `end&#8217; parameter.

<p>
<br>

<td>
Correct as follows.

<p>
Requires: [fmt,end) shall be a valid range.

<p>
<br>

<p>
should be

<p><br>
<br>

<p>
Requires: [fmt,fmtend) shall be a valid range.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>JP52

<td>22.2.5.1,<br>
22.2.5.2,<br>
22.2.6.1

<td>

<td>te

<td>
InputIterator does not use concept.

<td>
Correct as follows.

<p>
<br>

<p>
22.2.5.1

<p>
&nbsp;

<p>
template &lt;class charT, class InputIterator =
istreambuf_iterator&lt;charT&gt; &gt;

<p>
class time_get : public locale::facet, public time_base {

<p>
public:

<p>
typedef charT char_type;

<p>
typedef InputIterator iter_type;

<p>
&nbsp;

<p>
should be

<p>
&nbsp;

<p>
template &lt;class charT, <u>InputIterator InputIter</u> =
istreambuf_iterator&lt;charT&gt; &gt;

<p>
class time_get : public locale::facet, public time_base {

<p>
public:

<p>
typedef charT char_type;

<p>
typedef <u>InputIter</u> iter_type;

<p>
&nbsp;

<p>
&nbsp;

<p>
22.2.5.2

<p>
&nbsp;

<p>
template &lt;class charT, class InputIterator =
istreambuf_iterator&lt;charT&gt; &gt;

<p>
class time_get_byname : public time_get&lt;charT,
InputIterator&gt; {

<p>
public:

<p>
typedef time_base::dateorder dateorder;

<p>
typedef InputIterator iter_type;

<p>
&nbsp;

<p>
should be

<p>
&nbsp;

<p>
template &lt;class charT, <u>InputIterator InputIter</u> =
istreambuf_iterator&lt;charT&gt; &gt;

<p>
class time_get_byname : public time_get&lt;charT,
InputIter&gt; {

<p>
public:

<p>
typedef time_base::dateorder dateorder;

<p>
typedef <u>InputIter</u> iter_type;

<p>
&nbsp;

<p>
&nbsp;

<p>
22.2.6.1

<p>
&nbsp;

<p>
template &lt;class charT,

<p>
class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;

<p>
class money_get : public locale::facet {

<p>
public:

<p>
typedef charT char_type;

<p>
typedef InputIterator iter_type;

<p>
&nbsp;

<p>
should be

<p>
&nbsp;

<p>
template &lt;class charT,

<p>
<u>InputIterator InputIter</u> =
istreambuf_iterator&lt;charT&gt; &gt;

<p>
class money_get : public locale::facet {

<p>
public:

<p>
typedef charT char_type;

<p>
typedef <u>InputIter</u> iter_type;

<td>to be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger

<tr valign="top">
<td>JP53

<td>22.2.5.3 ,<br>
22.2.5.4

<td>

<td>te

<td>
OutputIterator does not use concept.

<td>
Correct as follows.

<p>
&nbsp;

<p>
22.2.5.3

<p>
&nbsp;

<p>
template &lt;class charT, class OutputIterator =
ostreambuf_iterator&lt;charT&gt; &gt;

<p>
class time_put : public locale::facet {

<p>
public:

<p>
typedef charT char_type;

<p>
typedef OutputIterator iter_type;

<p>
&nbsp;

<p>
<span lang="zxx">&#12288;</span>should be

<p>
&nbsp;

<p>
template &lt;class charT, <u>OutputIterator OutputIter</u>
= ostreambuf_iterator&lt;charT&gt; &gt;

<p>
class time_put : public locale::facet {

<p>
public:

<p>
typedef charT char_type;

<p>
typedef <u>OutputIter</u> iter_type;

<p>
&nbsp;

<p>
&nbsp;

<p>
22.2.5.4

<p>
&nbsp;

<p>
template &lt;class charT, class OutputIterator =
ostreambuf_iterator&lt;charT&gt; &gt;

<p>
class time_put_byname : public time_put&lt;charT,
OutputIterator&gt;

<p>{

<p>
public:

<p>
typedef charT char_type;

<p>
typedef OutputIterator iter_type;

<p>
&nbsp;

<p>
should be

<p>
&nbsp;

<p>
template &lt;class charT, <u>OutputIterator OutputIter</u>
= ostreambuf_iterator&lt;charT&gt; &gt;

<p>
class time_put_byname : public time_put&lt;charT,
OutputIter&gt;

<p>{

<p>
public:

<p>
typedef charT char_type;

<p>typedef <u>OutputIter</u>
iter_type;

<td>to be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger

<tr valign="top">
<td>JP54

<td>23

<td>
2<sup>nd</sup> <font size="2" style=
"font-size: 11pt">para, Table 79</font>

<td>ed

<td>
There is not &lt;forward_list&gt; in Table 79.

<td>Add
&lt;forward_list&gt; between &lt;deque&gt; and
&lt;list&gt;.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK221

<td>23

<td>Table 79

<td>Ed

<td>The table is missing the new
&lt;forward_list&gt; header.

<td>Add
&lt;forward_list&gt; to the table for sequence containers.
Alternative (technical) solution might be to merge
&lt;forward_list&gt; into &lt;list&gt;.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK222

<td>23

    [container.<br>
require-ments]<td>

<td>Te

<td>It is not clear
what purpose the Requirement tables serve in the Containers
clause. Are they the definition of a library Container? Or
simply a conventient shorthand to factor common semantics
into a single place, simplifying the description of each
subsequent container? This becomes an issue for
'containers' like array, which does not meet the
default-construct-to-empty requirement, or forward_list
which does not support the size operation. Are these
components no longer containers? Does that mean the
remaining requirements don't apply? Or are these
contradictions that need fixing, despite being a clear
design decision?

<td>Clarify all the tables in 23.1 are there as
a convenience for documentation, rather than a strict set
of requirements. Containers should be allowed to relax
specific requirements if they call attention to them in
their documentation. The introductory text for array should
be expanded to mention a default constructed array is not
empty, and forward_list introduction should mention it does
not provide the required size operation as it cannot be
implemented efficiently.

<td>Agree in principle. We suggest proposed wording:

<tr valign="top">
<td>JP55

<td>23.1.1

<td>
3<sup>rd</sup> <font size="2" style=
"font-size: 11pt">para, 4<sup>th</sup> line</font>

<td>ed

<td>It
seems that &#8220;the MinimalAllocator concep&#8221; is the
typo of &#8220;the MinimalAllocator concept&#8221;.

<td>
Change to &#8230; models the MinimalAllocator
concep<font color="#339966">t</font><font size="2" style=
"font-size: 11pt">.</font>

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK223

<td>23.1.1

    [container.<br>
require-ments.<br>
general]<td>3

<td>Te

<td>The library does
not define the MinimalAllocator or ScopedAllocator
concepts, these were part of an earlier Allocators proposal
that was rejected.

<td>Remove the references to MinimalAllocator
and ScopedAllocator, or add definitions for these concepts
to clause 20.7.

<td>Agree. Proposed wording will be presented 
    in N2829 or D2840.

<tr valign="top">
<td><a name="UK224">UK224</a>

<td>23.1.1<br>

    [container.<br>
require-ments.<br>
general]<td>8

<td>Te

<td>This paragraph implicitly requires all
containers in clause 23 to support allocators, which
std::array does not.

<td>Add an 'unless
otherwise specified' rider somewhere in p8, or move the
whole array container from clause 23 [containers] to clause
20 [utilies] to accompany bitset, pair and tuple.

<td>Agree except with moving array to clause 
    20. Proposed wording will be presented in D2840.

<tr valign="top">
<td>UK225

<td>23.1.1

<td>Table 81

<td>Ed

<td>Inconsistent
words used to say the same thing. Table 80 describes
iterator/const_iterator typedef as returning an "iterator
type whose value type is T". Table 81 expresses the same
idea as an "iterator type pointing to T". Express identical
ideas with the same words to avoid accidentally introducing
subtlety and confusion

<td>Change return types for
X::(const)_reverse_iterator to say "iterator type whose
value type is (const) T".

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK226

<td>23.1.1

    [container.<br>
require-ments.<br>
general]<td>10

<td>Te

<td>&lt;array&gt;
must be added to this list. In particular it doesn't
satisfy: - no swap() function invalidates any references,
pointers, or iterators referring to the elements of the
containers being swapped. and probably doesn't satisfy:
&#8212; no swap() function throws an exception.

<td>If &lt;array&gt; remains a container, this
will have to also reference array, which will then have to
say which of these points it satisfies.

<td>Agree. The proposed resolution is 
    incomplete. Further work required.

<tr valign="top">
<td>UK227

<td>23.1.1

<td>Table 80

<td>Ed

<td>The post-condition for a = rv uses the word
&#8220;construction&#8221; when it means
&#8220;assignment&#8221;

<td>Replace the word
&#8220;construction&#8221; with the word
&#8220;assignment&#8221;

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK228

<td>23.1.1

<td>3

<td>Ed

<td>Line 4 contains
a spelling mistake in the fragment "MinimalAllocator
concep."

<td>Replace "concep" with "concept"

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK229

<td>23.1.1

<td>3

<td>Ed

<td>The fragment "A container may directly call
constructors" is not technically correct as constructors
are not callable.

<td>Replace "A
container may directly call constructors and destructors
for its stored objects" with something similar to "A
container may directly construct its stored objects and
call destructors for its stored objects"

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK230

<td>23.1.2

    [container.<br>
require-ments.<br>
dataraces]<td>1

<td>Te

<td>
&#8220;implementations shall consider the following
functions to be const&#8221; - what does this mean? I don't
understand what it means by implementations considering the
functions to be const &#8211; surely they are either
declared const or not?

<td>Clarify what is meant and what requirements
an implementation must satisfy.

<td>After considerable discussion and 
    consideration, we do not feel this is a defect given the reference to [res.on.data.races].

<tr valign="top">
<td>JP56

<td>23.1.3

<td>12<sup>th</sup> <font size="2"
style="font-size: 11pt">para, Table 84</font>

<td>ed

<td>
`array&#8217; is unstated in Table 84 - Optional sequence
container operations.

<td>Add
`array&#8217; to Container field for the following
Expression.

<p style=
"text-indent: 0.15in; margin-bottom: 0in">a.front()

<p style=
"text-indent: 0.15in; margin-bottom: 0in">a.back()

<p style=
"text-indent: 0.15in; margin-bottom: 0in">a[n]

<p style=
"text-indent: 0.15in; margin-top: 0.04in">a.at(n)

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK231

<td>23.1.3 [sequence.<br>
reqmts]<td>9-11

<td>Te

<td>These paragraphs
are redundant now that Concepts define what it means to be
an Iterator and guide overload resolution accordingly.

<td>Strike 23.1.3p9-11. Make sure
std::basic_string has constraints similar to std::vector to
meet this old guarantee.

<td>Agree with issue and change to [sequence.reqmts]. The changes required to 
    [strings] will be part of the general concept support for that clause.

<tr valign="top">
<td>UK232

<td>23.1.3&nbsp; [sequence.<br>
reqmts]<td>Table 84

<td>Te

<td>match_results
may follow the requirements but is not listed a general
purpose library container.

<td>Remove reference to match_results against
a[n] operation

<td>Agree. <code>operator[]</code> is defined elsewhere.

<tr valign="top">
<td>UK233

<td>23.1.3&nbsp; [sequence.<br>
reqmts]<td>Table 84

<td>Te

<td>Add references to the new containers.

<td>Add reference to
array to the rows for: a.front(), a. back(), a[n] a.at(n).
Add reference to forward_list to the rows for: a.front(),
a.emplace_front(args), a.push_front(t), a.push_front(rv),
a.pop_front(). Add reference to basic_string to the row
for: a.at(n).

<td>Agree.

<tr valign="top">
<td>UK234

<td>23.1.3&nbsp; [sequence.<br>
reqmts]<td>Table 84

<td>Te

<td>Ther reference
to iterator in semantics for back should also allow for
const_iterator when called on a const-qualified container.
This would be ugly to specify in the 03 standard, but is
quite easy with the addition of auto in this new standard.

<td>Replace iterator with auto in semantics for
back: { auto tmp = a.end(); --tmp; return *tmp; }

<td>Agree.

<tr valign="top">
<td>UK235

<td>23.1.3

<td>1

<td>Ed

<td>&#8220;The library provides three basic
kinds of sequence containers: vector, list, and
deque&#8221; - text appears to be out of date re addition
of array and forward_list

<td>Change the text
to read: &#8220;The library provides five basic kinds of
sequence containers: array, deque, forward_list, list and
vector&#8221;.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK236

<td>23.1.3

<td>2

<td>Ed

<td>[ I've moved (1)
into a separate comment because I believe it is editorial
in the simple sense, whereas (2) and (3) are not so
straight forward ] (2) &#8220;vector is the type of
sequence container that should be used by default&#8221; --
As I understand it vector was considered first port of call
because the things it has in common with the native array
make programmers (especially those new to the container
library) feel like they are on familiar territory. However,
we now have the array container, so I think this should be
recommended as the first port of call. (3) This paragraph
is actually giving guidance on the use of the containers
and should not be normative text

<td>Remove this paragraph

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK237

<td>23.1.3

<td>2

<td>Ed

<td>vector, list, and deque offer the
programmer different complexity trade-offs and should be
used accordingly - this ignores array and forward_list

<td>Modify the text
to read: "array, deque, forward_list, list and vector offer
the programmer different complexity trade-offs and should
be used accordingly"

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK238

<td>23.1.4 [assoc-iative.<br>
reqmts]<td>6

<td>Te

<td>Leaving it
unspecified whether or not iterator and const_iterator are
the same type is dangerous, as user code may or may not
violate the One Definition Rule by providing overloads for
both types. It is probably too late to specify a single
behaviour, but implementors should document what to expect.
Observing that problems can be avoided by users restricting
themselves to using const_iterator, add a note to that
effect.

<td>Change 'unspecified' to 'implementation
defined'. Add "[Note: As itererator and const_iterator have
identical semantics in this case, and iterator is
convertible to const_iterator, users can avoid violating
the One Definition Rule by always using const_iterator in
their function parameter lists -- end note]

<td>Agree with issue. Agree with adding the note but not with changing the 
    normative text. We believe the note provides sufficient guidance.

<tr valign="top">
<td>UK239

<td>23.1.4&nbsp; [assoc-iative.<br>
reqmts]<td>85

<td>Te

<td>It is not possible to take a move-only key
out of an unordered container, such as (multi)set or
(multi)map, or the new hashed containers.

<td>Add below
a.erase(q), a.extract(q), with the following notation:
a.extract(q), Return type pair&lt;key, iterator&gt;
Extracts the element pointed to by q and erases it from the
set. Returns a pair containing the value pointed to by q
and an iterator pointing to the element immediately
following q prior to the element being erased. If no such
element exists,returns a.end().

<td>We look forward to a paper on this topic. We recommend no action until a 
    paper is available. The paper would need to address exception safety.

<tr valign="top">
<td>UK240

<td>23.1.6.1 <br>
[container.<br>
concepts.<br>
free]<td>12

<td>Te

<td>The axiom
EmplacePushEquivalence should be asserting the stronger
contract that emplace and insert return the same iterator
value, not just iterators that dereference to the same
value. This is a similar statement that is easier to
express and should be equivalent - the idea that insert and
emplace might return iterator values that do not compare
equal but point to the same element should fail somewhere
in the iterator concepts. Also, this axiom should be
renamed to reflect its connection with insert, rather than
push_front/push_back,

<td>Remove the * to deference the returned
iterator either side of the == in the
EmplacePushEquivalence axiom, rename the axiom
EmplacementInsertionEquivalence : requires
InsertionContainer&lt;C&gt; &amp;&amp;
Constructible&lt;value_type, Args...&gt; axiom
EmplacementInsertionEquivalence(C c, const_iterator
position, Args... args) { emplace(c, position, args...) ==
insert(c, position, value_type(args...)); }

<td>We look forward to a paper on this topic. We recommend no action until a 
    paper is available. We suspect that there are other similar issues in this 
    sub-clause (9, 10).

<tr valign="top">
<td>JP57

<td>23.1.6.3

<td>
1<sup>st</sup> <font size="2" style=
"font-size: 11pt">para, 4<sup>th</sup> line</font>

<td>ed

<td>
Typo, duplicated "to"

<p>
"<u>to to</u> model insertion container concepts."

<td>
Remove one.

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK241

<td>23.2.1

<td>

<td>Te

<td>std::array does
not have an allocator, so need to document an exception to
the requirements of 23.1.1p3

<td>add exception to 23.1.1p3

<td>Duplicate of <a href="#UK224">UK 224</a>.

<tr valign="top">
<td>UK242

<td>23.2.1

<td>3

<td>Ed

<td>std:: qualification no longer needed for
reverse_iterator.

<td>remove std::
qualification from std::reverse_iterator&lt;iterator&gt;
and std::reverse_iterator&lt;const_iterator&gt;

<td>[Being reviewed by Editor]

<tr valign="top">
<td>UK243

<td>23.2.1 <br>
[array]<td>3

<td>Te

<td>Most containers,
and types in general have 3 swaps: swap(T&amp;, T&amp;)
swap(T&amp;&amp;, T&amp;) swap(T&amp;, T&amp;&amp;) But
array only has swap(T&amp;, T&amp;).

<td>add the other two swaps.

<td>Agree. The proposed wording is forthcoming from Martin. We feel that these 
    overloads of swap are more important for array than other containers because 
    swap is not O(1) for array.<p>

    <strong>HOWEVER</strong> in a later session discussing D2844, it was decided 
    to remove all the r-value-ref <code>swap</code> overloads from containers. 
    Therefore adding them to <code>array</code> has no benefit. So the final 
    disposition is NAD.

<tr valign="top">
<td>UK244

<td>23.2.1,<br>
&nbsp;23.2.6<br>
[array], [vector]

<td>1

<td>Te

<td>The validity of
the expression &amp;a[n] == &amp;a[0] + n is contingent on
operator&amp; doing the &#8220;right thing&#8221; (as
captured by the CopyConstructible requirements in table 30
in C++2003). However this constraint has been lost in the
Concepts of C++0x. This applies to vector and array (it
actually applies to string also, but that's a different
chapter, so I'll file a separate comment there and
cross-reference).

<td>Define a ContiguousStrorage and apply it to
vector,array and string. The Concept (supplied by Alisdair
M) looks like this: Concept&lt; typename C &gt;
ContiguousStrorage { requires Container&lt;C&gt;; typename
value_type = C::value_type; value_type * data( C ); axiom
Contiguous { C c; true = equal_ranges( data( c), data(c) +
size(c), begin(c)); } };

<td>Agree with the issue but not the details of the proposed solution. Walter to 
    provide wording for the new concept.

<tr valign="top">
<td><a name="UK245">UK245</a>

<td>23.2.3

<td>2

<td>Te

<td>The predicate types used in special member
function of forward_list should be CopyConstructible, as
per the algorithms of the same name. Note: an alternate
solution would be to require these callable concepts to be
CopyConstructible in clause 20, which would simplify the
library specification in general. See earlier comment for
details, that would render this one redundant.

<td>Add
CopyConstructible requirement to the following signatures:
template &lt;Predicate&lt;auto, T&gt; Pred&gt; requires
CopyConstructible&lt;Pred&gt; void remove_if(Pred pred);
template &lt;EquivalenceRelation&lt;auto, T&gt;
BinaryPredicate&gt; requires
CopyConstructible&lt;BinaryPredicate&gt; void
unique(BinaryPredicate binary_pred); template
&lt;StrictWeakOrder&lt;auto, T&gt; Compare&gt; requires
CopyConstructible&lt;Compare&gt; void
merge(forward_list&lt;T,Alloc&gt;&amp;&amp; x, Compare
comp); template &lt;StrictWeakOrder&lt;auto, T&gt;
Compare&gt; requires CopyConstructible&lt;Compare&gt; void
sort(Compare comp);

<p><br>

<td>UK245 with additional comments on <a href="#UK200">UK200</a> in clause 20: After further 
    discussion of UK200, we do not think adding constraints to predicates is a 
    good idea. Straw poll on 
    UK245: status quo, 5 pro - 0 con; add copy-constructible, 1 pro - 3 con; no 
    consensus for moving away from the status quo.

    

<tr valign="top">
<td>JP58

<td>23.2.3.2

<td>
1<sup>st</sup> <font size="2" style="font-size: 11pt">line
before 1<sup>st</sup> para</font>

<td>ed

<td>
Unnecessary "{" exists before a word iterator like
"{iterator before_begin()".

<td>
Remove "{"

<td>[Being reviewed by Editor]

<tr valign="top">
<td>JP59

<td>23.2.4.4

<td>

<td>ed

<td>
Types of the third and forth parameter of splice() are
iterator at 23.2.4.4, though types of them are
const_iterator at 23.2.4. (They are both const_iterator on
N2350)

<td>
Correct as follows.

<p>
void splice(const_iterator position,
list&lt;T,Allocator&gt;&amp;&amp; x, iterator i);

<p>
void splice(const_iterator position,
list&lt;T,Allocator&gt;&amp;&amp; x,

<p>
iterator first, iterator last);

<p>
<br>

<p>
should be

<p>
<br>

<p>
void splice(const_iterator position,
list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);

<p>
void splice(const_iterator position,
list&lt;T,Allocator&gt;&amp;&amp; x,

<p>const_iterator
first, const_iterator last);

<p>
<br>

<td>[Being reviewed by Editor]

<tr valign="top">
<td>US83

<td>23.2.6.2

<td>7

<td>ed

<td>
"shrink_to_fint" should be "shrink_to_fit".

<p>
<br>

<td>

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK246

<td>23.3.2.2

<td>

<td>Ed

<td>The content of
this sub-clause is purely trying to describe in words the
effect of the requires clauses on these operations, now
that we have Concepts. As such, the desctiption is more
confusing than the signature itself. The semantic for these
functions is adequately covered in the requirements tables
in 23.1.4.

<td>Strike 23.3.2.2 entirely. (but do NOT
strike these signatures from the class template
definition!)

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK247

<td>24.1

<td>

<td>Ge

<td>Iterator
concepts are not extensive enough to merit a whole new
header, and should be merged into &lt;concpts&gt;. This is
particularly important for supporting the new for loop
syntax which requires access to the Range concept. The
required header to enable this syntax shoud have a simple
name, like &lt;concepts&gt;, rather than something awkward
to type like &lt;iterator_concepts&gt;.

<td>Move the concepts of
&lt;iterator_concepts&gt; into the &lt;concepts&gt; header.
We take no position on moving the text from Clause 24 to
Clause 20 though.

<td>NAD. We believe the separate header to have value.<br>

    

<tr valign="top">
<td>UK248

<td>24.1

<td>6

<td>Ed

<td>The text "so for
any iterator type there is an iterator value that points
past the last element of a corresponding container" is
slightly misleading. Iterators can refer into generalised
ranges and sequences, not just containers. A broader term
than 'container' should be used.

<td>Replace the reference to container with a
more appropriate concept

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK250

<td>24.1.1

<td>

<td>Te

<td>A default implementation should be supplied
for the post-increment operator to simplify implementation
of iterators by users.

<td>Copy the Effects clause into the concept
description as the default implementation. Assumes a
default value for postincrement_result

<td>Howard will open an issue.<br>

    

<tr valign="top">
<td>UK251

<td>24.1.1

<td>3

<td>Te

<td>The
post-increment operator is dangerous for a general
InputIterator. The multi-pass guarantees that make it
meaningful are defined as part of the ForwardIterator
refinement. Any change will affect only constrained
templates that have not yet been written, so should not
break existing user iterators which remain free to add
these operations. This change will also affect the
generalised OutputIterator, although there is no percieved
need for the post-increment operator in this case either.

<td>Move declaration of postincrement operator
and postincrement_result type from Interator concept to the
ForwardIterator concept

<td>Alisdair will open an issue.<br>

    

<tr valign="top">
<td><p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK252

<p>

<td>24.1.2

<td>3

<td>Ed

<td>istream_iterator is not a class, but a
class template

<td>Change 'class' to 'class template' in the
note.

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK253

<td>24.1.3

<td>1

<td>Ed

<td>First sentance
does not make gramatical sense, Seems to be missing the
words 'if it' by comparison with similar sentance in other
subsections

<td>Add the words 'if it' : "X satisfies the
requirements of an output iterator IF IT meets the
syntactic and semantic requirements"

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK254

<td>24.1.3

<td>5

<td>Te

<td>This
postcondition for pre-increment operator should be written
as an axiom

<td>Move the postcondition into the concept
definition as an axiom

<td>deferred until we know whether we have axioms.<br>

    

<tr valign="top">
<td>UK255

<td>24.1.4

<td>4

<td>Te

<td>This
postcondition for pre-increment operator should be written
as an axiom

<td>Move the postcondition into the concept
definition as an axiom

<td>deferred until we know whether we have axioms.<br>

    

<tr valign="top">
<td>UK256

<td>24.1.5

<td>3, 4, 5

<td>Te

<td>The relationship between pre- and post-
decrement should be expressed as an axiom.

<td>Move the text
specification of pre/post-conditions and behaviour into an
axiom within the BidirectionalIterator concept

<td>deferred until we know whether we have axioms.<br>

    

<tr valign="top">
<td>UK257

<td>24.1.5

<td>

<td>Te

<td>There is a
reasonable default for postdecrement_result type, which is
X. X is required to be regular, therefore CopyConstructible
and a valid ResultType. Together with the next comment this
simplifies user defined iterator implentations

<td>Add the default : typename
postincrement_result = X;

<td>NAD, postdecrement_result is deduced.<br>

    

<tr valign="top">
<td>UK258

<td>24.1.5

<td>

<td>Te

<td>A default
implementation should be supplied for the post-decrement
operator to simplify implementation of iterators by users.

<td>Copy the Effects clause into the concept
description as the default implementation. Assumes a
default value for postincrement_result

<td>Howard will open an issue.<br>

    

<tr valign="top">
<td>UK259

<td>24.1.5

<td>

<td>Te

<td>
postdecrement_result is effectively returning a copy of the
original iterator value, so should have similar
constraints, rather than just HasDereference. If Concepts
do not support this circularity of definition suggest that
concepts feature may want a little more work

<td>Add the requirement: requires Iterator&lt;
postdecrement_result &gt;;

<td>NAD unless Alisdair comes back with more motivation.<br>

    

<tr valign="top">
<td>UK260

<td>24.1.5

<td>6

<td>Te

<td>The effects clause for post-decrement
iterator should be available as an axiom and a default
implementation, where the compiler can make better use of
it.

<td>Move the Effects
clause into the BidirectionalIterator concept definition as
an axiom, and as the default implementation for the
operation.

<td>deferred for axiom decision.<br>

    

<tr valign="top">
<td>UK249

<td><span lang=
"en-US">24.1.6</span>

<td>2

<td>Te

<td>The semantic for
operator+= should also be provided as a default
implementation to simplify implementation of user-defined
iterators

<td>Copy the text from the effects clause into
the RandomAccessIterator concept as the default
implementaiton.

<td>NAD, violates complexity requirements.<br>

    

<tr valign="top">
<td>UK261

<td>24.1.6

<td>

<td>Te

<td>To simplify user
defined random access iterator types, the
subscript_reference type should default to reference

<td>typename subscript_reference = reference;

<td>NAD, subscript reference isnt used.<p>In 
c++std-lib-23104, <span class="gI">
<span email="daniel.kruegler@googlemail.com" class="gD">Daniel Krgler 
commented,</span><span email="daniel.kruegler@googlemail.com" class="gD" style="color: rgb(0, 104, 28);">
</span></span>this [proposed change] would disable &quot;auto-deduction&quot; of 
the return type of any operator[]as described by [concept.map.assoc]/4+5.

<tr valign="top">
<td>UK262

<td>24.1.6

<td>3, 4

<td>Te

<td>Effects and post-conditions for operator+
are more useful if expressed as axioms, and supplied as
default implementations.

<td>Move the effects
and Postcondition definitions into the RandomAccessIterator
concept and copy the code in the specification as the
default implementation of these operations.

<td>default implementation already in Standard; axiom part 
deferred.<br>

    

<tr valign="top">
<td>UK263

<td>24.1.6

<td>5

<td>Te

<td>This requirement on operator-= would be
better expressed as a default implementation in the
concept, with a matching axiom

<td>Move the
specification for operator-= from the returns clause into
an axiom and default implementation within the
RandomAccessIterator concept

<td>Alisdair will open an issue, axiom part deferred.<br>

    

<tr valign="top">
<td>UK264

<td>24.1.6

<td>6

<td>Te

<td>Effects clauses are better expressed as
axioms where possible.

<td>Move code in
operator- effects clause into RandomAccessIterator concept
as both a default implementation and an axiom

<td>deferred/axiom.<br>

    

<tr valign="top">
<td>UK265

<td>24.1.6

<td>8

<td>Te

<td>This effects
clause is nonesense. It looks more like an axiom stating
equivalence, and certainly an effects clause cannot change
the state of two arguments passed by const reference

<td>Strike the Effects clause

<td>Doug will open issuestrike effect, returns n.<br>

    

<tr valign="top">
<td>UK266

<td>24.1.6

<td>9

<td>Te

<td>This sentance should be provided as a
default definition, along with a matching axiom

<td>Move the Returns
clause into the spefication for RandomAccessIterator
operator- as a default implementation. Move the Effects
clause as the matching axiom.

<td>default definition is not implementable; axiom part 
deferred.<br>

    

<tr valign="top">
<td>UK267

<td>24.1.6

<td>24.1.6

<td>Te

<td>The code in the
Requires clause for RandomAccessIterator operator[] would
be better expressed as an axiom.

<td>Rewrite the Requires clause as an axiom in
the RandomAccessIterator concept

<td>deferred/axiom.<br>

    

<tr valign="top">
<td>UK268

<td>24.1.6

<td>12

<td>Ed

<td>This note is
potentialy confusing as __far enters the syntax as a clear
language extension, but the note treats it as a regular
part of the grammar. It might be better expressed using
attributes in the current wording.

<td>Clean up the note to either avoid using
language extension, or spell out this is a constraint to
support extensions.

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>JP60

<td>24.1.8

<td>1<sup>st</sup> <font size="2"
style="font-size: 11pt">para</font>

<td>te

<td>
Capability of an iterator is too much restricted by
concept.

<p>
<br>

<p>
Concept of std::Range is defined as:

<p>
<br>

<p>
concept Range&lt;typename T&gt; {

<p>
InputIterator iterator;

<p>
iterator begin(T&amp;);

<p>
iterator end(T&amp;);

<p>}

<p>
<br>

<p>So
the following code generates an error.

<p>
<br>

<p>
template &lt;std::Range Rng&gt;

<p>
void sort(Rng&amp; r)

<p>{

<p style=
"margin-left: 0.08in; text-indent: -0.08in; margin-bottom: 0in">
// error! Rng::iterator does not satisfy requirements of a
random

<p style=
"margin-left: 0.07in; text-indent: 0.08in; margin-bottom: 0in">
// access iterator.

<p>
std::sort(begin(r), end(r));

<p>}

<p>
<br>

<p>
std::vector&lt;int&gt; v; // vector::iterator is a random
access iterator.

<p>
sort(v);

<p>
<br>

<p>
This is because the concept of an iterator of std::Range is
InputIterator. For this reason, a random access iterator
loses its capability when passed to a std::Range parameter.

<p>
<br>

<p>To
be able to work the above code, we need to write as
follows:

<p>
<br>

<p>
template &lt;std::Range T&gt;

<p>
requires std::RandomAccessIterator&lt;T::iterator&gt;
&amp;&amp;

<p>
std::ShuffleIterator&lt;T::iterator&gt; &amp;&amp;

<p>
std::LessThanComparable&lt;T::iterator::value_type&gt;

<p>
void sort(T&amp; r)

<p>{

<p>
sort(begin(r), end(r));

<p>}

<p>
<br>

<p>
std::vector&lt;int&gt; v;

<p>
sort(v);

<p>
<br>

<p>It
needs quiet a few amount of codes like this only to recover
random access capability from InputIterator concept.

<p>
<br>

<p>We
can write the following valid code with Boost.Range, which
is implemented with using C++03 SFINAE.

<p>
<br>

<p>
template &lt;class Range&gt;

<p>
void sort(Range&amp; r)

<p>{

<p>
std::sort(boost::begin(r), boost::end(r));

<p>}

<p>
<br>

<p>
std::vector&lt;int&gt; v;

<p>
sort(v); // OK

<p>
<br>

<p>One of the
motivation to introduce concepts are supporting template
programming techniques by language directly to eliminate
hacky techniques such as tag-dispatch, SFINAE and Type
Traints. But SFINAE will be kept using because it needs
quite a few amount of codes without using SFAINAE.

<p>
<br>

<td>Add
InputRange, OutputRange, ForwardRange, BidirectionalRange
and RandomAccessRange.

<td>NAD, beyond the scope of the Standard because we are not 
supplying range-based algorithms.<br>

    

<tr valign="top">
<td>UK269

<td>24.3

<td>3

<td>Ed

<td>'decrements for
negative n' seems to imply a negative number of decrement
operations, which is odd.

<td>Need simple, clearer wording

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK270

<td>24.3

<td>4

<td>Te

<td>The reachability
constraint in p5 means that a negavite result, implying
decrements operations in p4, is not possible

<td>Split the two overloads into separate
descriptions, where reachability is permitted to be in
either direction for RandomAccessIterator

<td>Howard will open an issue.<br>

    

<tr valign="top">
<td>UK271

<td>24.3

<td>6,7

<td>Te

<td>next/prev return
an incremented iterator without changing the value of the
original iterator. However, even this may invalidate an
InputIterator. A ForwardIterator is required to guarantee
the 'multipass' property.

<td>Replace InputIterator constraint with
FOrwardIterator in next and prev function templates.

<td>Alisdair will open an issue.<br>

    

<tr valign="top">
<td>UK272

<td>24.4

<td>

<td>Te

<td>reverse_iterator
and move_iterator use different formulations for their
comparison operations. move_iterator merely requires the
minimal set of operations, &lt; and ==, from its underlying
iterator and synthesizes all oprations from these two.
reverse_iterator relies on the undelying iterator to
support all comparision operations directly. In practice,
move_iterator can only be implemented this way as it must
support iterator types that are merely InputIterators, and
so SemiRegular and not Regular. However, reserse_iterator
has an existing specification and any change of semantic
could change behaviour of conforming programs today -
although an iterator that yields different results for (a
&gt; b) than (b &lt; a) may fall foul of some semantic
consistency requirements, even if the syntax is met.

<td>Rephrase the reverse_iterator comparison
operations using only operators &lt; and ==, as per the
move_iterator specification.

<td>NAD, no consensus.<br>

    

<tr valign="top">
<td>UK274

<td>24.4, 24.5

<td>

<td>Ed

<td>The subclauses
for standard iterator adaptors could be better organised.
There are essentially 3 kinds of iterator wrappers
provided, stream iterators adapt streams and get their own
subsection. insert iterators adapt containers, and get
their own subsection but it is inserted into the middle of
24.4 Predifined iterators. reverse_iterator and
move_iterator adpat other iterators, but their presentation
is split by insert iterators

<td>Promote 24.4.2 [insert.iterators] up one
level to 24.6. Emphasize that insert iterators adapt
containers Retarget 24.4 [predef.iterators] as iterator
adapters for iterator templates that wrap other iterators.

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK275

<td>24.4.1.1

<td>

<td>Te

<td>The constructor
template taking a single Iterator argument will be selected
for Copy Initialization instead of the non-template
constructor taking a single Iterator argument selected by
Direct Initialization.

<td>The reverse_iterator template constructor
taking a single Iterator argument should be explicit.

<td>NAD, withdrawn by submitter.<br>

    

<tr valign="top">
<td>UK276

<td>24.4.1.1

<td>

<td>Ed

<td>It is odd to
have a mix of declaration stlyes for operator+ overloads.
Prefer if either all are member functions, or all are
'free' functions.

<td>Make the member operators taking a
difference_type argument non-member operators

<td>NAD, not editorial, withdrawn by submitter.<br>

    

<tr valign="top">
<td>UK277

<td>24.4.1.2.1

<td>1

<td>Te

<td>The default
constructor default-initializes current, rather than
value-initializes. This means that when Iterator
corresponds to a trivial type, the current member is left
un-initialized, even when the user explictly requests value
intialization! At this point, it is not safe to perform any
operations on the reverse_iterator other than assign it a
new value or destroy it. Note that this does correspond to
the basic definition of a singular iterator.

<td>i/ Specify value initialization rather than
default intialization or ii/ specify = default; rather than
spell out the semantic. This will at least allow users to
select value initialization and copy the iterator value. or
iii/ Add a note to the description emphasizing the singular
nature of a value-initialized reserve iterator.

<td>agree with option i, Alisdair will open an issue.<br>

    

<tr valign="top">
<td>UK278

<td>24.4.1.2.1

<td>3

<td>Te

<td>There is an
inconsistency between the constructor taking an iterator
and the constructor template taking a reverse_iterator
where one passes by value, and the other by const
reference. The by-value form is preferred as it allows for
efficient moving when copy elision fails to kick in.

<td>Change the const reverse_iterator&lt;U&gt;
&amp; parameter to pass-by-value

<td>NAD, we dont believe that copy elision is a 
sufficiently high priority for iterator types.<br>

    

<tr valign="top">
<td>UK279

<td>24.4.1.<br>
2.12,<br>
24.4.3.<br>
2.12

<td>

<td>Te

<td>The reason the
return type became unspecified is LWG issue 386. This
reasoning no longer applies as there are at least two ways
to get the right return type with the new language
facilities added since the previous standard.

<td>Specify the return type using either
decltype or the Iter concept map

<td>under discussion. This is a general question about all 
iterator adapters.<br>

    

<tr valign="top">
<td>UK280

<td>24.4.1.<br>
2.4

<td>

<td>Ed

<td>The presence of
the second iterator value is surprising for many readers
who underestimate the size of a reverse_iterator object.
Adding the exposition only member that is required by the
semantic will reduce confusion.

<td>Add reverse_iterator expsoition only member
tmp as a comment to class declaration, as a private member

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK281

<td>24.4.1.<br>
2.5

<td>

<td>Te

<td>The current
specification for return value will always be a true
pointer type, but reverse_iterator supports proxy iterators
where the pointer type may be some kind of 'smart pointer'

<td>Replace the existing returns specification
with a copy of the operator* specification that returns
this-&gt;tmp.operator-&gt;

<td>study group formed to come up with a suggested 
resolution.<br>

    

<tr valign="top">
<td>UK282

<td>24.4.2.1,<br>
24.4.2.2.2,<br>
24.4.2.3,<br>
24.4.2.4.2,<br>
24.4.2.5,<br>
24.4.2.6.2

<td>n/a

<td>Te

<td>Insert iterators of move-only types will
move from lvalues

<td>Add an additional constrained overload for
operator= that requires
!CopyConstructible&lt;Cont::value_type&gt; and mark it
=delete.

<td>deferred to discussion of N2831.<br>

    

<tr valign="top">
<td>UK283

<td>24.4.2.5,<br>
24.4.2.6.4

<td>

<td>Te

<td>postincrement operator overloads
traditionally return by value - insert_iterator is declared
as return by reference. The change is harmless in this
case, but either front/back_insert_iterator should take the
matching change for consistency, or this function should
return-by-value

<td>change operator++(int) overload to return
by value, not reference. Affects both class summary and
operator definition in p

<td>NAD. This is compatible with C++03; and we lack a 
consensus for change.<br>

    

<tr valign="top">
<td>JP61

<td>24.4.3.2.1

<td>2<sup>nd</sup> <font size="2"
style="font-size: 11pt">para, 1<sup>st</sup>
line</font>

<td>ed

<td>
Typo.

<p>
"intializing" should be "in<u>i</u>tializing"

<td>Add
"i"

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK284

<td>24.5

<td>

<td>Te

<td>The stream
iterators need constraining with concepts/requrires
clauses.

<td>Provide constraints

<td>We agree. To be handled by Howard, Martin and PJ.<br>

    

<tr valign="top">
<td>UK285

<td>24.5.1

<td>1,2

<td>Ed

<td>Much of the
content of p1 and the whole of p2 is a redundant
redefinition of InputIterator. It should be simplified

<td>Strike p2. Simplify p1 and add a
cross-reference to the definition of InputIterator concept.

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK286

<td>24.5.1

<td>3

<td>Ed

<td>To the casual
reader it is not clear if it is intended to be able to
assign to istream_iterator objects. Specifying the copy
constructor but relying on the implicit copy-assign
operator is confusing.

<td>Either provide a similar definition to the
copy-assign operator as for the copy constructor, or strike
the copy constructor

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK287

<td>24.5.1.1

<td>2

<td>Te

<td>It is not clear
what the intial state of an istream_iterator should be. Is
_value_ initialized by reading the stream, or default/value
initialized? If it is initialized by reading the stream,
what happens if the initialization is deferred until first
dereference, when ideally the iterator value should have
been that of an end-of-stream iterator which is not safely
dereferencable?

<td>Specify _value_ is initialized by reading
the stream, or the iterator takes on the end-of-stream
value if the stream is empty

<td>Martin will address with existing LWG
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#788">issue 788</a>.<br>

    

<tr valign="top">
<td>UK288

<td>24.5.1.1

<td>3

<td>Ed

<td>The provided specification is vacuous,
offering no useful information.

<td>Either strike
the specification of the copy constructor, or simply
replace it with an = default definition.

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK289

<td>24.5.1.2

<td>6

<td>Ed

<td>It is very hard
to pick up the correct specification for
istream_iterator::operator== as the complete specification
requires reading two quite disconnected paragraphs,
24.5.1p3, and 24.5.1.2p6. Reading just the specifaction of
the operation itself suggests that end-of-stream iterators
are indistinguishable from 'valid' stream iterators, which
is a very dangerous misreading.

<td>Merge 24.5.1p3, equality comparison of
end-of-stream-iterators, into 24.5.1.2p6, the specification
of the equality operator for istream_iterator.

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK290

<td>24.5.2

<td>1

<td>Te

<td>The character
type of a string delimiter for an ostream_iterator should
be const charT *, the type of the elements, not char *, a
narrow character string.

<td>Replace char * with const charT *

<td>We agree and believe it to be editorial.<br>

    

<tr valign="top">
<td>UK291

<td>24.5.2.2

<td>2

<td>Te

<td>ostream_iterator
postincrement operator returns by reference rather than by
value. This may be a small efficiency gain, but it is
otherwise unconventional. Prefer return-by-value.

<td>ostream_iterator operator++(int);

<td>NAD. This is compatible with C++03; and we lack a 
consensus for change.<br>

    

<tr valign="top">
<td>FR34

<td>24.5.3<br>
[istream-<br>
buf.<br>
iterator]

<td>

<td>ed

<td>There are two public
sections, and the content of the second one is indented
with respect to the first. I don't it should be.

<p>

<td>

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK292

<td>24.5.3

<td>1

<td>Ed

<td>Prefer the use
of the new nullptr constant to the zero literal when using
a null pointer in text.

<td>Change istreambuf_iterator(0) to
istreambuf_iterator(nullptr)

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK293

<td>24.5.3

<td>2,3,4

<td>Ed

<td>The listed paragraphs redundantly redefine
an input iterator, and redundancy can be a dangerous thing
in a specification. Suggest a simpler phrasing below.

<td>2. The result of
operator*() on an end of stream is undefined. For any other
iterator value a char_type value is returned. 3. Two end of
stream iterators are always equal. An end of stream
iterator is not equal to a non-end of stream iterator. 4.
As istreambuf_iterator() is an InputIterator but not a
ForwardIterator, istreambuf_iterators object can be used
only for one-pass algorithms. It is not possible to assign
a character via an input iterator.

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK294

<td>24.5.3.2

<td>2

<td>Te

<td>Implicit converting constructors can be
invoked at surprising times, so there should always be a
good reason for declaring one.

<td>Mark the two
single-argument constructors take a stream or stream buffer
as explicit. The proxy constructor should remain implicit.
explicit
istreambuf_iterator(basic_istream&lt;charT,traits&gt;&amp;
s) throw(); explicit
istreambuf_iterator(basic_streambuf&lt;charT,traits&gt;* s)
throw();

<td>NAD. This could potentially [break] C++03-conforming 
programs.<br>

    

<tr valign="top">
<td>UK295

<td>25

<td>

<td>Te

<td>THere is a level
of redundancy in the library specification for many
algorithms that can be eliminated with the combination of
concepts and default parameters for function templates.
Eliminating redundancy simplified specification and reduces
the risk of inttroducing accidental inconsistencies.

<td>Adopt n2743, or an update of that paper.

<td>NAD, this change would break code that takes the address 
of an algorithm.<br>

    

<tr valign="top">
<td>JP62

<td>25, 25.3.1.5,<br>
26.3.6.5

<td>

<td>te

<td><p style=
"margin-left: 0.2in; text-indent: -0.2in; margin-bottom: 0in">
The return types of is_sorted_until function and
is_heap_until function are iterator. But basically, the
return type of is_xxx function is bool. And the return type
of lower_bound function and upper_bound is iterator.

<p style=
"text-indent: 0.2in; margin-top: 0.04in; margin-bottom: 0.04in">
So we think that it is reasonable to change those two
functions.

<p style=
"text-indent: 0.2in; margin-top: 0.04in"><br>

<td>
Change "is_sorted_until" to "sorted_bound"

<p>
Change "is_heap" to "heap_bound"

<td>no consensus to make the change.<br>

    

<tr valign="top">
<td>UK296

<td>25.1.8

<td>1

<td>Te

<td>The 'Returns' of
adjacent_find requires only HasEqualTo, or a Predicate.
Requiring EqualityComparable or EquivalenceRelation seems
too strong and not useful.

<td>Change EqualityComparable to HasEqualTo and
EquivalnceRelation to Predicate

<td>no consensus to make the change.<br>

    

<tr valign="top">
<td>UK297

<td>25.2.11

<td>6

<td>Ed

<td>The definition
of rotate_copy is very complicated. It is equivalent to:
return copy(first, middle, copy(middle, last, result));

<td>Change 'effects' to, returns, requires,
complexity to: effects: equivalent to: return copy(first,
middle, copy(middle, last, result));

<td>Editor requests guidance: we agree that it is editorial.<br>

    

<tr valign="top">
<td>UK298

<td>25.2.13

<td>13

<td>Te

<td>partition_point requires a partitioned
array

<td>requires: is_partitioned(first, last, pred)
!= false;

<td>We agree with the suggested change and believe that it 
is editorial.<br>

    

<tr valign="top">
<td>UK299

<td>25.2.2

<td>

<td>Ed

<td>Should be consistent in style use of
concepts in template parameter lists. The
auto-OutputIterator sytle used in std::copy is probably
preferred.

<td>Change way signature is declared:
template&lt;InputIterator InIter, OutputIterator&lt;auto,
RvalueOf&lt;InIter::reference&gt;::type&gt; OutIter&gt;
OutIter move(InIter first, InIter last, OutIter result);

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK300

<td>25.2.3

<td>

<td>Te

<td>Since publishing
the original standard, we have learned that swap is a
fundamental operation, and several common idioms rely on it
- especially those related to exception safety. As such it
belongs in the common &lt;utility&gt; header rather than
the broader &lt;algorithm&gt; header, and likewise should
move to clause 20. For backwards compatiblility the
algorithm header should be required to #include
&lt;utility&gt;, which would be covered in the resolution
of LWG issue 343. There are already dependencies in
&lt;algorithm&gt; on types declared in this header, so this
comment does not create a new dependency.

<td>Move primary swap template from
&lt;algorithm&gt; into &lt;utility&gt;. Move 25.2.3 to
somewhere under 20.2. Require &lt;algorithm&gt; to #include
&lt;utility&gt; to access pair and provide legacy support
for finding swap.

<td>no consensus to make the change.<br>

    

<tr valign="top">
<td>UK301

<td>25.2.5

<td>

<td>Te

<td>replace and
replace_if have the requirement: OutputIterator&lt;Iter,
Iter::reference&gt; Which implies they need to copy some
values in the range the algorithm is iterating over. This
is not however the case, the only thing that happens is
const T&amp;s might be copied over existing elements (hence
the OutputIterator&lt;Iter, const T&amp;&gt;

<td>Remove OutputIterator&lt;Iter,
Iter::reference&gt; from replace and replace_if

<td>agreed. Howard will open an issue.<br>

    

<tr valign="top">
<td>UK302

<td>25.3

<td>4

<td>Ed

<td>the concept
StrictWeakOrder covers the definition of a strict weak
ordering, described in paragraph 4.

<td>Remove 4, and mention StrictWeakOrder in
paragraph 1.

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK303

<td>25.3

<td>6

<td>Ed

<td>This paragraph just describes
is_partitioned

<td>6 A sequence
[start,finish) is partitioned with respect to an expression
f(e) if is_partitioned(start, finish, e) != false

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK304

<td>25.3.6

<td>

<td>Ed

<td>The requires
clauses of push_heap, pop_heap and make_heap are
inconsistently formatted, dispite being identical

<td>Format them identically.

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>UK305

<td>25.3.7

<td>1, 9, 17

<td>Te

<td>The negative requirement on IsSameType is a
hold-over from an earlier draught with a variadic template
form of min/max algorith. It is no longer necessary.

<td>Strike the !IsSameType&lt;T, Compare&gt;
constraint on min/max/minmax algorithms

<td>agreed. We request that someone from the UK open an 
issue.<br>

    

<tr valign="top">
<td>US84

<td>26

<td>

<td>ge

<td>
Parts of the numerics chapter are not concept enabled.

<td>

<td>The portions of this comment dealing 
with random numbers are resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">
N2836</a>, which was accepted in New Jersey.<br>

    

<tr valign="top">
<td>FR35

<td>26.3<br>
[Complex<br>
&nbsp;numbers]

<td>

<td>te

<td>Instantiations of the class
template complex&lt;&gt; have to be allowed for integral
types, to reflect existing practice and ISO standards
(LIA-III).

<p>

<td>

<td>

<tr valign="top">
<td>UK306

<td>26.4

<td>

<td>Te

<td>Random number
library component cannot be used in constrained templates

<td>Provide constraints for the random number
library

<td>Resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">
N2836</a>, which was accepted in New Jersey.<br>

    

<tr valign="top">
<td>JP63

<td>26.4.8.5.1

<td>

<td>te

<td>No
constructor of discrete_distribution that accepts
initializer_list.

<p>
discrete_distribution initialize distribution by a given
range (iterators), but temporary variable of a container or
an array is needed in the following case.

<p>
<br>

<p>int
ar[] = {1, 2, 3};

<p>
discrete_distribution&lt;&gt; dist(ar, ar+3);

<p>
<br>

<p>Other libraries
also accept initializer_list, so change
discrete_distribution library to accept initializer_list
too.

<p>
<br>

<td>Add
the following constructer.

<p>
<u>discrete_distribution(initializer_list&lt;result_type&gt;);</u>

<td>Resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">
N2836</a>, which was accepted in New Jersey.</p>
<p>This comment is also covered by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#874">
issue 874</a>. [Suggested by <span class="gI">
<span email="daniel.kruegler@googlemail.com" class="gD">Daniel Krgler 
and confirmed by the submitter.]</span></span><p><br>

    

<tr valign="top">
<td>JP64

<td>26.5.2

<td>

<td>te

<td>
&#8220;valarray&lt;T&gt;&amp; operator+=
(initializer_list&lt;T&gt;);&#8221; is not defined.

<p>
<br>

<td>Add
valarray&lt;T&gt;&amp; operator+=
(initializer_list&lt;T&gt;);

<td>

<tr valign="top">
<td>UK307

<td>26.7

<td>Footnote 288

<td>Ed

<td>The footnote
refers to TR1, which is not a defined term in this
standard. Drop the reference to TR1, those templates are a
regular part of the standard now and how they were
introduced is no longer relevant.

<td>Drop the reference to TR1.

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>US85

<td>27

<td>

<td>ge

<td>The
input/output chapter is not concept enabled.

<td>

<td>

<tr valign="top">
<td>UK308

<td>27

<td>

<td>Te

<td>
<span lang="en-US">iostreams library cannot be used from
constrained templates</span>

<td>Provide constraints for the iostreams
library, clause 27

<td>

<tr valign="top">
<td>JP65

<td>27.4.4

<td>

<td>te

<td>Switch from
&#8220;unspecified-bool-type&#8221; to<span lang=
"zxx">&#12288;&#8220;</span>explicit operator bool()
const&#8221;.

<p>
<br>

<td>
Replace "operator <i>unspecified-bool-type</i>() const;"
with "explicit operator bool() const;"

<td>

<tr valign="top">
<td>JP66

<td>27.4.4.3

<td>1<sup>st</sup> <font size="2"
style="font-size: 11pt">para</font>

<td>te

<td>Switch from
&#8220;unspecified-bool-type&#8221; to<span lang=
"zxx">&#12288;&#8220;</span>explicit operator bool()
const&#8221;

<p>
<br>

<td>
Replace "operator <i>unspecified-bool-type</i>() const;"
with "explicit operator bool() const;"

<td>

<tr valign="top">
<td>FR36

<td>27.6.1.2.2<br>
[istream.<br>
formatted.<br>
arithmetic]

<td>1, 2, and 3

<td>ed

<td>iostate err = 0;

<p>

<p>iostate is a bitmask type and
so could be an enumeration. Probably using

<p>goodbit is the solution.

<p>

<td>

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>FR37

<td>27.6.1.2.2<br>
[istream.<br>
formatted.<br>
arithmetic]

<td>3

<td>ed

<td>else if (lval &lt;
numeric_limits&lt;int&gt;::min()

<p>||
numeric_limits&lt;int&gt;::max() &lt; lval))

<p>

<p>The parentheses aren't
balanced.

<p>

<td>

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>JP67

<td>27.7.1

<td>

<td>te

<td>
basic_stringbuf dose not use concept.

<td>
Replace &#8220;class Allocator&#8221; to &#8220;Allocator
Alloc&#8221;.

<p>
&nbsp; Correct as follows.

<p>
<br>

<p>
namespace std {

<p>
template &lt;class charT, class traits =
char_traits&lt;charT&gt;,

<p>
<u>Allocator Alloc</u> = allocator&lt;charT&gt; &gt;

<p>
class basic_stringbuf : public
basic_streambuf&lt;charT,traits&gt; {

<p>
public:

<p>...

<p>
<br>

<p>//
27.7.1.1 Constructors:

<p>
explicit basic_stringbuf(ios_base::openmode which

<p>=
ios_base::in | ios_base::out);

<p>
explicit basic_stringbuf

<p>
(const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
str,

<p>
ios_base::openmode which = ios_base::in | ios_base::out);

<p>
basic_stringbuf(basic_stringbuf&amp;&amp; rhs);

<p>
&nbsp;

<p>...

<p>
&nbsp;

<p>
&nbsp;

<p>//
27.7.1.3 Get and set:

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt; str() const;

<p>
void str(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; s);

<p>
&nbsp;

<p>...

<p>};

<p>
&nbsp;

<p>
template &lt;class charT, class traits, <u>Allocator
Alloc</u>&gt;

<p>
void swap(basic_stringbuf&lt;charT, traits,
<u>Alloc</u>&gt;&amp; x,

<p>
basic_stringbuf&lt;charT, traits, <u>Alloc</u>&gt;&amp; y);

<p>
template &lt;class charT, class traits, <u>Allocator
Alloc</u>&gt;

<p>
void swap(basic_stringbuf&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; x,

<p>
basic_stringbuf&lt;charT, traits, <u>Alloc</u>&gt;&amp; y);

<p>
template &lt;class charT, class traits, <u>Allocator
Alloc</u>&gt;

<p>
void swap(basic_stringbuf&lt;charT, traits,
<u>Alloc</u>&gt;&amp; x,

<p>
basic_stringbuf&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; y);

<p>}

<p>
<br>

<td>

<tr valign="top">
<td>JP68

<td>27.7.2

<td>

<td>te

<td>
basic_istringstream dose not use concept.

<td>
Replace &#8220;class Allocator&#8221; to &#8220;Allocator
Alloc&#8221;.

<p>
&nbsp; Correct as follows.

<p>
&nbsp;

<p>
namespace std {

<p>
template &lt;class charT, class traits =
char_traits&lt;charT&gt;,

<p>
<u>Allocator Alloc</u> = allocator&lt;charT&gt; &gt;

<p>
class basic_istringstream : public
basic_istream&lt;charT,traits&gt; {

<p>
public:

<p>
typedef charT char_type;

<p>
typedef typename traits::int_type int_type;

<p>
typedef typename traits::pos_type pos_type;

<p>
typedef typename traits::off_type off_type;

<p>
typedef traits traits_type;

<p>
typedef <u>Alloc</u> allocator_type;

<p>
<br>

<p>//
27.7.2.1 Constructors:

<p>
explicit basic_istringstream(ios_base::openmode which =
ios_base::in);

<p>
explicit basic_istringstream(

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
str,

<p>
ios_base::openmode which = ios_base::in);

<p>
basic_istringstream(basic_istringstream&amp;&amp; rhs);

<p>
&nbsp;

<p>//
27.7.2.2 Assign and swap:

<p>
basic_istringstream&amp;
operator=(basic_istringstream&amp;&amp; rhs);

<p>
void swap(basic_istringstream&amp;&amp; rhs);

<p>
&nbsp;

<p>//
27.7.2.3 Members:

<p>
basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt;* rdbuf()
const;

<p>
&nbsp;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt; str() const;

<p>
void str(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; s);

<p>
&nbsp;

<p>
private:

<p>//
basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt; sb;
exposition only

<p>};

<p>
&nbsp;

<p>
template &lt;class charT, class traits, <u>Allocator
Alloc</u>&gt;

<p>
void swap(basic_istringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; x,

<p>
basic_istringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
y);

<p>
template &lt;class charT, class traits, <u>Allocator
Alloc</u>&gt;

<p>
void swap(basic_istringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; x,

<p>
basic_istringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
y);

<p>
template &lt;class charT, class traits, <u>Allocator
Alloc</u>&gt;

<p>
void swap(basic_istringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; x,

<p>
basic_istringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; y);

<p>}

<td>

<tr valign="top">
<td>JP69

<td>27.7.3

<td>

<td>te

<td>
basic_ostringstream dose not use concept.

<td>
Replace &#8220;class Allocator&#8221; to &#8220;Allocator
Alloc&#8221;.

<p>
&nbsp; Correct as follows.

<p>
<br>

<p>
namespace std {

<p>
template &lt;class charT, class traits =
char_traits&lt;charT&gt;,

<p>
<u>Allocator Alloc</u> = allocator&lt;charT&gt; &gt;

<p>
class basic_ostringstream : public
basic_ostream&lt;charT,traits&gt; {

<p>
public:

<p>//
types:

<p>
typedef charT char_type;

<p>
typedef typename traits::int_type int_type;

<p>
typedef typename traits::pos_type pos_type;

<p>
typedef typename traits::off_type off_type;

<p>
typedef traits traits_type;

<p>
typedef <u>Alloc</u> allocator_type;

<p>
&nbsp;

<p>//
27.7.3.1 Constructors/destructor:

<p>
explicit basic_ostringstream(ios_base::openmode which =
ios_base::out);

<p>
explicit basic_ostringstream(

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
str,

<p>
ios_base::openmode which = ios_base::out);

<p>
basic_ostringstream(basic_ostringstream&amp;&amp; rhs);

<p>
&nbsp;

<p>//
27.7.3.2 Assign/swap:

<p>
basic_ostringstream&amp;
operator=(basic_ostringstream&amp;&amp; rhs);

<p>
void swap(basic_ostringstream&amp;&amp; rhs);

<p>
&nbsp;

<p>//
27.7.3.3 Members:

<p>
basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt;* rdbuf()
const;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt; str() const;

<p>
void str(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; s);

<p>
private:

<p>//
basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt; sb;
exposition only

<p>};

<p>
&nbsp;

<p>
template &lt;class charT, class traits, <u>Allocator</u>
<font size="2" style=
"font-size: 11pt"><u>Alloc</u>&gt;</font>

<p>
void swap(basic_ostringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; x,

<p>
basic_ostringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
y);

<p>
template &lt;class charT, class traits, <u>Allocator</u>
<font size="2" style=
"font-size: 11pt"><u>Alloc</u>&gt;</font>

<p>
void swap(basic_ostringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; x,

<p>
basic_ostringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
y);

<p>
template &lt;class charT, class traits, <u>Allocator
Alloc</u>&gt;

<p>
void swap(basic_ostringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; x,

<p>
basic_ostringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; y);

<p>}

<p>
<br>

<td>

<tr valign="top">
<td>JP71

<td>27.7.3

<td>

<td>ed

<td>
Typo.

<p>"template" is missing in
"class basic_ostringstream" of the title of the chapter.

<td>
Correct as follows.

<p>
27.7.3 Class basic_ostringstream

<p>
<br>

<p>
should be

<p>
<br>

<p>27.7.3 Class <u>template</u>
basic_ostringstream

<td>[Being reviewed by Editor]<br>

    

<tr valign="top">
<td>JP72

<td>27.7.4

<td>

<td>te

<td>
basic_stringstream dose not use concept.

<td>
Replace "class Allocator" to "Allocator Alloc".

<p>
&nbsp; Correct as follows.

<p>
&nbsp;

<p>
namespace std {

<p>
template &lt;class charT, class traits =
char_traits&lt;charT&gt;,

<p>
<u>Allocator Alloc</u> = allocator&lt;charT&gt; &gt;

<p>
class basic_stringstream

<p>:
public basic_iostream&lt;charT,traits&gt; {

<p>
public:

<p>//
types:

<p>
typedef charT char_type;

<p>
typedef typename traits::int_type int_type;

<p>
typedef typename traits::pos_type pos_type;

<p>
typedef typename traits::off_type off_type;

<p>
typedef traits traits_type;

<p>
typedef <u>Alloc</u> allocator_type;

<p>
&nbsp;

<p>//
constructors/destructor

<p>
explicit basic_stringstream(

<p>
ios_base::openmode which = ios_base::out|ios_base::in);

<p>
explicit basic_stringstream(

<p>
const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
str,

<p>
ios_base::openmode which = ios_base::out|ios_base::in);

<p>
basic_stringstream(basic_stringstream&amp;&amp; rhs);

<p>
&nbsp;

<p>//
27.7.5.1 Assign/swap:

<p>
void swap(basic_stringstream&amp;&amp; rhs);

<p>
&nbsp;

<p>//
Members:

<p>
basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt;* rdbuf()
const;

<p>
basic_string&lt;charT,traits,<u>Alloc</u>&gt; str() const;

<p>
void str(const
basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str);

<p>
private:

<p>//
basic_stringbuf&lt;charT, traits&gt; sb; exposition only

<p>};

<p>
&nbsp;

<p>
template &lt;class charT, class traits, <u>Allocator
Alloc</u>&gt;

<p>
void swap(basic_stringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; x,

<p>
basic_stringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
y);

<p>
template &lt;class charT, class traits, <u>Allocator</u>
<font size="2" style=
"font-size: 11pt"><u>Alloc</u>&gt;</font>

<p>
void swap(basic_stringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; x,

<p>
basic_stringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
y);

<p>
template &lt;class charT, class traits, <u>Allocator</u>
<font size="2" style=
"font-size: 11pt"><u>Alloc</u>&gt;</font>

<p>
void swap(basic_stringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp; x,

<p>
basic_stringstream&lt;charT, traits,
<u>Alloc</u>&gt;&amp;&amp; y);

<p>}

<td>

<tr valign="top">
<td>JP73

<td>27.8.1.14

<td>

<td>te

<td>It is a problem
from C++98, fstream cannot appoint a filename of wide
character string(const wchar_t and const wstring&amp;).

<p>
<br>

<td>Add
interface corresponding to wchar_t, char16_t and char32_t.

<td>

<tr valign="top">
<td>US86

<td>28

<td>

<td>ge

<td>The
regular expressions chapter is not concept enabled.

<td>

<td>US86, UK309, UK310: We believe that an issue can be 
opened and we await a volunteer.<br>

    

<tr valign="top">
<td>UK309

<td>28

<td>

<td>Te

<td>Regular
expressions cannot be used in constrained templates

<td>Provide constraints for the regular
expression library, clause 28

<td>US86, UK309, UK310: We believe that an issue can be 
opened and we await a volunteer.<br>

    

<tr valign="top">
<td>UK310

<td>28

<td>

<td>Te

<td>The regex chapter uses iterators in the old
pre-concept style, it should be changed to use concepts
instead.

<td>Use concepts for iterator template
arguments throughout.

<td>US86, UK309, UK310: We believe that an issue can be 
opened and we await a volunteer.

<tr valign="top">
<td>UK314

<td>28.4

<td>

<td>Te

<td>The swap
overloads for regex classes are only supplied for l-value
references. Other sections of the library (eg 21 strings or
23 containers) provide two extra overloads taking an
r-value reference as the first and second argument
respectively.

<td>Add the missing overloads to 28.4 and the
corresponding later sections in 28 for each swap function.
We want to accept AMs paper which proposes a single
overload with two r-value references

<td>deferred to discussion of N2831.<br>

    

<tr valign="top">
<td>UK315

<td>28.4

<td>p6

<td>Te

<td>6 Effects:
string_type str(first, last); return
use_facet&lt;collate&lt;charT&gt; &gt;(
getloc()).transform(&amp;*str.begin(), &amp;*str.end()); Is
it legal to dereference str.end() ?

<td>Reword to effect clause to use legal
iterator dereferences

<td>We believe that this is editorial.<br>

    

<tr valign="top">
<td>UK316

<td>28.4 ff

<td>

<td>Te

<td>The constructors
for regex classes do not have an r-value overload.

<td>Add the missing r-value constructors to
regex classes.

<td>We agree and await assistance from the UK.<br>

    

<tr valign="top">
<td>UK317

<td>28.8

<td>

<td>Te

<td>basic_string has both a constructor and an
assignment operator that accepts an initializer list,
basic_regex should have the same.

<td>In the
basic_regex synopsis, after: basic_regex&amp;
operator=(const charT* ptr); add: basic_regex&amp;
operator=(initializer_list&lt;charT&gt; il); And after
paragraph 20 add: basic_regex&amp;
operator=(initializer_list&lt;charT&gt; il); Effects:
returns assign(il.begin(), il.end());

<td>UK317, JP74: Alisdair will open an issue.<br>

    

<tr valign="top">
<td>JP74

<td>28.8

<td>

<td>te

<td>
&#8220;basic_regx &amp; operator=
(initializer_list&lt;T&gt;);&#8221; is not defined.

<p>
<br>

<td>Add
basic_regx &amp; operator= (initializer_list&lt;T&gt;);

<td>UK317, JP74: Alisdair will open an issue.<br>

    

<tr valign="top">
<td>UK318

<td>28.8.2

<td>para 22

<td>Ed

<td>Constructor
definition should appear with the other constructors not
after assignment ops.

<td>Move para 22 to just after para 17.

<td>

<tr valign="top">
<td>UK319

<td>28.12.2

<td>

<td>Te

<td>It was always expected that
regex_token_iterator would be constructible from an array
literal: indeed ideally this is the prefered method of
initializing such an object. However, the best we could do
in C++0x was: template &lt;std::size_t N&gt;
regex_token_iterator(BidirectionalIterator a,
BidirectionalIterator b, const regex_type&amp; re, const
int (&amp;submatches)[N], regex_constants::match_flag_type
m = regex_constants::match_default); Now that we have
initializer_lists we should use them to remove this
particular wart.

<td>To the synopsis
for regex_token_iterator, after template &lt;std::size_t
N&gt; regex_token_iterator(BidirectionalIterator a,
BidirectionalIterator b, const regex_type&amp; re, const
int (&amp;submatches)[N], regex_constants::match_flag_type
m = regex_constants::match_default); add
regex_token_iterator(BidirectionalIterator a,
BidirectionalIterator b, const regex_type&amp; re,
initializer_list&lt;int&gt; submatches,
regex_constants::match_flag_type m =
regex_constants::match_default); In 28.12.2.1 add the
declaration: regex_token_iterator(BidirectionalIterator a,
BidirectionalIterator b, const regex_type&amp; re,
initializer_list&lt;int&gt; submatches,
regex_constants::match_flag_type m =
regex_constants::match_default); And to the end of para 3
add: The forth constructor initializes the member subs to
hold a copy of the sequence of integer values in the range
[submatches.begin(), submatches.end()).

<td>We agree. Alisdair will open an issue.<p>In 
c++std-lib-23130, <span class="gI">
<span email="daniel.kruegler@googlemail.com" class="gD">Daniel Krgler 
pointed out that this comment is already covered by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#909">
issue 909</a>.</span></span><br>

    

<tr valign="top">
<td>US87

<td>29

<td>

<td>ge

<td>The
atomics chapter is not concept enabled. The adopted paper,
N2427, did have those concepts.

<td>

<td>Create an issue for concepts in the atomics chapter. See 
N2427. Needs to also consider issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#923">923</a> and 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#924">924</a>.<br>

    

<tr valign="top">
<td>UK311

<td>29

<td>

<td>Te

<td>Atomic types
cannot be used generically in a constrained template

<td>Provide constraints for the atomics
library, clause 29

<td>Duplicate of US 87.<br>

    

<tr valign="top">
<td>UK312

<td>29

<td>

<td>Te

<td>The contents of the &lt;stdatomic.h&gt;
header are not listed anywhere, and &lt;cstdatomic&gt; is
listed as a C99 header in chapter 17. If we intend to use
these for compatibility with a future C standard, we should
not use them now.

<td>Remove &lt;cstdatomic&gt; from the C99
headers in table 14. Add a new header &lt;atomic&gt; to the
headers in table 13. Update chapter 29 to remove reference
to &lt;stdatomic.h&gt; and replace the use of
&lt;cstdatomic&gt; with &lt;atomic&gt;. If and when WG14
adds atomic operations to C we can add corresponding
headers to table 14 with a TR.

<td>Create an issue. Assigned to Lawrence Crowl. May be 
resolvable with a footnote for clarity stating that the header is 
defined where it exists.<br>

    

<tr valign="top">
<td>JP75

<td>29

<td>

<td>ed

<td>A
definition of enum or struct is the style of C using
typedef.

<td>
Change to a style of C++.

<p>
Correct as follows.

<p>
<br>

<p>
29.1

<p>
&nbsp;

<p>
namespace std {

<p>
<u>typedef</u> enum memory_order {

<p>
memory_order_relaxed, memory_order_consume,
memory_order_acquire,

<p>
memory_order_release, memory_order_acq_rel,
memory_order_seq_cst

<p>}
memory_order;

<p>}

<p>
<br>

<p>
should be

<p>
<br>

<p>
namespace std {

<p>
enum memory_order {

<p>
memory_order_relaxed, memory_order_consume,
memory_order_acquire,

<p>
memory_order_release, memory_order_acq_rel,
memory_order_seq_cst

<p>};

<p>}

<p>
<br>

<p>
29.3.1

<p>
<br>

<p>
namespace std {

<p>
<u>typedef</u> struct atomic_bool {

<p>...

<p>}
atomic_bool;

<p>}

<p>
<br>

<p>
should be

<p>
<br>

<p>
namespace std {

<p>
struct atomic_bool {

<p>...

<p>};

<p>}

<p>
<br>

<p>
namespace std {

<p>
<u>typedef</u> struct atomic_<i>itype</i> {

<p>...

<p>}
atomic_<i>itype</i>;

<p>}

<p>
<br>

<p>
should be

<p>
<br>

<p>
namespace std {

<p>
struct atomic_<i>itype</i> {

<p>...

<p>};

<p>}

<p>
<br>

<p>
29.3.2

<p>
<br>

<p>
namespace std {

<p>
<u>typedef</u> struct atomic_address {

<p>...

<p>}
atomic_address;

<p>}

<p>
<br>

<p>
should be

<p>
<br>

<p>
namespace std {

<p>
struct atomic_address {

<p>...

<p>};

<p>}

<p>
<br>

<p>
29.5

<p>
<br>

<p>
namespace std {

<p>
<u>typedef</u> struct atomic_flag {

<p>...

<p>}
atomic_flag;

<p>}

<p>
<br>

<p>
should be

<p>
<br>

<p>
namespace std {

<p>
struct atomic_flag {

<p>...

<p>};

<p>}

<td>Recommend to reject the comment: We believe the current 
syntax is most appropriate for an interface that is intended to be 
highly compatible with C.<br>

    

<tr valign="top">
<td>UK313

<td>29.1

<td>

<td>Te

<td>seq_cst fences don't necessarily guarantee
ordering
http://home.twcny.rr.com/hinnant/cpp_extensions/issues_preview/lwg-active.html#926

<td>Add a new
paragraph after 29.1 [atomics.order]p5 that says For atomic
operations A and B on an atomic object M, where A and B
modify M, if there are memory_order_seq_cst fences X and Y
such that A is sequenced before X, Y is sequenced before B,
and X precedes Y in S, then B occurs later than A in the
modifiction order of M.

<td>Hans to make proposal. See LWG
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#926">Issue 926</a>.<p>
UK 313 Update and LWG
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#926">
926</a>: Accept proposed resolution, correcting 
spelling. Move to review state. Hans to ask additional review from cpp-threads.<br>

    

<tr valign="top">
<td>US88

<td>29.2

<td>

<td>te

<td>The "lockfree" facilities do
not tell the programmer enough.

<td>
Expand the "lockfree" facilities. See the attached paper
"Issues with the C++ Standard" under Chapter 29,
"atomics.lockfree doesn't tell the programmer enough"

<td>Create an issue, will require more discussion. Assigned 
to Lawrence. Description of issue should be based on what is in the 
additional notes for US 88.<p>See wiki for further 
comments.<br>

    

<tr valign="top">
<td>US89

<td>29.3.1

<td>Table 122

<td>te

<td>The
types in the table "Atomics for standard typedef types"
should be typedefs, not classes. These semantics are
necessary for compatibility with C.

<td>Change the classes to
typedefs.

<td>LWG
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#927">Issue 937</a>. Direct the editor to turn the types into typedefs as proposed in the comment. Paper approved by committee used 
typedefs, this appears to have been introduced as an editorial change. 
Rationale: for compatibility with C.

<tr valign="top">
<td>US90

<td>29.4

<td>

<td>te

<td>Are atomic functions allowed
to have non-volatile overloads?

<td>
Allow non-volatile overloads. See the attached paper
"Issues with the C++ Standard, under Chapter 29, "Are
atomic functions allowed to have non-volatile overloads?"

<td>Create an issue. Assigned to Lawrence Crowl. Should 
explicitly consider the process shared issue.<br>

    

<tr valign="top">
<td>US91

<td>29.4

<td>

<td>te

<td>Whether or not a failed
compare_exchange is a RMW operation (as used in 1.10
[intro.multithread]) is unclear.

<td>
Make failing compare_exchange operations <font size="2"
style="font-size: 11pt"><strong>not</strong> be RMW. See
the attached paper under "atomic RMW status of failed
compare_exchange"</font>

<td>Create an issue, goes to review. Attention: Howard. 
Group agrees with the resolution as proposed by Anthony Williams in the 
attached note.<br>

    

<tr valign="top">
<td>US92

<td>29.4

<td>

<td>te

<td>The effect of
memory_order_consume with atomic RMW operations is unclear.

<td>
Follow the lead of fences [atomics.fences], and promote
memory_order_consume to memory_order_acquire with RMW
operations.

<td>Create an issue. Assigned to Lawrence. Resolution 
requires proposed wording.<p>Later: Mark as Not A Defect. 
We can not see the issue being suggested by the comment.<br>

    

<tr valign="top">
<td>JP76

<td>30

<td>

<td>ed

<td>A
description for "<i>Throws:</i> Nothing." are not unified.

<p>At
the part without throw, "<i>Throws:</i> Nothing." should be
described.

<td>Add
"<i>Throws:</i> Nothing." to the following.

<p>
30.2.1.6 , 1<sup>st</sup> <font size="2" style=
"font-size: 11pt">paragraph</font>

<p>
30.3.3.1 , 4<sup>th</sup> <font size="2" style=
"font-size: 11pt">paragraph</font>

<p>
30.3.3.2.1 , 6<sup>th</sup> <font size="2" style=
"font-size: 11pt">paragraph</font>

<p>
30.4.1 , 7<sup>th</sup> <font size="2" style=
"font-size: 11pt">and 8<sup>th</sup> paragraph</font>

<p>30.4.2 ,
6<sup>th</sup><font size="2" style="font-size: 11pt">,
7<sup>th</sup>,19<sup>th</sup>,21th and 25<sup>th</sup>
paragraph</font>

<p>
<br>

<td>Pass on to editor.<br>

    

<tr valign="top">
<td><a name="US93">US 93</a>

<td>30

<td>

<td>ge

<td>The
thread chapter is not concept enabled.

<td>

<td>Create an issue. Need to find volunteers to work on 
this.<br>

    

<tr valign="top">
<td><p align="justify" style=
"margin-right: -0.18in; margin-bottom: 0in">UK320<p>

<td>30

<td>

<td>Te

<td>Threads library cannot be used in
constrained templates

<td>Provide constraints for the threads
library, clause 30

<td>Duplicate of <a href="#US93">US 93</a>.<br>

    

<tr valign="top">
<td>UK321

<td>30

<td>

<td>Ed

<td>Throughout this
clause, the term Requires: is used to introduce compile
time requirements, which we expect to be replaced with
concepts and requires in code. Run-time preconditions are
introduced with the term "Preconditions:" which is not a
defined part of the library documentation structure
(17.5.2.4). However, this is exactly the direction that BSI
would like to see the organisation move, replacing
Requires: clauses with Preconditions: clasues throught the
library. See comment against clause 17 for more details.

<td>Decument Preconditions: paragraphs in
17.5.2.4, and use consistently through rest of the library.

<td>Pass on to editor.<br>

    

<tr valign="top">
<td>US94

<td>30.1.2

<td>1

<td>te

<td>The first sentence of para 1 suggests that no other
library function is permitted to call operating system or
low level APIs.

<td>Rewrite para 1
as: &#8220; <font color="#000000">Some functions described
in this Clause are specified to throw exceptions of type
system_error (</font><font color="#0000FF">19.4.5</font>
<font color="#000000">). Such exceptions shall be thrown if
a call to an operating system or underlying API results in
an error that prevents the library function from satisfying
its postconditions or from returning a meaningful
value.&#8221;</font>

<p>

<td>Reclassify as editorial. Pass on to editor, wording roughly as proposed.

<tr valign="top">
<td>US95

<td>30.1.3

<td>1

<td>te

<td>&#8220;native_handle_type&#8221; is a typedef, not a
class member.

<td>Several classes
described in this Clause have a member native_handle (of
type native_handle_type) . The

<p>
presence of this member and its semantics is implementation
defined. [ Note: This member allows implementations to
provide access to implementation details. The name of the
member and the type are specified to facilitate portable
compile-time detection. Actual use of this member or the
corresponding type is inherently non-portable. &#8212;end
note ]

<td>Not a defect. native_handle_type is a typedef, but it is also a member of 
    the classes in question.

<tr valign="top">
<td>US96

<td>30.1.4

<td>2

<td>te

<td>There is no definition here for monotonic clock.

<td>Implementations
should use a <i>monotonic clock</i> to measure time for
these functions. A monotonic clock measures real time, but
cannot be set, and is guaranteed to have no negative clock
jumps.

<td>There is a good definition. NAD. There are other problems here (see issue 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#859">859</a>). Create an issue, together with UK 322. Detlef will write the issue, 
    but not proposed wording. Refer also to sections [time.clock.req] and [time.clock.monotonic].

<tr valign="top">
<td>UK322

<td>30.1.4

<td>2

<td>Te

<td>Not all systms
can provide a monotonic clock. How are they expected to
treat a _for function?

<td>Add at least a note explaining the intent
for systems that do not support a monotonic clock.

<td>Create an issue, together with UK 96. Note that the specification as is 
    already allows a non-monotonic clock due to the word &quot;should&quot; rather than 
    &quot;shall&quot;. If this wording is kept, a footnote should be added to make the 
    meaning clear.

<tr valign="top">
<td>UK323

<td>30.2.1

<td>1

<td>Te

<td>The presence of
a non-explicit variadic template constructor alongside an
explicit single-argument constructor can lead to behaviour
that is not intended: the variadic constructor will be
selected for implicit conversions, defeating the purpose of
the explicit single-argument constructor. Additionally the
single-argument constructor is redundant; the variadic
constructor can provide identical functionality with one
*fewer* copies if the supplied func is an lvalue.

<td>Mark constructor template &lt;class F,
class ...Args&gt; thread(F&amp;&amp; f, Args&amp;&amp;...
args); as explicit and remove the single-argument
constructor.

<td>Create an issue, goes to review. Attention: Howard. Group agrees with the 
    proposed resolution.

<tr valign="top">
<td>UK324

<td>30.2.1.1

<td>

<td>Te

<td>thread::id
objects should be as useable in hashing containers as they
are in ordered associative containers.

<td>Add thread::id
support for std::hash

<p><br>

<p><br>

<td>Not a defect. See [unord.hash], where std::thread:id is already listed as a 
    required specialization for std::hash().

<tr valign="top">
<td>JP77

<td>30.2.1.2

<td>

<td>te

<td>
"CopyConstructible" and "MoveConstructible" in
"<i>Requires:</i> F and each Ti in Args shall be
CopyConstructible if an lvalue and otherwise
MoveConstructible." are reflected by interface.

<p>
<br>

<td>Add
a concept for constructor of thread.

<td>Subset of <a href="#US93">US 93</a>. Should be addressed under the issue corresponding to US 93.

<tr valign="top">
<td>JP78

<td>30.2.1.2

<td>
4<sup>th</sup> <font size="2" style=
"font-size: 11pt">para, 1<sup>st</sup> line</font>

<td>ed

<td>In
"F and each Ti in Args", 'Ti' is not clear.

<td>
Replace "Ti" with "args"

<td>Pass on to editor.

<tr valign="top">
<td>US97

<td>30.2.1.3

<td>1

<td>te

<td>detach-on-destruction may result in
&#8220;escaped&#8221; threads accessing objects with
bounded lifetime after the end of their lifetime.

<td>See document WG21 N2802=08-0312 written by Hans Boehm.

<td>Create an issue. To be discussed in full library group.<p>

    Later: straw poll 10-0, put N2802 Alternative 2 on formal motions page.

<tr valign="top">
<td>US98

<td>30.2.1.3,<br>
30.2.1.4

<td>

<td>

<td>The current defined behavior
for the std::thread destructor is to detach the thread.
Unfortunately, this behavior exposes programmers to tricky,
hard-to-diagnose, undefined behavior.

<td>
Change destruction behavior to undefined behavior, with a
note strongly encouraging termination. See the attached
paper "Issues with the C++ Standard" under Chapter 30,
"Implicit thread detach is harmful".

<td>Duplicate of US 97.

<tr valign="top">
<td>UK325

<td>30.3.3

<td>2

<td>Te

<td>We believe constexpr literal values should
be a more natural expression of empty tag types than extern
objects as it should improve the compilers ability to
optimize the empty object away completely.

<td>Replace the
extern declarations: extern const defer_lock_t defer_lock;
extern const try_to_lock_t try_to_lock; extern const
adopt_lock_t adopt_lock; with constexpr values constexpr
defer_lock_t defer_lock{}; constexpr try_to_lock_t
try_to_lock{}; constexpr adopt_lock_t adopt_lock{};

<td>Create an issue. Move to review, attention: Howard. The current 
    specification is a &quot;hack&quot;, and the proposed specification is a better 
    &quot;hack&quot;.

<tr valign="top">
<td>UK326

<td>30.3.3.2.1

<td>7

<td>Te

<td>The precondition
that the mutex is not owned by this thread offers
introduces the risk of un-necessary undefined behaviour
into the program. The only time it matters whether the
current thread owns the mutex is in the lock operation, and
that will happen subsequent to construction in this case.
The lock operation has the identical pre-condition, so
there is nothing gained by asserting that precondition
earlier and denying the program the right to get into a
valid state before calling lock.

<td>Strike 30.3.3.2.1p7

<td>Create an issue. Move to review, attention: Howard. Proposed resolution is 
    fine.

<tr valign="top">
<td>UK327

<td>30.3.3.2.2

<td>4, 9, 14, 19

<td>Te

<td>Not clear what
the specification for error condition
resource_deadlock_would_occur means. It is perfectly
possible for this thread to own the mutex without setting
owns to true on this specific lock object. It is also
possible for lock operations to succeed even if the thread
does own the mutex, if the mutex is recursive. Likewise, if
the mutex is not recursive and the mutex has been locked
externally, it is not always possible to know that this
error condition should be raised, depending on the host
operating system facilities. It is possible that 'i.e.' was
supposed to be 'e.g.' and that suggests that recursive
locks are not allowed. That makes sense, as the
exposition-only member owns is boolean and not a integer to
count recursive locks.

<td>Add a precondition !owns. Change the 'i.e.'
in the error condition to be 'e.g.' to allow for this
condition to propogate deadlock detection by the host OS.

<td>Create an issue. Assigned to Lawrence Crowl. Note: not sure what try_lock 
    means for recursive locks when you are the owner. POSIX has language on 
    this, which should ideally be followed. Proposed fix is not quite right, for 
    example, try_lock should have different wording from lock.

<tr valign="top">
<td>UK328

<td>30.3.3.2.2

<td>20

<td>Te

<td>There is a missing precondition that owns
is true, or an if(owns) test is missing from the effect
clause

<td>Add a
precondition that owns == true. Add an error condition to
detect a violation, rather than yield undefined behaviour.

<td>Handle in same issue as UK 327. Also uncertain that the proposed resolution 
    is the correct one.

<tr valign="top">
<td>UK329

<td>30.5

<td>

<td>Te

<td>future, promise and packaged_task provide a
framework for creating future values, but a simple function
to tie all three components together is missing. Note that
we only need a *simple* facility for C++0x. Advanced thread
pools are to be left for TR2.

<td>Provide a simple
function along the lines of: template&lt; typename F,
typename ... Args &gt; requires Callable&lt; F, Args...
&gt; future&lt; Callable::result_type &gt; async(
F&amp;&amp; f, Args &amp;&amp; ... ); Semantics are similar
to creating a thread object with a packaged_task invoking f
with forward&lt;Args&gt;(args...) but details are left
unspecified to allow different scheduling and thread
spawning implementations. It is unspecified whether a task
submitted to async is run on its own thread or a thread
previously used for another async task. If a call to async
succeeds, it shall be safe to wait for it from any thread.
The state of thread_local variables shall be preserved
during async calls. No two incomplete async tasks shall see
the same value of this_thread::get_id(). [Note: this
effectively forces new tasks to be run on a new thread, or
a fixed-size pool with no queue. If the library is unable
to spawn a new thread or there are no free worker threads
then the async call should fail.]

<td>The concurrency subgroup has revisited this issue and decided that it could 
    be considered a defect according to the Kona compromise. A task group was 
    formed lead by Lawrence Crowl &lt;crowl@google.com&gt; and Bjarne Stroustrup &lt;bs@cs.tamu.edu&gt; 
    to write a paper for Frankfort proposing a simple asynchronous launch 
    facility returning a future. It was agreed that the callable <strong>must</strong> 
    be run on a separate thread from the caller, but not necessarily a brand-new 
    thread. The proposal might or might not allow for an implementation that 
    uses fixed-size or unlimited thread pools.<p>

    Bjarne in c++std-lib-23121: I think that what we agreed was that to avoid 
    deadlock async() would almost certainly be specified to &nbsp;launch in a 
    different thread from the thread that executed async(), but I don't think it 
    was a specific design constraint.

<tr valign="top">
<td>UK330

<td>30.5.1

<td>

<td>Ed

<td>30.5.1 (and then 30.5.7) refer to a
specialisation of
constructible_with_allocator_prefix&lt;&gt; However this
trait is not in the CD, so references to it should be
removed.

<td>Remove the
reference to constructible_with_allocator_prefix in 30.5.1
Remove paragraph 30.5.7

<td>Related to <a href="#JP79">JP 79</a> and therefore subset of <a href="#US93">US 93</a>. Should be addressed under 
    the issue corresponding to US 93.

<tr valign="top">
<td><a name="JP79">JP79 </a>

<td>30.5.1

<td>

<td>te

<td>The
concept of UsesAllocator and Allocator should be used.

<td>
Correct as follows.

<p>
&nbsp;

<p>
template &lt;class R, class Alloc&gt;

<p>
struct uses_allocator&lt;promise&lt;R&gt;, Alloc&gt;;

<p>
template &lt;class R&gt;

<p>
struct
constructible_with_allocator_prefix&lt;promise&lt;R&gt;
&gt;;

<p>
&nbsp;

<p>
should be

<p>
&nbsp;

<p>
template&lt;class R, Allocator Alloc&gt;

<p>concept_map
UsesAllocator&lt;promise&lt;R&gt;, Alloc&gt;;

<p>
<br>

<td>Subset of <a href="#US93">US 93</a>. Should be addressed under the issue corresponding to US 93.

<tr valign="top">
<td>UK331

<td>30.5.3

<td>

<td>Te

<td>Not clear what
it means for a public constructor to be 'exposition only'.
If the intent is purely to support the library calling this
constructor then it can be made private and accessed
through friendship. Otherwise it should be documented for
public consumption.

<td>Declare the constructor as private with a
note about intended friendship, or remove the
exposition-only comment and document the semantics.

<td>Create an issue. Assigned to Detlef. Suggested resolution probably makes 
    sense.

<tr valign="top">
<td>UK332

<td>30.5.4

<td>

<td>Ed

<td>It is not clear
without reference to the original proposal how to use a
future. In particular, the only way for the user to
construct a future is via the promise API which is
documented after the presentation of future. Most library
clauses feature a small description of their components and
intended use, it would be most useful in this case.

<td>Provide a small introductory paragraph,
docuenting intended purpose of the future class template
and the way futures can only be created via the promise
API.

<td>Pass on to editor. Detlef has volunteered to provide some wording.

<tr valign="top">
<td>UK333

<td>30.5.4

<td>5

<td>Ge

<td>We expect the complicated 3-signature
specifcation for future::get() to be simplified to a single
signature with a requires clause by the application of
concepts.

<td>Requires fully baked concepts for clause 30

<td>Subset of <a href="#US93">US 93</a>. Should be addressed under the issue corresponding to US 93.

<tr valign="top">
<td>UK334

<td>30.5.4

<td>5

<td>Te

<td>Behaviour of
get() is undefined if calling get() while not is_ready().
The intent is that get() is a blocking call, and will wait
for the future to become ready.

<td>Effects: If is_ready() would return false,
block on the asynchronous result associated with *this.

<td>Create an issue. Move to review, attention: Howard. Proposed resolution is 
    fine.

<tr valign="top">
<td>UK335

<td>30.5.4

<td>

<td>Te

<td>
std::unique_future is MoveConstructible, so you can
transfer the association with an asynchronous result from
one instance to another. However, there is no way to
determine whether or not an instance has been moved from,
and therefore whether or not it is safe to wait for it.
std::promise&lt;int&gt; p; std::unique_future&lt;int&gt;
uf(p.get_future()); std::unique_future&lt;int&gt;
uf2(std::move(uf)); uf.wait(); // oops, uf has no result to
wait for.

<td>Add a "waitable()" function to
unique_future (and shared_future) akin to
std::thread::joinable(), which returns true if there is an
associated result to wait for (whether or not it is ready).
Then we can say: if(uf.waitable()) uf.wait();

<td>Create an issue. Requires input from Howard. Probably NAD.

<tr valign="top">
<td>UK336

<td>30.5.4

<td>

<td>Te

<td>It is possible
to transfer ownership of the asynchronous result from one
unique_future instance to another via the move-constructor.
However, it is not possible to transfer it back, and nor is
it possible to create a default-constructed unique_future
instance to use as a later move target. This unduly limits
the use of unique_future in code. Also, the lack of a
move-assignment operator restricts the use of unique_future
in containers such as std::vector - vector::insert requires
move-assignable for example.

<td>Add a default constructor with the
semantics that it creates a unique_future with no
associated asynchronous result. Add a move-assignment
operator which transfers ownership.

<td>Create an issue. Detlef will look into it.

<tr valign="top">
<td>JP80

<td>30.5.4 ,<br>
30.5.5

<td>

<td>ed

<td>
Typo, duplicated "&gt;"

<p>"class
Period&gt;&gt;"

<p>
<br>

<td>
Remove one

<td>Pass on to editor.

<tr valign="top">
<td>UK337

<td>30.5.5

<td>

<td>Te

<td>shared_future
should support an efficient move constructor that can avoid
unnecessary manipulation of a reference count, much like
shared_ptr

<td>Add a move constructor

<td>Create an issue. Detlef will look into it.

<tr valign="top">
<td>UK338

<td>30.5.5

<td>

<td>Te

<td>shared_future is currently
CopyConstructible, but not CopyAssignable. This is
inconsistent with shared_ptr, and will surprise users.
Users will then write work-arounds to provide this
behaviour. We should provide it simply and efficiently as
part of shared_future. Note that since the shared_future
member functions for accessing the state are all declared
const, the original usage of an immutable shared_future
value that can be freely copied by multiple threads can be
retained by declaring such an instance as "const
shared_future".

<td>Remove "=delete"
from the copy-assignment operator of shared_future. Add a
move-constructor shared_future(shared_future&amp;&amp;
rhs), and a move-assignment operator shared_future&amp;
operator=(shared_future&amp;&amp; rhs). The postcondition
for the copy-assignment operator is that *this has the same
associated state as rhs. The postcondition for the
move-constructor and move assignment is that *this has the
same associated as rhs had before the
constructor/assignment call and that rhs has no associated
state.

<td>Create an issue. Detlef will look into it.

<tr valign="top">
<td>UK339

<td>30.5.6

<td>6, 7

<td>Te

<td>Move assignment is goiing in the wrong
direction, assigning from *this to the passed rvalue, and
then returning a reference to an unusable *this

<td>Strike 6. 7
Postcondition: associated state of *this is the same as the
associated state of rhs before the call. rhs has no
associated state.

<td>Create an issue. Move to review, attention: Howard. Proposed resolution is 
    fine.

<tr valign="top">
<td>UK340

<td>30.5.6

<td>11, 12, 13

<td>Te

<td>There is an
implied postcondition that the state of the promise is
transferred into the future leaving the promise with no
associated state. It should be spelled out.

<td>Postcondition: *this has no associated
state.

<td>Create an issue. Move to review, attention: Howard. Proposed resolution is 
    fine.

<tr valign="top">
<td>UK341

<td>30.5.6

<td>

<td>Te

<td>promise::swap accepts its parameter by
lvalue reference. This is inconsistent with other types
that provide a swap member function, where those swap
functions accept an rvalue reference

<td>Change promise::swap to take an rvalue
reference.

<td>Create an issue. Detlef will look into it. Probably ready as it.

<tr valign="top">
<td>UK342

<td>30.5.6

<td>

<td>Te

<td>std::promise is
missing a non-member overload of swap. This is inconsistent
with other types that provide a swap member function

<td>Add a non-member overload void
swap(promise&amp;&amp; x,promise&amp;&amp; y){ x.swap(y); }

<td>Create an issue. Move to review, attention: Howard. Detlef will also look 
    into it.

<tr valign="top">
<td>UK343

<td>30.5.6

<td>3

<td>Te

<td>The move constructor of a std::promise
object does not need to allocate any memory, so the
move-construct-with-allocator overload of the constructor
is superfluous.

<td>Remove the
constructor with the signature template &lt;class
Allocator&gt; promise(allocator_arg_t, const Allocator&amp;
a, promise&amp; rhs);

<td>Create an issue. Detlef will look into it. Will solicit feedback from Pablo. 
    Note that &quot;rhs&quot; argument should also be an rvalue reference in any case.

<tr valign="top">
<td>JP81

<td>30.5.8

<td>

<td>ed

<td>
There are not requirements for F and a concept of Allocator
dose not use.

<td>
Correct as follows.

<p>
<br>

<p>
template &lt;class F&gt;

<p>
explicit packaged_task(F f);

<p>
template &lt;class F, class Allocator&gt;

<p>
explicit packaged_task(allocator_arg_t, const
Allocator&amp; a, F f);

<p>
template &lt;class F&gt;

<p>
explicit packaged_task(F&amp;&amp; f);

<p>
template &lt;class F, class Allocator&gt;

<p>
explicit packaged_task(allocator_arg_t, const
Allocator&amp; a, F&amp;&amp; f);

<p>
&nbsp;

<p>
should be

<p>
&nbsp;

<p>
template &lt;class F&gt;

<p>
<u>requires CopyConstructible&lt;F&gt; &amp;&amp;
Callable&lt;F, ArgTypes...&gt;</u>

<p>
&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;

<p>
explicit packaged_task(F f);

<p>
&nbsp;

<p>
template &lt;class F, <u>Allocator Alloc</u>&gt;

<p>
<u>requires CopyConstructible&lt;F&gt; &amp;&amp;
Callable&lt;F, ArgTypes...&gt;</u>

<p>
&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;

<p>
explicit packaged_task(allocator_arg_t, const
<u>Alloc</u>&amp; a, F f);

<p>
&nbsp;

<p>
template &lt;class F&gt;

<p>
<u>requires CopyConstructible&lt;F&gt; &amp;&amp;
Callable&lt;F, ArgTypes...&gt;</u>

<p>
&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;

<p>
explicit packaged_task(F&amp;&amp; f);

<p>
&nbsp;

<p>
template &lt;class F, <u>Allocator Alloc</u>&gt;

<p>
<u>requires CopyConstructible&lt;F&gt; &amp;&amp;
Callable&lt;F, ArgTypes...&gt;</u>

<p>
&amp;&amp; Convertible&lt;Callable&lt;F,
ArgTypes...&gt;::result_type, R&gt;

<p>explicit
packaged_task(allocator_arg_t, const <u>Alloc</u>&amp; a,
F&amp;&amp; f);

<td>Subset of <a href="#US93">US 93</a>. Should be addressed under the issue corresponding to US 93. 
    We do not consider this to be an editorial change.

<tr valign="top">
<td>DE23

<td>Annex B

<td>p2

<td>te

<td>DE23 Recursive
use of constexpr functions appears to be permitted. Since
such functions may be required to be evaluated at
compile-time, Annex B "implementation quantities" should
specify a maximum depth of recursion.

<td>In Annex B, specify a recursion depth of 256 or a larger
value.

<td>Create issue, share with DE 25. See 
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2826.html">N2826</a>. Attention: core group.

<tr valign="top">
<td>DE24

<td>Annex B

<td>p2

<td>te

<td>DE24 The
number of placeholders for "bind" is implementation-defined
in 20.7.12.1.4, but no minimum is suggested in Annex B.<br>

<td>Add a miminum of 10 placeholders to Annex B.

<td>Create issue, proposed resolution as in comment. Attention: LWG subgroup 2. 
    Note the section in N2800 is actually 20.6.12.1.4 [func.bind.place].

<tr valign="top">
<td>DE25

<td>Annex B

<td>p2

<td>te

<td>DE25
Specifying a minimum of 17 recursively nested template
instantiations is too small for practical purposes. The
limit is too high to effectively limit compiler resource
usage, see
http://ubiety.uwaterloo.ca/~tveldhui/papers/2003/turing.pdf
. The conclusion is that the metric "number of recursively
nested template instantiations" is inapposite.

<td>Remove the bullet "Recursively nested template
instantiations [17]".

<td>Create issue, share with DE 23. Attention: core group.

<tr valign="top">
<td>FR38

<td>C.2<br>
[diffs.<br>
library]

<td>1

<td>ed

<td>What is ISO/IEC 1990:9899/DAM
1? My guess is that's a typo for ISO/IEC

<p>9899/Amd.1:1995 which I'd
have expected to be referenced here (the tables

<p>make reference to things
which were introduced by Amd.1).

<td>One need probably a reference
to the document which introduce char16_t and

<p>char32_t in C (ISO/IEC TR 19769:2004?).

<td>Create issue. Document in question should be C99, not C90+ammendment1. The 
    rest of the section requires careful review for completeness. Example &lt;cstdint&gt; 
    18.3.1 [csdtint.sym]. Assign to C liasons.

<tr valign="top">
<td>UK344

<td>Appendix D

<td>

<td>Ge

<td>It is desirable to allow some mechanism to
support phasing out of deprecated features in the future.
Allowing compilers to implement a mode where deprecated
features are not available is a good first step.

<td>Add to the definition of deprecated
features permission for compilers to maintain a
conditionally supported mode where deprecated features can
be disabled, so long as they also default to a mode where
all deprecated features are supported.

<td>Deals with deprecation, needs to be discussed in general group. Attention: 
    Bill Plauger<p>

    Update 2009-03-04: Mark as NAD. Compiler switches are outside the domain of 
    the standard.

<tr valign="top">
<td>FR39

<td>Index

<td>

<td>ed

<td>Some definitions seem not
indexed (such as /trivially copyable/ or

<p>/sequenced before/), indexing
them would be useful (and marking specially the page -- say
bold or italic -- which reference to the definition would
increase the usefulness; having a separate index of all
definitions is something which could also be considered).

<td>

<td>  Pass to the editor.
</table><hr>