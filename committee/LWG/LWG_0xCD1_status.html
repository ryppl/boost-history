<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<meta name="generator" content=
"Microsoft FrontPage 5.0">
  <meta name="generator" content="Microsoft FrontPage 5.0">
  <meta name="generator" content="Microsoft FrontPage 5.0">
  <meta http-equiv="CONTENT-TYPE" content=
  "text/html; charset=us-ascii">

  <title>LWG CD1 Status of Comments</title>
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
  <meta name="AUTHOR" content="dow">
  <meta name="CREATED" content="20090221;19590000">
  <meta name="CHANGEDBY" content=" Barry E Hedquist">
  <meta name="CHANGED" content="20090222;18460000">
  <meta name="DESCRIPTION" content="FORM (ISO)">
<style type="text/css">
  body    { font-family: sans-serif; margin: 1em; }
</style>

<h1>Library Working Group<br>
Status of CD1 National Body Comments</h1>
<p>Revised:
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %b %Y %I:%M:%S %p %Z" startspan -->04 Mar 2009 01:40:40 PM -0500<!--webbot bot="Timestamp" endspan i-checksum="42233" --></p>

<table border="1" bordercolor="#000000" cellpadding="7"
  cellspacing="0" style="border-collapse: collapse">
    
    <tr valign="top">
      <td>
        <p><b>MB<br></b><br>

      <td>
        <p><b>Clause No./<br>
        Subclause No./<br>
        Annex<br></b>(e.g. 3.1)

      <td>
        <p><b>Para/<br>
        Figure/<br>Table/<br>Note</b><td>
        <p><b>Type </b>

      <td>
        <p><b>Comment (justification for change) by the MB</b>

      <td>
        <p><b>Proposed change by the MB</b>

      <td>
        <p align="center" style=
        "margin-top: 0.07in; margin-bottom: 0.04in; page-break-inside: avoid">
        <b>Disposition</b>

        <p>

    <tr valign="top">
      <td>
        <p align="left">US 2

      <td>
        <p align="left">17-30

      <td>
        <p align="left"><br>

      <td>
        <p align="left">ge/te

      <td>
        <p align="left">The
        active issues identified in WG21 N2806, C++ Standard
        Library Active Issues, must be addressed and appropriate
        action taken.

        <p align="left">
        <br>

        <p align="left">
        <font color="#000080"><u><a href=
        "http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">
        http://www.open-std.org/</a><br>
        <a href=
        "http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">
        jtc1/sc22/wg21/docs/lwg-active.html</a></u></font>

        <p align="left"><br>

      <td>
        <p align="left">Appropriate action would
        include making changes to the CD, identifying an issue as
        not requiring a change to the CD, or deferring the issue to
        a later point in time.

      <td>
        <p>

    Acknowledged<tr valign="top">
      <td>
        <p>FR 2

      <td>
        <p>General<br>
        Comment

      <td>
        <p>Library

      <td>
        <p>ge

      <td>
        <p>The adoption of the library `constexpr' proposal was not
        reflected in the draft, despite formal WG21 committee vote.

      <td>
        <p>FR 2

      <td>
        <p>Editorial; sent to Pete Becker<tr valign="top">
      <td>
        <p align="left">US 61

      <td>
        <p align="left">17 onward

      <td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p>The concepts core language feature is applied to only
        some of the Standard Library clauses, and even then not
        always consistently.

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Review all
        clauses of the Standard Library, and consistently apply
        concept technology wherever possible and appropriate. The
        proposed wording in WG21 N2781 exemplifies the necessary
        level of detail.

        <p>

      <td>
        <p>

    Agreed. Duplicates CA2<tr valign="top">
      <td>
        <p>CA-2

      <td>
        <p style="margin-top: 0.04in">17 Library

      <td>
        <p>

      <td>
        <p>Ge

      <td>
        <p align="left" style="margin-top: 0.04in">
        &#8220;Concepts&#8221; are a significant new addition to
        the language, but are not exploited uniformly in the
        library as documented in CD 14882.

      <td>
        <p align="left" style="margin-top: 0.04in">Fix
        the standard library so that &#8220;Concepts&#8221; are
        used appropriately in the library.

      <td>
        <p>

    Agreed; We intend to address this.<tr valign="top">
      <td>
        <p align="left">US 62

      <td>
        <p align="left">17-30

      <td>
        <p align="left"><br>

      <td>
        <p align="left">ge

      <td>
        <p align="left">Provide concepts
        and requirements clauses for all standard library templates

        <p align="left"><br>

      <td>
        <p align="left"><br>

      <td>
        <p align="left">Agreed. Duplicates CA2<br>

    <tr valign="top">
      <td>
        <p>US 63

      <td>
        <p style="margin-top: 0.04in; margin-bottom: 0.04in">17-30

        <p>

      <td>
        <p>

      <td>
        <p>te

      <td>
        <p>The behavior of the library in the presence of threads
        is incompletely specified.

        <p>For example, if thread 1 assigns to X, then writes data
        to file f, which is read by thread 2, and then accesses
        variable X, is thread 2 guaranteed to be able to see the
        value assigned to X by thread 1? In other words, does the
        write of the data "happen before" the read?

        <p>Another example: does simultaneous access using operator
        at() to different characters in the same non-const string
        really introduce a data race?

      <td>
        <p>

      <td>
        <p>

    17 SG: should go to threads group; misclassified in document<p>

    Concurrency SG: Create an issue. Hans will look into it.<tr valign="top">
      <td>
        <p>DE-2

      <td>
        <p>17 through 30

      <td>
        <p>

      <td>
        <p>te

      <td>
        <p>DE-2 Marking a constructor with "explicit" has semantics
        even for a constructor with zero or several parameters:
        Such a constructor cannot be used with list-initialization
        in a copy-initialization context, see 13.3.1.7. The
        standard library apparently has not been reviewed for
        marking non-single-parameter constructors as "explicit".

      <td>
        <p>Consider marking zero-parameter and multi-parameter
        constructors "explicit" in classes that have at least one
        constructor marked "explicit" and that do not have an
        initializer-list constructor.

      <td>
        <p>

    Robert Klarer to address this one<tr valign="top">
      <td>
        <p>JP 21

      <td>
        <p align="left">
        <br>

        <p align="left">17
        Library

        <p align="left">
        21.2, 21.4,

        <p align="left">27.2, 27.6,<br>
&nbsp;27.7,<br>
&nbsp;27.8.1,<br>
&nbsp;28.4

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left">
        Support of char16_t/char32_t is insufficient. The basic_xxx
        classes of &lt;iostream&gt;, &lt;fstream&gt;,
        &lt;regex&gt;, etc. does not have typedefs for
        char16_t/char32_t.

        <p align="left" style="margin-top: 0.04in">
        Functions such as stoi, to_string in &#8216;21.4 Numeric
        Conversion&#8217; does not support char16_t/char32_t types.

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Add commented
        lines corresponding to char16_t, char32_t.

        <p align="left">
        <br>

        <p align="left">
        21.2 paragraph1

        <p align="left">
        &nbsp;

        <p align="left">
        namespace std {

        <p align="left">
        &nbsp;...

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;// 21.4: numeric conversions

        <p align="left">
        &nbsp;...

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;int stoi(const u16string&amp; str, size_t *idx = 0,
        int base = 10);

        <p align="left">
        &nbsp;long stol(const u16string&amp; str, size_t *idx = 0,
        int base = 10);

        <p align="left">
        &nbsp;unsigned long stoul(const u16string&amp; str, size_t
        *idx = 0, int base = 10);

        <p align="left">
        &nbsp;long long stoll(const u16string&amp; str, size_t *idx
        = 0, int base = 10);

        <p align="left">
        &nbsp;unsigned long long stoull(const u16string&amp; str,
        size_t *idx = 0, int base = 10);

        <p align="left">
        &nbsp;float stof(const u16string&amp; str, size_t *idx =
        0);

        <p align="left">
        &nbsp;double stod(const u16string&amp; str, size_t *idx =
        0);

        <p align="left">
        &nbsp;long double stold(const u16string&amp; str, size_t
        *idx = 0);

        <p align="left">
        &nbsp;u16string to_u16string(long long val);

        <p align="left">
        &nbsp;u16string to_u16string(unsigned long long val);

        <p align="left">
        &nbsp;u16string to_u16string(long double val);

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp; int stoi(const u32string&amp; str, size_t *idx = 0,
        int base = 10);

        <p align="left">
        &nbsp;long stol(const u32string&amp; str, size_t *idx = 0,
        int base = 10);

        <p align="left">
        &nbsp;unsigned long stoul(const u32string&amp; str, size_t
        *idx = 0, int base = 10);

        <p align="left">
        &nbsp;long long stoll(const u32string&amp; str, size_t *idx
        = 0, int base = 10);

        <p align="left">
        &nbsp;unsigned long long stoull(const u32string&amp; str,
        size_t *idx = 0, int base = 10);

        <p align="left">
        &nbsp;float stof(const u32string&amp; str, size_t *idx =
        0);

        <p align="left">
        &nbsp;double stod(const u32string&amp; str, size_t *idx =
        0);

        <p align="left">
        &nbsp;long double stold(const u32string&amp; str, size_t
        *idx = 0);

        <p align="left">
        &nbsp;u32string to_u32string(long long val);

        <p align="left">
        &nbsp;u32string to_u32string(unsigned long long val);

        <p align="left">
        &nbsp;u32string to_u32string(long double val);

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        27.2

        <p align="left">
        &nbsp;

        <p align="left">
        namespace std {

        <p align="left">
        &nbsp;...

        <p align="left">
        &nbsp;typedef basic_ios&lt;char&gt; ios;

        <p align="left">
        &nbsp;typedef basic_ios&lt;wchar_t&gt; wios;

        <p align="left">
        &nbsp;typedef basic_ios&lt;char16_t&gt; u16ios;

        <p align="left">
        &nbsp;typedef basic_ios&lt;char32_t&gt; u32ios;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;...

        <p align="left">
        &nbsp;typedef basic_ifstream&lt;wchar_t&gt; wifstream;

        <p align="left">
        &nbsp;typedef basic_ofstream&lt;wchar_t&gt; wofstream;

        <p align="left">
        &nbsp;typedef basic_fstream&lt;wchar_t&gt; wfstream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;typedef basic_streambuf&lt;char16_t&gt; u16streambuf;

        <p align="left">
        &nbsp;typedef basic_istream&lt;char16_t&gt; u16istream;

        <p align="left">
        &nbsp;typedef basic_ostream&lt;char16_t&gt; u16ostream;

        <p align="left">
        &nbsp;typedef basic_iostream&lt;char16_t&gt; u16iostream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;typedef basic_stringbuf&lt;char16_t&gt; u16stringbuf;

        <p align="left">
        &nbsp;typedef basic_istringstream&lt;char16_t&gt;
        u16istringstream;

        <p align="left">
        &nbsp;typedef basic_ostringstream&lt;char16_t&gt;
        u16ostringstream;

        <p align="left">
        &nbsp;typedef basic_stringstream&lt;char16_t&gt;
        u16stringstream;

        <p align="left">
        &nbsp;typedef basic_filebuf&lt;char16_t&gt; u16filebuf;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;typedef basic_ifstream&lt;char16_t&gt; u16ifstream;

        <p align="left">
        &nbsp;typedef basic_ofstream&lt;char16_t&gt; u16ofstream;

        <p align="left">
        &nbsp;typedef basic_fstream&lt;char16_t&gt; u16fstream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;typedef basic_streambuf&lt;char32_t&gt; u32streambuf;

        <p align="left">
        &nbsp;typedef basic_istream&lt;char32_t&gt; u32istream;

        <p align="left">
        &nbsp;typedef basic_ostream&lt;char32_t&gt; u32ostream;

        <p align="left">
        &nbsp;typedef basic_iostream&lt;char32_t&gt; u32iostream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;typedef basic_stringbuf&lt;char32_t&gt; u32stringbuf;

        <p align="left">
        &nbsp;typedef basic_istringstream&lt;char32_t&gt;
        u32istringstream;

        <p align="left">
        &nbsp;typedef basic_ostringstream&lt;char32_t&gt;
        u32ostringstream;

        <p align="left">
        &nbsp;typedef basic_stringstream&lt;char32_t&gt;
        u32stringstream;

        <p align="left">
        &nbsp;typedef basic_filebuf&lt;char32_t&gt; u32filebuf;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;typedef basic_ifstream&lt;char32_t&gt; u32ifstream;

        <p align="left">
        &nbsp;typedef basic_ofstream&lt;char32_t&gt; u32ofstream;

        <p align="left">
        <u>&nbsp;typedef basic_fstream&lt;char32_t&gt;
        u32fstream;</u>

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;...

        <p align="left">
        &nbsp;template &lt;class state&gt; class fpos;

        <p align="left">
        &nbsp;typedef
        fpos&lt;char_traits&lt;char&gt;::state_type&gt; streampos;

        <p align="left">
        &nbsp;typedef
        fpos&lt;char_traits&lt;wchar_t&gt;::state_type&gt;
        wstreampos;

        <p align="left">
        &nbsp;typedef
        fpos&lt;char_traits&lt;char16_t&gt;::state_type&gt;
        u16streampos;

        <p align="left">
        &nbsp;typedef
        fpos&lt;char_traits&lt;char32_t&gt;::state_type&gt;
        u32streampos;

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        27.6

        <p align="left">
        &nbsp;

        <p align="left">
        namespace std {

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_istream;

        <p align="left">
        &nbsp;typedef basic_istream&lt;char&gt; istream;

        <p align="left">
        &nbsp;typedef basic_istream&lt;wchar_t&gt; wistream;

        <p align="left">
        &nbsp;<u>typedef basic_istream&lt;char16_t&gt;
        u16istream;</u>

        <p align="left">
        &nbsp;typedef basic_istream&lt;char32_t&gt; u32istream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_iostream;

        <p align="left">
        &nbsp;typedef basic_iostream&lt;char&gt; iostream;

        <p align="left">
        &nbsp;typedef basic_iostream&lt;wchar_t&gt; wiostream;

        <p align="left">
        &nbsp;<u>typedef basic_iostream&lt;char16_t&gt;
        u16iostream;</u>

        <p align="left">
        &nbsp;typedef basic_iostream&lt;char32_t&gt; u32iostream;

        <p align="left">}

        <p align="left">
        &nbsp;

        <p align="left">
        namespace std {

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_ostream;

        <p align="left">
        &nbsp;typedef basic_ostream&lt;char&gt; ostream;

        <p align="left">
        &nbsp;typedef basic_ostream&lt;wchar_t&gt; wostream;

        <p align="left">
        &nbsp;<u>typedef basic_ostream&lt;char16_t&gt;
        u16ostream;</u>

        <p align="left">
        &nbsp;typedef basic_ostream&lt;char32_t&gt; u32ostream;

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        27.7 paragraph 1

        <p align="left">
        &nbsp;

        <p align="left">
        namespace std {

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        &nbsp;&nbsp;&nbsp;&nbsp; class Allocator =
        allocator&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_stringbuf;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;typedef basic_stringbuf&lt;char&gt; stringbuf;

        <p align="left">
        &nbsp;typedef basic_stringbuf&lt;wchar_t&gt; wstringbuf;

        <p align="left">
        &nbsp;<u>typedef basic_stringbuf&lt;char16_t&gt;
        u16stringbuf;</u>

        <p align="left">
        &nbsp;typedef basic_stringbuf&lt;char32_t&gt; u32stringbuf;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        &nbsp;&nbsp;&nbsp;&nbsp; class Allocator =
        allocator&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_istringstream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;typedef basic_istringstream&lt;char&gt;
        istringstream;

        <p align="left">
        &nbsp;typedef basic_istringstream&lt;wchar_t&gt;
        wistringstream;

        <p align="left">
        &nbsp;<u>typedef basic_istringstream&lt;char16_t&gt;
        u16istringstream;</u>

        <p align="left">
        &nbsp;typedef basic_istringstream&lt;char32_t&gt;
        u32istringstream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        &nbsp;&nbsp;&nbsp;&nbsp; class Allocator =
        allocator&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_ostringstream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;typedef basic_ostringstream&lt;char&gt;
        ostringstream;

        <p align="left">
        &nbsp;typedef basic_ostringstream&lt;wchar_t&gt;
        wostringstream;

        <p align="left">
        &nbsp;<u>typedef basic_ostringstream&lt;char16_t&gt;
        u16ostringstream;</u>

        <p align="left">
        &nbsp;typedef basic_ostringstream&lt;char32_t&gt;
        u32ostringstream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        &nbsp;&nbsp;&nbsp;&nbsp; class Allocator =
        allocator&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_stringstream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;typedef basic_stringstream&lt;char&gt; stringstream;

        <p align="left">
        &nbsp;typedef basic_stringstream&lt;wchar_t&gt;
        wstringstream;

        <p align="left">
        &nbsp;typedef basic_stringstream&lt;char16_t&gt;
        u16stringstream;

        <p align="left">
        &nbsp;typedef basic_stringstream&lt;char32_t&gt;
        u32stringstream;

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        27.8.1 paragraph 1

        <p align="left">
        &nbsp;

        <p align="left">
        namespace std {

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_filebuf;

        <p align="left">
        &nbsp;typedef basic_filebuf&lt;char&gt; filebuf;

        <p align="left">
        &nbsp;typedef basic_filebuf&lt;wchar_t&gt; wfilebuf;

        <p align="left">
        &nbsp;<u>typedef basic_filebuf&lt;char16_t&gt;
        u16filebuf;</u>

        <p align="left">
        &nbsp;typedef basic_filebuf&lt;char32_t&gt; u32filebuf;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_ifstream;

        <p align="left">
        &nbsp;typedef basic_ifstream&lt;char&gt; ifstream;

        <p align="left">
        &nbsp;typedef basic_ifstream&lt;wchar_t&gt; wifstream;

        <p align="left">
        &nbsp;<u>typedef basic_ifstream&lt;char16_t&gt;
        u16ifstream;</u>

        <p align="left">
        &nbsp;typedef basic_ifstream&lt;char32_t&gt; u32ifstream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_ofstream;

        <p align="left">
        &nbsp;typedef basic_ofstream&lt;char&gt; ofstream;

        <p align="left">
        &nbsp;typedef basic_ofstream&lt;wchar_t&gt; wofstream;

        <p align="left">
        &nbsp;<u>typedef basic_ofstream&lt;char16_t&gt;
        u16ofstream;</u>

        <p align="left">
        &nbsp;typedef basic_ofstream&lt;char32_t&gt; u32ofstream;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;template &lt;class charT, class traits =
        char_traits&lt;charT&gt; &gt;

        <p align="left">
        &nbsp;class basic_fstream;

        <p align="left">
        &nbsp;typedef basic_fstream&lt;char&gt; fstream;

        <p align="left">
        &nbsp;typedef basic_fstream&lt;wchar_t&gt; wfstream;

        <p align="left">
        &nbsp;<u>typedef basic_fstream&lt;char16_t&gt;
        u16fstream;</u>

        <p align="left">
        &nbsp;typedef basic_fstream&lt;char32_t&gt; u32fstream;

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        28.4

        <p align="left">
        &nbsp;

        <p align="left">
        namespace std {

        <p align="left">
        &nbsp;...

        <p align="left">
        &nbsp;typedef basic_regex&lt;char&gt; regex;

        <p align="left">
        &nbsp;typedef basic_regex&lt;wchar_t&gt; wregex;

        <p align="left">
        &nbsp;typedef basic_regex&lt;char16_t&gt; u16regex;

        <p align="left">
        &nbsp;typedef basic_regex&lt;char32_t&gt; u32regex;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;...

        <p align="left">
        &nbsp;typedef sub_match&lt;const char*&gt; csub_match;

        <p align="left">
        &nbsp;typedef sub_match&lt;const wchar_t*&gt; wcsub_match;

        <p align="left">
        &nbsp;typedef sub_match&lt;const char16_t*&gt;
        u16csub_match;

        <p align="left">
        &nbsp;typedef sub_match&lt;const char32_t*&gt;
        u16csub_match;

        <p align="left">
        &nbsp;typedef sub_match&lt;string::const_iterator&gt;
        ssub_match;

        <p align="left">
        &nbsp;typedef sub_match&lt;wstring::const_iterator&gt;
        wssub_match;

        <p align="left">
        &nbsp;typedef sub_match&lt;u16string::const_iterator&gt;
        u16ssub_match;

        <p align="left">
        &nbsp;typedef sub_match&lt;u32string::const_iterator&gt;
        u32ssub_match;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;...

        <p align="left">
        &nbsp;typedef match_results&lt;const char*&gt; cmatch;

        <p align="left">
        &nbsp;typedef match_results&lt;const wchar_t*&gt; wcmatch;

        <p align="left">
        &nbsp;typedef match_results&lt;const char16_t*&gt;
        u16cmatch;

        <p align="left">
        &nbsp;typedef match_results&lt;const char32_t*&gt;
        u32cmatch;

        <p align="left">
        &nbsp;typedef match_results&lt;string::const_iterator&gt;
        smatch;

        <p align="left">
        &nbsp;typedef match_results&lt;wstring::const_iterator&gt;
        wsmatch;

        <p align="left">
        &nbsp;typedef
        match_results&lt;u16string::const_iterator&gt; u16smatch;

        <p align="left">
        &nbsp;typedef
        match_results&lt;u32string::const_iterator&gt; u32smatch;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;...

        <p align="left">
        &nbsp;typedef regex_iterator&lt;const char*&gt;
        cregex_iterator;

        <p align="left">
        &nbsp;typedef regex_iterator&lt;const wchar_t*&gt;
        wcregex_iterator;

        <p align="left">
        &nbsp;typedef regex_iterator&lt;const cha16r_t*&gt;
        u16cregex_iterator;

        <p align="left">
        &nbsp;typedef regex_iterator&lt;const char32_t*&gt;
        u32cregex_iterator;

        <p align="left">
        &nbsp;typedef regex_iterator&lt;string::const_iterator&gt;
        sregex_iterator;

        <p align="left">
        &nbsp;typedef regex_iterator&lt;wstring::const_iterator&gt;
        wsregex_iterator;

        <p align="left">
        &nbsp;typedef
        regex_iterator&lt;u16string::const_iterator&gt;
        u16sregex_iterator;

        <p align="left">
        &nbsp;typedef
        regex_iterator&lt;u32string::const_iterator&gt;
        u32sregex_iterator;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;...

        <p align="left">
        &nbsp;typedef regex_token_iterator&lt;const char*&gt;
        cregex_token_iterator;

        <p align="left">
        &nbsp;typedef regex_token_iterator&lt;const wchar_t*&gt;
        wcregex_token_iterator;

        <p align="left">
        &nbsp;typedef regex_token_iterator&lt;const char16_t*&gt;
        u16cregex_token_iterator;

        <p align="left">
        &nbsp;typedef regex_token_iterator&lt;const char32_t*&gt;
        u32cregex_token_iterator;

        <p align="left">
        &nbsp;typedef
        regex_token_iterator&lt;string::const_iterator&gt;
        sregex_token_iterator;

        <p align="left">
        &nbsp;typedef
        regex_token_iterator&lt;wstring::const_iterator&gt;<span lang="zxx">
        &#12288;&#12288;&#12288;</span>wsregex_token_iterator;

        <p align="left">
        &nbsp;typedef
        regex_token_iterator&lt;u16string::const_iterator&gt;
        u16sregex_token_iterator;

        <p align="left">
        &nbsp;typedef
        regex_token_iterator&lt;u32string::const_iterator&gt;<span lang="zxx">
        &#12288;</span>u32sregex_token_iterator;

        <p align="left">}

        <p align="left"><br>

      <td>
        <p>

    Previously considered; we decided not to do it. We believe it is not too 
    onerous to use wbuffer_convert and wstring_convert which were added as 
    intermediaries to avoid proliferation of types.<tr valign="top">
      <td>
        <p>UK<br>
        144

      <td>
        <p align="justify">17.1

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">List of contents of library should be
        extened to cover new clauses

      <td>
        <p align="left">Add "regular expressions, atomic operations
        and threads"

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        145

      <td>
        <p align="justify">17.1

      <td>
        <p align="justify">6

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">
        <span lang="en-US">Summary of numeric facilities should
        mention random numbers</span>

        <p align="left"><br>

      <td>
        <p align="left">Add random number framework to the list of
        library facilities

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        146

      <td>
        <p align="justify">17.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Add a summary paragraph for regular
        expressions

      <td>
        <p align="left">Add a summary paragraph for regular
        expressions

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        147

      <td>
        <p align="justify">17.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Add a summary paragraph for threads

      <td>
        <p align="left">Add a summary paragraph for threads

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        148

      <td>
        <p align="justify">17.2

      <td>
        <p align="justify">Table 12

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Table 12 is
        mentioned in and relates to section 17.2, but has been
        pushed down to appear directly after the title of section
        17.3 which is rather unfortunate/confusing for the reader.

        <p align="left"><br>

      <td>
        <p align="left">Make sure tables are rendered in the
        section to which they relate.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        149

      <td>
        <p align="justify">17.3

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">For consistency
        with narrow-oriented and wide-oriented streams, we should
        add terms for streams of Unicode character sequences

        <p align="left"><br>

      <td>
        <p align="left">Define Utf16-oriented stream classes and
        Uft32-oriented stream classes for streams of
        char16_t/char32_t values.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        150

      <td>
        <p align="justify">17.3

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The addition of move semantics to the
        language means that many library APIs leave an object in a
        safely-destructible state, where no other operations can
        safely be performed unless it is assigned a new value.
        Library presentation would be simplified and made more
        precise if we introduce a term for this state. By analogy
        with singular iterators suggest the term 'singular object'
        or 'the object is in a singular state'.

      <td>
        <p align="left">Define 'singular
        state' such that an object with a singular state can only
        be assigned to or safely destroyed. Assiging a new value
        typically removes the singular state. Note that objects
        with a singular state may not be safely copied, so you
        cannot put an object into a singular state by copying
        another object in a singular state. Use this new term in
        the postcondition of all library APIs that move from an
        rvalue reference. It might also be used to simplify the
        definition of singular iterator to an iterator value with a
        singular state.

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        151

      <td>
        <p align="justify">17.3.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Missing
        crossreference to 17.3.17 [defns.repositional.stream]

        <p align="left"><br>

      <td>
        <p align="left">Add cross-reference in the existing empty
        brackets

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        152

      <td>
        <p align="justify">17.3.12

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Object state is
        using a definition of object (instance of a class) from
        outside the standard, rather than the 'region of storage'
        definiton in 1.8p1

        <p align="left"><br>

      <td>
        <p align="left">Clarify terms and usage

      <td>
        <p>

    we think we're removing this; Howard to create LWG issue. Howard, see [func.referenceclosure.cons]<tr valign="top">
      <td>
        <p>UK<br>
        153

      <td>
        <p align="justify">17.3.17

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">If a
        repositional stream can only seek to a position previously
        encountered, then an arbitrary-positional-stream cannot
        satisfy this definition, as cross-referenced in 17.3.17

        <p align="left"><br>

      <td>
        <p align="left">Strike the word 'only'. A note might be
        added to reinforce the intent

      <td>
        <p>

    editorial; sent to Pete Becker<tr valign="top">
      <td>
        <p align="justify" style=
        "margin-right: -0.18in; margin-bottom: 0in">UK<br>
        154

        <p>

      <td>
        <p align="justify">17.3.20

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Missing definition of a stable partition
        algorithm

      <td>
        <p align="left">Add definition from 25.2.12p7

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        155

      <td>
        <p align="justify">17.3.3

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Add clause 28 to list that use this
        definition of character

      <td>
        <p align="left">Add clause 28 to list that use this
        definition of character

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        156

      <td>
        <p align="justify">17.3.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Add regular
        expressions to set of templates using character container
        type

        <p align="left"><br>

      <td>
        <p align="left">Add regular expressions to set of templates
        using character container type

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        157

      <td>
        <p align="justify">17.5.2.2

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Add concepts to
        the ordered list of presentation

        <p align="left"><br>

        <p align="left"><br>

      <td>
        <p align="left">Add concepts into the sequence

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        158

      <td>
        <p align="justify">17.5.2.2

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">templates are neither classes nor functions

      <td>
        <p align="left">Replace
        'classes' and 'functions' with 'classes and class
        templates' and 'functions and function templates'

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        159

      <td>
        <p align="justify">17.5.2.4

      <td>
        <p align="justify">Footnote 152

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">This informative
        footnote was relevant in 1998, not 2008. The term 'existing
        vendors' may imply something different now

        <p align="left"><br>

      <td>
        <p align="left">Strike the footnote, or replace 'existing'
        with 'original' or similar

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        160

      <td>
        <p align="justify">17.5.2.4

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">requires is now
        a keyword with a specific meaning related to concepts, and
        its use in library specifcation may be confusing. Generally
        the Requires clause is used to make requirements on the
        caller, not the library, so typically providing runtime
        pre-conditions. Suggest a new name to refflect that. Note
        that Clause 30 already seems to be written to this
        convention.

        <p align="left"><br>

      <td>
        <p align="left">Replace 'Requires' with 'Preconditions'

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        161

      <td>
        <p align="justify">17.5.2.4

      <td>
        <p align="justify">4

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">This paragraph
        is redundant as the definition of the term 'handler
        function' is already provided in 17.3. Are we in danger of
        proving two definitions of the same terms? Which is the
        'controlling' definition?

        <p align="left"><br>

      <td>
        <p align="left">Strike 17.5.2.4p4

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        162

      <td>
        <p align="justify">17.5.2.4

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Clause 30 makes
        use of a 'Synchronization' semantic element, that
        frequently appears either between Effects: and
        Postconditions:, or between Returns: and Throws:

        <p align="left"><br>

      <td>
        <p align="left">Add 'Synchronization' to the list either
        between Effects: and Postconditions:, or between Returns:
        and Throws:.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        163

      <td>
        <p align="justify">17.5.2.4

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Many functions
        are defined as "Effects: Equivalent to a...", which seems
        to also define the preconditions, effects, etc. But this is
        not made clear.

        <p align="left"><br>

      <td>
        <p align="left">Introduce an explicit "Equivalent to",
        which defines all of the properties of the function.

      <td>
        <p>

    Tom Plum to open LWG issue; we believe this is related to LWG625<tr valign="top">
      <td>
        <p>UK<br>
        164

      <td>
        <p align="justify">17.5.3.2.1

      <td>
        <p align="justify">1

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">This phrasing predates concepts. While this
        kind of description is still used, the examples provided
        are now all concepts, and should be replaced with
        appropriate examples

      <td>
        <p align="left">Use better names
        for the examples. Ideally totally replace the need by
        constraining all templates in library, so that real
        concepts are all that is needed. Note if retained that
        CopyConstructible is mis-spelled.

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        165

      <td>
        <p align="justify">17.5.3.2.2,<br>
&nbsp;17.5.3.2.3

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">constraints on
        bitmask and enumation types were supposed to be tightened
        up as part of the motivation for the constexpr feature -
        see paper n2235 for deails

        <p align="left"><br>

      <td>
        <p align="left">Adopt wording in line with the motivation
        described in N2235

      <td>
        <p>

    Robert Klarer to review<tr valign="top">
      <td>
        <p>UK<br>
        166

      <td>
        <p align="justify">17.5.3.<br>
        2.4.1,<br>
        17.5.3.3

        <p align="justify"><br>

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">List of library clauses should go up to 30,
        not 27

      <td>
        <p align="left">Replace initial refernce to ch27 with ch30

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        167

      <td>
        <p align="justify">17.5.3.4<br>
&nbsp;Private<br>
&nbsp;members

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Comment marker in wrong place.

      <td>
        <p align="left">Change: //
        streambuf* sb; exposition only to streambuf* sb; //
        exposition only To reflect actual usage.

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        168

      <td>
        <p align="justify">17.6.2.2

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">We should make
        it clear (either by note or normatively) that namespace std
        may contain inline namespaces, and that entities specified
        to be defined in std may in fact be defined in one of these
        inline namespaces. (If we're going to use them for
        versioning, eg when TR2 comes along, we're going to need
        that.)

        <p align="left"><br>

      <td>
        <p align="left">Replace "namespace std or namespaces nested
        within namespace std" with "namespace std or namespaces
        nested within namespace std or inline namespaces nested
        directly or indirectly within namespace std"

      <td>
        <p>

    Howard will create issue to adopt UK words (some have reservations whether 
    it is correct)<tr valign="top">
      <td>
        <p>UK<br>
        169

      <td>
        <p align="justify">17.6.2.2

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">This phrasing
        contradicts later freedom to implement the C standard
        library portions in the global namespace as well as std.
        (17.6.2.3p4)

        <p align="left"><br>

      <td>
        <p align="left">Resolve conflict in either place

      <td>
        <p>

    Bill Plauger to open issue. If the wording is too broad we need to add an 
    exception to the standard C library.<tr valign="top">
      <td>
        <p>UK<br>
        170

      <td>
        <p align="justify">17.6.2.3

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">One of goals of
        C++0x is to make language easier to teach and for
        'incidental' programmers. The fine-grained headers of the
        C++ library are valuable in large scale systems for
        managing dependencies and optimising build times, but
        overcomplicated for simple development and tutorials. Add
        additional headers to support the whole library through a
        single include statement.

        <p align="left"><br>

      <td>
        <p align="left">Add a new header &lt;std&gt; that has the
        effect of including everything in tables 13 and 14, except
        &lt;iosfwd&gt; and &lt;cassert&gt;. Add an additional
        header &lt;fwd&gt; that adds all declarations from
        &lt;std&gt; but no definitions.

      <td>
        <p>

    Alisdair to open issue. We prefer &lt;std&gt; only.<tr valign="top">
      <td>
        <p>UK<br>
        171

      <td>
        <p align="justify">17.6.2.4

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Does
        freestanding implementation require a full implementation
        of all listed headers? The reference to abort, at_exit and
        exit is confusing. Is a conforming implementation allow to
        deliver partial forms of these headers? If so which ones?
        Are empty versions of everything but &lt;cstdlib&gt;
        conforming?

        <p align="left"><br>

      <td>
        <p align="left">Either strike the references to abort,
        at_exit and exit, or clarify which headers only require
        partial support.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        172

      <td>
        <p align="justify">17.6.2.4

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Te

      <td>
        <p align="left">No reference to
        new functions quick_exit and at_quick_exit

        <p align="left"><br>

      <td>
        <p align="left">Add reference to quick_exit and
        at_quick_exit

      <td>
        <p>

    NAD. We do not belive at_exit and at_quick_exit should be required by 
    freestanding implementations.<tr valign="top">
      <td>
        <p>UK<br>
        173

      <td>
        <p align="justify">17.6.2.4

      <td>
        <p align="justify">table 15

      <td>
        <p align="justify">Te

      <td>
        <p align="left">
        &lt;initializer_list&gt; is missing from headers required
        in freestanding implementations.

        <p align="left"><br>

      <td>
        <p align="left">Add 18.8, initializer lists,
        &lt;initializer_list&gt;, to the end of the table.

      <td>
        <p>

    LWG is interested in N2814, but we're concerned whether CWG will accept 
    language recommendations.<tr valign="top">
      <td>
        <p>JP 23

      <td>
        <p align="left">17.6.2.4

      <td>
        <p align="left">2<sup>nd</sup> <font size="2"
        style="font-size: 11pt">para, Table 15</font>

      <td>
        <p>te

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">There is a
        freestanding implementation including &lt;type_traits&gt;,
        &lt;array&gt;, &lt;ratio&gt;, lately added to Table 13, C++
        library headers.<br>
        Programmers think them useful and hope that these headers
        are also added to Table 15, C++ headers for freestanding
        implementations, that shows the set of headers which a
        freestanding implementation shall include at least.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        &lt;type_traits&gt;, &lt;array&gt;, &lt;ration&gt; to Table
        15.

      <td>
        <p>

    LWG is interested in N2814, but we're concerned whether CWG will accept 
    language recommendations.<p>

    add &lt;type_traits&gt; only. Alisdair will draft an issue.<tr valign="top">
      <td>
        <p>UK<br>
        174

      <td>
        <p align="justify">17.6.3.2

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The phrasing is
        mildly ambiguous when using the word 'it' to refer back to
        the header - an unfotunate reading might confuse it with
        the translate unit, which is the subject of the surrounding
        clause.

        <p align="left"><br>

      <td>
        <p align="left">Replace 'the first reference to any of the
        entities declared in that header by the translation unit'
        with 'the first reference to any of the entities that
        header declares in the translation unit'

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        175

      <td>
        <p align="justify">17.6.4.2.1

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Local types can
        now be used to instantiate templates, but don't have
        external linkage

        <p align="left"><br>

      <td>
        <p align="left">Remove the reference to external linkage

      <td>
        <p>

    we accept the proposed solution. Martin will draft an issue.<tr valign="top">
      <td>
        <p>UK<br>
        176

      <td>
        <p align="justify">17.6.4.3.3

      <td>
        <p align="justify">Footnote 175

        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Reference to namespace ::std should be
        17.6.4.2

      <td>
        <p align="left">Change referfence from 17.6.4.3 to 17.6.4.2

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        177

      <td>
        <p align="justify">17.6.4.3.4

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Sentence is
        redundant as double underscores are reserved in all
        contexts by 17.6.4.3.3

        <p align="left"><br>

      <td>
        <p align="left">Strike the sentence

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        178

      <td>
        <p align="justify">17.6.4.8

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The last sentence of the third bullet
        "Operations on such types can report a failure by throwing
        an exception unless otherwise specified" is redundant as
        behaviour is already undefined.

      <td>
        <p align="left">Strike the sentence

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        179

      <td>
        <p align="justify">17.6.4.8

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">According to the
        4th bullet there is a problem if "if any replacement
        function or handler function or destructor operation throws
        an exception". There should be no problem throwing
        exceptions so long as they are caught within the function.

        <p align="left"><br>

      <td>
        <p align="left">Replace the word 'throws' with 'propogates'

      <td>
        <p>

    Agreed. Alisdair will draft an issue.<tr valign="top">
      <td>
        <p>JP 22

      <td>
        <p align="left">17.6.5.7

      <td>
        <p align="left">4<sup>th</sup> <font size="2"
        style="font-size: 11pt">para, 1<sup>st</sup>
        line</font>

      <td>
        <p>ed

      <td>
        <p align="left">The
        statement below describes relation among two or more
        threads using words &#8220;between threads&#8221;:<br>
        [Note: This means, for example, that implementations
        can&#8217;t use a static object for internal purposes
        without synchronization because it could cause a data race
        even in programs that do not explicitly share objects
        between threads. &#8212;end note ]

        <p align="left" style="margin-top: 0.04in">In
        such case, &#8220;among&#8221; is preferred instead of
        &#8220;between&#8221;.

      <td>
        <p align="left">
        Change "between threads" to "among threads".

        <p align="left" style="margin-top: 0.04in">
        There are same cases in 17.6.1 paragraph 2, 17.6.5.7
        paragraph 6, 30.1 paragraph 1, 30.3.1 paragraph 1 also.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        180

      <td>
        <p align="justify">17.6.5.10

      <td>
        <p align="justify">1, 4

      <td>
        <p align="justify">Te

      <td>
        <p align="left">It should not be
        possible to strengthen the exception specification for
        virtual functions as this could break user code. Note this
        is not a problem in practice as there are no virtual
        functions with exception specifications in the current
        library, other than empty throw specifications which it is
        not possible to strengthen.

        <p align="left"><br>

      <td>
        <p align="left">Add restriction that exception
        specification of virtual functions cannot be tightened.

      <td>
        <p>

    NAD, the standard already has the desired restriction.<tr valign="top">
      <td>
        <p>UK<br>
        181

      <td>
        <p align="justify">17.6.5.10

      <td>
        <p align="justify">Footnote 186

      <td>
        <p align="justify">Te

      <td>
        <p align="left">This footnote is
        wrong. C library functions do not have any exception
        specification, but might be treated as if they had an empty
        throw specification

        <p align="left"><br>

      <td>
        <p align="left">Clarify that this note does not mean the
        functions are genuinely declared with the specification,
        but are treated as-if.

      <td>
        <p>

    We agree that the footnote is wrong and it will be removed. Pete will handle 
    as editorial.<tr valign="top">
      <td>
        <p>UK<br>
        182

      <td>
        <p align="justify">17.6.5.10

      <td>
        <p align="justify">Footnote 188

      <td>
        <p align="justify">Te

      <td>
        <p align="left">It is very
        helpful to assume all exceptions thrown by the standard
        library derive from std::exception. The 'encouragement' of
        this note should be made normative.

        <p align="left"><br>

      <td>
        <p align="left">Make this footnote normative

      <td>
        <p>

    NAD. We cannot mandate all standard-library functions that might use some 
    third-party library.<tr valign="top">
      <td>
        <p>UK<br>
        184

      <td>
        <p align="justify">18 -&gt; 30

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The new
        alias-declaration syntax is generally easier to read than a
        typedef declaration. This is especially true for complex
        types like function pointers.

        <p align="left"><br>

      <td>
        <p align="left">Replace all typedef declarations in the
        standard library with alias-declarations, except in the
        standard C library.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>JP 24

      <td>
        <p align="left">18

      <td>
        <p align="left">2<sup>nd</sup> <font size="2"
        style="font-size: 11pt">para, Table 16</font>

      <td>
        <p>ed

      <td>
        <p align="left">
        Subclauses are listed in Table 16 as:

        <p align="left" style=
        "text-indent: 0.06in; margin-bottom: 0in">"18.6 Type
        identification &#8230;"

        <p align="left" style=
        "text-indent: 0.06in; margin-bottom: 0in">"18.8 Initializer
        lists &#8230;"

        <p align="left" style=
        "text-indent: 0.06in; margin-top: 0.04in">"18.7 Exception
        handling &#8230;".

      <td>
        <p align="left" style=
        "margin-left: 0.06in; text-indent: -0.06in; margin-bottom: 0in">
        Sort them in the increasing order<br>
        "18.6 Type identification &#8230;"

        <p align="left" style=
        "text-indent: 0.06in; margin-bottom: 0in">"18.7 Exception
        handling &#8230;".

        <p align="left" style=
        "text-indent: 0.06in; margin-top: 0.04in; margin-bottom: 0.04in">
        "18.8 Initializer lists &#8230;"

        <p align="left" style=
        "text-indent: 0.06in; margin-top: 0.04in"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>JP 25

      <td>
        <p align="left">18.1

      <td>
        <p align="left">
        6<sup>th</sup> <font size="2" style=
        "font-size: 11pt">para , last line, SEE ALSO</font>

        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">
        max_align_t is described in 18.1, so add 3.11 Alignment as
        the reference.

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        "<u>3.11, Alignment</u><font color="#000000">" to</font>
        <font size="2" style="font-size: 11pt">SEE ALSO.</font>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>FR 32

      <td>
        <p>18.2.1<br>
&nbsp;[Numeric<br>
&nbsp;limits]

      <td>
        <p>

      <td>
        <p>te

      <td>
        <p>The definition of
        numeric_limits&lt;&gt; as requiring a regular type is both
        conceptually wrong and operationally illogical. As we
        pointed before, this mistake needs to be corrected. For
        example, the template can be left unconstrained. In fact
        this reflects a much more general problem with
        concept_maps/axioms and their interpretations. It appears
        that the current text heavily leans toward experimental
        academic type theory.

        <p>

      <td>
        <p>We suggest that a more pragmatic approach, in the spirit
        of C and C++, be taken so that calls to constrained
        function templates are interpreted as assertions on
        *values*, not necessarily semantics assertions on the
        carrier type.

      <td>
        <p>

    Alisdair and Gaby will work on a resolution.<tr valign="top">
      <td>
        <p>DE-16

      <td>
        <p>18.2.1

      <td>
        <p>

      <td>
        <p>te

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">DE-16 The class
        template numeric_limits should not specify the Regular
        concept requirement for its template parameter, because it
        contains functions returning NaN values for floating-point
        types; these values violate the semantics of
        EqualityComparable. See also library issue 902 in WG21
        document N2794 "C++ Standard Library Active Issues List
        (Revision R60)", available at
        http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2794.html
        .

        <p>

      <td>
        <p>Specify a concept requirement with fewer constraints as
        appropriate, for example SemiRegular.

      <td>
        <p>

    Alisdair and Gaby will work on a resolution.<tr valign="top">
      <td>
        <p>JP 26

      <td>
        <p align="left">18.2.1.1

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        numeric_limits does not use concept.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        <br>

        <p align="left">
        template&lt;class T&gt; class numeric_limits&lt;const
        T&gt;;

        <p align="left">
        template&lt;class T&gt; class numeric_limits&lt;volatile
        T&gt;;

        <p align="left">
        template&lt;class T&gt; class numeric_limits&lt;const
        volatile T&gt;;

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left">
        <br>

        <p align="left">
        template&lt;<u>Regular</u> T&gt; class
        numeric_limits&lt;const T&gt;;

        <p align="left">
        template&lt;<u>Regular</u> T&gt; class
        numeric_limits&lt;volatile T&gt;;

        <p align="left">
        template&lt;<u>Regular</u> T&gt; class
        numeric_limits&lt;const volatile T&gt;;

        <p align="left"><br>

      <td>
        <p>

    Alisdair will work on a resolution.<tr valign="top">
      <td>
        <p>DE-17

      <td>
        <p>18.2.6

      <td>
        <p>

      <td>
        <p>te

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">DE-17 The class
        type_index should be removed; it provides no additional
        functionality beyond providing appropriate concept maps.

        <p>

      <td>
        <p>Specify concept maps for "const type_info *" as required
        by the ordered and unordered containers and remove the
        class type_index.

      <td>
        <p>

    Doug will open an issue.<tr valign="top">
      <td>
        <p>UK<br>
        185

      <td>
        <p align="justify">18.3.1

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">There is no
        header &lt;stdint&gt;, it should either be &lt;stdint.h&gt;
        or &lt;cstdint&gt;

        <p align="left"><br>

      <td>
        <p align="left">Replace &lt;stdint&gt; with &lt;cstdint&gt;

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>DE-18

      <td>
        <p>18.4

      <td>
        <p>

      <td>
        <p>te

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">DE-18 The
        proposed C++ standard makes a considerable number of
        existing programs that have well-defined behavior according
        to ISO/IEC 14882:2003 have undefined behavior without a
        diagnostic hint to the programmer at all. This applies to
        the presence of threads and to pointer safety (the latter
        was introduced to support garbage collection). In order to
        avoid requiring a full code review for user code,
        facilities should be present that allow the compile-time
        detection of the advanced features of the proposed C++
        standard. It is expected that C++ implementations will
        provide a means (for example, a command-line switch) to
        turn off either or both of threads and garbage collection
        support, turning potentially undefined programs into
        well-defined ones.<br>
        <i>Note:</i> This issue is contributing significantly to
        Germany's overall &#8220;no&#8221; vote.

        <p>

      <td>
        <p>Consider applying the changes proposed in WG21 document
        N2693 "Requirements on programs and backwards
        compatibility", available at
        http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2693.html
        .

      <td>
        <p>

    Straw polls: pointer safety: 9-1-10; threading: 14-2-9. Jens will open 
    multiple issues.<tr valign="top">
      <td>
        <p>UK<br>
        186

      <td>
        <p align="justify">18.4

      <td>
        <p align="justify">Footnote 221

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">What is the
        purpose of this comment? The standard stream objects (cin,
        cerr etc.) have a peculiar lifetime that extends beyond the
        program. They may never be destroyed so will not be
        responsible for flushing buffers at the stated time.

        <p align="left"><br>

      <td>
        <p align="left">Remove the footnote

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        187

      <td>
        <p align="justify">18.4

      <td>
        <p align="justify">9

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The term "thread
        safe" is not defined nor used in this context anywhere else
        in the standard.

        <p align="left"><br>

      <td>
        <p align="left">Clarify the intended meaing of "thread
        safe"

      <td>
        <p>

    Lawrence Crowl will open an issue.<tr valign="top">
      <td>
        <p>UK<br>
        188

      <td>
        <p align="justify">18.4

      <td>
        <p align="justify">12

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The function
        _Exit does not appear to be defined in this standard.
        Should it be added to the table of functions
        included-by-reference to the C standard?

        <p align="left"><br>

      <td>
        <p align="left">Depends on where _Exit comes from

      <td>
        <p>

    Agreed. Bill Plauger will open an issue.<tr valign="top">
      <td>
        <p>UK<br>
        189

      <td>
        <p align="justify">18.4, 18.7

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The addition of the [[noreturn]] attribute
        to the language will be an important aid for static
        analysis tools.

      <td>
        <p align="left">The following
        functions should be declared in C++ with the [[noreturn]]
        attribute: abort exit quick_exit terminate unexpected
        rethrow_exception throw_with_nested

        <p align="left"><br>

      <td>
        <p>

    Agreed. Howard will open an issue.<tr valign="top">
      <td>
        <p>JP 27

      <td>
        <p align="left">18.4, 18.9,<br>
&nbsp;18.7.2.2,<br>
&nbsp;18.7.3.1

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        There are Standard library functions that never return to
        the caller. They are explained so in the Standard but not
        declared explicitly.

      <td>
        <p align="left">
        Consider to add the attribute [[noreturn]] to such
        functions,

        <p align="left">
        <br>

        <p align="left">
        15.5.2 unexpected<br>
        18.4: abort(), exit(), quick_exit,<br>
        18.7.2.2: unexpected_handler,<br>
        18.7.3.1: terminate_handler,

        <p align="left">
        18.7.6 rethrow_nested

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">18.7.6
        throw_with_nested<br>
        18.9: longjmp.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p>

    See UK 180<tr valign="top">
      <td>
        <p>UK<br>
        190

      <td>
        <p align="justify">18.5.1

      <td>
        <p align="justify">various

      <td>
        <p align="justify">Te

      <td>
        <p align="left">It is not entirely clear how the current
        specification acts in the presence of a garbage collected
        implementation.

      <td>
        <p align="left">All deallocation
        functions taking a pointer parameter should have a
        Precondition : ptr is a safely-derived pointer value.

        <p align="left"><br>

      <td>
        <p>

    agreed. Alisdair will open an issue.<tr valign="top">
      <td>
        <p>UK<br>
        191

      <td>
        <p align="justify">18.5.1.1

      <td>
        <p align="justify">4

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">According to the second bullet, behaviour
        becomes undefined (for lack of a specification) if the user
        has not yet called set_new_handler.

      <td>
        <p align="left">Rephrase the
        second bullet in terms of a new handler being installed,
        and update any definition of handler function necessary to
        be sure the term 'installed' is defined.

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        192

      <td>
        <p align="justify">18.5.1.2

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The declared
        signature is not compatible with the current requirement to
        throw std::length_error. It is too late to weaken the
        exception specification, so the only other change is to
        preserve new (improved) behaviour is to throw
        std::bad_alloc, or something derived from std::bad_alloc.

        <p align="left"><br>

      <td>
        <p align="left">Fix 5.3.4p7 by required std::bad_alloc
        rather than std::length_error

      <td>
        <p>

    Howard will open a CWG issue referring to N2814.<tr valign="top">
      <td>
        <p>UK<br>
        193

      <td>
        <p align="justify">18.5.2.2

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">quick_exit has
        been added as a new valid way to terminate a program in a
        well defined way

        <p align="left"><br>

      <td>
        <p align="left">Change 3rd bullet: call either abort(),
        exit() or quick_exit();

      <td>
        <p>

    change &quot;call either abort() or exit()&quot; to terminate the program. Bill 
    Plauger will open an issue.<tr valign="top">
      <td>
        <p>UK<br>
        194

      <td>
        <p align="justify">18.6

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The inclusion of
        type_index and hash&lt;type_index&gt; in &lt;typeinfo&gt;
        brings dependencies into &lt;typeinfo&gt; which are
        inconsistent with the definition of freestanding C++ in
        17.6.2.4.

        <p align="left"><br>

      <td>
        <p align="left">Move type_index and hash&lt;type_index&gt;
        out of &lt;typeinfo&gt; and into a new header,
        &lt;typeindex&gt;.

      <td>
        <p>

    already handled by the free-standing paper.<tr valign="top">
      <td>
        <p>JP 28

      <td>
        <p align="left">18.6,<br>
&nbsp;18.7,<br>
&nbsp;19.1

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left">
        Errors reported by Exception classes are of types char or
        std::string only. For example, std::exception is declared
        with char, std::string types, therefore types
        wchar_t/wstring, char16_t/u16string, or char32_t/u32string
        can not be used.

        <p align="left"><br>

      <td>
        <p align="left" style="margin-top: 0.04in">
        Consider other types.

      <td>
        <p>

    NAD. There is already guidance in the CD. It is the caller's responsibility 
    to internationalize MB character string.<tr valign="top">
      <td>
        <p>JP 29

      <td>
        <p align="left">18.7.6

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        throw_with_nested does not use concept.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        template&lt;class T&gt; void throw_with_nested(T&amp;&amp;
        t); // [[noreturn]]

        <p align="left">
        <br>

        <p align="left" style=
        "text-indent: 0.06in; margin-bottom: 0in">should be

        <p align="left">
        <br>

        <p align="left">
        template&lt;CopyConstructible T&gt; void
        throw_with_nested(T&amp;&amp; t); // [[noreturn]]

        <p align="left"><br>

      <td>
        <p>

    Alisdair will open an issue.<tr valign="top">
      <td>
        <p>JP 30

      <td>
        <p align="left">18.7.6

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">To
        handle nested exceptions strictly, error information of
        tree structure will be required though, the
        nested_exception does not support tree structure. It is
        insufficient as error handling.

      <td>
        <p align="left" style="margin-top: 0.04in">
        Consider nested_exception to support tree structure.

      <td>
        <p>

    Howard will ping Bill Plauger to request more information.<tr valign="top">
      <td>
        <p>JP 31

      <td>
        <p align="left">18.7.6

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">It
        is difficult to understand in which case nested_exception
        is applied.

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Consider to add
        a sample program which rethrows exception.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p>

    Alisdair will incorporate this in the JP29 paper.<tr valign="top">
      <td>
        <p>UK<br>
        195

      <td>
        <p align="justify">18.8

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The class
        definition of std::initializer_list contains concept-maps
        to Range which should be out of the class, and in
        &lt;iterator_concepts&gt; instead. Otherwise, it's not
        possible to use initializer_lists in a freestanding C++
        implementation.

        <p align="left"><br>

      <td>
        <p align="left">Delete the two concept maps from
        std::initializer_list.

      <td>
        <p>

    will be handled in connection with the free-standing paper.<tr valign="top">
      <td>
        <p>UK<br>
        196

      <td>
        <p align="justify">18.8.3

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Concept maps for initializer_list to Range
        should not be in language support headers, but instead in
        iterator concepts.

      <td>
        <p align="left">Remove section
        18.8.3 and put it in 24.1.8.1 instead, so that the
        concept_maps from initializer_list to Range are specified
        under Range instead of under initializer lists; also, so
        that they're implemented in &lt;iterator_concepts&gt;
        instead of &lt;initializer_list&gt;.

        <p align="left"><br>

      <td>
        <p>

    will be handled in connection with the free-standing paper.<tr valign="top">
      <td>
        <p>UK<br>
        197

      <td>
        <p align="justify">19

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">All the exception classes in this clause
        take a std::string argument by const reference. They should
        all be overloaded to accept std::string by rvalue rerefence
        for an efficient move as well.

      <td>
        <p align="left">Provide a
        constructor for every exception class in clause 19
        accepting a std::string by rvalue reference, with the
        semantics that the passed string may be moved.

        <p align="left"><br>

      <td>
        <p>

    NAD. Implementations are permitted to add the requested signature under the 
    as-if rule.<tr valign="top">
      <td>
        <p>JP 32

      <td>
        <p align="left">19.1

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left">
        Messages returned by the member function what() of standard
        exception classes seem difficult to judge.

        <p align="left">For
        example, following messages are returned by what() of
        std::bad_alloc of existing implementations:

        <p align="left">
        <br>

        <p align="left">
        Compiler: Message returned by what()

        <p align="left">
        ---------------------------------------------

        <p align="left">
        Borland C++ 5.6.4: no named exception thrown

        <p align="left">
        Visual C++ 8.0: bad allocation

        <p align="left">
        Code Warrior 8.0: exception

        <p align="left">g++
        3.4.4: St9exception

        <p align="left">
        <br>

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">It is difficult
        to recognize what exception was thrown when using those
        compilers except Visual C++.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">
        Consider to add footnote that recommends what() returns
        message easy to recognize what exception was thrown.

      <td>
        <p>

    NAD. Q of I.<tr valign="top">
      <td>
        <p>US 64

      <td>
        <p>19.3

      <td>
        <p>1

      <td>
        <p>Ge

      <td>
        <p><font color="#000000">&#8220;</font> See also: ISO C
        7.1.4, 7.2, Amendment 1 4.3.<font color="#000000">&#8221;
        It is unclear why this cross reference is here. Amendment 1
        was to C89, not C99.</font>

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Delete this
        cross reference. If necessary, expand the main text to
        include the relevant referenced text

        <p>

      <td>
        <p>

    We believe that this is editorial.<tr valign="top">
      <td>
        <p align="left">US 65

      <td>
        <p align="left">20

      <td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">Scoped allocators and
        allocator propagation traits add a small amount of utility
        at the cost of a great deal of machinery. The machinery is
        user visible, and it extends to library components that
        don't have any obvious connection to allocators, including
        basic concepts and simple components like pair and tuple.

      <td>
        <p align="left">
        Sketch of proposed resolution: Eliminate scoped allocators,
        replace allocator propagation traits with a simple uniform
        rule (e.g. always propagate on copy and move), remove all
        mention of allocators from components that don't explicitly
        allocate memory (e.g. pair), and adjust container
        interfaces to reflect this simplification.

        <p align="left">
        Components that I propose eliminating include <font size=
        "2" style="font-size: 11pt"><font color=
        "#0000FF"><span style=
        "background: #ffffce">HasAllocatorType</span></font><font color="#000080">
        <u><a href=
        "http://wiki.corp.google.com/twiki/bin/edit/Main/HasAllocatorType?topicparent=Main.CppStandardIssues">
        ?</a></u></font>, is_scoped_allocator,
        allocator_propagation_map, scoped_allocator_adaptor, and
        <font color="#0000FF"><span style=
        "background: #ffffce">ConstructibleAsElement</span></font><font color="#000080">
        <u><a href=
        "http://wiki.corp.google.com/twiki/bin/edit/Main/ConstructibleAsElement?topicparent=Main.CppStandardIssues">
        ?</a></u></font>.</font>

        <p align="left"><br>

      <td>
        <p align="left">The statement made in the comment was already aired prior to the last vote. 
    Without further input, the committee cannot remove a feature that was voted 
    into the draft. We will look at this comment in the light of N2829, which 
    attempts to make scoped allocators less intrusive.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        198

      <td>
        <p align="justify">20

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The organization of clause 20 could be
        improved to better group related items, making the standard
        easier to navigate.

      <td>
        <p align="left">20.6.7, 20.6.8,
        20.6.9 and 20.6.10 should be grouped under a section called
        "operator wrappers" or similar. The goal of all 4
        subsections combined is to provide a functor for every
        operator in the language. 20.6.17 class template hash
        should numerically appear immediately after the operator
        wrappers, as they are functors that are used in similar
        ways 20.6.11, 20.6.12, 20.6.13, 20.6.14, 20.6.15 are
        strongly related to 20.6.3, and to an extent 20.6.2. These
        should all come under a subheading of "function adapters"
        20.7.1, 20.7.3, 20.7.4, 20.7.5, 20.7.6, 20.7.7 and 20.7.10
        should all be grouped as subclauses under [20.7.2
        Allocators] [20.7.12 unique_ptr] should be a sub-section of
        [20.7.13 smart pointers] [20.7.13 smart pointers] is
        important enough to have a high level bullet after [20.7
        memory], suggest renumbering as [20.8 smart pointers]
        [20.7.13.7 Pointer safety] is nothing to do with smart
        pointers and should become its own subclause [20.7.14
        Pointer safety] [20.9 date and time functions] should be
        moved under [20.8 time utilities] and retitled [20.8.6 C
        Library] (as per memory management/C Library) [20.6.18
        reference_closure] is fundamentally a language support
        feature and should move to clause 18, see separate comment
        [20.6.5 reference_wrapper] should be simplified and moved
        into [2.2 utility components], see separate comment [20.6.4
        result_of] should be reorganised as a type trait - see
        separate comment Tuples and pairs are closely related so
        merge tuple and pair into the same subclause - see more
        general comment on this

        <p align="left"><br>

      <td>
        <p>

    Agree that this is editorial -- forward to project editor. (effective 
    duplicate of US 69)<tr valign="top">
      <td>
        <p>UK<br>
        199

      <td>
        <p align="justify">20.1.1, 20.1.2

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The requirement
        that programs do not supply concept_maps should probably be
        users do not supply their own concept_map specializations.
        THe program will almost certainly supply concept_maps - the
        standard itself supplies a specialization for RvalueOf?
        references. Note that the term _program_ is defined in
        3.5p1 and makes no account of the standard library being
        treated differently to user written code.

        <p align="left"><br>

      <td>
        <p align="left">Replace the term 'program' with 'user'.

      <td>
        <p>

    Agree change 'program' to 'user' in clauses 20.1.1 and 20.1.2<tr valign="top">
      <td>
        <p>UK<br>
        200

      <td>
        <p align="justify">20.1.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">All standard library use expects Predicates
        to be CopyConstructible, and this should be recognised
        easily without reatedly stating on every use-case.

      <td>
        <p align="left">Either require
        CopyConstructible&lt;F&gt; as part of Predicate, or create
        a refined concept, StdPredicate, used throughout the
        library that requires CopyConstructible as well as
        Callable. Consider making (Std)Predicate SemiRegular.

        <p align="left"><br>

      <td>
        <p>

    We agree that adding constraints to predicate is a good idea. Predicate 
    should be further constrained, rather than creating a new StdPredicate to 
    avoid the need users to constantly choose between them. At a minimum, 
    Predicate should refine MoveConstructible. However, upon review of existing 
    library components, CopyConstructible or even SemiRegular might be more 
    appropriate for Predicate.<tr valign="top">
      <td>
        <p>UK<br>
        201

      <td>
        <p align="justify">20.1.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The Consistency axiom for
        LessThanComparable will not compile.

      <td>
        <p align="left">Add a requires
        clause to the Consistency axiomL requires
        HasLessEquals&lt;T&gt; &amp;&amp;
        HasGreaterEquals&lt;T&gt;, or split the Consistency axiom
        into two so that 'basic' consistency can be asserted
        regardless of the &lt;=/&gt;= requirement.

        <p align="left"><br>

      <td>
        <p>

    After consultation with the submitter, we agreed that the suggestion was in 
    error and there is nothing else to be done.<tr valign="top">
      <td>
        <p>JP 33

      <td>
        <p align="left">20.1.5

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        LessThanComparable and EqualityComparable don't correspond
        to NaN.

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Apply
        concept_map to these concepts at FloatingPointType

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p>

    We believe that no change is necessary, but it should be reviewed by a group 
    devoted to numeric issues. Not every possible state for a type must 
    participate in the axioms. For example, pointers are dereferenceable even if 
    some pointers (e.g. the null pointer) should not be dereferenced.<tr valign="top">
      <td>
        <p>US 66

      <td>
        <p>20.1.10

      <td>
        <p>

      <td>
        <p>te

      <td>
        <p>Application of the "Regular" concept to floating-point
        types appears to be controversial (see long discussion on
        std-lib reflector).

      <td>
        <p>State that the &#8220;Regular&#8221; concept does not
        apply to floating-point types.

      <td>
        <p>

    Recommend that we handle the same as JP 33.<tr valign="top">
      <td>
        <p>JP 34

      <td>
        <p align="left">20.2

      <td>
        <p align="left">
        1<sup>st</sup> <font size="2" style=
        "font-size: 11pt">para, 4<sup>th</sup> line</font>

        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">
        Though N2672 pointed at adding
        "#include&lt;initializer_list&gt;", it isn't reflected.

      <td>
        <p align="left">add
        followings

        <p align="left" style="margin-top: 0.04in">
        #include &lt;initializer_list&gt; // for concept_map

      <td>
        <p>

    Agree that the omission of <code>#include
    <initializer_list></initializer_list>
    </code>was not agreed to in a vote and that the editor should reinstate it. 
    There is some disagreement as to whether it actually <em>should</em> be 
    there. Some believed it did not belong because we do not guarantee that one 
    header includes another anywhere else in the standard. However, the paper 
    that was voted in explicitly did make that guarantee. Removing that 
    guarantee is beyond the scope of this review.<tr valign="top">
      <td>
        <p>US 67

      <td>
        <p>20.2.1

      <td>
        <p>&#182; 5 first sent.

      <td>
        <p>ed

      <td>
        <p>Some connective words are missing.

      <td>
        <p>Insert &#8220;corresponding to&#8221; before &#8220;an
        lvalue reference type.&#8221;

      <td>
        <p>

    Yes. Forward to project editor.<tr valign="top">
      <td>
        <p>JP 35

      <td>
        <p align="left">20.2.3

      <td>
        <p align="left">
        6<sup>th</sup> <font size="2" style=
        "font-size: 11pt">para, 1<sup>st</sup> line</font>

        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left">
        Typo,

        <p align="left">"stdforward" should be
        "std::forward"

      <td>
        <p align="left">Correct typo.

      <td>
        <p>

    Yes. Forward to project editor.<tr valign="top">
      <td>
        <p>UK<br>
        202

      <td>
        <p align="justify">20.2.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The references
        to pair in the tuple-like access to pair functions qualify
        pair with std::pair even though they are in a namespace std
        block.

        <p align="left"><br>

      <td>
        <p align="left">Remove the std:: qualification from these
        references to pair.

      <td>
        <p>

    Yes. Forward to project editor.<tr valign="top">
      <td>
        <p>US 68

      <td>
        <p>20.2.12

      <td>
        <p>Integral<br>
        Like

      <td>
        <p>te/ed

      <td>
        <p>The code defining the context is syntactically
        incorrect.

      <td>
        <p>Insert a comma in two places: at the end of the third
        line of refinements, and at the end of the fourth line of
        refinements.

      <td>
        <p>

    Editorial. The correct section is 20.1.12, not 20.2.12. Forward to project 
    editor.<tr valign="top">
      <td>
        <p>UK<br>
        203

      <td>
        <p align="justify">20.3.2

      <td>
        <p align="justify">1-4

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The ratio_xyz
        types have a misplaced '}'. For example: template &lt;class
        R1, class R2&gt; struct ratio_add { typedef see below}
        type; ;

        <p align="left"><br>

      <td>
        <p align="left">Move the '}' to after the typedef: template
        &lt;class R1, class R2&gt; struct ratio_add { typedef see
        below type; };

      <td>
        <p>

    Yes. Forward to project editor.<tr valign="top">
      <td>
        <p>JP 36

      <td>
        <p align="left">20.4.2.1

      <td>
        <p align="left">
        19<sup>th</sup> <font size="2" style=
        "font-size: 11pt">para, 6<sup>th</sup> line</font>

        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left">
        Typo.

        <p align="left" style="margin-top: 0.04in">"it
        it" should be "it is"

      <td>
        <p align="left" style="margin-top: 0.04in">
        Correct typo.

      <td>
        <p>

    Yes. Forward to project editor.<tr valign="top">
      <td>
        <p>UK<br>
        204

      <td>
        <p align="justify">20.5

    [meta.<br>
        trans.<br>
        other]<td>
        <p align="justify">Table 41

      <td>
        <p align="justify">Te

      <td>
        <p align="left">It is not
        possible to create a variant union based on a parameter
        pack expansion, e.g. to implement a classic discriminated
        union template.

        <p align="left"><br>

      <td>
        <p align="left">Restore aligned_union template that was
        removed by LWG issue 856.

      <td>
        <p>

    Agree. The need for aligned_union is compelling enough to reinstate.<tr valign="top">
      <td>
        <p>US 69

      <td>
        <p>20.5

      <td>
        <p>

      <td>
        <p>ed

      <td>
        <p>This section, dealing with tuple&lt;&gt;, should be in
        the same section as the similar utility pair&lt;&gt;.

      <td>
        <p>Restructure Clause 20 so as to bring these similar
        components together.

      <td>
        <p>

    Editorial (effective duplicate of UK 198). Forward to project editor.<tr valign="top">
      <td>
        <p>UK<br>
        205

      <td>
        <p align="justify">20.5.3

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">
        integral_constant objects should be usable in
        integral-constant-expressions. The addition to the language
        of literal types and the enhanced rules for constant
        expressions make this possible.

        <p align="left"><br>

      <td>
        <p align="left">Add a constexpr conversion operator to
        class tempalate integral_constant: constexpr operator
        value_type() { return value; }

      <td>
        <p>

    Agree: Add a constexpr conversion operator to class template 
    integral_constant: <code>constexpr operator value_type() { return value; }</code><tr valign="top">
      <td>
        <p>UK<br>
        206

      <td>
        <p align="justify">20.5.5

      <td>
        <p align="justify">para 4

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Currently the
        std says: "In order to instantiate the template
        is_convertible&lt;From, To&gt;, the following code shall be
        well formed:" But the code shown is the requirement for the
        result of is_convertible to be a true_type, not a
        precondition on whether the template can be instantiated.

        <p align="left"><br>

      <td>
        <p align="left">Change: "In order to instantiate the
        template is_convertible&lt;From, To&gt;, the following code
        shall be well formed:" To: "The template
        is_convertible&lt;From, To&gt; inherits either directly or
        indirectly from true_type if the following code is well
        formed:"

      <td>
        <p>

    Agree with the proposed resolution: Section 20.5.5, Change: &quot;In order to 
    instantiate the template is_convertible&lt;From, To&gt;, the following code shall 
    be well formed:&quot; To: &quot;The template is_convertible&lt;From, To&gt; inherits either 
    directly or indirectly from true_type if the following code is well formed:&quot;<tr valign="top">
      <td>
        <p>UK<br>
        207

      <td>
        <p align="justify">20.5.6.1

      <td>
        <p align="justify">Table 36

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">suffix "::type" is missing from the some of
        the examples.

      <td>
        <p align="left">Change:
        Example:remove_const&lt;const volatile int&gt;::type
        evaluates to volatile int, whereas remove_const&lt;const
        int*&gt; is const int*. &#8212;end example To:
        Example:remove_const&lt;const volatile int&gt;::type
        evaluates to volatile int, whereas remove_const&lt;const
        int*&gt;::type is const int*. &#8212;end example And
        change: Example:remove_volatile&lt;const volatile
        int&gt;::type evaluates to const int, whereas
        remove_volatile&lt;volatile int*&gt; is volatile int*.
        &#8212;end example To: Example:remove_volatile&lt;const
        volatile int&gt;::type evaluates to const int, whereas
        remove_volatile&lt;volatile int*&gt;::type is volatile
        int*. &#8212;end example And change:
        Example:remove_cv&lt;const volatile int&gt;::type evaluates
        to int, whereas remove_cv&lt;const volatile int*&gt; is
        const volatile int*. &#8212;end example To:
        Example:remove_cv&lt;const volatile int&gt;::type evaluates
        to int, whereas remove_cv&lt;const volatile int*&gt;::type
        is const volatile int*. &#8212;end example

        <p align="left"><br>

      <td>
        <p>

    We tend to agree. Forward to project editor. Also recommend that the word 
    &quot;is&quot; be replaced with &quot;evaluates to&quot; in the same text.<tr valign="top">
      <td>
        <p>JP 37

      <td>
        <p align="left">20.5.7

      <td>
        <p align="left">Table 41

      <td>
        <p>ed

      <td>
        <p align="left">
        Typo.

        <p align="left" style=
        "text-indent: 0.19in; margin-bottom: 0in">There isn't a
        period at the end of enable_if's comments.

        <p align="left">
        <br>

        <p align="left">If
        B is true, the member typedef type shall equal T;
        otherwise, there shall be no member typedef type

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left">
        <br>

        <p align="left">If
        B is true, the member typedef type shall equal T;
        otherwise, there shall be no member typedef type.

        <p align="left"><br>

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        &#8221;.&#8221;

      <td>
        <p>

    Agree. Forward to project editor.<tr valign="top">
      <td>
        <p>US 70

      <td>
        <p>20.5 [meta]<td>
        <p>

      <td>
        <p>te

      <td>
        <p>Specifications now expressed via narrative text are more
        accurately and clearly expressed via executable code.

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Wherever
        concepts are available that directly match this
        section&#8217;s type traits, express the traits in terms of
        the concepts instead of via narrative text. Where the type
        traits do not quite match the corresponding concepts, bring
        the two into alignment so as to avoid two nearly-identical
        notions.

        <p>

      <td>
        <p>

    (The correct reference is section 20.5, not 20.6) We think that this is a 
    good idea, but it requires a lot of work. If someone submits a paper 
    proposing specific changes, we would be happy to review it at the next 
    meeting.<tr valign="top">
      <td>
        <p>US 71

      <td>
        <p>20.6.7 [meta.<br>
        trans.<br>
        other]<td>
        <p>Table 51, last row, column 3

      <td>
        <p>ed

      <td>
        <p>The grammar is incorrect.

      <td>
        <p>Change &#8220;conversion are&#8221; to &#8220;conversion
        is&#8221;.

      <td>
        <p>

    (The correct reference is section 20.5.7, table 41, last row). Agree: 
    Forward to project editor. There are several ways to fix the grammar.<tr>
      <td>
        <p>DE-20

      <td>
        <p>20.6.12 [bind]

      <td>
        <p>

      <td>
        <p>ed

      <td>
        <p>DE-20 The section heading and the first sentence use the term 
        &quot;template function&quot;, which is undefined.

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Replace &quot;template function&quot; 
        by &quot;function template&quot;.

        <p>

      <td>
        <p>

    Agree. Forward to the project editor.</tr>
    <tr>
      <td>
        <p align="left">US 72

      <td>
        <p align="left">20.6.12 [func.bind.<br>
        bind]<td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">
        bind should support move-only functors and bound arguments.

        <p align="left"><br>

      <td>
        <p align="left"><br>

      <td>
        <p align="left">We look forward to a paper on this topic. We recommend 
        no action until a paper is available. We do think that bind would 
        require further overloads to support move semantics, if indeed move 
        semantics are possible.<br>

    </tr>
    <tr>
      <td valign="top">
        <p>JP 38

      <td valign="top">
        <p align="left">20.6.12.<br>
        1.3 [func.<br>
        bind.<br>
        bind]<td valign="top">
        <p align="left"><br>

      <td valign="top">
        <p>te

      <td valign="top">
        <p align="left" style=
        "margin-left: 0.19in; text-indent: -0.19in; margin-bottom: 0in">
        add the move requirement for bind's return type.<br>
        <br>

        <p align="left" style=
        "margin-left: 0.19in; text-indent: -0.19in; margin-bottom: 0in">
        For example, assume following th1 and th2,

        <p align="left">
        <br>
        void f(vector&lt;int&gt; v) { }<br>
        <br>
        vector&lt;int&gt; v{ ... };<br>
        thread th1([v]{ f(v); });<br>
        thread th2(bind(f, v));<br>
        <br>
        When function object are set to thread, v is moved to th1's
        lambda expression in a Move Constructor of lambda
        expression becuase th1's lambda expression has a Move
        Constructor. But bind of th2's return type doesn't have the
        requirement of Move, so it may not moved but copied.

        <p align="left">Add
        the requirement of move to get rid of this useless copy.

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">And also, add
        the MoveConstructible as well as CopyConstructible.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td valign="top">
        <p align="left">Add
        the following requirements.<br>
        "<font color="#000000">it has a public move constructor
        that performs a member-wise move."</font>

        <p align="left" style="margin-top: 0.04in">Add
        the MoveConstructible.

      <td valign="top">
        <p>

    We were not clear about what the submitter really intended. Requiring that 
    the result of bind be <span class="twikiNewLink">MoveConstructible<a href="http://wiki.dinkumware.com/twiki/bin/edit/Wg21summit/MoveConstructible?topicparent=Wg21summit.LWGSubGroup2" rel="nofollow" title="Create this topic">?</a></span> 
    and/or <span class="twikiNewLink">CopyConstructible<a href="http://wiki.dinkumware.com/twiki/bin/edit/Wg21summit/CopyConstructible?topicparent=Wg21summit.LWGSubGroup2" rel="nofollow" title="Create this topic">?</a></span> 
    might be a start, but we would like to communicate with the submitter. 
    [NOTE: We would like to see a clarification of the wording for Returnable<t> 
    that makes it clear that move-only types can be Returnable.] </t>

    </tr>
    <tr>
      <td valign="top">
        <p>DE-21

      <td valign="top">
        <p>20.6.12.<br>
        1.3 [func.bind.<br>
        bind]<td valign="top">
        <p>

      <td valign="top">
        <p>te

      <td valign="top">
        <p>DE-21 The specification for bind claims twice that &quot;the values and 
        types for the bound arguments v1, v2, ..., vN are determined as 
        specified below&quot;. No such specification appears to exist.

      <td valign="top">
        <p>Add the missing specification in the same section, or add a 
        cross-reference indicating the section where the specification appears.

      <td valign="top">
        <p align="left">Agree. There are several differences (omissions) between 
        N2691 [func.bind.bind] and N2800 [func.bind.bind]. Ask the project 
        editor to review the changes.<br>

    </tr>
    <tr>
      <td valign="top">
        <p>UK<br>
        211

      <td valign="top">
        <p align="justify">20.6.12.<br>
        2.3 [unique.<br>
        ptr.<br>
        single.<br>
        asgn]<td valign="top">
        <p align="justify">11

      <td valign="top">
        <p align="justify">Te

      <td valign="top">
        <p align="left">The nullptr_t type was introduced to resolve the null 
        pointer literal problem. It should be used for the assignemnt operator, 
        as with the constructor and elsewhere through the library.

        <p align="left"><br>

      <td valign="top">
        <p align="left">Change signature here and in the synopsis to: unique_ptr&amp; 
        operator=(nullptr_t); Strike the sentance an note before the Effects 
        clause.

      <td valign="top">
        <p align="left">Agree.<br>

    </tr>
    <tr>
      <td valign="top">
        <p>UK<br>
        212

      <td valign="top">
        <p align="justify">20.6.13.7 [util.<br>
        dynamic.<br>
        safety]<td valign="top">
        <p align="justify"><br>

      <td valign="top">
        <p align="justify">Te

      <td valign="top">
        <p align="left">The pointer-safety API is nothing to do with smart 
        pointers, so does not belong in 20.7.13. In fact it is a set of language 
        support features are really belongs in clause 18, with the contents 
        declared in a header that deals with language-support of memory 
        management.

        <p align="left"><br>

      <td valign="top">
        <p align="left">Move this specification to 18.5. Move the declarations 
        into the header &lt;new&gt;.

      <td valign="top">
        <p align="left">Agree in principle, but not with the proposed 
        resolution. We believe it belongs either a subsection of either 20 
        [utilities] or 20.7 [memory] as part of the general reorganization of 
        20. The declaration should stay in
        <memory>. </memory>
        <br>

    </tr>
    <tr>
      <td valign="top">
        <p>DE-22

      <td valign="top">
        <p>20.6.16.2 [func.<br>
        wrap.<br>
        func]<td valign="top">
        <p>

      <td valign="top">
        <p>te

      <td valign="top">
        <p>DE-22 The conditions for deriving from std::unary_function and 
        std::binary_function are unclear: The condition would also be satisfied 
        if ArgTypes were std::vector&lt;T1&gt;, because it (arguably) &quot;contains&quot; T1.

      <td valign="top">
        <p>Consider stating the conditions in normative prose instead of in 
        comments in the class definition. Use &quot;consists of&quot; instead of 
        &quot;contains&quot;. Consider using &quot;if and only if&quot; instead of &quot;iff&quot;.

      <td valign="top">
        <p align="left">Agree. std::reference_wrapper has the same structure, 
        and we suggest that std::function be presented in the same way as 
        std::reference_wrapper.<br>

    </tr>
    <tr>
      <td valign="top">
        <p align="left">US 73

      <td valign="top">
        <p align="left">20.6.18<br>
        [expr.prim.<br>
        lambda], [func.<br>
        reference<br>
        closure]

      <td valign="top">
        <p align="left"><br>

      <td valign="top">
        <p align="left">te

      <td valign="top">
        <p align="left">The std::reference_closure template is redundant with 
        std::function and should be removed.

        <p align="left"><br>

        <p align="left">
        std::reference_closure is a premature optimization that provides a 
        limited subset of the functionality of std::function intended to improve 
        performance in a narrow use case. However, the parallel application 
        performance benchmark used to motivate the inclusion of 
        std::reference_closure was flawed in several ways:

        <ol start="3">
          <li>
            <p align="left">it failed to enable a common optimization in 
            std::function (implemented by all vendors), exacting a large and 
            unrealistic penalty for copying std::function instances, and

          <li>
            <p align="left">it failed to account for parallel scheduler overhead 
            or realistically-sized work units, both of which would dominate the 
            costs measured by the benchmark in any realistic application.
          </ol>

        <p align="left" style="margin-left: 0.25in"><br>

      <td valign="top">
        <p align="left">Remove 20.7.18 [func.referenceclosure].

        <p align="left"><br>

        <p align="left">Remove 5.1.1 paragraph 12.

      <td valign="top">
        <p align="left">This requires attention from CWG and/or EWG.<br>

    </tr>

    <tr valign="top">
      <td>
        <p>JP 39

      <td>
        <p align="left">20.6.16.2

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        There are no requires corresponding to F of std::function.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        template&lt;class F, Allocator A&gt;
        function(allocator_arg_t, const A&amp;, F);

        <p align="left">
        template&lt;class F, Allocator A&gt;
        function(allocator_arg_t, const A&amp;, F&amp;&amp;);

        <p align="left">
        <br>

        <p align="left" style=
        "text-indent: 0.06in; margin-bottom: 0in">should be

        <p align="left">
        <br>

        <p align="left">
        template&lt;class F, Allocator A&gt;

        <p align="left">
        requires CopyConstructible&lt;F&gt; &amp;&amp;
        Callable&lt;F, ArgTypes...&gt;

        <p align="left">
        &amp;&amp; Convertible&lt;Callable&lt;F,
        ArgTypes...&gt;::result_type, R&gt;

        <p align="left">
        function(allocator_arg_t, const A&amp;, F);

        <p align="left">
        template&lt;class F, Allocator A&gt;

        <p align="left">
        requires CopyConstructible&lt;F&gt; &amp;&amp;
        Callable&lt;F, ArgTypes...&gt;

        <p align="left">
        &amp;&amp; Convertible&lt;Callable&lt;F,
        ArgTypes...&gt;::result_type, R&gt;

        <p align="left">
        function(allocator_arg_t, const A&amp;, F&amp;&amp;);

        <p align="left"><br>

      <td>
        <p>

    Agree with one correction: <span class="twikiNewLink">CopyConstructible<a href="http://wiki.dinkumware.com/twiki/bin/edit/Wg21summit/CopyConstructible?topicparent=Wg21summit.LWGSubGroup2" rel="nofollow" title="Create this topic">?</a></span> 
    should be <span class="twikiNewLink">ConstructibleWithAllocator<a href="http://wiki.dinkumware.com/twiki/bin/edit/Wg21summit/ConstructibleWithAllocator?topicparent=Wg21summit.LWGSubGroup2" rel="nofollow" title="Create this topic">?</a></span> 
    . Pablo to supply wording. Also check with Howard that omission was not 
    deliberate.<tr valign="top">
      <td>
        <p>JP 40

      <td>
        <p align="left">20.6.16.2

      <td>
        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">
        Thougn it's "Allocator Aloc" at other places, it's
        "Allocator A" only std::function constructor template
        parameter.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        template&lt;class F, Allocator A&gt;
        function(allocator_arg_t, const A&amp;, F);

        <p align="left">
        template&lt;class F, Allocator A&gt;
        function(allocator_arg_t, const A&amp;, F&amp;&amp;);

        <p align="left">
        <br>

        <p align="left" style=
        "text-indent: 0.06in; margin-bottom: 0in">should be

        <p align="left">
        <br>

        <p align="left">
        template&lt;class F, Allocator <u>Alloc</u>&gt;
        function(allocator_arg_t, const <u>Alloc</u> &amp;, F);

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">
        template&lt;class F, Allocator <u>Alloc</u>&gt;
        function(allocator_arg_t, const <u>Alloc</u> &amp;,
        F&amp;&amp;);

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p>

    Agree, though minor. Forward to project editor (who may disregard).<tr valign="top">
      <td>
        <p>JP 41

      <td>
        <p align="left">20.6.16.2

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        There are no requires corresponding to R and Args of
        UsesAllocator.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        template &lt;class R, class... Args&gt;

        <p align="left">
        concept_map UsesAllocator&lt;function&lt;R(Args...)&gt;,
        Alloc&gt; {

        <p align="left">
        typedef Alloc allocator_type;

        <p align="left">}

        <p align="left">
        <br>

        <p align="left" style=
        "text-indent: 0.06in; margin-bottom: 0in">should be

        <p align="left">
        <br>

        <p align="left">
        template &lt;<u>Returnable</u> R,
        <u>CopyConstructible</u>... Args&gt;

        <p align="left">
        concept_map UsesAllocator&lt;function&lt;R(Args...)&gt;,
        Alloc&gt; {

        <p align="left">
        typedef Alloc allocator_type;

        <p align="left" style="margin-top: 0.04in">}

      <td>
        <p>

    This change would be redundant because function&lt;&gt; is already sufficiently 
    constrained. No actions necessary.<tr valign="top">
      <td>
        <p>JP 42

      <td>
        <p align="left">20.6.16.2

      <td>
        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">The requires
        are wrong.

        <p align="left" style="margin-top: 0.04in">R
        require Returnable, and ArgTypes requires CopyConstructible
        by a definition of function, then it's a mistake to
        designate followings by MoveConstructible.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        <br>

        <p align="left">
        template &lt;MoveConstructible R, MoveConstructible...
        ArgTypes&gt;

        <p align="left">
        bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;,
        nullptr_t);

        <p align="left">
        template &lt;MoveConstructible R, MoveConstructible...
        ArgTypes&gt;

        <p align="left">
        bool operator==(nullptr_t, const
        function&lt;R(ArgTypes...)&gt;&amp;);

        <p align="left">
        template &lt;MoveConstructible R, MoveConstructible...
        ArgTypes&gt;

        <p align="left">
        bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;,
        nullptr_t);

        <p align="left">
        template &lt;MoveConstructible R, MoveConstructible...
        ArgTypes&gt;

        <p align="left">
        bool operator!=(nullptr_t, const
        function&lt;R(ArgTypes...)&gt;&amp;);

        <p align="left">
        template &lt;MoveConstructible R, MoveConstructible...
        ArgTypes&gt;

        <p align="left">
        void swap(function&lt;R(ArgTypes...)&gt;&amp;,
        function&lt;R(ArgTypes...)&gt;&amp;);

        <p align="left">
        <br>

        <p align="left" style=
        "text-indent: 0.06in; margin-bottom: 0in">should be

        <p align="left">
        <br>

        <p align="left">
        template &lt;<u>Returnable</u> R,
        <u>CopyConstructible</u>... ArgTypes&gt;

        <p align="left">
        bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;,
        nullptr_t);

        <p align="left">
        template &lt;<u>Returnable</u> R,
        <u>CopyConstructible</u>... ArgTypes&gt;

        <p align="left">
        bool operator==(nullptr_t, const
        function&lt;R(ArgTypes...)&gt;&amp;);

        <p align="left">
        template &lt;<u>Returnable</u> R,
        <u>CopyConstructible</u>... ArgTypes&gt;

        <p align="left">
        bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;,
        nullptr_t);

        <p align="left">
        template &lt;<u>Returnable</u> R,
        <u>CopyConstructible</u>... ArgTypes&gt;

        <p align="left">
        bool operator!=(nullptr_t, const
        function&lt;R(ArgTypes...)&gt;&amp;);

        <p align="left">
        template &lt;<u>Returnable</u> R,
        <u>CopyConstructible</u>... ArgTypes&gt;

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">void
        swap(function&lt;R(ArgTypes...)&gt;&amp;,
        function&lt;R(ArgTypes...)&gt;&amp;);

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p>

    As with JP 41, these constraints are redundant given that function&lt;&gt; is 
    already constrained. So we recommend changing each occurence of &quot;MoveConstructible&quot; 
    to &quot;class&quot;. Note: this issue is also present in func.wrap.func.nullptr.<tr valign="top">
      <td>
        <p>UK<br>
        208

      <td>
        <p align="justify">20.6.17

      <td>
        <p align="justify">1

      <td>
        <p align="justify">Te

      <td>
        <p align="left">std::hash should
        be implemented for much more of the standard library. In
        particular for pair, tuple and all the standard containers.

        <p align="left"><br>

      <td>
        <p align="left">.

      <td>
        <p>

    Consensus is that this is an expansion of the scope of C++0X and so we 
    recommend no action.<tr valign="top">
      <td>
        <p>UK<br>
        209

      <td>
        <p align="justify">20.7

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Smart pointers cannot be used in
        constrained templates

      <td>
        <p align="left">Provide
        constraints for smart pointers

        <p align="left"><br>

        <p align="left"><br>

      <td>
        <p>

    We look forward to a paper on this topic. We recommend no action until a 
    paper is available. We understand that a paper is forthcoming.<tr valign="top">
      <td>
        <p>UK<br>
        213

      <td>
        <p align="justify">20.7.6

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">std::allocator
        should be constrained to simplify its use on constrained
        contexts. This library component models allocation from
        free store via the new operator so choose constraints to
        match. The Allocator concept allows for a wider variety of
        allocators that users may choose to supply if their
        allocation model does not require operator new, without
        impacting the requirements of this template.

        <p align="left"><br>

      <td>
        <p align="left">The primary allocator template should be
        constrained to require ObjectType&lt;T&gt; and
        FreeStoreAllocatable&lt;T&gt;. Further operations to be
        constrained as required.

      <td>
        <p>

    [default.allocator]

    Agree as stated. A future paper will address additional related issues.<tr valign="top">
      <td>
        <p>UK<br>
        214

      <td>
        <p align="justify">20.7.8

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">
        raw_storage_iterator needs constraining as an iterator
        adaptor to be safely used in constrained templates

        <p align="left"><br>

      <td>
        <p align="left">Constrain the raw_storage_iterator template

      <td>
        <p>

    We look forward to a paper on this topic. We recommend no action until a 
    paper is available.<tr valign="top">
      <td>
        <p>UK<br>
        210

      <td>
        <p align="justify">20.7.11

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Specialized algorithms for memory
        managenment need requirements to be easily usable in
        constrained templates

      <td>
        <p align="left">Provide
        constraints for all algorithms in 20.7.11

        <p align="left"><br>

        <p align="left"><br>

      <td>
        <p>

    We look forward to a paper on this topic. We recommend no action until a 
    paper is available.<tr>
      <td>
        <p>JP 44

      <td>
        <p align="left">20.7.13.6 [util.<br>
        smartptr.<br>
        shared.<br>
        atomic]<td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left">The
        1st parameter p and 2nd parameter v is now
        shared_ptr&lt;T&gt; *.

        <p align="left" style="margin-top: 0.04in">It
        should be shared_ptr&lt;T&gt;&amp;, or if these are
        shared_ptr&lt;T&gt;* then add the "p shall not be a null
        pointer" at the requires.

      <td>
        <p align="left" style="margin-top: 0.04in">
        Change shared_ptr&lt;T&gt;&amp; or add the "p shall not be
        a null pionter" at the requires.

      <td>
        <p align="left">Agree. All of the 
        functions need a requirement that p (or v) is a pointer to a valid 
        object.<br>

    </tr>

    <tr valign="top">
      <td>
        <p align="left">US 74.1

      <td>
        <p align="left">20.8

      <td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">Scoped
        allocators represent a poor trade-off for standardization,
        since (1) scoped-allocator--aware containers can be
        implemented outside the C++ standard library but used with
        its algorithms, (2) scoped allocators only benefit a tiny
        proportion of the C++ community (since few C++ programmers
        even use today&#8217;s allocators), and (3) all C++ users,
        especially the vast majority of the C++ community that
        won&#8217;t ever use scoped allocators are forced to cope
        with the interface complexity introduced by scoped
        allocators. In essence, the larger community will suffer to
        support a very small subset of the community who can
        already implement their own data structures outside of the
        standard library. Therefore, scoped allocators should be
        removed from the working paper.

        <p align="left">Some evidence of
        the complexity introduced by scoped allocators:

        <p align="left">20.3.3, 20.5:
        large increase in the number of pair and tuple constructors

        <p align="left">23: confusing
        &#8220;AllocatableElement&#8221; requirements throughout.

        <p align="left"><br>

      <td>
        <p align="left">Remove support
        for scoped allocators from the working paper. This includes
        at least the following changes:

        <p align="left"><br>

        <p align="left">Remove 20.8.3
        [allocator.element.concepts]

        <p align="left"><br>

        <p align="left">Remove 20.8.7
        [allocator.adaptor]

        <p align="left"><br>

        <p align="left">Remove 20.8.10
        [construct.element]

        <p align="left"><br>

        <p align="left">In Clause 23:
        replace requirements naming the AllocatableElement concept
        with requirements naming CopyConstructible,
        MoveConstructible, DefaultConstructible, or Constructible,
        as appropriate.

        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr>
      <td>
        <p>US 80

      <td>
        <p>20.8.2.1 [time.traits.<br>
        is_fp]<td>
        <p>Heading

      <td>
        <p>ed

      <td>
        <p>The section heading does not describe the contents.

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Change the
        heading &#8220;<span lang=
        "en-US">is_floating_point</span>&#8221; to
        &#8220;<span lang=
        "en-US">treat_as_floating_point</span>&#8221;. Optionally
        adjust the section&#8217;s label similarly.

        <p>

      <td>
        <p>

    Agree. The section name and the section label 
    ([time.traits.is_fp]) are wrong. Forward to project editor.</tr>

    <tr valign="top">
      <td>
        <p>US 74.2

      <td>
        <p>20.8.2.2 [allocator.<br>
        concepts]<td>
        <p>(a) syn-opsis (b) after &#182; 14

      <td>
        <p>te/ed

      <td>
        <p>A concept name is twice misspelled.

      <td>
        <p>Change &#8220;Hasconstructor&#8221; to
        &#8220;HasConstructor&#8221; (twice).

      <td>
        <p>

    Agree. Forward to project editor.<tr valign="top">
      <td>
        <p>US 75

      <td>
        <p>20.8.2.2

      <td>
        <p>

      <td>
        <p>te

      <td>
        <p>Allocator concepts are incomplete

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">See paper:
        http://www.halpernwightsoftware.com/WG21/n2810_allocator_defects.pdf

        <p>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>JP 43

      <td>
        <p align="left">20.8.3

    [allocator.<br>
        element.<br>
        concepts]<td>
        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left">
        Typo.

        <p align="left" style="margin-top: 0.04in">
        "alloc" should be "Alloc"

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        <br>

        <p align="left">
        auto concept UsesAllocator&lt;typename T, typename
        Alloc&gt; {

        <p align="left">
        requires Allocator&lt;alloc&gt;;

        <p align="left">
        typename allocator_type = T::allocator_type;

        <p align="left">
        &nbsp;

        <p align="left">
        should be

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">&nbsp;

        <p align="left">
        auto concept UsesAllocator&lt;typename T, typename
        Alloc&gt; {

        <p align="left">
        requires Allocator&lt;<u>Alloc</u>&gt;;

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">typename
        allocator_type = T::allocator_type;

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p>

    Agree. Forward to project editor.<tr valign="top">
      <td>
        <p>UK<br>
        215

      <td>
        <p align="justify">20.8.3.3

    [time.<br>
        duration.<br>
        arithmetic]

      <td>
        <p align="justify">6,8

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Extra pair of
        {}, presumably some formatting code gone awry :
        duration&amp; operator-{-}();

        <p align="left"><br>

      <td>
        <p align="left">Remove the {} or fix formatting

      <td>
        <p>

    Agree. Forward to project editor.<tr valign="top">
      <td>
        <p align="left">US 77

      <td>
        <p align="left">20.8.4

      <td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">
        Allocator-specific move and copy behavior for containers
        (N2525) complicates a little-used and already-complicated
        portion of the standard library (allocators), and breaks
        the conceptual model of move-constructor and
        move-assignment operations on standard containers being
        efficient operations. The extensions for allocator-specific
        move and copy behavior should be removed from the working
        paper.

        <p align="left">With the
        introduction of rvalue references, we are teaching
        programmers that moving from a standard container (e.g., a
        vector&lt;string&gt;) is an efficient, constant-time
        operation. The introduction of N2525 removed that
        guarantee; depending on the behavior of four different
        traits (20.8.4), the complexity of copy and move operations
        can be constant or linear time. This level of customization
        greatly increases the complexity of standard containers,
        and benefits only a tiny fraction of the C++ community.

        <p align="left"><br>

      <td>
        <p align="left">Remove 20.8.4.

        <p align="left"><br>

        <p align="left">Remove 20.8.5.

        <p align="left"><br>

        <p align="left">Remove all references to the facilities in
        20.8.4 and 20.8.5 from clause 23.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p align="left">US 78

      <td>
        <p align="left">20.8.12,<br>
        20.8.13.2 [unique.<br>
        ptr], [util.<br>
        smartptr.<br>
        shared]<td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">There is presently no way to
        convert directly from a <font size="2" style=
        "font-size: 11pt"><code>shared_ptr</code> to a
        <code>unique_ptr</code>.</font>

      <td>
        <p align="left">Add
        an interface that performs the conversion. See the
        attached, Issues with the C++ Standard" paper under Chapter
        20, "Conversion from <font size="2" style=
        "font-size: 11pt"><code>shared_ptr</code> to
        <code>unique_ptr".</code></font>

        <p align="left"><br>

      <td>
        <p align="left">We look forward to 
        a paper on this topic. We recommend no action until a paper is 
        available. We believe that the shared pointer must use the default deleter for the conversion to succeed.<br>

    <tr valign="top">
      <td>
        <p align="left">US 79

      <td>
        <p align="left">20.8.12.2.1 [unique.ptr.<br>
        single.ctor]<td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">
        [unique.ptr.single.ctor]/5 no longer requires for D not to
        be a pointer type. &nbsp;This restriction needs to be put
        back in. &nbsp;Otherwise we have a run time failure that
        could have been caught at compile time:

        <p align="left">
        <br>

        <p align="left">
        unique_ptr&lt;int, void(*)(void*)&gt;
        p(malloc(sizeof(int))); &nbsp;// should not compile

        <p align="left">
        <br>

        <p align="left">
        unique_ptr&lt;int, void(*)(void*)&gt;
        p(malloc(sizeof(int)), free); &nbsp;// ok

        <p align="left"><br>

      <td>
        <p align="left"><br>

      <td>
        <p align="left">Agree. The unique_ptr(pointer 
        p) <em>Requires</em> clause should be the same as the unique_ptr() <em>
        Requires</em> clause. Note that unique_ptr [unique.ptr] needs concepts.<br>

    <tr valign="top">
      <td>
        <p>JP 45

      <td>
        <p align="left">20.9 [time]<td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left">
        Rep, Period, Clock and Duration don't correspond to
        concept.

        <p align="left">
        template &lt;class Rep, class Period = ratio&lt;1&gt;&gt;
        class duration;

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">template
        &lt;class Clock, class Duration = typename
        Clock::duration&gt; class time_point;

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">
        Make concept for Rep, Period, Clock and Duration, and fix
        20.9 and wait_until and wait_for's template parameter at
        30.

      <td>
        <p align="left">We agree that this section needs concepts. We 
        look forward to a paper on this topic. We recommend no action until a 
        paper is available.<br>

    <tr valign="top">
      <td>
        <p align="left">US 81

      <td>
        <p align="left">20.9.3

      <td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">
        chrono::duration is missing the modulous operator for both
        member and non-member arithmetic. This operator is useful
        for finding the position of a duration within a bounded
        time frame. Having it be built in to duration is safer than
        requiring the client to extract and operate directly on the
        duration&#8217;s representation as the latter will not
        enforce the correct units of the operation.

        <p align="left">
        <br>

        <p align="left">Ex:

        <p align="left">
        <br>

        <p align="left">
        milliseconds ms(...);

        <p align="left">
        microseconds us(...);

        <p align="left">
        <br>

        <p align="left">ms
        % us; // microseconds

        <p align="left">us
        % ms; // microseconds

        <p align="left">ms
        % 5; // milliseconds

        <p align="left">5 %
        ms; // does not compile

        <p align="left"><br>

      <td>
        <p align="left">Add:

        <p align="left"><br>

        <p align="left">
        template &lt;class Rep, class Period = ratio&lt;1&gt;&gt;

        <p align="left">
        class duration {

        <p align="left">
        public:

        <p align="left">...

        <p align="left">duration&amp;
        operator%(const rep&amp;);

        <p align="left">duration&amp;
        operator%(const duration&amp;);

        <p align="left">..

        <p align="left">};

        <p align="left"><br>

        <p align="left">template
        &lt;class Rep1, class Period,

        <p align="left">class Rep2&gt;

        <p align="left">
        duration&lt;typename common_type&lt;

        <p align="left">Rep1,
        Rep2&gt;::type, Period&gt;

        <p align="left">operator%(const
        duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);

        <p align="left"><br>

        <p align="left">template
        &lt;class Rep1, class Period1,

        <p align="left">class Rep2,
        class Period2&gt;

        <p align="left">typename
        common_type&lt;duration&lt;Rep1, Period1&gt;,
        duration&lt;Rep2, Period2&gt;&gt;::type

        <p align="left">operator%(const
        duration&lt;Rep1, Period1&gt;&amp; lhs, const
        duration&lt;Rep2, Period2&gt;&amp; rhs);

        <p align="left"><br>

      <td>
        <p align="left">[time.duration] Agree except that there is a typo in the 
        proposed resolution. The member operators should be operator%=. This is 
        also LWG issue 934.<br>

    <tr valign="top">
      <td>
        <p>US 82

      <td>
        <p>20.9.5.3

      <td>
        <p>after &#182; 1

      <td>
        <p>ed

      <td>
        <p>The code synopsis has a minor alignment error.

      <td>
        <p>Align &#8220;rep&#8221; with the other symbols defined
        in this synopsis.

      <td>
        <p>

    [time.clock.hires] Agree. Forward to project editor.<tr valign="top">
      <td>
        <p>UK<br>
        216

      <td>
        <p align="justify">21

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">All the containers use concepts for their
        iterator usage, exect for basic_string. This needs fixing.

      <td>
        <p align="left">Use concepts for iterator template
        parameters throughout the chapter.

      <td>
        <p>

    NB comments to be handled by Dave Abrahams and Howard Hinnant with advice 
    from PJP: UK216 (which duplicates) JP46, JP48. JP46 supplies extensive 
    proposed wording; start there.<tr valign="top">
      <td>
        <p>JP 46

      <td>
        <p align="left">21.2, 21.3

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">The
        basic_string does not use concept.

      <td>
        <p align="left">The
        "class Alloc" is changed to "Allocator Alloc".

        <p align="left">The
        "class InputIterator" is changed to "InputIterator Iter".

        <p align="left">
        <br>

        <p align="left">//
        21.3, basic_string:

        <p align="left">
        template&lt;class charT, class traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        <u>Allocator</u> Alloc = allocator&lt;charT&gt; &gt;

        <p align="left">
        class basic_string;

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;

        <p align="left">
        operator+(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

        <p align="left">
        operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
        lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

        <p align="left">
        operator+(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

        <p align="left">
        operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
        lhs,

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;

        <p align="left">
        operator+(const charT* lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

        <p align="left">
        operator+(const charT* lhs,

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;

        <p align="left">
        operator+(charT lhs, const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

        <p align="left">
        operator+(charT lhs,
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;

        <p align="left">
        operator+(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const charT* rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

        <p align="left">
        operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
        lhs,

        <p align="left">
        const charT* rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;

        <p align="left">
        operator+(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,
        charT rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;

        <p align="left">
        operator+(basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;&amp;
        lhs, charT rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator==(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator==(const charT* lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator==(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const charT* rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator!=(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator!=(const charT* lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator!=(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const charT* rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&lt; (const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&lt; (const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const charT* rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&lt; (const charT* lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&gt; (const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&gt; (const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const charT* rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&gt; (const charT* lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&lt;=(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&lt;=(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const charT* rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&lt;=(const charT* lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&gt;=(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&gt;=(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; lhs,

        <p align="left">
        const charT* rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        bool operator&gt;=(const charT* lhs,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        rhs);

        <p align="left">
        &nbsp;

        <p align="left">//
        21.3.8.8: swap

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        void swap(basic_string&lt;charT,traits,Alloc&gt;&amp; lhs,

        <p align="left">
        basic_string&lt;charT,traits,Alloc&gt;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        void swap(basic_string&lt;charT,traits,Alloc&gt;&amp;&amp;
        lhs,

        <p align="left">
        basic_string&lt;charT,traits,Alloc&gt;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        void swap(basic_string&lt;charT,traits,Alloc&gt;&amp; lhs,

        <p align="left">
        basic_string&lt;charT,traits,Alloc&gt;&amp;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">//
        21.3.8.9: inserters and extractors

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_istream&lt;charT,traits&gt;&amp;

        <p align="left">
        operator&gt;&gt;(basic_istream&lt;charT,traits&gt;&amp;&amp;
        is,

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_ostream&lt;charT, traits&gt;&amp;

        <p align="left">
        operator&lt;&lt;(basic_ostream&lt;charT,
        traits&gt;&amp;&amp; os,

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        str);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_istream&lt;charT,traits&gt;&amp;

        <p align="left">
        getline(basic_istream&lt;charT,traits&gt;&amp;&amp; is,

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str,

        <p align="left">
        charT delim);

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc</u>&gt;

        <p align="left">
        basic_istream&lt;charT,traits&gt;&amp;

        <p align="left">
        getline(basic_istream&lt;charT,traits&gt;&amp;&amp; is,

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str);

        <p align="left">
        &nbsp;

        <p align="left">
        <br>

        <p align="left">//
        21.3 Class template basic_string

        <p align="left">
        namespace std {

        <p align="left">
        template&lt;class charT, class traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        <u>Allocator Alloc</u> = allocator&lt;charT&gt; &gt;

        <p align="left">
        class basic_string {

        <p align="left">
        public:

        <p align="left">//
        types:

        <p align="left">
        typedef traits traits_type;

        <p align="left">
        typedef typename traits::char_type value_type;

        <p align="left">
        typedef <u>Alloc</u> allocator_type;

        <p align="left">
        typedef typename <u>Alloc</u>::size_type size_type;

        <p align="left">
        typedef typename <u>Alloc</u>::difference_type
        difference_type;

        <p align="left">
        typedef typename <u>Alloc</u>::reference reference;

        <p align="left">
        typedef typename <u>Alloc</u>::const_reference
        const_reference;

        <p align="left">
        typedef typename <u>Alloc</u>::pointer pointer;

        <p align="left">
        typedef typename <u>Alloc</u>::const_pointer const_pointer;

        <p align="left">
        typedef implementation-defined iterator; // See 23.1

        <p align="left">
        typedef implementation-defined const_iterator; // See 23.1

        <p align="left">
        typedef std::reverse_iterator&lt;iterator&gt;
        reverse_iterator;

        <p align="left">
        typedef std::reverse_iterator&lt;const_iterator&gt;
        const_reverse_iterator;

        <p align="left">
        static const size_type npos = -1;

        <p align="left">
        &nbsp;

        <p align="left">//
        21.3.2 construct/copy/destroy:

        <p align="left">
        explicit basic_string(const <u>Alloc</u>&amp; a =
        <u>Alloc</u>());

        <p align="left">
        basic_string(const basic_string&amp; str);

        <p align="left">
        basic_string(basic_string&amp;&amp; str);

        <p align="left">
        basic_string(const basic_string&amp; str, size_type pos,
        size_type n = npos,

        <p align="left">
        const <u>Alloc</u>&amp; a = <u>Alloc</u>());

        <p align="left">
        basic_string(const charT* s,

        <p align="left">
        size_type n, const <u>Alloc</u>&amp; a = <u>Alloc</u>());

        <p align="left">
        basic_string(const charT* s, const <u>Alloc</u>&amp; a =
        <u>Alloc</u>());

        <p align="left">
        basic_string(size_type n, charT c, const <u>Alloc</u>&amp;
        a = <u>Alloc</u>());

        <p align="left">
        template&lt;<u>InputIterator</u> <u>Iter</u>&gt;

        <p align="left">
        basic_string(<u>Iter</u> begin, <u>Iter</u> end,

        <p align="left">
        const <u>Alloc</u>&amp; a = <u>Alloc</u>());

        <p align="left">
        basic_string(initializer_list&lt;charT&gt;, const
        <u>Alloc</u>&amp; = <u>Alloc</u>());

        <p align="left">
        basic_string(const basic_string&amp;, const
        <u>Alloc</u>&amp;);

        <p align="left">
        basic_string(basic_string&amp;&amp;, const
        <u>Alloc</u>&amp;);

        <p align="left">
        ~basic_string();

        <p align="left">
        basic_string&amp; operator=(const basic_string&amp; str);

        <p align="left">
        basic_string&amp; operator=(basic_string&amp;&amp; str);

        <p align="left">
        basic_string&amp; operator=(const charT* s);

        <p align="left">
        basic_string&amp; operator=(charT c);

        <p align="left">
        basic_string&amp; operator=(initializer_list&lt;charT&gt;);

        <p align="left">
        &nbsp;

        <p align="left">//
        21.3.3 iterators:

        <p align="left">...

        <p align="left">
        &nbsp;

        <p align="left">//
        21.3.4 capacity:

        <p align="left">...

        <p align="left">
        &nbsp;

        <p align="left">//
        21.3.5 element access:

        <p align="left">...

        <p align="left">
        &nbsp;

        <p align="left">//
        21.3.6 modifiers:

        <p align="left">...

        <p align="left">
        &nbsp;

        <p align="left">
        basic_string&amp; append(const basic_string&amp; str);

        <p align="left">
        basic_string&amp; append(const basic_string&amp; str,
        size_type pos,

        <p align="left">
        size_type n);

        <p align="left">
        basic_string&amp; append(const charT* s, size_type n);

        <p align="left">
        basic_string&amp; append(const charT* s);

        <p align="left">
        basic_string&amp; append(size_type n, charT c);

        <p align="left">
        template&lt;<u>InputIterator</u> <u>Iter</u>&gt;

        <p align="left">
        basic_string&amp; append(<u>Iter</u> first, <u>Iter</u>
        last);

        <p align="left">
        basic_string&amp; append(initializer_list&lt;charT&gt;);

        <p align="left">
        void push_back(charT c);

        <p align="left">
        &nbsp;

        <p align="left">
        basic_string&amp; assign(const basic_string&amp; str);

        <p align="left">
        basic_string&amp; assign(basic_string&amp;&amp; str);

        <p align="left">
        basic_string&amp; assign(const basic_string&amp; str,
        size_type pos,

        <p align="left">
        size_type n);

        <p align="left">
        basic_string&amp; assign(const charT* s, size_type n);

        <p align="left">
        basic_string&amp; assign(const charT* s);

        <p align="left">
        basic_string&amp; assign(size_type n, charT c);

        <p align="left">
        template&lt;<u>InputIterator</u> <u>Iter</u>&gt;

        <p align="left">
        basic_string&amp; assign(<u>Iter</u> first, <u>Iter</u>
        last);

        <p align="left">
        basic_string&amp; assign(initializer_list&lt;charT&gt;);

        <p align="left">
        &nbsp;

        <p align="left">
        basic_string&amp; insert(size_type pos1, const
        basic_string&amp; str);

        <p align="left">
        basic_string&amp; insert(size_type pos1, const
        basic_string&amp; str,

        <p align="left">
        size_type pos2, size_type n);

        <p align="left">
        basic_string&amp; insert(size_type pos, const charT* s,
        size_type n);

        <p align="left">
        basic_string&amp; insert(size_type pos, const charT* s);

        <p align="left">
        basic_string&amp; insert(size_type pos, size_type n, charT
        c);

        <p align="left">
        iterator insert(const_iterator p, charT c);

        <p align="left">
        void insert(const_iterator p, size_type n, charT c);

        <p align="left">
        template&lt;<u>InputIterator</u> <u>Iter</u>&gt;

        <p align="left">
        void insert(const_iterator p, <u>Iter</u> first,
        <u>Iter</u> last);

        <p align="left">
        void insert(const_iterator p,
        initializer_list&lt;charT&gt;);

        <p align="left">
        &nbsp;

        <p align="left">...

        <p align="left">
        basic_string&amp; replace(size_type pos1, size_type n1,

        <p align="left">
        const basic_string&amp; str);

        <p align="left">
        basic_string&amp; replace(size_type pos1, size_type n1,

        <p align="left">
        const basic_string&amp; str,

        <p align="left">
        size_type pos2, size_type n2);

        <p align="left">
        basic_string&amp; replace(size_type pos, size_type n1,
        const charT* s,

        <p align="left">
        size_type n2);

        <p align="left">
        basic_string&amp; replace(size_type pos, size_type n1,
        const charT* s);

        <p align="left">
        basic_string&amp; replace(size_type pos, size_type n1,
        size_type n2,

        <p align="left">
        charT c);

        <p align="left">
        basic_string&amp; replace(iterator i1, iterator i2,

        <p align="left">
        const basic_string&amp; str);

        <p align="left">
        basic_string&amp; replace(iterator i1, iterator i2, const
        charT* s,

        <p align="left">
        size_type n);

        <p align="left">
        basic_string&amp; replace(iterator i1, iterator i2, const
        charT* s);

        <p align="left">
        basic_string&amp; replace(iterator i1, iterator i2,

        <p align="left">
        size_type n, charT c);

        <p align="left">
        template&lt;<u>InputIterator</u> <u>Iter</u>&gt;

        <p align="left">
        basic_string&amp; replace(iterator i1, iterator i2,

        <p align="left">
        <u>Iter</u> j1, <u>Iter</u> j2);

        <p align="left">
        basic_string&amp; replace(iterator, iterator,
        initializer_list&lt;charT&gt;);

        <p align="left">
        &nbsp;

        <p align="left">...

        <p align="left">
        &nbsp;

        <p align="left">//
        21.3.7 string operations:

        <p align="left">...

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator</u>
        <u>Alloc&gt;</u>

        <p align="left">
        struct constructible_with_allocator_suffix&lt;

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">
        basic_string&lt;charT, traits, <u>Alloc</u>&gt; &gt; :
        true_type { };

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p>

    See UK 216<tr valign="top">
      <td>
        <p>JP 47

      <td>
        <p align="left">21.3

      <td>
        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left">
        Typo. Missing &#8221;&gt;&#8221;

        <p align="left">
        template &lt;class charT, class traits, Allocator Alloc

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left">
        <br>

        <p align="left">
        template &lt;class charT, class traits, Allocator Alloc&gt;

        <p align="left"><br>

      <td>
        <p align="left" style="margin-top: 0.04in">
        Correct typo.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>JP 48

      <td>
        <p align="left">21.3

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left">
        char_traits does not use concept.

        <p align="left">For
        example, create CharTraits concept and change as follows:

        <p align="left">
        <br>

        <p align="left">
        template&lt;class charT, <u>CharTraits</u> traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        class Allocator = allocator&lt;charT&gt; &gt;

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">class
        basic_string {

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        a concept for char_traits.

      <td>
        <p>

    See UK 216<tr valign="top">
      <td>
        <p>UK<br>
        217

      <td>
        <p align="justify">21.3

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">basic_string refers to
        constructible_with_allocator_suffix, which I thought was
        removed?

      <td>
        <p align="left">Remove the
        lines: template &lt;class charT, class traits, class Alloc
        struct constructible_with_allocator_suffix&lt;
        basic_string&lt;charT, traits, Alloc&gt; &gt; : true_type {
        };

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        218

      <td>
        <p align="justify">21.3.1

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The identity
        "&amp;*(s.begin() + n) == &amp;*s.begin() + n" relies on
        operator&amp; doing the "right thing", which (AFAICS) there
        is no requirement for. See my comment under clauses
        "23.2.1, 23.2.6" (p1 in both cases) - this is the same
        issue, but I've created a separate comment for basic_string
        because it is in a different chapter.

        <p align="left"><br>

      <td>
        <p align="left">See my recommendations for "23.2.1,
        23.2.6".

      <td>
        <p>

    NAD, we think. basic_string elements have to be POD and PODs may not have 
    overloaded operator&amp;. Need to check whether this is true in light of relaxed 
    POD constraints.<tr valign="top">
      <td>
        <p>UK<br>
        219

      <td>
        <p align="justify">21.3.6.6<br>
        [string.<br>
        replace]

      <td>
        <p align="justify">11

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Effects refers to "whose first begin() - i1
        elements" However i1 is greater than begin()...

      <td>
        <p align="left">Effects refers to "whose first i1 - begin()
        elements"

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        220

      <td>
        <p align="justify">21.3.8.9

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The
        operator&lt;&lt; for basic_string takes the output stream
        by r-value reference. This is different from the same
        operator for error_code (19.4.2.6), bitset (20.2.6.3),
        shared_ptr (20.7.13.2.8), complex (26.3.6) and sub_match
        (28.4)

        <p align="left"><br>

      <td>
        <p align="left">Use the same reference type for the all the
        library types. This should be the r-value reference. There
        are other places in the standard where TR1, and new
        classes, did not receive an 'R-value' update.

      <td>
        <p>

    We did it differently for basic_string because otherwise rvalue strreaming 
    was producing confusing results with strings, but this difference will be 
    fixed by N2831 if it's accepted.<tr valign="top">
      <td>
        <p>FR 33

      <td>
        <p>22.1.1<br>
&nbsp;[locale]

      <td>
        <p>3

      <td>
        <p>ed

      <td>
        <p>ios_base::iostate err = 0;

        <p>

        <p>iostate is a bitmask type and
        so could be an enumeration. Probably using

        <p>goodbit is the solution.

      <td>
        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>JP 49

      <td>
        <p align="left">22.1.3.<br>
        2.2

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left">
        codecvt does not use concept. For example, create
        CodeConvert concept and change as follows.

        <p align="left" style="margin-top: 0.04in">
        template&lt;<u>CodeConvert</u> Codecvt, class Elem =
        wchar_t&gt; class wstring_convert {

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        a concept for codecvt.

      <td>
        <p>

    to be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plaugher<tr valign="top">
      <td>
        <p>JP 50

      <td>
        <p align="left">22.1.3.<br>
        2.2

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        custom allocator parameter to wstring_convert, since we
        cannot allocate memory for strings from a custom allocator.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        template&lt;class Codecvt, class Elem = wchar_t&gt; class
        wstring_convert {

        <p align="left">
        public:

        <p align="left">
        typedef std::basic_string&lt;char&gt; byte_string;

        <p align="left">
        typedef std::basic_string&lt;Elem&gt; wide_string;

        <p align="left">
        &nbsp;

        <p align="left" style=
        "text-indent: 0.06in; margin-bottom: 0in">should be

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class Codecvt, class Elem = wchar_t<u>,</u>

        <p align="left">
        <u>Allocator WideAllocator = allocator&lt;Elem&gt;,</u>

        <p align="left">
        <u>Allocator ByteAllocator = allocator&lt;char&gt;</u>&gt;

        <p align="left">
        class wstring_convert {

        <p align="left">
        public:

        <p align="left">
        typedef std::basic_string&lt;char,
        <u>char_traits&lt;char&gt;, ByteAllocator</u>&gt;
        byte_string;

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">typedef
        std::basic_string&lt;Elem, <u>char_traits&lt;Elem&gt;,
        WideAllocator</u>&gt; wide_string;

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p>

    to be handled by PJ Plaugher<tr valign="top">
      <td>
        <p>FI 4

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">22.2.1.4.1

        <p>22.2.1.4.2

      <td>
        <p>

      <td>
        <p>ed

      <td>
        <p><tt>to_end and to_limit are both used. Only one is
        needed.</tt>

      <td>
        <p>Change to_limit to to_end.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>FI 5

      <td>
        <p><tt>22.2.<br>
        1.4.2</tt>

      <td>
        <p>#3

      <td>
        <p>ed

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in"><tt>[ Note: As
        a result of operations on state, it can return ok or
        partial and set next == from and to_next != to. &#8212;end
        note ]</tt><br>
        <br>
        <br>

        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in"><tt>"next"
        should be "from_next."</tt>

        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in"><tt>Also, the
        sentence applies to all the examples, including do_in and
        do_out.</tt>

        <p><tt>Reasoning: When reading one element of multibyte
        source data such as UTF-8, it is possible that from_next is
        incremented, to_next is unaltered, state is altered and
        return value is partial.<br>
        When reading one element of wide character data, the output
        can be several multibyte characters, so it is possible that
        from_next is unaltered, to_next is advanced, state is
        altered and return value is partial.</tt>

      <td>
        <p><tt>[ Note: As a result of operations on state, do_in
        and do_out can return</tt><br>
        <tt>ok or partial and set from_next == from and/or to_next
        != to. &#8212;end</tt><br>
        <tt>note ]</tt>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>FI 6

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">22.2.1.5

        <p>See also<br>
&nbsp;22.2.1.4<br>
&nbsp;(1,2,3)

      <td>
        <p>

      <td>
        <p>te

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">
        <tt>codecvt_byname is only specified to work with locale
        names. There is no built-in means to find a codecvt with a
        character set's name. A locale and a character set are not
        the same. If the user has data which is encoded in a
        certain character set and she wants to create a codecvt
        which can convert from that character set to another one,
        she must iterate through locales to find one, or use
        external means (iconv, ICU's uconv). Specifying a locale
        with the character set is not a suitable solution, since
        there is no built-in mapping from character sets to
        locales. It is only possible to inquire the character set
        once the locale is known.</tt>

        <p>

      <td>
        <p><tt>There should be a built-in means to find a codecvt
        with a pair of character set names.</tt>

      <td>
        <p>

    Martin Sebor interested in solving this problem (also POSIX group), but 
    addressing it controversial because it's probably too late in the process 
    for what looks like a new feature.<tr valign="top">
      <td>
        <p>FI 7

      <td>
        <p>22.2.1.4

      <td>
        <p>1,2,3

      <td>
        <p>ed

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">The word
        "codeset" is used, whereas the word "character set" is used
        elsewhere in the text. The words are intended to convey the
        same concept, so only one should be used (or always both
        together).

        <p>

      <td>
        <p>Change "codeset" to "character set."

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>JP 51

      <td>
        <p align="left">22.2.5.1.1

      <td>
        <p align="left">7<sup>th</sup> <font size="2"
        style="font-size: 11pt">para, 1<sup>st</sup>
        line</font>

      <td>
        <p>ed

      <td>
        <p align="left">A
        parameter `end&#8217; should be `fmtend&#8217;.<br>
        get() function had two `end&#8217; parameters at N2321.

        <p align="left">
        iter_type get (iter_type s, iter_type end, ios_base&amp; f,
        ios_base::iostate&amp; err, tm* t, const char_type* fmt,
        const char_type *end) const;

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">The function
        prototype of get() has been corrected at N2800, but a
        Requires statement still refers `end&#8217; parameter.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        Requires: [fmt,end) shall be a valid range.

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in"><br>
        <br>

        <p align="left" style="margin-top: 0.04in">
        Requires: [fmt,fmtend) shall be a valid range.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>JP 52

      <td>
        <p align="left">22.2.5.1,<br>
        22.2.5.2,<br>
        22.2.6.1

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        InputIterator does not use concept.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        <br>

        <p align="left">
        22.2.5.1

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, class InputIterator =
        istreambuf_iterator&lt;charT&gt; &gt;

        <p align="left">
        class time_get : public locale::facet, public time_base {

        <p align="left">
        public:

        <p align="left">
        typedef charT char_type;

        <p align="left">
        typedef InputIterator iter_type;

        <p align="left">
        &nbsp;

        <p align="left">
        should be

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, <u>InputIterator InputIter</u> =
        istreambuf_iterator&lt;charT&gt; &gt;

        <p align="left">
        class time_get : public locale::facet, public time_base {

        <p align="left">
        public:

        <p align="left">
        typedef charT char_type;

        <p align="left">
        typedef <u>InputIter</u> iter_type;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;

        <p align="left">
        22.2.5.2

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, class InputIterator =
        istreambuf_iterator&lt;charT&gt; &gt;

        <p align="left">
        class time_get_byname : public time_get&lt;charT,
        InputIterator&gt; {

        <p align="left">
        public:

        <p align="left">
        typedef time_base::dateorder dateorder;

        <p align="left">
        typedef InputIterator iter_type;

        <p align="left">
        &nbsp;

        <p align="left">
        should be

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, <u>InputIterator InputIter</u> =
        istreambuf_iterator&lt;charT&gt; &gt;

        <p align="left">
        class time_get_byname : public time_get&lt;charT,
        InputIter&gt; {

        <p align="left">
        public:

        <p align="left">
        typedef time_base::dateorder dateorder;

        <p align="left">
        typedef <u>InputIter</u> iter_type;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;

        <p align="left">
        22.2.6.1

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT,

        <p align="left">
        class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;

        <p align="left">
        class money_get : public locale::facet {

        <p align="left">
        public:

        <p align="left">
        typedef charT char_type;

        <p align="left">
        typedef InputIterator iter_type;

        <p align="left">
        &nbsp;

        <p align="left">
        should be

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT,

        <p align="left">
        <u>InputIterator InputIter</u> =
        istreambuf_iterator&lt;charT&gt; &gt;

        <p align="left">
        class money_get : public locale::facet {

        <p align="left">
        public:

        <p align="left">
        typedef charT char_type;

        <p align="left">
        typedef <u>InputIter</u> iter_type;

        <p align="left"><br>

      <td>
        <p>

    to be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plaugher<tr valign="top">
      <td>
        <p>JP 53

      <td>
        <p align="left">22.2.5.3 ,<br>
        22.2.5.4

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        OutputIterator does not use concept.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        &nbsp;

        <p align="left">
        22.2.5.3

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, class OutputIterator =
        ostreambuf_iterator&lt;charT&gt; &gt;

        <p align="left">
        class time_put : public locale::facet {

        <p align="left">
        public:

        <p align="left">
        typedef charT char_type;

        <p align="left">
        typedef OutputIterator iter_type;

        <p align="left">
        &nbsp;

        <p align="left">
        <span lang="zxx">&#12288;</span>should be

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, <u>OutputIterator OutputIter</u>
        = ostreambuf_iterator&lt;charT&gt; &gt;

        <p align="left">
        class time_put : public locale::facet {

        <p align="left">
        public:

        <p align="left">
        typedef charT char_type;

        <p align="left">
        typedef <u>OutputIter</u> iter_type;

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;

        <p align="left">
        22.2.5.4

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, class OutputIterator =
        ostreambuf_iterator&lt;charT&gt; &gt;

        <p align="left">
        class time_put_byname : public time_put&lt;charT,
        OutputIterator&gt;

        <p align="left">{

        <p align="left">
        public:

        <p align="left">
        typedef charT char_type;

        <p align="left">
        typedef OutputIterator iter_type;

        <p align="left">
        &nbsp;

        <p align="left">
        should be

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, <u>OutputIterator OutputIter</u>
        = ostreambuf_iterator&lt;charT&gt; &gt;

        <p align="left">
        class time_put_byname : public time_put&lt;charT,
        OutputIter&gt;

        <p align="left">{

        <p align="left">
        public:

        <p align="left">
        typedef charT char_type;

        <p align="left">typedef <u>OutputIter</u>
        iter_type;

      <td>
        <p>

    to be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plaugher<tr valign="top">
      <td>
        <p>JP 54

      <td>
        <p align="left">23

      <td>
        <p align="left">
        2<sup>nd</sup> <font size="2" style=
        "font-size: 11pt">para, Table 79</font>

        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">
        There is not &lt;forward_list&gt; in Table 79.

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        &lt;forward_list&gt; between &lt;deque&gt; and
        &lt;list&gt;.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        221

      <td>
        <p align="justify">23

      <td>
        <p align="justify">Table 79

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The table is missing the new
        &lt;forward_list&gt; header.

      <td>
        <p align="left">Add
        &lt;forward_list&gt; to the table for sequence containers.
        Alternative (technical) solution might be to merge
        &lt;forward_list&gt; into &lt;list&gt;.

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        222

      <td>
        <p align="justify">23

    [container.<br>
        require-ments]<td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">It is not clear
        what purpose the Requirement tables serve in the Containers
        clause. Are they the definition of a library Container? Or
        simply a conventient shorthand to factor common semantics
        into a single place, simplifying the description of each
        subsequent container? This becomes an issue for
        'containers' like array, which does not meet the
        default-construct-to-empty requirement, or forward_list
        which does not support the size operation. Are these
        components no longer containers? Does that mean the
        remaining requirements don't apply? Or are these
        contradictions that need fixing, despite being a clear
        design decision?

        <p align="left"><br>

      <td>
        <p align="left">Clarify all the tables in 23.1 are there as
        a convenience for documentation, rather than a strict set
        of requirements. Containers should be allowed to relax
        specific requirements if they call attention to them in
        their documentation. The introductory text for array should
        be expanded to mention a default constructed array is not
        empty, and forward_list introduction should mention it does
        not provide the required size operation as it cannot be
        implemented efficiently.

      <td>
        <p>

    Agree in principle. We suggest proposed wording:<tr valign="top">
      <td>
        <p>JP 55

      <td>
        <p align="left">23.1.1

      <td>
        <p align="left">
        3<sup>rd</sup> <font size="2" style=
        "font-size: 11pt">para, 4<sup>th</sup> line</font>

        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">It
        seems that &#8220;the MinimalAllocator concep&#8221; is the
        typo of &#8220;the MinimalAllocator concept&#8221;.

      <td>
        <p align="left" style="margin-top: 0.04in">
        Change to &#8230; models the MinimalAllocator
        concep<font color="#339966">t</font><font size="2" style=
        "font-size: 11pt">.</font>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        223

      <td>
        <p align="justify">23.1.1

    [container.<br>
        require-ments.<br>
        general]<td>
        <p align="justify">3

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The library does
        not define the MinimalAllocator or ScopedAllocator
        concepts, these were part of an earlier Allocators proposal
        that was rejected.

        <p align="left"><br>

      <td>
        <p align="left">Remove the references to MinimalAllocator
        and ScopedAllocator, or add definitions for these concepts
        to clause 20.7.

      <td>
        <p>

    Agree. Proposed wording will be presented 
    in N2829 or D2840.<tr valign="top">
      <td>
        <p>UK<br>
        224

      <td>
        <p align="justify">23.1.1<br>

    [container.<br>
        require-ments.<br>
        general]<td>
        <p align="justify">8

      <td>
        <p align="justify">Te

      <td>
        <p align="left">This paragraph implicitly requires all
        containers in clause 23 to support allocators, which
        std::array does not.

      <td>
        <p align="left">Add an 'unless
        otherwise specified' rider somewhere in p8, or move the
        whole array container from clause 23 [containers] to clause
        20 [utilies] to accompany bitset, pair and tuple.

        <p align="left"><br>

      <td>
        <p>

    Agree except with moving array to clause 
    20. Proposed wording will be presented in D2840.<tr valign="top">
      <td>
        <p>UK<br>
        225

      <td>
        <p align="justify">23.1.1

      <td>
        <p align="justify">Table 81

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Inconsistent
        words used to say the same thing. Table 80 describes
        iterator/const_iterator typedef as returning an "iterator
        type whose value type is T". Table 81 expresses the same
        idea as an "iterator type pointing to T". Express identical
        ideas with the same words to avoid accidentally introducing
        subtlety and confusion

        <p align="left"><br>

      <td>
        <p align="left">Change return types for
        X::(const)_reverse_iterator to say "iterator type whose
        value type is (const) T".

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        226

      <td>
        <p align="justify">23.1.1

    [container.<br>
        require-ments.<br>
        general]<td>
        <p align="justify">10

      <td>
        <p align="justify">Te

      <td>
        <p align="left">&lt;array&gt;
        must be added to this list. In particular it doesn't
        satisfy: - no swap() function invalidates any references,
        pointers, or iterators referring to the elements of the
        containers being swapped. and probably doesn't satisfy:
        &#8212; no swap() function throws an exception.

        <p align="left"><br>

      <td>
        <p align="left">If &lt;array&gt; remains a container, this
        will have to also reference array, which will then have to
        say which of these points it satisfies.

      <td>
        <p>

    Agree. The proposed resolution is 
    incomplete. Further work required.<tr valign="top">
      <td>
        <p>UK<br>
        227

      <td>
        <p align="justify">23.1.1

      <td>
        <p align="justify">Table 80

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The post-condition for a = rv uses the word
        &#8220;construction&#8221; when it means
        &#8220;assignment&#8221;

      <td>
        <p align="left">Replace the word
        &#8220;construction&#8221; with the word
        &#8220;assignment&#8221;

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        228

      <td>
        <p align="justify">23.1.1

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Line 4 contains
        a spelling mistake in the fragment "MinimalAllocator
        concep."

        <p align="left"><br>

      <td>
        <p align="left">Replace "concep" with "concept"

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        229

      <td>
        <p align="justify">23.1.1

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The fragment "A container may directly call
        constructors" is not technically correct as constructors
        are not callable.

      <td>
        <p align="left">Replace "A
        container may directly call constructors and destructors
        for its stored objects" with something similar to "A
        container may directly construct its stored objects and
        call destructors for its stored objects"

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        230

      <td>
        <p align="justify">23.1.2

    [container.<br>
        require-ments.<br>
        dataraces]<td>
        <p align="justify">1

      <td>
        <p align="justify">Te

      <td>
        <p align="left">
        &#8220;implementations shall consider the following
        functions to be const&#8221; - what does this mean? I don't
        understand what it means by implementations considering the
        functions to be const &#8211; surely they are either
        declared const or not?

        <p align="left"><br>

      <td>
        <p align="left">Clarify what is meant and what requirements
        an implementation must satisfy.

      <td>
        <p>

    After considerable discussion and 
    consideration, we do not feel this is a defect given the reference to [res.on.data.races].<tr valign="top">
      <td>
        <p>JP 56

      <td>
        <p align="left">23.1.3

      <td>
        <p align="left">12<sup>th</sup> <font size="2"
        style="font-size: 11pt">para, Table 84</font>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">
        `array&#8217; is unstated in Table 84 - Optional sequence
        container operations.

      <td>
        <p align="left">Add
        `array&#8217; to Container field for the following
        Expression.

        <p align="left" style=
        "text-indent: 0.15in; margin-bottom: 0in">a.front()

        <p align="left" style=
        "text-indent: 0.15in; margin-bottom: 0in">a.back()

        <p align="left" style=
        "text-indent: 0.15in; margin-bottom: 0in">a[n]

        <p align="left" style=
        "text-indent: 0.15in; margin-top: 0.04in">a.at(n)

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        231

      <td>
        <p align="justify">23.1.3 [sequence.<br>
        reqmts]<td>
        <p align="justify">9-11

      <td>
        <p align="justify">Te

      <td>
        <p align="left">These paragraphs
        are redundant now that Concepts define what it means to be
        an Iterator and guide overload resolution accordingly.

        <p align="left"><br>

      <td>
        <p align="left">Strike 23.1.3p9-11. Make sure
        std::basic_string has constraints similar to std::vector to
        meet this old guarantee.

      <td>
        <p>

    Agree with issue and change to [sequence.reqmts]. The changes required to 
    [strings] will be part of the general concept support for that clause.<tr valign="top">
      <td>
        <p>UK<br>
        232

      <td>
        <p align="justify">23.1.3&nbsp; [sequence.<br>
        reqmts]<td>
        <p align="justify">Table 84

      <td>
        <p align="justify">Te

      <td>
        <p align="left">match_results
        may follow the requirements but is not listed a general
        purpose library container.

        <p align="left"><br>

      <td>
        <p align="left">Remove reference to match_results against
        a[n] operation

      <td>
        <p>

    Agree. <code>operator[]</code> is defined elsewhere.<tr valign="top">
      <td>
        <p>UK<br>
        233

      <td>
        <p align="justify">23.1.3&nbsp; [sequence.<br>
        reqmts]<td>
        <p align="justify">Table 84

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Add references to the new containers.

      <td>
        <p align="left">Add reference to
        array to the rows for: a.front(), a. back(), a[n] a.at(n).
        Add reference to forward_list to the rows for: a.front(),
        a.emplace_front(args), a.push_front(t), a.push_front(rv),
        a.pop_front(). Add reference to basic_string to the row
        for: a.at(n).

        <p align="left"><br>

      <td>
        <p>

    Agree.<tr valign="top">
      <td>
        <p>UK<br>
        234

      <td>
        <p align="justify">23.1.3&nbsp; [sequence.<br>
        reqmts]<td>
        <p align="justify">Table 84

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Ther reference
        to iterator in semantics for back should also allow for
        const_iterator when called on a const-qualified container.
        This would be ugly to specify in the 03 standard, but is
        quite easy with the addition of auto in this new standard.

        <p align="left"><br>

      <td>
        <p align="left">Replace iterator with auto in semantics for
        back: { auto tmp = a.end(); --tmp; return *tmp; }

      <td>
        <p>

    Agree.<tr valign="top">
      <td>
        <p>UK<br>
        235

      <td>
        <p align="justify">23.1.3

      <td>
        <p align="justify">1

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">&#8220;The library provides three basic
        kinds of sequence containers: vector, list, and
        deque&#8221; - text appears to be out of date re addition
        of array and forward_list

      <td>
        <p align="left">Change the text
        to read: &#8220;The library provides five basic kinds of
        sequence containers: array, deque, forward_list, list and
        vector&#8221;.

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        236

      <td>
        <p align="justify">23.1.3

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">[ I've moved (1)
        into a separate comment because I believe it is editorial
        in the simple sense, whereas (2) and (3) are not so
        straight forward ] (2) &#8220;vector is the type of
        sequence container that should be used by default&#8221; --
        As I understand it vector was considered first port of call
        because the things it has in common with the native array
        make programmers (especially those new to the container
        library) feel like they are on familiar territory. However,
        we now have the array container, so I think this should be
        recommended as the first port of call. (3) This paragraph
        is actually giving guidance on the use of the containers
        and should not be normative text

        <p align="left"><br>

      <td>
        <p align="left">Remove this paragraph

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        237

      <td>
        <p align="justify">23.1.3

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">vector, list, and deque offer the
        programmer different complexity trade-offs and should be
        used accordingly - this ignores array and forward_list

      <td>
        <p align="left">Modify the text
        to read: "array, deque, forward_list, list and vector offer
        the programmer different complexity trade-offs and should
        be used accordingly"

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        238

      <td>
        <p align="justify">23.1.4 [assoc-iative.<br>
        reqmts]<td>
        <p align="justify">6

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Leaving it
        unspecified whether or not iterator and const_iterator are
        the same type is dangerous, as user code may or may not
        violate the One Definition Rule by providing overloads for
        both types. It is probably too late to specify a single
        behaviour, but implementors should document what to expect.
        Observing that problems can be avoided by users restricting
        themselves to using const_iterator, add a note to that
        effect.

        <p align="left"><br>

      <td>
        <p align="left">Change 'unspecified' to 'implementation
        defined'. Add "[Note: As itererator and const_iterator have
        identical semantics in this case, and iterator is
        convertible to const_iterator, users can avoid violating
        the One Definition Rule by always using const_iterator in
        their function parameter lists -- end note]

      <td>
        <p>

    Agree with issue. Agree with adding the note but not with changing the 
    normative text. We believe the note provides sufficient guidance.<tr valign="top">
      <td>
        <p>UK<br>
        239

      <td>
        <p align="justify">23.1.4&nbsp; [assoc-iative.<br>
        reqmts]<td>
        <p align="justify">85

      <td>
        <p align="justify">Te

      <td>
        <p align="left">It is not possible to take a move-only key
        out of an unordered container, such as (multi)set or
        (multi)map, or the new hashed containers.

      <td>
        <p align="left">Add below
        a.erase(q), a.extract(q), with the following notation:
        a.extract(q), Return type pair&lt;key, iterator&gt;
        Extracts the element pointed to by q and erases it from the
        set. Returns a pair containing the value pointed to by q
        and an iterator pointing to the element immediately
        following q prior to the element being erased. If no such
        element exists,returns a.end().

        <p align="left"><br>

      <td>
        <p>

    We look forward to a paper on this topic. We recommend no action until a 
    paper is available. The paper would need to address exception safety.<tr valign="top">
      <td>
        <p>UK<br>
        240

      <td>
        <p align="justify">23.1.6.1 <br>
        [container.<br>
        concepts.<br>
        free]<td>
        <p align="justify">12

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The axiom
        EmplacePushEquivalence should be asserting the stronger
        contract that emplace and insert return the same iterator
        value, not just iterators that dereference to the same
        value. This is a similar statement that is easier to
        express and should be equivalent - the idea that insert and
        emplace might return iterator values that do not compare
        equal but point to the same element should fail somewhere
        in the iterator concepts. Also, this axiom should be
        renamed to reflect its connection with insert, rather than
        push_front/push_back,

        <p align="left"><br>

      <td>
        <p align="left">Remove the * to deference the returned
        iterator either side of the == in the
        EmplacePushEquivalence axiom, rename the axiom
        EmplacementInsertionEquivalence : requires
        InsertionContainer&lt;C&gt; &amp;&amp;
        Constructible&lt;value_type, Args...&gt; axiom
        EmplacementInsertionEquivalence(C c, const_iterator
        position, Args... args) { emplace(c, position, args...) ==
        insert(c, position, value_type(args...)); }

      <td>
        <p>

    We look forward to a paper on this topic. We recommend no action until a 
    paper is available. We suspect that there are other similar issues in this 
    sub-clause (9, 10).<tr valign="top">
      <td>
        <p>JP 57

      <td>
        <p align="left">23.1.6.3

      <td>
        <p align="left">
        1<sup>st</sup> <font size="2" style=
        "font-size: 11pt">para, 4<sup>th</sup> line</font>

        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left">
        Typo, duplicated "to"

        <p align="left" style="margin-top: 0.04in">
        "<u>to to</u> model insertion container concepts."

      <td>
        <p align="left" style="margin-top: 0.04in">
        Remove one.

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        241

      <td>
        <p align="justify">23.2.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">std::array does
        not have an allocator, so need to document an exception to
        the requirements of 23.1.1p3

        <p align="left"><br>

      <td>
        <p align="left">add exception to 23.1.1p3

      <td>
        <p>

    Duplicate of UK 224.<tr valign="top">
      <td>
        <p>UK<br>
        242

      <td>
        <p align="justify">23.2.1

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">std:: qualification no longer needed for
        reverse_iterator.

      <td>
        <p align="left">remove std::
        qualification from std::reverse_iterator&lt;iterator&gt;
        and std::reverse_iterator&lt;const_iterator&gt;

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>UK<br>
        243

      <td>
        <p align="justify">23.2.1 <br>
        [array]<td>
        <p align="justify">3

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Most containers,
        and types in general have 3 swaps: swap(T&amp;, T&amp;)
        swap(T&amp;&amp;, T&amp;) swap(T&amp;, T&amp;&amp;) But
        array only has swap(T&amp;, T&amp;).

        <p align="left"><br>

      <td>
        <p align="left">add the other two swaps.

      <td>
        <p>

    Agree. The proposed wording is forthcoming from Martin. We feel that these 
    overloads of swap are more important for array than other containers because 
    swap is not O(1) for array.<tr valign="top">
      <td>
        <p>UK<br>
        244

      <td>
        <p align="justify">23.2.1,<br>
&nbsp;23.2.6<br>
        [array], [vector]

      <td>
        <p align="justify">1

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The validity of
        the expression &amp;a[n] == &amp;a[0] + n is contingent on
        operator&amp; doing the &#8220;right thing&#8221; (as
        captured by the CopyConstructible requirements in table 30
        in C++2003). However this constraint has been lost in the
        Concepts of C++0x. This applies to vector and array (it
        actually applies to string also, but that's a different
        chapter, so I'll file a separate comment there and
        cross-reference).

        <p align="left"><br>

      <td>
        <p align="left">Define a ContiguousStrorage and apply it to
        vector,array and string. The Concept (supplied by Alisdair
        M) looks like this: Concept&lt; typename C &gt;
        ContiguousStrorage { requires Container&lt;C&gt;; typename
        value_type = C::value_type; value_type * data( C ); axiom
        Contiguous { C c; true = equal_ranges( data( c), data(c) +
        size(c), begin(c)); } };

      <td>
        <p>

    Agree with the issue but not the details of the proposed solution. Walter to 
    provide wording for the new concept.<tr valign="top">
      <td>
        <p>UK<br>
        245

      <td>
        <p align="justify">23.2.3

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The predicate types used in special member
        function of forward_list should be CopyConstructible, as
        per the algorithms of the same name. Note: an alternate
        solution would be to require these callable concepts to be
        CopyConstructible in clause 20, which would simplify the
        library specification in general. See earlier comment for
        details, that would render this one redundant.

      <td>
        <p align="left">Add
        CopyConstructible requirement to the following signatures:
        template &lt;Predicate&lt;auto, T&gt; Pred&gt; requires
        CopyConstructible&lt;Pred&gt; void remove_if(Pred pred);
        template &lt;EquivalenceRelation&lt;auto, T&gt;
        BinaryPredicate&gt; requires
        CopyConstructible&lt;BinaryPredicate&gt; void
        unique(BinaryPredicate binary_pred); template
        &lt;StrictWeakOrder&lt;auto, T&gt; Compare&gt; requires
        CopyConstructible&lt;Compare&gt; void
        merge(forward_list&lt;T,Alloc&gt;&amp;&amp; x, Compare
        comp); template &lt;StrictWeakOrder&lt;auto, T&gt;
        Compare&gt; requires CopyConstructible&lt;Compare&gt; void
        sort(Compare comp);

        <p align="left"><br>

        <p align="left"><br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>JP 58

      <td>
        <p align="left">23.2.3.2

      <td>
        <p align="left">
        1<sup>st</sup> <font size="2" style="font-size: 11pt">line
        before 1<sup>st</sup> para</font>

        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">
        Unnecessary "{" exists before a word iterator like
        "{iterator before_begin()".

      <td>
        <p align="left" style="margin-top: 0.04in">
        Remove "{"

      <td>
        <p>

    <tr valign="top">
      <td>
        <p>JP 59

      <td>
        <p align="left">23.2.4.4

      <td>
        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">
        Types of the third and forth parameter of splice() are
        iterator at 23.2.4.4, though types of them are
        const_iterator at 23.2.4. (They are both const_iterator on
        N2350)

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        void splice(const_iterator position,
        list&lt;T,Allocator&gt;&amp;&amp; x, iterator i);

        <p align="left">
        void splice(const_iterator position,
        list&lt;T,Allocator&gt;&amp;&amp; x,

        <p align="left">
        iterator first, iterator last);

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left">
        <br>

        <p align="left">
        void splice(const_iterator position,
        list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);

        <p align="left">
        void splice(const_iterator position,
        list&lt;T,Allocator&gt;&amp;&amp; x,

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">const_iterator
        first, const_iterator last);

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p>

    <tr valign="top">
      <td>
        <p align="left">US 83

      <td>
        <p align="left">23.2.6.2

      <td>
        <p align="left">7

      <td>
        <p align="left">ed

      <td>
        <p align="left">
        "shrink_to_fint" should be "shrink_to_fit".

        <p align="left">
        <br>

        <p align="left"><br>

      <td>
        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        246

      <td>
        <p align="justify">23.3.2.2

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The content of
        this sub-clause is purely trying to describe in words the
        effect of the requires clauses on these operations, now
        that we have Concepts. As such, the desctiption is more
        confusing than the signature itself. The semantic for these
        functions is adequately covered in the requirements tables
        in 23.1.4.

        <p align="left"><br>

      <td>
        <p align="left">Strike 23.3.2.2 entirely. (but do NOT
        strike these signatures from the class template
        definition!)

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        247

      <td>
        <p align="justify">24.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ge

      <td>
        <p align="left">Iterator
        concepts are not extensive enough to merit a whole new
        header, and should be merged into &lt;concpts&gt;. This is
        particularly important for supporting the new for loop
        syntax which requires access to the Range concept. The
        required header to enable this syntax shoud have a simple
        name, like &lt;concepts&gt;, rather than something awkward
        to type like &lt;iterator_concepts&gt;.

        <p align="left"><br>

      <td>
        <p align="left">Move the concepts of
        &lt;iterator_concepts&gt; into the &lt;concepts&gt; header.
        We take no position on moving the text from Clause 24 to
        Clause 20 though.

      <td>
        <p align="left">NAD. We believe the separate header to have value.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        248

      <td>
        <p align="justify">24.1

      <td>
        <p align="justify">6

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The text "so for
        any iterator type there is an iterator value that points
        past the last element of a corresponding container" is
        slightly misleading. Iterators can refer into generalised
        ranges and sequences, not just containers. A broader term
        than 'container' should be used.

        <p align="left"><br>

      <td>
        <p align="left">Replace the reference to container with a
        more appropriate concept

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        250

      <td>
        <p align="justify">24.1.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">A default implementation should be supplied
        for the post-increment operator to simplify implementation
        of iterators by users.

      <td>
        <p align="left">Copy the Effects clause into the concept
        description as the default implementation. Assumes a
        default value for postincrement_result

      <td>
        <p align="left">Howard will open an issue.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        251

      <td>
        <p align="justify">24.1.1

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The
        post-increment operator is dangerous for a general
        InputIterator. The multi-pass guarantees that make it
        meaningful are defined as part of the ForwardIterator
        refinement. Any change will affect only constrained
        templates that have not yet been written, so should not
        break existing user iterators which remain free to add
        these operations. This change will also affect the
        generalised OutputIterator, although there is no percieved
        need for the post-increment operator in this case either.

        <p align="left"><br>

      <td>
        <p align="left">Move declaration of postincrement operator
        and postincrement_result type from Interator concept to the
        ForwardIterator concept

      <td>
        <p align="left">Alisdair will open an issue.<br>

    <tr valign="top">
      <td>
        <p align="justify" style=
        "margin-right: -0.18in; margin-bottom: 0in">UK<br>
        252

        <p>

      <td>
        <p align="justify">24.1.2

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">istream_iterator is not a class, but a
        class template

      <td>
        <p align="left">Change 'class' to 'class template' in the
        note.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        253

      <td>
        <p align="justify">24.1.3

      <td>
        <p align="justify">1

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">First sentance
        does not make gramatical sense, Seems to be missing the
        words 'if it' by comparison with similar sentance in other
        subsections

        <p align="left"><br>

      <td>
        <p align="left">Add the words 'if it' : "X satisfies the
        requirements of an output iterator IF IT meets the
        syntactic and semantic requirements"

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        254

      <td>
        <p align="justify">24.1.3

      <td>
        <p align="justify">5

      <td>
        <p align="justify">Te

      <td>
        <p align="left">This
        postcondition for pre-increment operator should be written
        as an axiom

        <p align="left"><br>

      <td>
        <p align="left">Move the postcondition into the concept
        definition as an axiom

      <td>
        <p align="left">deferred until we know whether we have axioms.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        255

      <td>
        <p align="justify">24.1.4

      <td>
        <p align="justify">4

      <td>
        <p align="justify">Te

      <td>
        <p align="left">This
        postcondition for pre-increment operator should be written
        as an axiom

        <p align="left"><br>

      <td>
        <p align="left">Move the postcondition into the concept
        definition as an axiom

      <td>
        <p align="left">deferred until we know whether we have axioms.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        256

      <td>
        <p align="justify">24.1.5

      <td>
        <p align="justify">3, 4, 5

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The relationship between pre- and post-
        decrement should be expressed as an axiom.

      <td>
        <p align="left">Move the text
        specification of pre/post-conditions and behaviour into an
        axiom within the BidirectionalIterator concept

        <p align="left"><br>

      <td>
        <p align="left">deferred until we know whether we have axioms.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        257

      <td>
        <p align="justify">24.1.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">There is a
        reasonable default for postdecrement_result type, which is
        X. X is required to be regular, therefore CopyConstructible
        and a valid ResultType. Together with the next comment this
        simplifies user defined iterator implentations

        <p align="left"><br>

      <td>
        <p align="left">Add the default : typename
        postincrement_result = X;

      <td>
        <p align="left">NAD, postdecrement_result is deduced.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        258

      <td>
        <p align="justify">24.1.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">A default
        implementation should be supplied for the post-decrement
        operator to simplify implementation of iterators by users.

        <p align="left"><br>

      <td>
        <p align="left">Copy the Effects clause into the concept
        description as the default implementation. Assumes a
        default value for postincrement_result

      <td>
        <p align="left">Howard will open an issue.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        259

      <td>
        <p align="justify">24.1.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">
        postdecrement_result is effectively returning a copy of the
        original iterator value, so should have similar
        constraints, rather than just HasDereference. If Concepts
        do not support this circularity of definition suggest that
        concepts feature may want a little more work

        <p align="left"><br>

      <td>
        <p align="left">Add the requirement: requires Iterator&lt;
        postdecrement_result &gt;;

      <td>
        <p align="left">NAD unless Alisdair comes back with more motivation.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        260

      <td>
        <p align="justify">24.1.5

      <td>
        <p align="justify">6

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The effects clause for post-decrement
        iterator should be available as an axiom and a default
        implementation, where the compiler can make better use of
        it.

      <td>
        <p align="left">Move the Effects
        clause into the BidirectionalIterator concept definition as
        an axiom, and as the default implementation for the
        operation.

        <p align="left"><br>

      <td>
        <p align="left">deferred for axiom decision.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        249

      <td>
        <p align="justify"><span lang=
        "en-US">24.1.6</span>

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The semantic for
        operator+= should also be provided as a default
        implementation to simplify implementation of user-defined
        iterators

        <p align="left"><br>

      <td>
        <p align="left">Copy the text from the effects clause into
        the RandomAccessIterator concept as the default
        implementaiton.

      <td>
        <p align="left">NAD, violates complexity requirements.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        261

      <td>
        <p align="justify">24.1.6

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">To simplify user
        defined random access iterator types, the
        subscript_reference type should default to reference

        <p align="left"><br>

      <td>
        <p align="left">typename subscript_reference = reference;

      <td>
        <p align="left">NAD, subscript reference isnt used.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        262

      <td>
        <p align="justify">24.1.6

      <td>
        <p align="justify">3, 4

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Effects and post-conditions for operator+
        are more useful if expressed as axioms, and supplied as
        default implementations.

      <td>
        <p align="left">Move the effects
        and Postcondition definitions into the RandomAccessIterator
        concept and copy the code in the specification as the
        default implementation of these operations.

        <p align="left"><br>

      <td>
        <p align="left">default implementation already in Standard; axiom part 
        deferred.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        263

      <td>
        <p align="justify">24.1.6

      <td>
        <p align="justify">5

      <td>
        <p align="justify">Te

      <td>
        <p align="left">This requirement on operator-= would be
        better expressed as a default implementation in the
        concept, with a matching axiom

      <td>
        <p align="left">Move the
        specification for operator-= from the returns clause into
        an axiom and default implementation within the
        RandomAccessIterator concept

        <p align="left"><br>

      <td>
        <p align="left">Alisdair will open an issue, axiom part deferred.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        264

      <td>
        <p align="justify">24.1.6

      <td>
        <p align="justify">6

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Effects clauses are better expressed as
        axioms where possible.

      <td>
        <p align="left">Move code in
        operator- effects clause into RandomAccessIterator concept
        as both a default implementation and an axiom

        <p align="left"><br>

      <td>
        <p align="left">deferred/axiom.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        265

      <td>
        <p align="justify">24.1.6

      <td>
        <p align="justify">8

      <td>
        <p align="justify">Te

      <td>
        <p align="left">This effects
        clause is nonesense. It looks more like an axiom stating
        equivalence, and certainly an effects clause cannot change
        the state of two arguments passed by const reference

        <p align="left"><br>

      <td>
        <p align="left">Strike the Effects clause

      <td>
        <p align="left">Doug will open issuestrike effect, returns n.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        266

      <td>
        <p align="justify">24.1.6

      <td>
        <p align="justify">9

      <td>
        <p align="justify">Te

      <td>
        <p align="left">This sentance should be provided as a
        default definition, along with a matching axiom

      <td>
        <p align="left">Move the Returns
        clause into the spefication for RandomAccessIterator
        operator- as a default implementation. Move the Effects
        clause as the matching axiom.

        <p align="left"><br>

      <td>
        <p align="left">default definition is not implementable; axiom part 
        deferred.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        267

      <td>
        <p align="justify">24.1.6

      <td>
        <p align="justify">24.1.6

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The code in the
        Requires clause for RandomAccessIterator operator[] would
        be better expressed as an axiom.

        <p align="left"><br>

      <td>
        <p align="left">Rewrite the Requires clause as an axiom in
        the RandomAccessIterator concept

      <td>
        <p align="left">deferred/axiom.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        268

      <td>
        <p align="justify">24.1.6

      <td>
        <p align="justify">12

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">This note is
        potentialy confusing as __far enters the syntax as a clear
        language extension, but the note treats it as a regular
        part of the grammar. It might be better expressed using
        attributes in the current wording.

        <p align="left"><br>

      <td>
        <p align="left">Clean up the note to either avoid using
        language extension, or spell out this is a constraint to
        support extensions.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 60

      <td>
        <p align="left">24.1.8

      <td>
        <p align="left">1<sup>st</sup> <font size="2"
        style="font-size: 11pt">para</font>

      <td>
        <p>te

      <td>
        <p align="left">
        Capability of an iterator is too much restricted by
        concept.

        <p align="left">
        <br>

        <p align="left">
        Concept of std::Range is defined as:

        <p align="left">
        <br>

        <p align="left">
        concept Range&lt;typename T&gt; {

        <p align="left">
        InputIterator iterator;

        <p align="left">
        iterator begin(T&amp;);

        <p align="left">
        iterator end(T&amp;);

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">So
        the following code generates an error.

        <p align="left">
        <br>

        <p align="left">
        template &lt;std::Range Rng&gt;

        <p align="left">
        void sort(Rng&amp; r)

        <p align="left">{

        <p align="left" style=
        "margin-left: 0.08in; text-indent: -0.08in; margin-bottom: 0in">
        // error! Rng::iterator does not satisfy requirements of a
        random

        <p align="left" style=
        "margin-left: 0.07in; text-indent: 0.08in; margin-bottom: 0in">
        // access iterator.

        <p align="left">
        std::sort(begin(r), end(r));

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        std::vector&lt;int&gt; v; // vector::iterator is a random
        access iterator.

        <p align="left">
        sort(v);

        <p align="left">
        <br>

        <p align="left">
        This is because the concept of an iterator of std::Range is
        InputIterator. For this reason, a random access iterator
        loses its capability when passed to a std::Range parameter.

        <p align="left">
        <br>

        <p align="left">To
        be able to work the above code, we need to write as
        follows:

        <p align="left">
        <br>

        <p align="left">
        template &lt;std::Range T&gt;

        <p align="left">
        requires std::RandomAccessIterator&lt;T::iterator&gt;
        &amp;&amp;

        <p align="left">
        std::ShuffleIterator&lt;T::iterator&gt; &amp;&amp;

        <p align="left">
        std::LessThanComparable&lt;T::iterator::value_type&gt;

        <p align="left">
        void sort(T&amp; r)

        <p align="left">{

        <p align="left">
        sort(begin(r), end(r));

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        std::vector&lt;int&gt; v;

        <p align="left">
        sort(v);

        <p align="left">
        <br>

        <p align="left">It
        needs quiet a few amount of codes like this only to recover
        random access capability from InputIterator concept.

        <p align="left">
        <br>

        <p align="left">We
        can write the following valid code with Boost.Range, which
        is implemented with using C++03 SFINAE.

        <p align="left">
        <br>

        <p align="left">
        template &lt;class Range&gt;

        <p align="left">
        void sort(Range&amp; r)

        <p align="left">{

        <p align="left">
        std::sort(boost::begin(r), boost::end(r));

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        std::vector&lt;int&gt; v;

        <p align="left">
        sort(v); // OK

        <p align="left">
        <br>

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">One of the
        motivation to introduce concepts are supporting template
        programming techniques by language directly to eliminate
        hacky techniques such as tag-dispatch, SFINAE and Type
        Traints. But SFINAE will be kept using because it needs
        quite a few amount of codes without using SFAINAE.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        InputRange, OutputRange, ForwardRange, BidirectionalRange
        and RandomAccessRange.

      <td>
        <p align="left">NAD, beyond the scope of the Standard because we are not 
        supplying range-based algorithms.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        269

      <td>
        <p align="justify">24.3

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">'decrements for
        negative n' seems to imply a negative number of decrement
        operations, which is odd.

        <p align="left"><br>

      <td>
        <p align="left">Need simple, clearer wording

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        270

      <td>
        <p align="justify">24.3

      <td>
        <p align="justify">4

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The reachability
        constraint in p5 means that a negavite result, implying
        decrements operations in p4, is not possible

        <p align="left"><br>

      <td>
        <p align="left">Split the two overloads into separate
        descriptions, where reachability is permitted to be in
        either direction for RandomAccessIterator

      <td>
        <p align="left">Howard will open an issue.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        271

      <td>
        <p align="justify">24.3

      <td>
        <p align="justify">6,7

      <td>
        <p align="justify">Te

      <td>
        <p align="left">next/prev return
        an incremented iterator without changing the value of the
        original iterator. However, even this may invalidate an
        InputIterator. A ForwardIterator is required to guarantee
        the 'multipass' property.

        <p align="left"><br>

      <td>
        <p align="left">Replace InputIterator constraint with
        FOrwardIterator in next and prev function templates.

      <td>
        <p align="left">Alisdair will open an issue.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        272

      <td>
        <p align="justify">24.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">reverse_iterator
        and move_iterator use different formulations for their
        comparison operations. move_iterator merely requires the
        minimal set of operations, &lt; and ==, from its underlying
        iterator and synthesizes all oprations from these two.
        reverse_iterator relies on the undelying iterator to
        support all comparision operations directly. In practice,
        move_iterator can only be implemented this way as it must
        support iterator types that are merely InputIterators, and
        so SemiRegular and not Regular. However, reserse_iterator
        has an existing specification and any change of semantic
        could change behaviour of conforming programs today -
        although an iterator that yields different results for (a
        &gt; b) than (b &lt; a) may fall foul of some semantic
        consistency requirements, even if the syntax is met.

        <p align="left"><br>

      <td>
        <p align="left">Rephrase the reverse_iterator comparison
        operations using only operators &lt; and ==, as per the
        move_iterator specification.

      <td>
        <p align="left">NAD, no consensus.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        274

      <td>
        <p align="justify">24.4, 24.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The subclauses
        for standard iterator adaptors could be better organised.
        There are essentially 3 kinds of iterator wrappers
        provided, stream iterators adapt streams and get their own
        subsection. insert iterators adapt containers, and get
        their own subsection but it is inserted into the middle of
        24.4 Predifined iterators. reverse_iterator and
        move_iterator adpat other iterators, but their presentation
        is split by insert iterators

        <p align="left"><br>

      <td>
        <p align="left">Promote 24.4.2 [insert.iterators] up one
        level to 24.6. Emphasize that insert iterators adapt
        containers Retarget 24.4 [predef.iterators] as iterator
        adapters for iterator templates that wrap other iterators.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        275

      <td>
        <p align="justify">24.4.1.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The constructor
        template taking a single Iterator argument will be selected
        for Copy Initialization instead of the non-template
        constructor taking a single Iterator argument selected by
        Direct Initialization.

        <p align="left"><br>

      <td>
        <p align="left">The reverse_iterator template constructor
        taking a single Iterator argument should be explicit.

      <td>
        <p align="left">NAD, withdrawn by submitter.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        276

      <td>
        <p align="justify">24.4.1.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">It is odd to
        have a mix of declaration stlyes for operator+ overloads.
        Prefer if either all are member functions, or all are
        'free' functions.

        <p align="left"><br>

      <td>
        <p align="left">Make the member operators taking a
        difference_type argument non-member operators

      <td>
        <p align="left">NAD, not editorial, withdrawn by submitter.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        277

      <td>
        <p align="justify">24.4.1.2.1

      <td>
        <p align="justify">1

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The default
        constructor default-initializes current, rather than
        value-initializes. This means that when Iterator
        corresponds to a trivial type, the current member is left
        un-initialized, even when the user explictly requests value
        intialization! At this point, it is not safe to perform any
        operations on the reverse_iterator other than assign it a
        new value or destroy it. Note that this does correspond to
        the basic definition of a singular iterator.

        <p align="left"><br>

      <td>
        <p align="left">i/ Specify value initialization rather than
        default intialization or ii/ specify = default; rather than
        spell out the semantic. This will at least allow users to
        select value initialization and copy the iterator value. or
        iii/ Add a note to the description emphasizing the singular
        nature of a value-initialized reserve iterator.

      <td>
        <p align="left">agree with option i, Alisdair will open an issue.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        278

      <td>
        <p align="justify">24.4.1.2.1

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Te

      <td>
        <p align="left">There is an
        inconsistency between the constructor taking an iterator
        and the constructor template taking a reverse_iterator
        where one passes by value, and the other by const
        reference. The by-value form is preferred as it allows for
        efficient moving when copy elision fails to kick in.

        <p align="left"><br>

      <td>
        <p align="left">Change the const reverse_iterator&lt;U&gt;
        &amp; parameter to pass-by-value

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        279

      <td>
        <p align="justify">24.4.1.<br>
        2.12,<br>
        24.4.3.<br>
        2.12

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The reason the
        return type became unspecified is LWG issue 386. This
        reasoning no longer applies as there are at least two ways
        to get the right return type with the new language
        facilities added since the previous standard.

        <p align="left"><br>

      <td>
        <p align="left">Specify the return type using either
        decltype or the Iter concept map

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        280

      <td>
        <p align="justify">24.4.1.<br>
        2.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The presence of
        the second iterator value is surprising for many readers
        who underestimate the size of a reverse_iterator object.
        Adding the exposition only member that is required by the
        semantic will reduce confusion.

        <p align="left"><br>

      <td>
        <p align="left">Add reverse_iterator expsoition only member
        tmp as a comment to class declaration, as a private member

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        281

      <td>
        <p align="justify">24.4.1.<br>
        2.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The current
        specification for return value will always be a true
        pointer type, but reverse_iterator supports proxy iterators
        where the pointer type may be some kind of 'smart pointer'

        <p align="left"><br>

      <td>
        <p align="left">Replace the existing returns specification
        with a copy of the operator* specification that returns
        this-&gt;tmp.operator-&gt;

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        282

      <td>
        <p align="justify">24.4.2.1,<br>
        24.4.2.2.2,<br>
        24.4.2.3,<br>
        24.4.2.4.2,<br>
        24.4.2.5,<br>
        24.4.2.6.2

      <td>
        <p align="justify">n/a

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Insert iterators of move-only types will
        move from lvalues

      <td>
        <p align="left">Add an additional constrained overload for
        operator= that requires
        !CopyConstructible&lt;Cont::value_type&gt; and mark it
        =delete.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        283

      <td>
        <p align="justify">24.4.2.5,<br>
        24.4.2.6.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">postincrement operator overloads
        traditionally return by value - insert_iterator is declared
        as return by reference. The change is harmless in this
        case, but either front/back_insert_iterator should take the
        matching change for consistency, or this function should
        return-by-value

      <td>
        <p align="left">change operator++(int) overload to return
        by value, not reference. Affects both class summary and
        operator definition in p

      <td>
        <p align="left">NAD. This is compatible with C++03; and we lack a 
        consensus for change.<br>

    <tr valign="top">
      <td>
        <p>JP 61

      <td>
        <p align="left">24.4.3.2.1

      <td>
        <p align="left">2<sup>nd</sup> <font size="2"
        style="font-size: 11pt">para, 1<sup>st</sup>
        line</font>

      <td>
        <p>ed

      <td>
        <p align="left">
        Typo.

        <p align="left" style="margin-top: 0.04in">
        "intializing" should be "in<u>i</u>tializing"

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        "i"

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        284

      <td>
        <p align="justify">24.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The stream
        iterators need constraining with concepts/requrires
        clauses.

        <p align="left"><br>

      <td>
        <p align="left">Provide constraints

      <td>
        <p align="left">We agree. To be handled by Howard, Martin and PJ.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        285

      <td>
        <p align="justify">24.5.1

      <td>
        <p align="justify">1,2

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Much of the
        content of p1 and the whole of p2 is a redundant
        redefinition of InputIterator. It should be simplified

        <p align="left"><br>

      <td>
        <p align="left">Strike p2. Simplify p1 and add a
        cross-reference to the definition of InputIterator concept.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        286

      <td>
        <p align="justify">24.5.1

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">To the casual
        reader it is not clear if it is intended to be able to
        assign to istream_iterator objects. Specifying the copy
        constructor but relying on the implicit copy-assign
        operator is confusing.

        <p align="left"><br>

      <td>
        <p align="left">Either provide a similar definition to the
        copy-assign operator as for the copy constructor, or strike
        the copy constructor

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        287

      <td>
        <p align="justify">24.5.1.1

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">It is not clear
        what the intial state of an istream_iterator should be. Is
        _value_ initialized by reading the stream, or default/value
        initialized? If it is initialized by reading the stream,
        what happens if the initialization is deferred until first
        dereference, when ideally the iterator value should have
        been that of an end-of-stream iterator which is not safely
        dereferencable?

        <p align="left"><br>

      <td>
        <p align="left">Specify _value_ is initialized by reading
        the stream, or the iterator takes on the end-of-stream
        value if the stream is empty

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        288

      <td>
        <p align="justify">24.5.1.1

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The provided specification is vacuous,
        offering no useful information.

      <td>
        <p align="left">Either strike
        the specification of the copy constructor, or simply
        replace it with an = default definition.

        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        289

      <td>
        <p align="justify">24.5.1.2

      <td>
        <p align="justify">6

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">It is very hard
        to pick up the correct specification for
        istream_iterator::operator== as the complete specification
        requires reading two quite disconnected paragraphs,
        24.5.1p3, and 24.5.1.2p6. Reading just the specifaction of
        the operation itself suggests that end-of-stream iterators
        are indistinguishable from 'valid' stream iterators, which
        is a very dangerous misreading.

        <p align="left"><br>

      <td>
        <p align="left">Merge 24.5.1p3, equality comparison of
        end-of-stream-iterators, into 24.5.1.2p6, the specification
        of the equality operator for istream_iterator.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        290

      <td>
        <p align="justify">24.5.2

      <td>
        <p align="justify">1

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The character
        type of a string delimiter for an ostream_iterator should
        be const charT *, the type of the elements, not char *, a
        narrow character string.

        <p align="left"><br>

      <td>
        <p align="left">Replace char * with const charT *

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        291

      <td>
        <p align="justify">24.5.2.2

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">ostream_iterator
        postincrement operator returns by reference rather than by
        value. This may be a small efficiency gain, but it is
        otherwise unconventional. Prefer return-by-value.

        <p align="left"><br>

      <td>
        <p align="left">ostream_iterator operator++(int);

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>FR 34

      <td>
        <p>24.5.3<br>
        [istream-<br>
        buf.<br>
        iterator]

      <td>
        <p>

      <td>
        <p>ed

      <td>
        <p>There are two public
        sections, and the content of the second one is indented
        with respect to the first. I don't it should be.

        <p>

      <td>
        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        292

      <td>
        <p align="justify">24.5.3

      <td>
        <p align="justify">1

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Prefer the use
        of the new nullptr constant to the zero literal when using
        a null pointer in text.

        <p align="left"><br>

      <td>
        <p align="left">Change istreambuf_iterator(0) to
        istreambuf_iterator(nullptr)

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        293

      <td>
        <p align="justify">24.5.3

      <td>
        <p align="justify">2,3,4

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The listed paragraphs redundantly redefine
        an input iterator, and redundancy can be a dangerous thing
        in a specification. Suggest a simpler phrasing below.

      <td>
        <p align="left">2. The result of
        operator*() on an end of stream is undefined. For any other
        iterator value a char_type value is returned. 3. Two end of
        stream iterators are always equal. An end of stream
        iterator is not equal to a non-end of stream iterator. 4.
        As istreambuf_iterator() is an InputIterator but not a
        ForwardIterator, istreambuf_iterators object can be used
        only for one-pass algorithms. It is not possible to assign
        a character via an input iterator.

        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        294

      <td>
        <p align="justify">24.5.3.2

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Implicit converting constructors can be
        invoked at surprising times, so there should always be a
        good reason for declaring one.

      <td>
        <p align="left">Mark the two
        single-argument constructors take a stream or stream buffer
        as explicit. The proxy constructor should remain implicit.
        explicit
        istreambuf_iterator(basic_istream&lt;charT,traits&gt;&amp;
        s) throw(); explicit
        istreambuf_iterator(basic_streambuf&lt;charT,traits&gt;* s)
        throw();

        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        295

      <td>
        <p align="justify">25

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">THere is a level
        of redundancy in the library specification for many
        algorithms that can be eliminated with the combination of
        concepts and default parameters for function templates.
        Eliminating redundancy simplified specification and reduces
        the risk of inttroducing accidental inconsistencies.

        <p align="left"><br>

      <td>
        <p align="left">Adopt n2743, or an update of that paper.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 62

      <td>
        <p align="left">25, 25.3.1.5,<br>
        26.3.6.5

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style=
        "margin-left: 0.2in; text-indent: -0.2in; margin-bottom: 0in">
        The return types of is_sorted_until function and
        is_heap_until function are iterator. But basically, the
        return type of is_xxx function is bool. And the return type
        of lower_bound function and upper_bound is iterator.

        <p align="left" style=
        "text-indent: 0.2in; margin-top: 0.04in; margin-bottom: 0.04in">
        So we think that it is reasonable to change those two
        functions.

        <p align="left" style=
        "text-indent: 0.2in; margin-top: 0.04in"><br>

      <td>
        <p align="left">
        Change "is_sorted_until" to "sorted_bound"

        <p align="left" style="margin-top: 0.04in">
        Change "is_heap" to "heap_bound"

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        296

      <td>
        <p align="justify">25.1.8

      <td>
        <p align="justify">1

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The 'Returns' of
        adjacent_find requires only HasEqualTo, or a Predicate.
        Requiring EqualityComparable or EquivalenceRelation seems
        too strong and not useful.

        <p align="left"><br>

      <td>
        <p align="left">Change EqualityComparable to HasEqualTo and
        EquivalnceRelation to Predicate

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        297

      <td>
        <p align="justify">25.2.11

      <td>
        <p align="justify">6

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The definition
        of rotate_copy is very complicated. It is equivalent to:
        return copy(first, middle, copy(middle, last, result));

        <p align="left"><br>

      <td>
        <p align="left">Change 'effects' to, returns, requires,
        complexity to: effects: equivalent to: return copy(first,
        middle, copy(middle, last, result));

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        298

      <td>
        <p align="justify">25.2.13

      <td>
        <p align="justify">13

      <td>
        <p align="justify">Te

      <td>
        <p align="left">partition_point requires a partitioned
        array

      <td>
        <p align="left">requires: is_partitioned(first, last, pred)
        != false;

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        299

      <td>
        <p align="justify">25.2.2

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Should be consistent in style use of
        concepts in template parameter lists. The
        auto-OutputIterator sytle used in std::copy is probably
        preferred.

      <td>
        <p align="left">Change way signature is declared:
        template&lt;InputIterator InIter, OutputIterator&lt;auto,
        RvalueOf&lt;InIter::reference&gt;::type&gt; OutIter&gt;
        OutIter move(InIter first, InIter last, OutIter result);

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        300

      <td>
        <p align="justify">25.2.3

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Since publishing
        the original standard, we have learned that swap is a
        fundamental operation, and several common idioms rely on it
        - especially those related to exception safety. As such it
        belongs in the common &lt;utility&gt; header rather than
        the broader &lt;algorithm&gt; header, and likewise should
        move to clause 20. For backwards compatiblility the
        algorithm header should be required to #include
        &lt;utility&gt;, which would be covered in the resolution
        of LWG issue 343. There are already dependencies in
        &lt;algorithm&gt; on types declared in this header, so this
        comment does not create a new dependency.

        <p align="left"><br>

      <td>
        <p align="left">Move primary swap template from
        &lt;algorithm&gt; into &lt;utility&gt;. Move 25.2.3 to
        somewhere under 20.2. Require &lt;algorithm&gt; to #include
        &lt;utility&gt; to access pair and provide legacy support
        for finding swap.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        301

      <td>
        <p align="justify">25.2.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">replace and
        replace_if have the requirement: OutputIterator&lt;Iter,
        Iter::reference&gt; Which implies they need to copy some
        values in the range the algorithm is iterating over. This
        is not however the case, the only thing that happens is
        const T&amp;s might be copied over existing elements (hence
        the OutputIterator&lt;Iter, const T&amp;&gt;

        <p align="left"><br>

      <td>
        <p align="left">Remove OutputIterator&lt;Iter,
        Iter::reference&gt; from replace and replace_if

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        302

      <td>
        <p align="justify">25.3

      <td>
        <p align="justify">4

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">the concept
        StrictWeakOrder covers the definition of a strict weak
        ordering, described in paragraph 4.

        <p align="left"><br>

      <td>
        <p align="left">Remove 4, and mention StrictWeakOrder in
        paragraph 1.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        303

      <td>
        <p align="justify">25.3

      <td>
        <p align="justify">6

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">This paragraph just describes
        is_partitioned

      <td>
        <p align="left">6 A sequence
        [start,finish) is partitioned with respect to an expression
        f(e) if is_partitioned(start, finish, e) != false

        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        304

      <td>
        <p align="justify">25.3.6

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The requires
        clauses of push_heap, pop_heap and make_heap are
        inconsistently formatted, dispite being identical

        <p align="left"><br>

      <td>
        <p align="left">Format them identically.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        305

      <td>
        <p align="justify">25.3.7

      <td>
        <p align="justify">1, 9, 17

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The negative requirement on IsSameType is a
        hold-over from an earlier draught with a variadic template
        form of min/max algorith. It is no longer necessary.

      <td>
        <p align="left">Strike the !IsSameType&lt;T, Compare&gt;
        constraint on min/max/minmax algorithms

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p align="left">US 84

      <td>
        <p align="left">26

      <td>
        <p align="left"><br>

      <td>
        <p align="left">ge

      <td>
        <p align="left">
        Parts of the numerics chapter are not concept enabled.

        <p align="left"><br>

      <td>
        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>FR 35

      <td>
        <p>26.3<br>
        [Complex<br>
&nbsp;numbers]

      <td>
        <p>

      <td>
        <p>te

      <td>
        <p>Instantiations of the class
        template complex&lt;&gt; have to be allowed for integral
        types, to reflect existing practice and ISO standards
        (LIA-III).

        <p>

      <td>
        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        306

      <td>
        <p align="justify">26.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Random number
        library component cannot be used in constrained templates

        <p align="left"><br>

      <td>
        <p align="left">Provide constraints for the random number
        library

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 63

      <td>
        <p align="left">26.4.8.5.1

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left">No
        constructor of discrete_distribution that accepts
        initializer_list.

        <p align="left">
        discrete_distribution initialize distribution by a given
        range (iterators), but temporary variable of a container or
        an array is needed in the following case.

        <p align="left">
        <br>

        <p align="left">int
        ar[] = {1, 2, 3};

        <p align="left">
        discrete_distribution&lt;&gt; dist(ar, ar+3);

        <p align="left">
        <br>

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Other libraries
        also accept initializer_list, so change
        discrete_distribution library to accept initializer_list
        too.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left">Add
        the following constructer.

        <p align="left" style="margin-top: 0.04in">
        <u>discrete_distribution(initializer_list&lt;result_type&gt;);</u>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 64

      <td>
        <p align="left">26.5.2

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">
        &#8220;valarray&lt;T&gt;&amp; operator+=
        (initializer_list&lt;T&gt;);&#8221; is not defined.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        valarray&lt;T&gt;&amp; operator+=
        (initializer_list&lt;T&gt;);

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        307

      <td>
        <p align="justify">26.7

      <td>
        <p align="justify">Footnote 288

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">The footnote
        refers to TR1, which is not a defined term in this
        standard. Drop the reference to TR1, those templates are a
        regular part of the standard now and how they were
        introduced is no longer relevant.

        <p align="left"><br>

      <td>
        <p align="left">Drop the reference to TR1.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p align="left">US 85

      <td>
        <p align="left">27

      <td>
        <p align="left"><br>

      <td>
        <p align="left">ge

      <td>
        <p align="left">The
        input/output chapter is not concept enabled.

        <p align="left"><br>

      <td>
        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        308

      <td>
        <p align="justify">27

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">
        <span lang="en-US">iostreams library cannot be used from
        constrained templates</span>

        <p align="left"><br>

      <td>
        <p align="left">Provide constraints for the iostreams
        library, clause 27

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 65

      <td>
        <p align="left">27.4.4

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Switch from
        &#8220;unspecified-bool-type&#8221; to<span lang=
        "zxx">&#12288;&#8220;</span>explicit operator bool()
        const&#8221;.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">
        Replace "operator <i>unspecified-bool-type</i>() const;"
        with "explicit operator bool() const;"

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 66

      <td>
        <p align="left">27.4.4.3

      <td>
        <p align="left">1<sup>st</sup> <font size="2"
        style="font-size: 11pt">para</font>

      <td>
        <p>te

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Switch from
        &#8220;unspecified-bool-type&#8221; to<span lang=
        "zxx">&#12288;&#8220;</span>explicit operator bool()
        const&#8221;

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">
        Replace "operator <i>unspecified-bool-type</i>() const;"
        with "explicit operator bool() const;"

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>FR 36

      <td>
        <p>27.6.1.2.2<br>
        [istream.<br>
        formatted.<br>
        arithmetic]

      <td>
        <p>1, 2, and 3

      <td>
        <p>ed

      <td>
        <p>iostate err = 0;

        <p>

        <p>iostate is a bitmask type and
        so could be an enumeration. Probably using

        <p>goodbit is the solution.

        <p>

      <td>
        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>FR 37

      <td>
        <p>27.6.1.2.2<br>
        [istream.<br>
        formatted.<br>
        arithmetic]

      <td>
        <p>3

      <td>
        <p>ed

      <td>
        <p>else if (lval &lt;
        numeric_limits&lt;int&gt;::min()

        <p>||
        numeric_limits&lt;int&gt;::max() &lt; lval))

        <p>

        <p>The parentheses aren't
        balanced.

        <p>

      <td>
        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 67

      <td>
        <p align="left">27.7.1

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        basic_stringbuf dose not use concept.

      <td>
        <p align="left">
        Replace &#8220;class Allocator&#8221; to &#8220;Allocator
        Alloc&#8221;.

        <p align="left">
        &nbsp; Correct as follows.

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        template &lt;class charT, class traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        <u>Allocator Alloc</u> = allocator&lt;charT&gt; &gt;

        <p align="left">
        class basic_stringbuf : public
        basic_streambuf&lt;charT,traits&gt; {

        <p align="left">
        public:

        <p align="left">...

        <p align="left">
        <br>

        <p align="left">//
        27.7.1.1 Constructors:

        <p align="left">
        explicit basic_stringbuf(ios_base::openmode which

        <p align="left">=
        ios_base::in | ios_base::out);

        <p align="left">
        explicit basic_stringbuf

        <p align="left">
        (const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        str,

        <p align="left">
        ios_base::openmode which = ios_base::in | ios_base::out);

        <p align="left">
        basic_stringbuf(basic_stringbuf&amp;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">...

        <p align="left">
        &nbsp;

        <p align="left">
        &nbsp;

        <p align="left">//
        27.7.1.3 Get and set:

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt; str() const;

        <p align="left">
        void str(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; s);

        <p align="left">
        &nbsp;

        <p align="left">...

        <p align="left">};

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator
        Alloc</u>&gt;

        <p align="left">
        void swap(basic_stringbuf&lt;charT, traits,
        <u>Alloc</u>&gt;&amp; x,

        <p align="left">
        basic_stringbuf&lt;charT, traits, <u>Alloc</u>&gt;&amp; y);

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator
        Alloc</u>&gt;

        <p align="left">
        void swap(basic_stringbuf&lt;charT, traits,
        <u>Alloc</u>&gt;&amp;&amp; x,

        <p align="left">
        basic_stringbuf&lt;charT, traits, <u>Alloc</u>&gt;&amp; y);

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator
        Alloc</u>&gt;

        <p align="left">
        void swap(basic_stringbuf&lt;charT, traits,
        <u>Alloc</u>&gt;&amp; x,

        <p align="left">
        basic_stringbuf&lt;charT, traits,
        <u>Alloc</u>&gt;&amp;&amp; y);

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">}

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 68

      <td>
        <p align="left">27.7.2

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        basic_istringstream dose not use concept.

      <td>
        <p align="left">
        Replace &#8220;class Allocator&#8221; to &#8220;Allocator
        Alloc&#8221;.

        <p align="left">
        &nbsp; Correct as follows.

        <p align="left">
        &nbsp;

        <p align="left">
        namespace std {

        <p align="left">
        template &lt;class charT, class traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        <u>Allocator Alloc</u> = allocator&lt;charT&gt; &gt;

        <p align="left">
        class basic_istringstream : public
        basic_istream&lt;charT,traits&gt; {

        <p align="left">
        public:

        <p align="left">
        typedef charT char_type;

        <p align="left">
        typedef typename traits::int_type int_type;

        <p align="left">
        typedef typename traits::pos_type pos_type;

        <p align="left">
        typedef typename traits::off_type off_type;

        <p align="left">
        typedef traits traits_type;

        <p align="left">
        typedef <u>Alloc</u> allocator_type;

        <p align="left">
        <br>

        <p align="left">//
        27.7.2.1 Constructors:

        <p align="left">
        explicit basic_istringstream(ios_base::openmode which =
        ios_base::in);

        <p align="left">
        explicit basic_istringstream(

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        str,

        <p align="left">
        ios_base::openmode which = ios_base::in);

        <p align="left">
        basic_istringstream(basic_istringstream&amp;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">//
        27.7.2.2 Assign and swap:

        <p align="left">
        basic_istringstream&amp;
        operator=(basic_istringstream&amp;&amp; rhs);

        <p align="left">
        void swap(basic_istringstream&amp;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">//
        27.7.2.3 Members:

        <p align="left">
        basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt;* rdbuf()
        const;

        <p align="left">
        &nbsp;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt; str() const;

        <p align="left">
        void str(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; s);

        <p align="left">
        &nbsp;

        <p align="left">
        private:

        <p align="left">//
        basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt; sb;
        exposition only

        <p align="left">};

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator
        Alloc</u>&gt;

        <p align="left">
        void swap(basic_istringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp; x,

        <p align="left">
        basic_istringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
        y);

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator
        Alloc</u>&gt;

        <p align="left">
        void swap(basic_istringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp;&amp; x,

        <p align="left">
        basic_istringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
        y);

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator
        Alloc</u>&gt;

        <p align="left">
        void swap(basic_istringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp; x,

        <p align="left">
        basic_istringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp;&amp; y);

        <p align="left">}

        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 69

      <td>
        <p align="left">27.7.3

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        basic_ostringstream dose not use concept.

      <td>
        <p align="left">
        Replace &#8220;class Allocator&#8221; to &#8220;Allocator
        Alloc&#8221;.

        <p align="left">
        &nbsp; Correct as follows.

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        template &lt;class charT, class traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        <u>Allocator Alloc</u> = allocator&lt;charT&gt; &gt;

        <p align="left">
        class basic_ostringstream : public
        basic_ostream&lt;charT,traits&gt; {

        <p align="left">
        public:

        <p align="left">//
        types:

        <p align="left">
        typedef charT char_type;

        <p align="left">
        typedef typename traits::int_type int_type;

        <p align="left">
        typedef typename traits::pos_type pos_type;

        <p align="left">
        typedef typename traits::off_type off_type;

        <p align="left">
        typedef traits traits_type;

        <p align="left">
        typedef <u>Alloc</u> allocator_type;

        <p align="left">
        &nbsp;

        <p align="left">//
        27.7.3.1 Constructors/destructor:

        <p align="left">
        explicit basic_ostringstream(ios_base::openmode which =
        ios_base::out);

        <p align="left">
        explicit basic_ostringstream(

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        str,

        <p align="left">
        ios_base::openmode which = ios_base::out);

        <p align="left">
        basic_ostringstream(basic_ostringstream&amp;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">//
        27.7.3.2 Assign/swap:

        <p align="left">
        basic_ostringstream&amp;
        operator=(basic_ostringstream&amp;&amp; rhs);

        <p align="left">
        void swap(basic_ostringstream&amp;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">//
        27.7.3.3 Members:

        <p align="left">
        basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt;* rdbuf()
        const;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt; str() const;

        <p align="left">
        void str(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; s);

        <p align="left">
        private:

        <p align="left">//
        basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt; sb;
        exposition only

        <p align="left">};

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator</u>
        <font size="2" style=
        "font-size: 11pt"><u>Alloc</u>&gt;</font>

        <p align="left">
        void swap(basic_ostringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp; x,

        <p align="left">
        basic_ostringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
        y);

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator</u>
        <font size="2" style=
        "font-size: 11pt"><u>Alloc</u>&gt;</font>

        <p align="left">
        void swap(basic_ostringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp;&amp; x,

        <p align="left">
        basic_ostringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
        y);

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator
        Alloc</u>&gt;

        <p align="left">
        void swap(basic_ostringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp; x,

        <p align="left">
        basic_ostringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp;&amp; y);

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">}

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 71

      <td>
        <p align="left">27.7.3

      <td>
        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left">
        Typo.

        <p align="left">"template" is missing in
        "class basic_ostringstream" of the title of the chapter.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        27.7.3 Class basic_ostringstream

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left">
        <br>

        <p align="left">27.7.3 Class <u>template</u>
        basic_ostringstream

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 72

      <td>
        <p align="left">27.7.4

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">
        basic_stringstream dose not use concept.

      <td>
        <p align="left">
        Replace "class Allocator" to "Allocator Alloc".

        <p align="left">
        &nbsp; Correct as follows.

        <p align="left">
        &nbsp;

        <p align="left">
        namespace std {

        <p align="left">
        template &lt;class charT, class traits =
        char_traits&lt;charT&gt;,

        <p align="left">
        <u>Allocator Alloc</u> = allocator&lt;charT&gt; &gt;

        <p align="left">
        class basic_stringstream

        <p align="left">:
        public basic_iostream&lt;charT,traits&gt; {

        <p align="left">
        public:

        <p align="left">//
        types:

        <p align="left">
        typedef charT char_type;

        <p align="left">
        typedef typename traits::int_type int_type;

        <p align="left">
        typedef typename traits::pos_type pos_type;

        <p align="left">
        typedef typename traits::off_type off_type;

        <p align="left">
        typedef traits traits_type;

        <p align="left">
        typedef <u>Alloc</u> allocator_type;

        <p align="left">
        &nbsp;

        <p align="left">//
        constructors/destructor

        <p align="left">
        explicit basic_stringstream(

        <p align="left">
        ios_base::openmode which = ios_base::out|ios_base::in);

        <p align="left">
        explicit basic_stringstream(

        <p align="left">
        const basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp;
        str,

        <p align="left">
        ios_base::openmode which = ios_base::out|ios_base::in);

        <p align="left">
        basic_stringstream(basic_stringstream&amp;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">//
        27.7.5.1 Assign/swap:

        <p align="left">
        void swap(basic_stringstream&amp;&amp; rhs);

        <p align="left">
        &nbsp;

        <p align="left">//
        Members:

        <p align="left">
        basic_stringbuf&lt;charT,traits,<u>Alloc</u>&gt;* rdbuf()
        const;

        <p align="left">
        basic_string&lt;charT,traits,<u>Alloc</u>&gt; str() const;

        <p align="left">
        void str(const
        basic_string&lt;charT,traits,<u>Alloc</u>&gt;&amp; str);

        <p align="left">
        private:

        <p align="left">//
        basic_stringbuf&lt;charT, traits&gt; sb; exposition only

        <p align="left">};

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator
        Alloc</u>&gt;

        <p align="left">
        void swap(basic_stringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp; x,

        <p align="left">
        basic_stringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
        y);

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator</u>
        <font size="2" style=
        "font-size: 11pt"><u>Alloc</u>&gt;</font>

        <p align="left">
        void swap(basic_stringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp;&amp; x,

        <p align="left">
        basic_stringstream&lt;charT, traits, <u>Alloc</u>&gt;&amp;
        y);

        <p align="left">
        template &lt;class charT, class traits, <u>Allocator</u>
        <font size="2" style=
        "font-size: 11pt"><u>Alloc</u>&gt;</font>

        <p align="left">
        void swap(basic_stringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp; x,

        <p align="left">
        basic_stringstream&lt;charT, traits,
        <u>Alloc</u>&gt;&amp;&amp; y);

        <p align="left" style="margin-top: 0.04in">}

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 73

      <td>
        <p align="left">27.8.1.14

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">It is a problem
        from C++98, fstream cannot appoint a filename of wide
        character string(const wchar_t and const wstring&amp;).

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        interface corresponding to wchar_t, char16_t and char32_t.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p align="left">US 86

      <td>
        <p align="left">28

      <td>
        <p align="left"><br>

      <td>
        <p align="left">ge

      <td>
        <p align="left">The
        regular expressions chapter is not concept enabled.

        <p align="left"><br>

      <td>
        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        309

      <td>
        <p align="justify">28

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Regular
        expressions cannot be used in constrained templates

        <p align="left"><br>

      <td>
        <p align="left">Provide constraints for the regular
        expression library, clause 28

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        310

      <td>
        <p align="justify">28

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The regex chapter uses iterators in the old
        pre-concept style, it should be changed to use concepts
        instead.

      <td>
        <p align="left">Use concepts for iterator template
        arguments throughout.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        314

      <td>
        <p align="justify">28.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The swap
        overloads for regex classes are only supplied for l-value
        references. Other sections of the library (eg 21 strings or
        23 containers) provide two extra overloads taking an
        r-value reference as the first and second argument
        respectively.

        <p align="left"><br>

      <td>
        <p align="left">Add the missing overloads to 28.4 and the
        corresponding later sections in 28 for each swap function.
        We want to accept AMs paper which proposes a single
        overload with two r-value references

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        315

      <td>
        <p align="justify">28.4

      <td>
        <p align="justify">p6

      <td>
        <p align="justify">Te

      <td>
        <p align="left">6 Effects:
        string_type str(first, last); return
        use_facet&lt;collate&lt;charT&gt; &gt;(
        getloc()).transform(&amp;*str.begin(), &amp;*str.end()); Is
        it legal to dereference str.end() ?

        <p align="left"><br>

      <td>
        <p align="left">Reword to effect clause to use legal
        iterator dereferences

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        316

      <td>
        <p align="justify">28.4 ff

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The constructors
        for regex classes do not have an r-value overload.

        <p align="left"><br>

      <td>
        <p align="left">Add the missing r-value constructors to
        regex classes.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        317

      <td>
        <p align="justify">28.8

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">basic_string has both a constructor and an
        assignment operator that accepts an initializer list,
        basic_regex should have the same.

      <td>
        <p align="left">In the
        basic_regex synopsis, after: basic_regex&amp;
        operator=(const charT* ptr); add: basic_regex&amp;
        operator=(initializer_list&lt;charT&gt; il); And after
        paragraph 20 add: basic_regex&amp;
        operator=(initializer_list&lt;charT&gt; il); Effects:
        returns assign(il.begin(), il.end());

        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>JP 74

      <td>
        <p align="left">28.8

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">
        &#8220;basic_regx &amp; operator=
        (initializer_list&lt;T&gt;);&#8221; is not defined.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        basic_regx &amp; operator= (initializer_list&lt;T&gt;);

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        318

      <td>
        <p align="justify">28.8.2

      <td>
        <p align="justify">para 22

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Constructor
        definition should appear with the other constructors not
        after assignment ops.

        <p align="left"><br>

      <td>
        <p align="left">Move para 22 to just after para 17.

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p>UK<br>
        319

      <td>
        <p align="justify">28.12.2

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">It was always expected that
        regex_token_iterator would be constructible from an array
        literal: indeed ideally this is the prefered method of
        initializing such an object. However, the best we could do
        in C++0x was: template &lt;std::size_t N&gt;
        regex_token_iterator(BidirectionalIterator a,
        BidirectionalIterator b, const regex_type&amp; re, const
        int (&amp;submatches)[N], regex_constants::match_flag_type
        m = regex_constants::match_default); Now that we have
        initializer_lists we should use them to remove this
        particular wart.

      <td>
        <p align="left">To the synopsis
        for regex_token_iterator, after template &lt;std::size_t
        N&gt; regex_token_iterator(BidirectionalIterator a,
        BidirectionalIterator b, const regex_type&amp; re, const
        int (&amp;submatches)[N], regex_constants::match_flag_type
        m = regex_constants::match_default); add
        regex_token_iterator(BidirectionalIterator a,
        BidirectionalIterator b, const regex_type&amp; re,
        initializer_list&lt;int&gt; submatches,
        regex_constants::match_flag_type m =
        regex_constants::match_default); In 28.12.2.1 add the
        declaration: regex_token_iterator(BidirectionalIterator a,
        BidirectionalIterator b, const regex_type&amp; re,
        initializer_list&lt;int&gt; submatches,
        regex_constants::match_flag_type m =
        regex_constants::match_default); And to the end of para 3
        add: The forth constructor initializes the member subs to
        hold a copy of the sequence of integer values in the range
        [submatches.begin(), submatches.end()).

        <p align="left"><br>

      <td>
        <p align="left"><br>

    <tr valign="top">
      <td>
        <p align="left">US 87

      <td>
        <p align="left">29

      <td>
        <p align="left"><br>

      <td>
        <p align="left">ge

      <td>
        <p align="left">The
        atomics chapter is not concept enabled. The adopted paper,
        N2427, did have those concepts.

        <p align="left"><br>

      <td>
        <p align="left"><br>

      <td>
        <p align="left">Create an issue for concepts in the atomics chapter. See 
        N2427. Needs to also consider issues 923 and 924.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        311

      <td>
        <p align="justify">29

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Atomic types
        cannot be used generically in a constrained template

        <p align="left"><br>

      <td>
        <p align="left">Provide constraints for the atomics
        library, clause 29

      <td>
        <p align="left">Duplicate of US 87.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        312

      <td>
        <p align="justify">29

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The contents of the &lt;stdatomic.h&gt;
        header are not listed anywhere, and &lt;cstdatomic&gt; is
        listed as a C99 header in chapter 17. If we intend to use
        these for compatibility with a future C standard, we should
        not use them now.

      <td>
        <p align="left">Remove &lt;cstdatomic&gt; from the C99
        headers in table 14. Add a new header &lt;atomic&gt; to the
        headers in table 13. Update chapter 29 to remove reference
        to &lt;stdatomic.h&gt; and replace the use of
        &lt;cstdatomic&gt; with &lt;atomic&gt;. If and when WG14
        adds atomic operations to C we can add corresponding
        headers to table 14 with a TR.

      <td>
        <p align="left">Create an issue. Assigned to Lawrence Crowl. May be 
        resolvable with a footnote for clarity stating that the header is 
        defined where it exists.<br>

    <tr valign="top">
      <td>
        <p>JP 75

      <td>
        <p align="left">29

      <td>
        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">A
        definition of enum or struct is the style of C using
        typedef.

      <td>
        <p align="left">
        Change to a style of C++.

        <p align="left">
        Correct as follows.

        <p align="left">
        <br>

        <p align="left">
        29.1

        <p align="left">
        &nbsp;

        <p align="left">
        namespace std {

        <p align="left">
        <u>typedef</u> enum memory_order {

        <p align="left">
        memory_order_relaxed, memory_order_consume,
        memory_order_acquire,

        <p align="left">
        memory_order_release, memory_order_acq_rel,
        memory_order_seq_cst

        <p align="left">}
        memory_order;

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        enum memory_order {

        <p align="left">
        memory_order_relaxed, memory_order_consume,
        memory_order_acquire,

        <p align="left">
        memory_order_release, memory_order_acq_rel,
        memory_order_seq_cst

        <p align="left">};

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        29.3.1

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        <u>typedef</u> struct atomic_bool {

        <p align="left">...

        <p align="left">}
        atomic_bool;

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        struct atomic_bool {

        <p align="left">...

        <p align="left">};

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        <u>typedef</u> struct atomic_<i>itype</i> {

        <p align="left">...

        <p align="left">}
        atomic_<i>itype</i>;

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        struct atomic_<i>itype</i> {

        <p align="left">...

        <p align="left">};

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        29.3.2

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        <u>typedef</u> struct atomic_address {

        <p align="left">...

        <p align="left">}
        atomic_address;

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        struct atomic_address {

        <p align="left">...

        <p align="left">};

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        29.5

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        <u>typedef</u> struct atomic_flag {

        <p align="left">...

        <p align="left">}
        atomic_flag;

        <p align="left">}

        <p align="left">
        <br>

        <p align="left">
        should be

        <p align="left">
        <br>

        <p align="left">
        namespace std {

        <p align="left">
        struct atomic_flag {

        <p align="left">...

        <p align="left">};

        <p align="left">}

      <td>
        <p align="left">Recommend to reject the comment: We believe the current 
        syntax is most appropriate for an interface that is intended to be 
        highly compatible with C.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        313

      <td>
        <p align="justify">29.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">seq_cst fences don't necessarily guarantee
        ordering
        http://home.twcny.rr.com/hinnant/cpp_extensions/issues_preview/lwg-active.html#926

      <td>
        <p align="left">Add a new
        paragraph after 29.1 [atomics.order]p5 that says For atomic
        operations A and B on an atomic object M, where A and B
        modify M, if there are memory_order_seq_cst fences X and Y
        such that A is sequenced before X, Y is sequenced before B,
        and X precedes Y in S, then B occurs later than A in the
        modifiction order of M.

        <p align="left"><br>

      <td>
        <p align="left">Hans to make proposal. See LWG Issue 926.<p align="left">
        UK 313 Update and LWG 926: Accept proposed resolution, correcting 
        spelling. Move to review state. Hans to ask additional review from cpp-threads.<br>

    <tr valign="top">
      <td>
        <p align="left">US 88

      <td>
        <p align="left">29.2

      <td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">The "lockfree" facilities do
        not tell the programmer enough.

      <td>
        <p align="left">
        Expand the "lockfree" facilities. See the attached paper
        "Issues with the C++ Standard" under Chapter 29,
        "atomics.lockfree doesn't tell the programmer enough"

        <p align="left"><br>

      <td>
        <p align="left">Create an issue, will require more discussion. Assigned 
        to Lawrence. Description of issue should be based on what is in the 
        additional notes for US 88.<p align="left">See wiki for further 
        comments.<br>

    <tr valign="top">
      <td>
        <p align="left">US 89

      <td>
        <p align="left">29.3.1

      <td>
        <p align="left">Table 122

      <td>
        <p align="left">te

      <td>
        <p align="left">The
        types in the table "Atomics for standard typedef types"
        should be typedefs, not classes. These semantics are
        necessary for compatibility with C.

        <p align="left"><br>

      <td>
        <p align="left">Change the classes to
        typedefs.

      <td>
        <p align="left">LWG Issue 937. Direct the editor to turn the types into 
        typedefs as proposed in the comment. Paper approved by committee used 
        typedefs, this appears to have been introduced as an editorial change. 
        Rationale: for compatibility with C.<tr valign="top">
      <td>
        <p align="left">US 90

      <td>
        <p align="left">29.4

      <td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">Are atomic functions allowed
        to have non-volatile overloads?

      <td>
        <p align="left">
        Allow non-volatile overloads. See the attached paper
        "Issues with the C++ Standard, under Chapter 29, "Are
        atomic functions allowed to have non-volatile overloads?"

        <p align="left"><br>

      <td>
        <p align="left">Create an issue. Assigned to Lawrence Crowl. Should 
        explicitly consider the process shared issue.<br>

    <tr valign="top">
      <td>
        <p align="left">US 91

      <td>
        <p align="left">29.4

      <td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">Whether or not a failed
        compare_exchange is a RMW operation (as used in 1.10
        [intro.multithread]) is unclear.

      <td>
        <p align="left">
        Make failing compare_exchange operations <font size="2"
        style="font-size: 11pt"><strong>not</strong> be RMW. See
        the attached paper under "atomic RMW status of failed
        compare_exchange"</font>

        <p align="left"><br>

      <td>
        <p align="left">Create an issue, goes to review. Attention: Howard. 
        Group agrees with the resolution as proposed by Anthony Williams in the 
        attached note.<br>

    <tr valign="top">
      <td>
        <p align="left">US 92

      <td>
        <p align="left">29.4

      <td>
        <p align="left"><br>

      <td>
        <p align="left">te

      <td>
        <p align="left">The effect of
        memory_order_consume with atomic RMW operations is unclear.

      <td>
        <p align="left">
        Follow the lead of fences [atomics.fences], and promote
        memory_order_consume to memory_order_acquire with RMW
        operations.

        <p align="left"><br>

      <td>
        <p align="left">Create an issue. Assigned to Lawrence. Resolution 
        requires proposed wording.<p align="left">Later: Mark as Not A Defect. 
        We can not see the issue being suggested by the comment.<br>

    <tr valign="top">
      <td>
        <p>JP 76

      <td>
        <p align="left">30

      <td>
        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left">A
        description for "<i>Throws:</i> Nothing." are not unified.

        <p align="left" style="margin-top: 0.04in">At
        the part without throw, "<i>Throws:</i> Nothing." should be
        described.

      <td>
        <p align="left">Add
        "<i>Throws:</i> Nothing." to the following.

        <p align="left">
        30.2.1.6 , 1<sup>st</sup> <font size="2" style=
        "font-size: 11pt">paragraph</font>

        <p align="left">
        30.3.3.1 , 4<sup>th</sup> <font size="2" style=
        "font-size: 11pt">paragraph</font>

        <p align="left">
        30.3.3.2.1 , 6<sup>th</sup> <font size="2" style=
        "font-size: 11pt">paragraph</font>

        <p align="left">
        30.4.1 , 7<sup>th</sup> <font size="2" style=
        "font-size: 11pt">and 8<sup>th</sup> paragraph</font>

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">30.4.2 ,
        6<sup>th</sup><font size="2" style="font-size: 11pt">,
        7<sup>th</sup>,19<sup>th</sup>,21th and 25<sup>th</sup>
        paragraph</font>

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left">Pass on to editor.<br>

    <tr valign="top">
      <td>
        <p align="left">US 93

      <td>
        <p align="left">30

      <td>
        <p align="left"><br>

      <td>
        <p align="left">ge

      <td>
        <p align="left">The
        thread chapter is not concept enabled.

        <p align="left"><br>

      <td>
        <p align="left"><br>

      <td>
        <p align="left">Create an issue. Need to find volunteers to work on 
        this.<br>

    <tr valign="top">
      <td>
        <p align="justify" style=
        "margin-right: -0.18in; margin-bottom: 0in">UK<br>
        320 F<p>

      <td>
        <p align="justify">30

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Threads library cannot be used in
        constrained templates

      <td>
        <p align="left">Provide constraints for the threads
        library, clause 30

      <td>
        <p align="left">Duplicate of US 93.<br>

    <tr valign="top">
      <td>
        <p>UK<br>
        321

      <td>
        <p align="justify">30

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">Throughout this
        clause, the term Requires: is used to introduce compile
        time requirements, which we expect to be replaced with
        concepts and requires in code. Run-time preconditions are
        introduced with the term "Preconditions:" which is not a
        defined part of the library documentation structure
        (17.5.2.4). However, this is exactly the direction that BSI
        would like to see the organisation move, replacing
        Requires: clauses with Preconditions: clasues throught the
        library. See comment against clause 17 for more details.

        <p align="left"><br>

      <td>
        <p align="left">Decument Preconditions: paragraphs in
        17.5.2.4, and use consistently through rest of the library.

      <td>
        <p align="left">Pass on to editor.<br>

    <tr valign="top">
      <td>
        <p>US 94

      <td>
        <p>30.1.2

      <td>
        <p>1

      <td>
        <p>te

      <td>
        <p>The first sentence of para 1 suggests that no other
        library function is permitted to call operating system or
        low level APIs.

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Rewrite para 1
        as: &#8220; <font color="#000000">Some functions described
        in this Clause are specified to throw exceptions of type
        system_error (</font><font color="#0000FF">19.4.5</font>
        <font color="#000000">). Such exceptions shall be thrown if
        a call to an operating system or underlying API results in
        an error that prevents the library function from satisfying
        its postconditions or from returning a meaningful
        value.&#8221;</font>

        <p>

      <td>
        <p>

    Reclassify as editorial. Pass on to editor, wording roughly as proposed.<tr valign="top">
      <td>
        <p>US 95

      <td>
        <p>30.1.3

      <td>
        <p>1

      <td>
        <p>te

      <td>
        <p>&#8220;native_handle_type&#8221; is a typedef, not a
        class member.

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Several classes
        described in this Clause have a member native_handle (of
        type native_handle_type) . The

        <p align="left">
        presence of this member and its semantics is implementation
        defined. [ Note: This member allows implementations to
        provide access to implementation details. The name of the
        member and the type are specified to facilitate portable
        compile-time detection. Actual use of this member or the
        corresponding type is inherently non-portable. &#8212;end
        note ]

        <p align="left"><br>

      <td>
        <p>

    Not a defect. native_handle_type is a typedef, but it is also a member of 
    the classes in question.<tr valign="top">
      <td>
        <p>US 96

      <td>
        <p>30.1.4

      <td>
        <p>2

      <td>
        <p>te

      <td>
        <p>There is no definition here for monotonic clock.

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">Implementations
        should use a <i>monotonic clock</i> to measure time for
        these functions. A monotonic clock measures real time, but
        cannot be set, and is guaranteed to have no negative clock
        jumps.

        <p align="left"><br>

      <td>
        <p>

    Create an issue, together with UK 322. Detlef will write the issue, but not 
    proposed wording. Refer also to sections [time.clock.req] and [time.clock.monotonic].<tr valign="top">
      <td>
        <p>UK<br>
        322

      <td>
        <p align="justify">30.1.4

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Not all systms
        can provide a monotonic clock. How are they expected to
        treat a _for function?

        <p align="left"><br>

      <td>
        <p align="left">Add at least a note explaining the intent
        for systems that do not support a monotonic clock.

      <td>
        <p>

    Create an issue, together with UK 96. Note that the specification as is 
    already allows a non-monotonic clock due to the word &quot;should&quot; rather than 
    &quot;shall&quot;. If this wording is kept, a footnote should be added to make the 
    meaning clear.<tr valign="top">
      <td>
        <p>UK<br>
        323

      <td>
        <p align="justify">30.2.1

      <td>
        <p align="justify">1

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The presence of
        a non-explicit variadic template constructor alongside an
        explicit single-argument constructor can lead to behaviour
        that is not intended: the variadic constructor will be
        selected for implicit conversions, defeating the purpose of
        the explicit single-argument constructor. Additionally the
        single-argument constructor is redundant; the variadic
        constructor can provide identical functionality with one
        *fewer* copies if the supplied func is an lvalue.

        <p align="left"><br>

      <td>
        <p align="left">Mark constructor template &lt;class F,
        class ...Args&gt; thread(F&amp;&amp; f, Args&amp;&amp;...
        args); as explicit and remove the single-argument
        constructor.

      <td>
        <p>

    Create an issue, goes to review. Attention: Howard. Group agrees with the 
    proposed resolution.<tr valign="top">
      <td>
        <p>UK<br>
        324

      <td>
        <p align="justify">30.2.1.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">thread::id
        objects should be as useable in hashing containers as they
        are in ordered associative containers.

        <p align="left"><br>

      <td>
        <p align="left">Add thread::id
        support for std::hash

        <p align="left"><br>

        <p align="left"><br>

        <p align="left"><br>

      <td>
        <p>

    Not a defect. See [unord.hash], where std::thread:id is already listed as a 
    required specialization for std::hash().<tr valign="top">
      <td>
        <p>JP 77

      <td>
        <p align="left">30.2.1.2

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">
        "CopyConstructible" and "MoveConstructible" in
        "<i>Requires:</i> F and each Ti in Args shall be
        CopyConstructible if an lvalue and otherwise
        MoveConstructible." are reflected by interface.

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">Add
        a concept for constructor of thread.

      <td>
        <p>

    Subset of US 93. Should be addressed under the issue corresponding to US 93.<tr valign="top">
      <td>
        <p>JP 78

      <td>
        <p align="left">30.2.1.2

      <td>
        <p align="left">
        4<sup>th</sup> <font size="2" style=
        "font-size: 11pt">para, 1<sup>st</sup> line</font>

        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">In
        "F and each Ti in Args", 'Ti' is not clear.

      <td>
        <p align="left" style="margin-top: 0.04in">
        Replace "Ti" with "args"

      <td>
        <p>

    Pass on to editor.<tr valign="top">
      <td>
        <p>US 97

      <td>
        <p>30.2.1.3

      <td>
        <p>1

      <td>
        <p>te

      <td>
        <p>detach-on-destruction may result in
        &#8220;escaped&#8221; threads accessing objects with
        bounded lifetime after the end of their lifetime.

      <td>
        <p>See document WG21 N2802=08-0312 written by Hans Boehm.

      <td>
        <p>

    Create an issue. To be discussed in full library group.<p>

    Later: straw poll 10-0, put N2802 Alternative 2 on formal motions page.<tr valign="top">
      <td>
        <p align="left">US 98

      <td>
        <p align="left">30.2.1.3,<br>
        30.2.1.4

      <td>
        <p align="left"><br>

      <td>
        <p align="left"><br>

      <td>
        <p align="left">The current defined behavior
        for the std::thread destructor is to detach the thread.
        Unfortunately, this behavior exposes programmers to tricky,
        hard-to-diagnose, undefined behavior.

      <td>
        <p align="left">
        Change destruction behavior to undefined behavior, with a
        note strongly encouraging termination. See the attached
        paper "Issues with the C++ Standard" under Chapter 30,
        "Implicit thread detach is harmful".

        <p align="left"><br>

      <td>
        <p>

    Duplicate of US 97.<tr valign="top">
      <td>
        <p>UK<br>
        325

      <td>
        <p align="justify">30.3.3

      <td>
        <p align="justify">2

      <td>
        <p align="justify">Te

      <td>
        <p align="left">We believe constexpr literal values should
        be a more natural expression of empty tag types than extern
        objects as it should improve the compilers ability to
        optimize the empty object away completely.

      <td>
        <p align="left">Replace the
        extern declarations: extern const defer_lock_t defer_lock;
        extern const try_to_lock_t try_to_lock; extern const
        adopt_lock_t adopt_lock; with constexpr values constexpr
        defer_lock_t defer_lock{}; constexpr try_to_lock_t
        try_to_lock{}; constexpr adopt_lock_t adopt_lock{};

        <p align="left"><br>

      <td>
        <p>

    Create an issue. Move to review, attention: Howard. The current 
    specification is a &quot;hack&quot;, and the proposed specification is a better 
    &quot;hack&quot;.<tr valign="top">
      <td>
        <p>UK<br>
        326

      <td>
        <p align="justify">30.3.3.2.1

      <td>
        <p align="justify">7

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The precondition
        that the mutex is not owned by this thread offers
        introduces the risk of un-necessary undefined behaviour
        into the program. The only time it matters whether the
        current thread owns the mutex is in the lock operation, and
        that will happen subsequent to construction in this case.
        The lock operation has the identical pre-condition, so
        there is nothing gained by asserting that precondition
        earlier and denying the program the right to get into a
        valid state before calling lock.

        <p align="left"><br>

      <td>
        <p align="left">Strike 30.3.3.2.1p7

      <td>
        <p>

    Create an issue. Move to review, attention: Howard. Proposed resolution is 
    fine.<tr valign="top">
      <td>
        <p>UK<br>
        327

      <td>
        <p align="justify">30.3.3.2.2

      <td>
        <p align="justify">4, 9, 14, 19

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Not clear what
        the specification for error condition
        resource_deadlock_would_occur means. It is perfectly
        possible for this thread to own the mutex without setting
        owns to true on this specific lock object. It is also
        possible for lock operations to succeed even if the thread
        does own the mutex, if the mutex is recursive. Likewise, if
        the mutex is not recursive and the mutex has been locked
        externally, it is not always possible to know that this
        error condition should be raised, depending on the host
        operating system facilities. It is possible that 'i.e.' was
        supposed to be 'e.g.' and that suggests that recursive
        locks are not allowed. That makes sense, as the
        exposition-only member owns is boolean and not a integer to
        count recursive locks.

        <p align="left"><br>

      <td>
        <p align="left">Add a precondition !owns. Change the 'i.e.'
        in the error condition to be 'e.g.' to allow for this
        condition to propogate deadlock detection by the host OS.

      <td>
        <p>

    Create an issue. Assigned to Lawrence Crowl. Note: not sure what try_lock 
    means for recursive locks when you are the owner. POSIX has language on 
    this, which should ideally be followed. Proposed fix is not quite right, for 
    example, try_lock should have different wording from lock.<tr valign="top">
      <td>
        <p>UK<br>
        328

      <td>
        <p align="justify">30.3.3.2.2

      <td>
        <p align="justify">20

      <td>
        <p align="justify">Te

      <td>
        <p align="left">There is a missing precondition that owns
        is true, or an if(owns) test is missing from the effect
        clause

      <td>
        <p align="left">Add a
        precondition that owns == true. Add an error condition to
        detect a violation, rather than yield undefined behaviour.

        <p align="left"><br>

      <td>
        <p>

    Handle in same issue as UK 327. Also uncertain that the proposed resolution 
    is the correct one.<tr valign="top">
      <td>
        <p>UK<br>
        329

      <td>
        <p align="justify">30.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">future, promise and packaged_task provide a
        framework for creating future values, but a simple function
        to tie all three components together is missing. Note that
        we only need a *simple* facility for C++0x. Advanced thread
        pools are to be left for TR2.

      <td>
        <p align="left">Provide a simple
        function along the lines of: template&lt; typename F,
        typename ... Args &gt; requires Callable&lt; F, Args...
        &gt; future&lt; Callable::result_type &gt; async(
        F&amp;&amp; f, Args &amp;&amp; ... ); Semantics are similar
        to creating a thread object with a packaged_task invoking f
        with forward&lt;Args&gt;(args...) but details are left
        unspecified to allow different scheduling and thread
        spawning implementations. It is unspecified whether a task
        submitted to async is run on its own thread or a thread
        previously used for another async task. If a call to async
        succeeds, it shall be safe to wait for it from any thread.
        The state of thread_local variables shall be preserved
        during async calls. No two incomplete async tasks shall see
        the same value of this_thread::get_id(). [Note: this
        effectively forces new tasks to be run on a new thread, or
        a fixed-size pool with no queue. If the library is unable
        to spawn a new thread or there are no free worker threads
        then the async call should fail.]

        <p align="left"><br>

      <td>
        <p>

    Not a defect. This class of feature has been rejected by the committee as a 
    whole multiple times.<tr valign="top">
      <td>
        <p>UK<br>
        330

      <td>
        <p align="justify">30.5.1

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">30.5.1 (and then 30.5.7) refer to a
        specialisation of
        constructible_with_allocator_prefix&lt;&gt; However this
        trait is not in the CD, so references to it should be
        removed.

      <td>
        <p align="left">Remove the
        reference to constructible_with_allocator_prefix in 30.5.1
        Remove paragraph 30.5.7

        <p align="left"><br>

      <td>
        <p>

    Related to JP 79 and therefore subset of US 93. Should be addressed under 
    the issue corresponding to US 93.<tr valign="top">
      <td>
        <p>JP 79

      <td>
        <p align="left">30.5.1

      <td>
        <p align="left"><br>

      <td>
        <p>te

      <td>
        <p align="left" style="margin-top: 0.04in">The
        concept of UsesAllocator and Allocator should be used.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class R, class Alloc&gt;

        <p align="left">
        struct uses_allocator&lt;promise&lt;R&gt;, Alloc&gt;;

        <p align="left">
        template &lt;class R&gt;

        <p align="left">
        struct
        constructible_with_allocator_prefix&lt;promise&lt;R&gt;
        &gt;;

        <p align="left">
        &nbsp;

        <p align="left">
        should be

        <p align="left">
        &nbsp;

        <p align="left">
        template&lt;class R, Allocator Alloc&gt;

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">concept_map
        UsesAllocator&lt;promise&lt;R&gt;, Alloc&gt;;

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p>

    Subset of US 93. Should be addressed under the issue corresponding to US 93.<tr valign="top">
      <td>
        <p>UK<br>
        331

      <td>
        <p align="justify">30.5.3

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Not clear what
        it means for a public constructor to be 'exposition only'.
        If the intent is purely to support the library calling this
        constructor then it can be made private and accessed
        through friendship. Otherwise it should be documented for
        public consumption.

        <p align="left"><br>

      <td>
        <p align="left">Declare the constructor as private with a
        note about intended friendship, or remove the
        exposition-only comment and document the semantics.

      <td>
        <p>

    Create an issue. Assigned to Detlef. Suggested resolution probably makes 
    sense.<tr valign="top">
      <td>
        <p>UK<br>
        332

      <td>
        <p align="justify">30.5.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ed

      <td>
        <p align="left">It is not clear
        without reference to the original proposal how to use a
        future. In particular, the only way for the user to
        construct a future is via the promise API which is
        documented after the presentation of future. Most library
        clauses feature a small description of their components and
        intended use, it would be most useful in this case.

        <p align="left"><br>

      <td>
        <p align="left">Provide a small introductory paragraph,
        docuenting intended purpose of the future class template
        and the way futures can only be created via the promise
        API.

      <td>
        <p>

    Pass on to editor. Detlef has volunteered to provide some wording.<tr valign="top">
      <td>
        <p>UK<br>
        333

      <td>
        <p align="justify">30.5.4

      <td>
        <p align="justify">5

      <td>
        <p align="justify">Ge

      <td>
        <p align="left">We expect the complicated 3-signature
        specifcation for future::get() to be simplified to a single
        signature with a requires clause by the application of
        concepts.

      <td>
        <p align="left">Requires fully baked concepts for clause 30

      <td>
        <p>

    Subset of US 93. Should be addressed under the issue corresponding to US 93.<tr valign="top">
      <td>
        <p>UK<br>
        334

      <td>
        <p align="justify">30.5.4

      <td>
        <p align="justify">5

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Behaviour of
        get() is undefined if calling get() while not is_ready().
        The intent is that get() is a blocking call, and will wait
        for the future to become ready.

        <p align="left"><br>

      <td>
        <p align="left">Effects: If is_ready() would return false,
        block on the asynchronous result associated with *this.

      <td>
        <p>

    Create an issue. Move to review, attention: Howard. Proposed resolution is 
    fine.<tr valign="top">
      <td>
        <p>UK<br>
        335

      <td>
        <p align="justify">30.5.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">
        std::unique_future is MoveConstructible, so you can
        transfer the association with an asynchronous result from
        one instance to another. However, there is no way to
        determine whether or not an instance has been moved from,
        and therefore whether or not it is safe to wait for it.
        std::promise&lt;int&gt; p; std::unique_future&lt;int&gt;
        uf(p.get_future()); std::unique_future&lt;int&gt;
        uf2(std::move(uf)); uf.wait(); // oops, uf has no result to
        wait for.

        <p align="left"><br>

      <td>
        <p align="left">Add a "waitable()" function to
        unique_future (and shared_future) akin to
        std::thread::joinable(), which returns true if there is an
        associated result to wait for (whether or not it is ready).
        Then we can say: if(uf.waitable()) uf.wait();

      <td>
        <p>

    Create an issue. Requires input from Howard. Probably NAD.<tr valign="top">
      <td>
        <p>UK<br>
        336

      <td>
        <p align="justify">30.5.4

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">It is possible
        to transfer ownership of the asynchronous result from one
        unique_future instance to another via the move-constructor.
        However, it is not possible to transfer it back, and nor is
        it possible to create a default-constructed unique_future
        instance to use as a later move target. This unduly limits
        the use of unique_future in code. Also, the lack of a
        move-assignment operator restricts the use of unique_future
        in containers such as std::vector - vector::insert requires
        move-assignable for example.

        <p align="left"><br>

      <td>
        <p align="left">Add a default constructor with the
        semantics that it creates a unique_future with no
        associated asynchronous result. Add a move-assignment
        operator which transfers ownership.

      <td>
        <p>

    Create an issue. Detlef will look into it.<tr valign="top">
      <td>
        <p>JP 80

      <td>
        <p align="left">30.5.4 ,<br>
        30.5.5

      <td>
        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left">
        Typo, duplicated "&gt;"

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">"class
        Period&gt;&gt;"

        <p align="left" style="margin-top: 0.04in">
        <br>

      <td>
        <p align="left" style="margin-top: 0.04in">
        Remove one

      <td>
        <p>

    Pass on to editor.<tr valign="top">
      <td>
        <p>UK<br>
        337

      <td>
        <p align="justify">30.5.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">shared_future
        should support an efficient move constructor that can avoid
        unnecessary manipulation of a reference count, much like
        shared_ptr

        <p align="left"><br>

      <td>
        <p align="left">Add a move constructor

      <td>
        <p>

    Create an issue. Detlef will look into it.<tr valign="top">
      <td>
        <p>UK<br>
        338

      <td>
        <p align="justify">30.5.5

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">shared_future is currently
        CopyConstructible, but not CopyAssignable. This is
        inconsistent with shared_ptr, and will surprise users.
        Users will then write work-arounds to provide this
        behaviour. We should provide it simply and efficiently as
        part of shared_future. Note that since the shared_future
        member functions for accessing the state are all declared
        const, the original usage of an immutable shared_future
        value that can be freely copied by multiple threads can be
        retained by declaring such an instance as "const
        shared_future".

      <td>
        <p align="left">Remove "=delete"
        from the copy-assignment operator of shared_future. Add a
        move-constructor shared_future(shared_future&amp;&amp;
        rhs), and a move-assignment operator shared_future&amp;
        operator=(shared_future&amp;&amp; rhs). The postcondition
        for the copy-assignment operator is that *this has the same
        associated state as rhs. The postcondition for the
        move-constructor and move assignment is that *this has the
        same associated as rhs had before the
        constructor/assignment call and that rhs has no associated
        state.

        <p align="left"><br>

      <td>
        <p>

    Create an issue. Detlef will look into it.<tr valign="top">
      <td>
        <p>UK<br>
        339

      <td>
        <p align="justify">30.5.6

      <td>
        <p align="justify">6, 7

      <td>
        <p align="justify">Te

      <td>
        <p align="left">Move assignment is goiing in the wrong
        direction, assigning from *this to the passed rvalue, and
        then returning a reference to an unusable *this

      <td>
        <p align="left">Strike 6. 7
        Postcondition: associated state of *this is the same as the
        associated state of rhs before the call. rhs has no
        associated state.

        <p align="left"><br>

      <td>
        <p>

    Create an issue. Move to review, attention: Howard. Proposed resolution is 
    fine.<tr valign="top">
      <td>
        <p>UK<br>
        340

      <td>
        <p align="justify">30.5.6

      <td>
        <p align="justify">11, 12, 13

      <td>
        <p align="justify">Te

      <td>
        <p align="left">There is an
        implied postcondition that the state of the promise is
        transferred into the future leaving the promise with no
        associated state. It should be spelled out.

        <p align="left"><br>

      <td>
        <p align="left">Postcondition: *this has no associated
        state.

      <td>
        <p>

    Create an issue. Move to review, attention: Howard. Proposed resolution is 
    fine.<tr valign="top">
      <td>
        <p>UK<br>
        341

      <td>
        <p align="justify">30.5.6

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">promise::swap accepts its parameter by
        lvalue reference. This is inconsistent with other types
        that provide a swap member function, where those swap
        functions accept an rvalue reference

      <td>
        <p align="left">Change promise::swap to take an rvalue
        reference.

      <td>
        <p>

    Create an issue. Detlef will look into it. Probably ready as it.<tr valign="top">
      <td>
        <p>UK<br>
        342

      <td>
        <p align="justify">30.5.6

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Te

      <td>
        <p align="left">std::promise is
        missing a non-member overload of swap. This is inconsistent
        with other types that provide a swap member function

        <p align="left"><br>

      <td>
        <p align="left">Add a non-member overload void
        swap(promise&amp;&amp; x,promise&amp;&amp; y){ x.swap(y); }

      <td>
        <p>

    Create an issue. Move to review, attention: Howard. Detlef will also look 
    into it.<tr valign="top">
      <td>
        <p>UK<br>
        343

      <td>
        <p align="justify">30.5.6

      <td>
        <p align="justify">3

      <td>
        <p align="justify">Te

      <td>
        <p align="left">The move constructor of a std::promise
        object does not need to allocate any memory, so the
        move-construct-with-allocator overload of the constructor
        is superfluous.

      <td>
        <p align="left">Remove the
        constructor with the signature template &lt;class
        Allocator&gt; promise(allocator_arg_t, const Allocator&amp;
        a, promise&amp; rhs);

        <p align="left"><br>

      <td>
        <p>

    Create an issue. Detlef will look into it. Will solicit feedback from Pablo. 
    Note that &quot;rhs&quot; argument should also be an rvalue reference in any case.<tr valign="top">
      <td>
        <p>JP 81

      <td>
        <p align="left">30.5.8

      <td>
        <p align="left"><br>

      <td>
        <p>ed

      <td>
        <p align="left" style="margin-top: 0.04in">
        There are not requirements for F and a concept of Allocator
        dose not use.

      <td>
        <p align="left">
        Correct as follows.

        <p align="left">
        <br>

        <p align="left">
        template &lt;class F&gt;

        <p align="left">
        explicit packaged_task(F f);

        <p align="left">
        template &lt;class F, class Allocator&gt;

        <p align="left">
        explicit packaged_task(allocator_arg_t, const
        Allocator&amp; a, F f);

        <p align="left">
        template &lt;class F&gt;

        <p align="left">
        explicit packaged_task(F&amp;&amp; f);

        <p align="left">
        template &lt;class F, class Allocator&gt;

        <p align="left">
        explicit packaged_task(allocator_arg_t, const
        Allocator&amp; a, F&amp;&amp; f);

        <p align="left">
        &nbsp;

        <p align="left">
        should be

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class F&gt;

        <p align="left">
        <u>requires CopyConstructible&lt;F&gt; &amp;&amp;
        Callable&lt;F, ArgTypes...&gt;</u>

        <p align="left">
        &amp;&amp; Convertible&lt;Callable&lt;F,
        ArgTypes...&gt;::result_type, R&gt;

        <p align="left">
        explicit packaged_task(F f);

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class F, <u>Allocator Alloc</u>&gt;

        <p align="left">
        <u>requires CopyConstructible&lt;F&gt; &amp;&amp;
        Callable&lt;F, ArgTypes...&gt;</u>

        <p align="left">
        &amp;&amp; Convertible&lt;Callable&lt;F,
        ArgTypes...&gt;::result_type, R&gt;

        <p align="left">
        explicit packaged_task(allocator_arg_t, const
        <u>Alloc</u>&amp; a, F f);

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class F&gt;

        <p align="left">
        <u>requires CopyConstructible&lt;F&gt; &amp;&amp;
        Callable&lt;F, ArgTypes...&gt;</u>

        <p align="left">
        &amp;&amp; Convertible&lt;Callable&lt;F,
        ArgTypes...&gt;::result_type, R&gt;

        <p align="left">
        explicit packaged_task(F&amp;&amp; f);

        <p align="left">
        &nbsp;

        <p align="left">
        template &lt;class F, <u>Allocator Alloc</u>&gt;

        <p align="left">
        <u>requires CopyConstructible&lt;F&gt; &amp;&amp;
        Callable&lt;F, ArgTypes...&gt;</u>

        <p align="left">
        &amp;&amp; Convertible&lt;Callable&lt;F,
        ArgTypes...&gt;::result_type, R&gt;

        <p align="left" style=
        "margin-top: 0.04in; margin-bottom: 0.04in">explicit
        packaged_task(allocator_arg_t, const <u>Alloc</u>&amp; a,
        F&amp;&amp; f);

        <td>
        <p>

    Subset of US 93. Should be addressed under the issue corresponding to US 93. 
    We do not consider this to be an editorial change.<tr valign="top">
      <td>
        <p>DE-23

      <td>
        <p>Annex B

      <td>
        <p>p2

      <td>
        <p>te

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">DE-23 Recursive
        use of constexpr functions appears to be permitted. Since
        such functions may be required to be evaluated at
        compile-time, Annex B "implementation quantities" should
        specify a maximum depth of recursion.

        <td>
        <p>In Annex B, specify a recursion depth of 256 or a larger
        value.

      <td>
        <p>

    DE 23: Create issue, share with DE 25. See N2826. Attention: core group.<tr valign="top">
      <td>
        <p>DE-24

      <td>
        <p>Annex B

      <td>
        <p>p2

      <td>
        <p>te

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">DE-24 The
        number of placeholders for "bind" is implementation-defined
        in 20.7.12.1.4, but no minimum is suggested in Annex B.<br>

      <td>
        <p>Add a miminum of 10 placeholders to Annex B.

      <td>
        <p>

    Create issue, proposed resolution as in comment. Attention: LWG subgroup 2. 
    Note the section in N2800 is actually 20.6.12.1.4 [func.bind.place].<tr valign="top">
      <td>
        <p>DE-25

      <td>
        <p>Annex B

      <td>
        <p>p2

      <td>
        <p>te

      <td>
        <p style=
        "margin-top: 0.04in; margin-bottom: 0.04in">DE-25
        Specifying a minimum of 17 recursively nested template
        instantiations is too small for practical purposes. The
        limit is too high to effectively limit compiler resource
        usage, see
        http://ubiety.uwaterloo.ca/~tveldhui/papers/2003/turing.pdf
        . The conclusion is that the metric "number of recursively
        nested template instantiations" is inapposite.

        <td>
        <p>Remove the bullet "Recursively nested template
        instantiations [17]".

      <td>
        <p>

    DE 25: Create issue, share with DE 23. Attention: core group.<tr valign="top">
      <td>
        <p>FR 38

      <td>
        <p>C.2<br>
        [diffs.<br>
        library]

      <td>
        <p>1

      <td>
        <p>ed

      <td>
        <p>What is ISO/IEC 1990:9899/DAM
        1? My guess is that's a typo for ISO/IEC

        <p>9899/Amd.1:1995 which I'd
        have expected to be referenced here (the tables

        <p>make reference to things
        which were introduced by Amd.1).

        <td>
        <p>One need probably a reference
        to the document which introduce char16_t and

        <p>char32_t in C (ISO/IEC TR 19769:2004?).

      <td>
        <p>

    Create issue. Document in question should be C99, not C90+ammendment1. The 
    rest of the section requires careful review for completeness. Example &lt;cstdint&gt; 
    18.3.1 [csdtint.sym]. Assign to C liasons.<tr valign="top">
      <td>
        <p>UK<br>
        344

      <td>
        <p align="justify">Appendix D

      <td>
        <p align="justify"><br>

      <td>
        <p align="justify">Ge

      <td>
        <p align="left">It is desirable to allow some mechanism to
        support phasing out of deprecated features in the future.
        Allowing compilers to implement a mode where deprecated
        features are not available is a good first step.

      <td>
        <p align="left">Add to the definition of deprecated
        features permission for compilers to maintain a
        conditionally supported mode where deprecated features can
        be disabled, so long as they also default to a mode where
        all deprecated features are supported.

      <td>
        <p>

    Deals with deprecation, needs to be discussed in general group. Attention: 
    Bill Plaugher<p>

    Update 2009-03-04: Mark as NAD. Compiler switches are outside the domain of 
    the standard.<tr valign="top">
      <td>
        <p>FR 39

      <td>
        <p>Index

      <td>
        <p>

      <td>
        <p>ed

      <td>
        <p>Some definitions seem not
        indexed (such as /trivially copyable/ or

        <p>/sequenced before/), indexing
        them would be useful (and marking specially the page -- say
        bold or italic -- which reference to the definition would
        increase the usefulness; having a separate index of all
        definitions is something which could also be considered).

        <td>
        <p>

      <td>
        <p>

      Pass to the editor.</table><hr>