\documentclass{article}
\usepackage{hyperref}
\usepackage{vmargin}
\setpapersize{USletter}
\setmarginsrb{1in}{1in}{1in}{1in}{0.25in}{0.25in}{0in}{0in}

\newcommand{\comment}[2]{[{\Large\sc #1:} \textsf{#2}]}

\newcommand{\doug}[1]{\comment{Doug}{#1}}
\newcommand{\gary}[1]{\comment{Gary}{#1}}
\newcommand{\jaakko}[1]{\comment{Jaakko}{#1}}

\begin{document}

\markboth{Doc. no: N1603=04-0043}{Doc. no: N1603=04-0043}
\pagestyle{myheadings}

\title{Variadic Templates}
\author{Douglas Gregor \and Jaakko J\"arvi \and Gary Powell}
\date{}
\maketitle

\par\noindent Document number: N1603=04-0043
\par\noindent Date: \today
\par\noindent Project: Programming Language C++, Evolution Working Group
\par\noindent Reply-to: Douglas Gregor $<${\tt gregod@cs.rpi.edu}$>$

\section{Introduction}
This proposal directly addresses two problems:
\begin{itemize}
\item The inability to instantiate class and function templates with an arbitrarily-long list of template parameters.
\item The inability to pass an arbitrary number of arguments to a function in a type-safe manner.
\end{itemize}

The proposed resolution is to introduce a syntax and semantics for
variable-length template argument lists (usable with function templates
via explicit template argument specification and with class templates)
along with a method of argument ``bundling'' using the same mechanism to
pass an arbitrary number of function call arguments to a function in a
typesafe manner.

\section{Motivation}
\subsection{Variable-length template parameter lists}
Variable-length template parameter lists (variadic templates) allow a
class or function template to accept some number (possibly zero) of
template arguments beyond the number of template parameters specified.
This behavior can be simulated in C++ via a long list of defaulted
template parameters, e.g., a typelist wrapper may appear as:

\begin{verbatim}
struct unused;
template<typename T1 = unused, typename T2 = unused, 
         typename T3 = unused, typename T4 = unused, 
         /* up to */ typename TN = unused> class list;
\end{verbatim}

This technique is used by the Boost Tuples library~\cite{Tuples01},
for the specification of class template {\tt std::tuple<>} in the
library TR~\cite{Jarvi02}, and in the Boost metaprogramming
library~\cite{Gurtovoy02}. Unfortunately, this method leads to very
long type names in error messages (compilers tend to print the
defaulted arguments) and very long mangled names. It is also not
scalable to additional arguments without resorting to preprocessor
magic~\cite{Preprocessor01}. In all of these libraries (and presumably
many more), an implementation based on variadic template would be
shorter and would not suffer the limitations of the aforementioned
implementation. The declaration of the {\tt list<>} template above may
be:
\begin{verbatim}
template<...> class list;
\end{verbatim}

\subsection{Typesafe Variable-length Function Parameter Lists}
Variable-length function parameter lists allow more arguments to be
passed to a function than are declared by the function. This feature
is rarely used in C++ code (except for compatibility with C
libraries), because passing non-POD types through an ellipsis ({\tt
  ...}) invokes undefined behavior. However, a typesafe form of such a
feature would be useful in many contexts, e.g., for implementing a
typesafe C++ {\tt printf} that works for non-POD types. The lack of
such a facility has resulted in odd syntax for formatting in the
Boost.Format library~\cite{Krempp02}:
\begin{verbatim}
format("writing %1%, x=%2%: %3%-th try") % "toto" % 40.23 % 50
\end{verbatim}

\section{Syntax and Semantics}
\subsection{Variadic templates}
\par The template parameter list to a function or class template can
be declared to accept an arbitrary number of extra template arguments
by terminating it with ``...'' optionally followed by an identifier
through which these extra arguments can be accessed.
Any number of template
parameters may precede the ``...''. Thus we can define, for instance,
a class {\tt Foo} accepting a template type parameter followed by an
arbitrary number of template arguments as:
\begin{verbatim}
template<typename T, ... Args> class Foo;
\end{verbatim}

\noindent
Here, {\tt T} is the name of the template type parameter and {\tt
  Args} is the name of a ``template parameter pack'' containing the
(possibly empty) set of template arguments given to {\tt Foo}.
Template parameter packs may contain template type, non-type, and
template template arguments and are represented as an unspecified
class type.

Function templates may also be variadic templates in the same manner
as class templates.  Arguments can be specified explicitly when
calling the function template, e.g:

\begin{verbatim}
template<... Args> void f();
// ... 
f<int, double>(); // Args will be contain <int, double>
\end{verbatim}
The next section describes when the types of the elements in 
a value parameter pack can be deduced from the argument types
of the call. 

\subsection{Typesafe variadic functions}
When a function template header contains a template parameter pack,
that template parameter pack may be used in the ``type'' of the final
function parameter, allowing the function to accept a variable number
of function parameters in a ``value parameter pack'' (or just
``parameter pack''). For instance, a typesafe C++ {\tt printf} may
be declared as:
\begin{verbatim}
template<... Args>
  void printf(const char* format, const Args&... args);
\end{verbatim}

\noindent The ellipsis indicates that the function ``parameter''
\texttt{args}
actually represents the ``unpacked'' parameters, so for a call to
\texttt{printf} with $N+1$ arguments, the signature is equivalent to
the pseudocode:

\begin{verbatim}
template<typename T1, typename T2, ..., typename TN>
  void printf(const char* format, const T1&, const T2&, ..., const TN&);
\end{verbatim}

\noindent 
Note that \texttt{Args} is used as a placeholder in the type of the
\texttt{args} ``parameter'', and \texttt{Args} is replaced by each
implicitly-named template parameter while \texttt{args} is replaced by
each implicitly-named function parameter. Deduction of template
parameter packs from function call arguments proceeds as it would if
the parameters were explicitly enumerated as in the pseudocode
declaration of \texttt{print}. For instance, calling
\texttt{printf("\%e \%i", 3.14159, 17)} would deduce \texttt{Args =
  <double,int>}, with the parameter types \texttt{const double\&} and
\texttt{const int\&}.

\subsection{Unpacking template and value parameter packs}
The ellipsis operator unpacks all of the values (or template
arguments) within a value (or template) parameter pack into a list of
arguments for use in function call argument lists, template argument
lists, and function types. For instance, given a template parameter pack
{\tt Elements}, we can create a {\tt tuple} storing elements of those
types via {\tt tuple<Elements...>}. Should we wish to append an {\tt int}
to the end of the tuple, we may write {\tt tuple<Elements..., int>}.

Value parameter packs are similarly expanded within a function call,
so that, for instance, a {\tt printf}-like function may pass the
remaining arguments on like this:
\begin{verbatim}
template<typename T, ... Args>
  void printf(const char* s, const T& next, Args... args)
  {
    // print characters in s until we hit a formatting command
    // format ``next'' by converting it as appropriate
    // move s after the formatting command
    printf(s, args...); 
  }

  void printf(const char* s)
  {
    // print characters in s, verifying that there is no 
    // formatting command
  }
\end{verbatim}

Note that when the parameter pack is empty, it expands to zero
arguments (in the function call or template argument list). Thus, the
recursion terminates for \texttt{printf} when {\tt args} is empty,
calling the second overload of \texttt{printf}.

The ellipsis operator is valid following any of these constructs:
\begin{itemize}
\item An argument in a function call argument list.
\item An argument in a template argument list.
\item The type of a parameter in a parameter declaration
\end{itemize}

In each case, the text of the argument (or parameter) preceding the
ellipsis is treated as a pattern to be repeated for each element in
the parameter pack as individual arguments (or parameters) within the
current argument (or parameter) list. In the pattern, the parameter
pack is a placeholder for the positions where the elements in the
parameter pack will be substituted. Fig.~\ref{fig:expansions}
illustrates the expansions of several template and value parameter
packs. In the figure, \texttt{X} is a template parameter pack
containing template parameters \texttt{X1}, \texttt{X2}, ....,
\texttt{XN} and, when all \texttt{Xi} are types, \texttt{x} is a value
parameter pack of type \texttt{X} such that \texttt{x1}, \texttt{x2},
..., \texttt{xN} are the contained values. Similarly, \texttt{Y} is a
template parameter pack of size \texttt{M}, with associated
\texttt{Yi}, \texttt{y}, and \texttt{yi}. Additionally, assume the
following declarations:
\begin{verbatim}
template<...> class list;
template<...> class vector;
template<... Args> void f(Args... args);
template<... Args> void g(Args... args;)
\end{verbatim}

\begin{figure}[h]
\centering
\begin{tabular}{l|l}
\textbf{Types \& Expressions} & \textbf{Expansion} \\\hline
\texttt{list<X...>} & \texttt{list<X1, X2, ..., XN>} \\
\texttt{list<int, X..., float>} & \texttt{list<int, X1, X2, ..., XN,
  float>} \\
\texttt{f(x...)} & \texttt{f(x1, x2, ..., xN)} \\
\texttt{f(17, x..., 3.14159)} & \texttt{f(17, x1, x2, ..., xN,
  3.14159)} \\
\texttt{int (*)(X...)} & \texttt{int (*)(X1, X2, ..., XN)} \\
\texttt{list<typename add\_pointer<X>::type...>} &
\texttt{list<typename add\_pointer<X1>::type,} \\
& \qquad\texttt{{ }typename add\_pointer<X2>::type,} \\
& \qquad\texttt{{ }typename add\_pointer<XN>::type>} \\

\texttt{f(x*x)} & \texttt{f(x1*x1, x2*x2, ..., xN*xN)} \\
\texttt{f(g(x, y...)...)} & \texttt{f(g(x1, y1, y2, ..., yM),} \\
& \texttt{{ }{ }g(x2, y1, y2, ..., yM),} \\
& \texttt{{ }{ }. . .} \\
& \texttt{{ }{ }g(xN, y1, y2, ..., yM))} \\
\end{tabular}
\caption{Illustration of the expansions of types and
  expressions using template and value parameter packs.}
\label{fig:expansions}
\end{figure}

Ellipsis operators may be nested, with each ellipsis binding to the
argument text it follows. The same parameter pack may appear in
multiple places within the argument text (and all will be replaced
with the same type or argument from the parameter pack in each
expansion). However, different parameter packs must not be present
within the same argument text unless the ellipsis operators are
nested. A program that attempts to apply the ellipsis operator to a
type or value that is not a parameter pack is ill-formed.

\subsection{Deducing template parameter packs from types}
Template parameter packs can be deduced from template argument lists
and function parameter lists, by packing the list of integral constant
expressions, templates, and types into the template parameter pack.

Example: we can define a template {\tt function\_traits} that extracts
the result type and argument types of a function:
\begin{verbatim}
template<...> class tuple;

template<...> struct function_traits;

template<typename R, ... Args> 
  struct function_traits<R(Args...)>
  { 
    typedef R result_type; 
    typedef tuple<Args...> argument_types;
  };
\end{verbatim}

Example: we can write a function accepting a tuple with an arbitrary
number of elements in it:
\begin{verbatim}
template<...> class tuple;

template<... Elements>
  void eat_tuple(tuple<Elements...>);
\end{verbatim}

Example: We can also split a template class into its template name and
template arguments, a task that could drastically reduce the amount of
code required to implement the meta-lambda facility of the Boost
Metaprogramming Library~\cite{Gurtovoy02}. For instance:

\begin{verbatim}
template<typename T> struct split_template_class;

template<template<... Args> class T> 
  struct split_template_class<T<Args...> >;
\end{verbatim}

\subsection{Explicit template argument specification}
If template arguments are explicitly specified when naming a function
template, the function template header is terminated with a template
parameter pack, and there are at least as many template arguments as
there are template parameters to the function (not including the
template parameter pack), all template arguments beyond the last one
required for the function's template parameters will comprise the
template parameter pack.

Example:
\begin{verbatim}
template<... Args> void f();

f<int, double>(); // OK: Args is <int, double>
f<>();            // OK: Args is empty
f();              // error: Args cannot be deduced
\end{verbatim}

\subsection{Partial ordering of variadic class template partial specializations}
The class template partial specialization partial ordering rules will
need to be augmented to include partial ordering with variadic
templates. This is the only deviation from the purely syntactic nature
of variadic templates. Intuitively, a binding to a parameter that
falls into a template's variable-length argument list is weaker than a
binding to a specified template parameter. For instance, given:

\begin{verbatim}
template<...> struct foo;
template<typename T, ...> struct foo<T>; // #1
template<typename T, typename U> struct foo<T, U>; // #2
\end{verbatim}

Partial specialization \#2 is more specialized than partial
specialization \#1 because \#2 requires that the second template
argument by a type (and not a template or acceptable
literal). 

Formalizing this notion, we introduce a new type of template
parameter we call a template {\em variant} parameter. Template variant
parameters cannot be declared explicitly, but occur implicitly as
parameters for variadic templates. However, any template argument
(type, nontype, or template) can be passed to a template {\em variant}
parameter. 

Paragraph 3 of 14.5.5.2 [temp.func.order] describes the rules for
transforming a template for the purpose of partial ordering. To
support partial ordering with variadic templates, introduce two
additional bullets:
\begin{itemize}
\item If after removing the variable-length template parameter list
  designator \verb|...| from both templates the template parameter lists of the
  templates are of different length, append unique template variant
  parameters to the shorter template parameter list until the template
  parameter lists are of equal length.
\item A binding of an argument to a variant parameter is weaker than a
  binding of an argument to a parameter of the same kind.
\end{itemize}

\subsection{Overloading}
\label{overloading}
The overloading rules need two minor changes to accomodate variadic template:
\begin{itemize}
\item Template variadic functions follow the same overloading rules as
  non-template variadic functions.
\item If two overloads differ only in that one is a variadic template
  function and the other is a non-template variadic function, the
  template variadic function is more specialized.
\end{itemize}

Thus we prefer the typesafe variadic functions to unsafe variadic
functions, even though these rules conflict with 13.3.3p1, which
prefers non-template functions to template functions when the
conversion sequences are otherwise equal.

\subsection{The types of variadic templates}
A template parameter pack is an unspecified, compiler-specific class
type; value parameter packs are instances of the corresponding
template parameter pack. Any program attempting to instantiate a value
parameter pack whose corresponding template parameter pack contains
nontype template parameters or template template parameters is
ill-formed. 

The type of an instantiation of a typesafe variadic function is
equivalent to the type of a nontemplate function with all template
parameters substituted and both template and value parameter packs
unpacked completely. Revisiting the {\tt printf} definition

\begin{verbatim}
template<typename T, ... Args>
  void printf(const char*, const T&, const Args&... args);
\end{verbatim}

and given a call {\tt printf(``\%i:\%f'', 5, 3.14f)}, the type of this
{\tt printf} instantiation will be {\tt void(const char*, const int\&,
  const float\&)}. This type compatibility is logical within the
context of templates (i.e., it follows the existing behavior of
instantiations of function templates) and useful in the
implementation of the polymorphic function adaptors~\cite{Gregor02}
proposal, which has placed the most stress on the formulation of
variadic templates thus far.

The class type of a template parameter pack \texttt{<T1, T2, ..., TN}
contains unnamed values here denoted \texttt{t1, t2, ..., tN} of types
\texttt{T1, T2, ..., TN}, respectively, and must provide the following
when all \texttt{Ti} are types:
\begin{itemize}
\item A default constructor that default-initializes \texttt{t1, t2,
    ..., tN}, if the types \texttt{<T1, T2, ..., TN} have default
  constructors.
\item A copy constructor that copy-constructs \texttt{t1, t2,
    ..., tN}, if the types \texttt{<T1, T2, ..., TN} have copy
  constructors.
\item A constructor that accepts $N$ arguments, of types \texttt{cv1
    T1\&, cv2 t2\&, ..., cvN tN\&}, where \texttt{cvi} is equivalent to
  the cv-qualifiers in the copy constructor of type \texttt{Ti}, and
  copy-constructs each \texttt{ti} from the corresponding argument.

\item A copy assignment operator that assigns to each \texttt{ti} from
  the corresponding \texttt{ti} of the parameter pack on the
  right-hand side.
\end{itemize}

Value parameter packs may (but are not required to) be implemented
with the following pseudocode:
\begin{verbatim}
template<typename T1, typename T2, ..., typename TN>
  struct __pp
  {
    // implicit default constructor
    // implicit copy constructor
    // implicit copy assignment operator
   
    __pp(cv1 T1& a1, cv2 T2& a2, ..., cvN TN& aN)
      : t1(a1), t2(a2), ..., tN(aN) {}

    T1 t1;
    T2 t2;
      .
      .
      .
    TN tN;
  };
\end{verbatim}

Implementations are permitted to perform an extra copy construction to
construct a parameter pack from the arguments passed to a function,
which may be unavoidable when variadic template functions are invoked
via a function pointer. However, since we make no restrictions on the
layout of parameter packs, and do not confine them to the same layout
as, e.g., a structure containing the same types as in the example
above, implementations may elide these copy constructions by
performing parameter pack layout in a manner that coincides with the
activation record for a particular platform.

\section{Examples}
To demonstrate the use of variadic templates, this section gives
skeletal implementations of four library components using variadic
templates,. All of these proposals were accepted by the library
working group into the first library TR, and are implementable to some
degree in C++03. However, all of them would benefit from variadic
templates in that the implementations can be more complete, more
useful, and more readable than their C++03 counterparts. The following
libraries are implemented:

\begin{itemize}
\item Member pointer adaptors~\cite{Dimov03a}
\item Tuples~\cite{Jarvi02}
\item Function object wrappers~\cite{Gregor02}
\item Function object binder~\cite{Dimov03b}
\end{itemize}

The implementations are not generally complete, but omit only features
that are irrelevant to the discussion of variadic template. The
implementations use several class templates (metafunctions) from the
type traits proposal~\cite{Maddock03}. Additionally, we use the
keyword {\tt auto} to make the examples cleaner and easier by omitting
the messy---but expressible--return types; however, this proposal does
not strictly depend on the {\tt decltype} proposal~\cite{Jarvi03}.

\subsection{Building Blocks}
\label{building_blocks}
The class template {\tt enable\_if} is used liberally to help guide
the overload process by eliminating candidates from the overload set
that would otherwise cause ambiguities or be selected when they
shouldn't be. It is defined as:

\small
\begin{verbatim}
template<bool Cond, typename T> struct enable_if;
template<typename T> struct enable_if<true, T> { typedef T type; };
template<typename T> struct enable_if<false, T> {};
\end{verbatim}
\normalsize

We can count the number of arguments in a parameter pack with this
simple class template, using {\tt integral\_constant} from the type
traits proposal~\cite{Maddock03} (part of the first library technical
report~\cite{Austern03}):

\small
\begin{verbatim}
// Count the number of arguments in a template parameter pack
template<...> struct count_args;

template<> struct count_args<> : integral_constant<int, 0> {};

template<typename T1, ... Args> struct count_args<T1, Args...>
  : integral_constant<int, (1 + count_args<Args...>::value)> {};
\end{verbatim}
\normalsize

\subsection{Member pointer adaptor implementation}
\label{mem_fnimpl}
The following code implements the enhanced member pointer adaptor
proposal~\cite{Dimov03a}. This implementation is complete.

\small
\begin{verbatim}
// Adaptor for member function pointers
template<typename Class, typename FunctionType>
struct mem_fn_adaptor
{
  typedef typename function_traits<FunctionType>::result_type result_type;

  mem_fn_adaptor(FunctionType Class::*pmf) : pmf(pmf) {}
  
  template<... Args>
  result_type operator()(Class& object, Args... args) const
    { return (object.*pmf)(args...); }

  template<... Args>
  result_type operator()(const Class& object, Args&... args) const
    { return (object.*pmf)(args...); }

  template<typename T, ... Args>
  typename enable_if<(!is_base_of<Class, T>::value), result_type>::type
  operator()(T& ptr, Args&... args) const
    { return ((*ptr).*pmf)(args...); }

  template<typename T, ... Args>
  typename enable_if<(!is_base_of<Class, T>::value), result_type>::type
  operator()(const T& ptr, Args&... args) const
    { return ((*ptr).*pmf)(args...); }

private:
  FunctionType Class::*pmf;
};

// Adaptor for member data pointers (for completeness only)
template<typename Class, typename T>
struct mem_ptr_adaptor
{
  typedef const T& result_type;

  mem_ptr_adaptor(T Class::*pm) : pm(pm) {}

  T& operator()(Class& object) const { return object.*pm; }
  const T& operator()(const Class& object) const { return object.*pm; }

  template<typename Ptr> 
  typename enable_if<(!is_base_of<Class, Ptr>::value), const T&>::type
    operator()(Ptr& ptr) const { return (*ptr).*pm; }

  template<typename Ptr> 
  typename enable_if<(!is_base_of<Class, Ptr>::value), const T&>::type
    operator()(const Ptr& ptr) const { return (*ptr).*pm; }

private:
  T Class::*pm;
};

template<typename Class, typename FunctionType>
typename enable_if<(is_function<FunctionType>::value), 
                   mem_fn_adaptor<Class, FunctionType> >::type
mem_fn(FunctionType Class::*pmf)
  { return mem_fn_adaptor<Class, FunctionType>(pmf); }

template<typename Class, typename T>
typename enable_if<(!is_function<T>::value), 
                   mem_ptr_adaptor<Class, T> >::type
mem_fn(T Class::*pm)
  { return mem_ptr_adaptor<Class, T>(pm); }
\end{verbatim}
\normalsize 

\subsection{Tuple implementation}
\label{tupleimpl}
The following code implements the interesting portions of the Tuple
proposal~\cite{Jarvi02} using variadic as proposed here. 

\small
\begin{verbatim}
// Derivation from tuple_base indicates that a type is a tuple
class tuple_base {};

// Determine if type T is a tuple
template<typename T>
struct is_tuple
  { static const bool value = is_base_of<tuple_base, T>::value; };

// A tuple of arbitrary length N
template<typename T1, ... Elements>
class tuple : public tuple_base 
{
  typedef typename add_reference<typename add_const<T1>::type>::type
    head_param_type;

public:
  typedef T1 head_type;
  typedef tuple<Elements...> tail_type;

  static const size_t size = 1 + tail_type::size;

  tuple() {}

  // enable_if condition ensures that we only match if N arguments are given
  template<... Tail> 
  explicit tuple(typename enable_if<(count_args<Args...>::value == size - 1),
                                    head_param_type>::type head,
                 Tail... tail)
    : head(head), tail(tail...) {}

  // enable_if condition only allows us to attempt implicit conversions
  // from tuples of the appropriate length
  template<typename Tuple>
  tuple(const Tuple& other,
        typename enable_if<(is_tuple<Tuple>::value && size == Tuple::size), 
                           void>::type* = 0)
    : head(other.head), tail(other.tail) {}

  // enable_if condition only allows us to attempt assignment from tuples of
  // the appropriate length
  template<typename Tuple>
  typename enable_if<(is_tuple<Tuple>::value && size == Tuple::size),
                     tuple&>::type
  operator=(const Tuple& tuple)
  {
    head = other.head;
    tail = other.tail;
    return *this;
  }

  head_type head;
  tail_type tail;
};

// Base case: a nullary tuple
template<> class tuple<> : public tuple_base 
{
public:
  static const size_t size = 0;
};

// Performs an arbitrary transform on each of the types in a
// tuple. This is a utility function, used by make_tuple.
template<typename MetaFun, typename Tuple, ... Rest>
  class transform_tuple_type
  {
    typedef typename Tuple::head_type old_head_type;
    typedef typename MetaFun::template apply<old_head_type>::type
      new_head_type;
    typedef typename Tuple::tail_type old_tail_type;
    typedef transform_tuple_type<MetaFun, old_tail_type, Rest, new_head_type>
      gen;
  public:
    typedef typename gen::type type;
  };

template<typename MetaFun, ... Rest>
  class transform_tuple_type<MetaFun, tuple<>, Rest>
  {
  public:
    typedef tuple<Rest> type;
  };

template<typename T>
  struct make_tuple_element_type
  {
    typedef T type;
  };

template<typename T>
  struct make_tuple_element_type<reference_wrapper<T> >
  {
    typedef T& type;
  };

template<... Elements> 
  auto make_tuple(const Elements&... elements)
  {
    typedef tuple<typename make_tuple_element_type<Elements>::type...>
      result_type;
    return result_type(elements...);
  }

// tie implementation
template<... Elements>
  tuple<Elements> tie(Elements&... elements)
  { return tuple<Elements&...>(elements...); }
\end{verbatim}
\normalsize

\subsection{Tuple algorithms implementation}
In this section we implement three ``core'' tuple algorithms.
Although there is not yet any proposal for these algorithms, they are
useful in practice and will be used in implementations within this
proposal.

The first tuple algorithm creates a tuple that is the reverse of the
input tuple.
\begin{verbatim}
template<... Args>
  tuple<Args> reverse(tuple<>, Args&... args)
  { return tuple<Args...>(args...); }

template<typename Tuple, ... Args>
  auto reverse(const Tuple& t, Args&... args)
  { 
    typedef typename Tuple::head_type head_type;
    typedef typename Tuple::tail_type tail_type;
    return reverse<tail_type, head_type>(t.tail, t.head, args...);
  }
\end{verbatim}

The second tuple algorithm illustrates the ability to convert a tuple into
a (value) parameter pack, so that the function call arguments can be passed
to a function object as a function call parameter. This allows us to store
the parameter pack as a tuple and manipulate it with the tuple algorithms
before using it
\begin{verbatim}
template<typename F, ... Args>
  auto apply(F f, tuple<>, Args&... args)
  { return f(args...); }

template<typename F, typename Tuple, ... Args>
  auto apply(F f, const Tuple& t, Args&... args)
  { return apply(f, t.tail, args..., t.head); }

template<typename F, typename Tuple, ... Args>
  auto apply(F f, Tuple& t, Args&... args)
  { return apply(f, t.tail, args..., t.head); }
\end{verbatim}

The final tuple algorithm represents a transformation on tuples,
similar to the {\tt transform} algorithm in the standard library.
\begin{verbatim}
template<typename F, ... Args>
  auto transform(tuple<>, F, Args&... args)
  { return make_tuple(args...); }

template<typename Tuple, typename F, ... Args>
  auto transform(const Tuple& t, F f, Args&... args)
  { return transform(t.tail, f, args..., f(t.head)); }
\end{verbatim}

\subsection{Function implementation}
\label{functionimpl}
This section implements the core interesting portions of class
template {\tt function} from the function object wrapper
proposal~\cite{Gregor02}. The implementation of this library is much
more subtle than that of the prior libraries, particularly the use of
template parameter deduction and explicit specification of function
template arguments to resolve the address of an overloaded function
within the constructor. The implementation is complete with one
exception: it does not properly support function pointers. The
modifications to account for function pointers are simple but are
outside the scope of this proposal.

\small
\begin{verbatim}
struct bad_function_call : public std::exception {};

template<typename> struct function;

template<typename R, ... ArgumentTypes>
  struct function<R(ArgumentTypes...)>
  {
    typedef R result_type;

    template<typename Functor>
      auto functor_invoker(ArgumentTypes&... args) const
      { return (*static_cast<Functor*>(functor))(args...); }
    
    template<typename Functor> 
      static void* functor_manager(void* ptr, bool clone)
      { 
        const Functor* functor = static_cast<Functor*>(ptr);
        if (clone) return new Functor(*functor); 
        else { delete functor; return 0; }
      }

    static void* trivial_manager(const void* ptr, bool)
    { return const_cast<void*>(ptr); }

    Function function::* invoker;
    mutable void*        functor;
    void* (*manager)(void*, bool /* clone or delete */);

    struct clear_type;

  public:
    function() : invoker(0), functor(0), manager(0) {}
    
    function(const function& other) : invoker(0), functor(0), manager(0)
      { 
        if (other.invoker) {
          invoker = other.invoker;
          functor = other.manager(other.functor, true);
          manager = other.manager;
        }
      }

    template<typename F> 
      function(F f, 
               typename enable_if<(!is_integral<F>::value, void*>::type = 0) 
        : invoker(0), functor(0), manager(0)
      {
        invoker = &function::functor_invoker<F>;
        functor = new Functor(f);
        manager = &functor_manager<F>;
      }

    template<typename F> 
      function(reference_wrapper<F> f) : invoker(0), functor(0), manager(0)
      { 
        invoker = &function::functor_invoker<F>;
        functor = &f.get();
        manager = &trivial_manager;
      }
    
    template<typename T, typename C> 
      function(T C::*pm) : invoker(0), functor(0), manager(0)
      { *this = std::mem_fn(pm); }

    function(clear_type*) : invoker(0), functor(0), manager(0) {}
    
    ~function() { if (invoker) manager(functor, false); }

    function& operator=(const function& other)
    {
      function tmp(other);
      tmp.swap(*this);
      return *this;
    }
    
    template<typename F> 
      typename enable_if<(!is_integral<F>::value, function&>::type
      operator=(F f)
      {
        function tmp(f);
        tmp.swap(*this);
        return *this;
      }
    
    function& operator=(clear_type*)
    {
      if (invoker) { 
        manager(functor, false);
        invoker = 0;
        functor = 0;
        manager = 0;
      }
    }

    operator bool() const { return invoker; }

    result_type operator()(ArgumentTypes... args) const
    {
      if (!invoker) throw bad_function_call;
      return (this->*invoker)(args...);
    }
    
    void swap(function& other)
    {
      using std::swap;
      swap(invoker, other.invoker);
      swap(functor, functor);
      swap(manager, manager);
    }
  };
\end{verbatim}
\normalsize

\subsection{Bind implementation}
\label{bindimpl}
The following code implements the enhanced binder
proposal~\cite{Dimov03b} using variadic templates and building on the
existing member pointer adaptor code. This implementation is complete,
with two exceptions (both of which require uninteresting but
nontrivial code, expressible in C++03):
\begin{itemize}
  \item {\tt result\_type} is not specified in {\tt binder}
  \item arity checking is not performed at bind time
\end{itemize}

\small
\begin{verbatim}
// Placeholders
template<int N> struct placeholder {};

namespace placeholders {
  typedef placeholder<1> _1;
  typedef placeholder<2> _2;
  typedef placeholder<3> _3;
}

template<typename T> struct is_placeholder : integral_constant<size_t, 0> {};

template<int N> 
struct is_placeholder<placeholder<N> > : integral_constant<size_t, N> {};

// Lambda
template<typename X> X& lambda(const reference_wrapper<X>& x)
  { return x.get(); }
template<typename X> X& lambda(X& x)
  { return x; }

// Get placeholder argument
template<typename T1, ... Args>
  T1& get_placeholder_arg(placeholder<1>, T1& t1, Args&...)
  { return t1; }

template<typename T1, typename T2, ... Args>
  T2& get_placeholder_arg(placeholder<2>, T1&, T2& t2, Args&...)
  { return t2; }

template<typename T1, typename T2, typename T3, ... Args>
  T2& get_placeholder_arg(placeholder<3>, T1&, T2&, T3& t3, Args&...)
  { return t3; }

template<int N, typename T1, typename T2, typename T3, ... Args>
  auto get_placeholder_arg(placeholder<N>, T1&, T2&, T3&, Args&... args)
  { return get_placeholder_arg(placeholder<N-3>(), args...); }

// Mu
template<typename X, typename Args> X& mu(reference_wrapper<X>& x, Args&)
  { return x.get(); }

template<typename X, typename Args>
auto 
mu(X&, Args& args, 
   typename enable_if<(is_placeholder<X>::value), void*>::type=0)
{ 
  return get_placeholder_arg(placeholder<is_placeholder<X>::value>(), args...);
}

template<typename X, typename Args>
  auto 
  mu(X& x, Args& args, 
     typename enable_if<(is_bind_expression<X>::value), void*>::type = 0)
  { return x(args...); }

template<typename X, typename Args> X& mu(X& x, Args&)
  { return x; }

// Return type of bind(...)
template<typename F, typename BoundArgs>
struct binder
{
  binder(const F& f, const BoundArgs& bound_args)
    : f(f), bound_args(bound_args) {}

  template<... Args> auto operator()(Args&... args)
    { return lambda(f)(mu(bound_args, args...)...); }

  template<... Args> auto operator()(Args&... args) const
    { return lambda(f)(mu(bound_args, args...)...); }

private:
  F f;
  BoundArgs bound_args;
};

// Helper to construct binder objects
template<typename F, typename BoundArgs>
  binder<F, BoundArgs> make_binder(F f, const BoundArgs& bound_args)
  { return binder<F, BoundArgs>(f, bound_args); }

// Determine if a type T is a binder type
template<typename T> struct is_bind_expression : integral_constant<bool, false> {};

template<typename F, typename BoundArgs>
struct is_bind_expression<binder<F, BoundArgs> > : integral_constant<bool, true> {};

// Bind overload for function objects and function pointers
template<typename F, ... BoundArgs>
  auto bind(F f, const BoundArgs&... bound_args)
  { return binder<F, BoundArgs>(f, bound_args); }

// Bind overload for member pointers (both function and data)
template<typename Class, typename T, ... BoundArgs>
  auto bind(T Class::*pm, const BoundArgs&... bound_args)
  { return make_binder(mem_fn(f), bound_args...); }
\end{verbatim}
\normalsize

\section{Alternatives \& Extensions}
\subsection{Extended template argument deduction}
One potential extension to this proposal we have considered is to
allow parameter packs to occur before the end of the template header
(so that multiple template parameter packs may be declared in a single
template header). This extension would then allow one to deduce
multiple parameter packs for, e.g., a function call:

\begin{verbatim}
struct PivotType {};

template<... Head, ... Tail>
void split(Head h, PivotType p, Tail t);
\end{verbatim}

Another example of this would be a ``pop\_back'' operation on a
parameter pack (here we place the result in a tuple):

\begin{verbatim}
template<... Elements, typename T>
  tuple<Elements> pop_back(Elements elements, const T&)
  { return tuple<Elements>(elements); }
\end{verbatim}

While we acknowledge that there may be some benefit to introducing
these extensions, we feel that the benefits are not sufficient to
outweight the cost of introducing yet more overloading rules to
account for this cases. We feel that the few operations that would
benefit may better be accomplished by working with a true
heterogeneous data structure such as a tuple.

\section{Revision history}
\begin{itemize}
\item \textbf{Since N1483=03-0066:} 
  \begin{itemize}
  \item Variadic templates no longer solve the forwarding problem for
    arguments. 
  \item Parameter packs are no longer tuples; instead, they are a
    typeless entity that may only be declared and unpacked.
  \item Introduced the ability to deduce a template parameter pack
    from a type (or list of template parameters).
  \item Eliminated the \texttt{apply}, \texttt{integral\_constant},
    and \texttt{template\_template\_arg} kludges.
  \end{itemize}
\end{itemize}

\section{Acknowledgements}
Discussions among Daveed Vandevoorde, David Abrahams, Mat Marcus, John
Spicer, and Jaakko J\"arvi resulted in the new syntax for
unpacking arguments using ``...''. This proposal has been greatly
improvement with their feedback. David Abrahams noticed that ``...''
could be used for metaprogramming if it could be applied to constructs
other than parameter packs. 

\bibliographystyle{abbrv}
\bibliography{template_varargs}
\end{document}
