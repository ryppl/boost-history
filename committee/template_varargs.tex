\documentclass{article}
\usepackage{hyperref}
\usepackage{vmargin}
\usepackage{amsmath}
\setpapersize{USletter}
\setmarginsrb{1in}{1in}{1in}{1in}{0.25in}{0.25in}{0in}{0in}

\newcommand{\comment}[2]{[{\Large\sc #1:} \textsf{#2}]}

\newcommand{\doug}[1]{\comment{Doug}{#1}}
\newcommand{\gary}[1]{\comment{Gary}{#1}}
\newcommand{\jaakko}[1]{\comment{Jaakko}{#1}}

\begin{document}

\markboth{Doc. no: N1603=04-0043}{Doc. no: N1603=04-0043}
\pagestyle{myheadings}

\title{Variadic Templates}
\author{Douglas Gregor \and Jaakko J\"arvi \and Gary Powell}
\date{}
\maketitle

\par\noindent Document number: N1603=04-0043
\par\noindent Date: \today
\par\noindent Project: Programming Language C++, Evolution Working Group
\par\noindent Reply-to: Douglas Gregor $<${\tt gregod@cs.rpi.edu}$>$

\section{Introduction}
This proposal directly addresses two problems:
\begin{itemize}
\item The inability to instantiate class and function templates with an arbitrarily-long list of template parameters.
\item The inability to pass an arbitrary number of arguments to a function in a type-safe manner.
\end{itemize}

The proposed resolution is to introduce a syntax and semantics for
variable-length template argument lists (usable with function templates
via explicit template argument specification and with class templates)
along with a method of argument ``bundling'' using the same mechanism to
pass an arbitrary number of function call arguments to a function in a
typesafe manner.

\section{Motivation}
\subsection{Variable-length template parameter lists}
Variable-length template parameter lists (variadic templates) allow a
class or function template to accept some number (possibly zero) of
template arguments beyond the number of template parameters specified.
This behavior can be simulated in C++ via a long list of defaulted
template parameters, e.g., a typelist wrapper may appear as:

\begin{verbatim}
struct unused;
template<typename T1 = unused, typename T2 = unused, 
         typename T3 = unused, typename T4 = unused, 
         /* up to */ typename TN = unused> class list;
\end{verbatim}

This technique is used by the Boost Tuples library~\cite{Tuples01},
for the specification of class template {\tt std::tuple<>} in the
library TR~\cite{Jarvi02}, and in the Boost metaprogramming
library~\cite{Gurtovoy02}. Unfortunately, this method leads to very
long type names in error messages (compilers tend to print the
defaulted arguments) and very long mangled names. It is also not
scalable to additional arguments without resorting to preprocessor
magic~\cite{Preprocessor01}. In all of these libraries (and presumably
many more), an implementation based on variadic template would be
shorter and would not suffer the limitations of the aforementioned
implementation. The declaration of the {\tt list<>} template above may
be:
\begin{verbatim}
template<...> class list;
\end{verbatim}

\subsection{Typesafe Variable-length Function Parameter Lists}
Variable-length function parameter lists allow more arguments to be
passed to a function than are declared by the function. This feature
is rarely used in C++ code (except for compatibility with C
libraries), because passing non-POD types through an ellipsis ({\tt
  ...}) invokes undefined behavior. However, a typesafe form of such a
feature would be useful in many contexts, e.g., for implementing a
typesafe C++ {\tt printf} that works for non-POD types. The lack of
such a facility has resulted in odd syntax for formatting in the
Boost.Format library~\cite{Krempp02}:
\begin{verbatim}
format("writing %1%, x=%2%: %3%-th try") % "toto" % 40.23 % 50
\end{verbatim}

\section{Feature menu}
\subsection{Basic variadics}
Permits declaring variadic function and class templates and using the
ellipsis to unpack arguments.

\subsection{First-class template parameter packs}
Template parameter packs are normal C++ types, and are therefore
``first class'' in the type system. For instance, one can do the
following:

\begin{verbatim}
template<...> class tuple {};
assert(is_same<tuple<int, double>, tuple<int, double> >::value);
\end{verbatim}

\subsection{First-class parameter packs}
Parameter packs have actual storage and are CopyConstructible
types. They can therefore be stored, copied, etc. This can be useful
for building \texttt{tuple}~\cite{Jarvi02} facilities, e.g.,
\begin{verbatim}
template<... Elements> 
  class tuple
  {
  public:
    tuple(Elements... elements) : elements(elements) { }

  private:
    Elements elements;
  };
\end{verbatim}

Without first-class parameter packs, one typically needs to build
tuple types recursively, unwrapping the (template) parameter pack at
each step:

\begin{verbatim}
template<typename T, ... Rest>
  class tuple : private tuple<Rest...>
  {
  public:
    tuple(T head, Rest... rest) : tuple<Rest...>(rest...), head(head) { }

  private:
    T head;
  };

template<> class tuple {};
\end{verbatim}

A smart compiler should theoretically be able to optimize this
recursive version as well as the first-class, nonrecursive version
above, the but in practice this does not occur. In any case, the
recursive version places more burden on the compiler.
\doug{Do we have this data around?}

\section{Initializer lists are parameter packs}
Initializer lists are typeless entities stored in the compiler that
can only be used in very restrictive ways for initializing
aggregates. We could lift some of the restrictions on initializer
lists by making them parameter packs. This would permit writing
constructors and assignment operators that accept initializer lists,
e.g.,

\begin{verbatim}
template<... Elements>
  class tuple
  {
  public:
    // #1: Build from an initializer list
    tuple(Elements elements) : elements(elements) { }

    // #2: Build from an initializer list, converting as necessary
    template<... Args> tuple(Args args) : elements(args...) { }

  private:
    Elements elements;
  };

// Passes initializer list as parameter pack to constructor #1
tuple<int, double, float> t1 = { 17, 3.14159, 2.718f };
  
// Passes initializer list as parameter pack to constructor #2
tuple<int, double, std::string> t2 = { 17, 3.14f, "foo" };
\end{verbatim}

Additionally, this change permits emulation of sequence
constructors~\cite{DoReStr03} via parameter packs, e.g.,
\begin{verbatim}
template<typename T>
  class vector
  {
  public:
    template<... Elements> vector(Elements elements)
    {
      tr1::array<T, (pp_length<Elements>::value)> a = elements;
      assign(a.begin(), a.end());
    }
  };
\end{verbatim}

The construction of \texttt{a} actually performs aggregate
initialization from the incoming parameter pack, which unfortunately
requires one extra copy. This copy can be elided by implementing the
constructor as a metaprogram:

\begin{verbatim}
template<typename T>
  class vector
  {
  public:
    template<... Elements> vector(Elements elements)
    {
      reserve(pp_length<Elements>::value);
      do_push_back(elements...);
    }

    void push_back(const T&);

  private:
    template<... Rest>
    void do_push_back(const T& x, Rest... rest) {
      push_back(x);
      do_push_back(rest...);
    }

    void do_push_back() {}
  };
\end{verbatim}

\subsection{Parameter packs have a defined type}
The type of parameter packs has been intentionally left unspecified,
because they are true language entities. However, this need not always
be the case. We could define the type of parameter packs and permit
users to name this type directly as
\texttt{std::parameter\_pack<Elements...>}. This gives us an
alternative syntax for accepting parameter packs as function or
template arguments: 
\begin{verbatim}
template<... Elements>
  void f(parameter_pack<Elements...> p);
\end{verbatim}

\subsection{Length of parameter packs}
\label{sec:length-of-parameter-packs}
Unpacking a template or value parameter pack in a \texttt{sizeof}
expression will return its length, e.g.,

\begin{verbatim}
template<... Args>
  void f(Args... args)
  {
    const int num_args = sizeof(args...);
    // equivalent to...
    const int num_args = sizeof(Args...);
  }
\end{verbatim}

\subsection{Get Nth element for parameter pack}
Parameter packs are only accessible linearly, by peeling off arguments
at the front of the parameter pack. A general tuple, however, requires
the ability to access the Nth element. For parameter packs, we would
like to be able to access the Nth element. For this we propose to use
the \texttt{[]} operator, but restrict the argument to integral
constant expressions because the result type differs depending on the
value of the argument. For instance,

\begin{verbatim}
template<... Args>
  void f(Args... args)
  {
    // Make copy of 2nd argument
    auto second = args[1];
  }
\end{verbatim}

We rely on \texttt{auto}~\cite{JarviStroustrup04} to deduce the type
of the argument for us. See Sec.~\ref{sec:nth-element-template} for an
alternative that introduces more syntax to enable access to the types
in a template parameter pack.

\subsection{Get Nth element for template parameter packs}
\label{sec:nth-element-template}
Given the \texttt{decltype}~\cite{JarviStroustrup04} extension, one
can build a metafunction that extracts the $N^{\text{th}}$ type in a
template parameter pack using ${\cal O}(1)$ instantiations:

\begin{verbatim}
template<... Args, std::size_t N>
  struct nth_type
  {
    static Args args;
    typedef decltype(args[N]) type;
  };
\end{verbatim}

Without \texttt{decltype}, we end up with an ${\cal
O}(N)$-instantiation metafunction.

\begin{verbatim}
template<std::size_t N, ...> struct nth_type_impl;

template<std::size_t N, typename T, ... Rest>
  struct nth_type_impl<N, T, Rest...>
    : nth_type_impl<N-1, Rest...> { };

template<typename T, ... Rest>
  struct nth_type_impl<0, T, Rest...>
  {
    typedef T type;
  };
  
template<... Args, std::size_t N>
  struct nth_type : nth_type_impl<N, Args...> { };
\end{verbatim}

This option involves introducing additional syntax for accessing the
$N^{\text{th}}$ type of a template parameter pack, using the new
\texttt{::[]} operator, e.g.,

\begin{verbatim}
template<... Args, typename R>
  struct function_traits<R (*)(Args...)>
  {
    typedef typename Args::[0] first_argument_type;
    typedef typename Args::[1] second_argument_type;
  };
\end{verbatim}

\section{Syntax and Semantics}
\subsection{Variadic templates}
\par The template parameter list to a function or class template can
be declared to accept an arbitrary number of extra template arguments
by terminating it with ``...'' optionally followed by an identifier
through which these extra arguments can be accessed.
Any number of template
parameters may precede the ``...''. Thus we can define, for instance,
a class {\tt Foo} accepting a template type parameter followed by an
arbitrary number of template arguments as:
\begin{verbatim}
template<typename T, ... Args> class Foo;
\end{verbatim}

\noindent
Here, {\tt T} is the name of the template type parameter and {\tt
  Args} is the name of a ``template parameter pack'' containing the
(possibly empty) set of template arguments given to {\tt Foo}.
Template parameter packs may contain template type, non-type, and
template template arguments and are represented as an unspecified
class type when a type is required.

Function templates may also be variadic templates in the same manner
as class templates.  Arguments can be specified explicitly when
calling the function template, e.g:

\begin{verbatim}
template<... Args> void f();
// ... 
f<int, double>(); // Args will be contain <int, double>
\end{verbatim}
The next section describes when the types of the elements in 
a value parameter pack can be deduced from the argument types
of the call. 

\subsection{Typesafe variadic functions}
When a function template header contains a template parameter pack,
that template parameter pack may be used in the ``type'' of the final
function parameter, allowing the function to accept a variable number
of function parameters in a ``value parameter pack'' (or just
``parameter pack''). For instance, a typesafe C++ {\tt printf} may
be declared as:
\begin{verbatim}
template<... Args>
  void printf(const char* format, const Args&... args);
\end{verbatim}

\noindent The ellipsis indicates that the function ``parameter''
\texttt{args}
actually represents the ``unpacked'' parameters, so for a call to
\texttt{printf} with $N+1$ arguments, the signature is equivalent to
the pseudocode:

\begin{verbatim}
template<typename T1, typename T2, ..., typename TN>
  void printf(const char* format, const T1&, const T2&, ..., const TN&);
\end{verbatim}

\noindent 
Note that \texttt{Args} is used as a placeholder in the type of the
\texttt{args} ``parameter'', and \texttt{Args} is replaced by each
implicitly-named template parameter while \texttt{args} is replaced by
each implicitly-named function parameter. Deduction of template
parameter packs from function call arguments proceeds as it would if
the parameters were explicitly enumerated as in the pseudocode
declaration of \texttt{print}. For instance, calling
\texttt{printf("\%e \%i", 3.14159, 17)} would deduce \texttt{Args =
  <double,int>}, with the parameter types \texttt{const double\&} and
\texttt{const int\&}.

\subsection{Unpacking template and value parameter packs}
The ellipsis operator unpacks all of the values (or template
arguments) within a value (or template) parameter pack into a list of
arguments for use in function call argument lists, template argument
lists, and function types. For instance, given a template parameter pack
{\tt Elements}, we can create a {\tt tuple} storing elements of those
types via {\tt tuple<Elements...>}. Should we wish to append an {\tt int}
to the end of the tuple, we may write {\tt tuple<Elements..., int>}.

Value parameter packs are similarly expanded within a function call,
so that, for instance, a {\tt printf}-like function may pass the
remaining arguments on like this:
\begin{verbatim}
template<typename T, ... Args>
  void printf(const char* s, const T& next, const Args&... args)
  {
    // print characters in s until we hit a formatting command
    // format ``next'' by converting it as appropriate
    // move s after the formatting command
    printf(s, args...); 
  }

  void printf(const char* s)
  {
    // print characters in s, verifying that there is no 
    // formatting command
  }
\end{verbatim}

Note that when the parameter pack is empty, it expands to zero
arguments (in the function call or template argument list). Thus, the
recursion terminates for \texttt{printf} when {\tt args} is empty,
calling the second overload of \texttt{printf}.

The ellipsis operator is valid following any of these constructs:
\begin{itemize}
\item An argument in a function call argument list.
\item An argument in a template argument list.
\item The type of a parameter in a parameter declaration
\end{itemize}

In each case, the text of the argument (or parameter) preceding the
ellipsis is treated as a pattern to be repeated for each element in
the parameter pack as individual arguments (or parameters) within the
current argument (or parameter) list. In the pattern, the parameter
pack is a placeholder for the positions where the elements in the
parameter pack will be substituted. Fig.~\ref{fig:expansions}
illustrates the expansions of several template and value parameter
packs. In the figure, \texttt{X} is a template parameter pack
containing template parameters \texttt{X1}, \texttt{X2}, ....,
\texttt{XN} and, when all \texttt{Xi} are types, \texttt{x} is a value
parameter pack of type \texttt{X} such that \texttt{x1}, \texttt{x2},
..., \texttt{xN} are the contained values. Similarly, \texttt{Y} is a
template parameter pack of size \texttt{M}, with associated
\texttt{Yi}, \texttt{y}, and \texttt{yi}. Additionally, assume the
following declarations:
\begin{verbatim}
template<...> class list;
template<...> class vector;
template<... Args> void f(Args... args);
template<... Args> void g(Args... args;)
\end{verbatim}

\begin{figure}[h]
\centering
\begin{tabular}{l|l}
\textbf{Types \& Expressions} & \textbf{Expansion} \\\hline
\texttt{list<X...>} & \texttt{list<X1, X2, ..., XN>} \\
\texttt{list<int, X..., float>} & \texttt{list<int, X1, X2, ..., XN,
  float>} \\
\texttt{f(x...)} & \texttt{f(x1, x2, ..., xN)} \\
\texttt{f(17, x..., 3.14159)} & \texttt{f(17, x1, x2, ..., xN,
  3.14159)} \\
\texttt{int (*)(X...)} & \texttt{int (*)(X1, X2, ..., XN)} \\
\texttt{list<typename add\_pointer<X>::type...>} &
\texttt{list<typename add\_pointer<X1>::type,} \\
& \qquad\texttt{{ }typename add\_pointer<X2>::type,} \\
& \qquad\texttt{{ }typename add\_pointer<XN>::type>} \\

\texttt{f(x*x)} & \texttt{f(x1*x1, x2*x2, ..., xN*xN)} \\
\texttt{f(g(x, y...)...)} & \texttt{f(g(x1, y1, y2, ..., yM),} \\
& \texttt{{ }{ }g(x2, y1, y2, ..., yM),} \\
& \texttt{{ }{ }. . .} \\
& \texttt{{ }{ }g(xN, y1, y2, ..., yM))} \\
\end{tabular}
\caption{Illustration of the expansions of types and
  expressions using template and value parameter packs.}
\label{fig:expansions}
\end{figure}

Ellipsis operators may be nested, with each ellipsis binding to the
argument text it follows. The same parameter pack may appear in
multiple places within the argument text (and all will be replaced
with the same type or argument from the parameter pack in each
expansion). However, different parameter packs must not be present
within the same argument text unless the ellipsis operators are
nested. A program that attempts to apply the ellipsis operator to a
type or value that is not a parameter pack is ill-formed.

\subsection{Deducing template parameter packs from types}
Template parameter packs can be deduced from template argument lists
and function parameter lists, by packing the list of integral constant
expressions, templates, and types into the template parameter pack.

Example: we can define a template {\tt function\_traits} that extracts
the result type and argument types of a function:
\begin{verbatim}
template<...> class tuple;

template<...> struct function_traits;

template<typename R, ... Args> 
  struct function_traits<R(Args...)>
  { 
    typedef R result_type; 
    typedef tuple<Args...> argument_types;
  };
\end{verbatim}

Example: we can write a function accepting a tuple with an arbitrary
number of elements in it:
\begin{verbatim}
template<...> class tuple;

template<... Elements>
  void eat_tuple(tuple<Elements...>);
\end{verbatim}

Example: We can also split a template class into its template name and
template arguments, a task that could drastically reduce the amount of
code required to implement the meta-lambda facility of the Boost
Metaprogramming Library~\cite{Gurtovoy02}. For instance:

\begin{verbatim}
template<typename T> struct split_template_class;

template<template<... Args> class T> 
  struct split_template_class<T<Args...> >;
\end{verbatim}

\subsection{Explicit template argument specification}
If template arguments are explicitly specified when naming a function
template, the function template header is terminated with a template
parameter pack, and there are at least as many template arguments as
there are template parameters to the function (not including the
template parameter pack), all template arguments beyond the last one
required for the function's template parameters will comprise the
template parameter pack.

Example:
\begin{verbatim}
template<... Args> void f();

f<int, double>(); // OK: Args is <int, double>
f<>();            // OK: Args is empty
f();              // error: Args cannot be deduced
\end{verbatim}

\subsection{Partial ordering of variadic class template partial specializations}
The class template partial specialization partial ordering rules will
need to be augmented to include partial ordering with variadic
templates. This is the only deviation from the purely syntactic nature
of variadic templates. Intuitively, a binding to a parameter that
falls into a template's variable-length argument list is weaker than a
binding to a specified template parameter. For instance, given:

\begin{verbatim}
template<...> struct foo;
template<typename T, ...> struct foo<T>; // #1
template<typename T, typename U> struct foo<T, U>; // #2
\end{verbatim}

Partial specialization \#2 is more specialized than partial
specialization \#1 because \#2 requires that the second template
argument by a type (and not a template or acceptable
literal). 

Formalizing this notion, we introduce a new type of template
parameter we call a template {\em variant} parameter. Template variant
parameters cannot be declared explicitly, but occur implicitly as
parameters for variadic templates. However, any template argument
(type, nontype, or template) can be passed to a template {\em variant}
parameter. 

Paragraph 3 of 14.5.5.2 [temp.func.order] describes the rules for
transforming a template for the purpose of partial ordering. To
support partial ordering with variadic templates, introduce two
additional bullets:
\begin{itemize}
\item If after removing the variable-length template parameter list
  designator \verb|...| from both templates the template parameter lists of the
  templates are of different length, append unique template variant
  parameters to the shorter template parameter list until the template
  parameter lists are of equal length.
\item A binding of an argument to a variant parameter is weaker than a
  binding of an argument to a parameter of the same kind.
\end{itemize}

\subsection{Overloading}
\label{overloading}
The overloading rules need two minor changes to accomodate variadic template:
\begin{itemize}
\item Template variadic functions follow the same overloading rules as
  non-template variadic functions.
\item If two overloads differ only in that one is a variadic template
  function and the other is a non-template variadic function, the
  template variadic function is more specialized.
\end{itemize}

Thus we prefer the typesafe variadic functions to unsafe variadic
functions, even though these rules conflict with 13.3.3p1, which
prefers non-template functions to template functions when the
conversion sequences are otherwise equal.

\subsection{The types of variadic templates}
A template parameter pack is an unspecified, compiler-specific class
type; value parameter packs are instances of the corresponding
template parameter pack. Any program attempting to instantiate a value
parameter pack whose corresponding template parameter pack contains
nontype template parameters or template template parameters is
ill-formed. 

The type of an instantiation of a typesafe variadic function is
equivalent to the type of a nontemplate function with all template
parameters substituted and both template and value parameter packs
unpacked completely. Revisiting the {\tt printf} definition

\begin{verbatim}
template<typename T, ... Args>
  void printf(const char*, const T&, const Args&... args);
\end{verbatim}

and given a call {\tt printf(``\%i:\%f'', 5, 3.14f)}, the type of this
{\tt printf} instantiation will be {\tt void(const char*, const int\&,
  const float\&)}. This type compatibility is logical within the
context of templates (i.e., it follows the existing behavior of
instantiations of function templates) and useful in the
implementation of the polymorphic function adaptors~\cite{Gregor02}
proposal, which has placed the most stress on the formulation of
variadic templates thus far.

\subsection{The types of parameter packs}
Each template parameter pack \texttt{<T1, T2, ..., TN} has an
associated class type that contains unnamed values here denoted
\texttt{t1, t2, ..., tN} of types \texttt{T1, T2, ..., TN},
respectively, and must provide the following when all \texttt{Ti} are
types:
\begin{itemize}
\item A default constructor that default-initializes \texttt{t1, t2,
    ..., tN}, if the types \texttt{<T1, T2, ..., TN} have default
  constructors.
\item A copy constructor that copy-constructs \texttt{t1, t2,
    ..., tN}, if the types \texttt{<T1, T2, ..., TN} have copy
  constructors.
\item A constructor that accepts $N$ arguments, of types \texttt{cv1
    T1\&, cv2 t2\&, ..., cvN tN\&}, where \texttt{cvi} is equivalent to
  the cv-qualifiers in the copy constructor of type \texttt{Ti}, and
  copy-constructs each \texttt{ti} from the corresponding argument.

\item A copy assignment operator that assigns to each \texttt{ti} from
  the corresponding \texttt{ti} of the parameter pack on the
  right-hand side.
\end{itemize}

Value parameter packs may (but are not required to) be implemented
with the following pseudocode:
\begin{verbatim}
template<typename T1, typename T2, ..., typename TN>
  struct __pp
  {
    // implicit default constructor
    // implicit copy constructor
    // implicit copy assignment operator
   
    __pp(cv1 T1& a1, cv2 T2& a2, ..., cvN TN& aN)
      : t1(a1), t2(a2), ..., tN(aN) {}

    T1 t1;
    T2 t2;
      .
      .
      .
    TN tN;
  };
\end{verbatim}

Implementations are permitted to perform an extra copy construction to
construct a parameter pack from the arguments passed to a function,
which may be unavoidable when variadic template functions are invoked
via a function pointer. However, since we make no restrictions on the
layout of parameter packs, and do not confine them to the same layout
as, e.g., a structure containing the same types as in the example
above, implementations may elide these copy constructions by
performing parameter pack layout in a manner that coincides with the
activation record for a particular platform.

The types associated with template parameter packs \textit{may not} be
be used in conjunction with the ellipsis operator. For instance:

\begin{verbatim}
template<typename T> void bar(const T& x);

template<typename T1, ... Args>
  void foo(const T1&, const Args& args)
  { 
    foo(args...); // okay
    bar(args); // okay
  }

template<typename T> 
  void bar(const T& x)
  {
    T y = x; // okay for instantiation
    foo(x...); // not okay: x is not a parameter pack
  }
\end{verbatim}

\section{Examples}
To demonstrate the use of variadic templates, this section gives
skeletal implementations of four library components using variadic
templates,. All of these proposals were accepted by the library
working group into the first library TR, and are implementable to some
degree in C++03. However, all of them would benefit from variadic
templates in that the implementations can be more complete, more
useful, and more readable than their C++03 counterparts. The following
libraries are implemented:

\begin{itemize}
\item Member pointer adaptors~\cite{Dimov03a}
\item Tuples~\cite{Jarvi02}
\item Function object wrappers~\cite{Gregor02}
\item Function object binder~\cite{Dimov03b}
\end{itemize}

The implementations are not generally complete, but omit only features
that are irrelevant to the discussion of variadic template. The
implementations use several class templates (metafunctions) from the
type traits proposal~\cite{Maddock03}. Additionally, we use the
keyword {\tt auto} to make the examples cleaner and easier by omitting
the messy---but expressible--return types; however, this proposal does
not strictly depend on the {\tt decltype} proposal~\cite{Jarvi03}.

\subsection{Building Blocks}
\label{building_blocks}
The class template {\tt enable\_if} is used liberally to help guide
the overload process by eliminating candidates from the overload set
that would otherwise cause ambiguities or be selected when they
shouldn't be. It is defined as:

\small
\begin{verbatim}
template<bool Cond, typename T> struct enable_if;
template<typename T> struct enable_if<true, T> { typedef T type; };
template<typename T> struct enable_if<false, T> {};
\end{verbatim}
\normalsize

We can count the number of arguments in a parameter pack with this
simple class template, using {\tt integral\_constant} from the type
traits proposal~\cite{Maddock03} (part of the first library technical
report~\cite{Austern03}):

\small
\begin{verbatim}
// Count the number of arguments in a template parameter pack
template<...> struct count_args;

template<> struct count_args<> : integral_constant<int, 0> {};

template<typename T1, ... Args> struct count_args<T1, Args...>
  : integral_constant<int, (1 + count_args<Args...>::value)> {};
\end{verbatim}
\normalsize

\subsection{Member pointer adaptor implementation}
\label{mem_fnimpl}
The following code implements the enhanced member pointer adaptor
proposal~\cite{Dimov03a}. This implementation is complete.

\small
\begin{verbatim}
// Adaptor for member function pointers
template<typename Class, typename FunctionType>
struct mem_fn_adaptor
{
  typedef typename function_traits<FunctionType>::result_type result_type;

  mem_fn_adaptor(FunctionType Class::*pmf) : pmf(pmf) {}
  
  template<... Args>
  result_type operator()(Class& object, Args... args) const
    { return (object.*pmf)(args...); }

  template<... Args>
  result_type operator()(const Class& object, Args&... args) const
    { return (object.*pmf)(args...); }

  template<typename T, ... Args>
  typename enable_if<(!is_base_of<Class, T>::value), result_type>::type
  operator()(T& ptr, Args&... args) const
    { return ((*ptr).*pmf)(args...); }

  template<typename T, ... Args>
  typename enable_if<(!is_base_of<Class, T>::value), result_type>::type
  operator()(const T& ptr, Args&... args) const
    { return ((*ptr).*pmf)(args...); }

private:
  FunctionType Class::*pmf;
};

// Adaptor for member data pointers (for completeness only)
template<typename Class, typename T>
struct mem_ptr_adaptor
{
  typedef const T& result_type;

  mem_ptr_adaptor(T Class::*pm) : pm(pm) {}

  T& operator()(Class& object) const { return object.*pm; }
  const T& operator()(const Class& object) const { return object.*pm; }

  template<typename Ptr> 
  typename enable_if<(!is_base_of<Class, Ptr>::value), const T&>::type
    operator()(Ptr& ptr) const { return (*ptr).*pm; }

  template<typename Ptr> 
  typename enable_if<(!is_base_of<Class, Ptr>::value), const T&>::type
    operator()(const Ptr& ptr) const { return (*ptr).*pm; }

private:
  T Class::*pm;
};

template<typename Class, typename FunctionType>
typename enable_if<(is_function<FunctionType>::value), 
                   mem_fn_adaptor<Class, FunctionType> >::type
mem_fn(FunctionType Class::*pmf)
  { return mem_fn_adaptor<Class, FunctionType>(pmf); }

template<typename Class, typename T>
typename enable_if<(!is_function<T>::value), 
                   mem_ptr_adaptor<Class, T> >::type
mem_fn(T Class::*pm)
  { return mem_ptr_adaptor<Class, T>(pm); }
\end{verbatim}
\normalsize 

\subsection{Tuple implementation}
\label{tupleimpl}
The following code implements the interesting portions of the Tuple
proposal~\cite{Jarvi02} using variadic as proposed here. 

\small
\begin{verbatim}
// Derivation from tuple_base indicates that a type is a tuple
class tuple_base {};

// Determine if type T is a tuple
template<typename T>
struct is_tuple
  { static const bool value = is_base_of<tuple_base, T>::value; };

// A tuple of arbitrary length N
template<... Elements>
class tuple : public tuple_base 
{
public:
  static const size_t size = count_args<Elements...>::value;

  tuple() {}

  // enable_if condition ensures that we only match if N arguments are given
  explicit tuple(const Elements&... elements) : elements(elements) {}

  // enable_if condition only allows us to attempt implicit conversions
  // from tuples of the appropriate length
  template<typename Tuple>
  tuple(const Tuple& other,
        typename enable_if<(is_tuple<Tuple>::value && size == Tuple::size), 
                           void>::type* = 0)
    : elements(other.elements...) {}

  // enable_if condition only allows us to attempt assignment from tuples of
  // the appropriate length
  template<typename Tuple>
  typename enable_if<(is_tuple<Tuple>::value && size == Tuple::size),
                     tuple&>::type
  operator=(const Tuple& other)
  {
    *this = tuple(other.elements...);
    return *this;
  }

  Elements elements;
};

// tuple_element
template<int I, typename Head, typename Tail>
  struct tuple_element<I, tuple<Head, Tail...> >
    : tuple_element<I-1, tuple<Tail...> > { };

template<typename Head, typename Tail>
  struct tuple_element<0, tuple<Head, Tail...> >
  {
    typedef Head type;
  };

// make_tuple implementation
template<typename T>
  struct make_tuple_element_type
  {
    typedef T type;
  };

template<typename T>
  struct make_tuple_element_type<reference_wrapper<T> >
  {
    typedef T& type;
  };

template<... Elements> 
  auto make_tuple(const Elements&... elements)
  {
    typedef tuple<typename make_tuple_element_type<Elements>::type...>
      result_type;
    return result_type(elements...);
  }

// tie implementation
template<... Elements>
  tuple<Elements> tie(Elements&... elements)
  { return tuple<Elements&...>(elements...); }
\end{verbatim}
\normalsize

\subsection{Function implementation}
\label{functionimpl}
This section implements the core interesting portions of class
template {\tt function} from the function object wrapper
proposal~\cite{Gregor02}. The implementation of this library is much
more subtle than that of the prior libraries, particularly the use of
template parameter deduction and explicit specification of function
template arguments to resolve the address of an overloaded function
within the constructor. The implementation is complete with one
exception: it does not properly support function pointers. The
modifications to account for function pointers are simple but are
outside the scope of this proposal.

\small
\begin{verbatim}
struct bad_function_call : public std::exception {};

template<typename> struct function;

template<typename R, ... ArgumentTypes>
  struct function<R(ArgumentTypes...)>
  {
    typedef R result_type;

    template<typename Functor>
      auto functor_invoker(ArgumentTypes&... args) const
      { return (*static_cast<Functor*>(functor))(args...); }
    
    template<typename Functor> 
      static void* functor_manager(void* ptr, bool clone)
      { 
        const Functor* functor = static_cast<Functor*>(ptr);
        if (clone) return new Functor(*functor); 
        else { delete functor; return 0; }
      }

    static void* trivial_manager(const void* ptr, bool)
    { return const_cast<void*>(ptr); }

    Function function::* invoker;
    mutable void*        functor;
    void* (*manager)(void*, bool /* clone or delete */);

    struct clear_type;

  public:
    function() : invoker(0), functor(0), manager(0) {}
    
    function(const function& other) : invoker(0), functor(0), manager(0)
      { 
        if (other.invoker) {
          invoker = other.invoker;
          functor = other.manager(other.functor, true);
          manager = other.manager;
        }
      }

    template<typename F> 
      function(F f, 
               typename enable_if<(!is_integral<F>::value, void*>::type = 0) 
        : invoker(0), functor(0), manager(0)
      {
        invoker = &function::functor_invoker<F>;
        functor = new Functor(f);
        manager = &functor_manager<F>;
      }

    template<typename F> 
      function(reference_wrapper<F> f) : invoker(0), functor(0), manager(0)
      { 
        invoker = &function::functor_invoker<F>;
        functor = &f.get();
        manager = &trivial_manager;
      }
    
    template<typename T, typename C> 
      function(T C::*pm) : invoker(0), functor(0), manager(0)
      { *this = std::mem_fn(pm); }

    function(clear_type*) : invoker(0), functor(0), manager(0) {}
    
    ~function() { if (invoker) manager(functor, false); }

    function& operator=(const function& other)
    {
      function tmp(other);
      tmp.swap(*this);
      return *this;
    }
    
    template<typename F> 
      typename enable_if<(!is_integral<F>::value, function&>::type
      operator=(F f)
      {
        function tmp(f);
        tmp.swap(*this);
        return *this;
      }
    
    function& operator=(clear_type*)
    {
      if (invoker) { 
        manager(functor, false);
        invoker = 0;
        functor = 0;
        manager = 0;
      }
    }

    operator bool() const { return invoker; }

    result_type operator()(ArgumentTypes... args) const
    {
      if (!invoker) throw bad_function_call;
      return (this->*invoker)(args...);
    }
    
    void swap(function& other)
    {
      using std::swap;
      swap(invoker, other.invoker);
      swap(functor, functor);
      swap(manager, manager);
    }
  };
\end{verbatim}
\normalsize

\subsection{Bind implementation}
\label{bindimpl}
The following code implements the enhanced binder
proposal~\cite{Dimov03b} using variadic templates and building on the
existing member pointer adaptor code. This implementation is complete,
with two exceptions (both of which require uninteresting but
nontrivial code, expressible in C++03):
\begin{itemize}
  \item {\tt result\_type} is not specified in {\tt binder}
  \item arity checking is not performed at bind time
\end{itemize}

\small
\begin{verbatim}
// Placeholders
template<int N> struct placeholder {};

namespace placeholders {
  typedef placeholder<1> _1;
  typedef placeholder<2> _2;
  typedef placeholder<3> _3;
}

template<typename T> struct is_placeholder : integral_constant<size_t, 0> {};

template<int N> 
struct is_placeholder<placeholder<N> > : integral_constant<size_t, N> {};

// Lambda
template<typename X> X& lambda(const reference_wrapper<X>& x)
  { return x.get(); }
template<typename X> X& lambda(X& x)
  { return x; }

// Get placeholder argument
template<typename T1, ... Args>
  T1& get_placeholder_arg(placeholder<1>, T1& t1, Args&...)
  { return t1; }

template<typename T1, typename T2, ... Args>
  T2& get_placeholder_arg(placeholder<2>, T1&, T2& t2, Args&...)
  { return t2; }

template<typename T1, typename T2, typename T3, ... Args>
  T2& get_placeholder_arg(placeholder<3>, T1&, T2&, T3& t3, Args&...)
  { return t3; }

template<int N, typename T1, typename T2, typename T3, ... Args>
  auto get_placeholder_arg(placeholder<N>, T1&, T2&, T3&, Args&... args)
  { return get_placeholder_arg(placeholder<N-3>(), args...); }

// Mu
template<typename X, typename Args> X& mu(reference_wrapper<X>& x, Args&)
  { return x.get(); }

template<typename X, typename Args>
auto 
mu(X&, Args& args, 
   typename enable_if<(is_placeholder<X>::value), void*>::type=0)
{ 
  return get_placeholder_arg(placeholder<is_placeholder<X>::value>(), args...);
}

template<typename X, typename Args>
  auto 
  mu(X& x, Args& args, 
     typename enable_if<(is_bind_expression<X>::value), void*>::type = 0)
  { return x(args...); }

template<typename X, typename Args> X& mu(X& x, Args&)
  { return x; }

// Return type of bind(...)
template<typename F, ... BoundArgs>
struct binder
{
  binder(const F& f, const BoundArgs&... bound_args)
    : f(f), bound_args(bound_args...) {}

  template<... Args> auto operator()(Args&... args)
    { return lambda(f)(mu(bound_args, args...)...); }

  template<... Args> auto operator()(Args&... args) const
    { return lambda(f)(mu(bound_args, args...)...); }

private:
  F f;
  BoundArgs bound_args;
};

// Helper to construct binder objects
template<typename F, ... BoundArgs>
  binder<F, BoundArgs...> make_binder(F f, const BoundArgs&... bound_args)
  { return binder<F, BoundArgs...>(f, bound_args...); }

// Determine if a type T is a binder type
template<typename T> struct is_bind_expression : integral_constant<bool, false> {};

template<typename F, ... BoundArgs>
struct is_bind_expression<binder<F, BoundArgs...> > : integral_constant<bool, true> {};

// Bind overload for function objects and function pointers
template<typename F, ... BoundArgs>
  auto bind(F f, const BoundArgs&... bound_args)
  { return binder<F, BoundArgs...>(f, bound_args...); }

// Bind overload for member pointers (both function and data)
template<typename Class, typename T, ... BoundArgs>
  auto bind(T Class::*pm, const BoundArgs&... bound_args)
  { return make_binder(mem_fn(f), bound_args...); }
\end{verbatim}
\normalsize

\section{Alternatives \& Extensions}
\subsection{Ellipsis operator for ordinary class types}
One extension of the ellipsis operator would permit it to be applied
for any class type, which would have the effect of unpacking all of
the fields in that class type into separate arguments. This
information could be used for compile-time reflective metaprogramming,
e.g., to perform automatic marshalling or to construct property
inspectors. There are several open questions to be considered for this
extension:

\begin{enumerate}
\item How should base classes be handled? Base classes need to be
  forbidden (severely limiting), enumerated as arguments in some
  defined order, or have their fields enumerated. The middle option
  provides the most information, assuming that some method exists to
  distinguish a base class from a member.

\item How should protected/private members or base classes be
  handled? Enumerating protected and private members is essential for
  many applications of compile-time reflection, but through this
  operator one can easily (and even accidentally) break
  encapsulation. 
  
\item Would it lead to confusing situations? The proposed ellipsis
  operator is very different from other C++ operators, because it
  essentially permits macro-like expansion via template parameters. If
  extended to support arbitrary class types, problems involving the
  use of the ellipsis operator might be harder to debug, because,
  e.g., one may accidentally use \texttt{...} on a type that was never
  meant to be unbundled. Without this extension, diagnosing errors in
  the use of \texttt{...} would be very easy and very effective.

\item What syntax should we use? If the ellipsis operator applies to
  any class type, it is not clear what types the \texttt{...} binds
  to. We will require a new syntax that explicitly states which types
  to unpack.
\end{enumerate}

The combination of these factors (especially \#2) leads us to believe
that reflection should be supported differently, although it is very
likely that the underlying mechanism will take advantage of variadic
templates. 

\subsection{Parameter pack Nth element and size operators}
Access to the N$^\text{th}$ element of a parameter pack requires a
linear number of instantiation, as in the \texttt{tuple\_element}
definition in Sec.~\ref{tupleimpl}. A further extension may provide a
new operator that accesses the N$^\text{th}$ element of a parameter
pack without the linear number of instantiations. The suggested syntax
for such an operator involves two new operators: \texttt{.[]} to
access values and \texttt{.<>} to access types. For instance:

\begin{verbatim}
template<int N, typename Tuple> struct tuple_element;

template<int N, ... Elements>
  struct tuple_element<tuple<Elements...> >
  {
    typedef Elements.<N> type;
  };

template<int N, ... Elements>
  Elements.<N>& get(tuple<Elements...>& t)
  { return t.[N]; }

template<int N, ... Elements>
  const Elements.<N>& get(const tuple<Elements...>& t)
  { return t.[N]; }
\end{verbatim}

In addition, support for an operation returning the length (i.e.,
number of elements) in a parameter pack would permit the entirety of
the tuple proposal~\cite{Jarvi02} (plus other metaprogramming tasks)
to be implemented without incurring a large number of
instantiations. The \texttt{sizeof} operator, when provided with an
argument followed by an ellipsis, could provide the number of elements
in a parameter pack. For instance:

\begin{verbatim}
template<typename Tuple> struct tuple_size;

template<... Elements>
  struct tuple_size<tuple<Elements...> > 
    : integral_constant<size_t, sizeof(Elements...)> { };
\end{verbatim}

While these extensions may be useful, we believe that they introduce a
large amount of syntactic sugar that will not be very important in
practice. For the cases such as \texttt{tuple\_element} and
\texttt{tuple\_size} that incur a linear number of instantiations
without these extensions, the definitions can be manually ``unrolled''
to alleviate these problems, as is done for the \texttt{mu} function
in Sec.~\ref{bindimpl}.

\subsection{Overloadable operator \texttt{...}}
This proposal introduces \texttt{...} as a full-fledged operator only
usable for special, compiler-defined parameter packs. Some
user-defined types (notable the library-defined \texttt{tuple} type)
may wish to present a parameter-pack---like interface and support the
ellipsis operator. \texttt{operator...} could be a nonstatic member
function taking zero arguments and returning a parameter pack. For
instance, within the \texttt{tuple} type:

\begin{verbatim}
template<... Elements>
  class tuple 
  {
    // ...
  public:
    Elements operator...() const { return elements; }

  private:
    Elements elements;
  };
\end{verbatim}

The down side to allowing overloading of \texttt{operator...} is that
it will require a new syntax for the \texttt{...} operator. For
instance, consider the following code:

\begin{verbatim}
template<...> struct bar;

template<typename T1, typename T2>
  struct foo
  {
    typedef foo<bar<T1, T2>...> > foobar;
  };
\end{verbatim}

When neither or both of \texttt{T1} and \texttt{T2} have an
\texttt{operator...},, the instantiation is ill-formed. This ambiguity
delays checking of the use of the ellipsis operator in templates until
instantiation time, so we have decided not to include it in this
version of the proposal.

\subsection{Extended template argument deduction}
One potential extension to this proposal we have considered is to
allow parameter packs to occur before the end of the template header
(so that multiple template parameter packs may be declared in a single
template header). This extension would then allow one to deduce
multiple parameter packs for, e.g., a function call:

\begin{verbatim}
struct PivotType {};

template<... Head, ... Tail>
void split(Head... h, PivotType p, Tail... t);
\end{verbatim}

Another example of this would be a ``pop\_back'' operation on a
parameter pack (here we place the result in a tuple):

\begin{verbatim}
template<... Elements, typename T>
  tuple<Elements> pop_back(Elements... elements, const T&)
  { return tuple<Elements...>(elements); }
\end{verbatim}

While we acknowledge that there may be some benefit to introducing
these extensions, we feel that the benefits are not sufficient to
outweight the cost of introducing yet more overloading rules to
account for this cases. We feel that the few operations that would
benefit may better be accomplished by working with a true
heterogeneous data structure such as a tuple.

\section{Revision history}
\begin{itemize}
\item \textbf{Since N1483=03-0066:} 
  \begin{itemize}
  \item Variadic templates no longer solve the forwarding problem for
    arguments. 
  \item Parameter packs are no longer tuples; instead, they are a
    compiler-specific first-class entities.
  \item Introduced the ability to deduce a template parameter pack
    from a type (or list of template parameters).
  \item Eliminated the \texttt{apply}, \texttt{integral\_constant},
    and \texttt{template\_template\_arg} kludges.
  \end{itemize}
\end{itemize}

\section{Acknowledgements}
Discussions among Daveed Vandevoorde, David Abrahams, Mat Marcus, John
Spicer, and Jaakko J\"arvi resulted in the new syntax for unpacking
arguments using ``...''. This proposal has been greatly improved with
their feedback. David Abrahams noticed that ``...''  could be used for
metaprogramming if it could be applied to constructs other than
parameter packs.

\bibliographystyle{abbrv}
\bibliography{template_varargs}
\end{document}
