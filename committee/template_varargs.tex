\documentclass{article}
\usepackage{hyperref}
\usepackage{fullpage}

\newcommand{\comment}[2]{[{\Large\sc #1:} \textsf{#2}]}

\newcommand{\doug}[1]{\comment{Doug}{#1}}
\newcommand{\gary}[1]{\comment{Gary}{#1}}
\newcommand{\jaakko}[1]{\comment{Jaakko}{#1}}

\begin{document}

\markboth{Doc. no: DRAFT}{Doc. no: DRAFT}
\pagestyle{myheadings}

\title{Variadic Templates}
\author{Douglas Gregor \and Jaakko J\"arvi \and Gary Powell}
\date{}
\maketitle

\par\noindent Document number: DRAFT
\par\noindent Date: \today
\par\noindent Project: Programming Language C++, Evolution Working Group
\par\noindent Reply-to: Douglas Gregor $<${\tt gregod@cs.rpi.edu}$>$

\section{Introduction}
This proposal addresses three problems under a unified framework:
\begin{itemize}
\item The inability to instantiate class and function templates with an arbitrarily-long list of template parameters.
\item The inability to pass an arbitrary number of arguments to a function in a type-safe manner.
\item The argument forwarding problem for an arbitrary number of argumnets.
\end{itemize}

The proposed resolution is to introduce a syntax and semantics for
variable-length template argument lists (usable with function templates
via explicit template argument specification and with class templates)
along with a method of argument building using the same mechanism to
pass an arbitrary number of function call arguments to a function in a
typesafe manner.

\section{Motivation}
\subsection{Variable-length template parameter lists}
Variable-length template parameter lists (variadic templates) allow a class or
function template to accept some number (possibly zero) of template
arguments beyond the number of template parameters specified. This
behavior can be simulated in C++ via a long list of defaulted template
parameters, e.g., a typelist wrapper may appear as:

\begin{verbatim}
struct unused;
template<typename T1 = unused, typename T2 = unused, 
         typename T3 = unused, typename T4 = unused, 
         /* up to */ typename TN = unused> class list;
\end{verbatim}

This technique is used by the Boost Tuples library~\cite{Tuples01},
for the specification of class template {\tt std::tuple<>} in the
library TR~\cite{Jarvi02}, and in the Boost metaprogramming
library~\cite{Gurtovoy02}. Unfortunately, this method leads to very
long type names in error messages (compilers tend to print the
defaulted arguments) and very long mangled names. It is also not
scalable to additional arguments without resorting to preprocessor
magic~\cite{Preprocessor01}. In all of these libraries (and presumably
many more), an implementation based on variadic template would be
shorter and would not suffer the limitations of the aforementioned
implementation. The declaration of the {\tt list<>} template above may
be:
\begin{verbatim}
template<...> class list;
\end{verbatim}

This language feature is primarily designed for library developers,
and is drawn from experience in library development where these
techniques have been simulated in one way or
another~\cite{Gurtovoy02,Lambda02,Tuples01,Function01,Bind01}. Novice
users aren't likely to use this feature, as generically manipulating
heterogeneous type container (tuples, in this case) requires some
degree of metaprogramming.

\subsection{Typesafe Variable-length Function Parameter Lists}
Variable-length function parameter lists allow more arguments to be
passed to a function than are declared by the function. This feature
is rarely used in C++ code (except for compatibility with C
libraries), because passing non-POD types through {\tt ...} invokes
undefined behavior. However, a typesafe form of such a feature would
be useful in many contexts, e.g., for implementing a typesafe C++ {\tt
  printf} that works for non-POD types. The lack of such a facility
has resulted in odd syntax for formatting in the Boost.Format
library~\cite{Krempp02}:
\begin{verbatim}
format("writing %1%, x=%2%: %3%-th try") % "toto" % 40.23 % 50
\end{verbatim}

\subsection{Argument forwarding}
The forwarding problem, as described in~\cite{Dimov02}, is:

\begin{quote}
  For a given expression $E(a_1, a_2, ..., a_n)$ that depends on the
  (generic) parameters $a_1, a_2, ..., a_n$, it is not possible to
  write a function (object) $f$ such that $f(a_1, a_2, ..., a_n)$ is
  equivalent to $E(a_1, a_2, ..., a_n)$.
\end{quote}

The primary issue with the argument forwarding problem is to deduce
the types of $a_1, a_2, ..., a_n$ such that they can be forwarded to
the underlying function $E$ without changing the semantics of the
expression. The common implementation idiom is to accept a (non-const)
reference for each parameter, and to provide overloads for some number
of arguments to forward, e.g.:
\begin{verbatim}
template<typename E, typename T1>
void f(E e, T1& a1) { e(a1); }

template<typename E, typename T1, typename T2>
void f(E e, T1& a1, T2& a2) { e(a1, a2); }

template<typename E, typename T1, typename T2, typename T3>
void f(E e, T1& a1, T2& a2, T3& a3) { e(a1, a2, a3); }

// repeat up to N arguments
\end{verbatim}

However, this idiom fails to accept literal values and also requires
repetition for an arbitrary number of arguments (often done via
preprocessor metaprogramming in the Boost
libraries~\cite{Preprocessor01}). This proposal solves both issues:
arguments are passed via the ``Const + Non-const reference'' option
\#3 enumerated in~\cite{Dimov02}, which results in ``perfect''
forwarding of arguments, but does not require $2^N$ overloads to
support $N$ arguments: instead, a single overload suffices for any
number of arguments. Our solution matches all three criteria (C1-C3)
of the argument forwarding paper~\cite{Dimov02} by bundling the
arguments into a single argument and providing an unbundling method to
pass the arguments on to another function. Note that our solution
directly supports only functions which accept an unbounded number of
arguments. With this proposal and additional library tools, it is
possible to define perfect forwarding functions that only match to
invocations with a fixed number of arguments (or even with the number
of arguments in a fixed range). This is explained in
Section~\ref{building_blocks}.

\section{Syntax and Semantics}
\subsection{Variadic templates}
\par The template parameter list to a function or class template can
be declared to accept an arbitrary number of extra template arguments
by terminating it with ``...'' optionally followed by an identifier
through which these extra arguments can be accessed.
Any number of template
parameters may precede the ``...''. Thus we can define, for instance,
a class {\tt Foo} accepting a template type parameter followed by an
arbitrary number of template arguments as:
\begin{verbatim}
template<typename T, ... Elements> class Foo;
\end{verbatim}

\noindent
Here, {\tt T} is the name of the template type parameter and {\tt
  Args} is the name of a ``template parameter pack'' containing
the (possibly empty) set of template arguments given to {\tt
  Foo}. Template parameter packs may contain template type, non-type, and
template template arguments but themselves have no representation in
the C++ type system (i.e., they are not first-class entities in the
type system as are integral constants, types, and templates).

Function templates may also be declared to accept variable-length
template parameter lists in the same manner as class templates. 
Arguments can be specified explicitly when calling the function
template, e.g:

\begin{verbatim}
template<... Args> void f();
// ... 
f<int, double>(); // Args will be contain <int, double>
\end{verbatim}
The next section describes when the types of the elements in 
a value parameter pack can be deduced from the argument types
of the call. 

\subsection{Typesafe variadic functions}
When a function template header contains a template parameter pack,
that template parameter pack may be used as the ``type'' of the final
function parameter, allowing the function to accept a variable number
of function parameters in a ``value parameter pack'' (or just
``parameter pack''). For instance, a typesafe C++ {\tt printf} may
be declared as:
\begin{verbatim}
template<... Args>
  void printf(const char* format, Args args);
\end{verbatim}

\noindent
{\tt Args} is deduced as a template parameter pack containing the types of
the arguments, and {\tt args} is a value parameter pack containing
the function call arguments passed after the {\tt format}
argument.\footnote{Note that, unlike C, we do not require but
  do allow arguments prior to the argument bundle.} Like template
parameter packs, value parameter packs are not first-class entities:
their type is that of the associated template parameter pack, which is
itself not a user-accessible type of the C++ type system. 
Hence, both template and value
parameter packs may be thought of as naming a set of arguments, not as
having any intrinsic type or value themselves.

\subsection{Unpacking template and value parameter packs}
When template and value parameter packs are used in any manner, they
are implicitly ``unpacked'' into a list of template arguments or
values, respectively. For instance, given a template parameter pack
{\tt Elements}, we can create a {\tt tuple} storing elements of those
types via {\tt tuple<Elements>}. Should we wish to append an {\tt int}
to the end of the tuple, we may write {\tt tuple<Elements, int>}.

Value parameter packs are similarly expanded within a function call,
so that, for instance, a {\tt printf}-like function may pass the
remaining arguments on like this:
\begin{verbatim}
template<typename T, ... Args>
  void printf(const char* s, const T& next, Args args)
  {
    // print characters in s until we hit a formatting command
    // format ``next'' by converting it as appropriate
    // move s after the formatting command
    printf(s, args); 
  }

  void printf(const char* s)
  {
    // print characters in s, verifying that there is no 
    // formatting command
  }
\end{verbatim}

\subsection{Deducing parameter packs from a function call}
Template and value parameter packs can be deduced from a function call
by first deducing the argument type (to be included in the template
parameter pack) and then including the argument in the value parameter
pack. The type of each element in the template parameter pack is
deduced to achieve perfect argument forwarding. For an argument {\tt
  xi}, the type {\tt Ti} of the corresponding parameter pack element
is the parameter type of the {\tt forward} function determined by
overload resolution using the following two candidates\footnote{This
  formulation is expected to change if some variant of the move
  proposal~\cite{Hinnant02} is accepted}:
\begin{verbatim}
template<typename T> void forward(T&);
template<typename T> void forward(const T &);
\end{verbatim}

Example:
\begin{verbatim}
template<... Args> void f(Args args);

int x;
float y;

f(x, y, 3.14159); // Args is <int&, float&, const double&>
\end{verbatim}

\subsection{Deducing template parameter packs from types}
Template parameter packs can be deduced from template argument lists
and function parameter lists, by packing the list of integral constant
expressions, templates, and types into the template parameter pack.

Example: we can define a template {\tt function\_traits} that extracts
the result type and argument types of a function:
\begin{verbatim}
template<...> class tuple;

template<...> struct function_traits;

template<typename R, ... Args> 
  struct function_traits<R(Args)>
  { 
    typedef R result_type; 
    typedef tuple<Args> argument_types;
  };
\end{verbatim}

Example: we can write a function accepting a tuple with an arbitrary
number of elements in it:
\begin{verbatim}
template<...> class tuple;

template<... Elements>
  void eat_tuple(tuple<Elements>);
\end{verbatim}

Example: We can also split a template class into its template name and
template arguments, a task that could drastically reduce the amount of code required to implement the meta-lambda facility of the Boost Metaprogramming Library~\cite{Gurtovoy02}. For instance:

\begin{verbatim}
template<typename T> struct split_template_class;

template<template<... Args> class T> 
  struct split_template_class<T<Args> >;
\end{verbatim}

\subsection{Explicit template argument specification}
If template arguments are explicitly specified when naming a function
template, the function template header is terminated with a template
parameter pack, and there are at least as many template arguments as
there are template parameters to the function (not including the
template parameter pack), all template arguments beyond the last one
required for the function's template parameters will comprise the
template parameter pack.

Example:
\begin{verbatim}
template<... Args> void f();

f<int, double>(); // OK: Args is <int, double>
f<>();            // OK: Args is empty
f();              // error: Args cannot be deduced
\end{verbatim}

\subsection{Partial ordering of variadic class template partial specializations}
The class template partial specialization partial ordering rules will
need to be augmented to include partial ordering with variadic
templates. Intuitively, a binding to a parameter that falls into a
template's variable-length argument list is weaker than a binding to a
specified template parameter. For instance, given:

\begin{verbatim}
template<...> struct foo;
template<typename T, ...> struct foo<T>; // #1
template<typename T, typename U> struct foo<T, U>; // #2
\end{verbatim}

Partial specialization \#2 is more specialized than partial
specialization \#1 because \#2 requires that the second template
argument by a type (and not a template or acceptable
literal). 

Formalizing this notion, we introduce a new type of template
parameter we call a template {\em variant} parameter. Template variant
parameters cannot be declared explicitly, but occur implicitly as
parameters for variadic templates. However, any template argument
(type, nontype, or template) can be passed to a template {\em variant}
parameter. 

Paragraph 3 of 14.5.5.2 [temp.func.order] describes the rules for
transforming a template for the purpose of partial ordering. To
support partial ordering with variadic templates, introduce two
additional bullets:
\begin{itemize}
\item If after removing the variable-length template parameter list
  designator \verb|...| from both templates the template parameter lists of the
  templates are of different length, append unique template variant
  parameters to the shorter template parameter list until the template
  parameter lists are of equal length.
\item A binding of an argument to a variant parameter is weaker than a
  binding of an argument to a parameter of the same kind.
\end{itemize}

\subsection{Overloading}
\label{overloading}
The overloading rules need two minor changes to accomodate variadic template:
\begin{itemize}
\item Template variadic functions follow the same overloading rules as
  non-template variadic functions.
\item If two overloads differ only in that one is a variadic template
  function and the other is a non-template variadic function, the
  template variadic function is more specialized.
\end{itemize}

Thus we prefer the typesafe variadic functions to unsafe variadic
functions, even though these rules conflict with 13.3.3p1, which
prefers non-template functions to template functions when the
conversion sequences are otherwise equal.

\subsection{The types of variadic templates}
Since parameter packs do not have a type, we specify the
type of an instantiation of a typesafe variadic function to be equivalent
to the type of a nontemplate function with all template parameters
substituted and both template and value parameter packs unpacked
in place. Revisiting the {\tt printf} definition

\begin{verbatim}
template<typename T, ... Args>
  void printf(const char*, const T&, Args args);
\end{verbatim}

and given a call {\tt printf(``\%i:\%f'', 5, 3.14f)}, the type of this
{\tt printf} instantiation will be {\tt void(const char*, const int\&,
  const float\&)}. This type compatibility is logical within the
context of templates (i.e., it follows the existing behavior of
instantiations of function templates), necessary because parameter
packs do not have a representation in the type system, and useful in the
implementation of the polymorphic function adaptors~\cite{Gregor02}
proposal, which has placed the most stress on the formulation of
variadic templates thus far.

\section{Examples}
To demonstrate the use of variadic templates, this section gives
skeletal implementations of four library components using variadic
templates,. All of these proposals were accepted by the library
working group into the first library TR, and are implementable to some
degree in C++03. However, all of them would benefit from variadic
templates in that the implementations can be more complete, more
useful, and more readable than their C++03 counterparts. The following
libraries are implemented:

\begin{itemize}
\item Member pointer adaptors~\cite{Dimov03a}
\item Tuples~\cite{Jarvi02}
\item Function object wrappers~\cite{Gregor02}
\item Function object binder~\cite{Dimov03b}
\end{itemize}

The implementations are not generally complete, but omit only features
that are irrelevant to the discussion of variadic template. The
implementations use several class templates (metafunctions) from the
type traits proposal~\cite{Maddock03}. Additionally, we use the
keyword {\tt auto} to make the examples cleaner and easier by omitting
the messy---but expressible--return types; however, this proposal does
not depend on the {\tt decltype} proposal~\cite{Jarvi03}.

\subsection{Building Blocks}
\label{building_blocks}
The class template {\tt enable\_if} is used liberally to help guide
the overload process by eliminating candidates from the overload set
that would otherwise cause ambiguities or be selected when they
shouldn't be. It is defined as:

\small
\begin{verbatim}
template<bool Cond, typename T> struct enable_if;
template<typename T> struct enable_if<true, T> { typedef T type; };
template<typename T> struct enable_if<false, T> {};
\end{verbatim}
\normalsize

We can count the number of arguments in a parameter pack with this
simple class template, using {\tt integral\_constant} from the type
traits proposal~\cite{Maddock03} (part of the first library technical
report~\cite{Austern03}):

\small
\begin{verbatim}
// Count the number of arguments in a template parameter pack
template<...> struct count_args;

template<> struct count_args<> : integral_constant<int, 0> {};

template<typename T1, ... Args> struct count_args<T1, Args>
  : integral_constant<int, (1 + count_args<Args>::value)> {};
\end{verbatim}
\normalsize

Using \texttt{enable\_if} and \texttt{count\_args}, we can achieve
perfect forwarding for a fixed number of arguments \texttt{N}:
\small
\begin{verbatim}
template<typename Functor, ... Args>
  typename enable_if<count_args<Args>::value == N, void>::type
  forwardN(Functor functor, Args args)
  { return functor(args); }
\end{verbatim}
\normalsize

\subsection{Member pointer adaptor implementation}
\label{mem_fnimpl}
The following code implements the enhanced member pointer adaptor
proposal~\cite{Dimov03a}. This implementation is complete.

\small
\begin{verbatim}
// Adaptor for member function pointers
template<typename Class, typename FunctionType>
struct mem_fn_adaptor
{
  typedef typename function_traits<FunctionType>::result_type result_type;

  mem_fn_adaptor(FunctionType Class::*pmf) : pmf(pmf) {}
  
  template<... Args>
  result_type operator()(Class& object, Args args) const
    { return (object.*pmf)(args); }

  template<... Args>
  result_type operator()(const Class& object, Args args) const
    { return (object.*pmf)(args); }

  template<typename T, ... Args>
  typename enable_if<(!is_base_of<Class, T>::value), result_type>::type
  operator()(T& ptr, Args args) const
    { return ((*ptr).*pmf)(args); }

  template<typename T, ... Args>
  typename enable_if<(!is_base_of<Class, T>::value), result_type>::type
  operator()(const T& ptr, Args args) const
    { return ((*ptr).*pmf)(args); }

private:
  FunctionType Class::*pmf;
};

// Adaptor for member data pointers (for completeness only)
template<typename Class, typename T>
struct mem_ptr_adaptor
{
  typedef const T& result_type;

  mem_ptr_adaptor(T Class::*pm) : pm(pm) {}

  T& operator()(Class& object) const { return object.*pm; }
  const T& operator()(const Class& object) const { return object.*pm; }

  template<typename Ptr> 
  typename enable_if<(!is_base_of<Class, Ptr>::value), const T&>::type
    operator()(Ptr& ptr) const { return (*ptr).*pm; }

  template<typename Ptr> 
  typename enable_if<(!is_base_of<Class, Ptr>::value), const T&>::type
    operator()(const Ptr& ptr) const { return (*ptr).*pm; }

private:
  T Class::*pm;
};

template<typename Class, typename FunctionType>
typename enable_if<(is_function<FunctionType>::value), 
                   mem_fn_adaptor<Class, FunctionType> >::type
mem_fn(FunctionType Class::*pmf)
  { return mem_fn_adaptor<Class, FunctionType>(pmf); }

template<typename Class, typename T>
typename enable_if<(!is_function<T>::value), 
                   mem_ptr_adaptor<Class, T> >::type
mem_fn(T Class::*pm)
  { return mem_ptr_adaptor<Class, T>(pm); }
\end{verbatim}
\normalsize 

\subsection{Tuple implementation}
\label{tupleimpl}
The following code implements the interesting portions of the Tuple
proposal~\cite{Jarvi02} using variadic as proposed here. 

\small
\begin{verbatim}
// Derivation from tuple_base indicates that a type is a tuple
class tuple_base {};

// Determine if type T is a tuple
template<typename T>
struct is_tuple
  { static const bool value = is_base_of<tuple_base, T>::value; };

// A tuple of arbitrary length N
template<typename T1, ... Elements>
class tuple : public tuple_base 
{
  typedef typename add_reference<typename add_const<T1>::type>::type
    head_param_type;

public:
  typedef T1 head_type;
  typedef tuple<Elements> tail_type;

  static const size_t size = 1 + tail_type::size;

  tuple() {}

  // enable_if condition ensures that we only match if N arguments are given
  template<... Tail> 
  explicit tuple(typename enable_if<(count_args<Args>::value == size - 1),
                                    head_param_type>::type head,
                 Tail tail)
    : head(head), tail(tail) {}

  // enable_if condition only allows us to attempt implicit conversions
  // from tuples of the appropriate length
  template<typename Tuple>
  tuple(const Tuple& other,
        typename enable_if<(is_tuple<Tuple>::value && size == Tuple::size), 
                           void>::type* = 0)
    : head(other.head), tail(other.tail) {}

  // enable_if condition only allows us to attempt assignment from tuples of
  // the appropriate length
  template<typename Tuple>
  typename enable_if<(is_tuple<Tuple>::value && size == Tuple::size),
                     tuple&>::type
  operator=(const Tuple& tuple)
  {
    head = other.head;
    tail = other.tail;
    return *this;
  }

  head_type head;
  tail_type tail;
};

// Base case: a nullary tuple
template<> class tuple<> : public tuple_base 
{
public:
  static const size_t size = 0;
};

// Performs an arbitrary transform on each of the types in a
// tuple. This is a utility function, used by make_tuple.
template<typename MetaFun, typename Tuple, ... Rest>
  class transform_tuple_type
  {
    typedef typename Tuple::head_type old_head_type;
    typedef typename MetaFun::template apply<old_head_type>::type
      new_head_type;
    typedef typename Tuple::tail_type old_tail_type;
    typedef transform_tuple_type<MetaFun, old_tail_type, Rest, new_head_type>
      gen;
  public:
    typedef typename gen::type type;
  };

template<typename MetaFun, ... Rest>
  class transform_tuple_type<MetaFun, tuple<>, Rest>
  {
  public:
    typedef tuple<Rest> type;
  };

// make_tuple implementation
struct make_tuple_element_type
{
  template<typename T> 
    struct apply
    {
      typedef T type;
    };

  template<typename T>
    struct apply<T&>
    {
      typedef typename remove_cv<T>::type type;
    };

  template<typename T>
    struct apply<reference_wrapper<T> >
    {
      typedef T& type;
    };
};

template<... Elements> 
  auto make_tuple(Elements elements)
  {
    typedef typename transform_tuple_type<make_tuple_element_type,
                                          tuple<Elements> >::type result_type; 
    return result_type(elements);
  }

// tie implementation
template<... Elements>
  tuple<Elements> tie(Elements elements)
  { return tuple<Elements>(elements); }
\end{verbatim}
\normalsize

\subsection{Tuple algorithms implementation}
In this section we implement three ``core'' tuple algorithms.
Although there is not yet any proposal for these algorithms, they are
useful in practice and will be used in implementations within this
proposal.

The first tuple algorithm creates a tuple that is the reverse of the
input tuple.
\begin{verbatim}
template<... Args>
  tuple<Args> reverse(tuple<>, Args args)
  { return tuple<Args>(args); }

template<typename Tuple, ... Args>
  auto reverse(const Tuple& t, Args args)
  { 
    typedef typename Tuple::head_type head_type;
    typedef typename Tuple::tail_type tail_type;
    return reverse<tail_type, head_type>(t.tail, t.head, args);
  }
\end{verbatim}

The second tuple algorithm illustrates the ability to unpack a tuple
into a (value) parameter pack, so that function call arguments can be
stored in a tuple and later unpacked and passed to a function object
as function call parameters.
\begin{verbatim}
template<typename F, ... Args>
  auto apply(F f, tuple<>, Args args)
  { return f(args); }

template<typename F, typename Tuple, ... Args>
  auto apply(F f, const Tuple& t, Args args)
  { return apply(f, t.tail, args, t.head); }

template<typename F, typename Tuple, ... Args>
  auto apply(F f, Tuple& t, Args args)
  { return apply(f, t.tail, args, t.head); }
\end{verbatim}

The final tuple algorithm represents a transformation on tuples,
similar to the {\tt transform} algorithm in the standard library.
\begin{verbatim}
template<typename F, ... Args>
  auto transform(tuple<>, F, Args args)
  { return make_tuple(args); }

template<typename Tuple, typename F, ... Args>
  auto transform(const Tuple& t, F f, Args args)
  { return transform(t.tail, f, args, f(t.head)); }
\end{verbatim}

\subsection{Function implementation}
\label{functionimpl}
This section implements the core interesting portions of class
template {\tt function} from the function object wrapper
proposal~\cite{Gregor02}. The implementation of this library is much
more subtle than that of the prior libraries, particularly the use of
template parameter deduction and explicit specification of function
template arguments to resolve the address of an overloaded function
within the constructor. The implementation is complete with one
exception: it does not properly support function pointers. The
modifications to account for function pointers are simple but are
outside the scope of this proposal.

\small
\begin{verbatim}
struct bad_function_call : public std::exception {};

template<typename Function> // Function type R(T1, T2, ..., TN)
  struct function
  {
    typedef typename function_traits<Function>::result_type result_type;
    typedef typename function_traits<Function>::argument_types argument_types;

    template<typename Functor, ... Args>
      auto functor_invoker(Args args) const
      { return (*static_cast<Functor*>(functor))(args); }
    
    template<typename Functor> 
      static void* functor_manager(void* ptr, bool clone)
      { 
        const Functor* functor = static_cast<Functor*>(ptr);
        if (clone) return new Functor(*functor); 
        else { delete functor; return 0; }
      }

    static void* trivial_manager(const void* ptr, bool)
    { return const_cast<void*>(ptr); }

    Function function::* invoker;
    mutable void*        functor;
    void* (*manager)(void*, bool /* clone or delete */);

    struct clear_type;

  public:
    function() : invoker(0), functor(0), manager(0) {}
    
    function(const function& other) : invoker(0), functor(0), manager(0)
      { 
        if (other.invoker) {
          invoker = other.invoker;
          functor = other.manager(other.functor, true);
          manager = other.manager;
        }
      }

    template<typename F> 
      function(F f, 
               typename enable_if<(!is_integral<F>::value, void*>::type = 0) 
        : invoker(0), functor(0), manager(0)
      {
        invoker = &function::functor_invoker<F>;
        functor = new Functor(f);
        manager = &functor_manager<F>;
      }

    template<typename F> 
      function(reference_wrapper<F> f) : invoker(0), functor(0), manager(0)
      { 
        invoker = &function::functor_invoker<F>;
        functor = &f.get();
        manager = &trivial_manager;
      }
    
    template<typename T, typename C> 
      function(T C::*pm) : invoker(0), functor(0), manager(0)
      { *this = std::mem_fn(pm); }

    function(clear_type*) : invoker(0), functor(0), manager(0) {}
    
    ~function() { if (invoker) manager(functor, false); }

    function& operator=(const function& other)
    {
      function tmp(other);
      tmp.swap(*this);
      return *this;
    }
    
    template<typename F> 
      typename enable_if<(!is_integral<F>::value, function&>::type
      operator=(F f)
      {
        function tmp(f);
        tmp.swap(*this);
        return *this;
      }
    
    function& operator=(clear_type*)
    {
      if (invoker) { 
        manager(functor, false);
        invoker = 0;
        functor = 0;
        manager = 0;
      }
    }

    operator bool() const { return invoker; }

    template<... Args> result_type operator()(Args args) const
    {
      if (!invoker) throw bad_function_call;
      return (this->*invoker)(args);
    }
    
    void swap(function& other)
    {
      using std::swap;
      swap(invoker, other.invoker);
      swap(functor, functor);
      swap(manager, manager);
    }
  };
\end{verbatim}
\normalsize

\subsection{Bind implementation}
\label{bindimpl}
The following code implements the enhanced binder
proposal~\cite{Dimov03b} using variadic templates, and building on the
existing tuple and member pointer adaptor code. This implementation is
complete, with two exceptions (both of which require uninteresting but
nontrivial code, expressible in C++03):
\begin{itemize}
  \item {\tt result\_type} is not specified in {\tt binder}
  \item arity checking is not performed at bind time
\end{itemize}

\small
\begin{verbatim}
// Placeholders
template<int N> struct placeholder {};

namespace placeholders {
  typedef placeholder<1> _1;
  typedef placeholder<2> _2;
  typedef placeholder<3> _3;
}

template<typename T> struct is_placeholder : integral_constant<size_t, 0> {};

template<int N> 
struct is_placeholder<placeholder<N> > : integral_constant<size_t, N> {};

// Lambda
template<typename X> X& lambda(const reference_wrapper<X>& x)
  { return x.get(); }
template<typename X> X& lambda(X& x)
  { return x; }

// Mu
template<typename X, typename Args> X& mu(reference_wrapper<X>& x, Args&)
  { return x.get(); }

template<typename X, typename Args>
typename enable_if<(is_placeholder<X>::value),
                   typename tuple_element<X, is_placeholder<X>::value-1>::type
                   >::type
mu(X&, Args& args)
  { return std::get<is_placeholder<X>::value-1>(args); }

template<typename X, typename Args>
  auto 
  mu(X& x, Args& args, 
     typename enable_if<(is_bind_expression<X>::value), void*>::type = 0)
  { return apply(x, args); }

template<typename X, typename Args> X& mu(X& x, Args&)
  { return x; }

// Unary function object that calls mu with the object 'x' it receives
// and the bound arguments from binder_t.
template<typename BoundArgs>
struct apply_mu_t
{
  explicit apply_mu_t(BoundArgs& bound_args) : bound_args(bound_args) {}

  template<typename X> auto operator()(X& x) const
    { return mu(x, bound_args); }

private:
  BoundArgs bound_args;
};

// Return type of bind(...)
template<typename F, typename BoundArgs>
struct binder
{
  binder(const F& f, const BoundArgs& bound_args)
    : f(f), bound_args(bound_args) {}

  template<... Args> auto operator()(Args args)
    { return apply(lambda(f), transform(tie(args), apply_mu(bound_args))); }

  template<... Args> auto operator()(Args args) const
    { return apply(lambda(f), transform(tie(args), apply_mu(bound_args))); }

private:
  F f;
  BoundArgs bound_args;
};

// Helper to construct binder objects
template<typename F, typename BoundArgs>
  binder<F, BoundArgs> make_binder(F f, const BoundArgs& bound_args)
  { return binder<F, BoundArgs>(f, bound_args); }

// Determine if a type T is a binder type
template<typename T> struct is_bind_expression : integral_constant<bool, false> {};

template<typename F, typename BoundArgs>
struct is_bind_expression<binder<F, BoundArgs> > : integral_constant<bool, true> {};

// Bind overload for function objects and function pointers
template<typename F, ... BoundArgs>
  auto bind(F f, BoundArgs bound_args)
  { return make_binder(f, make_tuple(bound_args)); }

// Bind overload for member pointers (both function and data)
template<typename Class, typename T, ... BoundArgs>
  auto bind(T Class::*pm, BoundArgs bound_args)
  { return make_binder(mem_fn(f), make_tuple(bound_args)); }
\end{verbatim}
\normalsize

\section{Potential extension: More parameter pack deduction}
One potential extension to this proposal we have considered is to
allow parameter packs to occur before the end of the template header
(so that multiple template parameter packs may be declared in a single
template header). This extension would then allow one to deduce
multiple parameter packs for, e.g., a function call:

\begin{verbatim}
struct PivotType {};

template<... Head, ... Tail>
void split(Head h, PivotType p, Tail t);
\end{verbatim}

Another example of this would be a ``pop\_back'' operation on a
parameter pack (here we place the result in a tuple):

\begin{verbatim}
template<... Elements, typename T>
  tuple<Elements> pop_back(Elements elements, const T&)
  { return tuple<Elements>(elements); }
\end{verbatim}

While we acknowledge that there may be some benefit to introducing
these extensions, we feel that the benefits are not sufficient to
outweight the cost of introducing yet more overloading rules to
account for this cases. We feel that the few operations that would
benefit may better be accomplished by working with a true
heterogeneous data structure such as a tuple.

\section{Revision history}
\begin{itemize}
\item \textbf{Since N1483=03-0066:} 
  \begin{itemize}
  \item Parameter packs are no longer tuples; instead, they are a
    typeless entity that may only be declared and unpacked.
  \item Introduced the ability to deduce a template parameter pack
    from a type (or list of template parameters).
  \item Eliminated the \texttt{apply}, \texttt{integral\_constant},
    and \texttt{template\_template\_arg} kludges.
  \end{itemize}
\end{itemize}

\section{Acknowledgements}
Discussions among Daveed Vandevoorde, Dave Abrahams, Mat Marcus, John
Spicer, and Jaakko J\"arvi resulted in an interesting new syntax for
unpacking arguments using ``...'', that would unpack parameter packs
into separate arguments within a function call (or template
instantiation), e.g., \texttt{f(args...)}. While we have chosen not to
use this syntax (because unpacking is implicit in this proposal), our
experiments with this syntax lead us to the realization that
first-class parameter packs were unnecessary (and, in fact, are
detrimental).


\bibliographystyle{abbrv}
\bibliography{template_varargs}
\end{document}
