\documentclass{article}
\usepackage{hyperref}
\usepackage{fullpage}

\begin{document}

\markboth{Doc. no: N1483=03-0066}{Doc. no: N1483=03-0066}
\pagestyle{myheadings}

\title{Typesafe Variable-length Function and Template Argument Lists}
\author{Douglas Gregor \and Gary Powell \and Jaakko J\"arvi}
\date{}
\maketitle

\par\noindent Document number: N1483=03-0066
\par\noindent Date: 25 April 2003
\par\noindent Project: Programming Language C++, Evolution Working Group
\par\noindent Reply-to: Douglas Gregor $<${\tt gregod@cs.rpi.edu}$>$

\section{Introduction}
This proposal addresses three problems under a unified framework:
\begin{itemize}
\item The inability to instantiate class and function templates with an arbitrarily-long list of template parameters.
\item The inability to pass an arbitrary number of arguments to a function in a type-safe manner.
\item The argument forwarding problem.
\end{itemize}

The proposed resolution is to introduce a syntax and semantics for
variable-length template argument lists (usable with function templates
via explicit template argument specification and with class templates)
along with a method of argument building using the same mechanism to
pass an arbitrary number of function call arguments to a function in a
typesafe manner.

\section{Motivation}
\subsection{Variable-length template parameter lists}
Variable-length template parameter lists (varargs) allow a class or
function template to accept some number (possibly zero) of template
arguments beyond the number of template parameters specified. This
behavior can be simulated in C++ via a long list of defaulted template
parameters, e.g., a typelist wrapper may appear as:

\begin{verbatim}
struct unused;
template<typename T1 = unused, typename T2 = unused, 
         typename T3 = unused, typename T4 = unused, 
         /* up to */ typename TN = unused> class list;
\end{verbatim}

This technique is used by the Boost Tuples library~\cite{Tuples01},
for the specification of class template {\tt std::tuple<>} in the
library TR~\cite{Jarvi02}, and in the Boost metaprogramming
library~\cite{Gurtovoy02}. Unfortunately, this method leads to very
long type names in error messages (compilers tend to print the
defaulted arguments) and very long mangled names. It is also not
scalable to additional arguments without resorting to preprocessor
magic~\cite{Preprocessor01}. In all of these libraries (and presumably
many more), an implementation based on template varargs would be
shorter and would not suffer the limitations of the aforementioned
implementation. The declaration of the {\tt list<>} template above may
be:
\begin{verbatim}
template<...> class list;
\end{verbatim}

This language feature is primarily designed for library developers,
and is drawn from experience in library development where these
techniques have been simulated in one way or
another~\cite{Gurtovoy02,Lambda02,Tuples01,Function01,Bind01}. Novice
users aren't likely to use this feature, as generically manipulating
heterogeneous type container (tuples, in this case) requires some
degree of metaprogramming.

\subsection{Typesafe Variable-length Function Parameter Lists}
Variable-length function parameter lists allow more arguments to be
passed to a function than are declared by the function. This feature
is rarely used in C++ code (except for compatibility with C
libraries), because passing non-POD types through {\tt ...} invokes
undefined behavior. However, a typesafe form of such a feature would
be useful in many contexts, e.g., for implementing a typesafe C++ {\tt
  printf} that works for non-POD types. The lack of such a facility
has resulted in odd syntax for formatting in the Boost.Format
library~\cite{Krempp02}:
\begin{verbatim}
format("writing %1%, x=%2%: %3%-th try") % "toto" % 40.23 % 50
\end{verbatim}

\subsection{Argument forwarding}
The forwarding problem, as described in~\cite{Dimov02}, is:

\begin{quote}
  For a given expression $E(a_1, a_2, ..., a_n)$ that depends on the
  (generic) parameters $a_1, a_2, ..., a_n$, it is not possible to
  write a function (object) $f$ such that $f(a_1, a_2, ..., a_n)$ is
  equivalent to $E(a_1, a_2, ..., a_n)$.
\end{quote}

The primary issue with the argument forwarding problem is to deduce
the types of $a_1, a_2, ..., a_n$ such that they can be forwarded to
the underlying function $E$ without changing the semantics of the
expression. The common implementation idiom is to accept a (non-const)
reference for each parameter, and to provide overloads for some number
of arguments to forward, e.g.:
\begin{verbatim}
template<typename E, typename T1>
void f(E e, T1& a1) { e(a1); }

template<typename E, typename T1, typename T2>
void f(E e, T1& a1, T2& a2) { e(a1, a2); }

template<typename E, typename T1, typename T2, typename T3>
void f(E e, T1& a1, T2& a2, T3& a3) { e(a1, a2, a3); }

// repeat up to N arguments
\end{verbatim}

However, this idiom fails to accept literal values and also requires
repetition for an arbitrary number of arguments (often done via
preprocessor metaprogramming in the Boost
libraries~\cite{Preprocessor01}). This proposal solves both issues:
arguments are passed via the ``Const + Non-const reference'' option
\#3 enumerated in~\cite{Dimov02}, which results in ``perfect''
forwarding of arguments, but does not require $2^N$ overloads to
support $N$ arguments: instead, a single overload suffices for any
number of arguments. The solution matches all three criteria (C1-C3)
of the argument forwarding paper~\cite{Dimov02} by bundling the
arguments into a single argument and providing an unbundling method to
pass the arguments on to another function.

\section{Syntax and Semantics}
\subsection{Variadic templates}
\par The template parameter list to a function or class template can
be declared to accept an arbitrary number of extra template arguments
by terminating it with ``...'' optionally followed by an identifier
that will hold a tuple of the extra arguments. Any number of template
parameters may precede the ``...''. Thus we can define, for instance,
a class {\tt Foo} accepting a template type parameter followed by an
arbitrary number of template arguments as:
\begin{verbatim}
template<typename T, ... Elements> class Foo;
\end{verbatim}

Here, {\tt T} is the name of the template type parameter and {\tt
  Args} is the name of a ``type parameter pack'' containing
the (possibly empty) set of template arguments given to {\tt
  Foo}. Type parameter packs may contain template type, non-type, and
template template arguments but themselves have no representation in
the C++ type system (i.e., they are not first-class entities in the
type system as are integral constants, types, and templates).

Function templates may also be declared to accept variable-length
template parameter lists in the same manner as class templates. In
this case (and barring reuse of the vararg type as the final function
parameter, as described in the next section) arguments may only by
specified explicitly when calling the function template; they are not
deduced, e.g.,:

\begin{verbatim}
template<... Args> void f();
// ... 
f<int, double>(); // Args will be contain <int, double>
\end{verbatim}

\subsection{Typesafe variadic functions}
When a function template header contains a template parameter pack,
that template parameter pack may be used as the ``type'' of the final
function parameter, allowing the function to accept a variable number
of function parameters in a ``value parameter pack'' (or just
``parameter pack''). For instance, a typesafe C++ {\tt printf} may
be declared as:
\begin{verbatim}
template<... Args>
  void printf(const char* format, Args args);
\end{verbatim}

{\tt Args} is deduced as a template parameter pack containing the types of
the arguments, then {\tt args} is a value parameter pack containing
the function call arguments passed after the {\tt format}
argument.\footnote{Note that, unlike C varargs, we do not require but
  do allow an arguments prior to the argument bundle.} Like template
parameter packs, value parameter packs are not first-class entities:
their type is that of the associated template parameter pack, which is
itself not a type in the type system. Both template and value
parameter packs may be thought of as naming a set of arguments, not as
having any intrinsic type or value themselves.

\subsection{Unpacking template and value parameter packs}
Template and value parameter packs provide only a single operation:
that of unpacking the parameter pack when used to instantiate a
template or call a function. For instance, given a template parameter
pack {\tt Elements}, we can create a {\tt tuple} storing elements of
those types via {\tt tuple<Elements...>}; should we wish to append an
{\tt int} to the end of the tuple, we may write {\tt
  tuple<Elements..., int>}: the ``...'' syntax, suggested
by David Vandevoorde (???), represents an unpacking (or
``uncurrying'') of a template parameter pack into separate
arguments at the place in the instantiation.

Value parameter packs are similarly expanded within a function call,
so that, for instance, a {\tt printf}-like function may pass the
remaining arguments on like this:
\begin{verbatim}
template<typename T, ... Args>
  void printf(const char* s, const T& next, Args args)
  {
    // print characters in s until we hit a formatting command
    // format ``next'' by converting it as appropriate
    // move s after the formatting command
    printf(s, args...);
  }

  void printf(const char* s)
  {
    // print characters in s, verifying that there is no 
    // formatting command
  }
\end{verbatim}

\subsection{Argument type deduction}
The type of each element in the template parameter pack is deduced to
achieve perfect argument forwarding. For an argument {\tt xi}, the
type {\tt Ti} of the corresponding tuple element is the parameter type
of the {\tt forward} function determined by overload resolution using
the following two candidates:
\begin{verbatim}
template<typename T> void forward(T&);
template<typename T> void forward(const T &);
\end{verbatim}

\subsection{Partial ordering of variadic class template partial specializations}
The class template partial specialization partial ordering rules will
need to be augmented to include partial ordering with vararg
templates. Intuitively, a binding to a parameter that falls into a
template's variable-length argument list is weaker than a binding to a
specified template parameter. For instance, given:

\begin{verbatim}
template<...> struct foo;
template<typename T, ...> struct foo<T>; // #1
template<typename T, typename U> struct foo<T, U>; // #2
\end{verbatim}

Partial specialization \#2 is more specialized than partial
specialization \#1 because \#2 requires that the second template
argument by a type (and not a template or acceptable
literal). 

Formalizing this notion, we introduce a new type of template
parameter we call a template {\em variant} parameter. Template variant
parameters cannot be declared explicitly, but occur implicitly as
parameters for variadic templates. However, any template argument
(type, nontype, or template) can be passed to a template {\em variant}
parameter. 

Paragraph 3 of 14.5.5.2 [temp.func.order] describes the rules for
transforming a template for the purpose of partial ordering. To
support partial ordering with template varargs, introduce two
additional bullets:
\begin{itemize}
\item If after removing the variable-length template parameter list
  designator from both templates the template parameter lists of the
  templates are of different length, append unique template variant
  parameters to the shorter template parameter list until the template
  parameter lists are of equal length.
\item A binding of an argument to a variant parameter is weaker than a
  binding of an argument to a parameter of the same kind.
\end{itemize}

\subsection{Overloading}
\label{overloading}
The overloading rules need two minor changes to accomodate template
varargs:
\begin{itemize}
\item Template vararg functions follow the same overloading rules as
  non-template vararg functions.
\item If two overloads differ only in that one is a template vararg
  function and the other is a non-template vararg function, the
  template vararg function is more specialized.
\end{itemize}

Thus we prefer the typesafe variadic functions to unsafe variadic
functions, even though these rules conflict with 13.3.3p1, which
prefers non-template functions to template functions when the
conversion sequences are otherwise equal.

\subsection{The types of variadic templates}
Since parameter packs have no associated types, we specify the
type of an instantiation typesafe variadic function to be equivalent
to the type of a nontemplate function with all template parameters
substituted and both the template and value parameter packs unpacked
at the end of the template and function parameter lists,
respectively. Revisiting the {\tt printf} definition

\begin{verbatim}
template<typename T, ... Args>
  void printf(const char*, const T&, Args args);
\end{verbatim}

and given a call {\tt printf(``\%i:\%f'', 5, 3.14f)}, the type of this
{\tt printf} instantiation will be {\tt void(const char*, const int\&,
  const float\&)}. This type compatibility is logical within the
context of templates (i.e., it follows the existing behavior of
instantiations of function templates), necessary because parameter
packs do not have a representation in the type system, and useful in the
implementation of the polymorphic function adaptors~\cite{Gregor02}
proposal, which has placed the most stress on the formulation of
variadic templates thus far.

\section{Revision history}
HERE HERE HERE

\section{Examples}
To demonstrate the use of variadic templates, this section gives
skeletal implementations of four library components using vararg
templates,. All of these proposals were accepted by the library
working group into the first library TR, and are implementable to some
degree in C++03. However, all of them would benefit from variadic
templates in that the implementations can be more complete, more
useful, and more readable than their C++03 counterparts. The following
libraries are implemented:

\begin{itemize}
\item Member pointer adaptors~\cite{Dimov03a}
\item Tuples~\cite{Jarvi02}
\item Function object wrappers~\cite{Gregor02}
\item Function object binder~\cite{Dimov03b}
\end{itemize}

The implementations are not generally complete, but omit only features
that are irrelevant to the discussion of template varargs. The
implementations use several class templates (metafunctions) from the
type traits proposal~\cite{Maddock03}.

\subsection{Building Blocks}
\label{building_blocks}
The class template {\tt enable\_if} is used liberally to help guide
the overload process by eliminating candidates from the overload set
that would otherwise cause ambiguities or be selected when they
shouldn't be. It is defined as:

\begin{verbatim}
template<bool Cond, typename T> struct enable_if;
template<typename T> struct enable_if<true, T> { typedef T type; };
template<typename T> struct enable_if<false, T> {};
\end{verbatim}

We also rely on a tuple-specific version of the {\tt transform}
function found in the standard library. The tuple transform transforms
a tuple of length $N$ into another tuple of length $N$ by applying a
function object to each element in the source tuple and initializing
the corresponding element in the result tuple. Note that the types in
the result tuple ({\tt U1}, {\tt U2}, ..., {\tt UN}) are the types
returned from the transforming function object, as we assume these
will be available (e.g., via a {\tt typeof} extension or using the
library-defined {\tt result\_of}~\cite{Gregor03}). The following
pseudo-definition defines {\tt transform}:
\begin{verbatim}
// Type Ui is the type of f(std::get<i-1>(t))
template<typename T1, typename T2, ..., typename TN, typename F>
tuple<U1, U2, ..., UN> transform(const tuple<T1, T2, ..., TN>& t, F f)
{ 
  return tuple<U1, U2, ..., UN>(f(std::get<0>(t)), 
                                f(std::get<1>(t)),
                                      ...
                                f(std::get<N-1>(t)));
}
\end{verbatim}

Transform can be implemented as follows using template varargs:

\begin{verbatim}
template<typename F>
struct transformer
{
  transformer(F& f) : f(f) {}

  // U1 is the type of f(a1)
  template<typename T1, ... Args>
  the-return-type operator()(T1& a1, Args args) const
    { return tuple_cons<U1>(f(a1), std::apply(*this, args)); }

  // U1 is the type of f(a1)
  template<typename T1, ... Args>
  the-return-type operator()(const T1& a1, Args args) const
    { return tuple_cons<U1>(f(a1), std::apply(*this, args)); }

  // basis case
  tuple<> operator()() const { return tuple<>(); }

private:
  F& f;
};

template<typename Tuple, typename F>
the-return-type transform(const Tuple& t, F f)
{
  return std::apply(transformer<F>(f), t);
}
\end{verbatim}

\subsection{Member pointer adaptor implementation}
\label{mem_fnimpl}
The following code implements the enhanced member pointer adaptor
proposal~\cite{Dimov03a}. This implementation is complete.

\small
\begin{verbatim}
// Adaptor for member function pointers
template<typename Class, typename FunctionType>
struct mem_fn_adaptor
{
  typedef typename function_traits<FunctionType>::result_type result_type;

  mem_fn_adaptor(FunctionType Class::*pmf) : pmf(pmf) {}
  
  template<... Args>
  result_type operator()(Class& object, Args args) const
    { return std::apply(pmf, object, args); }

  template<... Args>
  result_type operator()(const Class& object, Args args) const
    { return std::apply(pmf, object, args); }

  template<typename T, ... Args>
  typename enable_if<(!is_base_of<Class, T>::value), result_type>::type
  operator()(T& ptr, Args args) const
    { return std::apply(pmf, *ptr, args); }

  template<typename T, ... Args>
  typename enable_if<(!is_base_of<Class, T>::value), result_type>::type
  operator()(const T& ptr, Args args) const
    { return std::apply(pmf, *ptr, args); }

private:
  FunctionType Class::*pmf;
};

// Adaptor for member data pointers (for completeness only)
template<typename Class, typename T>
struct mem_ptr_adaptor
{
  typedef const T& result_type;

  mem_ptr_adaptor(T Class::*pm) : pm(pm) {}

  T& operator()(Class& object) const { return object.*pm; }
  const T& operator()(const Class& object) const { return object.*pm; }

  
  template<typename Ptr> 
  typename enable_if<(!is_base_of<Class, Ptr>::value), const T&>::type
    operator()(Ptr& ptr) const { return (*ptr).*pm; }

  template<typename Ptr> 
  typename enable_if<(!is_base_of<Class, Ptr>::value), const T&>::type
    operator()(const Ptr& ptr) const { return (*ptr).*pm; }

private:
  T Class::*pm;
};

template<typename Class, typename FunctionType>
typename enable_if<(is_function<FunctionType>::value), 
                   mem_fn_adaptor<Class, FunctionType> >::type
mem_fn(FunctionType Class::*pmf)
  { return mem_fn_adaptor<Class, FunctionType>(pmf); }

template<typename Class, typename T>
typename enable_if<(!is_function<T>::value), 
                   mem_fn_adaptor<Class, T> >::type
mem_fn(T Class::*pm)
  { return mem_fn_adaptor<Class, T>(pm); }
\end{verbatim}
\normalsize 

\subsection{Tuple implementation}
\label{tupleimpl}
The following code implements the interesting portions of the Tuple
proposal~\cite{Jarvi02} using template varargs as proposed here. Note
that there is a mutual dependency: template varargs depend on tuples
and tuples are specified as a class template accepting a
variable-length template argument list. However, this mutual
dependency is not problematic, because we split a tuple of length $N$
into a head element and a tail tuple of length $N-1$, with the base
case (length $0$) as an explicit specialization.

\small
\begin{verbatim}
// Derivation from tuple_base indicates that a type is a tuple
class tuple_base {};

// Determine if type T is a tuple
template<typename T>
struct is_tuple
  { static const bool value = is_base_of<tuple_base, T>::value; };

// A tuple of arbitrary length N
template<typename T1, ... Elements>
class tuple : public tuple_base 
{
  typedef T1 head_type;
  typedef typename add_reference<typename add_const<head_type>::type>::type head_param_type;
  typedef Elements tail_type;
  typedef tuple self_type;

public:
  static const size_t size = 1 + tail_type::size;

  tuple() {}

  // enable_if condition ensures that we only match if N arguments are given
  template<... Tail> 
  explicit tuple(typename enable_if<(Args::size == size - 1),
                                    head_param_type>::type head,
                 Tail tail)
    : head(head), tail(tail) {}

  // enable_if condition only allows us to attempt implicit conversions
  // from tuples of the appropriate length
  template<typename Tuple>
  tuple(const Tuple& other,
        typename enable_if<(is_tuple<Tuple>::value && size == Tuple::size), 
                           void>::type* = 0)
    : head(other.head), tail(other.tail) {}

  // enable_if condition only allows us to attempt assignment from tuples of
  // the appropriate length
  template<typename Tuple>
  typename enable_if<(is_tuple<Tuple>::value && size == Tuple::size),
                     tuple&>::type
  operator=(const Tuple& tuple)
  {
    head = other.head;
    tail = other.tail;
    return *this;
  }

private:
  head_type head;
  tail_type tail;
};

// Base case: a nullary tuple
template<> class tuple<> : public tuple_base 
{
public:
  static const size_t size = 0;
};

// 2-element case, for pair specializations
template<typename T1, typename T2>
class tuple : public tuple_base 
{
  typedef T1 head_type;
  typedef tuple<T2> tail_type;

  typedef typename add_cv<T1>::type param1_type;
  typedef typename add_cv<T2>::type param2_type;

public:
  static const size_t size = 2;

  tuple() {}

  tuple(param1_type t1, param2_type) : head(t1), tail(t2) {}

  template<typename U1, typename U2>
  tuple(const pair<U1, U2>& other) : head(other.first), tail(other.second) {}

  template<typename U1, typename U2>
  tuple(const tuple<U1, U2>& other) : head(other.head), tail(other.tail) {}

  template<typename U1, typename U2>
  tuple& operator=(const pair<U1, U2>& other)
  {
    head = other.first;
    tail = tail_type(other.second);
    return *this;
  }

  template<typename U1, typename U2>
  tuple& operator=(const tuple<U1, U2>& other)
  {
    head = other.head;
    tail = other.tail;
    return *this;
  }

private:
  head_type head;
  tail_type tail;
};

struct convert_make_tuple_arg
{
  template<typename T> T operator()(T& t) { return t; }
  template<typename T> T& operator()(reference_wrapper<T>& t) { return t.get(); }
};

template<... Args> the-return-type make_tuple(Args args)
  { return transform(args, convert_make_tuple_arg()); }

template<... Args> Args tie(Args args) { return args; }
\end{verbatim}
\normalsize

\subsection{Function implementation}
\label{functionimpl}
This section implements the core interesting portions of class
template {\tt function} from the function object wrapper
proposal~\cite{Gregor02}.  
\small
\begin{verbatim}
struct bad_function_call : public std::exception {};

template<typename R, typename Args>
struct function_invoker_base
{
  virtual ~function_invoker_base() {}
  virtual R invoke(Args& args) = 0;
  virtual function_invoker_base* clone() = 0;
};

template<typename R, typename Args, typename F>
struct function_invoker : public function_invoker_base<R, Args>
{
  function_invoker(F f) : f(f) {}
  R invoke(Args& args) { return std::apply(f, args); }
  function_invoker_base<R, Args>* clone() { return new function_invoker(f); }

private:
   F f;
};

template<typename Args, typename F>
struct function_invoker<void, Args, F> 
  : public function_invoker_base<void, Args>
{
  function_invoker(F f) : f(f) {}
  void invoke(Args & args) { std::apply(f, args); }
  function_invoker_base<void, Args>* clone() { return new function_invoker(f); }

private:
  F f;
};

template<typename Function> // Function type R(T1, T2, ..., TN)
struct function
{
  typedef typename function_traits<Function>::result_type result_type;
  typedef typename function_traits<Function>::argument_types argument_types;
  
private:
  typedef function_invoker_base<result_type, argument_types> invoker_type;
  
public:
  function() : invoker(0) {}
  
  function(const function& other) : invoker(0)
    { if (other.invoker) invoker = other.invoker->clone(); }

  template<typename F> function(F f) : invoker(0)
    { invoker = new function_invoker<result_type, argument_types, F>(f); }

  template<typename F> function(reference_wrapper<F> f) : invoker(0)
  { 
    invoker = new function_invoker<result_type, argument_types, F&>(f.get()); 
  }
  
  template<typename T, typename C> function(T C::*pm) : invoker(0)
    { *this = std::mem_fn(pm); }

  function(int) : invoker(0) {}
  
  ~function() { if (invoker) { delete invoker; invoker = 0; } }

  function& operator=(const function& other)
  {
    function tmp(other);
    tmp.swap(*this);
    return *this;
  }
  
  template<typename F> function& operator=(F f)
  {
    function tmp(f);
    tmp.swap(*this);
    return *this;
  }
  
  operator bool() const { return invoker; }

  template<... Args>
  result_type operator()(Args args) const
  {
    if (!invoker) throw bad_function_call;
    return invoker->invoke(args);
  }
  
  void swap(function& other)
  {
    using std::swap;
    swap(invoker, other.invoker);
  }
  
private:
  invoker_type* invoker;
};
\end{verbatim}
\normalsize

\subsection{Bind implementation}
\label{bindimpl}
The following code implements the enhanced binder
proposal~\cite{Dimov03b} using vararg templates, and building on the
existing tuple and member pointer adaptor code. This implementation is
complete, with two exceptions (both of which require uninteresting but
nontrivial code, expressible in C++03):
\begin{itemize}
  \item {\tt result\_type} is not specified in {\tt binder}
  \item arity checking is not performed at bind time
\end{itemize}

 \small
\begin{verbatim}
// Placeholders
template<int N> struct placeholder {};

namespace placeholders {
  typedef placeholder<1> _1;
  typedef placeholder<2> _2;
  typedef placeholder<3> _3;
}

template<typename T> struct is_placeholder : integral_constant<size_t, 0> {};

template<int N> 
struct is_placeholder<placeholder<N> > : integral_constant<size_t, N> {};

// Lambda
template<typename X> X& lambda(const reference_wrapper<X>& x)
  { return x.get(); }
template<typename X> X& lambda(X& x)
  { return x; }

// Mu
template<typename X, typename Args> X& mu(reference_wrapper<X>& x, Args&)
  { return x.get(); }

template<typename X, typename Args>
typename enable_if<(is_placeholder<X>::value),
                   typename tuple_element<X, is_placeholder<X>::value-1>::type
                   >::type
mu(X&, Args& args)
  { return std::get<is_placeholder<X>::value-1>(args); }

template<typename X, typename Args>
typename enable_if<(is_bind_expression<X>::value), the-return-type>::type
mu(X& x, Args& args)
  { return std::apply(x, args); }

template<typename X, typename Args> X& mu(X& x, Args&)
  { return x; }

// Unary function object that calls mu with the object 'x' it receives
// and the bound arguments from binder_t.
template<typename BoundArgs>
struct apply_mu_t
{
  explicit apply_mu_t(BoundArgs& bound_args) : bound_args(bound_args) {}

  template<typename X> the-return-type operator()(X& x) const
    { return mu(x, bound_args); }

private:
  BoundArgs bound_args;
};

// Return type of bind(...)
template<typename F, typename BoundArgs>
struct binder
{
  binder(const F& f, const BoundArgs& bound_args)
    : f(f), bound_args(bound_args) {}

  template<... Args> the-return-type operator()(Args args)
    { return std::apply(lambda(f), transform(args, apply_mu(bound_args))); }

  template<... Args> the-return-type operator()(Args args) const
    { return std::apply(lambda(f), transform(args, apply_mu(bound_args))); }

private:
  F f;
  BoundArgs bound_args;
};

// Helper to construct binder objects
template<typename F, typename BoundArgs>
binder<F, BoundArgs> make_binder(F f, const BoundArgs& bound_args)
  { return binder<F, BoundArgs>(f, bound_args); }

// Determine if a type T is a binder type
template<typename T> struct is_bind_expression : integral_constant<bool, false> {};

template<typename F, typename BoundArgs>
struct is_bind_expression<binder<F, BoundArgs> > : integral_constant<bool, true> {};

// Remove the reference from a value
struct remove_ref { template<typename T> T operator()(T& x) const { return x; } };

// Bind overload for function objects and function pointers
template<typename F, ... BoundArgs>
the-return-type bind(F f, BoundArgs bound_args)
  { return make_binder(f, transform(bound_args, remove_ref())); }

// Bind overload for member pointers (both function and data)
template<typename Class, typename T, ... BoundArgs>
the-return-type bind(T Class::*pm, BoundArgs bound_args)
  { return make_binder(mem_fn(f), transform(bound_args, remove_ref())); }
\end{verbatim}
\normalsize

\bibliographystyle{abbrv}
\bibliography{template_varargs}
\end{document}
