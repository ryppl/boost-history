\documentclass[american,twoside]{book}
\usepackage{refbib}
\usepackage{hyperref}
\input{macros}

%%--------------------------------------------------
%% Set section numbering limit, toc limit
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{1}

%%--------------------------------------------------
%% Parameters that govern document appearance
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.6in}

%%--------------------------------------------------
%% Handle special hyphenation rules
\hyphenation{tem-plate ex-am-ple in-put-it-er-a-tor}

% Do not put blank pages after chapters that end on odd-numbered pages.
\def\cleardoublepage{\clearpage\if@twoside%
  \ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage%
  \if@twocolumn\hbox{}\newpage\fi\fi\fi}

\begin{document}
\raggedbottom

\begin{titlepage}
\begin{center}
\huge
Concepts for the C++0x Standard Library: Containers\\
(Revision 1)

\vspace{0.5in}

\normalsize
Douglas Gregor  \\
Open Systems Laboratory \\
Indiana University \\
Bloomington, IN\ \  47405 \\
\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}
\end{center}

\vspace{1in}
\par\noindent Document number: D2623=08-0133\vspace{-6pt}
\par\noindent Revises document number: N2085=06-0155\vspace{-6pt}
\par\noindent Date: \today\vspace{-6pt}
\par\noindent Project: Programming Language \Cpp{}, Library Working Group\vspace{-6pt}
\par\noindent Reply-to: Douglas Gregor $<$\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}$>$\vspace{-6pt}

\section*{Introduction}
\libintrotext{Chapter 23}
\end{titlepage}

%%--------------------------------------------------
%% Headers and footers
\pagestyle{fancy}
\fancyhead[LE,RO]{\textbf{\rightmark}}
\fancyhead[RE]{\textbf{\leftmark\hspace{1em}\thepage}}
\fancyhead[LO]{\textbf{\thepage\hspace{1em}\leftmark}}
\fancyfoot[C]{Draft}

\fancypagestyle{plain}{
\renewcommand{\headrulewidth}{0in}
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\fancyfoot{}
}

\renewcommand{\sectionmark}[1]{\markright{\thesection\hspace{1em}#1}}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

\color{black}

\setcounter{chapter}{22}
\rSec0[lib.containers]{Containers library}

\pnum
This clause describes components that \Cpp\ programs may use to
organize collections of information.

\pnum
The following subclauses describe
container \changedConcepts{requirements}{concepts},
and components for
sequences and
associative containers,
as summarized in
Table~\ref{tab:containers.lib.summary}:

\begin{libsumtab}{Containers library summary}{tab:containers.lib.summary}
\ref{lib.container.requirements} Requirements   &   \addedConcepts{\ttfamily <container>}                    \\ \rowsep
\ref{lib.sequences} Sequences                   &   \tcode{<array>}     \\
                                                &   \tcode{<deque>}     \\
                                                &   \tcode{<list>}      \\
                                                &   \tcode{<queue>}     \\
                                                &   \tcode{<stack>}     \\
                                                &   \tcode{<vector>}    \\ \rowsep
\ref{lib.associative} Associative containers    &   \tcode{<map>}       \\
                                                &   \tcode{<set>}       \\
\ref{lib.template.bitset} \tcode{bitset}        &   \tcode{<bitset>}    \\ \rowsep
\ref{lib.unord} \addedB{Unordered associative containers}&   \tcode{<unordered_map>}       \\
                                                &   \tcode{<unordered_set>}       \\
\end{libsumtab}

\rSec1[lib.container.requirements]{Container requirements}
\index{requirements!container}%

\pnum
Containers are objects that store other objects.
They control allocation and deallocation of these objects
through constructors, destructors, insert and erase operations.

\pnum
All of the complexity requirements in this clause are stated solely
in terms of the number of operations on the contained objects.
\enterexample\ 
the copy constructor of type
\tcode{vector <vector<int> >}\
has linear complexity,
even though the complexity of copying each contained
\tcode{vector<int>}\
is itself linear.
\exitexample\ 

\pnum
\removedConcepts{The type of objects stored in these components shall meet the requirements of
CopyConstructible
types (20.1.3).}

\pnum
\removedConcepts{Table~79 defines the Assignable requirement.
Some containers require this property of the types to be stored in the
container.
T
is the type used to instantiate the container,
t is a value of T,
and u is a value of (possibly
const) T.}

\eremove{Remove Table 79: Assignable requirements. Assignable is now a
  concept in Chapter 20.}

\color{addclr}
\synopsis{Header \tcode{<container>}\ synopsis}

\color{black}
\editorial{Note: Synchronize this with the rest of the text.}
\color{addclr}

\pnum
\removedConcepts{In Tables~80 and
81, X
denotes a container class containing objects of type
T, a and b
denote values of type X, u
denotes an identifier and r
denotes a value of X\&.} \color{addclr} The \tcode{Container}\ concept
describes the requirements common to all containers.

\begin{itemdecl}
concept Container<typename X> : DefaultConstructible<X>
{
  typename value_type =            X::value_type;
  typename reference =             X::reference;
  typename const_reference =       X::const_reference;
  InputIterator iterator =         X::iterator;
  InputIterator const_iterator =   X::const_iterator;
  SignedIntegral difference_type = X::difference_type;
  UnsignedIntegral size_type =     X::size_type;

  where Convertible<reference, value_type&> &&
        Convertible<const_reference, value_type const&>;

  where Convertible<iterator, const_iterator> &&
        SameType<iterator::value_type, value_type> &&
        SameType<const_iterator::value_type, value_type>;
 
  where SameType<difference_type, iterator::difference_type> &&
        SameType<difference_type, const_iterator::difference_type>;

  iterator       X::begin();
  const_iterator X::begin() const;
  iterator       X::end();
  const_iterator X::end() const;

  const_iterator X::cbegin() const;
  const_iterator X::cend() const;

  void X::swap(X&);

  size_type X::size() const;
  size_type X::max_size() const;
  bool X::empty() const;
}
\end{itemdecl}

\color{black}
\eremove{Remove Table 80: Container requirements}

\editorial{In translating the requirements table into a concept, we
  have fixed numerous places where the requirements table required a
  non-constant container, but where a constant container would
  work. This should not break any existing code.}
\color{addclr}

\begin{itemdecl}
X::X()
\end{itemdecl}

\begin{itemdescr}
\pnum
\postcondition\
\tcode{size() == 0}

\pnum
\complexity\
constant
\end{itemdescr}

\begin{itemdecl}
X::~X()
\end{itemdecl}

\begin{itemdescr}
\pnum
\note\
the destructor is applied to every element of \changedConcepts{a}{the
  container}; all the memory is deallocated

\pnum
\complexity\
linear
\end{itemdescr}

\begin{itemdecl}
iterator       X::begin();
const_iterator X::begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
an iterator referring to the first element in the container.
\pnum
\complexity\
constant
\end{itemdescr}

\begin{itemdecl}
iterator       X::end();
const_iterator X::end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
returns an iterator which is the past-the-end value for the container.
If the container is empty, then
\tcode{begin() == end()};

\pnum
\complexity\
constant
\end{itemdescr}

\begin{itemdecl}
const_iterator X::cbegin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_cast<X const\&>(*this).begin()}

\pnum
\complexity\
constant
\end{itemdescr}

\begin{itemdecl}
const_iterator X::cend() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_cast<X const\&>(*this).end()}

\pnum
\complexity\
constant
\end{itemdescr}

\begin{itemdecl}
void X::swap(X& b)
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
\tcode{swap(*this, b)}

\pnum
\complexity\
should be constant
\end{itemdescr}

\begin{itemdecl}
size_type X::size() const
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
returns the number of elements in the container.

\pnum
\complexity\
should be constant

\pnum
\note\
\changedConcepts{Its semantics}{The semantics of size()} is defined by the rules of constructors, inserts, and erases.
\end{itemdescr}

\begin{itemdecl}
size_type X::max_size() const
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{size()}\ of the largest possible container

\pnum
\complexity\
should be constant
\end{itemdescr}

\begin{itemdecl}
bool X::empty() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{size() == 0}

\pnum
\complexity\
constant
\end{itemdescr}

\pnum
In the expressions
\begin{codeblock}
    i == j
    i != j
    i < j
    i <= j
    i >= j
    i > j
    i - j
\end{codeblock}
where
\tcode{i}\
and
\tcode{j}\
denote objects of a container's
\tcode{iterator}\
type, either or both may be replaced by an object of the container's
\tcode{const_iterator}\
type referring to the same element with no change in semantics.

\color{black}
\editorial{The requirements table for containers calls for copy
  construction, assignment, and various comparison operators. However,
  these operators only work when the value type supports copy
  construction, assignment, etc. To capture this behaviro, we state
  these requirements via concept map templates.}
\color{addclr}

\begin{itemdecl}
@\textcolor{addclr}{template}@<Container X>
where CopyConstructible<X::value_type>
concept_map CopyConstructible<X> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
If the \tcode{value_type}\ of a container is
\tcode{CopyConstructible}, the container shall be
\tcode{CopyConstructible}

\pnum
\complexity\
linear
\end{itemdescr}

\begin{itemdecl}
template<Container X>
where Assignable<X::value_type>
concept_map Assignable<X> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
If the \tcode{value_type}\ of a container is
\tcode{Assignable}, the container shall be
\tcode{Assignable}

\pnum
\complexity\
linear
\end{itemdescr}

\begin{itemdecl}
template<Container X>
where EqualityComparable<X::value_type>
concept_map EqualityComparable<X> 
{ 
  bool operator==(X a, X b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
If the \tcode{value_type}\ of a container is
\tcode{EqualityComparable}, the container shall be
\tcode{EqualityComparable}
\end{itemdescr}

\begin{itemdecl}
bool operator==(X a, X b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
 \tcode{==}\ is an equivalence relation.

\pnum
\returns\
 \tcode{a.size() == b.size()}
 \tcode{\&\& equal(a.begin(),}
 \tcode{a.end(), b.begin()}

\pnum
\complexity\
linear
\end{itemdescr}

\begin{itemdecl}
template<Container X>
where LessThanComparable<X::value_type>
concept_map LessThanComparable<X> 
{ 
  bool operator<(X a, X b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
If the \tcode{value_type}\ of a container is
\tcode{LessThanComparable}, the container shall be
\tcode{LessThanComparable}
\end{itemdescr}

\begin{itemdecl}
bool operator<(X a, X b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
 \tcode{lexicographical_compare( a.begin(), a.end(), b.begin(), b.end())}

\pnum
\complexity\
linear
\end{itemdescr}

\color{black}

\pnum
Copy constructors for all container types defined in this clause
copy an allocator argument from their respective first parameters.
All other constructors for these container types take an
\tcode{Allocator\&}\
argument (\ref{lib.allocator.requirements}),
an allocator whose value type is the same as the container's value type.
A copy of this argument is used for any memory allocation
performed, by these constructors and by all member functions, during
the lifetime of each container object.
In all container types defined
in this clause, the member \tcode{get_allocator()}\ returns a copy
of the Allocator object used to construct the container.%
\footnote{As specified in~\ref{lib.allocator.requirements}, \removedConcepts{paragraphs 4-5},
the semantics described in this clause applies only to the case where
allocators compare equal.
}

\pnum
\addedConcepts{Containers that provide the ability to traverse their
  elements in reverse order are called reversible.}

\color{addclr}
\begin{itemdecl}
concept ReversibleContainer<typename X> : Container<X> {
  MutableBidirectionalIterator reverse_iterator       = X::reverse_iterator;
  BidirectionalIterator const_reverse_iterator = X::const_reverse_iterator;

  where MutableBidirectionalIterator<iterator> &&
        BidirectionalIterator<const_iterator>;

  where SameType<iterator::value_type, reverse_iterator::value_type> &&
        SameType<const_iterator::value_type, const_reverse_iterator::value_type>;

  reverse_iterator       X::rbegin();
  const_reverse_iterator X::rbegin() const;
  reverse_iterator       X::rend();
  const_reverse_iterator X::rend() const;
  const_reverse_iterator X::crbegin() const;
  const_reverse_iterator X::crend() const;
}
\end{itemdecl}
\color{black}

\eremove{Remove Table 81: Reversible container requirements}

\pnum
If the iterator type of a container \changedConcepts{belongs to the bidirectional or
random access iterator categories}{is bidirectional or random access} (\ref{lib.iterator.requirements}),
\changedConcepts{the container is called
reversible
and satisfies the additional requirements
in Table~81}{the container is reversible.}

\color{addclr}
\begin{itemdecl}
template<Container X>
where MutableBidirectionalIterator<X::iterator> &&
      BidirectionalIterator<X::const_iterator>
concept_map ReversibleContainer<X>
{
  typedef std::reverse_iterator<X::iterator>       reverse_iterator;
  typedef std::reverse_iterator<X::const_iterator> const_reverse_iterator;

  @\textcolor{addclr}{reverse}@_iterator       X::rbegin();
  const_reverse_iterator X::rbegin() const;
  reverse_iterator       X::rend();
  const_reverse_iterator X::rend() const;
  const_reverse_iterator X::crbegin() const;
  const_reverse_iterator X::crend() const;
}
\end{itemdecl}

\begin{itemdecl}
reverse_iterator       X::rbegin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{reverse_iterator(end())}
\end{itemdescr}

\begin{itemdecl}
const_reverse_iterator       X::rbegin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_reverse_iterator(end())}
\end{itemdescr}

\begin{itemdecl}
reverse_iterator       X::rend();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_reverse_iterator(begin())}
\end{itemdescr}

\begin{itemdecl}
const_reverse_iterator       X::rend() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_reverse_iterator(begin())}
\end{itemdescr}

\begin{itemdecl}
const_reverse_iterator X::crbegin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_cast<const X\&>(*this).rbegin()}
\end{itemdescr}

\begin{itemdecl}
const_reverse_iterator X::crend() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_cast<const X\&>(*this).rend()}
\end{itemdescr}

\color{black}

\pnum
Unless otherwise specified (see~\ref{lib.deque.modifiers}\ and
\ref{lib.vector.modifiers})
all container types defined in this clause meet
the following additional requirements:

\begin{itemize}
\item
if an exception is thrown by an
\tcode{insert()}
function while inserting a single element, that
function has no effects.
\item
if an exception is thrown by a
\tcode{push_back()}
or
\tcode{push_front()}
function, that function has no effects.
\item
no
\tcode{erase()},
\tcode{pop_back()}
or
\tcode{pop_front()}
function throws an exception.
\item
no copy constructor or assignment operator of a returned iterator
throws an exception.
\item
no
\tcode{swap()}
function throws an exception unless that
exception is thrown by the copy constructor or
assignment operator of the container's
Compare object (if any; see \ref{lib.associative.reqmts}).
\item
no
\tcode{swap()}
function invalidates any references,
pointers, or iterators referring to the elements
of the containers being swapped.
\end{itemize}

\pnum
Unless otherwise specified (either explicitly or by defining a
function in terms of other functions), invoking a container member
function or passing a container as an argument to a library function
shall not invalidate iterators to, or change the values of, objects
within that container.

\rSec2[lib.sequence.reqmts]{\textcolor{black}{Sequences}}

\pnum
A sequence is a kind of container that organizes a finite set of objects, all of the same type,
into a strictly linear arrangement.
The library provides three basic kinds of sequence containers:
\tcode{vector},
\tcode{list},
and
\tcode{deque}.
It also provides container adaptors that make it easy to construct abstract data types, such as
\tcode{stack}s
or
\tcode{queue}s,
out of the basic sequence kinds (or out of other kinds of sequences that the user might define).

\pnum
\tcode{vector},
\tcode{list},
and
\tcode{deque}
offer the programmer different complexity trade-offs and should be used
accordingly.
\tcode{vector}\
is the type of sequence that should be used by default.
\tcode{list}\
should be used when there are frequent insertions and deletions from the middle of the sequence.
\tcode{deque}\
is the data structure of choice
when most insertions and deletions take place at the beginning or at the end of the sequence.

\pnum
\removedConcepts{In Tables~82
and 83, X
denotes a sequence class,
a denotes a value of X,
i and j
denote iterators satisfying input iterator requirements,
[i, j)
denotes a valid range, n
denotes a value of X::size\_type,
p denotes a valid iterator to
a, q
denotes a valid dereferenceable iterator to
a, [q1, q2)
denotes a valid range in
a, and t
denotes a value of X::value\_type.}

\pnum
The complexities of the expressions are sequence dependent.

\eremove{Remove Table 82: Sequence requirements (in addition to
  container)}

\color{addclr}
\pnum 
Sequences are described by the \tcode{Sequence},
\tcode{FrontInsertionSequence}, and \tcode{BackInsertionSequence} concepts.

\begin{itemdecl}
concept Sequence<typename X> : Container<X>
{
  where MutableForwardIterator<iterator> && ForwardIterator<const_iterator>;

  X::X(size_type n, value_type t);

  template<InputIterator Iter>
    where Convertible<Iter::value_type, value_type>
    X::X(Iter first, Iter last);

  iterator X::insert(iterator p, value_type t);
  void X::insert(iterator p, size_type n, value_type t);
  template<InputIterator Iter>
    where Convertible<Iter::value_type, value_type>
    void X::insert(iterator p, Iter first, Iter last);

  iterator X::erase(iterator q);
  iterator X::erase(iterator q1, iterator q2);

  void X::clear();

  template<InputIterator Iter>
    where Convertible<Iter::value_type, value_type>
    void X::assign(Iter first, Iter last);
  void X::assign(size_type n, value_type);
}
\end{itemdecl}

\begin{itemdecl}
X::X(size_type n, value_type t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
constructs a sequence with \tcode{n}\ copies of \tcode{t}\

\pnum
\postcondition\
\tcode{size() == n}
\end{itemdescr}

\begin{itemdecl}
template<InputIterator Iter>
  where Convertible<Iter::value_type, value_type>
  X::X(Iter first, Iter last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
constructs a sequence equal to the range \tcode{[i, j)}

\pnum
\postconditions\
\tcode{size() == distance}\ between \tcode{i}\ and \tcode{j}
\end{itemdescr}

\begin{itemdecl}
iterator X::insert(iterator p, value_type t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
inserts a copy of \tcode{t}\ before \tcode{p}

\pnum
\returns\
\addedConcepts{an iterator that} points to the copy of
\tcode{t}\
inserted into
\tcode{a}.
\end{itemdescr}

\begin{itemdecl}
void X::insert(iterator p, size_type n, value_type t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
inserts \tcode{n}\ copies of \tcode{t}\ before \tcode{p}
\end{itemdescr}

\begin{itemdecl}
template<InputIterator Iter>
  where Convertible<Iter::value_type, value_type>
  void X::insert(iterator p, Iter first, Iter last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\precondition\
\tcode{i}\ and \tcode{j}\ are not iterators into \tcode{a}

\pnum
\effects\
inserts copies of elements in \tcode{[i, j)} before \tcode{p}
\end{itemdescr}

\begin{itemdecl}
iterator X::erase(iterator q);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
erases the element pointed to by \tcode{q}

\pnum
\returns\
\changedConcepts{The iterator returned from
a.erase(q)}{An iterator that}\
points to the element immediately following
\tcode{q}\
prior to the element being erased.
If no such element exists,
\tcode{a.end()}\
is returned.
\end{itemdescr}

\begin{itemdecl}
iterator X::erase(iterator q1, iterator q2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
erases the elements in the range \tcode{[q1, q2)}.

\pnum
\returns\
\changedConcepts{The iterator returned by
a.erase(q1,q2)}{An iterator that}\
points to the element pointed to by
\tcode{q2}\
prior to any elements being erased.
If no such element exists,
\tcode{a.end()}\
is returned.
\end{itemdescr}

\begin{itemdecl}
void X::clear();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
\tcode{erase(begin(), end())}

\pnum
\postconditions\
\tcode{size() == 0}
\end{itemdescr}

\begin{itemdecl}
template<InputIterator Iter>
  where Convertible<Iter::value_type, value_type>
  void X::assign(Iter first, Iter last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\precondition\
\tcode{i}, \tcode{j}\ are not iterators into \tcode{a}

\pnum
\effects\
Replaces elements in \tcode{a}\ with a copy of \tcode{[i, j)}.
\end{itemdescr}

\begin{itemdecl}
void X::assign(size_type n, value_type);
\end{itemdecl}

\begin{itemdescr}
\pnum
\precondition\
\tcode{t}\ is not a reference into \tcode{a}.

\pnum
\effects\
Replaces elements in \tcode{a}\ with \tcode{n}\ copies of \tcode{t}.
\end{itemdescr}

\eremove{Remove paragraphs 5--11, including the ``do the right thing''
clause.}

\pnum
\changedConcepts{Table~83 lists sequence operations
that are provided for some types of
sequential containers but not others.
An implementation shall provide
these operations for all container types shown in the ``container''
column, and shall implement them so as to take amortized constant
time.}{The BackAccessSequence concept describes sequences for which
the last element can be accessed in amortized constant time.}

\eremove{Remove Table 83: Optional sequence operations}

\begin{itemdecl}
concept BackAccessSequence<typename X> : Sequence<X>
{
  reference       X::back();
  const_reference X::back() const;
}
\end{itemdecl}

\begin{itemdecl}
reference       X::back();
const_reference X::back() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
 \tcode{\{ iterator tmp = end();}\\
 \tcode{    --tmp;}\\
 \tcode{    return *tmp; \}}
\end{itemdescr}

\pnum The \tcode{BackInsertionSequence} concept describes sequences for which
one can insert, remove, or access an element at the end of a container in
amortized constant time.

\begin{itemdecl}
concept BackInsertionSequence<typename X> : BackAccessSequence<X>
{
  void X::push_back(value_type x);
  void X::pop_back();
}
\end{itemdecl}

\begin{itemdecl}
void X::push_back(value_type x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
\tcode{insert(end(),x)}
\end{itemdescr}

\begin{itemdecl}
void X::pop_back();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
 \tcode{\{ iterator tmp = end();}\\
 \tcode{    --tmp;}\\
 \tcode{    erase(tmp); \}}
\end{itemdescr}

\pnum
The \tcode{FrontAccessSequence}\ concept describes sequences for which
one can access the element at the front of the container in amortized
constant time. 

\begin{itemdecl}
concept FrontAccessSequence<typename X> : Sequence<X>
{
  reference       X::front();
  const_reference X::front() const;
}
\end{itemdecl}

\begin{itemdecl}
reference       X::front();
const_reference X::front() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{*begin()}
\end{itemdescr}

\pnum
The \tcode{FrontInsertionSequence}\ concept describes sequences for which
one can insert, remove, or access an element at the front of a container in
amortized constant time.

\begin{itemdecl}
concept FrontInsertionSequence<typename X> : FrontAccessSequence<X>
{
  void X::push_front(value_type x);
  void X::pop_front();
}
\end{itemdecl}

\begin{itemdecl}
void X::push_front(value_type x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
\tcode{insert(begin(),x)}
\end{itemdescr}

\begin{itemdecl}
void X::pop_front();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
\tcode{erase(begin())}
\end{itemdescr}

\pnum
The \tcode{RandomAccessSequence} concept describes sequences that
provide access to any element in the container in amortized constant
time.

\begin{itemdecl}
concept RandomAccessSequence<typename X> 
  : FrontAccessSequence<X>, BackAccessSequence<X>
{
  where MutableRandomAccessIterator<iterator> &&
        RandomAccessIterator<const_iterator>;

  reference       operator[](X& a, size_type n);
  const_reference operator[](const X& a, size_type n);

  reference       at(X& a, size_type n);
  const_reference at(const X& a, size_type n);
}
\end{itemdecl}

\begin{itemdecl}
reference       operator[](X& a, size_type n);
const_reference operator[](const X& a, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{*(a.begin() + n)}
\end{itemdescr}

\begin{itemdecl}
reference       at(X& a, size_type n);
const_reference at(const X& a, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{*(a.begin() + n)}

\pnum
\throws
\tcode{out_of_range} if \tcode{n >= a.size()}.
\end{itemdescr}

\color{black}

\pnum
\addedConcepts{An implementation shall provide the following concept
  maps. When the implementation provides a vector<bool>
  specialization, vector<T> only meets the sequence concept when T is
  not bool.}
\color{addclr}
\begin{itemdecl}
@\textcolor{addclr}{template}@<CopyConstructible T, Allocator Alloc> 
  where !SameType<T, bool> // iff vector<bool> specialization is provided
  concept_map RandomAccessSequence<vector<T, Alloc> > { }
template<CopyConstructible T, Allocator Alloc> 
  where !SameType<T, bool> // iff vector<bool> specialization is provided
  concept_map BackInsertionSequence<vector<T, Alloc> > { }

template<CopyConstructible T, Allocator Alloc> 
  concept_map BackInsertionSequence<list<T, Alloc> > { }
template<CopyConstructible T, Allocator Alloc> 
  concept_map FrontInsertionSequence<list<T, Alloc> > { }

template<CopyConstructible T, Allocator Alloc> 
  concept_map RandomAccessSequence<deque<T, Alloc> > { }
template<CopyConstructible T, Allocator Alloc> 
  concept_map BackInsertionSequence<deque<T, Alloc> > { }
template<CopyConstructible T, Allocator Alloc> 
  concept_map FrontInsertionSequence<deque<T, Alloc> > { }
\end{itemdecl}
\color{black}

\rSec1[lib.sequences]{Sequences}

\pnum
Headers \tcode{<array>}, \tcode{<deque>}, \tcode{<forward_list>}, \tcode{<list>}, \tcode{<queue>}, \tcode{<stack>}, and \tcode{<vector>}.

\synopsis{Header \tcode{<array>}\ synopsis}%
\index{array@\tcode{<array>}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, size_t N > 
    @\addedConcepts{requires Destructible<T>}@
    struct array;
  template <@\changedConcepts{class}{EqualityComparable}@ T, size_t N>
    bool operator==(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, size_t N>
    bool operator!=(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator<(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator>(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator<=(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator>=(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{Swappable}@ T, size_t N >
    void swap(array<T,N>& x, array<T,N>& y);

  template <@\changedConcepts{class}{ObjectType}@ T> class tuple_size;
  template <int I, @\changedConcepts{class}{ObjectType}@ T> 
    class tuple_element;
  template <@\changedConcepts{class}{ObjectType}@ T, size_t N>
    struct tuple_size<array<T, N> >;
  template <int I, class T, size_t N>
    @\addedConcepts{requires True<(I > 0 \&\& I < N)>}@
    struct tuple_element<I, array<T, N> >;
  template <int I, class T, size_t N>
    @\addedConcepts{requires True<(I > 0 \&\& I < N)>}@
    T& get(array<T, N>&); 
  template <int I, class T, size_t N>
    @\addedConcepts{requires True<(I > 0 \&\& I < N)>}@
    const T& get(const array<T, N>&);
}
\end{codeblock}

\synopsis{Header \tcode{<deque>}\ synopsis}%
\index{deque@\tcode{<deque>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator = allocator<T> > 
    @\addedConcepts{requires Destructible<T>}@
    class deque;
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator<(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator>(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>&& x, deque<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>& x, deque<T,Allocator>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<forward_list>} synopsis}%
\index{forward_list@\tcode{<forward_list>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator = allocator<T> > 
    @\addedConcepts{requires Destructible<T>}@
    class forward_list; 
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator> 
    bool operator==(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator> 
    bool operator< (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator> 
    bool operator!=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator> 
    bool operator> (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator> 
    bool operator>=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator> 
    bool operator<=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator> 
    void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>& y); 
}
\end{codeblock}

\synopsis{Header \tcode{<list>}\ synopsis}%
\index{list@\tcode{<list>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator = allocator<T> > 
    @\addedConcepts{requires Destructible<T>}@
    class list;
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator==(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator< (const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator!=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator> (const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator>=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator<=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(list<T,Allocator>& x, list<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(list<T,Allocator>&& x, list<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(list<T,Allocator>& x, list<T,Allocator>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<queue>}\ synopsis}%
\index{queue@\tcode{<queue>}}

\begin{codeblock}
namespace std {
  template <class T, class Container = deque<T> > class queue;
  template <class T, class Container>
    bool operator==(const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Container>
    bool operator< (const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Container>
    bool operator> (const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Allocator>
    void swap(queue<T,Allocator>& x, queue<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(queue<T,Allocator>&& x, queue<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(queue<T,Allocator>& x, queue<T,Allocator>&& y);

  template <class T, class Container = vector<T>,
        class Compare = less<typename Container::value_type> >
  class priority_queue;
  template <class T, class Allocator>
    void swap(priority_queue<T,Allocator>& x, priority_queue<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(priority_queue<T,Allocator>&& x, priority_queue<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(priority_queue<T,Allocator>& x, priority_queue<T,Allocator>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<stack>}\ synopsis}%
\index{stack@\tcode{<stack>}}

\begin{codeblock}
namespace std {
  template <class T, class Container = deque<T> > class stack;
  template <class T, class Container>
    bool operator==(const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Container>
    bool operator< (const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Container>
    bool operator> (const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Allocator>
    void swap(stack<T,Allocator>& x, stack<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(stack<T,Allocator>&& x, stack<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(stack<T,Allocator>& x, stack<T,Allocator>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<vector>}\ synopsis}%
\index{vector@\tcode{<vector>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator = allocator<T> > 
    @\addedConcepts{requires Destructible<T>}@
    class vector;
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator==(const vector<T,Allocator>& x,const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator< (const vector<T,Allocator>& x,const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator!=(const vector<T,Allocator>& x,const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator> (const vector<T,Allocator>& x,const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator>=(const vector<T,Allocator>& x,const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator<=(const vector<T,Allocator>& x,const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(vector<T,Allocator>&& x, vector<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(vector<T,Allocator>& x, vector<T,Allocator>&& y);

  template <class Allocator> class vector<bool,Allocator>;
\end{codeblock}

\rSec2[array]{\marktr{}Class template \tcode{array}}
\index{array@\tcode{array}}%

\pnum
\index{array@\tcode{array}!contiguous storage}%
The header \tcode{<array>} defines a class template for storing fixed-size
sequences of objects. An \tcode{array} supports random access iterators. An
instance of \tcode{array<T, N>} stores \tcode{N} elements of type \tcode{T}, so that 
\tcode{size() == N} is an invariant. The elements of an \tcode{array} are stored contiguously,
meaning that if \tcode{a} is an \tcode{array<T, N>} then it obeys the identity 
\verb|&a[n] == &a[0] + n| for all \tcode{0 <= n < N}.

\pnum
\index{array@\tcode{array}!initialization}%
\index{array@\tcode{array}!as aggregate}%
An \tcode{array} is an aggregate~(\ref{dcl.init.aggr}) that can be
initialized with the syntax
\begin{codeblock}
array a = { initializer-list };
\end{codeblock}

where \textit{initializer-list} is a comma separated list of up
to \tcode{N} elements whose types are convertible to \tcode{T}.

\pnum
\index{requirements!Container}%
Unless otherwise specified, all \tcode{array} operations are as described
in~\ref{container.requirements}. Descriptions are provided here
only for operations on \tcode{array} that are not described in that clause
or for operations where there is additional semantic information.

\index{array@\tcode{array}}%
\index{array@\tcode{array}!begin@\tcode{begin}}%
\index{begin@\tcode{begin}!array@\tcode{array}}%
\index{array@\tcode{array}!end@\tcode{end}}%
\index{end@\tcode{end}!array@\tcode{array}}%
\index{array@\tcode{array}!size@\tcode{size}}%
\index{size@\tcode{size}!array@\tcode{array}}%
\index{array@\tcode{array}!max_size@\tcode{max_size}}%
\index{max_size@\tcode{max_size}!array@\tcode{array}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, size_t N >
  @\addedConcepts{requires Destructible<T>}@
  struct array {
    //  types:
    typedef T &                                   reference;
    typedef const T &                             const_reference;
    typedef @{\itshape implementation defined}@                iterator;
    typedef @{\itshape implementation defined}@                const_iterator;
    typedef size_t                                size_type;
    typedef ptrdiff_t                             difference_type;
    typedef T                                     value_type;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    T       elems[N];           // \expos

    // No explicit construct/copy/destroy for aggregate type

    @\addedConcepts{requires CopyAssignable<T>}@ void assign(const T& u);
    @\addedConcepts{requires Swappable<T>}@ void swap(array<T, N> &);

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    constexpr size_type size() const;
    constexpr size_type max_size() const;
    bool      empty() const;

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    T *       data();
    const T * data() const;
  };
}
\end{codeblock}

\pnum
\enternote\ The member variable \tcode{elems} is shown for exposition only,
to empahasize that \tcode{array} is a class aggregate.  The name \tcode{elems}
is not part of \tcode{array}'s interface. \exitnote\

\rSec3[array.cons]{\tcode{array} constructors, copy, and assignment}

\pnum
\index{array@\tcode{array}!initialization}%
\index{requirements!Container}%
The conditions for an aggregate~(\ref{dcl.init.aggr}) shall be
met. Class \tcode{array} relies on the implicitly-declared special
member functions~(\ref{class.ctor}, \ref{class.dtor}, and \ref{class.copy}) to
conform to the container requirements table in~\ref{container.requirements}.

\rSec3[array.special]{\tcode{array} specialized algorithms}

\index{array@\tcode{array}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!array@\tcode{array}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Swappable}@ T, size_t N> void swap(array<T,N>& x, array<T,N>& y);
\end{itemdecl}
\begin{itemdescr}
\pnum\effects\ 
\begin{codeblock}
swap_ranges(x.begin(), x.end(), y.begin() );
\end{codeblock}
\end{itemdescr}

\rSec3[array.size]{\tcode{array::size}}

\index{array@\tcode{array}!size@\tcode{size}}%
\index{size@\tcode{size}!array@\tcode{array}}%
\begin{itemdecl}
@\removedConcepts{template <class T, size_t N>}@ size_type @\removedConcepts{array<T,N>::}@size();
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{N}
\end{itemdescr}

\rSec3[array.data]{\tcode{array::data}}
\index{array@\tcode{array}!data@\tcode{data}}%
\index{data@\tcode{data}!array@\tcode{array}}%
\begin{itemdecl}
T *data();
const T *data() const;
\end{itemdecl}

\begin{itemdescr}
\pnum \returns\ \tcode{elems}.
\end{itemdescr}

\rSec3[array.zero]{Zero sized arrays}
\index{array@\tcode{array}!zero sized}%

\pnum\tcode{array} shall provide support for the special case \tcode{N == 0}.

\pnum In the case that \tcode{N == 0}, \tcode{begin() == end() ==} unique value.
The return value of \tcode{data()} is unspecified.

\pnum
The effect of calling \tcode{front()} or \tcode{back()} for a zero-sized array
is implementation defined.

\rSec3[array.tuple]{Tuple interface to class template \tcode{array}}
\index{array@\tcode{array}}%
\index{tuple@\tcode{tuple}}%
\index{tuple@\tcode{tuple}!and array@and \tcode{array}}%
\index{array@\tcode{array}!tuple interface to}%

\index{tuple_size@\tcode{tuple_size}}%
\begin{itemdecl}
tuple_size<array<T, N> >::value
\end{itemdecl}

\begin{itemdescr}
\pnum
\returntype\   integral constant expression.

\pnum
\cvalue\  \tcode{N}
\end{itemdescr}

\index{tuple_element@\tcode{tuple_element}}%
\begin{itemdecl}
tuple_element<I, array<T, N> >::type
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\  \tcode{0 <= I < N}.   The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\cvalue\  The type T.
\end{itemdescr}

\index{array@\tcode{array}!get@\tcode{get}}%
\index{get@\tcode{get}!array@\tcode{array}}%
\begin{itemdecl}
template <int I, class T, size_t N> 
  @\addedConcepts{requires True<(I > 0 \&\& I < N)>}@
  T& get(array<T, N>& a); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{0 <= I < N}}. The program is ill-formed if \mbox{\tcode{I}} is out of bounds.}

\returns\  A reference to the \tcode{I}th element of \tcode{a}, 
where indexing is zero-based.
\end{itemdescr}

\index{array@\tcode{array}!get@\tcode{get}}%
\index{get@\tcode{get}!array@\tcode{array}}%
\begin{itemdecl}
template <int I, class T, size_t N> 
  @\addedConcepts{requires True<(I > 0 \&\& I < N)>}@
  const T& get(const array<T, N>& a); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{0 <= I < N}}. The program is ill-formed if \mbox{\tcode{I}} is out of bounds.}

\pnum
\returns\ A const reference to the \tcode{I}th element of \tcode{a}, 
where indexing is zero-based.
\end{itemdescr}

\rSec2[deque]{Class template \tcode{deque}}%

\pnum
\index{deque@\tcode{deque}}
A
\tcode{deque}\
is a sequence container that, like a
\tcode{vector}\
(\ref{vector}), supports random access iterators.
In addition, it supports constant time insert and erase operations at the beginning or the end;
insert and erase in the middle take linear time.
That is, a deque is especially optimized for pushing and popping elements at the beginning and end.
As with vectors, storage management is handled automatically.

\pnum
A
\tcode{deque}\
satisfies all of the requirements of a container, of a reversible container
(given in tables in~\ref{container.requirements}), of a sequence container,
including the optional sequence container requirements
(\ref{sequence.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
Descriptions are provided here only for operations on
\tcode{deque}\
that are not described in one of these tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator = allocator<T> >
  @\addedConcepts{requires Destructible<T>}@
  class deque {
  public:
    // types:
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{deque.cons} construct/copy/destroy:
    explicit deque(const Allocator& = Allocator());
    @\addedConcepts{requires DefaultConstructible<T>}@ explicit deque(size_type n);
    @\addedConcepts{requires CopyConstructible<T>}@ deque(size_type n, const T& value,const Allocator& = Allocator());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<T, Iter::reference>}@ 
      deque(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,const Allocator& = Allocator());
    @\addedConcepts{requires CopyConstructible<T>}@ deque(const deque<T,Allocator>& x);
    deque(deque&&);
    @\addedConcepts{requires CopyConstructible<T>}@ deque(const deque&, const Allocator&);
    deque(deque&&, const Allocator&);

   ~deque();
    @\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@ 
      deque<T,Allocator>& operator=(const deque<T,Allocator>& x);
    deque<T,Allocator>& operator=(const deque<T,Allocator>&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<T, Iter::reference> \&\& CopyAssignable<T, Iter::reference>}@
      void assign(InputIterator first, InputIterator last);
    @\addedConcepts{requires CopyAssignable<T> \&\& CopyConstructible<T>}@ void assign(size_type n, const T& t);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // \ref{deque.capacity} capacity:
    size_type size() const;
    size_type max_size() const;
    @\addedConcepts{requires DefaultConstructible<T> \&\& MoveAssignable<T>}@ 
      void resize(size_type sz);
    @\addedConcepts{requires CopyConstructible<T> \&\& MoveAssignable<T>}@    
      void resize(size_type sz, const T& c);
    bool empty() const;

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{deque.modifiers} modifiers:
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
      void push_front(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
      void push_back(Args&&... args);

    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...> \&\& MoveAssignable<T>}@ 
      iterator emplace(const_iterator position, Args&&... args);

    @\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@
      iterator insert(const_iterator position, const T& x);
    @\addedConcepts{requires MoveConstructible<T> \&\& MoveAssignable<T>}@
      iterator insert(const_iterator position, T&& x);
    @\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@
      void insert(const_iterator position, size_type n, const T& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasCopyAssign<T, Iter::reference> \&\& HasConstructor<T, Iter::reference>}@
               @\addedConcepts{\&\& MoveAssignable<T>}@
      void insert(const_iterator position, InputIterator first, InputIterator last);

    void pop_front();
    void pop_back();

    @\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator position);
    @\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator first, const_iterator last);
    void     swap(deque<T,Allocator>&&);
    void     clear();
  };

  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator< (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator> (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>&& x, deque<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>& x, deque<T,Allocator>&& y);

  template <class T, class Alloc
    struct constructible_with_allocator_suffix<deque<T, Alloc> >
      : true_type { };
}
\end{codeblock}

\rSec3[deque.cons]{\tcode{deque}\ constructors, copy, and assignment}

\begin{itemdecl}
explicit deque(const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty
\tcode{deque},
using the specified allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T>}@ explicit deque(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{deque} with
\tcode{n} default constructed elements.

\pnum
@\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{DefaultConstructible}}.}@

\pnum
\complexity Linear in \farg{n}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T>}@
deque(size_type @\farg{n}@, const T& @\farg{value}@,
      const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs a
\tcode{deque}\
with \farg{n} copies of \farg{value},
using the specified allocator.

\pnum
@\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}@

\pnum
\complexity\ 
Linear in \farg{n}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<T, Iter::reference>}@
  deque(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@,
        const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs a
\tcode{deque}\
equal to the the range
\range{\farg{first}}{\farg{last}},
using the specified allocator.

\pnum
\complexity\ 
\tcode{distance(\farg{first}, \farg{last})}.
\end{itemdescr}

\index{assign@\tcode{assign}!\tcode{deque}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<T, Iter::reference> \&\& CopyAssignable<T, Iter::reference>}@
  void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
erase(begin(), end());
insert(begin(), first, last);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@
void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
erase(begin(), end());
insert(begin(), n, t);
\end{codeblock}
\end{itemdescr}

\rSec3[deque.capacity]{\tcode{deque}\ capacity}

\index{resize@\tcode{resize}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T> \&\& MoveAssignable<T>}@ 
  void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, equivalent to
\tcode{erase(begin() + sz, end());}. If \tcode{size() < sz},
appends \tcode{sz - size()} default constructed elements to the
sequence.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be
\mbox{\tcode{DefaultConstructible}}.}
\end{itemdescr}

\index{resize@\tcode{resize}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T> \&\& MoveAssignable<T>}@ 
  void resize(size_type sz, const T& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
if (sz > size())
  insert(end(), sz-size(), c);
else if (sz < size())
  erase(begin()+sz, end());
else
  ;                 // do nothing
\end{codeblock}

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be
\mbox{\tcode{CopyConstructible}}.}
\end{itemdescr}

\rSec3[deque.modifiers]{\tcode{deque}\ modifiers}

\index{insert@\tcode{insert}!\tcode{deque}}%
\index{insert@\tcode{push_front}!\tcode{deque}}%
\index{insert@\tcode{push_back}!\tcode{deque}}%
\index{insert@\tcode{emplace}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@
  iterator insert(const_iterator position, const T& x);
@\addedConcepts{requires MoveConstructible<T> \&\& MoveAssignable<T>}@
  iterator insert(const_iterator position, T&& x);
@\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@
  void     insert(const_iterator position, size_type n, const T& x);
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasCopyAssign<T, Iter::reference> \&\& HasConstructor<T, Iter::reference>}@
           @\addedConcepts{\&\& MoveAssignable<T>}@
  void insert(const_iterator position,
              @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
  void push_front(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
  void push_back(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...> \&\& MoveAssignable<T>}@ 
  iterator emplace(const_iterator position, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
An insertion in the middle of the deque invalidates all the iterators and
references to elements of the deque.
An insertion at either end of the
deque invalidates all the iterators to the deque, but has no effect on
the validity of references to elements of the deque.

\pnum
\notes\ 
If an exception is thrown other than by the
copy constructor or assignment operator of
\tcode{T}\
there are no effects.

\pnum
\complexity\ 
The complexity is linear in the number of elements inserted plus the lesser
of the distances to the beginning and end of the deque.
Inserting a single element either at the beginning or end of a deque always takes constant time
and causes a single call to a constructor of
\tcode{T}.
\end{itemdescr}

\index{erase@\tcode{erase}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator position);
@\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator first, const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
An erase in the middle of the deque invalidates all the iterators and
references to elements of the deque.
An erase at either end of the
deque invalidates only the iterators and the references to the erased elements.

\pnum
\complexity\ 
The number of calls to the destructor is the same as the
number of elements erased, but the number of the calls to the assignment operator is at most equal to the minimum
of the number of elements before the erased elements and the number of elements after the erased elements.

\pnum
\throws\ 
Nothing unless an exception is thrown by the copy constructor or assignment operator of
\tcode{T}.
\end{itemdescr}

\rSec3[deque.special]{\tcode{deque}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(deque<T,Allocator>&& x, deque<T,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(deque<T,Allocator>& x, deque<T,Allocator>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[forwardlist]{Class template \tcode{forward_list}}

\pnum
A \tcode{forward_list} is a container that supports forward iterators and allows constant time insert and erase operations anywhere within the sequence, with storage management handled automatically. Fast random access to list elements is not supported. \enternote It is intended that \tcode{forward_list} have zero space or time overhead relative to a hand-written C-style singly linked list. Features that would conflict with that goal have been omitted.\exitnote

\pnum
A \tcode{forward_list} satisfies all of the requirements of a container (table~\ref{tab:containers.container.requirements}), except that the \tcode{size()} member function is not provided. Descriptions are provided here only for operations on \tcode{forward_list} that are not described in that table or for operations where there is additional semantic information.

\begin{codeblock}
namespace std { 
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator = allocator<T> > 
  @\addedConcepts{requires Destructible<T>}@
  class forward_list { 
  public: 
    // types: 
    typedef typename Allocator::reference reference; 
    typedef typename Allocator::const_reference const_reference; 
    typedef @\impdef@ iterator;       // See 23.1 
    typedef @\impdef@ const_iterator; // See 23.1 
    typedef @\impdef@ size_type;      // See 23.1 
    typedef @\impdef@ difference_type;// See 23.1 
    typedef T value_type; 
    typedef Allocator allocator_type; 
    typedef typename Allocator::pointer pointer; 
    typedef typename Allocator::const_pointer const_pointer; 

    // \ref{forwardlist.cons} construct/copy/destroy: 
    explicit forward_list(const Allocator& = Allocator()); 
    @\addedConcepts{requires DefaultConstructible<T>}@ explicit forward_list(size_type n);
    @\addedConcepts{requires CopyConstructible<T>}@ 
      forward_list(size_type n, const T& value, 
                   const Allocator& = Allocator()); 
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{HasConstructor<T, Iter::reference>}@
      forward_list(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last, 
                   const Allocator& = Allocator()); 
    @\addedConcepts{requires CopyConstructible<T>}@ forward_list(const forward_list<T,Allocator>& x);
    forward_list(forward_list<T,Allocator>&& x);
    ~forward_list(); 
    @\addedConcepts{requires CopyAssignable<T>}@ 
      forward_list<T,Allocator>& operator=(const forward_list<T,Allocator>& x);
    forward_list<T,Allocator>& operator=(forward_list<T,Allocator>&& x); 
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires HasConstructor<T, Iter::reference>}@
      void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last); 
    @\addedConcepts{CopyConstructible<T>}@ void assign(size_type n, const T& t); 
    allocator_type get_allocator() const; 

    // \ref{forwardlist.iter} iterators:
    iterator before_begin();
    const_iterator before_begin() const;
    iterator begin(); 
    const_iterator begin() const; 
    iterator end(); 
    const_iterator end() const;

    const_iterator cbegin() const;
    const_iterator cbefore_begin() const;
    const_iterator cend() const;

    // capacity: 
    bool empty() const; 
    size_type max_size() const;

    // \ref{forwardlist.access} element access: 
    reference front(); 
    const_reference front() const; 

    // \ref{forwardlist.modifiers} modifiers: 
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
      void push_front(Args&&... args); 
    void pop_front();
   
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
      iterator emplace_after(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<T>}@ iterator insert_after(const_iterator position, const T& x);
    @\addedConcepts{requires MoveConstructible<T>}@ iterator insert_after(const_iterator position, T&& x);

    @\addedConcepts{requires CopyConstructible<T>}@ 
      void insert_after(const_iterator position, size_type n, const T& x); 
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires HasConstructor<T, Iter::reference>}@
      void insert_after(const_iterator position, @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator erase_after(const_iterator position); 
    iterator erase_after(const_iterator position, iterator last); 
    void swap(forward_list<T,Allocator>&&);

    @\addedConcepts{requires DefaultConstructible<T>}@ void resize(size_type sz);
    @\addedConcepts{requires CopyConstructible<T>}@ void resize(size_type sz, value_type c);
    void clear(); 

    // \ref{forwardlist.ops} forward_list operations: 
    void splice_after(const_iterator position, forward_list<T,Allocator>&& x); 
    void splice_after(const_iterator position, forward_list<T,Allocator>&& x,
                      const_iterator i); 
    void splice_after(const_iterator position, forward_list<T,Allocator>&& x,
                      const_iterator first, const_iterator last); 

    @\addedConcepts{requires EqualityComparable<T>}@ void remove(const T& value); 
    template <@\changedConcepts{class}{Predicate<auto, T>}@ Pred@\removedConcepts{icate}@> void remove_if(Pred@\removedConcepts{icate}@ pred); 

    @\addedConcepts{requires EqualityComparable<T>}@ void unique(); 
    template <@\changedConcepts{class}{Predicate<auto, T, T>}@ BinaryPredicate>
      void unique(BinaryPredicate binary_pred); 

    @\addedConcepts{requires LessThanComparable<T>}@ void merge(forward_list<T,Allocator>&& x); 
    template <@\changedConcepts{class}{Predicate<auto, T, T>}@ Compare> 
      void merge(forward_list<T,Allocator>&& x, Compare comp);

    @\addedConcepts{requires LessThanComparable<T>}@ void sort(); 
    template <@\changedConcepts{class}{Predicate<auto, T, T>}@ Compare> void sort(Compare comp); 

    void reverse(); 
  }; 

  // Comparison operators
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator> 
    bool operator==(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator> 
    bool operator< (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator> 
    bool operator!=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator> 
    bool operator> (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator> 
    bool operator>=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator> 
    bool operator<=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 

  // \ref{forwardlist.spec} specialized algorithms: 
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator> 
    void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator> 
    void swap(forward_list<T,Allocator>&& x, forward_list<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator> 
    void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>&& y); 
}
\end{codeblock}

\rSec3[forwardlist.cons]{\tcode{forward_list} constructors, copy, assignment}

\begin{itemdecl}
explicit forward_list(const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{forward_list} object using the specified allocator.

\pnum
\complexity Constant.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T>}@ explicit forward_list(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{forward_list} object with \tcode{n} default constructed elements.

\pnum
@\removedCC{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{DefaultConstructible}}.}@

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T>}@ 
  forward_list(size_type n, const T& value, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{forward_list} object with \tcode{n} copies of \tcode{value} using the specified allocator.

\pnum
@\removedCC{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}@

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{HasConstructor<T, Iter::reference>}@
  forward_list(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last, 
               const Allocator& = Allocator()); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{forward_list} object equal to the range \range{first}{last}.

\pnum
\complexity Linear in \tcode{distance(first, last)}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
  @\addedConcepts{requires HasConstructor<T, Iter::reference>}@
  void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{clear(); insert_after(before_begin(), first, last);}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{CopyConstructible<T>}@ void assign(size_type n, const T\& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{clear(); insert_after(before_begin(), n, t);}
\end{itemdescr}


\rSec3[forwardlist.iter]{\tcode{forward_list} iterators}

\begin{itemdecl}
{iterator before_begin();
const_iterator before_begin() const;
const_iterator cbefore_begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A non-dereferenceable iterator that, when incremented, is equal to the iterator returned by \tcode{begin()}.
\end{itemdescr}

\rSec3[forwardlist.access]{\tcode{forward_list} element access}

\begin{itemdecl}
reference front();
const_reference front() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*begin()}
\end{itemdescr}

\rSec3[forwardlist.modifiers]{\tcode{forward_list} modifiers}

\pnum
None of the overloads of \tcode{insert_after} shall affect the validity of iterators and reference, and \tcode{erase_after} shall invalidate only the iterators and references to the erased elements. If an exception is thrown during \tcode{insert_after}  there shall be no effect. Insertion of \tcode{n} elements into a \tcode{forward_list} is linear in \tcode{n}, and the number of calls to the copy or move constructor of \tcode{T} is exactly equal to \tcode{n}. Erasing \tcode{n} elements from a \tcode{forward_list} is linear time in \tcode{n} and the number of calls to the destructor of type \tcode{T} is exactly equal to \tcode{n}.

\begin{itemdecl}
template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
  void push_front(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Inserts an object of type \tcode{value_type} constructed with \tcode{value_type(std::forward<Args>(args)...)} at the beginning of the list.
\end{itemdescr}

\begin{itemdecl}
void pop_front();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{erase_after(before_begin())}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T>}@ iterator insert_after(const_iterator position, const T& x);
@\addedConcepts{requires MoveConstructible<T>}@ iterator insert_after(const_iterator position, T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}.

\pnum
\effects Inserts a copy of \tcode{x} after \tcode{position}.

\pnum
\returns An iterator pointing to the copy of \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T>}@ 
  void insert_after(const_iterator position, size_type n, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}.

\pnum
\effects Inserts \tcode{n} copies of \tcode{x} after \tcode{position}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
  @\addedConcepts{requires HasConstructor<T, Iter::reference>}@
  void insert_after(const_iterator position, @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}. \tcode{first} and \tcode{last} are not iterators in \tcode{*this}.

\pnum
\effects Inserts copies of elements in \range{first}{last} after \tcode{position}.
\end{itemdescr}

\begin{itemdecl}
template <class... Args>
  @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
  iterator emplace_after(const_iterator position, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}.

\pnum
\effects Inserts an object of type \tcode{value_type} constructed with \tcode{value_type(std::forward<Args>(args)...)} after \tcode{position}.
\end{itemdescr}

\begin{itemdecl}
iterator erase_after(const_iterator position);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The iterator following \tcode{position} is dereferenceable.

\pnum
\effects Erases the element pointed to by the iterator following \tcode{position}.

\pnum
\returns An iterator pointing to the element following the one that was erased, or \tcode{end()} if no such element exists.
\end{itemdescr}

\begin{itemdecl}
iterator erase_after(const_iterator position, iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires All iterators in the range \range{position}{last} are dereferenceable.

\pnum
\effects Erases the elements in the range \range{position}{last}.

\pnum
\returns \tcode{last}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T>}@ void resize(size_type sz);
@\addedConcepts{requires CopyConstructible<T>}@ void resize(size_type sz, value_type c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < distance(begin(), end())}, erases the last \tcode{distance(begin(), end()) - sz} elements from the list. Otherwise, inserts \tcode{sz - distance(begin(), end())} elements at the end of the list. For the first signature the inserted elements are default constructed, and for the second signature they are copies of \tcode{c}.
\end{itemdescr}

\begin{itemdecl}
void clear();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Erases all elements in the range \range{begin()}{end()}.
\end{itemdescr}

\rSec3[forwardlist.ops]{\tcode{forward_list} operations}

\begin{itemdecl}
void splice_after(const_iterator position, forward_list<T,Allocator>&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}. \tcode{\&x != this}.

\pnum
\effects Inserts the contents of \tcode{x} before \tcode{position}, and \tcode{x} becomes empty. Pointers and references to the moved elements of \tcode{x} now refer to those same elements but as members of \tcode{*this}. Iterators referring to the moved elements will continue to refer to their elements, but they now behave as iterators into \tcode{*this}, not into \tcode{x}.

\pnum
\throws Nothing.

\pnum
\complexity \bigoh{1}
\end{itemdescr}

\begin{itemdecl}
void splice_after(const_iterator position, forward_list<T,Allocator>&& x, const_iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}. The iterator following \tcode{i} is a dereferenceable iterator in \tcode{x}.

\pnum
\effects Inserts the element following \tcode{i} into \tcode{*this}, following \tcode{position}, and removes it from \tcode{x}. Pointers and references to the moved elements of \tcode{x} now refer to those same elements but as members of \tcode{*this}. Iterators referring to the moved elements will continue to refer to their elements, but they now behave as iterators into \tcode{*this}, not into \tcode{x}.

\pnum
\throws Nothing.

\pnum
\complexity \bigoh{1}
\end{itemdescr}

\begin{itemdecl}
void splice_after(const_iterator position, forward_list<T,Allocator>&& x, const_iterator first, const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}. \orange{first}{last} is a valid range in \tcode{x}, and all iterators in the range \orange{first}{last} are dereferenceable. \tcode{position} is not an iterator in the range \orange{first}{last}.

\pnum
\effects Inserts elements in the range \orange{first}{last} after \tcode{position} and removes the elements from \tcode{x}. Pointers and references to the moved elements of \tcode{x} now refer to those same elements but as members of \tcode{*this}. Iterators referring to the moved elements will continue to refer to their elements, but they now behave as iterators into \tcode{*this}, not into \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires EqualityComparable<T>}@ void remove(const T& value);
template <@\changedConcepts{class}{Predicate<auto, T>}@ Pred@\removedCC{icate}@> void remove_if(Pred@\removedCC{icate}@ pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects  Erases all the elements in the list referred by a list iterator \tcode{i} for which the following conditions hold: \tcode{*i == value} (for \tcode{remove()}), \tcode{pred(*i)} is true (for \tcode{remove_if()}). This operation shall be stable: the relative order of the elements that are not removed is the same as their relative order in the original list.

\pnum
\throws Nothing unless an exception is thrown by the equality comparison or the predicate.

\pnum
\complexity Exactly \tcode{distance(begin(), end())} applications of the corresponding predicate.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires EqualityComparable<T>}@ void unique();
template <@\changedConcepts{class}{Predicate<auto, T, T>}@ BinaryPredicate>
  void unique(BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Eliminates all but the first element from every consecutive group of equal elements referred to by the iterator \tcode{i} in the range \range{first + 1}{last} for which \tcode{*i == *(i-1)} (for the version with no arguments) or \tcode{pred(*i, *(i - 1))} (for the version with a predicate argument) holds.

\pnum
\throws Nothing unless an exception is thrown by the equality comparison or the predicate.

\pnum
\complexity If the range \range{first}{last} is not empty, exactly \tcode{(last - first) - 1} applications of the corresponding predicate, otherwise no applications of the predicate.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires LessThanComparable<T>}@ void merge(forward_list<T,Allocator>&& x);
template <@\changedConcepts{class}{Predicate<auto, T, T>}@ Compare> 
  void merge(forward_list<T,Allocator>&& x, Compare comp)
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{comp} defines a strict weak ordering~(\ref{alg.sorting}), and \tcode{*this} and \tcode{x} are both sorted according to this ordering.

\pnum
\effects Merges \tcode{x} into \tcode{*this}. This operation shall be stable: for equivalent elements in the two lists, the elements from \tcode{*this} shall always precede the elements from \tcode{x}. \tcode{x} is empty after the merge. If an exception is thrown other than by a comparison there are no effects.

\pnum
\complexity At most \tcode{size() + x.size() - 1} comparisons.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires LessThanComparable<T>}@ void sort();
template <@\changedConcepts{class}{Predicate<auto, T, T>}@ Compare> void sort(Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{operator<} (for the version with no arguments) or \tcode{comp} (for the version with a comparison argument) defines a strict weak ordering~(\ref{alg.sorting}).

\pnum
\effects Sorts the list according to the \tcode{operator<} or the \tcode{comp} function object. This operation shall be stable: the relative order of the equivalent elements is preserved. If an exception is thrown the order of the elements in \tcode{*this} is unspecified.

\pnum
\complexity Approximately $N \log N$ comparisons, where $N$ is \tcode{distance(begin(), end())}.
\end{itemdescr}

\begin{itemdecl}
void reverse();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Reverses the order of the elements in the list.

\pnum
\throws Nothing.

\pnum
\complexity Linear time.
\end{itemdescr}

\rSec3[forwardlist.spec]{\tcode{forward_list} specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(forward_list<T,Allocator>&& x, forward_list<T,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{x.swap(y)}
\end{itemdescr}

\rSec2[list]{Class template \tcode{list}}

\pnum
\index{list@\tcode{list}}%
A
\tcode{list}\
is a sequence container that supports
bidirectional iterators and allows constant time insert and erase
operations anywhere within the sequence, with storage management handled
automatically. Unlike vectors (\ref{vector}) and deques (\ref{deque}),
fast random access to list elements is not supported, but many
algorithms only need sequential access anyway.

\pnum
A \tcode{list}\ satisfies all of the requirements of a container, of
a reversible container (given in two tables in
\ref{container.requirements}), of a sequence container,
including most of the the optional sequence container
requirements (\ref{sequence.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
The exceptions are the
\tcode{operator[]}\
and
\tcode{at}\
member functions, which are not provided.%
\footnote{
These member functions are only provided by containers whose iterators
are random access iterators.
}
Descriptions are provided here only for operations on
\tcode{list}\
that are not described in one of these tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator = allocator<T> >
  @\addedConcepts{requires Destructible<T>}@
  class list {
  public:
    // types:
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{list.cons} construct/copy/destroy:
    explicit list(const Allocator& = Allocator());
    @\addedConcepts{requires DefaultConstructible<T>}@ explicit list(size_type n);
    @\addedConcepts{requires CopyConstructible<T>}@ 
      list(size_type @\farg{n}@, const T& @\farg{value}@, const Allocator& = Allocator());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<T, Iter::reference>}@
      list(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@, const Allocator& = Allocator());
    @\addedConcepts{requires CopyConstructible<T>}@ list(const list<T,Allocator>& @\farg{x}@);
    list(list&& x);
    @\addedConcepts{requires CopyConstructible<T>}@ list(const list&, const Allocator&);
    list(list&&, const Allocator&);
   ~list();
    @\addedConcepts{requires CopyAssignable<T>}@ list<T,Allocator>& operator=(const list<T,Allocator>& @\farg{x}@);
    list<T,Allocator>& operator=(list<T,Allocator>&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasCopyAssign<T, Iter::reference> \&\& HasConstructor<T, Iter::reference>}@
      void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires CopyAssignable<T> \&\& CopyConstructible<T>}@ void assign(size_type n, const T& t);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // \ref{list.capacity} capacity:
    bool      empty() const;
    size_type size() const;
    size_type max_size() const;
    @\addedConcepts{requires DefaultConstructible<T>}@ void resize(size_type sz);
    @\addedConcepts{requires CopyConstructible<T>}@ void resize(size_type sz, const T& c);

    // element access:
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{list.modifiers} modifiers:
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@
      void push_front(Args&&... args);
    void pop_front();
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@
      void push_back(Args&&... args);
    void pop_back();

    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<T>}@ iterator insert(const_iterator @\farg{position}@, const T& @\farg{x}@);
    @\addedConcepts{requires MoveConstructible<T>}@ iterator insert(const_iterator position, T&& x);
    @\addedConcepts{requires CopyConstructible<T>}@ 
      void insert(const_iterator @\farg{position}@, size_type @\farg{n}@, const T& @\farg{x}@);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<T, Iter::reference>}@
      void insert(const_iterator @\farg{position}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{first}@,
                  @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@);

    iterator erase(const_iterator @\farg{position}@);
    iterator erase(const_iterator @\farg{position}@, const_iterator @\farg{last}@);
    void     swap(list<T,Allocator>&&);
    void     clear();

    // \ref{list.ops} list operations:
    void splice(const_iterator @\farg{position}@, list<T,Allocator>&& @\farg{x}@);
    void splice(const_iterator @\farg{position}@, list<T,Allocator>&& @\farg{x}@, const_iterator @\farg{i}@);
    void splice(const_iterator @\farg{position}@, list<T,Allocator>&& @\farg{x}@,
                const_iterator @\farg{first}@, const_iterator @\farg{last}@);

    @\addedConcepts{requires EqualityComparable<T>}@ void remove(const T& @\farg{value}@);
    template <@\changedConcepts{class}{Predicate<auto, T>}@ Pred@\removedConcepts{icate}@> void remove_if(Pred@\removedConcepts{icate}@ @\farg{pred}@);

    @\addedConcepts{requires EqualityComparable<T>}@ void unique();
    template <@\changedConcepts{class}{Predicate<auto, T, T>}@ BinaryPredicate>
      void unique(BinaryPredicate @\farg{binary_pred}@);

    @\addedConcepts{requires LessThanComparable<T>}@ void merge(list<T,Allocator>&& @\farg{x}@);
    template <@\changedConcepts{class}{BinaryPredicate<auto, T, T>}@ Compare> 
      void merge(list<T,Allocator>&& @\farg{x}@, Compare @\farg{comp}@);

    @\addedConcepts{requires LessThanComparable<T>}@ void sort();
    template <@\changedConcepts{class}{BinaryPredicate<auto, T, T>}@ Compare> void sort(Compare @\farg{comp}@);

    void reverse();
  };

  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator==(const list<T,Allocator>& @\farg{x}@, const list<T,Allocator>& @\farg{y}@);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator< (const list<T,Allocator>& @\farg{x}@, const list<T,Allocator>& @\farg{y}@);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator!=(const list<T,Allocator>& @\farg{x}@, const list<T,Allocator>& @\farg{y}@);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator> (const list<T,Allocator>& @\farg{x}@, const list<T,Allocator>& @\farg{y}@);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator>=(const list<T,Allocator>& @\farg{x}@, const list<T,Allocator>& @\farg{y}@);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator<=(const list<T,Allocator>& @\farg{x}@, const list<T,Allocator>& @\farg{y}@);

  // specialized algorithms:
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(list<T,Allocator>& x, list<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(list<T,Allocator>&& x, list<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(list<T,Allocator>& x, list<T,Allocator>&& y);

  template <class T, class Alloc>
    struct constructible_with_allocator_suffix<list<T, Alloc> >
      : true_type { };
}
\end{codeblock}

\rSec3[list.cons]{\tcode{list}\ constructors, copy, and assignment}

\begin{itemdecl}
explicit list(const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty list, using the specified allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T>}@ explicit list(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{list} with
\tcode{n} default constructed elements.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{DefaultConstructible}}.}

\pnum
\complexity
Linear in
\tcode{n}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T>}@
  list(size_type @\farg{n}@, const T& @\farg{value}@,
                const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs a
\tcode{list}\
with
\tcode{n}\
copies of
\tcode{value},
using the specified allocator.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}

\pnum
\complexity\ 
Linear in
\tcode{n}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<T, Iter::reference>}@
  list(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@, const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs a
\tcode{list}\
equal to the range
\range{\farg{first}}{\farg{last}}.

\pnum
\complexity\ 
Linear in
\tcode{distance(\farg{first}, \farg{last})}.
\end{itemdescr}

\index{assign@\tcode{assign}!\tcode{list}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasCopyAssign<T, Iter::reference> \&\& HasConstructor<T, Iter::reference>}@
  void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Replaces the contents of the list with the range
\tcode{[first, last)}.

\begin{codeblock}
erase(begin(), end());
insert(begin(), n, t);
\end{codeblock}

\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyAssignable<T> \&\& CopyConstructible<T>}@ void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Replaces the contents of the list with \farg{n}\ copies of \farg{t}.
\end{itemdescr}

\rSec3[list.capacity]{\tcode{list}\ capacity}

\index{resize@\tcode{resize}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T>}@ void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, equivalent to
\tcode{list<T>::iterator it = begin();}
\tcode{advance(it, sz);}
\tcode{erase(it, end());}. If \tcode{size() < sz},
appends \tcode{sz - size()} default constructed elements to the
sequence.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be
\mbox{\tcode{DefaultConstructible}}.}
\end{itemdescr}

\index{resize@\tcode{resize}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T>}@ void resize(size_type sz, const T& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
if (sz > size())
  insert(end(), sz-size(), c);
else if (sz < size()) {
  iterator i = begin();
  advance(i, sz);
  erase(i, end());
}
else
  ;                 // do nothing
\end{codeblock}

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}
\end{itemdescr}

\rSec3[list.modifiers]{\tcode{list}\ modifiers}

\index{insert@\tcode{insert}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T>}@ iterator insert(const_iterator position, const T& x);
@\addedConcepts{requires MoveConstructible<T>}@ iterator insert(const_iterator position, T&& x);
@\addedConcepts{requires CopyConstructible<T>}@ 
  void insert(const_iterator @\farg{position}@, size_type @\farg{n}@, const T& @\farg{x}@);
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<T, Iter::reference>}@
  void insert(const_iterator @\farg{position}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{first}@,
              @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@);

template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@
  void push_front(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@
  void push_back(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@
  iterator emplace(const_iterator position, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes\ 
Does not affect the validity of iterators and references.
If an exception is thrown there are no effects.

\pnum
\complexity\ 
Insertion of a single element into a list takes constant time and
exactly one call to a constructor of
\tcode{T}. Insertion of multiple elements into a list is linear in the
number of elements inserted, and the number of calls to the copy
constructor or move constructor of \tcode{T}\ is exactly equal
to the number of elements inserted.
\end{itemdescr}

\index{erase@\tcode{erase}!\tcode{list}}%
\begin{itemdecl}
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);

void pop_front();
void pop_back();
void clear();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Invalidates only the iterators and references to the erased elements.

\pnum
\throws\ 
Nothing.

\pnum
\complexity\ 
Erasing a single element is a constant time operation with a single call to the destructor of
\tcode{T}.
Erasing a range in a list is linear time in the
size of the range and the number of calls to the destructor of type
\tcode{T}\
is exactly equal to the size of the range.
\end{itemdescr}

\rSec3[list.ops]{\tcode{list}\ operations}

\pnum
Since lists allow fast insertion and erasing from the middle of a list, certain operations are provided
specifically for them.%
\footnote{As specified in~\ref{allocator.requirements}, the requirements
in this clause apply only to lists whose allocators compare equal.
}

\pnum
\tcode{list}\
provides three splice operations that destructively move elements from one list to another. The behavior of splice operations is undefined if \tcode{get_allocator() != x.get_allocator()}.

\index{splice@\tcode{splice}!\tcode{list}}%
\begin{itemdecl}
void splice(const_iterator @\farg{position}@, list<T,Allocator>&& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\ 
\tcode{\&\farg{x} != this}.

\pnum
\effects\ 
Inserts the contents of
\tcode{x}
before
\tcode{position}
and
\tcode{x}
becomes empty.
Pointers and references to the moved elements of
\tcode{x}\
now refer to those same elements but as members of
\tcode{*this}.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into
\tcode{*this},
not into
\tcode{x}.

\pnum
\throws\ 
Nothing

\pnum
\complexity\ 
Constant time.
\end{itemdescr}

\begin{itemdecl}
void splice(const_iterator @\farg{position}@, list<T,Allocator>&& @\farg{x}@, iterator @\farg{i}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Inserts an element pointed to by
\tcode{i}\
from list
\tcode{x}\
before \tcode{position}\ and removes the element from
\tcode{x}.
The result is unchanged if
\tcode{position == i}
or
\tcode{position == ++i}.
Pointers and references to
\tcode{*i}\
continue to refer to this same element but as a member of
\tcode{*this}.
Iterators
to
\tcode{*i}\
(including
\tcode{i}\
itself) continue to refer to the same element, but now behave as iterators into
\tcode{*this},
not into
\tcode{x}.

\pnum
\throws\ 
Nothing

\pnum
\requires\ 
\tcode{i}\
is a valid dereferenceable iterator of
\tcode{x}.

\pnum
\complexity\ 
Constant time.
\end{itemdescr}

\begin{itemdecl}
void splice(const_iterator @\farg{position}@, list<T,Allocator>&& @\farg{x}@, iterator @\farg{first}@,
            iterator @\farg{last}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Inserts elements in the range
\range{first}{last}\
before
\tcode{position}
and removes the elements from
\tcode{x}.

\pnum
\requires\ 
\tcode{[first, last)}
is a valid range in
\tcode{x}.
The result is undefined if
\tcode{position}
is an iterator in the range
\range{first}{last}.
Pointers and references to the moved elements of
\tcode{x}\
now refer to those same elements but as members of
\tcode{*this}.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into
\tcode{*this},
not into
\tcode{x}.

\pnum
\throws\ 
Nothing

\pnum
\complexity\ 
Constant time if
\tcode{\&\farg{x} == this};
otherwise, linear time.
\end{itemdescr}

\index{remove@\tcode{remove}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires EqualityComparable<T>}@ void remove(const T& @\farg{value}@);
template <@\changedConcepts{class}{Predicate<auto, T>}@ Pred@\removedConcepts{icate}@> void remove_if(Pred@\removedConcepts{icate}@ @\farg{pred}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Erases all the elements in the list referred by a list iterator
\tcode{i}
for which the following conditions hold:
\tcode{*i == value, pred(*i) != false}.

\pnum
\throws\ 
Nothing unless an exception is thrown by
\tcode{*i == value}
or
\tcode{\farg{pred}(*i) != false}.

\pnum
\notes\ 
Stable.

\pnum
\complexity\ 
Exactly
\tcode{size()}
applications of the corresponding predicate.
\end{itemdescr}

\index{unique@\tcode{unique}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires EqualityComparable<T>}@ void unique();
template <@\changedConcepts{class}{Predicate<auto, T, T>}@ BinaryPredicate> void unique(BinaryPredicate @\farg{binary_pred}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Eliminates all but the first element from every
consecutive group of equal elements referred to by the
iterator
\tcode{i}\
in the range
\range{\farg{first} + 1}{\farg{last}}\
for which
\tcode{*i == *(i-1)}
(for the version of
\tcode{unique}\
with no arguments) or
\tcode{\farg{pred}(*i, *(i - 1))}\
(for the version of
\tcode{unique}
with a predicate argument)
holds.

\pnum
\throws\ 
Nothing unless an exception in thrown by
\tcode{*i == *(i-1)}\
or
\tcode{\farg{pred}(*i, *(i - 1))}\

\pnum
\complexity\ 
If the range
\tcode{[\farg{first}, \farg{last})}\
is not empty, exactly
\tcode{(\farg{last} - \farg{first}) - 1}
applications of the corresponding predicate,
otherwise no applications of the predicate.
\end{itemdescr}

\index{merge@\tcode{merge}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires LessThanComparable<T>}@ void merge(list<T,Allocator>&& @\farg{x}@);
template <@\changedConcepts{class}{Predicate<auto, T, T>}@ Compare> void merge(list<T,Allocator>&& @\farg{x}@, Compare @\farg{comp}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\ 
\farg{comp}\ shall define a strict weak ordering
(\ref{alg.sorting}), and both the list and the argument list shall be
sorted according to this ordering.

\pnum
\effects\ 
If
\tcode{(\&x == this)}\
does nothing; otherwise, merges the two sorted ranges
\tcode{[begin(), end())}\
and
\tcode{[x.\brk{}begin(), x.end())}.
The result is a range in which the elements will be sorted in non-decreasing
order according to the ordering defined by \tcode{comp};
that is, for every iterator \tcode{i}, in the range other than the first,
the condition
\tcode{comp(*i, *(i - 1)}\
will be false.

\pnum
\notes\ 
Stable. If \tcode{(\&x != this)}\ the range \tcode{[x.begin(), x.end())}\
is empty after the merge.

\pnum
\complexity\ 
At most
\tcode{size() + x.size() - 1}\
applications of \tcode{comp}\ if
\tcode{(\&x != this)};
otherwise, no applications of \tcode{comp}\ are performed.
If an exception is thrown other than by a comparison there are no effects.
\end{itemdescr}

\index{reverse@\tcode{reverse}!\tcode{list}}%
\begin{itemdecl}
void reverse();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Reverses the order of the elements in the list.

\pnum
\throws\ 
Nothing.

\pnum
\complexity\ 
Linear time.
\end{itemdescr}

\index{sort@\tcode{sort}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires LessThanComparable<T>}@ void sort();
template <@\changedConcepts{class}{BinaryPredicate<auto, T, T>}@ Compare> void sort(Compare @\farg{comp}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\ 
\tcode{operator<}\
(for the first
version)
or
\farg{comp}\ 
(for the second version)
shall define a strict weak ordering (\ref{alg.sorting}).

\pnum
\effects\ 
Sorts the list according to the
\tcode{operator<}\
or a
\tcode{Compare}\
function object.

\pnum
\notes\ 
Stable.

\pnum
\complexity\ 
Approximately
$N \log(N)$
comparisons, where
\tcode{N == size()}.
\end{itemdescr}

\rSec3[list.special]{\tcode{list}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(list<T,Allocator>& x, list<T,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(list<T,Allocator>&& x, list<T,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(list<T,Allocator>& x, list<T,Allocator>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[lib.container.adaptors]{Container adaptors}

\pnum
The container adaptors each take a Container template parameter,
and each constructor takes a Container reference argument.
This
container is copied into the Container member of each adaptor.

\rSec3[lib.queue]{Class template \tcode{queue}}

\pnum
\index{queue@\tcode{queue}}%
Any \changedConcepts{sequence supporting operations
front(),
back(),
push_back()
and
pop_front()}{container that meets the requirements of the
Back Insertion Sequence and Front Insertion Sequence concepts}
can be used to instantiate
\tcode{queue}.
In particular,
\tcode{list}\
(\ref{lib.list})
and
\tcode{deque}\
(\ref{lib.deque})
can be used.

\rSec4[lib.queue.defn]{\tcode{queue} definition}

\begin{codeblock}
namespace std {
  template <class T, @\addedConcepts{FrontInsertionSequence Container}@ = deque<T> >
  @\addedConcepts{where BackInsertionSequence<Cont>}@
  class queue {
  public:
    typedef Container::value_type            value_type;
    typedef Container::reference             reference;
    typedef Container::const_reference       const_reference;
    typedef Container::size_type             size_type;
    typedef Container                        container_type;
  protected:
    Container c;

  public:
    explicit queue(const Container& = Container());

    bool              empty() const     { return c.empty(); }
    size_type         size()  const     { return c.size(); }
    reference         front()           { return c.front(); }
    const_reference   front() const     { return c.front(); }
    reference         back()            { return c.back(); }
    const_reference   back() const      { return c.back(); }
    void push(const value_type& x)      { c.push_back(x); }
    void pop()                          { c.pop_front(); }
  };

  template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container>}@
    bool operator==(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator< (const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container>}@
    bool operator!=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator> (const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator>=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator<=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
}
\end{codeblock}

\rSec4[lib.queue.ops]{\tcode{queue} operators}

\index{operator==@\tcode{operator==}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container>}@
    bool operator==(const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c == y.c}.
\end{itemdescr}

\index{operator"!=@\tcode{operator"!=}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container>}@
    bool operator!=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c != y.c}.
\end{itemdescr}

\index{operator<@\tcode{operator<}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator< (const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c < y.c}.
\end{itemdescr}

\index{operator<=@\tcode{operator<=}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator<=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c <= y.c}.
\end{itemdescr}

\index{operator>@\tcode{operator>}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator> (const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c > y.c}.
\end{itemdescr}

\index{operator>=@\tcode{operator>=}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator>=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c >= y.c}.
\end{itemdescr}

\rSec3[lib.priority.queue]{Class template \tcode{priority_queue}}

\pnum
\index{priority_queue@\tcode{priority_queue}}%
Any sequence with random access iterator and supporting operations
\tcode{front()},
\tcode{push_back()}\
and
\tcode{pop_back()}\
can be used to instantiate
\tcode{priority_queue}.
In particular,
\tcode{vector}\
(\ref{lib.vector})
and
\tcode{deque}\
(\ref{lib.deque})
can be used.
Instantiating
\tcode{priority_queue}\
also involves supplying a function or function object for making priority comparisons;
the library assumes that the function or function object defines a strict
weak ordering (\ref{lib.alg.sorting}).

\begin{codeblock}
namespace std {
  template <class T, @\addedConcepts{RandomAccessSequence Container}@ = vector<T>,
            @\addedConcepts{BinaryPredicate<Container::value_type, Container::value_type>}@ Compare 
              = less<Container::value_type> >
  @\addedConcepts{where CopyConstructible<Compare>}@
  class priority_queue {
  public:
    typedef Container::value_type            value_type;
    typedef Container::reference             reference;
    typedef Container::const_reference       const_reference;
    typedef Container::size_type             size_type;
    typedef Container                        container_type;
  protected:
    Container c;
    Compare comp;

  public:
    explicit priority_queue(const Compare& x = Compare(),
                const Container& = Container());
    template <@\addedConcepts{InputIterator Iter}@>
      @\addedConcepts{where Convertible<Iter::value_type, value_type>}@
      priority_queue(Iter first, Iter last,
             const Compare& x = Compare(),
             const Container& = Container());

    bool      empty() const       { return c.empty(); }
    size_type size()  const       { return c.size(); }
    const_reference   top() const { return c.front(); }
    void push(const value_type& x);
    void pop();
  };
                // no equality is provided
}
\end{codeblock}

\rSec4[lib.priqueue.cons]{\tcode{priority_queue}\ constructors}

\index{priority_queue@\tcode{priority_queue}!\tcode{priority_queue}}%
\begin{itemdecl}
priority_queue(const Compare& x = Compare(),
               const Container& y = Container());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\ 
\farg{x}\ defines a strict weak ordering (\ref{lib.alg.sorting}).

\pnum
\effects\ 
Initializes
\tcode{comp}\ with
\tcode{x}\ and
\tcode{c}\ with
\tcode{y};
calls
\tcode{make_heap(c.begin(), c.end(), comp)}.
\end{itemdescr}

\begin{itemdecl}
template <@\addedConcepts{InputIterator Iter}@>
  @\addedConcepts{where Convertible<Iter::value_type, value_type>}@
  priority_queue(Iter first, Iter last,
                 const Compare& x = Compare(),
                 const Container& y = Container());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\ 
\farg{x}\ defines a strict weak ordering (\ref{lib.alg.sorting}).

\pnum
\effects\ 
Initializes
\tcode{c}\ with
\tcode{y}\ and
\tcode{comp}\ with
\tcode{x};
calls
\tcode{c.insert(c.end(), first, last)};
and finally calls
\tcode{make_heap(c.begin(), c.end(), comp)}.
\end{itemdescr}

\rSec4[lib.priqueue.members]{\tcode{priority_queue}\ members}

\index{push@\tcode{push}!\tcode{priority_queue}}%
\begin{itemdecl}
void push(const value_type& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
c.push_back(x);
push_heap(c.begin(), c.end(), comp);
\end{codeblock}
\end{itemdescr}

\index{pop@\tcode{pop}!\tcode{priority_queue}}%
\begin{itemdecl}
void pop();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
pop_heap(c.begin(), c.end(), comp);
c.pop_back();
\end{codeblock}
\end{itemdescr}

\rSec3[lib.stack]{Class template \tcode{stack}}

\pnum
\index{stack@\tcode{stack}}%
Any sequence supporting operations
\tcode{back()},
\tcode{push_back()}\
and
\tcode{pop_back()}\
can be used to instantiate
\tcode{stack}.
In particular,
\tcode{vector}\
(\ref{lib.vector}),
\tcode{list}\
(\ref{lib.list})
and
\tcode{deque}\
(\ref{lib.deque})
can be used.

\rSec4[lib.stack.defn]{\tcode{stack} definition}

\begin{codeblock}
namespace std {
  template <class T, @\addedConcepts{BackInsertionSequence Container}@ = deque<T> >
  class stack {
  public:
    typedef Container::value_type            value_type;
    typedef Container::reference             reference;
    typedef Container::const_reference       const_reference;
    typedef Container::size_type             size_type;
    typedef Container                        container_type;
  protected:
    Container c;

  public:
    explicit stack(const Container& = Container());

    bool      empty() const             { return c.empty(); }
    size_type size()  const             { return c.size(); }
    reference         top()             { return c.back(); }
    const_reference   top() const       { return c.back(); }
    void push(const value_type& x)      { c.push_back(x); }
    void pop()                          { c.pop_back(); }
  };

  template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container::value_type>}@
    bool operator==(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator< (const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container::value_type>}@
    bool operator!=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator> (const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator>=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator<=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
}
\end{codeblock}

\rSec4[lib.stack.ops]{\tcode{stack} operators}

\index{operator==@\tcode{operator==}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container::value_type>}@
    bool operator==(const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c == y.c}.
\end{itemdescr}

\index{operator"!=@\tcode{operator"!=}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container::value_type>}@
    bool operator!=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c != y.c}.
\end{itemdescr}

\index{operator<@\tcode{operator<}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator< (const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c < y.c}.
\end{itemdescr}

\index{operator<=@\tcode{operator<=}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator<=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c <= y.c}.
\end{itemdescr}

\index{operator>@\tcode{operator>}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator> (const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c > y.c}.
\end{itemdescr}

\index{operator>=@\tcode{operator>=}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator>=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c >= y.c}.
\end{itemdescr}

\rSec2[vector]{Class template \tcode{vector}}

\pnum
\index{vector@\tcode{vector}}%
A
\tcode{vector}\
is a sequence container that supports random access iterators.
In addition, it supports (amortized) constant time insert and erase operations at the end;
insert and erase in the middle take linear time.
Storage management is handled automatically, though hints can be given
to improve efficiency.
The elements of a vector are stored contiguously, meaning that if
\tcode{v}\
is a
\tcode{vector<T, Allocator>}\
where
\tcode{T}\
is some type other than
\tcode{bool},
then it obeys the identity
\tcode{\&v[n] == \&v[0] + n}\
for all
\tcode{0 <= n < v.size()}.

\pnum
A \tcode{vector}\ satisfies all of the requirements of a container and of a reversible container (given in two tables in~\ref{container.requirements}), of a sequence container, including most of the optional sequence container requirements (\ref{sequence.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}). The exceptions are the \tcode{push_front}\ and \tcode{pop_front}\ member functions, which are not provided. Descriptions are provided here only for operations on \tcode{vector}\ that are not described in one of these tables or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator = allocator<T> >
  @\addedConcepts{requires Destructible<T>}@
  class vector {
  public:
    // types:
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{vector.cons} construct/copy/destroy:
    explicit vector(const Allocator& = Allocator());
    @\addedConcepts{requires DefaultConstructible<T>}@ explicit vector(size_type n);
    @\addedConcepts{requires CopyConstructible<T>}@ vector(size_type n, const T& value, const Allocator& = Allocator());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<T, Iter::reference> \&\& MoveConstructible<T>}@
      vector(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
             const Allocator& = Allocator());
    @\addedConcepts{requires CopyConstructible<T>}@ vector(const vector<T,Allocator>& x);
    vector(vector&&);
    @\addedConcepts{requires CopyConstructible<T>}@ vector(const vector&, const Allocator&);
    vector(vector&&, const Allocator&);
   ~vector();
    @\addedConcepts{requires CopyAssignable<T>}@ vector<T,Allocator>& operator=(const vector<T,Allocator>& x);
    vector<T,Allocator>& operator=(vector<T,Allocator>&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<T, Iter::reference> \&\& HasCopyAssign<T, Iter::reference>}@
      void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@ void assign(size_type n, const T& u);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // \ref{vector.capacity} capacity:
    size_type size() const;
    size_type max_size() const;
    @\addedConcepts{requires DefaultConstructible<T> \&\& MoveConstructible<T>}@ void resize(size_type sz);
    @\addedConcepts{requires CopyConstructible<T>}@ void resize(size_type sz, const T& c);
    size_type capacity() const;
    bool      empty() const;
    @\addedConcepts{requires MoveConstructible<T>}@ void reserve(size_type n);

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{vector.data} data access
    pointer         data();
    const_pointer   data() const;

    // \ref{vector.modifiers} modifiers:
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...> \&\& MoveConstructible<T>}@
      void push_back(Args&&... args);
    void pop_back();

    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...> \&\& MoveConstructible<T>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@ 
      iterator insert(const_iterator position, const T& x);
    @\addedConcepts{requires MoveConstructible<T> \&\& MoveAssignable<T>}@
      void insert(const_iterator position, T&& x);
    @\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@
      void insert(const_iterator position, size_type n, const T& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
        @\addedConcepts{requires HasConstructor<T, Iter::reference> \&\& HasCopyAssign<T, Iter::reference>}@
              @\addedConcepts{\&\& MoveConstructible<T> \&\& MoveAssignable<T>}@
        void insert(const_iterator position,
                    @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator position);
    @\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator first, const_iterator last);
    void     swap(vector<T,Allocator>&&);
    void     clear();
  };

  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(vector<T,Allocator>&& x, vector<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(vector<T,Allocator>& x, vector<T,Allocator>&& y);

  template <class T, class Alloc>
    struct constructible_with_allocator_suffix<vector<T, Alloc> >
      : true_type { };
}
\end{codeblock}%
\index{vector@\tcode{vector}!\tcode{operator==}}%
\index{vector@\tcode{vector}!\tcode{operator<}}

\rSec3[vector.cons]{\tcode{vector}\ constructors, copy, and assignment}

\index{vector@\tcode{vector}!\tcode{vector}}
\begin{itemdecl}
vector(const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{vector}, using the
specified allocator.

\pnum
\complexity Constant.
\end{itemdescr}

\index{vector@\tcode{vector}!\tcode{vector}}
\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T>}@ explicit vector(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{vector} with \tcode{n}
default constructed elements.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{DefaultConstructible}}.}

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\index{vector@\tcode{vector}!\tcode{vector}}
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T>}@
explicit vector(size_type n, const T& value,
                const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{vector} with \tcode{n}
copies of \tcode{value}, using the specified allocator.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\index{vector@\tcode{vector}!\tcode{vector}}
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<T, Iter::reference> \&\& MoveConstructible<T>}@
  vector(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
         const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects Constructs a \tcode{vector} equal to the
range \range{first}{last}, using the specified allocator.

\pnum
\complexity\ 
Makes only $N$
calls to the copy constructor of
\tcode{T}\
(where $N$
is the distance between
\tcode{first}\
and
\tcode{last})
and no reallocations if iterators first and last are of forward, bidirectional, or random access categories.
It makes order
\tcode{N}\
calls to the copy constructor of
\tcode{T}\
and order
$\log(N)$
reallocations if they are just input iterators.
\end{itemdescr}

\index{assign@\tcode{assign}!\tcode{vector}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<T, Iter::reference> \&\& HasCopyAssign<T, Iter::reference>}@
  void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
erase(begin(), end());
insert(begin(), first, last);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@ 
  void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
erase(begin(), end());
insert(begin(), n, t);
\end{codeblock}
\end{itemdescr}

\rSec3[vector.capacity]{\tcode{vector}\ capacity}

\index{capacity@\tcode{capacity}!\tcode{vector}}%
\begin{itemdecl}
size_type capacity() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
The total number of elements that the vector can hold
without requiring reallocation.
\end{itemdescr}

\index{reserve@\tcode{reserve}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{requires MoveConstructible<T>}@ void reserve(size_type n);
\end{itemdecl}

\pnum
\requires If \tcode{value_type} has a move constructor, that
constructor shall not throw any exceptions.

\begin{itemdescr}
\pnum
\effects\ 
A directive that informs a
\tcode{vector}\
of a planned change in size, so that it can manage the storage allocation accordingly.
After
\tcode{reserve()},
\tcode{capacity()}\
is greater or equal to the argument of
\tcode{reserve}\
if reallocation happens; and equal to the previous value of
\tcode{capacity()}\
otherwise.
Reallocation happens at this point if and only if the current capacity is less than the
argument of
\tcode{reserve()}. If an exception is thrown, there are no effects.

\pnum
\complexity\ 
It does not change the size of the sequence and takes at most linear
time in the size of the sequence.

\pnum
\throws\ 
\tcode{length_error}\
if
\tcode{\farg{n} > max_size()}.%
\footnote{
\tcode{reserve()}\
uses
\tcode{Allocator::allocate()}\
which may throw an appropriate exception.
}

\pnum
\notes\ 
Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence.
It is guaranteed that no reallocation takes place during insertions that happen
after a call to
\tcode{reserve()}\
until the time when an insertion would make the size of the vector
greater than the value of
\tcode{capacity()}.
\end{itemdescr}

\index{swap@\tcode{swap}!\tcode{vector}}%
\begin{itemdecl}
void swap(vector<T,Allocator>&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
Exchanges the contents and
\tcode{capacity()}\
of
\tcode{*this}\
with that of \tcode{x}.

\pnum
\complexity\
Constant time.
\end{itemdescr}

\index{resize@\tcode{resize}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T> \&\& MoveConstructible<T>}@ void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, equivalent to
\tcode{erase(begin() + sz, end());}. If \tcode{size() < sz},
appends \tcode{sz - size()} default constructed elements to the
sequence.

\pnum
\requires \tcode{T} shall be
\tcode{DefaultConstructible}.
\end{itemdescr}

\index{resize@\tcode{resize}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T>}@ void resize(size_type sz, const T& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
if (sz > size())
  insert(end(), sz-size(), c);
else if (sz < size())
  erase(begin()+sz, end());
else
  ;                 // do nothing
\end{codeblock}

\pnum
\requires If \tcode{value_type} has a move constructor, that
constructor shall not throw any exceptions.
\end{itemdescr}

\rSec3[vector.data]{\tcode{vector}\ data}
\index{data@\tcode{data}!\tcode{vector}}%
\begin{itemdecl}
pointer         data();
const_pointer   data() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer such that \range{data()}{data() + size()} is a valid range. For a
non-empty vector, \tcode{data()} \tcode{==} \tcode{\&front()}.

\pnum
\complexity
Constant time.

\pnum
\throws
Nothing.
\end{itemdescr}

\rSec3[vector.modifiers]{\tcode{vector}\ modifiers}

\index{insert@\tcode{insert}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@
  iterator insert(const_iterator position, const T& x);
@\addedConcepts{requires MoveConstructible<T> \&\& MoveAssignable<T>}@
  iterator insert(const_iterator position, T&& x);
@\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@
  void insert(const_iterator position, size_type n, const T& x);
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
    @\addedConcepts{requires HasConstructor<T, Iter::reference> \&\& HasCopyAssign<T, Iter::reference>}@
          @\addedConcepts{\&\& MoveConstructible<T> \&\& MoveAssignable<T>}@
    void insert(const_iterator position,
                @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...> \&\& MoveConstructible<T>}@
  void push_back(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...> \&\& MoveConstructible<T>}@
  iterator emplace(const_iterator position, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{value_type} has a move constructor, that
constructor shall not throw any exceptions.

\pnum
\notes\ 
Causes reallocation if the new size is greater than the old capacity.
If no reallocation happens, all the iterators and references before the insertion point remain valid.
If an exception is thrown other than by
the copy constructor or assignment operator of
\tcode{T}\ or by any \tcode{InputIterator} operation
there are no effects.

\pnum
\complexity\ 
The complexity is linear in the number of elements inserted plus the distance
to the end of the vector.
\end{itemdescr}

\index{erase@\tcode{erase}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator position);
@\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator first, const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Invalidates iterators and references at or after the point of the erase.

\pnum
\complexity\ 
The destructor of \tcode{T}\ is called the number of times equal to the
number of the elements erased, but the move assignment operator
of \tcode{T}\ is called the number of times equal to the number of
elements in the vector after the erased elements.

\pnum
\throws\ 
Nothing unless an exception is thrown by the
copy constructor or assignment operator of
\tcode{T}.
\end{itemdescr}

\rSec3[vector.special]{\tcode{vector}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(vector<T,Allocator>&& x, vector<T,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(vector<T,Allocator>& x, vector<T,Allocator>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[vector.bool]{Class \tcode{vector<bool>}}

\pnum
\index{vector<bool>@\tcode{vector<bool>}}%
To optimize space allocation, a specialization of vector for
\tcode{bool}
elements is provided:

\begin{codeblock}
namespace std {
  template <class Allocator> class vector<bool, Allocator> {
  public:
    // types:
    typedef bool                                  const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef bool                                  value_type;
    typedef Allocator                             allocator_type;
    typedef @\impdef@                pointer;
    typedef @\impdef@                const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // bit reference:
    class reference {
      friend class vector;
      reference();
    public:
      ~reference();
      operator bool() const;
      reference& operator=(const bool x);
      reference& operator=(const reference& x);
      void flip();              // flips the bit
    };

    // construct/copy/destroy:
    explicit vector(const Allocator& = Allocator());
    explicit vector(size_type n, const bool& value = bool(),
                    const Allocator& = Allocator());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires Convertible<Iter::reference, bool>}@
      vector(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
             const Allocator& = Allocator());
    vector(const vector<bool,Allocator>& x);
    vector(vector<bool,Allocator>&& x);
    vector(const vector&, const Allocator&);
    vector(vector&&, const Allocator&);
   ~vector();
    vector<bool,Allocator>& operator=(const vector<bool,Allocator>& x);
    vector<bool,Allocator>& operator=(vector<bool,Allocator>&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires Convertible<Iter::reference, bool>}@
      void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    void assign(size_type n, const bool& t);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    size_type size() const;
    size_type max_size() const;
    void      resize(size_type sz, bool c = false);
    size_type capacity() const;
    bool      empty() const;
    void      reserve(size_type n);

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // modifiers:
    void push_back(const bool& x);
    void pop_back();
    iterator insert(const_iterator position, const bool& x);
    void     insert (const_iterator position, size_type n, const bool& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
        @\addedConcepts{requires Convertible<Iter::reference, bool>}@
        void insert(const_iterator position,
                    @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void swap(vector<bool,Allocator>&&);
    static void swap(reference x, reference y);
    void flip();                // flips all bits
    void clear();
  };

}
\end{codeblock}%

\pnum
Unless described below, all operations have the same requirements and
semantics as the primary \tcode{vector} template, except that operations
dealing with the \tcode{bool} value type map to bit values in the
container storage.

\pnum
There is no requirement that the data be stored as a contiguous allocation
of \tcode{bool} values. A space-optimized representation of bits is
recommended instead.

\pnum
\tcode{reference}
is a class that simulates the behavior of references of a single bit in
\tcode{vector<bool>}. The conversion operator returns \tcode{true}
when the bit is set, and \tcode{false} otherwise. The assignment operator
sets the bit when the argument is (convertible to) \tcode{true} and
clears it otherwise. \tcode{flip} reverses the state of the bit.

\begin{itemdecl}
void flip();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Replaces each element in the container with its complement.
It is unspecified whether the function has any effect on allocated but unused bits.
\end{itemdescr}

\rSec1[associative]{Associative containers}

\pnum
Headers \tcode{<map>}\ and \tcode{<set>}:

\synopsis{Header \tcode{<map>}\ synopsis}%
\index{map@\tcode{<map>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, 
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
    @\addedConcepts{requires Destructible<Key> \&\& Destructible<T> \&\& CopyConstructible<Compare>}@
    class map;
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Allocator>
    bool operator==(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator< (const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Allocator>
    bool operator!=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator> (const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator>=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator<=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(map<Key,T,Compare,Allocator>& x,
              map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(map<Key,T,Compare,Allocator&& x,
              map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(map<Key,T,Compare,Allocator& x,
              map<Key,T,Compare,Allocator>&& y);

  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, 
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
    @\addedConcepts{requires Destructible<Key> \&\& Destructible<T> \&\& CopyConstructible<Compare>}@
    class multimap;
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Allocator>
    bool operator==(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator< (const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Allocator>
    bool operator!=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator> (const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator>=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator<=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(multimap<Key,T,Compare,Allocator>& x,
              multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(multimap<Key,T,Compare,Allocator&& x,
              multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(multimap<Key,T,Compare,Allocator& x,
              multimap<Key,T,Compare,Allocator>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<set>}\ synopsis}%
\index{set@\tcode{<set>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            class Allocator = allocator<Key> >
    @\addedConcepts{requires Destructible<Key> \&\& CopyConstructible<Compare>}@
    class set;
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Allocator>
    bool operator==(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator< (const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Allocator>
    bool operator!=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator> (const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator>=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator<=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
    void swap(set<Key,Compare,Allocator>& x,
              set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, class T, class Compare, class Allocator>
    void swap(set<Key,T,Compare,Allocator&& x,
              set<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, class T, class Compare, class Allocator>
    void swap(set<Key,T,Compare,Allocator& x,
              set<Key,T,Compare,Allocator>&& y);

  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            class Allocator = allocator<Key> >
    @\addedConcepts{requires Destructible<Key> \&\& CopyConstructible<Compare>}@
    class multiset;
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Allocator>
    bool operator==(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator< (const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Allocator>
    bool operator!=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator> (const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator>=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator<=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
    void swap(multiset<Key,Compare,Allocator>& x,
              multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, class T, class Compare, class Allocator>
    void swap(multiset<Key,T,Compare,Allocator&& x,
              multiset<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, class T, class Compare, class Allocator>
    void swap(multiset<Key,T,Compare,Allocator& x,
              multiset<Key,T,Compare,Allocator>&& y);
}
\end{codeblock}

\rSec2[map]{Class template \tcode{map}}%
\index{map@\tcode{map}}

\pnum
A \tcode{map}\ is an associative container that
supports unique keys (contains at most one of each key value) and
provides for fast retrieval of values of another type \tcode{T}\ based
on the keys. The \tcode{map}\ class supports bidirectional iterators.

\pnum
A
\tcode{map}\
satisfies all of the requirements of a container, of a reversible container
(\ref{container.requirements}), of
an associative container (\ref{associative.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
A
\tcode{map}\
also provides most operations described in (\ref{associative.reqmts})
for unique keys.
This means that a
\tcode{map}\
supports the
\tcode{a_uniq}\
operations in (\ref{associative.reqmts})
but not the
\tcode{a_eq}\
operations.
For a
\tcode{map<Key,T>}\
the
\tcode{key_type}\
is
\tcode{Key}\
and the
\tcode{value_type}\
is
\tcode{pair<const Key,T>}.
Descriptions are provided here only for operations on
\tcode{map}\
that are not described in one of those tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, 
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
  @\addedConcepts{requires Destructible<Key> \&\& Destructible<T> \&\& CopyConstructible<Compare>}@
  class map {
  public:
    // types:
    typedef Key                                   key_type;
    typedef T                                     mapped_type;
    typedef pair<const Key, T>                    value_type;
    typedef Compare                               key_compare;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    class value_compare
      : public binary_function<value_type,value_type,bool> {
    friend class map;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) {}
    public:
      bool operator()(const value_type& x, const value_type& y) const {
        return comp(x.first, y.first);
      }
    };

    // \ref{map.cons} construct/copy/destroy:
    explicit map(const Compare& comp = Compare(),
                 const Allocator& = Allocator());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      map(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
          const Compare& comp = Compare(), const Allocator& = Allocator());
    @\addedConcepts{requires CopyConstructible<value_type>}@ map(const map<Key,T,Compare,Allocator>& x);
    map(map<Key,T,Compare,Allocator>&& x);
    map(const Allocator&);
    @\addedConcepts{requires CopyConstructible<value_type>}@ map(const map&, const Allocator&);
    map(map&&, const Allocator&);
   ~map();
    @\addedConcepts{requires CopyConstructible<value_type> \&\& CopyAssignable<value_type>}@ 
      map<Key,T,Compare,Allocator>& operator=(const map<Key,T,Compare,Allocator>& x);
    map<Key,T,Compare,Allocator>&
      operator=(map<Key,T,Compare,Allocator>&& x);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    bool      empty() const;
    size_type size() const;
    size_type max_size() const;

    // \ref{map.access} element access:
    @\addedConcepts{requires DefaultConstructible<T> \&\& CopyConstructible<Key>}@ T& operator[](const key_type& x);
    @\addedConcepts{requires DefaultConstructible<T> \&\& MoveConstructible<Key>}@ T& operator[](key_type&& x);
    T&       at(const key_type& x);
    const T& at(const key_type& x) const;

    // modifiers:
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<value_type>}@ pair<iterator, bool> insert(const value_type& x);
    template <class P> 
      @\addedConcepts{requires HasConstructor<value_type, P\&\&> \&\& Convertible<P, value_type>}@
      pair<iterator, bool> insert(P&& x);
    @\addedConcepts{requires CopyConstructible<value_type>}@ iterator insert(const_iterator position, const value_type& x);
    template <class P>
      @\addedConcepts{requires HasConstructor<value_type, P\&\&> \&\& Convertible<P, value_type>}@
      iterator insert(const_iterator position, P&&);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void swap(map<Key,T,Compare,Allocator>&&);
    void clear();

    // observers:
    key_compare   key_comp() const;
    value_compare value_comp() const;

    // \ref{map.ops} map operations:
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    size_type      count(const key_type& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;

    pair<iterator,iterator>
      equal_range(const key_type& x);
    pair<const_iterator,const_iterator>
      equal_range(const key_type& x) const;
  };

  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Allocator>
    bool operator==(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator< (const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Allocator>
    bool operator!=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator> (const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator>=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator<=(const map<Key,T,Compare,Allocator>& x,
                    const map<Key,T,Compare,Allocator>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(map<Key,T,Compare,Allocator>& x,
              map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(map<Key,T,Compare,Allocator&& x,
              map<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(map<Key,T,Compare,Allocator& x,
              map<Key,T,Compare,Allocator>&& y);

  template <class Key, class T, class Compare, class Alloc>
    struct constructible_with_allocator_suffix<
      map<Key, T, Compare, Alloc> >
        : true_type { };
}
\end{codeblock}%

\index{map@\tcode{map}!\tcode{operator==}}%
\index{map@\tcode{map}!\tcode{operator<}}%

\rSec3[map.cons]{\tcode{map}\ constructors, copy, and assignment}

\begin{itemdecl}
explicit map(const Compare& comp = Compare(),
             const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty
\tcode{map}\
using the specified comparison object and allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
  map(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
      const Compare& comp = Compare(), const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} If the iterator's dereference operator returns an lvalue or a
const rvalue \mbox{\tcode{pair<key_type, mapped_type>}}, then both
\mbox{\tcode{key_type}} and \mbox{\tcode{mapped_type}} shall be
\mbox{\tcode{CopyConstructible}}.}

\pnum
\effects\ 
Constructs an empty
\tcode{map}\
using the specified comparison object and allocator,
and inserts elements from the range
\range{\farg{first}}{\farg{last}}.

\pnum
\complexity\ 
Linear in $N$ if the range
\range{\farg{first}}{\farg{last}}\
is already sorted using \farg{comp}
and otherwise $N \log{N}$, where $N$
is \farg{last} - \farg{first}.
\end{itemdescr}

\rSec3[map.access]{\tcode{map}\ element access}

\index{operator[]@\tcode{operator[]}!map@\tcode{map}}%
\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T> \&\& CopyConstructible<Key>}@ T& operator[](const key_type& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
If there is no key equivalent to \tcode{x}\ in the map, inserts
\tcode{value_type(x, T())}\
into the map.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{key_type}} shall be
\mbox{\tcode{CopyConstructible}} and \mbox{\tcode{mapped_type}} shall be
\mbox{\tcode{DefaultConstructible}}.}

\pnum
\returns\ 
A reference to the
\tcode{mapped_type}\
corresponding to \tcode{x}\ in
\tcode{*this}.

\pnum
\complexity\
logarithmic.
\end{itemdescr}

\index{operator[]@\tcode{operator[]}!map@\tcode{map}}%
\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T> \&\& MoveConstructible<Key>}@ T& operator[](key_type&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If there is no key equivalent to \tcode{x} in the map, inserts
\tcode{value_type(std::move(x), T())}
into the map.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{mapped_type}} shall be
\mbox{\tcode{DefaultConstructible}}.}

\pnum
\returns
A reference to the
\tcode{mapped_type}
corresponding to \tcode{x} in
\tcode{*this}.

\pnum
\complexity
logarithmic.
\end{itemdescr}

\index{at@\tcode{at}!map@\tcode{map}}%
\begin{itemdecl}
T&       at(const key_type& x);
const T& at(const key_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A reference to the element whose key is equivalent to \tcode{x}.

\pnum
\throws
An exception object of type \tcode{out_of_range} if
no such element is present.

\pnum
\complexity
logarithmic.
\end{itemdescr}

\rSec3[map.modifiers]{\tcode{map}\ modifiers}

\begin{itemdecl}
template <class P> 
  @\addedConcepts{requires HasConstructor<value_type, P\&\&> \&\& Convertible<P, value_type>}@
  pair<iterator, bool> insert(P&& x);
template <class P> 
  @\addedConcepts{requires HasConstructor<value_type, P\&\&> \&\& Convertible<P, value_type>}@
  pair<iterator, bool> insert(const_iterator position, P&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}
\mbox{\tcode{P}} shall be convertible to \mbox{\tcode{value_type}}.}

If \tcode{P} is instantiated as a reference type, then
the argument \tcode{x} is copied from. Otherwise \tcode{x}
is considered to be an rvalue as it is converted to
\tcode{value_type} and inserted into the \tcode{map}.
Specifically, in such cases \tcode{CopyConstructible} is not required of
\tcode{key_type} or \tcode{mapped_type}
unless the conversion from \tcode{P} specifically
requires it (e.g. if \tcode{P} is a 
\tcode{tuple<const key_type, mapped_type>}, then
\tcode{key_type} must be \tcode{CopyConstructible}).
The signature taking \tcode{InputIterator}
parameters does not require \tcode{CopyConstructible}
of either \tcode{key_type} or
\tcode{mapped_type} if the dereferenced \tcode{InputIterator}
returns a non-const rvalue
\tcode{pair<key_type,mapped_type>}. Otherwise
\tcode{CopyConstructible} is required for
both \tcode{key_type} and \tcode{mapped_type}.
\end{itemdescr}

\rSec3[map.ops]{\tcode{map}\ operations}

\begin{itemdecl}
iterator       find(const key_type& x);
const_iterator find(const key_type& x) const;

iterator       lower_bound(const key_type& x);
const_iterator lower_bound(const key_type& x) const;

iterator       upper_bound(const key_type& x);
const_iterator upper_bound(const key_type &x) const;

pair<iterator, iterator>
  equal_range(const key_type &x);
pair<const_iterator, const_iterator>
  equal_range(const key_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
The
\tcode{find},
\tcode{lower_bound},
\tcode{upper_bound}\
and
\tcode{equal_range}\
member functions each have two versions,
one const and the other non-const.
In each case the behavior of the two functions is identical
except that the const version returns a
\tcode{const_iterator}\
and the non-const version an
\tcode{iterator}\
(\ref{associative.reqmts}).
\end{itemdescr}

\rSec3[map.special]{\tcode{map}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
  void swap(map<Key,T,Compare,Allocator>& x,
            map<Key,T,Compare,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
  void swap(map<Key,T,Compare,Allocator>&& x,
            map<Key,T,Compare,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
  void swap(map<Key,T,Compare,Allocator>& x,
            map<Key,T,Compare,Allocator>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[multimap]{Class template \tcode{multimap}}

\pnum
\index{multimap@\tcode{multimap}}%
A
\tcode{multimap}\
is an associative container that supports equivalent keys (possibly containing multiple copies of
the same key value) and provides for fast retrieval of values of another type
\tcode{T}\
based on the keys.
The
\tcode{multimap}\
class
supports bidirectional iterators.

\pnum
A
\tcode{multimap}\
satisfies all of the requirements of a container and of a reversible container
(\ref{container.requirements}), of
an associative container (\ref{associative.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
A
\tcode{multimap}\
also provides most operations described in (\ref{associative.reqmts})
for equal keys.
This means that a
\tcode{multimap}\
supports the
\tcode{a_eq}\
operations in
(\ref{associative.reqmts})
but not the
\tcode{a_uniq}\
operations.
For a
\tcode{multimap<Key,T>}\
the
\tcode{key_type}\
is
\tcode{Key}\
and the
\tcode{value_type}\
is
\tcode{pair<const Key,T>}.
Descriptions are provided here only for operations on
\tcode{multimap}\
that are not described in one of those tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, 
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
    @\addedConcepts{requires Destructible<Key> \&\& Destructible<T> \&\& CopyConstructible<Compare>}@
  class multimap {
  public:
    // types:
    typedef Key                                   key_type;
    typedef T                                     mapped_type;
    typedef pair<const Key,T>                     value_type;
    typedef Compare                               key_compare;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    class value_compare
      : public binary_function<value_type,value_type,bool> {
    friend class multimap;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) { }
    public:
      bool operator()(const value_type& x, const value_type& y) const {
        return comp(x.first, y.first);
      }
    };

    // construct/copy/destroy:
    explicit multimap(const Compare& comp = Compare(),
                      const Allocator& = Allocator());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      multimap(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
          const Compare& comp = Compare(), const Allocator& = Allocator());
    @\addedConcepts{requires CopyConstructible<value_type>}@ multimap(const multimap<Key,T,Compare,Allocator>& x);
    multimap(multimap<Key,T,Compare,Allocator>&& x);
    multimap(const Allocator&);
    @\addedConcepts{requires CopyConstructible<value_type>}@ multimap(const multimap&, const Allocator&);
    multimap(multimap&&, const Allocator&);
   ~multimap();
    @\addedConcepts{requires CopyConstructible<value_type> \&\& CopyAssignable<value_type>}@
      multimap<Key,T,Compare,Allocator>& operator=(const multimap<Key,T,Compare,Allocator>& x);
    multimap<Key,T,Compare,Allocator>&
      operator=(const multimap<Key,T,Compare,Allocator>&& x);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    bool           empty() const;
    size_type      size() const;
    size_type      max_size() const;

    // modifiers:
    template <class... Args>
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<value_type>}@ iterator insert(const value_type& x);
    template <class P> 
      @\addedConcepts{requires HasConstructor<value_type, P\&\&> \&\& Convertible<P, value_type>}@
      iterator insert(P&& x);
    @\addedConcepts{requires CopyConstructible<value_type>}@  iterator insert(const_iterator position, const value_type& x);
    template <class P> 
      @\addedConcepts{requires HasConstructor<value_type, P\&\&> \&\& Convertible<P, value_type>}@
      iterator insert(const_iterator position, P&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void swap(multimap<Key,T,Compare,Allocator>&&);
    void clear();

    // observers:
    key_compare    key_comp() const;
    value_compare  value_comp() const;

    // map operations:
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    size_type      count(const key_type& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;

    pair<iterator,iterator>
      equal_range(const key_type& x);
    pair<const_iterator,const_iterator>
      equal_range(const key_type& x) const;
  };

  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Allocator>
    bool operator==(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator< (const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Allocator>
    bool operator!=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator> (const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator>=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Allocator>
    bool operator<=(const multimap<Key,T,Compare,Allocator>& x,
                    const multimap<Key,T,Compare,Allocator>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(multimap<Key,T,Compare,Allocator>& x,
              multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(multimap<Key,T,Compare,Allocator&& x,
              multimap<Key,T,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
    void swap(multimap<Key,T,Compare,Allocator& x,
              multimap<Key,T,Compare,Allocator>&& y);

  template <class Key, class T, class Compare, class Alloc>
    struct constructible_with_allocator_suffix<
      multimap<Key, T, Compare, Alloc> >
        : true_type { };
}
\end{codeblock}%
\index{multimap@\tcode{multimap}!\tcode{operator==}}%
\index{multimap@\tcode{multimap}!\tcode{operator<}}

\rSec3[multimap.cons]{\tcode{multimap}\ constructors}

\begin{itemdecl}
explicit multimap(const Compare& comp = Compare(),
                  const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty
\tcode{multimap}\
using the specified comparison object and allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
  multimap(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
      const Compare& comp = Compare(), const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} If the iterator's dereference operator returns an lvalue or a
const rvalue \mbox{\tcode{pair<key_type, mapped_type>}}, then both
\mbox{\tcode{key_type}} and \mbox{\tcode{mapped_type}} shall be
\mbox{\tcode{CopyConstructible}}.}

\pnum
\effects\ 
Constructs an empty
\tcode{multimap}\
using the specified comparison object and allocator,
and inserts elements from the range
\range{\farg{first}}{\farg{last}}.

\pnum
\complexity\ 
Linear in $N$ if the range
\range{\farg{first}}{\farg{last}}\
is already sorted using \farg{comp}
and otherwise $N \log{N}$,
where $N$\ is
\tcode{\farg{last}\ - \farg{first}}.
\end{itemdescr}

\rSec3[multimap.modifiers]{\tcode{multimap}\ modifiers}

\begin{itemdecl}
template <class P> 
  @\addedConcepts{requires HasConstructor<value_type, P\&\&> \&\& Convertible<P, value_type>}@
  iterator insert(P&& x);
template <class P> 
  @\addedConcepts{requires HasConstructor<value_type, P\&\&> \&\& Convertible<P, value_type>}@
  iterator insert(const_iterator position, P&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}
\mbox{\tcode{P}} shall be convertible to \mbox{\tcode{value_type}}.}

If \tcode{P} is instantiated as a reference type, then
the argument \tcode{x} is copied from. Otherwise \tcode{x}
is considered to be an rvalue as it is converted to
\tcode{value_type} and inserted into the \tcode{map}.
Specifically, in such cases \tcode{CopyConstructible} is not required of
\tcode{key_type} or tcode{mapped_type}
unless the conversion from \tcode{P} specifically
requires it (e.g. if \tcode{P} is a 
\tcode{tuple<const key_type, mapped_type>}, then
\tcode{key_type} must be \tcode{CopyConstructible}).
The signature taking \tcode{InputIterator}
parameters does not require \tcode{CopyConstructible}
of either \tcode{key_type} or
\tcode{mapped_type} if the dereferenced \tcode{InputIterator}
returns a non-const rvalue
\tcode{pair<key_type,mapped_type>}. Otherwise
\tcode{CopyConstructible} is required for
both \tcode{key_type} and \tcode{mapped_type}.
\end{itemdescr}

\rSec3[multimap.ops]{\tcode{multimap}\ operations}

\begin{itemdecl}
iterator       find(const key_type &x);
const_iterator find(const key_type& x) const;

iterator       lower_bound(const key_type& x);
const_iterator lower_bound(const key_type& x) const;

pair<iterator, iterator>
  equal_range(const key_type& x);
pair<const_iterator, const_iterator>
  equal_range(const key_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
The
\tcode{find},
\tcode{lower_bound},
\tcode{upper_bound},
and
\tcode{equal_range}\
member functions each have two versions, one const and one non-const.
In each case the behavior of the two versions is identical
except that the const version returns a
\tcode{const_iterator}\
and the non-const version an
\tcode{iterator}\
(\ref{associative.reqmts}).
\end{itemdescr}

\rSec3[multimap.special]{\tcode{multimap}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
  void swap(multimap<Key,T,Compare,Allocator>& x,
            multimap<Key,T,Compare,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
  void swap(multimap<Key,T,Compare,Allocator>&& x,
            multimap<Key,T,Compare,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Compare, class Allocator>
  void swap(multimap<Key,T,Compare,Allocator>& x,
            multimap<Key,T,Compare,Allocator>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[set]{Class template \tcode{set}}

\pnum
\index{set@\tcode{set}}%
A
\tcode{set}\
is an associative container that supports unique keys (contains at most one of each key value) and
provides for fast retrieval of the keys themselves.
Class
\tcode{set}\
supports bidirectional iterators.

\pnum
A
\tcode{set}\
satisfies all of the requirements of a container, of a reversible container
(\ref{container.requirements}), of
an associative container (\ref{associative.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
A
\tcode{set}\
also provides most operations described in (\ref{associative.reqmts})
for unique keys.
This means that a
\tcode{set}\
supports the
\tcode{a_uniq}\
operations in (\ref{associative.reqmts})
but not the
\tcode{a_eq}\
operations.
For a
\tcode{set<Key>}\
both the
\tcode{key_type}\
and
\tcode{value_type}\
are
\tcode{Key}.
Descriptions are provided here only for operations on
\tcode{set}\
that are not described in one of these tables
and for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            class Allocator = allocator<Key> >
  @\addedConcepts{requires Destructible<Key> \&\& CopyConstructible<Compare>}@
  class set {
  public:
    // types:
    typedef Key                                   key_type;
    typedef Key                                   value_type;
    typedef Compare                               key_compare;
    typedef Compare                               value_compare;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{set.cons} construct/copy/destroy:
    explicit set(const Compare& comp = Compare(),
                 const Allocator& = Allocator());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      set(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
          const Compare& comp = Compare(), const Allocator& = Allocator());
    @\addedConcepts{requires CopyConstructible<value_type>}@ set(const set<Key,Compare,Allocator>& x);
    set(set<Key,Compare,Allocator>&& x);
    set(const Allocator&);
    @\addedConcepts{requires CopyConstructible<value_type>}@ set(const set&, const Allocator&);
    set(set&&, const Allocator&);
   ~set();

    @\addedConcepts{requires CopyConstructible<value_type> \&\& CopyAssignable<value_type>}@
      set<Key,Compare,Allocator>& operator=(const set<Key,Compare,Allocator>& x);
    set<Key,Compare,Allocator>& operator=(set<Key,Compare,Allocator>&& x);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    bool          empty() const;
    size_type     size() const;
    size_type     max_size() const;

    // modifiers:
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<value_type>}@ pair<iterator,bool> insert(const value_type& x);
    @\addedConcepts{requires MoveConstructible<value_type>}@ pair<iterator,bool> insert(value_type&& x);
    @\addedConcepts{requires CopyConstructible<value_type>}@ iterator insert(const_iterator position, const value_type& x);
    @\addedConcepts{requires MoveConstructible<value_type>}@ iterator insert(const_iterator position, value_type&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void swap(set<Key,Compare,Allocator>&);
    void clear();

    // observers:
    key_compare   key_comp() const;
    value_compare value_comp() const;

    // set operations:
    iterator        find(const key_type& x);
    const_iterator  find(const key_type& x) const;

    size_type count(const key_type& x) const;

    iterator        lower_bound(const key_type& x);
    const_iterator  lower_bound(const key_type& x) const;

    iterator        upper_bound(const key_type& x);
    const_iterator  upper_bound(const key_type& x) const;

    pair<iterator,iterator>             equal_range(const key_type& x);
    pair<const_iterator,const_iterator> equal_range(const key_type& x) const;
  };

  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Allocator>
    bool operator==(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator< (const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Allocator>
    bool operator!=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator> (const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator>=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator<=(const set<Key,Compare,Allocator>& x,
                    const set<Key,Compare,Allocator>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
    void swap(set<Key,Compare,Allocator>& x,
              set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
    void swap(set<Key,Compare,Allocator&& x,
              set<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
    void swap(set<Key,Compare,Allocator& x,
              set<Key,Compare,Allocator>&& y);

  template <class Key, class Compare, class Alloc>
    struct constructible_with_allocator_suffix<
      set<Key, Compare, Alloc> >
        : true_type { };
}
\end{codeblock}%
\index{set@\tcode{set}!\tcode{operator==}}%
\index{set@\tcode{set}!\tcode{operator<}}

\rSec3[set.cons]{\tcode{set}\ constructors, copy, and assignment}

\begin{itemdecl}
explicit set(const Compare& comp = Compare(),
             const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty set using the specified comparison objects and allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
  set(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@,
      const Compare& @\farg{comp}@ = Compare(), const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty
\tcode{set}\
using the specified comparison object and allocator,
and inserts elements from the range
\range{\farg{first}}{\farg{last}}.

\pnum
@\removedConcepts{\mbox{\requires} If the iterator's dereference operator returns an lvalue or a
non-const rvalue, then \mbox{\tcode{Key}} shall be
\mbox{\tcode{CopyConstructible}}.}

\pnum
\complexity\ 
Linear in $N$ if the range
\range{\farg{first}}{\farg{last}}\
is already sorted using \farg{comp}\
and otherwise $N \log{N}$,
where $N$\ is
\tcode{\farg{last} - \farg{first}}.
\end{itemdescr}

\rSec3[set.special]{\tcode{set}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
  void swap(set<Key,Compare,Allocator>& x,
            set<Key,Compare,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
  void swap(set<Key,Compare,Allocator>&& x,
            set<Key,Compare,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
  void swap(set<Key,Compare,Allocator>& x,
            set<Key,Compare,Allocator>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[multiset]{Class template \tcode{multiset}}

\pnum
\index{multiset@\tcode{multiset}}%
A
\tcode{multiset}\
is an associative container that supports equivalent keys (possibly contains multiple copies of
the same key value) and provides for fast retrieval of the keys themselves.
Class
\tcode{multiset}\
supports bidirectional iterators.

\pnum
A
\tcode{multiset}\
satisfies all of the requirements of a container, of a reversible container
(\ref{container.requirements}), of
an associative container (\ref{associative.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
\tcode{multiset}
also provides most operations described in
(\ref{associative.reqmts})
for duplicate keys.
This means that a
\tcode{multiset}\
supports the
\tcode{a_eq}\
operations in
(\ref{associative.reqmts})
but not the
\tcode{a_uniq}\
operations.
For a
\tcode{multiset<Key>}\
both the
\tcode{key_type}\
and
\tcode{value_type}\
are
\tcode{Key}.
Descriptions are provided here only for operations on
\tcode{multiset}\
that are not described in one of these tables
and for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            class Allocator = allocator<Key> >
  @\addedConcepts{requires Destructible<Key> \&\& CopyConstructible<Compare>}@
  class multiset {
  public:
    // types:
    typedef Key                                   key_type;
    typedef Key                                   value_type;
    typedef Compare                               key_compare;
    typedef Compare                               value_compare;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // construct/copy/destroy:
    explicit multiset(const Compare& comp = Compare(),
                      const Allocator& = Allocator());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      multiset(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
               const Compare& comp = Compare(),
               const Allocator& = Allocator());
    @\addedConcepts{requires CopyConstructible<value_type>}@ multiset(const multiset<Key,Compare,Allocator>& x);
    multiset(multiset<Key,Compare,Allocator>&& x);
    multiset(const Allocator&);
    @\addedConcepts{requires CopyConstructible<value_type>}@ multiset(const multiset&, const Allocator&);
    multiset(multiset&&, const Allocator&);
   ~multiset();
    @\addedConcepts{requires CopyConstructible<value_type> \&\& CopyAssignable<value_type>}@
      multiset<Key,Compare,Allocator>& operator=(const multiset<Key,Compare,Allocator>& x);
    multiset<Key,Compare,Allocator>& operator=(multiset<Key,Compare,Allocator>&& x);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    bool          empty() const;
    size_type     size() const;
    size_type     max_size() const;

    // modifiers:
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<value_type>}@ iterator insert(const value_type& x);
    @\addedConcepts{requires MoveConstructible<value_type>}@ iterator insert(value_type&& x);
    @\addedConcepts{requires CopyConstructible<value_type>}@ iterator insert(const_iterator position, const value_type& x);
    @\addedConcepts{requires MoveConstructible<value_type>}@ iterator insert(const_iterator position, value_type&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void swap(multiset<Key,Compare,Allocator>&&);
    void clear();

    // observers:
    key_compare   key_comp() const;
    value_compare value_comp() const;

    // set operations:
    iterator        find(const key_type& x);
    const_iterator  find(const key_type& x) const;

    size_type count(const key_type& x) const;

    iterator        lower_bound(const key_type& x);
    const_iterator  lower_bound(const key_type& x) const;

    iterator        upper_bound(const key_type& x);
    const_iterator  upper_bound(const key_type& x) const;

    pair<iterator,iterator>             equal_range(const key_type& x);
    pair<const_iterator,const_iterator> equal_range(const key_type& x) const;
  };

  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Allocator>
    bool operator==(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator< (const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Allocator>
    bool operator!=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator> (const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator>=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Allocator>
    bool operator<=(const multiset<Key,Compare,Allocator>& x,
                    const multiset<Key,Compare,Allocator>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
    void swap(multiset<Key,Compare,Allocator>& x,
              multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
    void swap(multiset<Key,Compare,Allocator&& x,
              multiset<Key,Compare,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
    void swap(multiset<Key,Compare,Allocator& x,
              multiset<Key,Compare,Allocator>&& y);

  template <class Key, class Compare, class Alloc>
    struct constructible_with_allocator_suffix<
      multiset<Key, Compare, Alloc> >
        : true_type { };
}
\end{codeblock}%
\index{multiset@\tcode{multiset}!\tcode{operator==}}%
\index{multiset@\tcode{multiset}!\tcode{operator<}}

\rSec3[multiset.cons]{\tcode{multiset}\ constructors}

\begin{itemdecl}
explicit multiset(const Compare& @\farg{comp}@ = Compare(),
                  const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty set using the specified comparison object and allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
  multiset(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@,
           const Compare& @\farg{comp}@ = Compare(),
           const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} If the iterator's dereference operator returns an lvalue or a
const rvalue, then \mbox{\tcode{Key}} shall be
\mbox{\tcode{CopyConstructible}}.}

\pnum
\effects\ 
Constructs an empty
\tcode{multiset}\
using the specified comparison object and allocator,
and inserts elements from the range
\range{\farg{first}}{\farg{last}}.

\pnum
\complexity\ 
Linear in $N$
if the range
\range{\farg{first}}{\farg{last}}\
is already sorted using \farg{comp}\ and otherwise $N \log{N}$,
where $N$ is
\tcode{\farg{last}\ - \farg{first}}.
\end{itemdescr}

\rSec3[multiset.special]{\tcode{multiset}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
  void swap(multiset<Key,Compare,Allocator>& x,
            multiset<Key,Compare,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
  void swap(multiset<Key,Compare,Allocator>&& x,
            multiset<Key,Compare,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ Key, class Compare, class Allocator>
  void swap(multiset<Key,Compare,Allocator>& x,
            multiset<Key,Compare,Allocator>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec1[unord]{\marktr{}Unordered associative containers}

\pnum
Headers \tcode{<unordered_map>}\ and \tcode{<unordered_set>}:

\synopsis{Header \tcode{<unordered_map>}\ synopsis}%
\index{unordered_map@\tcode{<unordered_map>}}%
\index{unordered_map@\tcode{unordered_map}}%
\index{unordered_multimap@\tcode{unordered_multimap}}%
\begin{codeblock}
namespace std {
  // \ref{unord.map}, class template unordered_map:
  template <@\changedConcepts{class}{ObjectType}@ Key,
            @\changedConcepts{class}{ObjectType}@ T,
            @\changedConcepts{class}{Callable<auto, Key>}@ Hash = hash<Key>,
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Pred = std::equal_to<Key>,
            class Alloc = std::allocator<std::pair<const Key, T> > >
    @\addedConcepts{requires SameType<Hash::result_type, std::size_t>}@
             @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
    class unordered_map;

  // \ref{unord.multimap}, class template unordered_multimap:
  template <@\changedConcepts{class}{ObjectType}@ Key,
            @\changedConcepts{class}{ObjectType}@ T,
            @\changedConcepts{class}{Callable<auto, Key>}@ Hash = hash<Key>,
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Pred = std::equal_to<Key>,
            class Alloc = std::allocator<std::pair<const Key, T> > >
    @\addedConcepts{requires SameType<Hash::result_type, std::size_t>}@
             @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
    class unordered_multimap;

  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Hash, class Pred, class Alloc>
    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_map<Key, T, Hash, Pred, Alloc>& y);

  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Hash, class Pred, class Alloc>
    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
              unordered_multimap<Key, T, Hash, Pred, Alloc>& y);
} // namespace std
\end{codeblock}

\synopsis{Header \tcode{<unordered_set>}\ synopsis}%
\index{unordered_set@\tcode{<unordered_set>}}%
\index{unordered_set@\tcode{unordered_set}}%
\index{unordered_multiset@\tcode{unordered_multiset}}%
\begin{codeblock}
namespace std {
  // \ref{unord.set}, class template unordered_set:
  template <@\changedConcepts{class}{ObjectType}@ Value,
            @\changedConcepts{class}{Callable<auto, Value>}@ Hash = hash<Value>,
            @\changedConcepts{class}{Predicate<auto, Value, Value>}@ class Pred = std::equal_to<Value>,
            class Alloc = std::allocator<Value> >
    @\addedConcepts{requires SameType<Hash::result_type, std::size_t>}@
             @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
    class unordered_set;

  // \ref{unord.multiset}, class template unordered_multiset:
  template <@\changedConcepts{class}{ObjectType}@ Value,
            @\changedConcepts{class}{Callable<auto, Value>}@ Hash = hash<Value>,
            @\changedConcepts{class}{Predicate<auto, Value, Value>}@ class Pred = std::equal_to<Value>,
            class Alloc = std::allocator<Value> >
    @\addedConcepts{requires SameType<Hash::result_type, std::size_t>}@
             @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
    class unordered_multiset;

  template <@\changedConcepts{class}{ObjectType}@ Value, class Hash, class Pred, class Alloc>
    void swap(unordered_set<Value, Hash, Pred, Alloc>& x,
              unordered_set<Value, Hash, Pred, Alloc>& y);

  template <@\changedConcepts{class}{ObjectType}@ Value, class Hash, class Pred, class Alloc>
    void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,
              unordered_multiset<Value, Hash, Pred, Alloc>& y);
} // namespace std
\end{codeblock}

\rSec2[unord.map]{Class template \tcode{unordered_map}}
\index{unordered_map@\tcode{unordered_map}}%
\index{allocator}

\pnum
\index{unordered_map@\tcode{unordered_map}!unique keys}%
\index{unordered associative containers!unique keys}%
An \tcode{unordered_map} is an unordered associative container that
supports unique keys (an \tcode{unordered_map} contains at most one of each
key value) and that associates values of another type
\tcode{mapped_type} with the keys.

\pnum
An \tcode{unordered_map} satisfies all of the requirements of a container, of an unordered associative container, and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}). It provides the operations described in the preceding requirements table for unique keys; that is, an \tcode{unordered_map} supports the \tcode{a_uniq} operations in that table, not the \tcode{a_eq} operations. For an \tcode{unordered_map<Key, T>} the \tcode{key type} is \tcode{Key}, the mapped type is \tcode{T}, and the value type is \tcode{std::pair<const Key, T>}.

\pnum
This section only describes operations on \tcode{unordered_map} that
are not described in one of the requirement tables, or for which there
is additional semantic information.

\index{unordered_map@\tcode{unordered_map}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ Key,
            @\changedConcepts{class}{ObjectType}@ T,
            @\changedConcepts{class}{Callable<auto, Key>}@ Hash = hash<Key>,
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Pred = std::equal_to<Key>,
            class Alloc = std::allocator<std::pair<const Key, T> > >
  @\addedConcepts{requires SameType<Hash::result_type, std::size_t>}@
           @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
  class unordered_map
  {
  public:
    // types
    typedef Key                                      key_type;
    typedef std::pair<const Key, T>                  value_type;
    typedef T                                        mapped_type;
    typedef Hash                                     hasher;
    typedef Pred                                     key_equal;
    typedef Alloc                                    allocator_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef @\impdef@                   size_type;
    typedef @\impdef@                   difference_type;

    typedef @\impdef@                   iterator;
    typedef @\impdef@                   const_iterator;
    typedef @\impdef@                   local_iterator;
    typedef @\impdef@                   const_local_iterator;

    // construct/destroy/copy
    explicit unordered_map(size_type n = @\textit{implementation-defined}@,
                           const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      unordered_map(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                    size_type n = @\textit{implementation-defined}@,
                    const hasher& hf = hasher(),
                    const key_equal& eql = key_equal(),
                    const allocator_type& a = allocator_type());
    @\addedConcepts{requires CopyConstructible<value_type>}@ unordered_map(const unordered_map&);
    unordered_map(const Allocator&);
    @\addedConcepts{requires CopyConstructible<value_type>}@ unordered_map(const unordered_map&, const Allocator&);
    unordered_map(unordered_map&&, const Allocator&);
    ~unordered_map();
    @\addedConcepts{requires CopyConstructible<value_type> \&\& CopyAssignable<value_type>}@ 
      unordered_map& operator=(const unordered_map&);
    allocator_type get_allocator() const;

    // size and capacity
    bool empty() const;
    size_type size() const;
    size_type max_size() const;

    // iterators
    iterator       begin();
    const_iterator begin() const;
    iterator       end();
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    // modifiers
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<value_type>}@
      std::pair<iterator, bool> insert(const value_type& obj);
    @\addedConcepts{requires CopyConstructible<value_type>}@
      iterator insert(const_iterator hint, const value_type& obj);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear();

    void swap(unordered_map&);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type count(const key_type& k) const;
    std::pair<iterator, iterator>             equal_range(const key_type& k);
    std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    @\addedConcepts{requires DefaultConstructible<T> \&\& CopyConstructible<key_type>}@ mapped_type& operator[](const key_type& k);

    // bucket interface
    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type n);
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n) const;
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;  

    // hash policy
    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    @\addedConcepts{requires MoveConstructible<value_type>}@ void rehash(size_type n);
  };

  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Hash, class Pred, class Alloc>
    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_map<Key, T, Hash, Pred, Alloc>& y);

  template <class Key, class T, class Hash, class Pred, class Alloc>
    struct constructible_with_allocator_suffix<
      unordered_map<Key, T, Hash, Pred, Compare, Alloc> >
        : true_type { };
}
\end{codeblock}

\rSec3[unord.map.cnstr]{\tcode{unordered_map} constructors}

\index{unordered_map@\tcode{unordered_map}!unordered_map@\tcode{unordered_map}}%
\begin{itemdecl}
explicit unordered_map(size_type n = @\textit{implementation-defined}@,
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_map} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Constant.
\end{itemdescr}

\index{unordered_map@\tcode{unordered_map}!unordered_map@\tcode{unordered_map}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
  unordered_map(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                size_type n = @\textit{implementation-defined}@,
                const hasher& hf = hasher(),
                const key_equal& eql = key_equal(),
                const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_map} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  (If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.)  Then
inserts elements from the range \tcode{[\textit{f}, \textit{l})}.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Average case linear, worst case quadratic.
\end{itemdescr}

\rSec3[unord.map.elem]{\tcode{unordered_map} element access}

\index{unordered_map@\tcode{unordered_map}!operator[]@\tcode{operator[]}}%
\index{operator[]@\tcode{operator[]}!unordered_map@\tcode{unordered_map}}%
\index{unordered_map@\tcode{unordered_map}!element access}%
\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T> \&\& CopyConstructible<key_type>}@ mapped_type& operator[](const key_type& k);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ If the \tcode{unordered_map} does not already contain
an element whose key is equivalent to \tcode{\textit{k}}, inserts 
the value
\tcode{std::pair<const key_type, mapped_type>(k, mapped_type())}.

\pnum
\returns\ A reference to \tcode{x.second}, where \tcode{x}
is the (unique) element whose key is equivalent to \tcode{\textit{k}}.
\end{itemdescr}

\rSec3[unord.map.swap]{\tcode{unordered_map} swap}

\index{unordered_map@\tcode{unordered_map}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!unordered_map@\tcode{unordered_map}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Hash, class Pred, class Alloc>
  void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
            unordered_map<Key, T, Hash, Pred, Alloc>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ \tcode{x.swap(y)}.
\end{itemdescr}

\rSec2[unord.multimap]{Class template \tcode{unordered_multimap}}
\index{unordered_multimap@\tcode{unordered_multimap}}%
\index{allocator}

\pnum
\index{unordered_multimap@\tcode{unordered_multimap}!equivalent keys}%
\index{unordered associative containers!equivalent keys}%
An \tcode{unordered_multimap} is an unordered associative container
that supports equivalent keys (an \tcode{unordered_multimap} may contain
multiple copies of each key value) and that associates values of
another type \tcode{mapped_type} with the keys.

\pnum
An \tcode{unordered_multimap} satisfies all of the requirements of a container, of an unordered associative container, and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}). It provides the operations described in the preceding requirements table for equivalent keys; that is, an \tcode{unordered_multimap} supports the \tcode{a_eq} operations in that table, not the \tcode{a_uniq} operations. For an \tcode{unordered_multimap<Key, T>} the \tcode{key type} is \tcode{Key}, the mapped type is \tcode{T}, and the value type is \tcode{std::pair<const Key, T>}.

\pnum
This section only describes operations on \tcode{unordered_multimap}
that are not described in one of the requirement tables, or for which
there is additional semantic information.

\index{unordered_multimap@\tcode{unordered_multimap}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ Key,
            @\changedConcepts{class}{ObjectType}@ T,
            @\changedConcepts{class}{Callable<auto, Key>}@ Hash = hash<Key>,
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Pred = std::equal_to<Key>,
            class Alloc = std::allocator<std::pair<const Key, T> > >
  @\addedConcepts{requires SameType<Hash::result_type, std::size_t>}@
           @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
  class unordered_multimap
  {
  public:
    // types
    typedef Key                                      key_type;
    typedef std::pair<const Key, T>                  value_type;
    typedef T                                        mapped_type;
    typedef Hash                                     hasher;
    typedef Pred                                     key_equal;
    typedef Alloc                                    allocator_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef @\impdef@                   size_type;
    typedef @\impdef@                   difference_type;

    typedef @\impdef@                   iterator;
    typedef @\impdef@                   const_iterator;
    typedef @\impdef@                   local_iterator;
    typedef @\impdef@                   const_local_iterator;

    // construct/destroy/copy
    explicit unordered_multimap(size_type n = @\textit{implementation-defined}@,
                                const hasher& hf = hasher(),
                                const key_equal& eql = key_equal(),
                                const allocator_type& a = allocator_type());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      unordered_multimap(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                         size_type n = @\textit{implementation-defined}@,
                         const hasher& hf = hasher(),
                         const key_equal& eql = key_equal(),
                         const allocator_type& a = allocator_type());
    @\addedConcepts{requires CopyConstructible<value_type>}@ unordered_multimap(const unordered_multimap&);
    unordered_multimap(const Allocator&);
    @\addedConcepts{requires CopyConstructible<value_type>}@
       unordered_multimap(const unordered_multimap&, const Allocator&);
    unordered_multimap(unordered_multimap&&, const Allocator&);
    ~unordered_multimap();
    @\addedConcepts{requires CopyConstructible<value_type> \&\& CopyAssignable<value_type>}@ 
      unordered_multimap& operator=(const unordered_multimap&);
    allocator_type get_allocator() const;

    // size and capacity
    bool empty() const;
    size_type size() const;
    size_type max_size() const;

    // iterators
    iterator       begin();
    const_iterator begin() const;
    iterator       end();
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    // modifiers
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<value_type>}@ iterator insert(const value_type& obj);
    @\addedConcepts{requires CopyConstructible<value_type>}@ 
      iterator insert(const_iterator hint, const value_type& obj);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear();

    void swap(unordered_multimap&);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type count(const key_type& k) const;
    std::pair<iterator, iterator>             equal_range(const key_type& k);
    std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type n);
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n) const;
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;  

    // hash policy
    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    @\addedConcepts{requires MoveConstructible<value_type>}@ void rehash(size_type n);
  };

  template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Hash, class Pred, class Alloc>
    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
              unordered_multimap<Key, T, Hash, Pred, Alloc>& y);

  template <class Key, class T, class Hash, class Pred, class Alloc>
    struct constructible_with_allocator_suffix<
      unordered_multimap<Key, T, Hash, Pred, Alloc> >
        : true_type { };
}
\end{codeblock}

\rSec3[unord.multimap.cnstr]{\tcode{unordered_multimap} constructors}

\index{unordered_multimap@\tcode{unordered_multimap}!unordered_multimap@\tcode{unordered_multimap}}%
\begin{itemdecl}
explicit unordered_multimap(size_type n = @\textit{implementation-defined}@,
                            const hasher& hf = hasher(),
                            const key_equal& eql = key_equal(),
                            const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_multimap} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Constant.
\end{itemdescr}

\index{unordered_multimap@\tcode{unordered_multimap}!unordered_multimap@\tcode{unordered_multimap}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
  unordered_multimap(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                     size_type n = @\textit{implementation-defined}@,
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_multimap} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  (If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.)  Then
inserts elements from the range \tcode{[\textit{f}, \textit{l})}.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Average case linear, worst case quadratic.
\end{itemdescr}

\rSec3[unord.multimap.swap]{\tcode{unordered_multimap} swap}

\index{unordered_multimap@\tcode{unordered_multimap}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!unordered_multimap@\tcode{unordered_multimap}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ Key, @\changedConcepts{class}{ObjectType}@ T, class Hash, class Pred, class Alloc>
  void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
            unordered_multimap<Key, T, Hash, Pred, Alloc>& y);
\end{itemdecl}


\begin{itemdescr}
\pnum\effects\ \tcode{x.swap(y)}.
\end{itemdescr}

\rSec2[unord.set]{Class template \tcode{unordered_set}}
\index{unordered_set@\tcode{unordered_set}}%

\pnum
\index{unordered_set@\tcode{unordered_set}!unique keys}%
\index{unordered associative containers!unique keys}%
An \tcode{unordered_set} is an unordered associative container that
supports unique keys (an \tcode{unordered_set} contains at most one of each
key value) and in which the elements' keys are the elements
themselves.

\pnum
An \tcode{unordered_set} satisfies all of the requirements of a container, of an unordered associative container, and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}). It provides the operations described in the preceding requirements table for unique keys; that is, an \tcode{unordered_set} supports the \tcode{a_uniq} operations in that table, not the \tcode{a_eq} operations. For an \tcode{unordered_set<Value>} the \tcode{key type} and the value type are both \tcode{Value}. The \tcode{iterator} and \tcode{const_iterator} types are both const iterator types. It is unspecified whether they are the same type.

\pnum
This section only describes operations on \tcode{unordered_set} that
are not described in one of the requirement tables, or for which there
is additional semantic information.

\index{unordered_set@\tcode{unordered_set}}%
\index{allocator}
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ Value,
            @\changedConcepts{class}{Callable<auto, Value>}@ Hash = hash<Value>,
            @\changedConcepts{class}{Predicate<auto, Value, Value>}@ class Pred = std::equal_to<Value>,
            class Alloc = std::allocator<Value> >
  @\addedConcepts{requires SameType<Hash::result_type, std::size_t>}@
           @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
  class unordered_set
  {
  public:
    // types
    typedef Value                                    key_type;
    typedef Value                                    value_type;
    typedef Hash                                     hasher;
    typedef Pred                                     key_equal;
    typedef Alloc                                    allocator_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef @\impdef@                   size_type;
    typedef @\impdef@                   difference_type;

    typedef @\impdef@                   iterator;
    typedef @\impdef@                   const_iterator;
    typedef @\impdef@                   local_iterator;
    typedef @\impdef@                   const_local_iterator;

    // construct/destroy/copy
    explicit unordered_set(size_type n = @\textit{implementation-defined}@,
                           const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      unordered_set(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                    size_type n = @\textit{implementation-defined}@,
                    const hasher& hf = hasher(),
                    const key_equal& eql = key_equal(),
                    const allocator_type& a = allocator_type());
    @\addedConcepts{requires CopyConstructible<value_type>}@ unordered_set(const unordered_set&);
    unordered_set(const Allocator&);
    @\addedConcepts{requires CopyConstructible<value_type>}@ unordered_set(const unordered_set&, const Allocator&);
    unordered_set(unordered_set&&, const Allocator&);
    ~unordered_set();
    @\addedConcepts{requires CopyConstructible<value_type> \&\& CopyAssignable<value_type>}@ 
      unordered_set& operator=(const unordered_set&);
    allocator_type get_allocator() const;

    // size and capacity
    bool empty() const;
    size_type size() const;
    size_type max_size() const;

    // iterators
    iterator       begin();
    const_iterator begin() const;
    iterator       end();
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    // modifiers
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<value_type>}@ std::pair<iterator, bool> insert(const value_type& obj);
    @\addedConcepts{requires CopyConstructible<value_type>}@ 
      iterator insert(const_iterator hint, const value_type& obj);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear();

    void swap(unordered_set&);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type count(const key_type& k) const;
    std::pair<iterator, iterator>             equal_range(const key_type& k);
    std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;  

    // hash policy
    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    @\addedConcepts{requires MoveConstructible<value_type>}@ void rehash(size_type n);
  };

  template <@\changedConcepts{class}{ObjectType}@ Value, class Hash, class Pred, class Alloc>
    void swap(unordered_set<Value, Hash, Pred, Alloc>& x,
              unordered_set<Value, Hash, Pred, Alloc>& y);

  template <class Value, class Hash, class Pred, class Alloc>
    struct constructible_with_allocator_suffix<
      map<Value, Hash, Pred, Alloc> >
        : true_type { };
}
\end{codeblock}

\rSec3[unord.set.cnstr]{\tcode{unordered_set} constructors}

\index{unordered_set@\tcode{unordered_set}!unordered_set@\tcode{unordered_set}}%
\begin{itemdecl}
explicit unordered_set(size_type n = @\textit{implementation-defined}@,
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_set} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  If \textit{\tcode{n}} is not
provided, the number of buckets is implementation
defined.  \tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Constant.
\end{itemdescr}

\index{unordered_set@\tcode{unordered_set}!unordered_set@\tcode{unordered_set}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
  unordered_set(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                size_type n = @\textit{implementation-defined}@,
                const hasher& hf = hasher(),
                const key_equal& eql = key_equal(),
                const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_set} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  (If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.)  Then
inserts elements from the range \tcode{[\textit{f}, \textit{l})}.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Average case linear, worst case quadratic.
\end{itemdescr}

\rSec3[unord.set.swap]{\tcode{unordered_set} swap}

\index{unordered_set@\tcode{unordered_set}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!unordered_set@\tcode{unordered_set}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ Value, class Hash, class Pred, class Alloc>
  void swap(unordered_set<Value, Hash, Pred, Alloc>& x,
            unordered_set<Value, Hash, Pred, Alloc>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ \tcode{x.swap(y)}.
\end{itemdescr}

\rSec2[unord.multiset]{Class template \tcode{unordered_multiset}}
\index{unordered_multiset@\tcode{unordered_multiset}}%
\index{allocator}

\pnum
\index{unordered_multiset@\tcode{unordered_multiset}!equivalent keys}%
\index{unordered associative containers!equivalent keys}%
An \tcode{unordered_multiset} is an unordered associative container
that supports equivalent keys (an \tcode{unordered_multiset} may contain
multiple copies of the same key value) and in which each element's key
is the element itself.

\pnum
An \tcode{unordered_multiset} satisfies all of the requirements of a container, of an unordered associative container, and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}). It provides the operations described in the preceding requirements table for equivalent keys; that is, an \tcode{unordered_multiset} supports the \tcode{a_eq} operations in that table, not the \tcode{a_uniq} operations. For an \tcode{unordered_multiset<Value>} the \tcode{key type} and the value type are both \tcode{Value}. The \tcode{iterator} and \tcode{const_iterator} types are both const iterator types. It is unspecified whether they are the same type.

\pnum
This section only describes operations on \tcode{unordered_multiset} that
are not described in one of the requirement tables, or for which there
is additional semantic information.

\index{unordered_multiset@\tcode{unordered_multiset}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ Value,
            @\changedConcepts{class}{Callable<auto, Value>}@ Hash = hash<Value>,
            @\changedConcepts{class}{Predicate<auto, Value, Value>}@ class Pred = std::equal_to<Value>,
            class Alloc = std::allocator<Value> >
  @\addedConcepts{requires SameType<Hash::result_type, std::size_t>}@
           @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
  class unordered_multiset
  {
  public:
    // types
    typedef Value                                    key_type;
    typedef Value                                    value_type;
    typedef Hash                                     hasher;
    typedef Pred                                     key_equal;
    typedef Alloc                                    allocator_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef @\impdef@                   size_type;
    typedef @\impdef@                   difference_type;

    typedef @\impdef@                   iterator;
    typedef @\impdef@                   const_iterator;
    typedef @\impdef@                   local_iterator;
    typedef @\impdef@                   const_local_iterator;

    // construct/destroy/copy
    explicit unordered_multiset(size_type n = @\textit{implementation-defined}@,
                                const hasher& hf = hasher(),
                                const key_equal& eql = key_equal(),
                                const allocator_type& a = allocator_type());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
      unordered_multiset(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                         size_type n = @\textit{implementation-defined}@,
                         const hasher& hf = hasher(),
                         const key_equal& eql = key_equal(),
                         const allocator_type& a = allocator_type());
    @\addedConcepts{requires CopyConstructible<value_type>}@ unordered_multiset(const unordered_multiset&);
    unordered_multiset(const Allocator&);
    @\addedConcepts{requires CopyConstructible<value_type>}@ unordered_multiset(const unordered_multiset&, const Allocator&);
    unordered_multiset(unordered_multiset&&, const Allocator&);
    ~unordered_multiset();
    @\addedConcepts{requires CopyConstructible<value_type> \&\& CopyAssignable<value_type>}@ 
      unordered_multiset& operator=(const unordered_multiset&);
    allocator_type get_allocator() const;

    // size and capacity
    bool empty() const;
    size_type size() const;
    size_type max_size() const;

    // iterators
    iterator       begin();
    const_iterator begin() const;
    iterator       end();
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    // modifiers
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<value_type, Args\&\&...>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires CopyConstructible<value_type>}@ iterator insert(const value_type& obj);
    @\addedConcepts{requires CopyConstructible<value_type>}@ 
      iterator insert(const_iterator hint, const value_type& obj);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires HasConstructor<value_type, Iter::value_type>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear();

    void swap(unordered_multiset&);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type count(const key_type& k) const;
    std::pair<iterator, iterator>             equal_range(const key_type& k);
    std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type n);
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n) const;
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;  

    // hash policy
    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    @\addedConcepts{requires MoveConstructible<value_type>}@ void rehash(size_type n);
  };

  template <@\changedConcepts{class}{ObjectType}@ Value, class Hash, class Pred, class Alloc>
    void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,
              unordered_multiset<Value, Hash, Pred, Alloc>& y);

  template <class Value, class Hash, class Pred, class Alloc>
    struct constructible_with_allocator_suffix<
      unordered_multiset<Value, Hash, Pred, Alloc> >
        : true_type { };
}
\end{codeblock}

\rSec3[unord.multiset.cnstr]{\tcode{unordered_multiset} constructors}

\index{unordered_multiset@\tcode{unordered_multiset}!unordered_multiset@\tcode{unordered_multiset}}%
\begin{itemdecl}
explicit unordered_multiset(size_type n = @\textit{implementation-defined}@,
                            const hasher& hf = hasher(),
                            const key_equal& eql = key_equal(),
                            const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_multiset} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Constant.
\end{itemdescr}

\index{unordered_multiset@\tcode{unordered_multiset}!unordered_multiset@\tcode{unordered_multiset}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<value_type, Iter::reference>}@
  unordered_multiset(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                     size_type n = @\textit{implementation-defined}@,
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ 
Constructs an empty \tcode{unordered_multiset} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  (If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.)  Then
inserts elements from the range \tcode{[\textit{f}, \textit{l})}.
\tcode{max_load_factor()} returns 1.0.

\pnum\complexity\ Average case linear, worst case quadratic.
\end{itemdescr}

\rSec3[unord.multiset.swap]{\tcode{unordered_multiset} swap}

\index{unordered_multiset@\tcode{unordered_multiset}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!unordered_multiset@\tcode{unordered_multiset}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ Value, class Hash, class Pred, class Alloc>
  void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,
            unordered_multiset<Value, Hash, Pred, Alloc>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ \tcode{x.swap(y);}
\end{itemdescr}

\index{unordered associative containers|)}

\bibliographystyle{plain}
\bibliography{local}

\end{document}