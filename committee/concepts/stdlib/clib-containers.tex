\documentclass[american,twoside]{book}
\usepackage{refbib}
\input{macros}

%%--------------------------------------------------
%% PDF

\usepackage[pdftex,
            pdftitle={Concepts for the C++0x Standard Library: Containers},
            pdfsubject={C++ International Standard Proposal},
            pdfcreator={Douglas Gregor},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}

%\usepackage{makeidx}
%\makeindex

%%--------------------------------------------------
%% Set section numbering limit, toc limit
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

%%--------------------------------------------------
%% Parameters that govern document appearance
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.6in}

\newcommand{\resetcolor}{\textcolor{addclr}{}}

%%--------------------------------------------------
%% Handle special hyphenation rules
\hyphenation{tem-plate ex-am-ple in-put-it-er-a-tor}

% Do not put blank pages after chapters that end on odd-numbered pages.
\def\cleardoublepage{\clearpage\if@twoside%
  \ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage%
  \if@twocolumn\hbox{}\newpage\fi\fi\fi}

\begin{document}
\raggedbottom

\begin{titlepage}
\begin{center}
\huge
Concepts for the C++0x Standard Library: Containers\\
(Revision 4)
\end{center}

\normalsize

\vspace{0.5in}
\par\noindent Authors: 
\begin{tabular}[t]{l}
Douglas Gregor, Indiana University \\
Mat Marcus, Adobe Systems, Inc.\\
Pablo Halpern,  Bloomberg, L.P.
\end{tabular}\vspace{-6pt}
\par\noindent Document number: D2776=08-0286\vspace{-6pt}
\par\noindent Revises document number: N2738=08-0248\vspace{-6pt}
\par\noindent Date: \today\vspace{-6pt}
\par\noindent Project: Programming Language \Cpp{}, Library Working Group\vspace{-6pt}
\par\noindent Reply-to: Douglas Gregor $<$\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}$>$\vspace{-6pt}

\section*{Introduction}
\libintrotext{Chapter 23}

\section*{Changes from N2738}
\begin{itemize}
\item Fix definition of \tcode{push_front} in the
  \tcode{FrontInsertionContainer} concept map
  (\ref{container.concepts.maps}).
\item Removed all uses of the term ``iterator category'', in favor of
  explicit mentions of iterator concept names
  (\ref{container.requirements.general}, \ref{sequence.reqmts},
  \ref{associative.reqmts}, \ref{unord.req},
  \ref{vector.cons}). Thanks to Alisdair Meredith for pointing out
  this inconsistency, and for detailed review work.
\item Fixed the \tcode{AccessBack} axiom in
  \tcode{BackInsertionContainer} and
  \tcode{MemberBackInsertionContainer}. Added an additional
  requirement to the *\tcode{Insertion} axioms that states that the
  value inserted is the value now stored at the place of
  insertion (thanks to Alisdair Meredith).
\item Convertibility requirement from \tcode{iterator} to
  \tcode{const_iterator} in the container concepts. Resolves concepts
  issue \#48. Also, added convertibility from the container's
  iterators \tcode{reference} types to its \tcode{reference} and
  \tcode{const_reference} types along with convertibility from the
  \tcode{difference_type} of a container's iterators to its
  \tcode{size_type}.
\item{Moved \tcode{front()} operations and axioms from
    \tcode{BackInsertionContainer} to \tcode{Container} and provided
    default implementation in terms of \tcode{begin}. Moved
    \tcode{pop_back()} and corresponding axioms out of
    \tcode{BackInsertionContainer} into the (new) refined concept
    \tcode{StackLikeContainer}. Moved \tcode{pop_front()} and
    corresponding axioms into the (new) refined concept
    \tcode{QueueLikeContainer()}. Similar changes were made to the
    Member versions of these concepts. Update constraints for
    \tcode{stack}, \tcode{queue}, and \tcode{priority_queue} to make
    use of these new concepts, avoiding \tcode{queue} overconstraint
    in the previous version of this document.}
\item{Removed all qualification by \tcode{std::}}
\item{Added axioms to Emplacement concepts.}
\item{Renamed \tcode{RandomAccessAllocator} to \tcode{Allocator}}
\item{Added \tcode{cbegin} and \tcode{cend} operations and default implementations to
    \tcode{Container}-related concepts}
\item The Container requirements table now states that the
  \tcode{X::iterator} and \tcode{X::const_iterator} types must meet
  the requirements of the \tcode{ForwardIterator} concept, rather than
  the \tcode{InputIterator} concept.
\item Renamed uses of \tcode{ConstructibleAsElement} to \tcode{AllocatableElement}.
\end{itemize}

\end{titlepage}

\section*{Proposed Wording}
\paragraph*{Issues resolved by concepts}
The following LWG are resolved by concepts. These issues should be
resolved as NAD following the application of this proposal to the
wording paper:
\begin{description}
\item[Issue 676. Moving the unordered containers.] Applied a
  conceptualized version of the proposed wording. This issue was voted
  into the Working Paper in Bellevue, but is not in the Working Paper
  due to some editorial problems with the proposed wording, including
  some errors in the ``hint'' versions of the \tcode{insert}
  operations and the verbosity of the specification. These errors have
  been corrected in this document.

\item[Issue 704. MoveAssignable requirement for container value type
  overly strict.] The concepts proposal for the containers specifies
  precisely which routines require \tcode{MoveAssignable} value types.
\end{description}

%%--------------------------------------------------
%% Headers and footers
\pagestyle{fancy}
\fancyhead[LE,RO]{\textbf{\rightmark}}
\fancyhead[RE]{\textbf{\leftmark\hspace{1em}\thepage}}
\fancyhead[LO]{\textbf{\thepage\hspace{1em}\leftmark}}
\fancyfoot[C]{Draft}

\fancypagestyle{plain}{
\renewcommand{\headrulewidth}{0in}
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\fancyfoot{}
}

\renewcommand{\sectionmark}[1]{\markright{\thesection\hspace{1em}#1}}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

\color{black}

\setcounter{chapter}{22}
\rSec0[containers]{Containers library}

\pnum
This clause describes components that \Cpp\ programs may use to
organize collections of information.

\pnum
The following subclauses describe
container \changedConcepts{requirements}{concepts},
and components for
sequences and
associative containers,
as summarized in
Table~\ref{tab:containers.summary}:

\begin{libsumtab}{Containers library summary}{tab:containers.summary}
\ref{container.requirements} Requirements   &                       \\
\ref{container.concepts} \addedConcepts{Concepts}   & \addedConcepts{\mbox{\tcode{<container_concepts>}}}                      \\ \rowsep
\ref{sequences} Sequences                   &   \tcode{<array>}     \\
                                                &   \tcode{<deque>}     \\
                                                &   \tcode{<list>}      \\
                                                &   \tcode{<queue>}     \\
                                                &   \tcode{<stack>}     \\
                                                &   \tcode{<vector>}    \\ \rowsep
\ref{associative} Associative containers    &   \tcode{<map>}       \\
                                                &   \tcode{<set>}       \\
\ref{template.bitset} \tcode{bitset}        &   \tcode{<bitset>}    \\ \rowsep
\ref{unord} \addedB{Unordered associative containers}&   \tcode{<unordered_map>}       \\
                                                &   \tcode{<unordered_set>}       \\
\end{libsumtab}

\rSec1[container.requirements]{Container requirements}
\index{requirements!container}%

\editorial{Unlike with other sections containing requirements tables,
  we have opted not to completely replace everything
  in~\ref{container.requirements} with a set of concepts. This
  decision is due to the unique nature of the container requirements,
  which don't really correspond to concepts because they aren't used
  in algorithms. Rather, the requirements tables in
  ~\ref{container.requirements} are shorthand descriptions for all of the
  containers in this section; each container meets some subset of the
  requirements stated, sometimes with differing requirements on the
  container's value type for the same operation. Those container
  concepts that are actually needed (e.g., for the container
  adaptors~\ref{container.adaptors}) are specified in the new
  section~\ref{container.concepts}. We have, however, removed many
  informal ``requires'' clauses from the container requirements
  tables, because they have never been complete and the same
  information is available more formally in the real requires clauses
  of the containers themselves (which appropriately account for the
  variation between containers).}

\setcounter{Paras}{2}
\pnum
Objects stored in these components shall be constructed using
\mbox{\tcode{construct_element}}~(\mbox{\ref{construct.element}})
\addedConcepts{and destroyed using the
  \mbox{\tcode{destroy}} member function of the container's
  allocator~(\mbox{\ref{allocator.concepts}})}. 
%
\addedConcepts{A container may directly call constructors and
  destructors for its stored objects, without calling the
  \mbox{\tcode{construct_element}} or \mbox{\tcode{destroy}}
  functions, if the allocator models the
  \mbox{\tcode{MinimalAllocator}} concept.}
%
\removedConcepts{For each 
operation that inserts an element of type \mbox{\tcode{T}} into a container
(\mbox{\tcode{insert}}, \mbox{\tcode{push_back}}, \mbox{\tcode{push_front}},
\mbox{\tcode{emplace}}, etc.) with arguments \mbox{\tcode{args...}}
\mbox{\tcode{T}} shall 
be \mbox{\tcode{ConstructibleAsElement}}, as described in
table~\mbox{\ref{constructibleaselement}}.} \enternote If the component is
instantiated with a scoped allocator of type \tcode{A} (i.e., an
allocator \changedConcepts{for which
  \mbox{\tcode{is_scoped_allocator<A>::value}} is 
\mbox{\tcode{true}}}{that meets the requirements of the
\mbox{\tcode{ScopedAllocator}} concept}), then
\mbox{\tcode{construct_element}}
may pass an inner 
allocator argument to \tcode{T}'s constructor. \exitnote

\pnum
\removedConcepts{In table~\mbox{\ref{constructibleaselement}},
  \mbox{\tcode{T}} denotes an object type, \mbox{\tcode{A}} denotes an
  allocator, \mbox{\tcode{I}} denotes an allocator of type
  \mbox{\tcode{A::inner_allocator_type}} (if any),and
  \mbox{\tcode{Args}} denotes a template parameter pack}

\editorial{Remove Table 89: \mbox{\tcode{ConstructibleAsElement<A, T,
      Args>}} requirements}

\setcounter{Paras}{4}
\pnum
In Tables~\ref{tab:containers.container.requirements} and
\ref{tab:containers.reversible.requirements}, \tcode{X}\
denotes a container class containing objects of type
\tcode{T}, \tcode{a}\ and \tcode{b}
denote values of type \tcode{X}, \tcode{u}\
denotes an identifier, \tcode{r}\ denotes
an lvalue or a const rvalue of type \tcode{X}, and \tcode{rv}
denotes a non-const rvalue of type \tcode{X}.

\setcounter{table}{89}

\begin{libreqtab5}
{Container requirements}
{tab:containers.container.requirements}
\\ \topline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{operational}  &
\chdr{assertion/note}   &   \rhdr{complexity}   \\
    &   &   \chdr{semantics}    &   \chdr{pre/post-condition}   &       \\ \capsep
\endfirsthead
\topline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{operational}  &
\chdr{assertion/note}   &   \rhdr{complexity}   \\
    &   &   \chdr{semantics}    &   \chdr{pre/post-condition}   &       \\ \capsep
\endhead

\tcode{X::value_type}       &
 \tcode{T}                  &
                            &
                            &
 compile time               \\ \rowsep

\tcode{X::reference}        &
 lvalue of \tcode{T}        &
                            &
                            &
 compile time               \\ \rowsep

\tcode{X::const_reference} &
 const lvalue of \tcode{T}  &
                            &
                            &
 compile time               \\ \rowsep

\tcode{X::iterator}         &
 iterator type whose value type is \tcode{T} &
                            &
 \changedConcepts{any iterator category except output iterator}{meets the requirements of the \mbox{\tcode{ForwardIterator}} concept}.
 convertible to \tcode{X::const_iterator}. &
 compile time               \\ \rowsep

\tcode{X::const_iterator}  &   
 constant iterator type whose value type is \tcode{T} &
                            &
\changedConcepts{any iterator category except output iterator}{meets the requirements of the \mbox{\tcode{ForwardIterator}} concept} &
 compile time               \\ \rowsep

\tcode{X::dif\-ference_type}   &
 signed integral type           &
                                &
 is identical to the difference type of \tcode{X::iterator}\ and \tcode{X::const_iterator} &
 compile time               \\ \rowsep

\tcode{X::size_type}       &
 unsigned integral type     &
                            &
 \tcode{size_type} can represent any non-negative value of \tcode{difference_type} &
 compile time                \\ \rowsep

\tcode{X u;}                &
                            &
                            &
 post: \tcode{u.size() == 0}&
 constant                   \\ \rowsep

\tcode{X();}                &
                            &
                            &
 \tcode{X().size() == 0}    &
 constant                   \\ \rowsep

\tcode{X(a);}               &
                            &
                            &
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} is \mbox{\tcode{CopyConstructible}}.} post: \tcode{a == X(a)}.         &
 linear                     \\ \rowsep

\tcode{X u(a);}             &
                            &
                            &
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} is \mbox{\tcode{CopyConstructible}}.}       &
 linear                     \\
\tcode{X u = a;}            &
                            &
                            &
 post: \tcode{u == a}       &
                            \\ \rowsep

\tcode{X u(rv);} &
                            &
                            &
	\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} is \mbox{\tcode{MoveConstructible}}.}													&
(Note B)           \\
\tcode{X u = rv;} &
                            &
                            &
 post: \tcode{u} shall be equal to the value that \tcode{rv} had before this construction   
                            &
                            \\ \rowsep

\tcode{a = rv;} &
\tcode{X\&} &
All existing elements of \tcode{a} are either move assigned or destroyed                  &
\tcode{a} shall be equal to the value that \tcode{rv}
had before this construction   &
 (Note C)           \\ \rowsep
\tcode{(\&a)->$\sim$X();}   &
 \tcode{void}               &
                            &
 note: the destructor is applied to every element of \tcode{a}; all the memory is deallocated. &
 linear                     \\ \rowsep

\tcode{a.begin();}          &
 \tcode{iterator}; \tcode{const_iterator}\ for constant \tcode{a} &
                            &
                            &
 constant                   \\ \rowsep

\tcode{a.end();}            &
 \tcode{iterator}; \tcode{const_iterator}\ for constant \tcode{a} &
                            &
                            &
 constant                   \\ \rowsep

\tcode{a.cbegin();}         &
 \tcode{const_iterator}     &
 \tcode{const_cast<X const\&>(a).begin();} &
                            &
 constant                   \\ \rowsep

\tcode{a.cend();}         &
 \tcode{const_iterator}     &
 \tcode{const_cast<X const\&>(a).end();} &
                            &
 constant                   \\ \rowsep

\tcode{a == b}                  &
 convertible to \tcode{bool}    &
                                &
 \tcode{==}\ is an equivalence relation.
 \tcode{a.size() == b.size()}
 \tcode{\&\& equal(a.begin(),}
 \tcode{a.end(), b.begin())}     &
 linear                         \\ \rowsep

\tcode{a != b}                      &
 convertible to \tcode{bool}        &
                                    &
 Equivalent to: \tcode{!(a == b)}   &
 linear                             \\ \rowsep

\tcode{a.swap(b)};          &
 \tcode{void}               &
                            &
 \tcode{swap(a,b)}          &
 (Note A)                   \\ \rowsep

\tcode{r = a}               &
 \tcode{X\&}                &
                            &
 post: \tcode{r == a}.      &
 linear                     \\ \rowsep

\tcode{a.size()}                &
 \tcode{size_type}             &
 \tcode{a.end() $-$ a.begin()}  &
                                &
 (Note A)                       \\ \rowsep

\tcode{a.max_size()}        &
 \tcode{size_type}         &
 \tcode{size()}\ of the largest possible container &
                            &
 (Note A)                   \\ \rowsep

\tcode{a.empty()}               &
 convertible to \tcode{bool}    &
 \tcode{a.size() == 0}          &
                                &
constant                        \\ \rowsep

\resetcolor{}\tcode{a < b}                   &
 convertible to \tcode{bool}    &
 \tcode{lexico\-graphical_compare( a.begin(), a.end(), b.begin(), b.end())} &
 pre: \tcode{<}\ is defined for values of \tcode{T}. \tcode{<} is a total ordering relationship.    &
 linear                     \\ \rowsep

\tcode{a > b}                   &
 convertible to \tcode{bool}    &
 \tcode{b < a}                  &
                                &
 linear                         \\ \rowsep

\tcode{a <= b}                  &
 convertible to \tcode{bool}    &
 \tcode{!(a > b)}               &
                                &
 linear                         \\ \rowsep

\tcode{a >= b}                  &
 convertible to \tcode{bool}    &
 \tcode{!(a < b)}               &
                                &
 linear                         \\
\end{libreqtab5}

\setcounter{Paras}{10}
\pnum
If the iterator type of a container \changedConcepts{belongs to the
  bidirectional or random access iterator categories (24.1)}{meets the
  requirements of the \mbox{\tcode{BidirectionalIterator}} concept}, 
the container is called reversible and satisfies the additional
requirements in Table 91. 

\rSec2[sequence.reqmts]{Sequence containers}
\setcounter{Paras}{3}
\pnum
The complexities of the expressions are sequence dependent.

\setcounter{table}{92}

\begin{libreqtab3}
{Sequence container requirements (in addition to container)}
{tab:containers.sequence.requirements}
\\ \topline
\lhdr{expression}       &   \chdr{return type}  &   \rhdr{assertion/note}       \\
                        &                       &   \rhdr{pre/post-condition}   \\ \capsep
\endfirsthead
\hline
\lhdr{expression}       &   \chdr{return type}  &   \rhdr{assertion/note}       \\
                        &                       &   \rhdr{pre/post-condition}   \\ \capsep
\endhead
\tcode{X(n, t)}\br
\tcode{X a(n, t)}   &
                &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}\br
 post: \tcode{size() == n}\br
 Constructs a sequence container with \tcode{n}\ copies of \tcode{t}  \\ \rowsep
\tcode{X(i, j)}\br
\tcode{X a(i, j)}   &
                    &
\mbox{\requires} \removedConcepts{If the iterator's dereference operation returns an
 lvalue or a const rvalue, \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}
 Each iterator in the range \range{i}{j} shall be dereferenced exactly once.\br
 post: \tcode{size() == distance}\ between \tcode{i}\ and \tcode{j}\br
 Constructs a sequence container equal to the range \tcode{[i, j)}    \\ \rowsep
\tcode{X(il)} &
   &
Equivalent to \tcode{X(il.begin(), il.end())} \\ \rowsep
\tcode{a = il} &
\tcode{X\&}    &
\tcode{a = il;}\br
\tcode{return *this;} \\ \rowsep
\tcode{a.emplace(p, args)}  &
 \tcode{iterator}            &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{T, Args>}}.}
 Inserts an object of type \tcode{T} constructed with
 \tcode{std::forward<Args>(args)...}.   \\ \rowsep

\tcode{a.insert(p,t)}   &
 \tcode{iterator}       &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{T, T>}}
 and \mbox{\tcode{T}} shall be \mbox{\tcode{CopyAssignable}}.}\br
 Inserts a copy of \tcode{t}\ before \tcode{p}. \\ \rowsep

\tcode{a.insert(p,rv)}   &
 \tcode{iterator}       &
\removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{T, T\&\&>}} and \mbox{\tcode{T}} shall be \mbox{\tcode{MoveAssignable}}.}
 Inserts a copy of \tcode{rv} before \tcode{p}. \\ \rowsep

\tcode{a.insert(p,n,t)}     &
 \tcode{void}               &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}
 and \mbox{\tcode{CopyAssignable}}.}\br
 Inserts \tcode{n}\ copies of \tcode{t}\ before \tcode{p}. \\ \rowsep

\tcode{a.insert(p,i,j)}    &
 \tcode{void}           &
\removedConcepts{\mbox{\requires} If the iterator's dereference operation returns an
 lvalue or a const rvalue, \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}
 Each iterator in the range \range{i}{j} shall be dereferenced exactly once.\br
 pre: \tcode{i}\ and \tcode{j}\ are not iterators into \tcode{a}.\br
 Inserts copies of elements in \tcode{[i, j)} before \tcode{p}  \\ \rowsep

\tcode{a.insert(p, il)} &
\tcode{void}            &
\tcode{a.insert(p, il.begin(), il.end())} \\ \rowsep

\tcode{a.erase(q)}  &
 \tcode{iterator}   &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{MoveAssignable}}.}
 Erases the element pointed to by \tcode{q} \\ \rowsep

\tcode{a.erase(q1,q2)}  &
 \tcode{iterator}   &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{MoveAssignable}}.}
 Erases the elements in the range \tcode{[q1, q2)}.  \\ \rowsep

\tcode{a.clear()}   &
 \tcode{void}       &
 \tcode{erase(begin(), end())}\br
 post: \tcode{size() == 0}      \\ \rowsep

\tcode{a.assign(i,j)}   &
 \tcode{void}           &
 \requires \removedConcepts{If the iterator's dereference operation returns an
 lvalue or a const rvalue, \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}
 and \mbox{\tcode{CopyAssignable}}.}
 Each iterator in the range \range{i}{j} shall be dereferenced exactly once.\br
 pre: \tcode{i}, \tcode{j}\ are not iterators into \tcode{a}.\br
 Replaces elements in \tcode{a}\ with a copy of \tcode{[i, j)}. \\ \rowsep

\tcode{a.assign(il)}    &
\tcode{void}            &
\tcode{a.assign(il.begin(), il.end())} \\ \rowsep

\tcode{a.assign(n,t)}   &
 \tcode{void}           &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}
 and \mbox{\tcode{CopyAssignable}}.}\br
 pre: \tcode{t}\ is not a reference into \tcode{a}.\br
 Replaces elements in \tcode{a}\ with \tcode{n}\ copies of \tcode{t}.   \\
\end{libreqtab3}

\setcounter{Paras}{4}
\pnum
\tcode{iterator} and \tcode{const_iterator} types for sequence
containers shall \changedConcepts{be at least of the forward iterator
  category}{meet the requirements of the
  \mbox{\tcode{ForwardIterator}} concept}. 

\setcounter{Paras}{11}

\pnum
Table~\ref{tab:containers.sequence.optional} lists operations
that are provided for some types of
sequence containers but not others.
An implementation shall provide
these operations for all container types shown in the ``container''
column, and shall implement them so as to take amortized constant
time.

\begin{libreqtab4a}
{Optional sequence container operations}
{tab:containers.sequence.optional}
\\ \topline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{assertion/note}       &   \rhdr{container}    \\
                        &                       &   \chdr{pre/post-condition}   &                       \\ \capsep
\endfirsthead
\hline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{assertion/note}       &   \rhdr{container}    \\
                        &                       &   \chdr{pre/post-condition}   &                       \\ \capsep
\endhead

\tcode{a.front()}       &
 \tcode{reference; const_reference}\ for constant \tcode{a}    &
 \tcode{*a.begin()}     &
 \tcode{vector}, \tcode{list}, \tcode{deque}, \tcode{basic_string}\\ \rowsep

\tcode{a.back()}        &
 \tcode{reference; const_reference}\ for constant \tcode{a}    &
 \tcode{\{ iterator tmp = a.end();}\br
 \tcode{    \dcr tmp;}\br
 \tcode{    return *tmp; \}}    &
 \tcode{vector}, \tcode{list}, \tcode{deque}, \tcode{basic_string}\\ \rowsep

\tcode{a.emplace_-} \tcode{front(args)}      &
 \tcode{void}                &
 \tcode{a.emplace(a.begin(),} \tcode{std::forward<Args>(args)...)}
 \removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{T, Args>}}}    &
 \tcode{list}, \tcode{deque}  \\ \rowsep

\tcode{a.emplace_-} \tcode{back(args)}      &
 \tcode{void}                &
 \tcode{a.emplace(a.end(),} \tcode{std::forward<Args>(args)...)}
 \removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{T, Args>}}}    &
 \tcode{list}, \tcode{deque}, \tcode{vector}  \\ \rowsep

\tcode{a.push_-} \tcode{front(t)}      &
\tcode{void}                           &
\tcode{a.insert(a.begin(), t)}\br
\removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{T, T>}} and \mbox{\tcode{T}} shall be \mbox{\tcode{CopyAssignable}}.} & 
\tcode{list}, \tcode{deque} \\ \rowsep

\tcode{a.push_-} \tcode{front(rv)}      &
\tcode{void}                           &
\tcode{a.insert(a.begin(), rv)}\br
\removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{T, T\&\&>}} and \mbox{\tcode{T}} shall be \mbox{\tcode{MoveAssignable}}.} & 
\tcode{list}, \tcode{deque} \\ \rowsep

\tcode{a.push_-} \tcode{back(t)}      &
\tcode{void}                           &
\tcode{a.insert(a.end(), t)}\br
\removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{T, T>}} and \mbox{\tcode{T}} shall be \mbox{\tcode{CopyAssignable}}.} & 
\tcode{vector}, \tcode{list}, \tcode{deque}, \tcode{basic_string} \\ \rowsep

\tcode{a.push_-} \tcode{back(rv)}      &
\tcode{void}                           &
\tcode{a.insert(a.end(), rv)}\br
\removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{T, T\&\&>}} and \mbox{\tcode{T}} shall be \mbox{\tcode{MoveAssignable}}.} & 
\tcode{vector}, \tcode{list}, \tcode{deque}, \tcode{basic_string} \\ \rowsep

\tcode{a.pop_front()}      &
 \tcode{void}               &
 \tcode{a.erase(a.begin())} &
 \tcode{list}, \tcode{deque}    \\ \rowsep

\tcode{a.pop_back()}       &
 \tcode{void}               &
 \tcode{\{ iterator tmp = a.end();}\br
 \tcode{    \dcr tmp;}\br
 \tcode{    a.erase(tmp); \}}   &
 \tcode{vector}, \tcode{list}, \tcode{deque}, \tcode{basic_string}\\ \rowsep

\tcode{a[n]}                &
 \tcode{reference; const_reference}\ for constant \tcode{a}    &
 \tcode{*(a.begin() + n)}   &
 \tcode{vector}, \tcode{deque}, \tcode{basic_string}, \tcode{match_results}\\ \rowsep

\tcode{a.at(n)}             &
 \tcode{reference; const_reference}\ for constant \tcode{a}    &
 \tcode{*(a.begin() + n)}   &
 \tcode{vector}, \tcode{deque}      \\

\end{libreqtab4a}

\rSec2[associative.reqmts]{Associative containers}
\setcounter{Paras}{5}
\pnum
\tcode{iterator} of an associative container \changedConcepts{is of
  the bidirectional iterator category}{meets the requirements of the
  \mbox{\tcode{BidirectionalIterator}} concept}. For associative
containers where 
the value type is the same as the key type, both \tcode{iterator} and
\tcode{const_iterator} are constant iterators. It 
is unspecified whether or not \tcode{iterator} and
\tcode{const_iterator} are the same type. 

\pnum
In Table~\ref{tab:containers.associative.requirements},
\tcode{X}\ denotes an associative container class,
\tcode{a}\ denotes a value of \tcode{X},
\tcode{a_uniq}\ denotes a value of \tcode{X}\
when \tcode{X}\ supports unique keys,
\tcode{a_eq}\ denotes a value of \tcode{X}\
when \tcode{X}\ supports multiple keys,
\tcode{u} denotes an identifier, \tcode{r} denotes an lvalue or a const rvalue of type \tcode{X}, \tcode{rv} denotes a non-const rvalue of type \tcode{X},
\tcode{i}\ and \tcode{j}\
satisfy input iterator requirements and refer to elements
implicitly convertible to
\tcode{value_type}, \range{i}{j}\
denotes a valid range,
\tcode{p}\ denotes a valid const iterator to \tcode{a},
\tcode{q}\ denotes a valid dereferenceable const iterator to \tcode{a},
\tcode{[q1, q2)}\ denotes a valid range of const iterators in \tcode{a},
\tcode{t}\ denotes a value of \tcode{X::value_type},
\tcode{k} denotes a value of \tcode{X::key_type}\
and \tcode{c}\ denotes a value of type \tcode{X::key_compare}.
\tcode{A} denotes the storage allocator used by \tcode{X}, if any, or \tcode{std::allocator<X::value_type>} otherwise, and \tcode{m} denotes an allocator of a type convertible to \tcode{A}.

\begin{libreqtab4b}
{Associative container requirements (in addition to container)}
{tab:containers.associative.requirements}
\\ \topline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{assertion/note}       &   \rhdr{complexity}   \\
                        &                       &   \chdr{pre/post-condition}   &                       \\ \capsep
\endfirsthead
\hline
\lhdr{expression}       &   \chdr{return type}  &   \chdr{assertion/note}       &   \rhdr{complexity}   \\
                        &                       &   \chdr{pre/post-condition}   &                       \\ \capsep
\endhead

\tcode{X::key_type}    &
 \tcode{Key}            &
 \removedConcepts{\mbox{\tcode{Key}} is \mbox{\tcode{CopyConstructible}} and \mbox{\tcode{CopyAssignable}}}  &
  compile time \\ \rowsep

\tcode{X::key_compare} &   \tcode{Compare} &   defaults to 
 \tcode{less<key_type>} &   compile time   \\ \rowsep

\tcode{X::value_compare}           &
 a binary predicate type           &
 is the same as \tcode{key_compare}\ for \tcode{set}\ and
 \tcode{multiset}; is an ordering relation on pairs induced by the
 first component (\textit{i.e.} \tcode{Key}) for \tcode{map}\ and \tcode{multimap}. &
 compile time                       \\ \rowsep

\tcode{X(c)}\br
\tcode{X a(c);}                         &
                                        &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{key_compare, key_compare>}}.}
 Constructs an empty container.\br
 Uses a copy of \tcode{c} as a comparison object.  &
 constant                               \\ \rowsep

\tcode{X()}\br\tcode{X a;}                      &
                                                &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{key_compare, key_compare>}}.}
 Constructs an empty container.\br
 Uses \tcode{Compare()} as a comparison object  &
 constant                                       \\ \rowsep

\tcode{X(i,j,c)}\br
\tcode{X~a(i,j,c);}     &
                        &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{key_compare, key_compare>}}.}
 Constructs an empty container and inserts elements from the
 range \tcode{[i, j)}\ into it; uses \tcode{c}\ as a comparison object. &
 $N \log N$ in general ($N$ is the distance from \tcode{i}\ to \tcode{j});
 linear if \tcode{[i, j)}\ is sorted with \tcode{value_comp()} \\ \rowsep

\tcode{X(i,j)} \tcode{X~a(i,j);}    &
                                    &
 \removedConcepts{\mbox{\requires} \mbox{\tcode{ConstructibleAsElement<A,}} \mbox{\tcode{key_compare, key_compare>}}.}
 Same as above, but uses \tcode{Compare()}\ as a comparison object  &
 same as above                      \\ \rowsep
\multicolumn{4}{c}{\editorial{No additional changes to this table.}} \\ \rowsep
\end{libreqtab4b}

\rSec2[unord.req]{Unordered associative containers}
\setcounter{Paras}{8}
\setcounter{table}{95}
\pnum
\index{unordered associative containers}%
\index{unordered associative containers!requirements}%
\index{requirements!Unordered Associative Container}%
\index{unordered associative containers!unique keys}%
\index{unordered associative containers!equivalent keys}%
\index{requirements!Container}%
In table~\ref{tab:HashRequirements}: 
\tcode{X} is an unordered associative container class, \tcode{a} is an
object of type \tcode{X}, \tcode{b} is a possibly const object of
type \tcode{X}, \tcode{a_uniq} is an object of type \tcode{X}
when \tcode{X} supports unique keys, \tcode{a_eq} is an object of
type \tcode{X} when \tcode{X} supports equivalent keys, \tcode{i}
and \tcode{j} are input iterators that refer
to \tcode{value_type}, \tcode{[i, j)} is a valid range,
\tcode{p} and \tcode{q2} are valid const iterators to \tcode{a},
\tcode{q} and \tcode{q1} are valid dereferenceable const iterators to \tcode{a},
\tcode{[q1, q2)} is a valid range in \tcode{a},
\tcode{t} is a value of
type \tcode{X::value_type}, \tcode{k} is a value of
type \tcode{key_type}, \tcode{hf} is a possibly const value of
type \tcode{hasher}, \tcode{eq} is a possibly const value of
type \tcode{key_equal}, \tcode{n} is a value of
type \tcode{size_type}, and \tcode{z} is a value of
type \tcode{float}. 

\begin{libreqtab4d}
  {Unordered associative container requirements (in addition to container)}
  {tab:HashRequirements}
\\ \topline
\lhdr{expression} & \chdr{return type}
& \chdr{assertion/note pre/post-condition}
& \rhdr{complexity} \\ \capsep
\endfirsthead
\hline
\lhdr{expression} & \chdr{return type} & \chdr{assertion/note pre/post-condition} & \rhdr{complexity} \\ \capsep
\endhead
%%
\tcode{X::key_type}
&   \tcode{Key}
&   \removedConcepts{\mbox{\tcode{Key}} shall be \mbox{\tcode{CopyAssignable}} and \mbox{\tcode{CopyConstructible}}}
    \index{unordered associative containers!key_type@\tcode{key_type}}%
    \index{key_type@\tcode{key_type}!unordered associative containers}%
&   compile time
\\ \rowsep
%
\tcode{X::hasher}
&   \tcode{Hash}
&   \removedConcepts{\mbox{\tcode{Hash}} shall be a unary function object type such that the expression 
    \mbox{\tcode{hf(k)}} has type \mbox{\tcode{std::size_t}}.}
    \index{unordered associative containers!hasher@\tcode{hasher}}%
    \index{hasher@\tcode{hasher}!unordered associative containers}%
&   compile time
\\ \rowsep
%
\tcode{X::key_equal}
&   \tcode{Pred}
&   \removedConcepts{\mbox{\tcode{Pred}} shall be a binary predicate that takes two arguments
    of type \mbox{\tcode{Key}}.}  \tcode{Pred} is an equivalence relation.%
    \index{unordered associative containers!key_equal@\tcode{key_equal}}%
    \index{key_equal@\tcode{key_equal}!unordered associative containers}%
&   compile time
\\ \rowsep
\multicolumn{4}{c}{\editorial{No additional changes to this table.}} \\ \rowsep
\end{libreqtab4d}

\setcounter{Paras}{10}
\pnum
The iterator types \tcode{iterator} and \tcode{const_iterator} of an unordered associative container \changedConcepts{are of at least the 
forward iterator category}{meet the requirements of the
\mbox{\tcode{ForwardIterator}} concept}. For unordered associative containers where the key type and value type are the 
same, both \tcode{iterator} and \tcode{const_iterator} are const\addedConcepts{ant} iterators. 

\editorial{Add the following new section [container.concepts]}
\color{addclr}
\rSec2[container.concepts]{Container concepts}
\pnum
\addedConcepts{The \mbox{\tcode{container_concepts}} header describes
  requirements on the template arguments used in container
  adaptors. It contains two sets of container concepts, one that uses
non-member functions (\mbox{\ref{container.concepts.free}}) and the
other that uses
member functions (\mbox{\ref{container.concepts.member}}). A set
of concept map templates (\mbox{\ref{container.concepts.maps}}) adapts
the member-function syntax (the way most containers are implemented)
to free-function syntax (which is used by most generic functions,
because of its flexibility).}

\synopsis{Header \tcode{<container_concepts>} synopsis}
\begin{codeblock}
namespace std {
  // \ref{container.concepts.free}, container concepts
  concept Container<typename C> @\textit{see below}@
  concept FrontInsertionContainer<typename C> @\textit{see below}@
  concept BackInsertionContainer<typename C> @\textit{see below}@
  concept StackLikeContainer<typename C> @\textit{see below}@
  concept QueueLikeContainer<typename C> @\textit{see below}@
  concept InsertionContainer<typename C> @\textit{see below}@
  concept RangeInsertionContainer<typename C, typename Iter> @\textit{see below}@
  concept FrontEmplacementContainer<typename C, typename... Args> @\textit{see below}@
  concept BackEmplacementContainer<typename C, typename... Args> @\textit{see below}@
  concept EmplacementContainer<typename C, typename... Args> @\textit{see below}@

  // \ref{container.concepts.member}, member container concepts
  auto concept MemberContainer<typename C> @\textit{see below}@
  auto concept MemberFrontInsertionContainer<typename C> @\textit{see below}@
  auto concept MemberBackInsertionContainer<typename C> @\textit{see below}@
  auto concept MemberStackLikeContainer<typename C> @\textit{see below}@
  auto concept MemberQueueLikeContainer<typename C> @\textit{see below}@
  auto concept MemberInsertionContainer<typename C> @\textit{see below}@
  auto concept MemberRangeInsertionContainer<typename C, typename Iter> @\textit{see below}@
  auto concept MemberFrontEmplacementContainer<typename C, typename... Args> @\textit{see below}@
  auto concept MemberBackEmplacementContainer<typename C, typename... Args> @\textit{see below}@
  auto concept MemberEmplacementContainer<typename C, typename... Args> @\textit{see below}@

  // \mbox{\ref{container.concepts.maps}}, container concept maps
  template <MemberContainer C>              concept_map Container<C> @\textit{see below}@
  template <MemberFrontInsertionContainer C> concept_map FrontInsertionContainer<C> @\textit{see below}@
  template <MemberBackInsertionContainer C>  concept_map BackInsertionContainer<C> @\textit{see below}@
  template <MemberStackLikeContainer C>  concept_map StackLikeContainer<C> @\textit{see below}@
  template <MemberQueueLikeContainer C>  concept_map QueueLikeContainer<C> @\textit{see below}@
  template <MemberInsertionContainer C>      concept_map InsertionContainer<C> @\textit{see below}@
  template <MemberRangeInsertionContainer C, InputIterator Iter>
    concept_map RangeInsertionContainer<C, Iter> @\textit{see below}@
  template <MemberFrontEmplacementContainer C, typename... Args> 
    concept_map FrontEmplacementContainer<C, Args...> @\textit{see below}@
  template <MemberBackEmplacementContainer C, typename... Args>  
    concept_map BackEmplacementContainer<C, Args...> @\textit{see below}@
  template <MemberEmplacementContainer C, typename... Args>
    concept_map EmplacementContainer<C, Args...> @\textit{see below}@
  template <typename E, size_t N>           concept_map Container<E[N]> @\textit{see below}@
  template <typename E, size_t N>           concept_map Container<const E[N]> @\textit{see below}@
}
\end{codeblock}

\rSec3[container.concepts.free]{Free function container concepts}

\pnum
\addedConcepts{This section contains the container concepts that are used by
  other parts of the library. These concepts are written in terms of
  free functions. For backward compatibility, member function versions and 
concept maps adapting member to free syntax follow in
(\mbox{\ref{container.concepts.member}}) and (\mbox{\ref{container.concepts.maps}}).}

\begin{itemdecl}
concept Container<typename C> {
  ObjectType           value_type      = typename C::value_type;
  typename             reference       = typename C::reference;
  typename             const_reference = typename C::const_reference;
  UnsignedIntegralLike size_type       = typename C::size_type;

  ForwardIterator iterator;
  ForwardIterator const_iterator;

  requires Convertible<reference, const_reference>
        && Convertible<reference, const value_type&>
        && Convertible<const_reference, const _value_type&>;
        && Convertible<iterator, const_iterator>
        && SameType<ForwardIterator<iterator>::value_type, value_type> 
        && SameType<ForwardIterator<const_iterator>::value_type, value_type>
        && Convertible<ForwardIterator<iterator>::reference, reference>
        && Convertible<ForwardIterator<const_iterator>::reference, const_reference>
        && SameType<ForwardIterator<iterator>::difference_type,
                    ForwardIterator<const_iterator>::difference_type>
        && IntegralType<size_type>
        && Convertible<ForwardIterator<iterator>::difference_type, size_type>;

  bool            empty(const C& c) { return begin(c) == end(c); }
  size_type       size(const C& c)  { return distance(begin(c), end(c)); }

  iterator        begin(C&);
  const_iterator  begin(const C&);
  iterator        end(C&);
  const_iterator  end(const C&);
  const_iterator  cbegin(const C& c) { return begin(c); }
  const_iterator  cend(const C& c)   { return end(c); }
  reference       front(C& c) { return *begin(c); } 
  const_reference front(const C& c) { return *begin(c); }

  axiom AccessFront(C c) {
    if (begin(c) != end(c)) front(c) == *begin(c);
  }  

  axiom ContainerSize(C c) {
    (begin(c) == end(c)) == empty(c);
    (begin(c) != end(c)) == (size(c) > 0);
  }
}

\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container, which provides
  iteration through a sequence of elements stored in the container.}

\pnum
\addedConcepts{\mbox{\requires} for a (possibly 
  \mbox{\tcode{const}}-qualified) container \mbox{\tcode{c}},
  \mbox{\tcode{[begin(c), end(c))}} is a valid range.}

\end{itemdescr}

\begin{itemdecl}
concept FrontInsertionContainer<typename C> : Container<C> {
  void push_front(C&, value_type&&);

  axiom FrontInsertion(C c, value_type x) {
    x == (push_front(c, x), front(c));
  }
}
\end{itemdecl}


\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container that can be
  modified by adding elements to the front of the
  sequence.}
\end{itemdescr}

\begin{itemdecl}
concept BackInsertionContainer<typename C> : Container<C> {
  reference       back(C&);
  const_reference back(const C&);

  void push_back(C&, value_type&&);

  requires BidirectionalIterator<iterator> axiom AccessBack(C c) {
    if (begin(c) != end(c)) back(c) == *(--end(c));
  }

  axiom BackInsertion(C c, value_type x) {
    x == (push_back(c, x), back(c));
  }
}
\end{itemdecl}


\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container that can be
  modified by adding to the back of the
  sequence.}
\end{itemdescr}


\begin{itemdecl}
concept StackLikeContainer<typename C> : BackInsertionContainer<C> {
  void pop_back(C&);

  axiom BackRemoval(C c, value_type x) {
    c == (push_back(c, x), pop_back(c), c);
  }
}
\end{itemdecl}


\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container that can be
  modified by adding or removing elements from the back of the
  sequence.}
\end{itemdescr}


\begin{itemdecl}
concept QueueLikeContainer<typename C> : BackInsertionContainer<C> {
  void pop_front(C&);
}
\end{itemdecl}


\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container that can be
  modified by adding elements to the back or removing elements from the front of the
  sequence.}
\end{itemdescr}

\begin{itemdecl}
concept InsertionContainer<typename C> : Container<C> {
  iterator insert(C&, const_iterator, value_type&&);

  axiom Insertion(C c, const_iterator position, value_type v) {
    v == *insert(c, position, v);
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container that can be
  modified by inserting elements at any position within the sequence.}
\end{itemdescr}

\begin{itemdecl}
concept RangeInsertionContainer<typename C, typename Iter> : InsertionContainer<C> {
  requires InputIterator<Iter>;
  void insert(C&, const_iterator position, Iter first, Iter last);
}
\end{itemdecl}

\begin{itemdescr}
  \pnum \addedConcepts{\mbox{\reallynote} describes a container that
    can be modified by inserting a sequence of elements at any
    position within the sequence.}
\end{itemdescr}

\begin{itemdecl}
concept FrontEmplacementContainer<typename C, typename... Args> : Container<C> {
  void emplace_front(C& c, Args&&... args);

  reqiures Constructible<value_type, Args...>
    axiom FrontEmplacement(C c, Args... args) {
      value_type(args...) == (emplace_front(c, args...), front(c));
    }

  requires FrontInsertionContainer<C> && Constructible<value_type, Args...> 
    axiom FrontEmplacementPushEquivalence(C c, Args... args) {
      (emplace_front(c, args...), front(c)) == (push_front(c, value_type(args...)), front(c));
    }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container that can be
  modified by constructing elements at the front of the sequence.} 
\end{itemdescr}

\begin{itemdecl}
concept BackEmplacementContainer<typename C, typename... Args> : Container<C> {
  void emplace_back(C& c, Args&&... args);

  requires Constructible<value_type, Args...>
    axiom BackEmplacement(C c, Args... args) {
      value_type(args...) == (emplace_back(c, args...), back(c));
    }

  requires BackInsertionContainer<C> && Constructible<value_type, Args...>
    axiom BackEmplacementPushEquivalence(C c, Args... args) {
      (emplace_back(c, args...), back(c)) == (push_back(c, value_type(args...)), back(c));
    }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container that can be
  modified by constructing elements at the back of the sequence.} 
\end{itemdescr}

\begin{itemdecl}
concept EmplacementContainer<typename C, typename... Args> : Container<C> {
  iterator emplace(C& c, const_iterator position, Args&&... args);

  requires Constructible<value_type, Args...>
    axiom Emplacement(C c, const_iterator position, Args... args) {
      value_type(args...) == *emplace(c, position, args...);
    }

  requires InsertionContainer<C> && Constructible<value_type, Args...> 
    axiom EmplacementPushEquivalence(C c, const_iterator position, Args... args) {
      *emplace(c, position, args...) == *insert(c, position, value_type(args...));
    }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container that can be
  modified by constructing elements at any position within 
  the sequence.}
\end{itemdescr}

\rSec3[container.concepts.member]{Member container concepts} 

\pnum 
\addedConcepts{This section contains backward compatibility concepts,
  written using member function syntax, corresponding to the container
  concepts (\mbox{\ref{container.concepts.free}}). Concept maps
  that automatically adapt these member function concepts to the free
  function concept syntax follow 
  (\mbox{\ref{container.concepts.maps}}).}

\color{addclr}
\begin{itemdecl}
auto concept MemberContainer<typename C> {
  ObjectType           value_type      = typename C::value_type;
  typename             reference       = typename C::reference;
  typename             const_reference = typename C::const_reference;
  UnsignedIntegralLike size_type       = typename C::size_type;

  ForwardIterator iterator;
  ForwardIterator const_iterator;

  requires Convertible<reference, const_reference>
        && Convertible<reference, const value_type&>
        && Convertible<const_reference, const value_type&>;
        && Convertible<iterator, const_iterator>
        && SameType<ForwardIterator<iterator>::value_type, value_type> 
        && SameType<ForwardIterator<const_iterator>::value_type, value_type>
        && Convertible<ForwardIterator<iterator>::reference, reference>
        && Convertible<ForwardIterator<const_iterator>::reference, const_reference>
        && SameType<ForwardIterator<iterator>::difference_type,
                    ForwardIterator<const_iterator>::difference_type>
        && IntegralType<size_type>
        && Convertible<ForwardIterator<iterator>::difference_type, size_type>;

  bool            C::empty() const { return  this->begin() == this->end(); }
  size_type       C::size() const  { return  distance(this->begin(), this->end()); }

  iterator        C::begin();
  const_iterator  C::begin() const;
  iterator        C::end();
  const_iterator  C::end() const;
  const_iterator  C::cbegin() const { return this->begin(); }
  const_iterator  C::cend() const   { return this->end(); }
  reference       C::front()        { return *this->begin(); }
  const_reference C::front() const  { return *this->begin(); }

  axiom MemberAccessFront(C c) {
    if (c.begin() != c.end()) c.front() == *c.begin();
  }  

  axiom MemberContainerSize(C c) {
    (c.begin() == c.end()) == c.empty();
    (c.begin() != c.end()) == (c.size() > 0);
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container, in terms of
  member functions, which provides
  iteration through a sequence of elements stored in the container.}
\pnum
\addedConcepts{\mbox{\requires} for a (possibly
  \mbox{\tcode{const}}-qualified) container \mbox{\tcode{c}},
  \mbox{\tcode{[c.begin(), c.end())}} is a valid range.}
\end{itemdescr}

\begin{itemdecl}
auto concept MemberFrontInsertionContainer<typename C> : MemberContainer<C> {
  void C::push_front(value_type&&);

  axiom MemberFrontInsertion(C c, value_type x) {
    x == (c.push_front(x), c.front());
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container, in terms of
  member functions, that can be
  modified by adding elements to the front of the
  container.}
\end{itemdescr}

\begin{itemdecl}
auto concept MemberBackInsertionContainer<typename C> : MemberContainer<C> {
  reference       C::back();
  const_reference C::back() const;

  void C::push_back(value_type&&);

  requires BidirectionalIterator<iterator> axiom MemberAccessBack(C c) {
    if (c.begin() != c.end()) c.back() == *(--c.end());
  }

  axiom MemberBackInsertion(C c, value_type x) {
    x == (c.push_back(x), c.back());
  }
}
\end{itemdecl}


\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container, in terms of member functions, that can be
  modified by adding elements to the back of the
  container.}
\end{itemdescr}

\begin{itemdecl}
auto concept MemberStackLikeContainer<typename C> : MemberBackInsertionContainer<C> {
  void C::pop_back();

  axiom MemberBackRemoval(C c, value_type x) {
    c == (c.push_back(x), c.pop_back(), c);
  }
}
\end{itemdecl}


\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container, in terms of member functions, that can be
  modified by adding or removing elements from the back of the
  container.}
\end{itemdescr}


\begin{itemdecl}
auto concept MemberQueueLikeContainer<typename C> : MemberBackInsertionContainer<C> {
  void C::pop_front();
}
\end{itemdecl}


\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container, in terms of member functions, that can be
  modified by adding elements to the back or removing elements from the front of the
  container.}
\end{itemdescr}

\begin{itemdecl}
auto concept MemberInsertionContainer<typename C> : MemberContainer<C> {
  iterator C::insert(const_iterator, value_type&&);

  axiom MemberInsertion(C c, const_iterator position, value_type v) {
    v == *c.insert(position, v);
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container, in terms of member functions, that can be
  modified by inserting elements at any position within the container.}
\end{itemdescr}

\begin{itemdecl}
auto concept MemberRangeInsertionContainer<typename C, typename Iter> : MemberInsertionContainer<C> {
  requires InputIterator<Iter>;
  void C::insert(const_iterator position, Iter first, Iter last);
}
\end{itemdecl}

\begin{itemdescr}
  \pnum \addedConcepts{\mbox{\reallynote} describes a container, in terms of member functions,  that
    can be modified by inserting a sequence of elements at any
    position within the sequence.}
\end{itemdescr}

\begin{itemdecl}
auto concept MemberFrontEmplacementContainer<typename C, typename... Args> : MemberContainer<C> {
  void C::emplace_front(Args&&... args);

  requires Constructible<value_type, Args...>
    axiom MemberFrontEmplacement(C c, Args... args) {
      value_type(args...) == (c.emplace_front(args...), front(c));
    }

  requires MemberFrontInsertionContainer<C> && Constructible<value_type, Args...>
    axiom MemberFrontEmplacementPushEquivalence(C c, Args... args) {
      (c.emplace_front(args...), c.front()) == (c.push_front(value_type(args...)), c.front());
    }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container, in terms of member functions, that can be
  modified by placing a newly-constructed object at the front of the sequence.} 
\end{itemdescr}

\begin{itemdecl}
auto concept MemberBackEmplacementContainer<typename C, typename... Args> : MemberBackInsertionContainer<C> {
  void C::emplace_back(Args&&... args);

  requires Constructible<value_type, Args...>
    axiom MemberBackEmplacement(C c, Args... args) {
      value_type(args...) == (c.emplace_back(args...), back(c));
    }

  requires BackInsertionContainer<C> && Constructible<value_type, Args...>
    axiom MemberBackEmplacementPushEquivalence(C c, Args... args) {
      (c.emplace_back(args...), c.back()) == (c.push_back(value_type(args...)), c.back());
    }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container, in terms of member functions, that can be
  modified by constructing elements at the back of the sequence.} 
\end{itemdescr}

\begin{itemdecl}
auto concept MemberEmplacementContainer<typename C, typename... Args> : MemberInsertionContainer<C> {
  void C::emplace(const_iterator position, Args&&... args);

  require Constructible<value_type, Args...>
    axiom MemberEmplacement(C c, const_iterator position, Args... args) {
      value_type(args...) == *c.emplace(position, args...);
    }

  requires MemberInsertionContainer<C> && Constructible<value_type, Args...>
    axiom MemberEmplacementPushEquivalence(C c, const_iterator position, Args... args) {
      *c.emplace(position, args...) == *c.insert(position, value_type(args...));
    }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a container, in terms of member functions, that can be
  modified by constructing elements at any position within 
  the sequence.}
\end{itemdescr}

\rSec3[container.concepts.maps]{Container concept maps}

\pnum
\addedConcepts{This section contains concept maps that automatically adapt
  classes with the appropriate member functions, as specified in
  (\mbox{\ref{container.concepts.member}}), to meet the free function
  container concept syntax in (\mbox{\ref{container.concepts.free}}). It
  also contains maps adapting built-in arrays to model the appropriate
  container concepts, and maps adapting emplacement container concepts to
  to model insertion container concepts. }


\begin{itemdecl}
template <MemberContainer C>
concept_map Container<C> {
  typedef C::value_type      value_type;
  typedef C::reference       reference;
  typedef C::const_reference const_reference;
  typedef C::size_type       size_type;

  typedef C::iterator        iterator;
  typedef C::const_iterator  const_iterator;

  bool            empty(const C& c)   { return c.empty(); }
  size_type       size(const C& c)    { return c.size(); }

  iterator        begin(C& c)         { return c.begin(); }
  const_iterator  begin(const C& c)   { return c.begin(); }
  iterator        end(C& c)           { return c.end(); }
  const_iterator  end(const C& c)     { return c.end(); }
  const_iterator  cbegin(const C& c)  { return c.cbegin(); }
  const_iterator  cend(const C& c)    { return c.cend(); }
  reference       front(C& c)         { return c.front(); }
  const_reference front(const C& c)   { return c.front(); }
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts an existing container, which uses
  member function syntax for each of its operations, to the
  \mbox{\tcode{Container}} concept.}
\end{itemdescr}

\begin{itemdecl}
template <MemberFrontInsertionContainer C> 
concept_map FrontInsertionContainer<C> {
  typedef Container<C>::value_type value_type;

  void push_front(C& c, value_type&& v) { c.push_front(static_cast<value_type&&>(v)); }
}			
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts an existing container, which uses
  member function syntax for each of its operations, to the}
  \\\addedConcepts{\mbox{\tcode{FrontInsertionContainer}} concept.}
\end{itemdescr}

\begin{itemdecl}
template <MemberBackInsertionContainer C> 
concept_map BackInsertionContainer<C> {
  typedef Container<C>::value_type      value_type;
  typedef Container<C>::reference       reference;
  typedef Container<C>::const_reference const_reference;

  reference       back(C& c)        { return c.back(); }
  const_reference back(const C& c)  { return c.back(); }

  void push_back(C& c, value_type&& v) { c.push_back(static_cast<value_type&&>(v)); }
}			
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts an existing container, which uses
  member function syntax for each of its operations, to the}
  \\\addedConcepts{\mbox{\tcode{BackInsertionContainer}} concept.}
\end{itemdescr}

\begin{itemdecl}
template <MemberStackLikeContainer C> 
concept_map StackLikeContainer<C> {
    void pop_back(C& c)  { c.pop_back(); }
}			
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts an existing container, which uses
  member function syntax for each of its operations, to the}
  \\\addedConcepts{\mbox{\tcode{StackLikeContainer}} concept.}
\end{itemdescr}

\begin{itemdecl}
template <MemberQueueLikeContainer C> 
concept_map QueueLikeContainer<C> {
    void pop_front(C& c)  { c.pop_front(); }
}			
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts an existing container, which uses
  member function syntax for each of its operations, to the}
  \\\addedConcepts{\mbox{\tcode{QueueLikeContainer}} concept.}
\end{itemdescr}

\begin{itemdecl}
template <MemberInsertionContainer C> 
concept_map InsertionContainer<C> {
  typedef Container<C>::value_type value_type;
  Container<C>::iterator insert(C& c, Container<C>::const_iterator i, value_type&& v)    
  { return c.insert(i, static_cast<value_type&&>(v)); }
}			
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts an existing insertion container, which uses
  member function syntax for each of its operations, to the}
  \\\addedConcepts{\mbox{\tcode{InsertionContainer}} concept.}
\end{itemdescr}

\begin{itemdecl}
template <MemberRangeInsertionContainer C, InputIterator Iter> 
concept_map RangeInsertionContainer<C, Iter> {
  void insert(C& c, Container<C>::const_iterator i, Iter first, Iter last)
  { c.insert(i, first, last); }
}			
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts an existing range-insertion container, which uses
  member function syntax for each of its operations, to the}
  \addedConcepts{\mbox{\tcode{RangeInsertionContainer}} concept.}
\end{itemdescr}

\begin{itemdecl}
template <MemberFrontEmplacementContainer C, typename... Args> 
  concept_map FrontEmplacementContainer<C, Args...> {
    void emplace_front(C& c, Args&&... args) 
    { c.emplace_front(forward<Args>(args)...); }
  }
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts an existing front-emplace container, which uses
  member function syntax for each of its operations, to the}
  \addedConcepts{\mbox{\tcode{FrontEmplacementContainer}} concept.}
\end{itemdescr}

\begin{itemdecl}
template <MemberBackEmplacementContainer C, typename... Args> 
  concept_map BackEmplacementContainer<C, Args...> {
    void emplace_back(C& c, Args&&... args) 
    { c.emplace_back(forward<Args>(args)...); }
  }
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts an existing back-emplace container, which uses
  member function syntax for each of its operations, to the}
  \addedConcepts{\mbox{\tcode{BackEmplacementContainer}} concept.}
\end{itemdescr}

\begin{itemdecl}
template <MemberEmplacementContainer C, typename... Args> 
  concept_map EmplacementContainer<C, Args...> {
    Container<C>::iterator emplace(C& c, Container<C>::const_iterator position, Args&&... args) 
    { return c.emplace(position, forward<Args>(args)...); }
  }
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts an existing emplace container, which uses
  member function syntax for each of its operations, to the}
  \\\addedConcepts{\mbox{\tcode{EmplacementContainer}} concept.}
\end{itemdescr}

\begin{itemdecl}
template <typename E, size_t N>
concept_map Container<E[N]> {
  typedef E                  value_type;
  typedef E&                 reference;
  typedef const E&           const_reference;
  typedef size_t             size_type;
  typedef E*                 iterator;
  typedef const E*           const_iterator;

  bool           empty(const E(&c)[N]) { return N==0; }
  size_type      size(const E(&c) [N]) { return N; }

  iterator       begin(E(&c)[N])       { return c; }
  const_iterator begin(const E(&c)[N]) { return c; }
  iterator       end(E(&c)[N])         { return c + N; }  
  const_iterator end(const E(&c)[N])   { return c + N; }
}
\end{itemdecl}

\begin{itemdecl}
template <typename E, size_t N>
concept_map Container<const E[N]> {
  typedef E                  value_type;
  typedef const E&           reference;
  typedef const E&           const_reference;
  typedef size_t             size_type;

  typedef const E*           iterator;
  typedef const E*           const_iterator;

  bool           empty(const E(&c)[N]) { return N==0; }
  size_type      size(const E(&c)[N])  { return N; }

  const_iterator begin(const E(&c)[N]) { return c; }
  const_iterator end(const E(&c)[N])   { return c + N; }
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} Adapts built-in arrays to the 
  \mbox{\tcode{Container}} concept.}
\end{itemdescr}

\color{black}

\rSec1[sequences]{Sequences}

\pnum
Headers \tcode{<array>}, \tcode{<deque>}, \tcode{<forward_list>}, \tcode{<list>}, \tcode{<queue>}, \tcode{<stack>}, and \tcode{<vector>}.

\synopsis{Header \tcode{<array>}\ synopsis}%
\index{array@\tcode{<array>}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ T, size_t N > 
    @\addedConcepts{requires NothrowDestructible<T>}@
    struct array;
  template <@\changedConcepts{class}{EqualityComparable}@ T, size_t N>
    bool operator==(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, size_t N>
    bool operator!=(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator<(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator>(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator<=(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator>=(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{Swappable}@ T, size_t N >
    void swap(array<T,N>& x, array<T,N>& y);

  template <@\changedConcepts{class}{ObjectType}@ T> class tuple_size;
  template <size_t I, @\changedConcepts{class}{ObjectType}@ T> 
    class tuple_element;
  template <@\changedConcepts{class}{ObjectType}@ T, size_t N>
    struct tuple_size<array<T, N> >;
  template <size_t I, class T, size_t N>
    @\addedConcepts{requires True<(I < N)>}@
    struct tuple_element<I, array<T, N> >;
  template <size_t I, class T, size_t N>
    @\addedConcepts{requires True<(I < N)>}@
    T& get(array<T, N>&); 
  template <size_t I, class T, size_t N>
    @\addedConcepts{requires True<(I < N)>}@
    const T& get(const array<T, N>&);
}
\end{codeblock}

\synopsis{Header \tcode{<deque>}\ synopsis}%
\index{deque@\tcode{<deque>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ T, @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<T> > 
    @\addedConcepts{requires NothrowDestructible<T>}@
    class deque;
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator==(const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator<(const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator>(const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(deque<T,Alloc@\removedConcepts{ator}@>& x, deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(deque<T,Alloc@\removedConcepts{ator}@>&& x, deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(deque<T,Alloc@\removedConcepts{ator}@>& x, deque<T,Alloc@\removedConcepts{ator}@>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<forward_list>} synopsis}%
\index{forward_list@\tcode{<forward_list>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ T, @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<T> > 
    @\addedConcepts{requires NothrowDestructible<T>}@
    class forward_list; 
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator==(const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator< (const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator!=(const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator> (const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator>=(const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator<=(const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@> 
    void swap(forward_list<T,Alloc@\removedConcepts{ator}@>& x, forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
}
\end{codeblock}

\synopsis{Header \tcode{<list>}\ synopsis}%
\index{list@\tcode{<list>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ T, @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<T> > 
    @\addedConcepts{requires NothrowDestructible<T>}@
    class list;
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator==(const list<T,Alloc@\removedConcepts{ator}@>& x, const list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator< (const list<T,Alloc@\removedConcepts{ator}@>& x, const list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const list<T,Alloc@\removedConcepts{ator}@>& x, const list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator> (const list<T,Alloc@\removedConcepts{ator}@>& x, const list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const list<T,Alloc@\removedConcepts{ator}@>& x, const list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const list<T,Alloc@\removedConcepts{ator}@>& x, const list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(list<T,Alloc@\removedConcepts{ator}@>& x, list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(list<T,Alloc@\removedConcepts{ator}@>&& x, list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(list<T,Alloc@\removedConcepts{ator}@>& x, list<T,Alloc@\removedConcepts{ator}@>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<queue>}\ synopsis}%
\index{queue@\tcode{<queue>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Cont@\removedConcepts{ainer}@ = deque<T> >
    @\addedConcepts{requires QueueLikeContainer<Cont>}@
          @\addedConcepts{\&\& SameType<T, Cont::value_type>}@
          @\addedConcepts{\&\& NothrowDestructible<Cont>}@
    class queue;
  template <class T, @\changedConcepts{class}{EqualityComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator==(const queue<T, Cont@\removedConcepts{ainer}@>& x,const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator< (const queue<T, Cont@\removedConcepts{ainer}@>& x,const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{EqualityComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator!=(const queue<T, Cont@\removedConcepts{ainer}@>& x,const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator> (const queue<T, Cont@\removedConcepts{ainer}@>& x,const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator>=(const queue<T, Cont@\removedConcepts{ainer}@>& x,const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator<=(const queue<T, Cont@\removedConcepts{ainer}@>& x,const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(queue<T,Cont@\removedConcepts{ainer}@>& x, queue<T,Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(queue<T,Cont@\removedConcepts{ainer}@>&& x, queue<T,Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(queue<T,Cont@\removedConcepts{ainer}@>& x, queue<T,Cont@\removedConcepts{ainer}@>&& y);

  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{StackLikeContainer}@ Cont@\removedConcepts{ainer}@ = vector<T>,
        @\changedConcepts{{class}}{StrictWeakOrder<auto, T>}@ Compare = less<typename Cont@\removedConcepts{ainer}@::value_type> >
    @\addedConcepts{requires SameType<Cont::value_type, T> \&\& RandomAccessIterator<Cont::iterator>}@
          @\addedConcepts{\&\& ShuffleIterator<Cont::iterator> \&\& CopyConstructible<Compare>}@
          @\addedConcepts{\&\& NothrowDestructible<Cont>}@
  class priority_queue;
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@, @\changedConcepts{class}{Swappable}@ Compare>
    void swap(priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& x, priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@, @\changedConcepts{class}{Swappable}@ Compare>
    void swap(priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>&& x, priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@, @\changedConcepts{class}{Swappable}@ Compare>
    void swap(priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& x, priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<stack>}\ synopsis}%
\index{stack@\tcode{<stack>}}

\begin{codeblock} 
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{StackLikeContainer}@ Cont@\removedConcepts{ainer}@ = deque<T> > 
    @\addedConcepts{requires SameType<Cont::value_type, T>}@
          @\addedConcepts{\&\& NothrowDestructible<Cont>}@
    class stack;
  template <class T, @\changedConcepts{class}{EqualityComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator==(const stack<T, Cont@\removedConcepts{ainer}@>& x,const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator< (const stack<T, Cont@\removedConcepts{ainer}@>& x,const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{EqualityComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator!=(const stack<T, Cont@\removedConcepts{ainer}@>& x,const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator> (const stack<T, Cont@\removedConcepts{ainer}@>& x,const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator>=(const stack<T, Cont@\removedConcepts{ainer}@>& x,const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator<=(const stack<T, Cont@\removedConcepts{ainer}@>& x,const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(stack<T,@\changedConcepts{Allocator}{Cont}@>& x, stack<T, @\changedConcepts{Allocator}{Cont}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(stack<T, Cont@\removedConcepts{ainer}@>&& x, stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(stack<T, Cont@\removedConcepts{ainer}@>& x, stack<T, Cont@\removedConcepts{ainer}@>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<vector>}\ synopsis}%
\index{vector@\tcode{<vector>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ T, @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<T> > 
    @\addedConcepts{requires MoveConstructible<T>}@
    class vector;
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator==(const vector<T,Alloc@\removedConcepts{ator}@>& x,const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator< (const vector<T,Alloc@\removedConcepts{ator}@>& x,const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const vector<T,Alloc@\removedConcepts{ator}@>& x,const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator> (const vector<T,Alloc@\removedConcepts{ator}@>& x,const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const vector<T,Alloc@\removedConcepts{ator}@>& x,const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const vector<T,Alloc@\removedConcepts{ator}@>& x,const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(vector<T,Alloc@\removedConcepts{ator}@>& x, vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(vector<T,Alloc@\removedConcepts{ator}@>&& x, vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(vector<T,Alloc@\removedConcepts{ator}@>& x, vector<T,Alloc@\removedConcepts{ator}@>&& y);

  template <@\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@> class vector<bool,Alloc@\removedConcepts{ator}@>;
\end{codeblock}

\rSec2[array]{\marktr{}Class template \tcode{array}}
\index{array@\tcode{array}}%

\pnum
\index{array@\tcode{array}!contiguous storage}%
The header \tcode{<array>} defines a class template for storing fixed-size
sequences of objects. An \tcode{array} supports random access iterators. An
instance of \tcode{array<T, N>} stores \tcode{N} elements of type \tcode{T}, so that 
\tcode{size() == N} is an invariant. The elements of an \tcode{array} are stored contiguously,
meaning that if \tcode{a} is an \tcode{array<T, N>} then it obeys the identity 
\verb|&a[n] == &a[0] + n| for all \tcode{0 <= n < N}.

\pnum
\index{array@\tcode{array}!initialization}%
\index{array@\tcode{array}!as aggregate}%
An \tcode{array} is an aggregate~(\ref{dcl.init.aggr}) that can be
initialized with the syntax
\begin{codeblock}
array a = { initializer-list };
\end{codeblock}

where \textit{initializer-list} is a comma separated list of up
to \tcode{N} elements whose types are convertible to \tcode{T}.

\pnum
\index{requirements!Container}%
Unless otherwise specified, all \tcode{array} operations are as described
in~\ref{container.requirements}. Descriptions are provided here
only for operations on \tcode{array} that are not described in that clause
or for operations where there is additional semantic information.

\index{array@\tcode{array}}%
\index{array@\tcode{array}!begin@\tcode{begin}}%
\index{begin@\tcode{begin}!array@\tcode{array}}%
\index{array@\tcode{array}!end@\tcode{end}}%
\index{end@\tcode{end}!array@\tcode{array}}%
\index{array@\tcode{array}!size@\tcode{size}}%
\index{size@\tcode{size}!array@\tcode{array}}%
\index{array@\tcode{array}!max_size@\tcode{max_size}}%
\index{max_size@\tcode{max_size}!array@\tcode{array}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ T, size_t N >
  @\addedConcepts{requires NothrowDestructible<T>}@
  struct array {
    //  types:
    typedef T &                                   reference;
    typedef const T &                             const_reference;
    typedef @{\itshape implementation defined}@                iterator;
    typedef @{\itshape implementation defined}@                const_iterator;
    typedef size_t                                size_type;
    typedef ptrdiff_t                             difference_type;
    typedef T                                     value_type;
    typedef reverse_iterator<iterator>       reverse_iterator;
    typedef reverse_iterator<const_iterator> const_reverse_iterator;

    T       elems[N];           // \expos

    // No explicit construct/copy/destroy for aggregate type

    @\addedConcepts{requires CopyAssignable<T>}@ void assign(const T& u);
    @\addedConcepts{requires Swappable<T>}@ void swap(array<T, N> &);

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    constexpr size_type size() const;
    constexpr size_type max_size() const;
    bool      empty() const;

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    T *       data();
    const T * data() const;
  };
}
\end{codeblock}

\pnum
\enternote\ The member variable \tcode{elems} is shown for exposition only,
to empahasize that \tcode{array} is a class aggregate.  The name \tcode{elems}
is not part of \tcode{array}'s interface. \exitnote\

\rSec3[array.cons]{\tcode{array} constructors, copy, and assignment}

\pnum
\index{array@\tcode{array}!initialization}%
\index{requirements!Container}%
The conditions for an aggregate~(\ref{dcl.init.aggr}) shall be
met. Class \tcode{array} relies on the implicitly-declared special
member functions~(\ref{class.ctor}, \ref{class.dtor}, and \ref{class.copy}) to
conform to the container requirements table in~\ref{container.requirements}.

\rSec3[array.special]{\tcode{array} specialized algorithms}

\index{array@\tcode{array}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!array@\tcode{array}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Swappable}@ T, size_t N> void swap(array<T,N>& x, array<T,N>& y);
\end{itemdecl}
\begin{itemdescr}
\pnum\effects\ 
\begin{codeblock}
swap_ranges(x.begin(), x.end(), y.begin() );
\end{codeblock}
\end{itemdescr}

\rSec3[array.size]{\tcode{array::size}}

\index{array@\tcode{array}!size@\tcode{size}}%
\index{size@\tcode{size}!array@\tcode{array}}%
\begin{itemdecl}
@\removedConcepts{template <class T, size_t N>}@ size_type @\removedConcepts{array<T,N>::}@size();
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{N}
\end{itemdescr}

\rSec3[array.data]{\tcode{array::data}}
\index{array@\tcode{array}!data@\tcode{data}}%
\index{data@\tcode{data}!array@\tcode{array}}%
\begin{itemdecl}
T *data();
const T *data() const;
\end{itemdecl}

\begin{itemdescr}
\pnum \returns\ \tcode{elems}.
\end{itemdescr}

\rSec3[array.zero]{Zero sized arrays}
\index{array@\tcode{array}!zero sized}%

\pnum\tcode{array} shall provide support for the special case \tcode{N == 0}.

\pnum In the case that \tcode{N == 0}, \tcode{begin() == end() ==} unique value.
The return value of \tcode{data()} is unspecified.

\pnum
The effect of calling \tcode{front()} or \tcode{back()} for a zero-sized array
is implementation defined.

\rSec3[array.tuple]{Tuple interface to class template \tcode{array}}
\index{array@\tcode{array}}%
\index{tuple@\tcode{tuple}}%
\index{tuple@\tcode{tuple}!and array@and \tcode{array}}%
\index{array@\tcode{array}!tuple interface to}%

\index{tuple_size@\tcode{tuple_size}}%
\begin{itemdecl}
tuple_size<array<T, N> >::value
\end{itemdecl}

\begin{itemdescr}
\pnum
\returntype\   integral constant expression.

\pnum
\cvalue\  \tcode{N}
\end{itemdescr}

\index{tuple_element@\tcode{tuple_element}}%
\begin{itemdecl}
tuple_element<I, array<T, N> >::type
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\  \tcode{0 <= I < N}.   The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\cvalue\  The type T.
\end{itemdescr}

\index{array@\tcode{array}!get@\tcode{get}}%
\index{get@\tcode{get}!array@\tcode{array}}%
\begin{itemdecl}
template <size_t I, class T, size_t N> 
  @\addedConcepts{requires True<(I < N)>}@
  T& get(array<T, N>& a); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{I < N}}. The program is ill-formed if \mbox{\tcode{I}} is out of bounds.}

\returns\  A reference to the \tcode{I}th element of \tcode{a}, 
where indexing is zero-based.

\throws\ nothing.
\end{itemdescr}

\index{array@\tcode{array}!get@\tcode{get}}%
\index{get@\tcode{get}!array@\tcode{array}}%
\begin{itemdecl}
template <size_t I, class T, size_t N> 
  @\addedConcepts{requires True<(I < N)>}@
  const T& get(const array<T, N>& a); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{I < N}}. The program is ill-formed if \mbox{\tcode{I}} is out of bounds.}

\pnum
\returns\ A const reference to the \tcode{I}th element of \tcode{a}, 
where indexing is zero-based.

\throws\ nothing.
\end{itemdescr}

\rSec2[deque]{Class template \tcode{deque}}%

\pnum
\index{deque@\tcode{deque}}
A
\tcode{deque}\
is a sequence container that, like a
\tcode{vector}\
(\ref{vector}), supports random access iterators.
In addition, it supports constant time insert and erase operations at the beginning or the end;
insert and erase in the middle take linear time.
That is, a deque is especially optimized for pushing and popping elements at the beginning and end.
As with vectors, storage management is handled automatically.

\pnum
A
\tcode{deque}\
satisfies all of the requirements of a container, of a reversible container
(given in tables in~\ref{container.requirements}), of a sequence container,
including the optional sequence container requirements
(\ref{sequence.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
Descriptions are provided here only for operations on
\tcode{deque}\
that are not described in one of these tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ T, @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<T> >
  @\addedConcepts{requires NothrowDestructible<T>}@
  class deque {
  public:
    // types:
    typedef typename Alloc@\removedConcepts{ator}@::reference         reference;
    typedef typename Alloc@\removedConcepts{ator}@::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef T                                     value_type;
    typedef Alloc@\removedConcepts{ator}@                             allocator_type;
    typedef typename Alloc@\removedConcepts{ator}@::pointer           pointer;
    typedef typename Alloc@\removedConcepts{ator}@::const_pointer     const_pointer;
    typedef reverse_iterator<iterator>       reverse_iterator;
    typedef reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{deque.cons} construct/copy/destroy:
    explicit deque(const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    @\addedConcepts{requires AllocatableElement<Alloc, T>}@ explicit deque(size_type n);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      deque(size_type n, const T& value, const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@ 
      deque(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last, const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ deque(const deque<T,Alloc@\removedConcepts{ator}@>& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ deque(deque&&);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ deque(const deque&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ deque(deque&&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      deque(initializer_list<T>, const Allocator& = Allocator());

   ~deque();
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>} \addedConcepts{\&\& CopyAssignable<T>}@
      deque<T,Alloc@\removedConcepts{ator}@>& operator=(const deque<T,Alloc@\removedConcepts{ator}@>& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&> \&\& MoveAssignable<T>}@
      deque<T,Alloc@\removedConcepts{ator}@>& operator=(@\removedConcepts{const}@ deque<T,Alloc@\removedConcepts{ator}@>&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& CopyAssignable<T>}@
      deque& operator=(initializer_list<T>);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
            @\addedConcepts{\&\& HasAssign<T, Iter::reference>}@
      void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>} \addedConcepts{\&\& CopyAssignable<T>}@ 
      void assign(size_type n, const T& t);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>} \addedConcepts{\&\& CopyAssignable<T>}@ 
      void assign(initializer_list<T>);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // \ref{deque.capacity} capacity:
    size_type size() const;
    size_type max_size() const;
    @\addedConcepts{requires AllocatableElement<Alloc, T>}@ 
      void resize(size_type sz);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@
      void resize(size_type sz, const T& c);
    bool empty() const;

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{deque.modifiers} modifiers:
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@ 
      void emplace_front(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@ 
      void emplace_back(Args&&... args);

    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_front(const T& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_front(T&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_back(const T& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_back(T&& x);

    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...> \&\& MoveAssignable<T>}@ 
      iterator emplace(const_iterator position, Args&&... args);

    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& MoveAssignable<T>}@
      iterator insert(const_iterator position, const T& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&> \&\& MoveAssignable<T>}@
      iterator insert(const_iterator position, T&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& MoveAssignable<T>}@
      void insert(const_iterator position, size_type n, const T& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference> \&\& MoveAssignable<T>}@
      void insert(const_iterator position, @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& MoveAssignable<T>}@
      void insert(const_iterator position, initializer_list<T>);

    void pop_front();
    void pop_back();

    @\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator position);
    @\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator first, const_iterator last);
    void     swap(deque<T,Alloc@\removedConcepts{ator}@>&&);
    void     clear();
  };

  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator==(const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator< (const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator> (const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const deque<T,Alloc@\removedConcepts{ator}@>& x, const deque<T,Alloc@\removedConcepts{ator}@>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(deque<T,Alloc@\removedConcepts{ator}@>& x, deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(deque<T,Alloc@\removedConcepts{ator}@>&& x, deque<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(deque<T,Alloc@\removedConcepts{ator}@>& x, deque<T,Alloc@\removedConcepts{ator}@>&& y);

  @\removedConcepts{template <class T, class Alloc}@
    @\removedConcepts{struct constructible_with_allocator_suffix<deque<T, Alloc> >}@
      @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}

\rSec3[deque.cons]{\tcode{deque}\ constructors, copy, and assignment}

\begin{itemdecl}
explicit deque(const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty
\tcode{deque},
using the specified allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T>}@ explicit deque(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{deque} with
\tcode{n} default constructed elements.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{DefaultConstructible}}.}

\pnum
\complexity Linear in \farg{n}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@
deque(size_type @\farg{n}@, const T& @\farg{value}@,
      const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs a
\tcode{deque}\
with \farg{n} copies of \farg{value},
using the specified allocator.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}

\pnum
\complexity\ 
Linear in \farg{n}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
  deque(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@,
        const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs a
\tcode{deque}\
equal to the the range
\range{\farg{first}}{\farg{last}},
using the specified allocator.

\pnum
\complexity\ 
\tcode{distance(\farg{first}, \farg{last})}.
\end{itemdescr}

\index{assign@\tcode{assign}!\tcode{deque}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
        @\addedConcepts{\&\& HasAssign<T, Iter::reference>}@
  void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
erase(begin(), end());
insert(begin(), first, last);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>} \addedConcepts{\&\& CopyAssignable<T>}@
void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
erase(begin(), end());
insert(begin(), n, t);
\end{codeblock}
\end{itemdescr}

\rSec3[deque.capacity]{\tcode{deque}\ capacity}

\index{resize@\tcode{resize}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T>}@
  void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, equivalent to
\tcode{erase(begin() + sz, end());}. If \tcode{size() < sz},
appends \tcode{sz - size()} default constructed elements to the
sequence.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be
\mbox{\tcode{DefaultConstructible}}.}
\end{itemdescr}

\index{resize@\tcode{resize}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
  void resize(size_type sz, const T& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
if (sz > size())
  insert(end(), sz-size(), c);
else if (sz < size())
  erase(begin()+sz, end());
else
  ;                 // do nothing
\end{codeblock}

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be
\mbox{\tcode{CopyConstructible}}.}
\end{itemdescr}

\rSec3[deque.modifiers]{\tcode{deque}\ modifiers}

\index{insert@\tcode{insert}!\tcode{deque}}%
\index{insert@\tcode{emplace_front}!\tcode{deque}}%
\index{insert@\tcode{emplace_back}!\tcode{deque}}%
\index{insert@\tcode{push_front}!\tcode{deque}}%
\index{insert@\tcode{push_back}!\tcode{deque}}%
\index{insert@\tcode{emplace}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& MoveAssignable<T>}@
  iterator insert(const_iterator position, const T& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&> \&\& MoveAssignable<T>}@
  iterator insert(const_iterator position, T&& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& MoveAssignable<T>}@
  void     insert(const_iterator position, size_type n, const T& x);
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference> \&\& MoveAssignable<T>}@
  void insert(const_iterator position,
              @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

template <class... Args> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@ 
  void emplace_front(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@ 
  void emplace_back(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...> \&\& MoveAssignable<T>}@ 
  iterator emplace(const_iterator position, Args&&... args);
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_front(const T& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_front(T&& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_back(const T& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_back(T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
An insertion in the middle of the deque invalidates all the iterators and
references to elements of the deque.
An insertion at either end of the
deque invalidates all the iterators to the deque, but has no effect on
the validity of references to elements of the deque.

\pnum
\notes\ 
If an exception is thrown other than by the
copy constructor or assignment operator of
\tcode{T}\
there are no effects.

\pnum
\complexity\ 
The complexity is linear in the number of elements inserted plus the lesser
of the distances to the beginning and end of the deque.
Inserting a single element either at the beginning or end of a deque always takes constant time
and causes a single call to a constructor of
\tcode{T}.
\end{itemdescr}

\index{erase@\tcode{erase}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator position);
@\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator first, const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
An erase in the middle of the deque invalidates all the iterators and
references to elements of the deque and the past-the-end iterator.
An erase at the beginning of the
deque invalidates only the iterators and the references to the erased elements.
An erase at the end of the deque invalides only the iterators and the references to the erased elements and the past-the-end iterator.

\pnum
\complexity\ 
The number of calls to the destructor is the same as the
number of elements erased, but the number of the calls to the assignment operator is at most equal to the minimum
of the number of elements before the erased elements and the number of elements after the erased elements.

\pnum
\throws\ 
Nothing unless an exception is thrown by the copy constructor or assignment operator of
\tcode{T}.
\end{itemdescr}

\rSec3[deque.special]{\tcode{deque}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(deque<T,Alloc@\removedConcepts{ator}@>& x, deque<T,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(deque<T,Alloc@\removedConcepts{ator}@>&& x, deque<T,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(deque<T,Alloc@\removedConcepts{ator}@>& x, deque<T,Alloc@\removedConcepts{ator}@>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[forwardlist]{Class template \tcode{forward_list}}

\pnum
A \tcode{forward_list} is a container that supports forward iterators and allows constant time insert and erase operations anywhere within the sequence, with storage management handled automatically. Fast random access to list elements is not supported. \enternote It is intended that \tcode{forward_list} have zero space or time overhead relative to a hand-written C-style singly linked list. Features that would conflict with that goal have been omitted.\exitnote

\pnum
A \tcode{forward_list} satisfies all of the requirements of a container (table~\ref{tab:containers.container.requirements}), except that the \tcode{size()} member function is not provided. Descriptions are provided here only for operations on \tcode{forward_list} that are not described in that table or for operations where there is additional semantic information.

\begin{codeblock}
namespace std { 
  template <@\changedConcepts{class}{ValueType}@ T, @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<T> > 
  @\addedConcepts{requires NothrowDestructible<T>}@
  class forward_list { 
  public: 
    // types: 
    typedef typename Alloc@\removedConcepts{ator}@::reference reference; 
    typedef typename Alloc@\removedConcepts{ator}@::const_reference const_reference; 
    typedef @\impdef@ iterator;       // See 23.1 
    typedef @\impdef@ const_iterator; // See 23.1 
    typedef @\impdef@ size_type;      // See 23.1 
    typedef @\impdef@ difference_type;// See 23.1 
    typedef T value_type; 
    typedef Alloc@\removedConcepts{ator}@ allocator_type; 
    typedef typename Alloc@\removedConcepts{ator}@::pointer pointer; 
    typedef typename Alloc@\removedConcepts{ator}@::const_pointer const_pointer; 

    // \ref{forwardlist.cons} construct/copy/destroy: 
    explicit forward_list(const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@()); 
    @\addedConcepts{requires AllocatableElement<Alloc, T>}@ 
      explicit forward_list(size_type n);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      forward_list(size_type n, const T& value, 
                   const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@()); 
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{AllocatableElement<Alloc, T, Iter::reference>}@
      forward_list(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last, 
                   const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@()); 
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      forward_list(const forward_list<T,Alloc@\removedConcepts{ator}@>& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ forward_list(forward_list<T,Alloc@\removedConcepts{ator}@>&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      forward_list(initializer_list<T>, const Allocator& = Allocator());
    ~forward_list(); 
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ @\addedConcepts{\&\& CopyAssignable<T>}@
      forward_list<T,Alloc@\removedConcepts{ator}@>& operator=(const forward_list<T,Alloc@\removedConcepts{ator}@>& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&> \&\& MoveAssignable<T>}@
      forward_list<T,Alloc@\removedConcepts{ator}@>& operator=(forward_list<T,Alloc@\removedConcepts{ator}@>&& x); 
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& CopyAssignable<T>}@
      forward_list<T,Alloc@\removedConcepts{ator}@> operator=(initializer_list<T>);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
            @\addedConcepts{\&\& HasAssign<T, Iter::reference>}@
      void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last); 
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ @\addedConcepts{\&\& CopyAssignable<T>}@
      void assign(size_type n, const T& t); 
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ @\addedConcepts{\&\& CopyAssignable<T>}@
      void assign(initializer_list<T>);
    allocator_type get_allocator() const; 

    // \ref{forwardlist.iter} iterators:
    iterator before_begin();
    const_iterator before_begin() const;
    iterator begin(); 
    const_iterator begin() const; 
    iterator end(); 
    const_iterator end() const;

    const_iterator cbegin() const;
    const_iterator cbefore_begin() const;
    const_iterator cend() const;

    // capacity: 
    bool empty() const; 
    size_type max_size() const;

    // \ref{forwardlist.access} element access: 
    reference front(); 
    const_reference front() const; 

    // \ref{forwardlist.modifiers} modifiers: 
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@ 
      void emplace_front(Args&&... args); 
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_front(const T& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_front(T&& x);
    void pop_front();
   
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@ 
      iterator emplace_after(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      iterator insert_after(const_iterator position, const T& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ 
      iterator insert_after(const_iterator position, T&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      void insert_after(const_iterator position, initializer_list<T> il);

    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      void insert_after(const_iterator position, size_type n, const T& x); 
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
      void insert_after(const_iterator position, @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

    iterator erase_after(const_iterator position); 
    iterator erase_after(const_iterator position, iterator last); 
    void swap(forward_list<T,Alloc@\removedConcepts{ator}@>&&);

    @\addedConcepts{requires AllocatableElement<Alloc, T>}@ void resize(size_type sz);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void resize(size_type sz, value_type c);
    void clear(); 

    // \ref{forwardlist.ops} forward_list operations: 
    void splice_after(const_iterator position, forward_list<T,Alloc@\removedConcepts{ator}@>&& x); 
    void splice_after(const_iterator position, forward_list<T,Alloc@\removedConcepts{ator}@>&& x,
                      const_iterator i); 
    void splice_after(const_iterator position, forward_list<T,Alloc@\removedConcepts{ator}@>&& x,
                      const_iterator first, const_iterator last); 

    @\addedConcepts{requires EqualityComparable<T>}@ void remove(const T& value); 
    template <@\changedConcepts{class}{Predicate<auto, T>}@ Pred@\removedConcepts{icate}@> void remove_if(Pred@\removedConcepts{icate}@ pred); 

    @\addedConcepts{requires EqualityComparable<T>}@ void unique(); 
    template <@\changedConcepts{class}{EquivalenceRelation<auto, T>}@ BinaryPredicate>
      void unique(BinaryPredicate binary_pred);

    @\addedConcepts{requires LessThanComparable<T>}@ void merge(forward_list<T,Alloc@\removedConcepts{ator}@>&& x); 
    template <@\changedConcepts{class}{StrictWeakOrder<auto, T>}@ Compare> 
      void merge(forward_list<T,Alloc@\removedConcepts{ator}@>&& x, Compare comp);

    @\addedConcepts{requires LessThanComparable<T>}@ void sort(); 
    template <@\changedConcepts{class}{StrictWeakOrder<auto, T>}@ Compare> void sort(Compare comp); 

    void reverse(); 
  }; 

  // Comparison operators
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator==(const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator< (const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator!=(const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator> (const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator>=(const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@> 
    bool operator<=(const forward_list<T,Alloc@\removedConcepts{ator}@>& x, const forward_list<T,Alloc@\removedConcepts{ator}@>& y); 

  // \ref{forwardlist.spec} specialized algorithms: 
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@> 
    void swap(forward_list<T,Alloc@\removedConcepts{ator}@>& x, forward_list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@> 
    void swap(forward_list<T,Alloc@\removedConcepts{ator}@>&& x, forward_list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@> 
    void swap(forward_list<T,Alloc@\removedConcepts{ator}@>& x, forward_list<T,Alloc@\removedConcepts{ator}@>&& y); 
}
\end{codeblock}

\rSec3[forwardlist.cons]{\tcode{forward_list} constructors, copy, assignment}

\begin{itemdecl}
explicit forward_list(const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{forward_list} object using the specified allocator.

\pnum
\complexity Constant.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T>}@ 
  explicit forward_list(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{forward_list} object with \tcode{n} default constructed elements.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{DefaultConstructible}}.}

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
  forward_list(size_type n, const T& value, const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{forward_list} object with \tcode{n} copies of \tcode{value} using the specified allocator.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{AllocatableElement<Alloc, T, Iter::reference>}@
  forward_list(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last, 
               const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@()); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{forward_list} object equal to the range \range{first}{last}.

\pnum
\complexity Linear in \tcode{distance(first, last)}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
        @\addedConcepts{\&\& HasAssign<T, Iter::reference>}@
  void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{clear(); insert_after(before_begin(), first, last);}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{AllocatableElement<Alloc, T, const T\&>} \addedConcepts{\&\& CopyAssignable<T>}@ 
  void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{clear(); insert_after(before_begin(), n, t);}
\end{itemdescr}


\rSec3[forwardlist.iter]{\tcode{forward_list} iterators}

\begin{itemdecl}
{iterator before_begin();
const_iterator before_begin() const;
const_iterator cbefore_begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns A non-dereferenceable iterator that, when incremented, is equal to the iterator returned by \tcode{begin()}.
\end{itemdescr}

\rSec3[forwardlist.access]{\tcode{forward_list} element access}

\begin{itemdecl}
reference front();
const_reference front() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*begin()}
\end{itemdescr}

\rSec3[forwardlist.modifiers]{\tcode{forward_list} modifiers}

\pnum
None of the overloads of \tcode{insert_after} shall affect the validity of iterators and reference, and \tcode{erase_after} shall invalidate only the iterators and references to the erased elements. If an exception is thrown during \tcode{insert_after}  there shall be no effect. Insertion of \tcode{n} elements into a \tcode{forward_list} is linear in \tcode{n}, and the number of calls to the copy or move constructor of \tcode{T} is exactly equal to \tcode{n}. Erasing \tcode{n} elements from a \tcode{forward_list} is linear time in \tcode{n} and the number of calls to the destructor of type \tcode{T} is exactly equal to \tcode{n}.

\begin{itemdecl}
template <class... Args> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@ 
  void emplace_front(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Inserts an object of type \tcode{value_type} constructed with \tcode{value_type(forward<Args>(args)...)} at the beginning of the list.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_front(const T& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_front(T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Inserts a copy of \tcode{x} at the beginning of the list.
\end{itemdescr}

\begin{itemdecl}
void pop_front();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{erase_after(before_begin())}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
  iterator insert_after(const_iterator position, const T& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ 
  iterator insert_after(const_iterator position, T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}.

\pnum
\effects Inserts a copy of \tcode{x} after \tcode{position}.

\pnum
\returns An iterator pointing to the copy of \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
  void insert_after(const_iterator position, size_type n, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}.

\pnum
\effects Inserts \tcode{n} copies of \tcode{x} after \tcode{position}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
  void insert_after(const_iterator position, @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}. \tcode{first} and \tcode{last} are not iterators in \tcode{*this}.

\pnum
\effects Inserts copies of elements in \range{first}{last} after \tcode{position}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
  void insert_after(const_iterator position, initializer_list<T> il);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{insert_after(p, s.begin(), s.end())}.
\end{itemdescr}

\begin{itemdecl}
template <class... Args>
  @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@ 
  iterator emplace_after(const_iterator position, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}.

\pnum
\effects Inserts an object of type \tcode{value_type} constructed with \tcode{value_type(forward<Args>(args)...)} after \tcode{position}.
\end{itemdescr}

\begin{itemdecl}
iterator erase_after(const_iterator position);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The iterator following \tcode{position} is dereferenceable.

\pnum
\effects Erases the element pointed to by the iterator following \tcode{position}.

\pnum
\returns An iterator pointing to the element following the one that was erased, or \tcode{end()} if no such element exists.
\end{itemdescr}

\begin{itemdecl}
iterator erase_after(const_iterator position, iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires All iterators in the range \range{position}{last} are dereferenceable.

\pnum
\effects Erases the elements in the range \range{position}{last}.

\pnum
\returns \tcode{last}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T>}@ void resize(size_type sz);
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void resize(size_type sz, value_type c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < distance(begin(), end())}, erases the last \tcode{distance(begin(), end()) - sz} elements from the list. Otherwise, inserts \tcode{sz - distance(begin(), end())} elements at the end of the list. For the first signature the inserted elements are default constructed, and for the second signature they are copies of \tcode{c}.
\end{itemdescr}

\begin{itemdecl}
void clear();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Erases all elements in the range \range{begin()}{end()}.
\end{itemdescr}

\rSec3[forwardlist.ops]{\tcode{forward_list} operations}

\begin{itemdecl}
void splice_after(const_iterator position, forward_list<T,Alloc@\removedConcepts{ator}@>&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}. \tcode{\&x != this}.

\pnum
\effects Inserts the contents of \tcode{x} before \tcode{position}, and \tcode{x} becomes empty. Pointers and references to the moved elements of \tcode{x} now refer to those same elements but as members of \tcode{*this}. Iterators referring to the moved elements will continue to refer to their elements, but they now behave as iterators into \tcode{*this}, not into \tcode{x}.

\pnum
\throws Nothing.

\pnum
\complexity \bigoh{1}
\end{itemdescr}

\begin{itemdecl}
void splice_after(const_iterator position, forward_list<T,Alloc@\removedConcepts{ator}@>&& x, const_iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}. The iterator following \tcode{i} is a dereferenceable iterator in \tcode{x}.

\pnum
\effects Inserts the element following \tcode{i} into \tcode{*this}, following \tcode{position}, and removes it from \tcode{x}. Pointers and references to the moved elements of \tcode{x} now refer to those same elements but as members of \tcode{*this}. Iterators referring to the moved elements will continue to refer to their elements, but they now behave as iterators into \tcode{*this}, not into \tcode{x}.

\pnum
\throws Nothing.

\pnum
\complexity \bigoh{1}
\end{itemdescr}

\begin{itemdecl}
void splice_after(const_iterator position, forward_list<T,Alloc@\removedConcepts{ator}@>&& x, 
                  const_iterator first, const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{position} is dereferenceable or equal to \tcode{before_begin()}. \orange{first}{last} is a valid range in \tcode{x}, and all iterators in the range \orange{first}{last} are dereferenceable. \tcode{position} is not an iterator in the range \orange{first}{last}.

\pnum
\effects Inserts elements in the range \orange{first}{last} after \tcode{position} and removes the elements from \tcode{x}. Pointers and references to the moved elements of \tcode{x} now refer to those same elements but as members of \tcode{*this}. Iterators referring to the moved elements will continue to refer to their elements, but they now behave as iterators into \tcode{*this}, not into \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires EqualityComparable<T>}@ void remove(const T& value);
template <@\changedConcepts{class}{Predicate<auto, T>}@ Pred@\removedConcepts{icate}@> void remove_if(Pred@\removedConcepts{icate}@ pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects  Erases all the elements in the list referred by a list iterator \tcode{i} for which the following conditions hold: \tcode{*i == value} (for \tcode{remove()}), \tcode{pred(*i)} is true (for \tcode{remove_if()}). This operation shall be stable: the relative order of the elements that are not removed is the same as their relative order in the original list.

\pnum
\throws Nothing unless an exception is thrown by the equality comparison or the predicate.

\pnum
\complexity Exactly \tcode{distance(begin(), end())} applications of the corresponding predicate.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires EqualityComparable<T>}@ void unique();
template <@\changedConcepts{class}{EquivalenceRelation<auto, T>}@ BinaryPredicate>
  void unique(BinaryPredicate pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Eliminates all but the first element from every consecutive group of equal elements referred to by the iterator \tcode{i} in the range \range{first + 1}{last} for which \tcode{*i == *(i-1)} (for the version with no arguments) or \tcode{pred(*i, *(i - 1))} (for the version with a predicate argument) holds.

\pnum
\throws Nothing unless an exception is thrown by the equality comparison or the predicate.

\pnum
\complexity If the range \range{first}{last} is not empty, exactly \tcode{(last - first) - 1} applications of the corresponding predicate, otherwise no applications of the predicate.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires LessThanComparable<T>}@ void merge(forward_list<T,Alloc@\removedConcepts{ator}@>&& x);
template <@\changedConcepts{class}{StrictWeakOrder<auto, T>}@ Compare> 
  void merge(forward_list<T,Alloc@\removedConcepts{ator}@>&& x, Compare comp)
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires 
\removedConcepts{\mbox{\tcode{comp}} defines a strict weak ordering~(\mbox{\ref{alg.sorting}}), and} \tcode{*this} and \tcode{x} are both sorted according to 
\changedConcepts{this ordering}{the strict weak ordering defined by \mbox{\tcode{operator<}} or \mbox{\tcode{comp}}}.

\pnum
\effects Merges \tcode{x} into \tcode{*this}. This operation shall be stable: for equivalent elements in the two lists, the elements from \tcode{*this} shall always precede the elements from \tcode{x}. \tcode{x} is empty after the merge. If an exception is thrown other than by a comparison there are no effects.

\pnum
\complexity At most \tcode{size() + x.size() - 1} comparisons.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires LessThanComparable<T>}@ void sort();
template <@\changedConcepts{class}{StrictWeakOrder<auto, T>}@ Compare> void sort(Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{operator<}} (for the version with no arguments) or \mbox{\tcode{comp}} (for the version with a comparison argument) defines a strict weak ordering~(\mbox{\ref{alg.sorting}}).}

\pnum
\effects Sorts the list according to the \tcode{operator<} or the \tcode{comp} function object. This operation shall be stable: the relative order of the equivalent elements is preserved. If an exception is thrown the order of the elements in \tcode{*this} is unspecified.

\pnum
\complexity Approximately $N \log N$ comparisons, where $N$ is \tcode{distance(begin(), end())}.
\end{itemdescr}

\begin{itemdecl}
void reverse();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Reverses the order of the elements in the list.

\pnum
\throws Nothing.

\pnum
\complexity Linear time.
\end{itemdescr}

\rSec3[forwardlist.spec]{\tcode{forward_list} specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(forward_list<T,Alloc@\removedConcepts{ator}@>& x, forward_list<T,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(forward_list<T,Alloc@\removedConcepts{ator}@>&& x, forward_list<T,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(forward_list<T,Alloc@\removedConcepts{ator}@>& x, forward_list<T,Alloc@\removedConcepts{ator}@>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{x.swap(y)}
\end{itemdescr}

\rSec2[list]{Class template \tcode{list}}

\pnum
\index{list@\tcode{list}}%
A
\tcode{list}\
is a sequence container that supports
bidirectional iterators and allows constant time insert and erase
operations anywhere within the sequence, with storage management handled
automatically. Unlike vectors (\ref{vector}) and deques (\ref{deque}),
fast random access to list elements is not supported, but many
algorithms only need sequential access anyway.

\pnum
A \tcode{list}\ satisfies all of the requirements of a container, of
a reversible container (given in two tables in
\ref{container.requirements}), of a sequence container,
including most of the the optional sequence container
requirements (\ref{sequence.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
The exceptions are the
\tcode{operator[]}\
and
\tcode{at}\
member functions, which are not provided.%
\footnote{
These member functions are only provided by containers whose iterators
are random access iterators.
}
Descriptions are provided here only for operations on
\tcode{list}\
that are not described in one of these tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ T, @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<T> >
  @\addedConcepts{requires NothrowDestructible<T>}@
  class list {
  public:
    // types:
    typedef typename Alloc@\removedConcepts{ator}@::reference         reference;
    typedef typename Alloc@\removedConcepts{ator}@::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef T                                     value_type;
    typedef Alloc@\removedConcepts{ator}@                             allocator_type;
    typedef typename Alloc@\removedConcepts{ator}@::pointer           pointer;
    typedef typename Alloc@\removedConcepts{ator}@::const_pointer     const_pointer;
    typedef reverse_iterator<iterator>       reverse_iterator;
    typedef reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{list.cons} construct/copy/destroy:
    explicit list(const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    @\addedConcepts{requires AllocatableElement<Alloc, T>}@ explicit list(size_type n);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      list(size_type @\farg{n}@, const T& @\farg{value}@, const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
      list(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@, const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ list(const list<T,Alloc@\removedConcepts{ator}@>& @\farg{x}@);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ list(list&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ list(const list&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ list(list&&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@
      list(initializer_list<T>, const Allocator& = Allocator());
   ~list();
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ @\addedConcepts{\&\& CopyAssignable<T>}@
      list<T,Alloc@\removedConcepts{ator}@>& operator=(const list<T,Alloc@\removedConcepts{ator}@>& @\farg{x}@);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&> \&\& MoveAssignable<T>}@
      list<T,Alloc@\removedConcepts{ator}@>& operator=(list<T,Alloc@\removedConcepts{ator}@>&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& CopyAssignable<T>}@
      list<T,Alloc@\removedConcepts{ator}@>& operator=(initializer_list<T>);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
            @\addedConcepts{\&\& HasAssign<T, Iter::reference>}@
      void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ @\addedConcepts{\&\& CopyAssignable<T>}@
      void assign(size_type n, const T& t);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& CopyAssignable<T>}@
      void assign(initializer_list<T>);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // \ref{list.capacity} capacity:
    bool      empty() const;
    size_type size() const;
    size_type max_size() const;
    @\addedConcepts{requires AllocatableElement<Alloc, T>}@ void resize(size_type sz);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void resize(size_type sz, const T& c);

    // element access:
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{list.modifiers} modifiers:
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@
      void emplace_front(Args&&... args);
    void pop_front();
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@
      void emplace_back(Args&&... args);
    void pop_back();

    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_front(const T& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_front(T&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_back(const T& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_back(T&& x);

    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      iterator insert(const_iterator @\farg{position}@, const T& @\farg{x}@);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ 
      iterator insert(const_iterator position, T&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      void insert(const_iterator @\farg{position}@, size_type @\farg{n}@, const T& @\farg{x}@);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
      void insert(const_iterator @\farg{position}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{first}@,
                  @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@
      void insert(const_iterator position, initializer_list<T> il);

    iterator erase(const_iterator @\farg{position}@);
    iterator erase(const_iterator @\farg{position}@, const_iterator @\farg{last}@);
    void     swap(list<T,Alloc@\removedConcepts{ator}@>&&);
    void     clear();

    // \ref{list.ops} list operations:
    void splice(const_iterator @\farg{position}@, list<T,Alloc@\removedConcepts{ator}@>&& @\farg{x}@);
    void splice(const_iterator @\farg{position}@, list<T,Alloc@\removedConcepts{ator}@>&& @\farg{x}@, const_iterator @\farg{i}@);
    void splice(const_iterator @\farg{position}@, list<T,Alloc@\removedConcepts{ator}@>&& @\farg{x}@,
                const_iterator @\farg{first}@, const_iterator @\farg{last}@);

    @\addedConcepts{requires EqualityComparable<T>}@ void remove(const T& @\farg{value}@);
    template <@\changedConcepts{class}{Predicate<auto, T>}@ Pred@\removedConcepts{icate}@> void remove_if(Pred@\removedConcepts{icate}@ @\farg{pred}@);

    @\addedConcepts{requires EqualityComparable<T>}@ void unique();
    template <@\changedConcepts{class}{EquivalenceRelation<auto, T>}@ BinaryPredicate>
      void unique(BinaryPredicate @\farg{binary_pred}@);

    @\addedConcepts{requires LessThanComparable<T>}@ void merge(list<T,Alloc@\removedConcepts{ator}@>&& @\farg{x}@);
    template <@\changedConcepts{class}{StrictWeakOrder<auto, T>}@ Compare> 
      void merge(list<T,Alloc@\removedConcepts{ator}@>&& @\farg{x}@, Compare @\farg{comp}@);

    @\addedConcepts{requires LessThanComparable<T>}@ void sort();
    template <@\changedConcepts{class}{StrictWeakOrder<auto, T>}@ Compare> 
      void sort(Compare @\farg{comp}@);

    void reverse();
  };

  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator==(const list<T,Alloc@\removedConcepts{ator}@>& @\farg{x}@, const list<T,Alloc@\removedConcepts{ator}@>& @\farg{y}@);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator< (const list<T,Alloc@\removedConcepts{ator}@>& @\farg{x}@, const list<T,Alloc@\removedConcepts{ator}@>& @\farg{y}@);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const list<T,Alloc@\removedConcepts{ator}@>& @\farg{x}@, const list<T,Alloc@\removedConcepts{ator}@>& @\farg{y}@);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator> (const list<T,Alloc@\removedConcepts{ator}@>& @\farg{x}@, const list<T,Alloc@\removedConcepts{ator}@>& @\farg{y}@);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const list<T,Alloc@\removedConcepts{ator}@>& @\farg{x}@, const list<T,Alloc@\removedConcepts{ator}@>& @\farg{y}@);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const list<T,Alloc@\removedConcepts{ator}@>& @\farg{x}@, const list<T,Alloc@\removedConcepts{ator}@>& @\farg{y}@);

  // specialized algorithms:
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(list<T,Alloc@\removedConcepts{ator}@>& x, list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(list<T,Alloc@\removedConcepts{ator}@>&& x, list<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(list<T,Alloc@\removedConcepts{ator}@>& x, list<T,Alloc@\removedConcepts{ator}@>&& y);

  @\removedConcepts{template <class T, class Alloc>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<list<T, Alloc> >}@
      @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}

\rSec3[list.cons]{\tcode{list}\ constructors, copy, and assignment}

\begin{itemdecl}
explicit list(const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty list, using the specified allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T>}@ explicit list(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{list} with
\tcode{n} default constructed elements.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{DefaultConstructible}}.}

\pnum
\complexity
Linear in
\tcode{n}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@
  list(size_type @\farg{n}@, const T& @\farg{value}@,
                const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs a
\tcode{list}\
with
\tcode{n}\
copies of
\tcode{value},
using the specified allocator.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}

\pnum
\complexity\ 
Linear in
\tcode{n}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
  list(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@, const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs a
\tcode{list}\
equal to the range
\range{\farg{first}}{\farg{last}}.

\pnum
\complexity\ 
Linear in
\tcode{distance(\farg{first}, \farg{last})}.
\end{itemdescr}

\index{assign@\tcode{assign}!\tcode{list}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
        @\addedConcepts{\&\& HasAssign<T, Iter::reference>}@
  void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Replaces the contents of the list with the range
\tcode{[first, last)}.

\begin{codeblock}
erase(begin(), end());
insert(begin(), n, t);
\end{codeblock}

\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>} \addedConcepts{\&\& CopyAssignable<T>}@
  void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Replaces the contents of the list with \farg{n}\ copies of \farg{t}.
\end{itemdescr}

\rSec3[list.capacity]{\tcode{list}\ capacity}

\index{resize@\tcode{resize}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T>}@ void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, equivalent to
\tcode{list<T>::iterator it = begin();}
\tcode{advance(it, sz);}
\tcode{erase(it, end());}. If \tcode{size() < sz},
appends \tcode{sz - size()} default constructed elements to the
sequence.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be
\mbox{\tcode{DefaultConstructible}}.}
\end{itemdescr}

\index{resize@\tcode{resize}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void resize(size_type sz, const T& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
if (sz > size())
  insert(end(), sz-size(), c);
else if (sz < size()) {
  iterator i = begin();
  advance(i, sz);
  erase(i, end());
}
else
  ;                 // do nothing
\end{codeblock}

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}
\end{itemdescr}

\rSec3[list.modifiers]{\tcode{list}\ modifiers}

\index{insert@\tcode{insert}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
  iterator insert(const_iterator position, const T& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ 
  iterator insert(const_iterator position, T&& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
  void insert(const_iterator @\farg{position}@, size_type @\farg{n}@, const T& @\farg{x}@);
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
  void insert(const_iterator @\farg{position}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{first}@,
              @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@);

template <class... Args> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@
  void emplace_front(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@
  void emplace_back(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@
  iterator emplace(const_iterator position, Args&&... args);
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_front(const T& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_front(T&& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_back(const T& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_back(T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes\ 
Does not affect the validity of iterators and references.
If an exception is thrown there are no effects.

\pnum
\complexity\ 
Insertion of a single element into a list takes constant time and
exactly one call to a constructor of
\tcode{T}. Insertion of multiple elements into a list is linear in the
number of elements inserted, and the number of calls to the copy
constructor or move constructor of \tcode{T}\ is exactly equal
to the number of elements inserted.
\end{itemdescr}

\index{erase@\tcode{erase}!\tcode{list}}%
\begin{itemdecl}
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);

void pop_front();
void pop_back();
void clear();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Invalidates only the iterators and references to the erased elements.

\pnum
\throws\ 
Nothing.

\pnum
\complexity\ 
Erasing a single element is a constant time operation with a single call to the destructor of
\tcode{T}.
Erasing a range in a list is linear time in the
size of the range and the number of calls to the destructor of type
\tcode{T}\
is exactly equal to the size of the range.
\end{itemdescr}

\rSec3[list.ops]{\tcode{list}\ operations}

\pnum
Since lists allow fast insertion and erasing from the middle of a list, certain operations are provided
specifically for them.%
\footnote{As specified in~\ref{allocator.requirements}, the requirements
in this clause apply only to lists whose allocators compare equal.
}

\pnum
\tcode{list}\
provides three splice operations that destructively move elements from one list to another. The behavior of splice operations is undefined if \tcode{get_allocator() != x.get_allocator()}.

\index{splice@\tcode{splice}!\tcode{list}}%
\begin{itemdecl}
void splice(const_iterator @\farg{position}@, list<T,Alloc@\removedConcepts{ator}@>&& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\ 
\tcode{\&\farg{x} != this}.

\pnum
\effects\ 
Inserts the contents of
\tcode{x}
before
\tcode{position}
and
\tcode{x}
becomes empty.
Pointers and references to the moved elements of
\tcode{x}\
now refer to those same elements but as members of
\tcode{*this}.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into
\tcode{*this},
not into
\tcode{x}.

\pnum
\throws\ 
Nothing

\pnum
\complexity\ 
Constant time.
\end{itemdescr}

\begin{itemdecl}
void splice(const_iterator @\farg{position}@, list<T,Alloc@\removedConcepts{ator}@>&& @\farg{x}@, iterator @\farg{i}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Inserts an element pointed to by
\tcode{i}\
from list
\tcode{x}\
before \tcode{position}\ and removes the element from
\tcode{x}.
The result is unchanged if
\tcode{position == i}
or
\tcode{position == ++i}.
Pointers and references to
\tcode{*i}\
continue to refer to this same element but as a member of
\tcode{*this}.
Iterators
to
\tcode{*i}\
(including
\tcode{i}\
itself) continue to refer to the same element, but now behave as iterators into
\tcode{*this},
not into
\tcode{x}.

\pnum
\throws\ 
Nothing

\pnum
\requires\ 
\tcode{i}\
is a valid dereferenceable iterator of
\tcode{x}.

\pnum
\complexity\ 
Constant time.
\end{itemdescr}

\begin{itemdecl}
void splice(const_iterator @\farg{position}@, list<T,Alloc@\removedConcepts{ator}@>&& @\farg{x}@, iterator @\farg{first}@,
            iterator @\farg{last}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Inserts elements in the range
\range{first}{last}\
before
\tcode{position}
and removes the elements from
\tcode{x}.

\pnum
\requires\ 
\tcode{[first, last)}
is a valid range in
\tcode{x}.
The result is undefined if
\tcode{position}
is an iterator in the range
\range{first}{last}.
Pointers and references to the moved elements of
\tcode{x}\
now refer to those same elements but as members of
\tcode{*this}.
Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into
\tcode{*this},
not into
\tcode{x}.

\pnum
\throws\ 
Nothing

\pnum
\complexity\ 
Constant time if
\tcode{\&\farg{x} == this};
otherwise, linear time.
\end{itemdescr}

\index{remove@\tcode{remove}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires EqualityComparable<T>}@ void remove(const T& @\farg{value}@);
template <@\changedConcepts{class}{Predicate<auto, T>}@ Pred@\removedConcepts{icate}@> void remove_if(Pred@\removedConcepts{icate}@ @\farg{pred}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Erases all the elements in the list referred by a list iterator
\tcode{i}
for which the following conditions hold:
\tcode{*i == value, pred(*i) != false}.

\pnum
\throws\ 
Nothing unless an exception is thrown by
\tcode{*i == value}
or
\tcode{\farg{pred}(*i) != false}.

\pnum
\notes\ 
Stable.

\pnum
\complexity\ 
Exactly
\tcode{size()}
applications of the corresponding predicate.
\end{itemdescr}

\index{unique@\tcode{unique}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires EqualityComparable<T>}@ void unique();
template <@\changedConcepts{class}{EquivalenceRelation<auto, T>}@ BinaryPredicate> void unique(BinaryPredicate @\farg{binary_pred}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Eliminates all but the first element from every
consecutive group of equal elements referred to by the
iterator
\tcode{i}\
in the range
\range{\farg{first} + 1}{\farg{last}}\
for which
\tcode{*i == *(i-1)}
(for the version of
\tcode{unique}\
with no arguments) or
\tcode{\farg{pred}(*i, *(i - 1))}\
(for the version of
\tcode{unique}
with a predicate argument)
holds.

\pnum
\throws\ 
Nothing unless an exception in thrown by
\tcode{*i == *(i-1)}\
or
\tcode{\farg{pred}(*i, *(i - 1))}\

\pnum
\complexity\ 
If the range
\tcode{[\farg{first}, \farg{last})}\
is not empty, exactly
\tcode{(\farg{last} - \farg{first}) - 1}
applications of the corresponding predicate,
otherwise no applications of the predicate.
\end{itemdescr}

\index{merge@\tcode{merge}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires LessThanComparable<T>}@ void merge(list<T,Alloc@\removedConcepts{ator}@>&& @\farg{x}@);
template <@\changedConcepts{class}{StrictWeakOrder<auto, T>}@ Compare> 
  void merge(list<T,Alloc@\removedConcepts{ator}@>&& @\farg{x}@, Compare @\farg{comp}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\ 
\removedConcepts{\mbox{\farg{comp}} shall define a strict weak ordering
(\mbox{\ref{alg.sorting}}), and} both the list and the argument list shall be
sorted according to \changedConcepts{this ordering}{\mbox{\tcode{operator<}} or \mbox{\tcode{comp}}}.

\pnum
\effects\ 
If
\tcode{(\&x == this)}\
does nothing; otherwise, merges the two sorted ranges
\tcode{[begin(), end())}\
and
\tcode{[x.\brk{}begin(), x.end())}.
The result is a range in which the elements will be sorted in non-decreasing
order according to the ordering defined by \tcode{comp};
that is, for every iterator \tcode{i}, in the range other than the first,
the condition
\tcode{comp(*i, *(i - 1)}\
will be false.

\pnum
\notes\ 
Stable. If \tcode{(\&x != this)}\ the range \tcode{[x.begin(), x.end())}\
is empty after the merge.

\pnum
\complexity\ 
At most
\tcode{size() + x.size() - 1}\
applications of \tcode{comp}\ if
\tcode{(\&x != this)};
otherwise, no applications of \tcode{comp}\ are performed.
If an exception is thrown other than by a comparison there are no effects.
\end{itemdescr}

\index{reverse@\tcode{reverse}!\tcode{list}}%
\begin{itemdecl}
void reverse();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Reverses the order of the elements in the list.

\pnum
\throws\ 
Nothing.

\pnum
\complexity\ 
Linear time.
\end{itemdescr}

\index{sort@\tcode{sort}!\tcode{list}}%
\begin{itemdecl}
@\addedConcepts{requires LessThanComparable<T>}@ void sort();
template <@\changedConcepts{class}{StrictWeakOrder<auto, T>}@ Compare> void sort(Compare @\farg{comp}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}
\mbox{\tcode{operator<}}
(for the first
version)
or
\mbox{\farg{comp}}
(for the second version)
shall define a strict weak ordering (\mbox{\ref{alg.sorting}}).}

\pnum
\effects\ 
Sorts the list according to the
\tcode{operator<}\
or a
\tcode{Compare}\
function object.

\pnum
\notes\ 
Stable.

\pnum
\complexity\ 
Approximately
$N \log(N)$
comparisons, where
\tcode{N == size()}.
\end{itemdescr}

\rSec3[list.special]{\tcode{list}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(list<T,Alloc@\removedConcepts{ator}@>& x, list<T,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(list<T,Alloc@\removedConcepts{ator}@>&& x, list<T,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(list<T,Alloc@\removedConcepts{ator}@>& x, list<T,Alloc@\removedConcepts{ator}@>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[container.adaptors]{Container adaptors}

\pnum
The container adaptors each take a \tcode{Container} template parameter, and each constructor takes a \tcode{Container} reference argument. This container is copied into the \tcode{Container} member of each adaptor. If the container takes an allocator, then a compatible allocator may be passed in to the adaptor's constructor. Otherwise, normal copy or move construction is used for the container argument. \enternote it is not necessary for an implementation to distinguish between the one-argument constructor that takes a \tcode{Container} and the one-argument constructor that takes an \tcode{allocator_type}. Both forms use their argument to construct an instance of the container. \exitnote

\rSec3[queue]{Class template \tcode{queue}}

\pnum
\index{queue@\tcode{queue}}%
Any sequence container \changedConcepts{supporting operations
\mbox{\tcode{front()}},
\mbox{\tcode{back()}},
\mbox{\tcode{push_back()}}
and
\mbox{\tcode{pop_front()}}}{meeting the requirements of the
\mbox{\tcode{FrontInsertionContainer}} and
\mbox{\tcode{BackInsertionContainer}} concepts}
can be used to instantiate
\tcode{queue}.
In particular,
\tcode{list}\
(\ref{list})
and
\tcode{deque}\
(\ref{deque})
can be used.

\rSec4[queue.defn]{\tcode{queue} definition}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Cont@\removedConcepts{ainer}@ = deque<T> >
  @\addedConcepts{requires QueueLikeContainer<Cont>}@
        @\addedConcepts{\&\& SameType<T, Cont::value_type>}@
        @\addedConcepts{\&\& NothrowDestructible<Cont>}@
  class queue {
  public:
    typedef typename Cont@\removedConcepts{ainer}@::value_type            value_type;
    typedef typename Cont@\removedConcepts{ainer}@::reference             reference;
    typedef typename Cont@\removedConcepts{ainer}@::const_reference       const_reference;
    typedef typename Cont@\removedConcepts{ainer}@::size_type             size_type;
    typedef          Cont@\removedConcepts{ainer}@                        container_type;
  protected:
    Cont@\removedConcepts{ainer}@ c;

  public:
    @\addedConcepts{requires CopyConstructible<Cont>}@ explicit queue(const Cont@\removedConcepts{ainer}@&);
    @\addedConcepts{requires MoveConstructible<Cont>}@ explicit queue(Cont@\removedConcepts{ainer}@&& = Cont@\removedConcepts{ainer}@());
    @\addedConcepts{requires MoveConstructible<Cont>}@ queue(queue&& q) : c(move(q.c)) {}
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, const Alloc\&>}@
      explicit queue(const Alloc&);
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, const Cont\&, const Alloc\&>}@
      queue(const Cont@\removedConcepts{ainer}@&, const Alloc&);
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, Cont\&\&, const Alloc\&>}@
      queue(Cont@\removedConcepts{ainer}@&&, const Alloc&);
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, Cont\&\&, const Alloc\&>}@
      queue(queue&&, const Alloc&);
    @\addedConcepts{requires MoveAssignable<Cont>}@ queue& operator=(queue&& q)
                                        { c = move(q.c); return *this; }

    bool              empty() const     { return @\removedConcepts{c.}@empty(@\addedConcepts{c}@); }
    size_type         size()  const     { return @\removedConcepts{c.}@size(@\addedConcepts{c}@); }
    reference         front()           { return @\removedConcepts{c.}@front(@\addedConcepts{c}@); }
    const_reference   front() const     { return @\removedConcepts{c.}@front(@\addedConcepts{c}@); }
    reference         back()            { return @\removedConcepts{c.}@back(@\addedConcepts{c}@); }
    const_reference   back() const      { return @\removedConcepts{c.}@back(@\addedConcepts{c}@); }
    void push(const value_type& x)      { @\removedConcepts{c.}@push_back(@\addedConcepts{c, }@x); }
    void push(value_type&& x)           { @\removedConcepts{c.}@push_back(@\addedConcepts{c, }@move(x)); }
    template <class... Args> 
      @\addedConcepts{requires BackEmplacementContainer<Cont, Args\&\&...>}@
      void emplace(Args&&... args)
      { @\removedConcepts{c.}@emplace_back(@\addedConcepts{c, }@forward<Args>(args)...); }
    void pop()                          { @\removedConcepts{c.}@pop_front(@\addedConcepts{c}@); }    
    @\addedConcepts{requires Swappable<Cont>}@
      void swap(queue&& q)              { @\removedConcepts{c.}@swap(@\addedConcepts{c, }@q.c); }
  };

  template <class T, @\changedConcepts{class}{EqualityComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator==(const queue<T, Cont@\removedConcepts{ainer}@>& x, const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator< (const queue<T, Cont@\removedConcepts{ainer}@>& x, const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{EqualityComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator!=(const queue<T, Cont@\removedConcepts{ainer}@>& x, const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator> (const queue<T, Cont@\removedConcepts{ainer}@>& x, const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator>=(const queue<T, Cont@\removedConcepts{ainer}@>& x, const queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator<=(const queue<T, Cont@\removedConcepts{ainer}@>& x, const queue<T, Cont@\removedConcepts{ainer}@>& y);

  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(queue<T, Cont@\removedConcepts{ainer}@>& x, queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(queue<T, Cont@\removedConcepts{ainer}@>&& x, queue<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(queue<T, Cont@\removedConcepts{ainer}@>& x, queue<T, Cont@\removedConcepts{ainer}@>&& y);

  @\addedConcepts{template <class T, class Cont, class Alloc>}@
    @\addedConcepts{requires UsesAllocator<Cont, Alloc>}@
    @\addedConcepts{concept_map UsesAllocator<queue<T, Cont>, Alloc> \{ \}}@

  @\removedConcepts{template <class T, class Container, class Alloc>}@
    @\removedConcepts{struct uses_allocator<queue<T, Container>, Alloc>}@
      @\removedConcepts{: uses_allocator<Container, Alloc>::type \{ \};}@

  @\removedConcepts{template <class T, class Container>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<queue<T, Container> >}@
      @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}

\rSec4[queue.ops]{\tcode{queue} operators}

\index{operator==@\tcode{operator==}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, @\changedConcepts{class}{EqualityComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator==(const queue<T, Cont@\removedConcepts{ainer}@>& x,
                    const queue<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c == y.c}.
\end{itemdescr}

\index{operator"!=@\tcode{operator"!=}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, @\changedConcepts{class}{EqualityComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator!=(const queue<T, Cont@\removedConcepts{ainer}@>& x,
                    const queue<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c != y.c}.
\end{itemdescr}

\index{operator<@\tcode{operator<}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator< (const queue<T, Cont@\removedConcepts{ainer}@>& x,
                    const queue<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c < y.c}.
\end{itemdescr}

\index{operator<=@\tcode{operator<=}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator<=(const queue<T, Cont@\removedConcepts{ainer}@>& x,
                    const queue<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c <= y.c}.
\end{itemdescr}

\index{operator>@\tcode{operator>}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator> (const queue<T, Cont@\removedConcepts{ainer}@>& x,
                    const queue<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c > y.c}.
\end{itemdescr}

\index{operator>=@\tcode{operator>=}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, @\changedConcepts{class}{LessThanComparable}@ Cont@\removedConcepts{ainer}@>
    bool operator>=(const queue<T, Cont@\removedConcepts{ainer}@>& x,
                    const queue<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c >= y.c}.
\end{itemdescr}

\rSec4[queue.special]{\tcode{queue} specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
  void swap(queue<T, Cont@\removedConcepts{ainer}@>& x, queue<T, Cont@\removedConcepts{ainer}@>& y);
template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
  void swap(queue<T, Cont@\removedConcepts{ainer}@>&& x, queue<T, Cont@\removedConcepts{ainer}@>& y);
template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
  void swap(queue<T, Cont@\removedConcepts{ainer}@>& x, queue<T, Cont@\removedConcepts{ainer}@>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{x.swap(y)}.
\end{itemdescr}

\rSec3[priority.queue]{Class template \tcode{priority_queue}}

\pnum
\index{priority_queue@\tcode{priority_queue}}%
Any sequence container with random access iterator and \changedConcepts{supporting operations
\mbox{\tcode{front()}},
\mbox{\tcode{push_back()}}
and
\mbox{\tcode{pop_back()}}}{that meets the requirements of the
\mbox{\tcode{BackInsertionContainer}} concept}
can be used to instantiate
\tcode{priority_queue}.
In particular,
\tcode{vector}\
(\ref{vector})
and
\tcode{deque}\
(\ref{deque})
can be used.
Instantiating
\tcode{priority_queue}\
also involves supplying a function or function object for making
priority comparisons; the library assumes that the function or function
object defines a strict weak ordering (\ref{alg.sorting}).

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{StackLikeContainer}@ Cont@\removedConcepts{ainer}@ = vector<T>,
            @\changedConcepts{class}{StrictWeakOrder<auto, T>}@ Compare = less<typename Cont@\removedConcepts{ainer}@::value_type> >
  @\addedConcepts{requires SameType<Cont::value_type, T> \&\& RandomAccessIterator<Cont::iterator>}@
        @\addedConcepts{\&\& ShuffleIterator<Cont::iterator> \&\& CopyConstructible<Compare>}@
        @\addedConcepts{\&\& NothrowDestructible<Cont>}@
  class priority_queue { 
  public:
    typedef typename Cont@\removedConcepts{ainer}@::value_type            value_type;
    typedef typename Cont@\removedConcepts{ainer}@::reference             reference;
    typedef typename Cont@\removedConcepts{ainer}@::const_reference       const_reference;
    typedef typename Cont@\removedConcepts{ainer}@::size_type             size_type;
    typedef          Cont@\removedConcepts{ainer}@                        container_type;
  protected:
    Cont@\removedConcepts{ainer}@ c;
    Compare comp;

  public:
    @\addedConcepts{requires CopyConstructible<Cont>}@ priority_queue(const Compare& x, const Cont@\removedConcepts{ainer}@&);
    @\addedConcepts{requires MoveConstructible<Cont>}@ 
      explicit priority_queue(const Compare& x = Compare(), Cont@\removedConcepts{ainer}@&& = Cont@\removedConcepts{ainer}@());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires CopyConstructible<Cont> \&\& RangeInsertionContainer<Cont, Iter>}@
      priority_queue(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
             const Compare& x, const Cont@\removedConcepts{ainer}@&);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires MoveConstructible<Cont> \&\& RangeInsertionContainer<Cont, Iter>}@
      priority_queue(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
             const Compare& x = Compare(), Cont@\removedConcepts{ainer}@&& = Cont@\removedConcepts{ainer}@());
    @\addedConcepts{requires MoveConstructible<Cont>}@ priority_queue(priority_queue&&);
    @\addedConcepts{requires MoveAssignable<Cont>}@ priority_queue& operator=(priority_queue&&);
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, const Alloc\&>}@
      explicit priority_queue(const Alloc&);
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, const Alloc\&>}@
      priority_queue(const Compare&, const Alloc&);
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, Cont, Alloc>}@
      priority_queue(const Compare&, const Cont@\removedConcepts{ainer}@&, const Alloc&);
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, Cont\&\&, Alloc>}@
      priority_queue(const Compare&, Cont@\removedConcepts{ainer}@&&, const Alloc&);
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, Cont\&\&, Alloc>}@
      priority_queue(priority_queue&&, const Alloc&);

    bool      empty() const       { return @\removedConcepts{c.}@empty(@\addedConcepts{c}@); }
    size_type size()  const       { return @\removedConcepts{c.}@size(@\addedConcepts{c}@); }
    const_reference   top() const { return @\changedConcepts{c.front()}{*begin(c)}@); }
    void push(const value_type& x);
    void push(value_type&& x);
    template <class... Args> 
      @\addedConcepts{requires BackEmplacementContainer<Cont, Args\&\&...>}@
      void emplace(Args&&... args);
    void pop();
    @\addedConcepts{requires Swappable<Cont>}@
      void swap(priority_queue&&);
  };
                // no equality is provided
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@, @\addedConcepts{Swappable}@ Compare>
    void swap(priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& x, priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@, @\addedConcepts{Swappable}@ Compare>
    void swap(priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>&& x, priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@, @\addedConcepts{Swappable}@ Compare>
    void swap(priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& x, priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>&& y);

  @\addedConcepts{template <class T, class Cont, class Compare, class Alloc>}@
    @\addedConcepts{requires UsesAllocator<Cont, Alloc>}@
    @\addedConcepts{concept_map UsesAllocator<priority_queue<T, Cont, Compare>, Alloc> \{ \}}@

  @\removedConcepts{template <class T, class Container, class Compare, class Alloc>}@
    @\removedConcepts{struct uses_allocator<priority_queue<T, Container, Compare>, Alloc>}@
      @\removedConcepts{: uses_allocator<Container, Alloc>::type \{ \};}@

  @\removedConcepts{template <class T, class Container, class Compare>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<}@
      @\removedConcepts{priority_queue<T, Container, Compare> >}@
      @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}

\rSec4[priqueue.cons]{\tcode{priority_queue}\ constructors}

\index{priority_queue@\tcode{priority_queue}!\tcode{priority_queue}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<Cont>}@ priority_queue(const Compare& x, const Cont@\removedConcepts{ainer}@& y);

@\addedConcepts{requires MoveConstructible<Cont>}@ 
explicit priority_queue(const Compare& x = Compare(), Cont@\removedConcepts{ainer}@&& y = Cont@\removedConcepts{ainer}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}
\mbox{\farg{x}} shall define a strict weak ordering (\mbox{\ref{alg.sorting}}).}

\pnum
\effects\ 
Initializes
\tcode{comp}\ with
\tcode{x}\ and
\tcode{c}\ with
\tcode{y} (copy constructing or move constructing as appropriate);
calls
\tcode{make_heap(\removedConcepts{c.}begin(\addedConcepts{c}), \removedConcepts{c.}end(\addedConcepts{c}), comp)}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires CopyConstructible<Cont> \&\& RangeInsertionContainer<Cont, Iter>}@
  priority_queue(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
         const Compare& x, const Cont@\removedConcepts{ainer}@&);
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires MoveConstructible<Cont> \&\& RangeInsertionContainer<Cont, Iter>}@
  priority_queue(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
         const Compare& x = Compare(), Cont@\removedConcepts{ainer}@&& = Cont@\removedConcepts{ainer}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}
\mbox{\farg{x}} shall define a strict weak ordering (\mbox{\ref{alg.sorting}}).}

\pnum
\effects\ 
Initializes
\tcode{comp} with
\tcode{x} and
\tcode{c} with
\tcode{y} (copy constructing or move constructing as appropriate);
calls
\tcode{\removedConcepts{c.}insert(\addedConcepts{c, }\removedConcepts{c.}end(\addedConcepts{c}), first, last)};
and finally calls
\tcode{make_heap(\removedConcepts{c.}begin(\addedConcepts{c}), \removedConcepts{c.}end(\addedConcepts{c}), comp)}.
\end{itemdescr}

\rSec4[priqueue.members]{\tcode{priority_queue}\ members}

\index{push@\tcode{push}!\tcode{priority_queue}}%
\begin{itemdecl}
void push(const value_type& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
@\removedConcepts{c.}@push_back(@\addedConcepts{c, }@x);
push_heap(@\removedConcepts{c.}@begin(@\addedConcepts{c}@), @\removedConcepts{c.}@end(@\addedConcepts{c}@), comp);
\end{codeblock}
\end{itemdescr}

\index{push@\tcode{push}!\tcode{priority_queue}}%
\begin{itemdecl}
void push(value_type&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
@\removedConcepts{c.}@push_back(@\addedConcepts{c, }@move(x));
push_heap(@\removedConcepts{c.}@begin(@\addedConcepts{c}@), @\removedConcepts{c.}@end(@\addedConcepts{c}@), comp);
\end{codeblock}
\end{itemdescr}

\index{emplace@\tcode{emplace}!\tcode{priority_queue}}%
\begin{itemdecl}
template <class... Args> 
  @\addedConcepts{requires BackEmplacementContainer<Cont, Args\&\&...>}@
  void emplace(Args&&... args);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
@\removedConcepts{c.}@emplace_back(@\addedConcepts{c, }@forward<Args>(args)...);
push_heap(@\removedConcepts{c.}@begin(@\addedConcepts{c}@), @\removedConcepts{c.}@end(@\addedConcepts{c}@), comp);
\end{codeblock}
\end{itemdescr}

\index{pop@\tcode{pop}!\tcode{priority_queue}}%
\begin{itemdecl}
void pop();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
pop_heap(@\removedConcepts{c.}@begin(@\addedConcepts{c}@), @\removedConcepts{c.}@end(@\addedConcepts{c}@), comp);
@\removedConcepts{c.}@pop_back(@\addedConcepts{c}@);
\end{codeblock}
\end{itemdescr}

\rSec4[priqueue.special]{\tcode{priority_queue} specialized algorithms}

\begin{itemdecl}
template <class T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@, @\changedConcepts{class}{Swappable}@ Compare>
  void swap(priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& x, priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& y);
template <class T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@, @\changedConcepts{class}{Swappable}@ Compare>
  void swap(priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>&& x, priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& y);
template <class T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@, @\changedConcepts{class}{Swappable}@ Compare>
  void swap(priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>& x, priority_queue<T, Cont@\removedConcepts{ainer}@, Compare>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{x.swap(y)}.
\end{itemdescr}

\rSec3[stack]{Class template \tcode{stack}}

\pnum
\index{stack@\tcode{stack}}%
Any sequence container \changedConcepts{supporting operations
\mbox{\tcode{back()}},
\mbox{\tcode{push_back()}}
and
\mbox{\tcode{pop_back()}}}{that meets the requirements of the 
\mbox{\tcode{BackInsertionContainer}} concept}
can be used to instantiate
\tcode{stack}.
In particular,
\tcode{vector}\
(\ref{vector}),
\tcode{list}\
(\ref{list})
and
\tcode{deque}\
(\ref{deque})
can be used.

\rSec4[stack.defn]{\tcode{stack} definition}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{StackLikeContainer}@ Cont@\removedConcepts{ainer}@ = deque<T> >
  @\addedConcepts{requires SameType<Cont::value_type, T>}@
        @\addedConcepts{\&\& NothrowDestructible<Cont>}@
  class stack {
  public:
    typedef typename Cont@\removedConcepts{ainer}@::value_type            value_type;
    typedef typename Cont@\removedConcepts{ainer}@::reference             reference;
    typedef typename Cont@\removedConcepts{ainer}@::const_reference       const_reference;
    typedef typename Cont@\removedConcepts{ainer}@::size_type             size_type;
    typedef          Cont@\removedConcepts{ainer}@                        container_type;
  protected:
    Cont@\removedConcepts{ainer}@ c;

  public:
    @\addedConcepts{requires CopyConstructible<Cont>}@ explicit stack(const Cont@\removedConcepts{ainer}@&);
    @\addedConcepts{requires MoveConstructible<Cont>}@ explicit stack(Cont@\removedConcepts{ainer}@&& = Cont@\removedConcepts{ainer}@());
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, const Alloc\&>}@
      explicit stack(const Alloc&);
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, const Cont\&, const Alloc\&>}@
      stack(const Cont@\removedConcepts{ainer}@&, const Alloc&);
    template <class Alloc> 
      @\addedConcepts{requires Constructible<Cont, Cont\&\&, const Alloc\&>}@
      stack(Cont@\removedConcepts{ainer}@&&, const Alloc&);
    template <class Alloc> 
      @\addedConcepts{Constructible<Cont, Cont\&\&, const Alloc\&>}@
      stack(stack&&, const Alloc&);

    bool      empty() const             { return @\removedConcepts{c.}@empty(@\addedConcepts{c}@); }
    size_type size()  const             { return @\removedConcepts{c.}@size(@\addedConcepts{c}@); }
    reference         top()             { return @\removedConcepts{c.}@back(@\addedConcepts{c}@); }
    const_reference   top() const       { return @\removedConcepts{c.}@back(@\addedConcepts{c}@); }
    void push(const value_type& x)      { @\removedConcepts{c.}@push_back(@\addedConcepts{c, }@x); }
    void push(value_type&& x)           { @\removedConcepts{c.}@push_back(@\addedConcepts{c, }@move(x)); }
    template <class... Args> 
      @\addedConcepts{requires BackEmplacementContainer<Cont, Args\&\&...>}@
      void emplace(Args&&... args)
      { @\removedConcepts{c.}@emplace_back(@\addedConcepts{c, }@forward<Args>(args)...); }
    void pop()                          { @\removedConcepts{c.}@pop_back(@\addedConcepts{c}@); }
    @\addedConcepts{requires Swappable<Cont>}@
      void swap(stack&& s)              { @\removedConcepts{c.}@swap(@\addedConcepts{c, }@s.c); }
  };

  template <@\changedConcepts{class}{EqualityComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator==(const stack<T, Cont@\removedConcepts{ainer}@>& x, const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator< (const stack<T, Cont@\removedConcepts{ainer}@>& x, const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator!=(const stack<T, Cont@\removedConcepts{ainer}@>& x, const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator> (const stack<T, Cont@\removedConcepts{ainer}@>& x, const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator>=(const stack<T, Cont@\removedConcepts{ainer}@>& x, const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator<=(const stack<T, Cont@\removedConcepts{ainer}@>& x, const stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(stack<T, Cont@\removedConcepts{ainer}@>& x, stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(stack<T, Cont@\removedConcepts{ainer}@>&& x, stack<T, Cont@\removedConcepts{ainer}@>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
    void swap(stack<T, Cont@\removedConcepts{ainer}@>& x, stack<T, Cont@\removedConcepts{ainer}@>&& y);

  @\addedConcepts{template <class T, class Cont, class Alloc>}@
    @\addedConcepts{requires UsesAllocator<Cont, Alloc>}@
    @\addedConcepts{concept_map UsesAllocator<stack<T, Cont>, Alloc> \{ \}}@

  @\removedConcepts{template <class T, class Container, class Alloc>}@
    @\removedConcepts{struct uses_allocator<stack<T, Container>, Alloc>}@
      @\removedConcepts{: uses_allocator<Container, Alloc>::type \{ \};}@

  @\removedConcepts{template <class T, class Container>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<stack<T, Container> >}@
      @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}

\rSec4[stack.ops]{\tcode{stack} operators}

\index{operator==@\tcode{operator==}!stack@\tcode{stack}}%
\begin{itemdecl}
template <@\changedConcepts{class}{EqualityComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator==(const stack<T, Cont@\removedConcepts{ainer}@>& x,
                    const stack<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c == y.c}.
\end{itemdescr}

\index{operator"!=@\tcode{operator"!=}!stack@\tcode{stack}}%
\begin{itemdecl}
template <@\changedConcepts{class}{EqualityComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator!=(const stack<T, Cont@\removedConcepts{ainer}@>& x,
                    const stack<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c != y.c}.
\end{itemdescr}

\index{operator<@\tcode{operator<}!stack@\tcode{stack}}%
\begin{itemdecl}
template <@\changedConcepts{class}{LessThanComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator< (const stack<T, Cont@\removedConcepts{ainer}@>& x,
                    const stack<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c < y.c}.
\end{itemdescr}

\index{operator<=@\tcode{operator<=}!stack@\tcode{stack}}%
\begin{itemdecl}
template <@\changedConcepts{class}{LessThanComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator<=(const stack<T, Cont@\removedConcepts{ainer}@>& x,
                    const stack<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c <= y.c}.
\end{itemdescr}

\index{operator>@\tcode{operator>}!stack@\tcode{stack}}%
\begin{itemdecl}
template <@\changedConcepts{class}{LessThanComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator> (const stack<T, Cont@\removedConcepts{ainer}@>& x,
                    const stack<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c > y.c}.
\end{itemdescr}

\index{operator>=@\tcode{operator>=}!stack@\tcode{stack}}%
\begin{itemdecl}
template <@\changedConcepts{class}{LessThanComparable}@ T, class Cont@\removedConcepts{ainer}@>
    bool operator>=(const stack<T, Cont@\removedConcepts{ainer}@>& x,
                    const stack<T, Cont@\removedConcepts{ainer}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c >= y.c}.
\end{itemdescr}

\rSec4[stack.special]{\tcode{stack} specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
  void swap(stack<T, Cont@\removedConcepts{ainer}@>& x, stack<T, Cont@\removedConcepts{ainer}@>& y);
template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
  void swap(stack<T, Cont@\removedConcepts{ainer}@>&& x, stack<T, Cont@\removedConcepts{ainer}@>& y);
template <@\changedConcepts{class}{ObjectType}@ T, @\changedConcepts{class}{Swappable}@ Cont@\removedConcepts{ainer}@>
  void swap(stack<T, Cont@\removedConcepts{ainer}@>& x, stack<T, Cont@\removedConcepts{ainer}@>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{x.swap(y)}.
\end{itemdescr}


\rSec2[vector]{Class template \tcode{vector}}

\pnum
\index{vector@\tcode{vector}}%
A
\tcode{vector}\
is a sequence container that supports random access iterators.
In addition, it supports (amortized) constant time insert and erase operations at the end;
insert and erase in the middle take linear time.
Storage management is handled automatically, though hints can be given
to improve efficiency.
The elements of a vector are stored contiguously, meaning that if
\tcode{v}\
is a
\tcode{vector<T, Alloc\removedConcepts{ator}>}\
where
\tcode{T}\
is some type other than
\tcode{bool},
then it obeys the identity
\tcode{\&v[n] == \&v[0] + n}\
for all
\tcode{0 <= n < v.size()}.

\pnum
A \tcode{vector}\ satisfies all of the requirements of a container and of a reversible container (given in two tables in~\ref{container.requirements}), of a sequence container, including most of the optional sequence container requirements (\ref{sequence.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}). The exceptions are the \tcode{push_front}\ and \tcode{pop_front}\ member functions, which are not provided. Descriptions are provided here only for operations on \tcode{vector}\ that are not described in one of these tables or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ T, @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<T> >
  @\addedConcepts{requires MoveConstructible<T>}@
  class vector {
  public:
    // types:
    typedef typename Alloc@\removedConcepts{ator}@::reference         reference;
    typedef typename Alloc@\removedConcepts{ator}@::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef T                                     value_type;
    typedef Alloc@\removedConcepts{ator}@                             allocator_type;
    typedef typename Alloc@\removedConcepts{ator}@::pointer           pointer;
    typedef typename Alloc@\removedConcepts{ator}@::const_pointer     const_pointer;
    typedef reverse_iterator<iterator>       reverse_iterator;
    typedef reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{vector.cons} construct/copy/destroy:
    explicit vector(const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    @\addedConcepts{requires AllocatableElement<Alloc, T>}@ 
      explicit vector(size_type n);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ 
      vector(size_type n, const T& value, const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
      vector(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
             const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ vector(const vector<T,Alloc@\removedConcepts{ator}@>& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ vector(vector&&);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ vector(const vector&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@ vector(vector&&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@
      vector(initializer_list<T>, const Allocator& = Allocator());
   ~vector();
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ @\addedConcepts{\&\& CopyAssignable<T>}@
      vector<T,Alloc@\removedConcepts{ator}@>& operator=(const vector<T,Alloc@\removedConcepts{ator}@>& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&> \&\& MoveAssignable<T>}@
      vector<T,Alloc@\removedConcepts{ator}@>& operator=(vector<T,Alloc@\removedConcepts{ator}@>&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& CopyAssignable<T>}@
      vector<T,Alloc@\removedConcepts{ator}@>& operator=(initializer_list<T>);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
            @\addedConcepts{\&\& HasAssign<T, Iter::reference>}@
      void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& CopyAssignable<T>}@
      void assign(size_type n, const T& u);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& CopyAssignable<T>}@
      void assign(initializer_list<T>);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // \ref{vector.capacity} capacity:
    size_type size() const;
    size_type max_size() const;
    @\addedConcepts{requires AllocatableElement<Alloc, T>}@
      void resize(size_type sz);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@
      void resize(size_type sz, const T& c);
    size_type capacity() const;
    bool      empty() const;
    void reserve(size_type n);
    void shrink_to_fit();

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{vector.data} data access
    pointer         data();
    const_pointer   data() const;

    // \ref{vector.modifiers} modifiers:
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@
      void emplace_back(Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_back(const T& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_back(T&& x);
    void pop_back();

    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@
            @\addedConcepts{\&\& MoveAssignable<T>}@
      iterator emplace(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ @\addedConcepts{\&\& MoveAssignable<T>}@
      iterator insert(const_iterator position, const T& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&> \&\& MoveAssignable<T>}@
      void insert(const_iterator position, T&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& MoveAssignable<T>}@
      void insert(const_iterator position, size_type n, const T& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
        @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
              @\addedConcepts{\&\& MoveAssignable<T>}@
        void insert(const_iterator position,
                    @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& MoveAssignable<T>}@
      void insert(const_iterator position, initializer_list<T> il);
    @\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator position);
    @\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator first, const_iterator last);
    void     swap(vector<T,Alloc@\removedConcepts{ator}@>&&);
    void     clear();
  };

  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator==(const vector<T,Alloc@\removedConcepts{ator}@>& x, const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator< (const vector<T,Alloc@\removedConcepts{ator}@>& x, const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const vector<T,Alloc@\removedConcepts{ator}@>& x, const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator> (const vector<T,Alloc@\removedConcepts{ator}@>& x, const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const vector<T,Alloc@\removedConcepts{ator}@>& x, const vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const vector<T,Alloc@\removedConcepts{ator}@>& x, const vector<T,Alloc@\removedConcepts{ator}@>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(vector<T,Alloc@\removedConcepts{ator}@>& x, vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(vector<T,Alloc@\removedConcepts{ator}@>&& x, vector<T,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
    void swap(vector<T,Alloc@\removedConcepts{ator}@>& x, vector<T,Alloc@\removedConcepts{ator}@>&& y);

  @\removedConcepts{template <class T, class Alloc>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<vector<T, Alloc> >}@
      @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}%
\index{vector@\tcode{vector}!\tcode{operator==}}%
\index{vector@\tcode{vector}!\tcode{operator<}}

\rSec3[vector.cons]{\tcode{vector}\ constructors, copy, and assignment}

\index{vector@\tcode{vector}!\tcode{vector}}
\begin{itemdecl}
vector(const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs an empty \tcode{vector}, using the
specified allocator.

\pnum
\complexity Constant.
\end{itemdescr}

\index{vector@\tcode{vector}!\tcode{vector}}
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T>}@ explicit vector(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{vector} with \tcode{n}
default constructed elements.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{DefaultConstructible}}.}

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\index{vector@\tcode{vector}!\tcode{vector}}
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@
explicit vector(size_type n, const T& value,
                const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{vector} with \tcode{n}
copies of \tcode{value}, using the specified allocator.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}

\pnum
\complexity Linear in \tcode{n}.
\end{itemdescr}

\index{vector@\tcode{vector}!\tcode{vector}}
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
  vector(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
         const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}

\pnum
\effects Constructs a \tcode{vector} equal to the
range \range{first}{last}, using the specified allocator.

\pnum
\complexity\ 
Makes only $N$
calls to the copy constructor of
\tcode{T}\
(where $N$
is the distance between
\tcode{first}\
and
\tcode{last})
and no reallocations if \changedConcepts{iterators first and last are of forward, bidirectional, or random access categories}{\mbox{\tcode{Iter}} meets the requirements of the \mbox{\tcode{ForwardIterator}} concept}.
It makes order
\tcode{N}\
calls to the copy constructor of
\tcode{T}\
and order
$\log(N)$
reallocations if they are just input iterators.
\end{itemdescr}

\index{assign@\tcode{assign}!\tcode{vector}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
        @\addedConcepts{\&\& HasAssign<T, Iter::reference>}@
  void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
erase(begin(), end());
insert(begin(), first, last);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ @\addedConcepts{\&\& CopyAssignable<T>}@
  void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
erase(begin(), end());
insert(begin(), n, t);
\end{codeblock}
\end{itemdescr}

\rSec3[vector.capacity]{\tcode{vector}\ capacity}

\index{capacity@\tcode{capacity}!\tcode{vector}}%
\begin{itemdecl}
size_type capacity() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
The total number of elements that the vector can hold
without requiring reallocation.
\end{itemdescr}

\index{reserve@\tcode{reserve}!\tcode{vector}}%
\begin{itemdecl}
void reserve(size_type n);
\end{itemdecl}

\pnum
\requires If \tcode{value_type} has a move constructor, that
constructor shall not throw any exceptions.

\begin{itemdescr}
\pnum
\effects\ 
A directive that informs a
\tcode{vector}\
of a planned change in size, so that it can manage the storage allocation accordingly.
After
\tcode{reserve()},
\tcode{capacity()}\
is greater or equal to the argument of
\tcode{reserve}\
if reallocation happens; and equal to the previous value of
\tcode{capacity()}\
otherwise.
Reallocation happens at this point if and only if the current capacity is less than the
argument of
\tcode{reserve()}. If an exception is thrown, there are no effects.

\pnum
\complexity\ 
It does not change the size of the sequence and takes at most linear
time in the size of the sequence.

\pnum
\throws\ 
\tcode{length_error}\
if
\tcode{\farg{n} > max_size()}.%
\footnote{
\tcode{reserve()}\
uses
\tcode{Alloc\removedConcepts{ator}::allocate()}\
which may throw an appropriate exception.
}

\pnum
\notes\ 
Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence.
It is guaranteed that no reallocation takes place during insertions that happen
after a call to
\tcode{reserve()}\
until the time when an insertion would make the size of the vector
greater than the value of
\tcode{capacity()}.
\end{itemdescr}

\begin{itemdecl}
void shrink_to_fit();
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes \tcode{shrink_to_fint} is a non-binding request to reduce \tcode{capacity()} to \tcode{size()}. \enternote The request is non-binding to allow latitude for implementation-specific optimizations. \exitnote
\end{itemdescr}

\index{swap@\tcode{swap}!\tcode{vector}}%
\begin{itemdecl}
void swap(vector<T,Alloc@\removedConcepts{ator}@>&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
Exchanges the contents and
\tcode{capacity()}\
of
\tcode{*this}\
with that of \tcode{x}.

\pnum
\complexity\
Constant time.
\end{itemdescr}

\index{resize@\tcode{resize}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T>}@
  void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, equivalent to
\tcode{erase(begin() + sz, end());}. If \tcode{size() < sz},
appends \tcode{sz - size()} default constructed elements to the
sequence.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be
\mbox{\tcode{DefaultConstructible}}.}
\end{itemdescr}

\index{resize@\tcode{resize}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@
  void resize(size_type sz, const T& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
if (sz > size())
  insert(end(), sz-size(), c);
else if (sz < size())
  erase(begin()+sz, end());
else
  ;                 // do nothing
\end{codeblock}

\pnum
\requires If \tcode{value_type} has a move constructor, that
constructor shall not throw any exceptions.
\end{itemdescr}

\rSec3[vector.data]{\tcode{vector}\ data}
\index{data@\tcode{data}!\tcode{vector}}%
\begin{itemdecl}
pointer         data();
const_pointer   data() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer such that \range{data()}{data() + size()} is a valid range. For a
non-empty vector, \tcode{data()} \tcode{==} \tcode{\&front()}.

\pnum
\complexity
Constant time.

\pnum
\throws
Nothing.
\end{itemdescr}

\rSec3[vector.modifiers]{\tcode{vector}\ modifiers}

\index{insert@\tcode{insert}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& MoveAssignable<T>}@
  iterator insert(const_iterator position, const T& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&> \&\& MoveAssignable<T>}@
  iterator insert(const_iterator position, T&& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&> \&\& MoveAssignable<T>}@
  void insert(const_iterator position, size_type n, const T& x);
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
    @\addedConcepts{requires AllocatableElement<Alloc, T, Iter::reference>}@
          @\addedConcepts{\&\& MoveAssignable<T>}@
    void insert(const_iterator position,
                @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

template <class... Args> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@
  void emplace_back(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires AllocatableElement<Alloc, T, Args\&\&...>}@
        @\addedConcepts{\&\& MoveAssignable<T>}@
  iterator emplace(const_iterator position, Args&&... args);
@\addedConcepts{requires AllocatableElement<Alloc, T, const T\&>}@ void push_back(const T& x);
@\addedConcepts{requires AllocatableElement<Alloc, T, T\&\&>}@      void push_back(T&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If \tcode{value_type} has a move constructor, that
constructor shall not throw any exceptions.

\pnum
\notes\ 
Causes reallocation if the new size is greater than the old capacity.
If no reallocation happens, all the iterators and references before the insertion point remain valid.
If an exception is thrown other than by
the copy constructor or assignment operator of
\tcode{T}\ or by any \tcode{InputIterator} operation
there are no effects.

\pnum
\complexity\ 
The complexity is linear in the number of elements inserted plus the distance
to the end of the vector.
\end{itemdescr}

\index{erase@\tcode{erase}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator position);
@\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator first, const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Invalidates iterators and references at or after the point of the erase.

\pnum
\complexity\ 
The destructor of \tcode{T}\ is called the number of times equal to the
number of the elements erased, but the move assignment operator
of \tcode{T}\ is called the number of times equal to the number of
elements in the vector after the erased elements.

\pnum
\throws\ 
Nothing unless an exception is thrown by the
copy constructor or assignment operator of
\tcode{T}.
\end{itemdescr}

\rSec3[vector.special]{\tcode{vector}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(vector<T,Alloc@\removedConcepts{ator}@>& x, vector<T,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(vector<T,Alloc@\removedConcepts{ator}@>&& x, vector<T,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ T, class Alloc@\removedConcepts{ator}@>
  void swap(vector<T,Alloc@\removedConcepts{ator}@>& x, vector<T,Alloc@\removedConcepts{ator}@>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[vector.bool]{Class \tcode{vector<bool>}}

\pnum
\index{vector<bool>@\tcode{vector<bool>}}%
To optimize space allocation, a specialization of vector for
\tcode{bool}
elements is provided:

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@> class vector<bool, Alloc@\removedConcepts{ator}@> {
  public:
    // types:
    typedef bool                                  const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef bool                                  value_type;
    typedef Alloc@\removedConcepts{ator}@                             allocator_type;
    typedef @\impdef@                pointer;
    typedef @\impdef@                const_pointer;
    typedef reverse_iterator<iterator>       reverse_iterator;
    typedef reverse_iterator<const_iterator> const_reverse_iterator;

    // bit reference:
    class reference {
      friend class vector;
      reference();
    public:
      ~reference();
      operator bool() const;
      reference& operator=(const bool x);
      reference& operator=(const reference& x);
      void flip();              // flips the bit
    };

    // construct/copy/destroy:
    explicit vector(const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    explicit vector(size_type n, const bool& value = bool(),
                    const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires Convertible<Iter::reference, bool>}@
      vector(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
             const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    vector(const vector<bool,Alloc@\removedConcepts{ator}@>& x);
    vector(vector<bool,Alloc@\removedConcepts{ator}@>&& x);
    vector(const vector&, const Alloc@\removedConcepts{ator}@&);
    vector(vector&&, const Alloc@\removedConcepts{ator}@&);
    vector(initializer_list<bool>);
   ~vector();
    vector<bool,Alloc@\removedConcepts{ator}@>& operator=(const vector<bool,Alloc@\removedConcepts{ator}@>& x);
    vector<bool,Alloc@\removedConcepts{ator}@>& operator=(vector<bool,Alloc@\removedConcepts{ator}@>&& x);
    vector<bool,Alloc@\removedConcepts{ator}@>& operator=(initializer_list<bool>);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires Convertible<Iter::reference, bool>}@
      void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    void assign(size_type n, const bool& t);
    void assign(initializer_list<bool>);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    size_type size() const;
    size_type max_size() const;
    void      resize(size_type sz, bool c = false);
    size_type capacity() const;
    bool      empty() const;
    void      reserve(size_type n);
    void      shrink_to_fit();

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // modifiers:
    void push_back(const bool& x);
    void pop_back();
    iterator insert(const_iterator position, const bool& x);
    void     insert (const_iterator position, size_type n, const bool& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
        @\addedConcepts{requires Convertible<Iter::reference, bool>}@
        void insert(const_iterator position,
                    @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    void insert(const_iterator position, initializer_list<bool> il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void swap(vector<bool,Alloc@\removedConcepts{ator}@>&&);
    static void swap(reference x, reference y);
    void flip();                // flips all bits
    void clear();
  };

}
\end{codeblock}%

\pnum
Unless described below, all operations have the same requirements and
semantics as the primary \tcode{vector} template, except that operations
dealing with the \tcode{bool} value type map to bit values in the
container storage.

\pnum
There is no requirement that the data be stored as a contiguous allocation
of \tcode{bool} values. A space-optimized representation of bits is
recommended instead.

\pnum
\tcode{reference}
is a class that simulates the behavior of references of a single bit in
\tcode{vector<bool>}. The conversion operator returns \tcode{true}
when the bit is set, and \tcode{false} otherwise. The assignment operator
sets the bit when the argument is (convertible to) \tcode{true} and
clears it otherwise. \tcode{flip} reverses the state of the bit.

\begin{itemdecl}
void flip();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Replaces each element in the container with its complement.
It is unspecified whether the function has any effect on allocated but unused bits.
\end{itemdescr}

\rSec1[associative]{Associative containers}

\pnum
Headers \tcode{<map>}\ and \tcode{<set>}:

\synopsis{Header \tcode{<map>}\ synopsis}%
\index{map@\tcode{<map>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, 
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<pair<const Key, T> > >
    @\addedConcepts{requires NothrowDestructible<Key> \&\& NothrowDestructible<T> \&\& CopyConstructible<Compare>}@
             @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, const Compare\&>}@
             @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, Compare\&\&>}@
    class map;
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator==(const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator< (const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator> (const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
              map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(map<Key,T,Compare,Alloc@\removedConcepts{ator}@&& x,
              map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(map<Key,T,Compare,Alloc@\removedConcepts{ator}@& x,
              map<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& y);

  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, 
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<pair<const Key, T> > >
    @\addedConcepts{requires NothrowDestructible<Key> \&\& NothrowDestructible<T> \&\& CopyConstructible<Compare>}@
             @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, const Compare\&>}@
             @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, Compare\&\&>}@
    class multimap;
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator==(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator< (const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator> (const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
              multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@&& x,
              multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@& x,
              multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<set>}\ synopsis}%
\index{set@\tcode{<set>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<Key> >
    @\addedConcepts{requires NothrowDestructible<Key> \&\& CopyConstructible<Compare>}@
             @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, const Compare\&>}@
             @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, Compare\&\&>}@
    class set;
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator==(const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator< (const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator> (const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
              set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, class T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(set<Key,T,Compare,Alloc@\removedConcepts{ator}@&& x,
              set<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, class T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(set<Key,T,Compare,Alloc@\removedConcepts{ator}@& x,
              set<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& y);

  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<Key> >
    @\addedConcepts{requires NothrowDestructible<Key> \&\& CopyConstructible<Compare>}@
             @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, const Compare\&>}@
             @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, Compare\&\&>}@
    class multiset;
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator==(const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator< (const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator> (const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
              multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, class T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multiset<Key,T,Compare,Alloc@\removedConcepts{ator}@&& x,
              multiset<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, class T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multiset<Key,T,Compare,Alloc@\removedConcepts{ator}@& x,
              multiset<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& y);
}
\end{codeblock}

\rSec2[map]{Class template \tcode{map}}%
\index{map@\tcode{map}}

\pnum
A \tcode{map}\ is an associative container that
supports unique keys (contains at most one of each key value) and
provides for fast retrieval of values of another type \tcode{T}\ based
on the keys. The \tcode{map}\ class supports bidirectional iterators.

\pnum
A
\tcode{map}\
satisfies all of the requirements of a container, of a reversible container
(\ref{container.requirements}), of
an associative container (\ref{associative.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
A
\tcode{map}\
also provides most operations described in (\ref{associative.reqmts})
for unique keys.
This means that a
\tcode{map}\
supports the
\tcode{a_uniq}\
operations in (\ref{associative.reqmts})
but not the
\tcode{a_eq}\
operations.
For a
\tcode{map<Key,T>}\
the
\tcode{key_type}\
is
\tcode{Key}\
and the
\tcode{value_type}\
is
\tcode{pair<const Key,T>}.
Descriptions are provided here only for operations on
\tcode{map}\
that are not described in one of those tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, 
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<pair<const Key, T> > >
  @\addedConcepts{requires NothrowDestructible<Key> \&\& NothrowDestructible<T> \&\& CopyConstructible<Compare>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, const Compare\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, Compare\&\&>}@
  class map {
  public:
    // types:
    typedef Key                                   key_type;
    typedef T                                     mapped_type;
    typedef pair<const Key, T>                    value_type;
    typedef Compare                               key_compare;
    typedef Alloc@\removedConcepts{ator}@                             allocator_type;
    typedef typename Alloc@\removedConcepts{ator}@::reference         reference;
    typedef typename Alloc@\removedConcepts{ator}@::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef typename Alloc@\removedConcepts{ator}@::pointer           pointer;
    typedef typename Alloc@\removedConcepts{ator}@::const_pointer     const_pointer;
    typedef reverse_iterator<iterator>       reverse_iterator;
    typedef reverse_iterator<const_iterator> const_reverse_iterator;

    class value_compare
      : public binary_function<value_type,value_type,bool> {
    friend class map;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) {}
    public:
      bool operator()(const value_type& x, const value_type& y) const {
        return comp(x.first, y.first);
      }
    };

    // \ref{map.cons} construct/copy/destroy:
    explicit map(const Compare& comp = Compare(),
                 const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      map(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
          const Compare& comp = Compare(), const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      map(const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x);
    map(map<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& x);
    map(const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      map(const map&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@
      map(map&&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      map(initializer_list<value_type>,
          const Compare& = Compare(),
          const Allocator& = Allocator());
   ~map();
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
          @\addedConcepts{\&\& CopyAssignable<value_type>}@
      map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& operator=(const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x);
    map<Key,T,Compare,Alloc@\removedConcepts{ator}@>&
      operator=(map<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
          @\addedConcepts{\&\& CopyAssignable<value_type>}@
      map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    bool      empty() const;
    size_type size() const;
    size_type max_size() const;

    // \ref{map.access} element access:
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const key_type\&, mapped_type\&\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, mapped_type>}@
      T& operator[](const key_type& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, key_type\&\&, mapped_type\&\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, mapped_type>}@
      T& operator[](key_type&& x);
    T&       at(const key_type& x);
    const T& at(const key_type& x) const;

    // modifiers:
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace_hint(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      pair<iterator, bool> insert(const value_type& x);
    template <class P> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
      pair<iterator, bool> insert(P&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const_iterator position, const value_type& x);
    template <class P>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
      iterator insert(const_iterator position, P&&);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      void insert(initializer_list<value_type>);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void swap(map<Key,T,Compare,Alloc@\removedConcepts{ator}@>&&);
    void clear();

    // observers:
    key_compare   key_comp() const;
    value_compare value_comp() const;

    // \ref{map.ops} map operations:
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    size_type      count(const key_type& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;

    pair<iterator,iterator>
      equal_range(const key_type& x);
    pair<const_iterator,const_iterator>
      equal_range(const key_type& x) const;
  };

  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator==(const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator< (const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator> (const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
              map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(map<Key,T,Compare,Alloc@\removedConcepts{ator}@&& x,
              map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(map<Key,T,Compare,Alloc@\removedConcepts{ator}@& x,
              map<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& y);

  @\removedConcepts{template <class Key, class T, class Compare, class Alloc>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<}@
      @\removedConcepts{map<Key, T, Compare, Alloc> >}@
        @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}%

\index{map@\tcode{map}!\tcode{operator==}}%
\index{map@\tcode{map}!\tcode{operator<}}%

\rSec3[map.cons]{\tcode{map}\ constructors, copy, and assignment}

\begin{itemdecl}
explicit map(const Compare& comp = Compare(),
             const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty
\tcode{map}\
using the specified comparison object and allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
          @\addedConcepts{\&\& MoveConstructible<value_type>}@
  map(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
      const Compare& comp = Compare(), const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} If the iterator's dereference operator returns an lvalue or a
const rvalue \mbox{\tcode{pair<key_type, mapped_type>}}, then both
\mbox{\tcode{key_type}} and \mbox{\tcode{mapped_type}} shall be
\mbox{\tcode{CopyConstructible}}.}

\pnum
\effects\ 
Constructs an empty
\tcode{map}\
using the specified comparison object and allocator,
and inserts elements from the range
\range{\farg{first}}{\farg{last}}.

\pnum
\complexity\ 
Linear in $N$ if the range
\range{\farg{first}}{\farg{last}}\
is already sorted using \farg{comp}
and otherwise $N \log{N}$, where $N$
is \farg{last} - \farg{first}.
\end{itemdescr}

\rSec3[map.access]{\tcode{map}\ element access}

\index{operator[]@\tcode{operator[]}!map@\tcode{map}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, value_type, const key_type\&>, mapped_type\&\&>}@
      @\addedConcepts{\&\& AllocatableElement<Alloc, mapped_type>}@
  T& operator[](const key_type& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
If there is no key equivalent to \tcode{x}\ in the map, inserts
\tcode{value_type(x, T())}\
into the map.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{key_type}} shall be
\mbox{\tcode{CopyConstructible}} and \mbox{\tcode{mapped_type}} shall be
\mbox{\tcode{DefaultConstructible}}.}

\pnum
\returns\ 
A reference to the
\tcode{mapped_type}\
corresponding to \tcode{x}\ in
\tcode{*this}.

\pnum
\complexity\
logarithmic.
\end{itemdescr}

\index{operator[]@\tcode{operator[]}!map@\tcode{map}}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, value_type, key_type\&\&, mapped_type\&\&>}@
      @\addedConcepts{\&\& AllocatableElement<Alloc, mapped_type>}@
  T& operator[](key_type&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If there is no key equivalent to \tcode{x} in the map, inserts
\tcode{value_type(move(x), T())}
into the map.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{mapped_type}} shall be
\mbox{\tcode{DefaultConstructible}}.}

\pnum
\returns
A reference to the
\tcode{mapped_type}
corresponding to \tcode{x} in
\tcode{*this}.

\pnum
\complexity
logarithmic.
\end{itemdescr}

\index{at@\tcode{at}!map@\tcode{map}}%
\begin{itemdecl}
T&       at(const key_type& x);
const T& at(const key_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A reference to the element whose key is equivalent to \tcode{x}.

\pnum
\throws
An exception object of type \tcode{out_of_range} if
no such element is present.

\pnum
\complexity
logarithmic.
\end{itemdescr}

\rSec3[map.modifiers]{\tcode{map}\ modifiers}

\begin{itemdecl}
template <class P> 
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
  pair<iterator, bool> insert(P&& x);
template <class P> 
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
  pair<iterator, bool> insert(const_iterator position, P&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}
\mbox{\tcode{P}} shall be convertible to \mbox{\tcode{value_type}}.}

If \tcode{P} is instantiated as a reference type, then
the argument \tcode{x} is copied from. Otherwise \tcode{x}
is considered to be an rvalue as it is converted to
\tcode{value_type} and inserted into the \tcode{map}.
Specifically, in such cases \tcode{CopyConstructible} is not required of
\tcode{key_type} or \tcode{mapped_type}
unless the conversion from \tcode{P} specifically
requires it (e.g. if \tcode{P} is a 
\tcode{tuple<const key_type, mapped_type>}, then
\tcode{key_type} must be \tcode{CopyConstructible}).
The signature taking \tcode{InputIterator}
parameters does not require \tcode{CopyConstructible}
of either \tcode{key_type} or
\tcode{mapped_type} if the dereferenced \tcode{InputIterator}
returns a non-const rvalue
\tcode{pair<key_type,mapped_type>}. Otherwise
\tcode{CopyConstructible} is required for
both \tcode{key_type} and \tcode{mapped_type}.
\end{itemdescr}

\rSec3[map.ops]{\tcode{map}\ operations}

\begin{itemdecl}
iterator       find(const key_type& x);
const_iterator find(const key_type& x) const;

iterator       lower_bound(const key_type& x);
const_iterator lower_bound(const key_type& x) const;

iterator       upper_bound(const key_type& x);
const_iterator upper_bound(const key_type &x) const;

pair<iterator, iterator>
  equal_range(const key_type &x);
pair<const_iterator, const_iterator>
  equal_range(const key_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
The
\tcode{find},
\tcode{lower_bound},
\tcode{upper_bound}\
and
\tcode{equal_range}\
member functions each have two versions,
one const and the other non-const.
In each case the behavior of the two functions is identical
except that the const version returns a
\tcode{const_iterator}\
and the non-const version an
\tcode{iterator}\
(\ref{associative.reqmts}).
\end{itemdescr}

\rSec3[map.special]{\tcode{map}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
            map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(map<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& x,
            map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(map<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
            map<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[multimap]{Class template \tcode{multimap}}

\pnum
\index{multimap@\tcode{multimap}}%
A
\tcode{multimap}\
is an associative container that supports equivalent keys (possibly containing multiple copies of
the same key value) and provides for fast retrieval of values of another type
\tcode{T}\
based on the keys.
The
\tcode{multimap}\
class
supports bidirectional iterators.

\pnum
A
\tcode{multimap}\
satisfies all of the requirements of a container and of a reversible container
(\ref{container.requirements}), of
an associative container (\ref{associative.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
A
\tcode{multimap}\
also provides most operations described in (\ref{associative.reqmts})
for equal keys.
This means that a
\tcode{multimap}\
supports the
\tcode{a_eq}\
operations in
(\ref{associative.reqmts})
but not the
\tcode{a_uniq}\
operations.
For a
\tcode{multimap<Key,T>}\
the
\tcode{key_type}\
is
\tcode{Key}\
and the
\tcode{value_type}\
is
\tcode{pair<const Key,T>}.
Descriptions are provided here only for operations on
\tcode{multimap}\
that are not described in one of those tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, 
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<pair<const Key, T> > >
    @\addedConcepts{requires NothrowDestructible<Key> \&\& NothrowDestructible<T> \&\& CopyConstructible<Compare>}@
           @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, const Compare\&>}@
           @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, Compare\&\&>}@
  class multimap {
  public:
    // types:
    typedef Key                                   key_type;
    typedef T                                     mapped_type;
    typedef pair<const Key,T>                     value_type;
    typedef Compare                               key_compare;
    typedef Alloc@\removedConcepts{ator}@                             allocator_type;
    typedef typename Alloc@\removedConcepts{ator}@::reference         reference;
    typedef typename Alloc@\removedConcepts{ator}@::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef typename Alloc@\removedConcepts{ator}@::pointer           pointer;
    typedef typename Alloc@\removedConcepts{ator}@::const_pointer     const_pointer;
    typedef reverse_iterator<iterator>       reverse_iterator;
    typedef reverse_iterator<const_iterator> const_reverse_iterator;

    class value_compare
      : public binary_function<value_type,value_type,bool> {
    friend class multimap;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) { }
    public:
      bool operator()(const value_type& x, const value_type& y) const {
        return comp(x.first, y.first);
      }
    };

    // construct/copy/destroy:
    explicit multimap(const Compare& comp = Compare(),
                      const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      multimap(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
          const Compare& comp = Compare(), const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      multimap(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x);
    multimap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& x);
    multimap(const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      multimap(const multimap&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@
      multimap(multimap&&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      multimap(initializer_list<value_type>,
          const Compare& = Compare(),
          const Allocator& = Allocator());
   ~multimap();
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
            @\addedConcepts{\&\& CopyAssignable<value_type>}@
      multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& operator=(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x);
    multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>&
      operator=(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
          @\addedConcepts{\&\& CopyAssignable<value_type>}@
      multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    bool           empty() const;
    size_type      size() const;
    size_type      max_size() const;

    // modifiers:
    template <class... Args>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace_hint(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const value_type& x);
    template <class P> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
      iterator insert(P&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const_iterator position, const value_type& x);
    template <class P> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
      iterator insert(const_iterator position, P&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      void insert(initializer_list<value_type>);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void swap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>&&);
    void clear();

    // observers:
    key_compare    key_comp() const;
    value_compare  value_comp() const;

    // map operations:
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    size_type      count(const key_type& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;

    pair<iterator,iterator>
      equal_range(const key_type& x);
    pair<const_iterator,const_iterator>
      equal_range(const key_type& x) const;
  };

  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator==(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator< (const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, @\changedConcepts{class}{EqualityComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator> (const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, @\changedConcepts{class}{LessThanComparable}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
              multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@&& x,
              multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@& x,
              multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& y);

  @\removedConcepts{template <class Key, class T, class Compare, class Alloc>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<}@
      @\removedConcepts{multimap<Key, T, Compare, Alloc> >}@
        @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}%
\index{multimap@\tcode{multimap}!\tcode{operator==}}%
\index{multimap@\tcode{multimap}!\tcode{operator<}}

\rSec3[multimap.cons]{\tcode{multimap}\ constructors}

\begin{itemdecl}
explicit multimap(const Compare& comp = Compare(),
                  const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty
\tcode{multimap}\
using the specified comparison object and allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
          @\addedConcepts{\&\& MoveConstructible<value_type>}@
  multimap(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
      const Compare& comp = Compare(), const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} If the iterator's dereference operator returns an lvalue or a
const rvalue \mbox{\tcode{pair<key_type, mapped_type>}}, then both
\mbox{\tcode{key_type}} and \mbox{\tcode{mapped_type}} shall be
\mbox{\tcode{CopyConstructible}}.}

\pnum
\effects\ 
Constructs an empty
\tcode{multimap}\
using the specified comparison object and allocator,
and inserts elements from the range
\range{\farg{first}}{\farg{last}}.

\pnum
\complexity\ 
Linear in $N$ if the range
\range{\farg{first}}{\farg{last}}\
is already sorted using \farg{comp}
and otherwise $N \log{N}$,
where $N$\ is
\tcode{\farg{last}\ - \farg{first}}.
\end{itemdescr}

\rSec3[multimap.modifiers]{\tcode{multimap}\ modifiers}

\begin{itemdecl}
template <class P> 
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
  iterator insert(P&& x);
template <class P> 
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
  iterator insert(const_iterator position, P&& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}
\mbox{\tcode{P}} shall be convertible to \mbox{\tcode{value_type}}.}

If \tcode{P} is instantiated as a reference type, then
the argument \tcode{x} is copied from. Otherwise \tcode{x}
is considered to be an rvalue as it is converted to
\tcode{value_type} and inserted into the \tcode{map}.
Specifically, in such cases \tcode{CopyConstructible} is not required of
\tcode{key_type} or tcode{mapped_type}
unless the conversion from \tcode{P} specifically
requires it (e.g. if \tcode{P} is a 
\tcode{tuple<const key_type, mapped_type>}, then
\tcode{key_type} must be \tcode{CopyConstructible}).
The signature taking \tcode{InputIterator}
parameters does not require \tcode{CopyConstructible}
of either \tcode{key_type} or
\tcode{mapped_type} if the dereferenced \tcode{InputIterator}
returns a non-const rvalue
\tcode{pair<key_type,mapped_type>}. Otherwise
\tcode{CopyConstructible} is required for
both \tcode{key_type} and \tcode{mapped_type}.
\end{itemdescr}

\rSec3[multimap.ops]{\tcode{multimap}\ operations}

\begin{itemdecl}
iterator       find(const key_type &x);
const_iterator find(const key_type& x) const;

iterator       lower_bound(const key_type& x);
const_iterator lower_bound(const key_type& x) const;

pair<iterator, iterator>
  equal_range(const key_type& x);
pair<const_iterator, const_iterator>
  equal_range(const key_type& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
The
\tcode{find},
\tcode{lower_bound},
\tcode{upper_bound},
and
\tcode{equal_range}\
member functions each have two versions, one const and one non-const.
In each case the behavior of the two versions is identical
except that the const version returns a
\tcode{const_iterator}\
and the non-const version an
\tcode{iterator}\
(\ref{associative.reqmts}).
\end{itemdescr}

\rSec3[multimap.special]{\tcode{multimap}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
            multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& x,
            multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>& x,
            multimap<Key,T,Compare,Alloc@\removedConcepts{ator}@>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[set]{Class template \tcode{set}}

\pnum
\index{set@\tcode{set}}%
A
\tcode{set}\
is an associative container that supports unique keys (contains at most one of each key value) and
provides for fast retrieval of the keys themselves.
Class
\tcode{set}\
supports bidirectional iterators.

\pnum
A
\tcode{set}\
satisfies all of the requirements of a container, of a reversible container
(\ref{container.requirements}), of
an associative container (\ref{associative.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
A
\tcode{set}\
also provides most operations described in (\ref{associative.reqmts})
for unique keys.
This means that a
\tcode{set}\
supports the
\tcode{a_uniq}\
operations in (\ref{associative.reqmts})
but not the
\tcode{a_eq}\
operations.
For a
\tcode{set<Key>}\
both the
\tcode{key_type}\
and
\tcode{value_type}\
are
\tcode{Key}.
Descriptions are provided here only for operations on
\tcode{set}\
that are not described in one of these tables
and for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<Key> >
  @\addedConcepts{requires NothrowDestructible<Key> \&\& CopyConstructible<Compare>}@
           @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, const Compare\&>}@
           @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, Compare\&\&>}@
  class set {
  public:
    // types:
    typedef Key                                   key_type;
    typedef Key                                   value_type;
    typedef Compare                               key_compare;
    typedef Compare                               value_compare;
    typedef Alloc@\removedConcepts{ator}@                             allocator_type;
    typedef typename Alloc@\removedConcepts{ator}@::reference         reference;
    typedef typename Alloc@\removedConcepts{ator}@::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef typename Alloc@\removedConcepts{ator}@::pointer           pointer;
    typedef typename Alloc@\removedConcepts{ator}@::const_pointer     const_pointer;
    typedef reverse_iterator<iterator>       reverse_iterator;
    typedef reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{set.cons} construct/copy/destroy:
    explicit set(const Compare& comp = Compare(),
                 const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      set(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
          const Compare& comp = Compare(), const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      set(const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x);
    set(set<Key,Compare,Alloc@\removedConcepts{ator}@>&& x);
    set(const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      set(const set&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@
      set(set&&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      set(initializer_list<value_type>,
          const Compare& = Compare(),
          const Allocator& = Allocator());
   ~set();

    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
            @\addedConcepts{\&\& CopyAssignable<value_type>}@
      set<Key,Compare,Alloc@\removedConcepts{ator}@>& operator=(const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x);
    set<Key,Compare,Alloc@\removedConcepts{ator}@>& operator=(set<Key,Compare,Alloc@\removedConcepts{ator}@>&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
          @\addedConcepts{\&\& CopyAssignable<value_type>}@
      set<Key,Compare,Alloc@\removedConcepts{ator}@>& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    bool          empty() const;
    size_type     size() const;
    size_type     max_size() const;

    // modifiers:
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace_hint(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      pair<iterator,bool> insert(const value_type& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@ 
      pair<iterator,bool> insert(value_type&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const_iterator position, const value_type& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@ 
      iterator insert(const_iterator position, value_type&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference> \&\& MoveConstructible<value_type>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      void insert(initializer_list<value_type>);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void swap(set<Key,Compare,Alloc@\removedConcepts{ator}@>&);
    void clear();

    // observers:
    key_compare   key_comp() const;
    value_compare value_comp() const;

    // set operations:
    iterator        find(const key_type& x);
    const_iterator  find(const key_type& x) const;

    size_type count(const key_type& x) const;

    iterator        lower_bound(const key_type& x);
    const_iterator  lower_bound(const key_type& x) const;

    iterator        upper_bound(const key_type& x);
    const_iterator  upper_bound(const key_type& x) const;

    pair<iterator,iterator>             equal_range(const key_type& x);
    pair<const_iterator,const_iterator> equal_range(const key_type& x) const;
  };

  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator==(const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator< (const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator> (const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
              set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(set<Key,Compare,Alloc@\removedConcepts{ator}@&& x,
              set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(set<Key,Compare,Alloc@\removedConcepts{ator}@& x,
              set<Key,Compare,Alloc@\removedConcepts{ator}@>&& y);

  @\removedConcepts{template <class Key, class Compare, class Alloc>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<}@
      @\removedConcepts{set<Key, Compare, Alloc> >}@
        @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}%
\index{set@\tcode{set}!\tcode{operator==}}%
\index{set@\tcode{set}!\tcode{operator<}}

\rSec3[set.cons]{\tcode{set}\ constructors, copy, and assignment}

\begin{itemdecl}
explicit set(const Compare& comp = Compare(),
             const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty set using the specified comparison objects and allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
          @\addedConcepts{\&\& MoveConstructible<value_type>}@
  set(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@,
      const Compare& @\farg{comp}@ = Compare(), const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty
\tcode{set}\
using the specified comparison object and allocator,
and inserts elements from the range
\range{\farg{first}}{\farg{last}}.

\pnum
\removedConcepts{\mbox{\requires} If the iterator's dereference operator returns an lvalue or a
non-const rvalue, then \mbox{\tcode{Key}} shall be
\mbox{\tcode{CopyConstructible}}.}

\pnum
\complexity\ 
Linear in $N$ if the range
\range{\farg{first}}{\farg{last}}\
is already sorted using \farg{comp}\
and otherwise $N \log{N}$,
where $N$\ is
\tcode{\farg{last} - \farg{first}}.
\end{itemdescr}

\rSec3[set.special]{\tcode{set}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
            set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(set<Key,Compare,Alloc@\removedConcepts{ator}@>&& x,
            set<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(set<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
            set<Key,Compare,Alloc@\removedConcepts{ator}@>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[multiset]{Class template \tcode{multiset}}

\pnum
\index{multiset@\tcode{multiset}}%
A
\tcode{multiset}\
is an associative container that supports equivalent keys (possibly contains multiple copies of
the same key value) and provides for fast retrieval of the keys themselves.
Class
\tcode{multiset}\
supports bidirectional iterators.

\pnum
A
\tcode{multiset}\
satisfies all of the requirements of a container, of a reversible container
(\ref{container.requirements}), of
an associative container (\ref{associative.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
\tcode{multiset}
also provides most operations described in
(\ref{associative.reqmts})
for duplicate keys.
This means that a
\tcode{multiset}\
supports the
\tcode{a_eq}\
operations in
(\ref{associative.reqmts})
but not the
\tcode{a_uniq}\
operations.
For a
\tcode{multiset<Key>}\
both the
\tcode{key_type}\
and
\tcode{value_type}\
are
\tcode{Key}.
Descriptions are provided here only for operations on
\tcode{multiset}\
that are not described in one of these tables
and for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Compare = less<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc@\removedConcepts{ator}@ = allocator<Key> >
  @\addedConcepts{requires NothrowDestructible<Key> \&\& CopyConstructible<Compare>}@
           @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, const Compare\&>}@
           @\addedConcepts{\&\& AllocatableElement<Alloc, Compare, Compare\&\&>}@
  class multiset {
  public:
    // types:
    typedef Key                                   key_type;
    typedef Key                                   value_type;
    typedef Compare                               key_compare;
    typedef Compare                               value_compare;
    typedef Alloc@\removedConcepts{ator}@                             allocator_type;
    typedef typename Alloc@\removedConcepts{ator}@::reference         reference;
    typedef typename Alloc@\removedConcepts{ator}@::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef typename Alloc@\removedConcepts{ator}@::pointer           pointer;
    typedef typename Alloc@\removedConcepts{ator}@::const_pointer     const_pointer;
    typedef reverse_iterator<iterator>       reverse_iterator;
    typedef reverse_iterator<const_iterator> const_reverse_iterator;

    // construct/copy/destroy:
    explicit multiset(const Compare& comp = Compare(),
                      const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      multiset(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,
               const Compare& comp = Compare(),
               const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      multiset(const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x);
    multiset(multiset<Key,Compare,Alloc@\removedConcepts{ator}@>&& x);
    multiset(const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      multiset(const multiset&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@
      multiset(multiset&&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      multiset(initializer_list<value_type>,
          const Compare& = Compare(),
          const Allocator& = Allocator());
   ~multiset();
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&> \&\& CopyAssignable<value_type>}@
      multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& operator=(const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x);
    multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& operator=(multiset<Key,Compare,Alloc@\removedConcepts{ator}@>&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
          @\addedConcepts{\&\& CopyAssignable<value_type>}@
      multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    bool          empty() const;
    size_type     size() const;
    size_type     max_size() const;

    // modifiers:
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace_hint(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const value_type& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@ 
      iterator insert(value_type&& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const_iterator position, const value_type& x);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@ 
      iterator insert(const_iterator position, value_type&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference> \&\& MoveConstructible<value_type>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      void insert(initializer_list<value_type>);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void swap(multiset<Key,Compare,Alloc@\removedConcepts{ator}@>&&);
    void clear();

    // observers:
    key_compare   key_comp() const;
    value_compare value_comp() const;

    // set operations:
    iterator        find(const key_type& x);
    const_iterator  find(const key_type& x) const;

    size_type count(const key_type& x) const;

    iterator        lower_bound(const key_type& x);
    const_iterator  lower_bound(const key_type& x) const;

    iterator        upper_bound(const key_type& x);
    const_iterator  upper_bound(const key_type& x) const;

    pair<iterator,iterator>             equal_range(const key_type& x);
    pair<const_iterator,const_iterator> equal_range(const key_type& x) const;
  };

  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator==(const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator< (const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator!=(const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator> (const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator>=(const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    bool operator<=(const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
                    const multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
              multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multiset<Key,Compare,Alloc@\removedConcepts{ator}@&& x,
              multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
  template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
    void swap(multiset<Key,Compare,Alloc@\removedConcepts{ator}@& x,
              multiset<Key,Compare,Alloc@\removedConcepts{ator}@>&& y);

  @\removedConcepts{template <class Key, class Compare, class Alloc>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<}@
      @\removedConcepts{multiset<Key, Compare, Alloc> >}@
        @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}%
\index{multiset@\tcode{multiset}!\tcode{operator==}}%
\index{multiset@\tcode{multiset}!\tcode{operator<}}

\rSec3[multiset.cons]{\tcode{multiset}\ constructors}

\begin{itemdecl}
explicit multiset(const Compare& @\farg{comp}@ = Compare(),
                  const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty set using the specified comparison object and allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
          @\addedConcepts{\&\& MoveConstructible<value_type>}@
  multiset(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@,
           const Compare& @\farg{comp}@ = Compare(),
           const Alloc@\removedConcepts{ator}@& = Alloc@\removedConcepts{ator}@());
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} If the iterator's dereference operator returns an lvalue or a
const rvalue, then \mbox{\tcode{Key}} shall be
\mbox{\tcode{CopyConstructible}}.}

\pnum
\effects\ 
Constructs an empty
\tcode{multiset}\
using the specified comparison object and allocator,
and inserts elements from the range
\range{\farg{first}}{\farg{last}}.

\pnum
\complexity\ 
Linear in $N$
if the range
\range{\farg{first}}{\farg{last}}\
is already sorted using \farg{comp}\ and otherwise $N \log{N}$,
where $N$ is
\tcode{\farg{last}\ - \farg{first}}.
\end{itemdescr}

\rSec3[multiset.special]{\tcode{multiset}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
            multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(multiset<Key,Compare,Alloc@\removedConcepts{ator}@>&& x,
            multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& y);
template <@\changedConcepts{class}{ValueType}@ Key, class Compare, class Alloc@\removedConcepts{ator}@>
  void swap(multiset<Key,Compare,Alloc@\removedConcepts{ator}@>& x,
            multiset<Key,Compare,Alloc@\removedConcepts{ator}@>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec1[unord]{\marktr{}Unordered associative containers}

\pnum
Headers \tcode{<unordered_map>}\ and \tcode{<unordered_set>}:

\synopsis{Header \tcode{<unordered_map>}\ synopsis}%
\index{unordered_map@\tcode{<unordered_map>}}%
\index{unordered_map@\tcode{unordered_map}}%
\index{unordered_multimap@\tcode{unordered_multimap}}%
\begin{codeblock}
namespace std {
  // \ref{unord.map}, class template unordered_map:
  template <@\changedConcepts{class}{ValueType}@ Key,
            @\changedConcepts{class}{ValueType}@ T,
            @\changedConcepts{class}{Callable<auto, const Key\&>}@ Hash = hash<Key>,
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Pred = equal_to<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc = allocator<pair<const Key, T> > >
    @\addedConcepts{requires NothrowDestructible<Key> \&\& NothrowDestructible<T>}@
          @\addedConcepts{\&\& SameType<Hash::result_type, size_t>}@
          @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, const Pred\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, Pred\&\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, const Hash\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, Hash\&\&>}@
    class unordered_map;

  // \ref{unord.multimap}, class template unordered_multimap:
  template <@\changedConcepts{class}{ValueType}@ Key,
            @\changedConcepts{class}{ValueType}@ T,
            @\changedConcepts{class}{Callable<auto, const Key\&>}@ Hash = hash<Key>,
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Pred = equal_to<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc = allocator<pair<const Key, T> > >
    @\addedConcepts{requires NothrowDestructible<Key> \&\& NothrowDestructible<T>}@
          @\addedConcepts{\&\& SameType<Hash::result_type, size_t>}@
          @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, const Pred\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, Pred\&\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, const Hash\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, Hash\&\&>}@
    class unordered_multimap;

  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Hash, class Pred, class Alloc>
    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_map<Key, T, Hash, Pred, Alloc>& y);
  @\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_map<Key, T, Hash, Pred, Alloc>\& x,}@
              @\addedConcepts{unordered_map<Key, T, Hash, Pred, Alloc>\&\& y);}@
  @\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_map<Key, T, Hash, Pred, Alloc>\&\& x,}@
              @\addedConcepts{unordered_map<Key, T, Hash, Pred, Alloc>\& y);}@

  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Hash, class Pred, class Alloc>
    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
              unordered_multimap<Key, T, Hash, Pred, Alloc>& y);
  @\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>\& x,}@
              @\addedConcepts{unordered_multimap<Key, T, Hash, Pred, Alloc>\&\& y);}@
  @\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>\&\& x,}@
              @\addedConcepts{unordered_multimap<Key, T, Hash, Pred, Alloc>\& y);}@
} // namespace std
\end{codeblock}

\synopsis{Header \tcode{<unordered_set>}\ synopsis}%
\index{unordered_set@\tcode{<unordered_set>}}%
\index{unordered_set@\tcode{unordered_set}}%
\index{unordered_multiset@\tcode{unordered_multiset}}%
\begin{codeblock}
namespace std {
  // \ref{unord.set}, class template unordered_set:
  template <@\changedConcepts{class}{ValueType}@ Value,
            @\changedConcepts{class}{Callable<auto, const Value\&>}@ Hash = hash<Value>,
            @\changedConcepts{class}{Predicate<auto, Value, Value>}@ class Pred = equal_to<Value>,
            @\changedConcepts{class}{Allocator}@ Alloc = allocator<Value> >
    @\addedConcepts{requires NothrowDestructible<Value>}@
          @\addedConcepts{\&\& SameType<Hash::result_type, size_t>}@
          @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, const Pred\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, Pred\&\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, const Hash\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, Hash\&\&>}@
    class unordered_set;

  // \ref{unord.multiset}, class template unordered_multiset:
  template <@\changedConcepts{class}{ValueType}@ Value,
            @\changedConcepts{class}{Callable<auto, const Value\&>}@ Hash = hash<Value>,
            @\changedConcepts{class}{Predicate<auto, Value, Value>}@ class Pred = equal_to<Value>,
            @\changedConcepts{class}{Allocator}@ Alloc = allocator<Value> >
    @\addedConcepts{requires NothrowDestructible<Value>}@
          @\addedConcepts{\&\& SameType<Hash::result_type, size_t>}@
          @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, const Pred\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, Pred\&\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, const Hash\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, Hash\&\&>}@
    class unordered_multiset;

  template <@\changedConcepts{class}{ValueType}@ Value, class Hash, class Pred, class Alloc>
    void swap(unordered_set<Value, Hash, Pred, Alloc>& x,
              unordered_set<Value, Hash, Pred, Alloc>& y);
  @\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_set<Value, Hash, Pred, Alloc>\& x,}@
              @\addedConcepts{unordered_set<Value, Hash, Pred, Alloc>\&\& y);}@
  @\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_set<Value, Hash, Pred, Alloc>\&\& x,}@
              @\addedConcepts{unordered_set<Value, Hash, Pred, Alloc>\& y);}@

  template <@\changedConcepts{class}{ValueType}@ Value, class Hash, class Pred, class Alloc>
    void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,
              unordered_multiset<Value, Hash, Pred, Alloc>& y);
  @\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_multiset<Value, Hash, Pred, Alloc>\& x,}@
              @\addedConcepts{unordered_multiset<Value, Hash, Pred, Alloc>\&\& y);}@
  @\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_multiset<Value, Hash, Pred, Alloc>\&\& x,}@
              @\addedConcepts{unordered_multiset<Value, Hash, Pred, Alloc>\& y);}@
} // namespace std
\end{codeblock}

\rSec2[unord.map]{Class template \tcode{unordered_map}}
\index{unordered_map@\tcode{unordered_map}}%
\index{allocator}

\pnum
\index{unordered_map@\tcode{unordered_map}!unique keys}%
\index{unordered associative containers!unique keys}%
An \tcode{unordered_map} is an unordered associative container that
supports unique keys (an \tcode{unordered_map} contains at most one of each
key value) and that associates values of another type
\tcode{mapped_type} with the keys.

\pnum
An \tcode{unordered_map} satisfies all of the requirements of a container, of an unordered associative container, and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}). It provides the operations described in the preceding requirements table for unique keys; that is, an \tcode{unordered_map} supports the \tcode{a_uniq} operations in that table, not the \tcode{a_eq} operations. For an \tcode{unordered_map<Key, T>} the \tcode{key type} is \tcode{Key}, the mapped type is \tcode{T}, and the value type is \tcode{pair<const Key, T>}.

\pnum
This section only describes operations on \tcode{unordered_map} that
are not described in one of the requirement tables, or for which there
is additional semantic information.

\index{unordered_map@\tcode{unordered_map}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ Key,
            @\changedConcepts{class}{ValueType}@ T,
            @\changedConcepts{class}{Callable<auto, const Key\&>}@ Hash = hash<Key>,
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Pred = equal_to<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc = allocator<pair<const Key, T> > >
  @\addedConcepts{requires NothrowDestructible<Key> \&\& NothrowDestructible<T>}@
        @\addedConcepts{\&\& SameType<Hash::result_type, size_t>}@
        @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, const Pred\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, Pred\&\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, const Hash\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, Hash\&\&>}@
  class unordered_map
  {
  public:
    // types
    typedef Key                                      key_type;
    typedef pair<const Key, T>                  value_type;
    typedef T                                        mapped_type;
    typedef Hash                                     hasher;
    typedef Pred                                     key_equal;
    typedef Alloc                                    allocator_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef @\impdef@                   size_type;
    typedef @\impdef@                   difference_type;

    typedef @\impdef@                   iterator;
    typedef @\impdef@                   const_iterator;
    typedef @\impdef@                   local_iterator;
    typedef @\impdef@                   const_local_iterator;

    // construct/destroy/copy
    explicit unordered_map(size_type n = @\textit{implementation-defined}@,
                           const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      unordered_map(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                    size_type n = @\textit{implementation-defined}@,
                    const hasher& hf = hasher(),
                    const key_equal& eql = key_equal(),
                    const allocator_type& a = allocator_type());
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      unordered_map(const unordered_map&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@
      @\addedConcepts{unordered_map(unordered_map\&\&);}@
    unordered_map(const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      unordered_map(const unordered_map&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@
      unordered_map(unordered_map&&, const Alloc@\removedConcepts{ator}@&);
     @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
       unordered_map(initializer_list<value_type>,
                     size_type = @\impdef@,
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
    ~unordered_map();
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&> \&\& CopyAssignable<value_type>}@
      unordered_map& operator=(const unordered_map&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&> \&\& MoveAssignable<value_type>}@
      @\addedConcepts{unordered_map\& operator=(unordered_map\&\&);}@
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&> \&\& CopyAssignable<value_type>}@
      unordered_map& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const;

    // size and capacity
    bool empty() const;
    size_type size() const;
    size_type max_size() const;

    // iterators
    iterator       begin();
    const_iterator begin() const;
    iterator       end();
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    // modifiers
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace_hint(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      @\removedConcepts{}@pair<iterator, bool> insert(const value_type& obj);
    @\addedConcepts{template <class P>}@
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
      @\addedConcepts{pair<iterator, bool> insert(P\&\& obj);}@
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      iterator insert(const_iterator hint, const value_type& obj);
    @\addedConcepts{template <class P>}@
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
      @\addedConcepts{pair<iterator, bool> insert(const_iterator hint, P\&\& obj);}@
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      void insert(initializer_list<value_type>);
    iterator erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear();

    void swap(unordered_map&@\addedConcepts{\&}@);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type count(const key_type& k) const;
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const key_type\&, mapped_type\&\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, mapped_type>}@
      mapped_type& operator[](const key_type& k);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, key_type\&\&, mapped_type\&\&>}@
          @\addedConcepts{\&\& AllocatableElement<Alloc, mapped_type>}@
      @\addedConcepts{mapped_type\& operator[](key_type\&\& k);}@
    mapped_type& at(const key_type& k);
    const mapped_type& at(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type n);
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n) const;
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;  

    // hash policy
    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    @\addedConcepts{requires MoveConstructible<value_type>}@ void rehash(size_type n);
  };

  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Hash, class Pred, class Alloc>
    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_map<Key, T, Hash, Pred, Alloc>& y);
  @\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_map<Key, T, Hash, Pred, Alloc>\& x,}@
              @\addedConcepts{unordered_map<Key, T, Hash, Pred, Alloc>\&\& y);}@
  @\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_map<Key, T, Hash, Pred, Alloc>\&\& x,}@
              @\addedConcepts{unordered_map<Key, T, Hash, Pred, Alloc>\& y);}@

  @\removedConcepts{template <class Key, class T, class Hash, class Pred, class Alloc>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<}@
      @\removedConcepts{unordered_map<Key, T, Hash, Pred, Compare, Alloc> >}@
        @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}

\rSec3[unord.map.cnstr]{\tcode{unordered_map} constructors}

\index{unordered_map@\tcode{unordered_map}!unordered_map@\tcode{unordered_map}}%
\begin{itemdecl}
explicit unordered_map(size_type n = @\textit{implementation-defined}@,
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_map} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Constant.
\end{itemdescr}

\index{unordered_map@\tcode{unordered_map}!unordered_map@\tcode{unordered_map}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
          @\addedConcepts{\&\& MoveConstructible<value_type>}@
  unordered_map(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                size_type n = @\textit{implementation-defined}@,
                const hasher& hf = hasher(),
                const key_equal& eql = key_equal(),
                const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_map} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  (If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.)  Then
inserts elements from the range \tcode{[\textit{f}, \textit{l})}.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Average case linear, worst case quadratic.
\end{itemdescr}

\rSec3[unord.map.elem]{\tcode{unordered_map} element access}

\index{unordered_map@\tcode{unordered_map}!operator[]@\tcode{operator[]}}%
\index{operator[]@\tcode{operator[]}!unordered_map@\tcode{unordered_map}}%
\index{unordered_map@\tcode{unordered_map}!element access}%
\begin{itemdecl}
@\addedConcepts{requires AllocatableElement<Alloc, value_type, key_type\&\&, mapped_type\&\&>}@
      @\addedConcepts{\&\& AllocatableElement<Alloc, mapped_type>}@
  mapped_type& operator[](const key_type& k);

@\addedConcepts{requires AllocatableElement<Alloc, value_type, key_type\&\&, mapped_type\&\&>}@
      @\addedConcepts{\&\& AllocatableElement<Alloc, mapped_type>}@
  @\addedConcepts{mapped_type\& operator[](key_type\&\& k);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ If the \tcode{unordered_map} does not already contain
an element whose key is equivalent to \tcode{\textit{k}}, inserts 
the value
\tcode{pair<const key_type, mapped_type>(k, mapped_type())}
\addedConcepts{or
\mbox{\tcode{pair<const key_type,}}}\\
\addedConcepts{\mbox{\tcode{mapped_type>(move(k), mapped_type())}}, respectively}.

\pnum
\returns\ A reference to \tcode{x.second}, where \tcode{x}
is the (unique) element whose key is equivalent to \tcode{\textit{k}}.
\end{itemdescr}

\begin{itemdecl}
mapped_type& at(const key_type& k);
const mapped_type& at(const key_type& k) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ A reference to \tcode{x.second}, where \tcode{x} is the (unique) element whose key is equivalent to \tcode{k}.

\pnum
\throws An exception object of type \tcode{out_of_range} if no such element is present.
\end{itemdescr}

\rSec3[unord.map.swap]{\tcode{unordered_map} swap}

\index{unordered_map@\tcode{unordered_map}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!unordered_map@\tcode{unordered_map}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Hash, class Pred, class Alloc>
  void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
            unordered_map<Key, T, Hash, Pred, Alloc>& y);
@\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
  @\addedConcepts{void swap(unordered_map<Key, T, Hash, Pred, Alloc>\& x,}@
            @\addedConcepts{unordered_map<Key, T, Hash, Pred, Alloc>\&\& y);}@
@\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
  @\addedConcepts{void swap(unordered_map<Key, T, Hash, Pred, Alloc>\&\& x,}@
            @\addedConcepts{unordered_map<Key, T, Hash, Pred, Alloc>\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ \tcode{x.swap(y)}.
\end{itemdescr}

\rSec2[unord.multimap]{Class template \tcode{unordered_multimap}}
\index{unordered_multimap@\tcode{unordered_multimap}}%
\index{allocator}

\pnum
\index{unordered_multimap@\tcode{unordered_multimap}!equivalent keys}%
\index{unordered associative containers!equivalent keys}%
An \tcode{unordered_multimap} is an unordered associative container
that supports equivalent keys (an \tcode{unordered_multimap} may contain
multiple copies of each key value) and that associates values of
another type \tcode{mapped_type} with the keys.

\pnum
An \tcode{unordered_multimap} satisfies all of the requirements of a container, of an unordered associative container, and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}). It provides the operations described in the preceding requirements table for equivalent keys; that is, an \tcode{unordered_multimap} supports the \tcode{a_eq} operations in that table, not the \tcode{a_uniq} operations. For an \tcode{unordered_multimap<Key, T>} the \tcode{key type} is \tcode{Key}, the mapped type is \tcode{T}, and the value type is \tcode{pair<const Key, T>}.

\pnum
This section only describes operations on \tcode{unordered_multimap}
that are not described in one of the requirement tables, or for which
there is additional semantic information.

\index{unordered_multimap@\tcode{unordered_multimap}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ Key,
            @\changedConcepts{class}{ValueType}@ T,
            @\changedConcepts{class}{Callable<auto, const Key\&>}@ Hash = hash<Key>,
            @\changedConcepts{class}{Predicate<auto, Key, Key>}@ Pred = equal_to<Key>,
            @\changedConcepts{class}{Allocator}@ Alloc = allocator<pair<const Key, T> > >
  @\addedConcepts{requires NothrowDestructible<Key> \&\& NothrowDestructible<T>}@
        @\addedConcepts{\&\& SameType<Hash::result_type, size_t>}@
        @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, const Pred\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, Pred\&\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, const Hash\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, Hash\&\&>}@
  class unordered_multimap
  {
  public:
    // types
    typedef Key                                      key_type;
    typedef pair<const Key, T>                  value_type;
    typedef T                                        mapped_type;
    typedef Hash                                     hasher;
    typedef Pred                                     key_equal;
    typedef Alloc                                    allocator_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef @\impdef@                   size_type;
    typedef @\impdef@                   difference_type;

    typedef @\impdef@                   iterator;
    typedef @\impdef@                   const_iterator;
    typedef @\impdef@                   local_iterator;
    typedef @\impdef@                   const_local_iterator;

    // construct/destroy/copy
    explicit unordered_multimap(size_type n = @\textit{implementation-defined}@,
                                const hasher& hf = hasher(),
                                const key_equal& eql = key_equal(),
                                const allocator_type& a = allocator_type());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      unordered_multimap(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                         size_type n = @\textit{implementation-defined}@,
                         const hasher& hf = hasher(),
                         const key_equal& eql = key_equal(),
                         const allocator_type& a = allocator_type());
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      unordered_multimap(const unordered_multimap&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@
      @\addedConcepts{unordered_multimap(unordered_multimap\&\&);}@
    unordered_multimap(const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
       unordered_multimap(const unordered_multimap&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@
       unordered_multimap(unordered_multimap&&, const Alloc@\removedConcepts{ator}@&);
     @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
       unordered_multimap(initializer_list<value_type>,
                          size_type = @\impdef@,
                          const hasher& hf = hasher(),
                          const key_equal& eql = key_equal(),
                          const allocator_type& a = allocator_type());
    ~unordered_multimap();
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&> \&\& CopyAssignable<value_type>}@
      unordered_multimap& operator=(const unordered_multimap&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&> \&\& MoveAssignable<value_type>}@
      @\addedConcepts{unordered_multimap\& operator=(unordered_multimap\&\&);}@
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&> \&\& CopyAssignable<value_type>}@
      unordered_multimap& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const;

    // size and capacity
    bool empty() const;
    size_type size() const;
    size_type max_size() const;

    // iterators
    iterator       begin();
    const_iterator begin() const;
    iterator       end();
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    // modifiers
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace_hint(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const value_type& obj);
    @\addedConcepts{template <class P>}@
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
      @\addedConcepts{iterator insert(P\&\& obj);}@
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const_iterator hint, const value_type& obj);
    @\addedConcepts{template <class P>}@
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, P\&\&> \&\& MoveConstructible<value_type>}@
      @\addedConcepts{iterator insert(const_iterator hint, P\&\& obj);}@
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      void insert(initializer_list<value_type>);

    iterator erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear();

    void swap(unordered_multimap&@\addedConcepts{\&}@);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type count(const key_type& k) const;
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type n);
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n) const;
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;  

    // hash policy
    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    @\addedConcepts{requires MoveConstructible<value_type>}@ void rehash(size_type n);
  };

  template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Hash, class Pred, class Alloc>
    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
              unordered_multimap<Key, T, Hash, Pred, Alloc>& y);
  @\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>\& x,}@
              @\addedConcepts{unordered_multimap<Key, T, Hash, Pred, Alloc>\&\& y);}@
  @\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>\&\& x,}@
              @\addedConcepts{unordered_multimap<Key, T, Hash, Pred, Alloc>\& y);}@

  @\removedConcepts{template <class Key, class T, class Hash, class Pred, class Alloc>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<}@
      @\removedConcepts{unordered_multimap<Key, T, Hash, Pred, Alloc> >}@
        @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}

\rSec3[unord.multimap.cnstr]{\tcode{unordered_multimap} constructors}

\index{unordered_multimap@\tcode{unordered_multimap}!unordered_multimap@\tcode{unordered_multimap}}%
\begin{itemdecl}
explicit unordered_multimap(size_type n = @\textit{implementation-defined}@,
                            const hasher& hf = hasher(),
                            const key_equal& eql = key_equal(),
                            const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_multimap} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Constant.
\end{itemdescr}

\index{unordered_multimap@\tcode{unordered_multimap}!unordered_multimap@\tcode{unordered_multimap}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
        @\addedConcepts{\&\& MoveConstructible<value_type>}@
  unordered_multimap(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                     size_type n = @\textit{implementation-defined}@,
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_multimap} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  (If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.)  Then
inserts elements from the range \tcode{[\textit{f}, \textit{l})}.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Average case linear, worst case quadratic.
\end{itemdescr}

\rSec3[unord.multimap.swap]{\tcode{unordered_multimap} swap}

\index{unordered_multimap@\tcode{unordered_multimap}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!unordered_multimap@\tcode{unordered_multimap}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ Key, @\changedConcepts{class}{ValueType}@ T, class Hash, class Pred, class Alloc>
  void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
            unordered_multimap<Key, T, Hash, Pred, Alloc>& y);
@\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
  @\addedConcepts{void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>\& x,}@
            @\addedConcepts{unordered_multimap<Key, T, Hash, Pred, Alloc>\&\& y);}@
@\addedConcepts{template <ValueType Key, ValueType T, class Hash, class Pred, class Alloc>}@
  @\addedConcepts{void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>\&\& x,}@
            @\addedConcepts{unordered_multimap<Key, T, Hash, Pred, Alloc>\& y);}@
\end{itemdecl}


\begin{itemdescr}
\pnum\effects\ \tcode{x.swap(y)}.
\end{itemdescr}

\rSec2[unord.set]{Class template \tcode{unordered_set}}
\index{unordered_set@\tcode{unordered_set}}%

\pnum
\index{unordered_set@\tcode{unordered_set}!unique keys}%
\index{unordered associative containers!unique keys}%
An \tcode{unordered_set} is an unordered associative container that
supports unique keys (an \tcode{unordered_set} contains at most one of each
key value) and in which the elements' keys are the elements
themselves.

\pnum
An \tcode{unordered_set} satisfies all of the requirements of a container, of an unordered associative container, and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}). It provides the operations described in the preceding requirements table for unique keys; that is, an \tcode{unordered_set} supports the \tcode{a_uniq} operations in that table, not the \tcode{a_eq} operations. For an \tcode{unordered_set<Value>} the \tcode{key type} and the value type are both \tcode{Value}. The \tcode{iterator} and \tcode{const_iterator} types are both const iterator types. It is unspecified whether they are the same type.

\pnum
This section only describes operations on \tcode{unordered_set} that
are not described in one of the requirement tables, or for which there
is additional semantic information.

\index{unordered_set@\tcode{unordered_set}}%
\index{allocator}
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ Value,
            @\changedConcepts{class}{Callable<auto, const Value\&>}@ Hash = hash<Value>,
            @\changedConcepts{class}{Predicate<auto, Value, Value>}@ class Pred = equal_to<Value>,
            @\changedConcepts{class}{Allocator}@ Alloc = allocator<Value> >
  @\addedConcepts{requires NothrowDestructible<Value>}@
        @\addedConcepts{\&\& SameType<Hash::result_type, size_t>}@
        @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, const Pred\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, Pred\&\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, const Hash\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, Hash\&\&>}@
  class unordered_set
  {
  public:
    // types
    typedef Value                                    key_type;
    typedef Value                                    value_type;
    typedef Hash                                     hasher;
    typedef Pred                                     key_equal;
    typedef Alloc                                    allocator_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef @\impdef@                   size_type;
    typedef @\impdef@                   difference_type;

    typedef @\impdef@                   iterator;
    typedef @\impdef@                   const_iterator;
    typedef @\impdef@                   local_iterator;
    typedef @\impdef@                   const_local_iterator;

    // construct/destroy/copy
    explicit unordered_set(size_type n = @\textit{implementation-defined}@,
                           const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      unordered_set(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                    size_type n = @\textit{implementation-defined}@,
                    const hasher& hf = hasher(),
                    const key_equal& eql = key_equal(),
                    const allocator_type& a = allocator_type());
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      unordered_set(const unordered_set&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@ 
      @\addedConcepts{unordered_set(unordered_set\&\&);}@
    unordered_set(const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      unordered_set(const unordered_set&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@
      unordered_set(unordered_set&&, const Alloc@\removedConcepts{ator}@&);
     @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
       unordered_set(initializer_list<value_type>,
                     size_type = @\impdef@,
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
    ~unordered_set();
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&> \&\& CopyAssignable<value_type>}@
      unordered_set& operator=(const unordered_set&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&> \&\& MoveAssignable<value_type>}@
      @\addedConcepts{unordered_set\& operator=(unordered_set\&\&);}@
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&> \&\& CopyAssignable<value_type>}@
      unordered_set& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const;

    // size and capacity
    bool empty() const;
    size_type size() const;
    size_type max_size() const;

    // iterators
    iterator       begin();
    const_iterator begin() const;
    iterator       end();
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    // modifiers
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace_hint(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      @\removedConcepts{}@pair<iterator, bool> insert(const value_type& obj);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@ 
      @\addedConcepts{pair<iterator, bool> insert(value_type\&\& obj);}@
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const_iterator hint, const value_type& obj);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@ 
      @\addedConcepts{iterator insert(const_iterator hint, value_type\&\& obj);}@
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@ 
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      void insert(initializer_list<value_type>);

    iterator erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear();

    void swap(unordered_set&@\addedConcepts{\&}@);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type count(const key_type& k) const;
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;  

    // hash policy
    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    @\addedConcepts{requires MoveConstructible<value_type>}@ void rehash(size_type n);
  };

  template <@\changedConcepts{class}{ValueType}@ Value, class Hash, class Pred, class Alloc>
    void swap(unordered_set<Value, Hash, Pred, Alloc>& x,
              unordered_set<Value, Hash, Pred, Alloc>& y);
  @\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_set<Value, Hash, Pred, Alloc>\& x,}@
              @\addedConcepts{unordered_set<Value, Hash, Pred, Alloc>\&\& y);}@
  @\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_set<Value, Hash, Pred, Alloc>\&\& x,}@
              @\addedConcepts{unordered_set<Value, Hash, Pred, Alloc>\& y);}@

  @\removedConcepts{template <class Value, class Hash, class Pred, class Alloc>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<}@
      @\removedConcepts{map<Value, Hash, Pred, Alloc> >}@
        @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}

\rSec3[unord.set.cnstr]{\tcode{unordered_set} constructors}

\index{unordered_set@\tcode{unordered_set}!unordered_set@\tcode{unordered_set}}%
\begin{itemdecl}
explicit unordered_set(size_type n = @\textit{implementation-defined}@,
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_set} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  If \textit{\tcode{n}} is not
provided, the number of buckets is implementation
defined.  \tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Constant.
\end{itemdescr}

\index{unordered_set@\tcode{unordered_set}!unordered_set@\tcode{unordered_set}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
        @\addedConcepts{\&\& MoveConstructible<value_type>}@
  unordered_set(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                size_type n = @\textit{implementation-defined}@,
                const hasher& hf = hasher(),
                const key_equal& eql = key_equal(),
                const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_set} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  (If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.)  Then
inserts elements from the range \tcode{[\textit{f}, \textit{l})}.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Average case linear, worst case quadratic.
\end{itemdescr}

\rSec3[unord.set.swap]{\tcode{unordered_set} swap}

\index{unordered_set@\tcode{unordered_set}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!unordered_set@\tcode{unordered_set}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ Value, class Hash, class Pred, class Alloc>
  void swap(unordered_set<Value, Hash, Pred, Alloc>& x,
            unordered_set<Value, Hash, Pred, Alloc>& y);
@\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
  @\addedConcepts{void swap(unordered_set<Value, Hash, Pred, Alloc>\& x,}@
            @\addedConcepts{unordered_set<Value, Hash, Pred, Alloc>\&\& y);}@
@\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
  @\addedConcepts{void swap(unordered_set<Value, Hash, Pred, Alloc>\&\& x,}@
            @\addedConcepts{unordered_set<Value, Hash, Pred, Alloc>\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ \tcode{x.swap(y)}.
\end{itemdescr}

\rSec2[unord.multiset]{Class template \tcode{unordered_multiset}}
\index{unordered_multiset@\tcode{unordered_multiset}}%
\index{allocator}

\pnum
\index{unordered_multiset@\tcode{unordered_multiset}!equivalent keys}%
\index{unordered associative containers!equivalent keys}%
An \tcode{unordered_multiset} is an unordered associative container
that supports equivalent keys (an \tcode{unordered_multiset} may contain
multiple copies of the same key value) and in which each element's key
is the element itself.

\pnum
An \tcode{unordered_multiset} satisfies all of the requirements of a container, of an unordered associative container, and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}). It provides the operations described in the preceding requirements table for equivalent keys; that is, an \tcode{unordered_multiset} supports the \tcode{a_eq} operations in that table, not the \tcode{a_uniq} operations. For an \tcode{unordered_multiset<Value>} the \tcode{key type} and the value type are both \tcode{Value}. The \tcode{iterator} and \tcode{const_iterator} types are both const iterator types. It is unspecified whether they are the same type.

\pnum
This section only describes operations on \tcode{unordered_multiset} that
are not described in one of the requirement tables, or for which there
is additional semantic information.

\index{unordered_multiset@\tcode{unordered_multiset}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ValueType}@ Value,
            @\changedConcepts{class}{Callable<auto, const Value\&>}@ Hash = hash<Value>,
            @\changedConcepts{class}{Predicate<auto, Value, Value>}@ class Pred = equal_to<Value>,
            @\changedConcepts{class}{Allocator}@ Alloc = allocator<Value> >
  @\addedConcepts{requires NothrowDestructible<Value>}@
        @\addedConcepts{\&\& SameType<Hash::result_type, size_t>}@
        @\addedConcepts{\&\& CopyConstructible<Hash> \&\& CopyConstructible<Pred>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, const Pred\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Pred, Pred\&\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, const Hash\&>}@
        @\addedConcepts{\&\& AllocatableElement<Alloc, Hash, Hash\&\&>}@
  class unordered_multiset
  {
  public:
    // types
    typedef Value                                    key_type;
    typedef Value                                    value_type;
    typedef Hash                                     hasher;
    typedef Pred                                     key_equal;
    typedef Alloc                                    allocator_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef @\impdef@                   size_type;
    typedef @\impdef@                   difference_type;

    typedef @\impdef@                   iterator;
    typedef @\impdef@                   const_iterator;
    typedef @\impdef@                   local_iterator;
    typedef @\impdef@                   const_local_iterator;

    // construct/destroy/copy
    explicit unordered_multiset(size_type n = @\textit{implementation-defined}@,
                                const hasher& hf = hasher(),
                                const key_equal& eql = key_equal(),
                                const allocator_type& a = allocator_type());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      unordered_multiset(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                         size_type n = @\textit{implementation-defined}@,
                         const hasher& hf = hasher(),
                         const key_equal& eql = key_equal(),
                         const allocator_type& a = allocator_type());
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      unordered_multiset(const unordered_multiset&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@ 
      @\addedConcepts{unordered_multiset(unordered_multiset\&\&);}@
    unordered_multiset(const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      unordered_multiset(const unordered_multiset&, const Alloc@\removedConcepts{ator}@&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@
      unordered_multiset(unordered_multiset&&, const Alloc@\removedConcepts{ator}@&);
     @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
       unordered_multiset(initializer_list<value_type>,
                          size_type = @\impdef@,
                          const hasher& hf = hasher(),
                          const key_equal& eql = key_equal(),
                          const allocator_type& a = allocator_type());
    ~unordered_multiset();
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&> \&\& CopyAssignable<value_type>}@
      unordered_multiset& operator=(const unordered_multiset&);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&> \&\& MoveAssignable<value_type>}@
      @\addedConcepts{unordered_multiset\& operator=(unordered_multiset\&\&);}@
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&> \&\& CopyAssignable<value_type>}@
      unordered_multiset& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const;

    // size and capacity
    bool empty() const;
    size_type size() const;
    size_type max_size() const;

    // iterators
    iterator       begin();
    const_iterator begin() const;
    iterator       end();
    const_iterator end() const;
    const_iterator cbegin() const;
    const_iterator cend() const;

    // modifiers
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Args\&\&...>}@
      iterator emplace_hint(const_iterator position, Args&&... args);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const value_type& obj);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@ 
      @\addedConcepts{iterator insert(value_type\&\& obj);}@
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@ 
      iterator insert(const_iterator hint, const value_type& obj);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, value_type\&\&>}@ 
      @\addedConcepts{iterator insert(const_iterator hint, value_type\&\& obj);}@
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@> 
      @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::value_type>}@
            @\addedConcepts{\&\& MoveConstructible<value_type>}@
      void insert(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
    @\addedConcepts{requires AllocatableElement<Alloc, value_type, const value_type\&>}@
      void insert(initializer_list<value_type>);

    iterator erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear();

    void swap(unordered_multiset&@\addedConcepts{\&}@);

    // observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type count(const key_type& k) const;
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // bucket interface
    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type n);
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n) const;
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;  

    // hash policy
    float load_factor() const;
    float max_load_factor() const;
    void max_load_factor(float z);
    @\addedConcepts{requires MoveConstructible<value_type>}@ void rehash(size_type n);
  };

  template <@\changedConcepts{class}{ValueType}@ Value, class Hash, class Pred, class Alloc>
    void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,
              unordered_multiset<Value, Hash, Pred, Alloc>& y);
  @\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_multiset<Value, Hash, Pred, Alloc>\& x,}@
              @\addedConcepts{unordered_multiset<Value, Hash, Pred, Alloc>\&\& y);}@
  @\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
    @\addedConcepts{void swap(unordered_multiset<Value, Hash, Pred, Alloc>\&\& x,}@
              @\addedConcepts{unordered_multiset<Value, Hash, Pred, Alloc>\& y);}@

  @\removedConcepts{template <class Value, class Hash, class Pred, class Alloc>}@
    @\removedConcepts{struct constructible_with_allocator_suffix<}@
      @\removedConcepts{unordered_multiset<Value, Hash, Pred, Alloc> >}@
        @\removedConcepts{: true_type \{ \};}@
}
\end{codeblock}

\rSec3[unord.multiset.cnstr]{\tcode{unordered_multiset} constructors}

\index{unordered_multiset@\tcode{unordered_multiset}!unordered_multiset@\tcode{unordered_multiset}}%
\begin{itemdecl}
explicit unordered_multiset(size_type n = @\textit{implementation-defined}@,
                            const hasher& hf = hasher(),
                            const key_equal& eql = key_equal(),
                            const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ Constructs an empty \tcode{unordered_multiset} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.
\tcode{max_load_factor()} returns 1.0.

\pnum
\complexity\ Constant.
\end{itemdescr}

\index{unordered_multiset@\tcode{unordered_multiset}!unordered_multiset@\tcode{unordered_multiset}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires AllocatableElement<Alloc, value_type, Iter::reference>}@
        @\addedConcepts{\&\& MoveConstructible<value_type>}@
  unordered_multiset(@\changedConcepts{InputIterator}{Iter}@ f, @\changedConcepts{InputIterator}{Iter}@ l,
                     size_type n = @\textit{implementation-defined}@,
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ 
Constructs an empty \tcode{unordered_multiset} using the
specified hash function, key equality function, and allocator, and
using at least \textit{\tcode{n}} buckets.  (If \textit{\tcode{n}} is not
provided, the number of buckets is implementation defined.)  Then
inserts elements from the range \tcode{[\textit{f}, \textit{l})}.
\tcode{max_load_factor()} returns 1.0.

\pnum\complexity\ Average case linear, worst case quadratic.
\end{itemdescr}

\rSec3[unord.multiset.swap]{\tcode{unordered_multiset} swap}

\index{unordered_multiset@\tcode{unordered_multiset}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!unordered_multiset@\tcode{unordered_multiset}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ValueType}@ Value, class Hash, class Pred, class Alloc>
  void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,
            unordered_multiset<Value, Hash, Pred, Alloc>& y);
@\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
  @\addedConcepts{void swap(unordered_multiset<Value, Hash, Pred, Alloc>\& x,}@
            @\addedConcepts{unordered_multiset<Value, Hash, Pred, Alloc>\&\& y);}@
@\addedConcepts{template <ValueType Value, class Hash, class Pred, class Alloc>}@
  @\addedConcepts{void swap(unordered_multiset<Value, Hash, Pred, Alloc>\&\& x,}@
            @\addedConcepts{unordered_multiset<Value, Hash, Pred, Alloc>\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ \tcode{x.swap(y);}
\end{itemdescr}

\index{unordered associative containers|)}

\bibliographystyle{plain}
\bibliography{local}

\end{document}