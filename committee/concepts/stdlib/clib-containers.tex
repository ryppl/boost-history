\documentclass[american,twoside]{book}
\usepackage{refbib}
\usepackage{hyperref}
\input{macros}

%%--------------------------------------------------
%% Set section numbering limit, toc limit
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{1}

%%--------------------------------------------------
%% Parameters that govern document appearance
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.6in}

%%--------------------------------------------------
%% Handle special hyphenation rules
\hyphenation{tem-plate ex-am-ple in-put-it-er-a-tor}

% Do not put blank pages after chapters that end on odd-numbered pages.
\def\cleardoublepage{\clearpage\if@twoside%
  \ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage%
  \if@twocolumn\hbox{}\newpage\fi\fi\fi}

\begin{document}
\raggedbottom

\begin{titlepage}
\begin{center}
\huge
Concepts for the C++0x Standard Library: Containers\\
(Revision 1)

\vspace{0.5in}

\normalsize
Douglas Gregor  \\
Open Systems Laboratory \\
Indiana University \\
Bloomington, IN\ \  47405 \\
\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}
\end{center}

\vspace{1in}
\par\noindent Document number: D2623=08-0133\vspace{-6pt}
\par\noindent Revises document number: N2085=06-0155\vspace{-6pt}
\par\noindent Date: \today\vspace{-6pt}
\par\noindent Project: Programming Language \Cpp{}, Library Working Group\vspace{-6pt}
\par\noindent Reply-to: Douglas Gregor $<$\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}$>$\vspace{-6pt}

\section*{Introduction}
\libintrotext{Chapter 23}
\end{titlepage}

%%--------------------------------------------------
%% Headers and footers
\pagestyle{fancy}
\fancyhead[LE,RO]{\textbf{\rightmark}}
\fancyhead[RE]{\textbf{\leftmark\hspace{1em}\thepage}}
\fancyhead[LO]{\textbf{\thepage\hspace{1em}\leftmark}}
\fancyfoot[C]{Draft}

\fancypagestyle{plain}{
\renewcommand{\headrulewidth}{0in}
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\fancyfoot{}
}

\renewcommand{\sectionmark}[1]{\markright{\thesection\hspace{1em}#1}}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

\color{black}

\setcounter{chapter}{22}
\rSec0[lib.containers]{Containers library}

\pnum
This clause describes components that \Cpp\ programs may use to
organize collections of information.

\pnum
The following subclauses describe
container \changedConcepts{requirements}{concepts},
and components for
sequences and
associative containers,
as summarized in
Table~\ref{tab:containers.lib.summary}:

\begin{libsumtab}{Containers library summary}{tab:containers.lib.summary}
\ref{lib.container.requirements} Requirements   &   \addedConcepts{\ttfamily <container>}                    \\ \rowsep
\ref{lib.sequences} Sequences                   &   \tcode{<array>}     \\
                                                &   \tcode{<deque>}     \\
                                                &   \tcode{<list>}      \\
                                                &   \tcode{<queue>}     \\
                                                &   \tcode{<stack>}     \\
                                                &   \tcode{<vector>}    \\ \rowsep
\ref{lib.associative} Associative containers    &   \tcode{<map>}       \\
                                                &   \tcode{<set>}       \\
\ref{lib.template.bitset} \tcode{bitset}        &   \tcode{<bitset>}    \\ \rowsep
\ref{lib.unord} \addedB{Unordered associative containers}&   \tcode{<unordered_map>}       \\
                                                &   \tcode{<unordered_set>}       \\
\end{libsumtab}

\rSec1[lib.container.requirements]{Container requirements}
\index{requirements!container}%

\pnum
Containers are objects that store other objects.
They control allocation and deallocation of these objects
through constructors, destructors, insert and erase operations.

\pnum
All of the complexity requirements in this clause are stated solely
in terms of the number of operations on the contained objects.
\enterexample\ 
the copy constructor of type
\tcode{vector <vector<int> >}\
has linear complexity,
even though the complexity of copying each contained
\tcode{vector<int>}\
is itself linear.
\exitexample\ 

\pnum
\removedConcepts{The type of objects stored in these components shall meet the requirements of
CopyConstructible
types (20.1.3).}

\pnum
\removedConcepts{Table~79 defines the Assignable requirement.
Some containers require this property of the types to be stored in the
container.
T
is the type used to instantiate the container,
t is a value of T,
and u is a value of (possibly
const) T.}

\eremove{Remove Table 79: Assignable requirements. Assignable is now a
  concept in Chapter 20.}

\color{addclr}
\synopsis{Header \tcode{<container>}\ synopsis}

\color{black}
\editorial{Note: Synchronize this with the rest of the text.}
\color{addclr}

\pnum
\removedConcepts{In Tables~80 and
81, X
denotes a container class containing objects of type
T, a and b
denote values of type X, u
denotes an identifier and r
denotes a value of X\&.} \color{addclr} The \tcode{Container}\ concept
describes the requirements common to all containers.

\begin{itemdecl}
concept Container<typename X> : DefaultConstructible<X>
{
  typename value_type =            X::value_type;
  typename reference =             X::reference;
  typename const_reference =       X::const_reference;
  InputIterator iterator =         X::iterator;
  InputIterator const_iterator =   X::const_iterator;
  SignedIntegral difference_type = X::difference_type;
  UnsignedIntegral size_type =     X::size_type;

  where Convertible<reference, value_type&> &&
        Convertible<const_reference, value_type const&>;

  where Convertible<iterator, const_iterator> &&
        SameType<iterator::value_type, value_type> &&
        SameType<const_iterator::value_type, value_type>;
 
  where SameType<difference_type, iterator::difference_type> &&
        SameType<difference_type, const_iterator::difference_type>;

  iterator       X::begin();
  const_iterator X::begin() const;
  iterator       X::end();
  const_iterator X::end() const;

  const_iterator X::cbegin() const;
  const_iterator X::cend() const;

  void X::swap(X&);

  size_type X::size() const;
  size_type X::max_size() const;
  bool X::empty() const;
}
\end{itemdecl}

\color{black}
\eremove{Remove Table 80: Container requirements}

\editorial{In translating the requirements table into a concept, we
  have fixed numerous places where the requirements table required a
  non-constant container, but where a constant container would
  work. This should not break any existing code.}
\color{addclr}

\begin{itemdecl}
X::X()
\end{itemdecl}

\begin{itemdescr}
\pnum
\postcondition\
\tcode{size() == 0}

\pnum
\complexity\
constant
\end{itemdescr}

\begin{itemdecl}
X::~X()
\end{itemdecl}

\begin{itemdescr}
\pnum
\note\
the destructor is applied to every element of \changedConcepts{a}{the
  container}; all the memory is deallocated

\pnum
\complexity\
linear
\end{itemdescr}

\begin{itemdecl}
iterator       X::begin();
const_iterator X::begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
an iterator referring to the first element in the container.
\pnum
\complexity\
constant
\end{itemdescr}

\begin{itemdecl}
iterator       X::end();
const_iterator X::end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
returns an iterator which is the past-the-end value for the container.
If the container is empty, then
\tcode{begin() == end()};

\pnum
\complexity\
constant
\end{itemdescr}

\begin{itemdecl}
const_iterator X::cbegin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_cast<X const\&>(*this).begin()}

\pnum
\complexity\
constant
\end{itemdescr}

\begin{itemdecl}
const_iterator X::cend() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_cast<X const\&>(*this).end()}

\pnum
\complexity\
constant
\end{itemdescr}

\begin{itemdecl}
void X::swap(X& b)
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
\tcode{swap(*this, b)}

\pnum
\complexity\
should be constant
\end{itemdescr}

\begin{itemdecl}
size_type X::size() const
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
returns the number of elements in the container.

\pnum
\complexity\
should be constant

\pnum
\note\
\changedConcepts{Its semantics}{The semantics of size()} is defined by the rules of constructors, inserts, and erases.
\end{itemdescr}

\begin{itemdecl}
size_type X::max_size() const
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{size()}\ of the largest possible container

\pnum
\complexity\
should be constant
\end{itemdescr}

\begin{itemdecl}
bool X::empty() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{size() == 0}

\pnum
\complexity\
constant
\end{itemdescr}

\pnum
In the expressions
\begin{codeblock}
    i == j
    i != j
    i < j
    i <= j
    i >= j
    i > j
    i - j
\end{codeblock}
where
\tcode{i}\
and
\tcode{j}\
denote objects of a container's
\tcode{iterator}\
type, either or both may be replaced by an object of the container's
\tcode{const_iterator}\
type referring to the same element with no change in semantics.

\color{black}
\editorial{The requirements table for containers calls for copy
  construction, assignment, and various comparison operators. However,
  these operators only work when the value type supports copy
  construction, assignment, etc. To capture this behaviro, we state
  these requirements via concept map templates.}
\color{addclr}

\begin{itemdecl}
@\textcolor{addclr}{template}@<Container X>
where CopyConstructible<X::value_type>
concept_map CopyConstructible<X> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
If the \tcode{value_type}\ of a container is
\tcode{CopyConstructible}, the container shall be
\tcode{CopyConstructible}

\pnum
\complexity\
linear
\end{itemdescr}

\begin{itemdecl}
template<Container X>
where Assignable<X::value_type>
concept_map Assignable<X> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
If the \tcode{value_type}\ of a container is
\tcode{Assignable}, the container shall be
\tcode{Assignable}

\pnum
\complexity\
linear
\end{itemdescr}

\begin{itemdecl}
template<Container X>
where EqualityComparable<X::value_type>
concept_map EqualityComparable<X> 
{ 
  bool operator==(X a, X b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
If the \tcode{value_type}\ of a container is
\tcode{EqualityComparable}, the container shall be
\tcode{EqualityComparable}
\end{itemdescr}

\begin{itemdecl}
bool operator==(X a, X b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
 \tcode{==}\ is an equivalence relation.

\pnum
\returns\
 \tcode{a.size() == b.size()}
 \tcode{\&\& equal(a.begin(),}
 \tcode{a.end(), b.begin()}

\pnum
\complexity\
linear
\end{itemdescr}

\begin{itemdecl}
template<Container X>
where LessThanComparable<X::value_type>
concept_map LessThanComparable<X> 
{ 
  bool operator<(X a, X b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
If the \tcode{value_type}\ of a container is
\tcode{LessThanComparable}, the container shall be
\tcode{LessThanComparable}
\end{itemdescr}

\begin{itemdecl}
bool operator<(X a, X b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
 \tcode{lexicographical_compare( a.begin(), a.end(), b.begin(), b.end())}

\pnum
\complexity\
linear
\end{itemdescr}

\color{black}

\pnum
Copy constructors for all container types defined in this clause
copy an allocator argument from their respective first parameters.
All other constructors for these container types take an
\tcode{Allocator\&}\
argument (\ref{lib.allocator.requirements}),
an allocator whose value type is the same as the container's value type.
A copy of this argument is used for any memory allocation
performed, by these constructors and by all member functions, during
the lifetime of each container object.
In all container types defined
in this clause, the member \tcode{get_allocator()}\ returns a copy
of the Allocator object used to construct the container.%
\footnote{As specified in~\ref{lib.allocator.requirements}, \removedConcepts{paragraphs 4-5},
the semantics described in this clause applies only to the case where
allocators compare equal.
}

\pnum
\addedConcepts{Containers that provide the ability to traverse their
  elements in reverse order are called reversible.}

\color{addclr}
\begin{itemdecl}
concept ReversibleContainer<typename X> : Container<X> {
  MutableBidirectionalIterator reverse_iterator       = X::reverse_iterator;
  BidirectionalIterator const_reverse_iterator = X::const_reverse_iterator;

  where MutableBidirectionalIterator<iterator> &&
        BidirectionalIterator<const_iterator>;

  where SameType<iterator::value_type, reverse_iterator::value_type> &&
        SameType<const_iterator::value_type, const_reverse_iterator::value_type>;

  reverse_iterator       X::rbegin();
  const_reverse_iterator X::rbegin() const;
  reverse_iterator       X::rend();
  const_reverse_iterator X::rend() const;
  const_reverse_iterator X::crbegin() const;
  const_reverse_iterator X::crend() const;
}
\end{itemdecl}
\color{black}

\eremove{Remove Table 81: Reversible container requirements}

\pnum
If the iterator type of a container \changedConcepts{belongs to the bidirectional or
random access iterator categories}{is bidirectional or random access} (\ref{lib.iterator.requirements}),
\changedConcepts{the container is called
reversible
and satisfies the additional requirements
in Table~81}{the container is reversible.}

\color{addclr}
\begin{itemdecl}
template<Container X>
where MutableBidirectionalIterator<X::iterator> &&
      BidirectionalIterator<X::const_iterator>
concept_map ReversibleContainer<X>
{
  typedef std::reverse_iterator<X::iterator>       reverse_iterator;
  typedef std::reverse_iterator<X::const_iterator> const_reverse_iterator;

  @\textcolor{addclr}{reverse}@_iterator       X::rbegin();
  const_reverse_iterator X::rbegin() const;
  reverse_iterator       X::rend();
  const_reverse_iterator X::rend() const;
  const_reverse_iterator X::crbegin() const;
  const_reverse_iterator X::crend() const;
}
\end{itemdecl}

\begin{itemdecl}
reverse_iterator       X::rbegin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{reverse_iterator(end())}
\end{itemdescr}

\begin{itemdecl}
const_reverse_iterator       X::rbegin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_reverse_iterator(end())}
\end{itemdescr}

\begin{itemdecl}
reverse_iterator       X::rend();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_reverse_iterator(begin())}
\end{itemdescr}

\begin{itemdecl}
const_reverse_iterator       X::rend() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_reverse_iterator(begin())}
\end{itemdescr}

\begin{itemdecl}
const_reverse_iterator X::crbegin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_cast<const X\&>(*this).rbegin()}
\end{itemdescr}

\begin{itemdecl}
const_reverse_iterator X::crend() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{const_cast<const X\&>(*this).rend()}
\end{itemdescr}

\color{black}

\pnum
Unless otherwise specified (see~\ref{lib.deque.modifiers}\ and
\ref{lib.vector.modifiers})
all container types defined in this clause meet
the following additional requirements:

\begin{itemize}
\item
if an exception is thrown by an
\tcode{insert()}
function while inserting a single element, that
function has no effects.
\item
if an exception is thrown by a
\tcode{push_back()}
or
\tcode{push_front()}
function, that function has no effects.
\item
no
\tcode{erase()},
\tcode{pop_back()}
or
\tcode{pop_front()}
function throws an exception.
\item
no copy constructor or assignment operator of a returned iterator
throws an exception.
\item
no
\tcode{swap()}
function throws an exception unless that
exception is thrown by the copy constructor or
assignment operator of the container's
Compare object (if any; see \ref{lib.associative.reqmts}).
\item
no
\tcode{swap()}
function invalidates any references,
pointers, or iterators referring to the elements
of the containers being swapped.
\end{itemize}

\pnum
Unless otherwise specified (either explicitly or by defining a
function in terms of other functions), invoking a container member
function or passing a container as an argument to a library function
shall not invalidate iterators to, or change the values of, objects
within that container.

\rSec2[lib.sequence.reqmts]{\textcolor{black}{Sequences}}

\pnum
A sequence is a kind of container that organizes a finite set of objects, all of the same type,
into a strictly linear arrangement.
The library provides three basic kinds of sequence containers:
\tcode{vector},
\tcode{list},
and
\tcode{deque}.
It also provides container adaptors that make it easy to construct abstract data types, such as
\tcode{stack}s
or
\tcode{queue}s,
out of the basic sequence kinds (or out of other kinds of sequences that the user might define).

\pnum
\tcode{vector},
\tcode{list},
and
\tcode{deque}
offer the programmer different complexity trade-offs and should be used
accordingly.
\tcode{vector}\
is the type of sequence that should be used by default.
\tcode{list}\
should be used when there are frequent insertions and deletions from the middle of the sequence.
\tcode{deque}\
is the data structure of choice
when most insertions and deletions take place at the beginning or at the end of the sequence.

\pnum
\removedConcepts{In Tables~82
and 83, X
denotes a sequence class,
a denotes a value of X,
i and j
denote iterators satisfying input iterator requirements,
[i, j)
denotes a valid range, n
denotes a value of X::size\_type,
p denotes a valid iterator to
a, q
denotes a valid dereferenceable iterator to
a, [q1, q2)
denotes a valid range in
a, and t
denotes a value of X::value\_type.}

\pnum
The complexities of the expressions are sequence dependent.

\eremove{Remove Table 82: Sequence requirements (in addition to
  container)}

\color{addclr}
\pnum 
Sequences are described by the \tcode{Sequence},
\tcode{FrontInsertionSequence}, and \tcode{BackInsertionSequence} concepts.

\begin{itemdecl}
concept Sequence<typename X> : Container<X>
{
  where MutableForwardIterator<iterator> && ForwardIterator<const_iterator>;

  X::X(size_type n, value_type t);

  template<InputIterator Iter>
    where Convertible<Iter::value_type, value_type>
    X::X(Iter first, Iter last);

  iterator X::insert(iterator p, value_type t);
  void X::insert(iterator p, size_type n, value_type t);
  template<InputIterator Iter>
    where Convertible<Iter::value_type, value_type>
    void X::insert(iterator p, Iter first, Iter last);

  iterator X::erase(iterator q);
  iterator X::erase(iterator q1, iterator q2);

  void X::clear();

  template<InputIterator Iter>
    where Convertible<Iter::value_type, value_type>
    void X::assign(Iter first, Iter last);
  void X::assign(size_type n, value_type);
}
\end{itemdecl}

\begin{itemdecl}
X::X(size_type n, value_type t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
constructs a sequence with \tcode{n}\ copies of \tcode{t}\

\pnum
\postcondition\
\tcode{size() == n}
\end{itemdescr}

\begin{itemdecl}
template<InputIterator Iter>
  where Convertible<Iter::value_type, value_type>
  X::X(Iter first, Iter last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
constructs a sequence equal to the range \tcode{[i, j)}

\pnum
\postconditions\
\tcode{size() == distance}\ between \tcode{i}\ and \tcode{j}
\end{itemdescr}

\begin{itemdecl}
iterator X::insert(iterator p, value_type t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
inserts a copy of \tcode{t}\ before \tcode{p}

\pnum
\returns\
\addedConcepts{an iterator that} points to the copy of
\tcode{t}\
inserted into
\tcode{a}.
\end{itemdescr}

\begin{itemdecl}
void X::insert(iterator p, size_type n, value_type t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
inserts \tcode{n}\ copies of \tcode{t}\ before \tcode{p}
\end{itemdescr}

\begin{itemdecl}
template<InputIterator Iter>
  where Convertible<Iter::value_type, value_type>
  void X::insert(iterator p, Iter first, Iter last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\precondition\
\tcode{i}\ and \tcode{j}\ are not iterators into \tcode{a}

\pnum
\effects\
inserts copies of elements in \tcode{[i, j)} before \tcode{p}
\end{itemdescr}

\begin{itemdecl}
iterator X::erase(iterator q);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
erases the element pointed to by \tcode{q}

\pnum
\returns\
\changedConcepts{The iterator returned from
a.erase(q)}{An iterator that}\
points to the element immediately following
\tcode{q}\
prior to the element being erased.
If no such element exists,
\tcode{a.end()}\
is returned.
\end{itemdescr}

\begin{itemdecl}
iterator X::erase(iterator q1, iterator q2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
erases the elements in the range \tcode{[q1, q2)}.

\pnum
\returns\
\changedConcepts{The iterator returned by
a.erase(q1,q2)}{An iterator that}\
points to the element pointed to by
\tcode{q2}\
prior to any elements being erased.
If no such element exists,
\tcode{a.end()}\
is returned.
\end{itemdescr}

\begin{itemdecl}
void X::clear();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
\tcode{erase(begin(), end())}

\pnum
\postconditions\
\tcode{size() == 0}
\end{itemdescr}

\begin{itemdecl}
template<InputIterator Iter>
  where Convertible<Iter::value_type, value_type>
  void X::assign(Iter first, Iter last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\precondition\
\tcode{i}, \tcode{j}\ are not iterators into \tcode{a}

\pnum
\effects\
Replaces elements in \tcode{a}\ with a copy of \tcode{[i, j)}.
\end{itemdescr}

\begin{itemdecl}
void X::assign(size_type n, value_type);
\end{itemdecl}

\begin{itemdescr}
\pnum
\precondition\
\tcode{t}\ is not a reference into \tcode{a}.

\pnum
\effects\
Replaces elements in \tcode{a}\ with \tcode{n}\ copies of \tcode{t}.
\end{itemdescr}

\eremove{Remove paragraphs 5--11, including the ``do the right thing''
clause.}

\pnum
\changedConcepts{Table~83 lists sequence operations
that are provided for some types of
sequential containers but not others.
An implementation shall provide
these operations for all container types shown in the ``container''
column, and shall implement them so as to take amortized constant
time.}{The BackAccessSequence concept describes sequences for which
the last element can be accessed in amortized constant time.}

\eremove{Remove Table 83: Optional sequence operations}

\begin{itemdecl}
concept BackAccessSequence<typename X> : Sequence<X>
{
  reference       X::back();
  const_reference X::back() const;
}
\end{itemdecl}

\begin{itemdecl}
reference       X::back();
const_reference X::back() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
 \tcode{\{ iterator tmp = end();}\\
 \tcode{    --tmp;}\\
 \tcode{    return *tmp; \}}
\end{itemdescr}

\pnum The \tcode{BackInsertionSequence} concept describes sequences for which
one can insert, remove, or access an element at the end of a container in
amortized constant time.

\begin{itemdecl}
concept BackInsertionSequence<typename X> : BackAccessSequence<X>
{
  void X::push_back(value_type x);
  void X::pop_back();
}
\end{itemdecl}

\begin{itemdecl}
void X::push_back(value_type x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
\tcode{insert(end(),x)}
\end{itemdescr}

\begin{itemdecl}
void X::pop_back();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
 \tcode{\{ iterator tmp = end();}\\
 \tcode{    --tmp;}\\
 \tcode{    erase(tmp); \}}
\end{itemdescr}

\pnum
The \tcode{FrontAccessSequence}\ concept describes sequences for which
one can access the element at the front of the container in amortized
constant time. 

\begin{itemdecl}
concept FrontAccessSequence<typename X> : Sequence<X>
{
  reference       X::front();
  const_reference X::front() const;
}
\end{itemdecl}

\begin{itemdecl}
reference       X::front();
const_reference X::front() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{*begin()}
\end{itemdescr}

\pnum
The \tcode{FrontInsertionSequence}\ concept describes sequences for which
one can insert, remove, or access an element at the front of a container in
amortized constant time.

\begin{itemdecl}
concept FrontInsertionSequence<typename X> : FrontAccessSequence<X>
{
  void X::push_front(value_type x);
  void X::pop_front();
}
\end{itemdecl}

\begin{itemdecl}
void X::push_front(value_type x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
\tcode{insert(begin(),x)}
\end{itemdescr}

\begin{itemdecl}
void X::pop_front();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
\tcode{erase(begin())}
\end{itemdescr}

\pnum
The \tcode{RandomAccessSequence} concept describes sequences that
provide access to any element in the container in amortized constant
time.

\begin{itemdecl}
concept RandomAccessSequence<typename X> 
  : FrontAccessSequence<X>, BackAccessSequence<X>
{
  where MutableRandomAccessIterator<iterator> &&
        RandomAccessIterator<const_iterator>;

  reference       operator[](X& a, size_type n);
  const_reference operator[](const X& a, size_type n);

  reference       at(X& a, size_type n);
  const_reference at(const X& a, size_type n);
}
\end{itemdecl}

\begin{itemdecl}
reference       operator[](X& a, size_type n);
const_reference operator[](const X& a, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{*(a.begin() + n)}
\end{itemdescr}

\begin{itemdecl}
reference       at(X& a, size_type n);
const_reference at(const X& a, size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{*(a.begin() + n)}

\pnum
\throws
\tcode{out_of_range} if \tcode{n >= a.size()}.
\end{itemdescr}

\color{black}

\pnum
\addedConcepts{An implementation shall provide the following concept
  maps. When the implementation provides a vector<bool>
  specialization, vector<T> only meets the sequence concept when T is
  not bool.}
\color{addclr}
\begin{itemdecl}
@\textcolor{addclr}{template}@<CopyConstructible T, Allocator Alloc> 
  where !SameType<T, bool> // iff vector<bool> specialization is provided
  concept_map RandomAccessSequence<vector<T, Alloc> > { }
template<CopyConstructible T, Allocator Alloc> 
  where !SameType<T, bool> // iff vector<bool> specialization is provided
  concept_map BackInsertionSequence<vector<T, Alloc> > { }

template<CopyConstructible T, Allocator Alloc> 
  concept_map BackInsertionSequence<list<T, Alloc> > { }
template<CopyConstructible T, Allocator Alloc> 
  concept_map FrontInsertionSequence<list<T, Alloc> > { }

template<CopyConstructible T, Allocator Alloc> 
  concept_map RandomAccessSequence<deque<T, Alloc> > { }
template<CopyConstructible T, Allocator Alloc> 
  concept_map BackInsertionSequence<deque<T, Alloc> > { }
template<CopyConstructible T, Allocator Alloc> 
  concept_map FrontInsertionSequence<deque<T, Alloc> > { }
\end{itemdecl}
\color{black}

\rSec1[lib.sequences]{Sequences}

\pnum
Headers \tcode{<array>}, \tcode{<deque>}, \tcode{<forward_list>}, \tcode{<list>}, \tcode{<queue>}, \tcode{<stack>}, and \tcode{<vector>}.

\synopsis{Header \tcode{<array>}\ synopsis}%
\index{array@\tcode{<array>}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, size_t N > struct array;
  template <@\changedConcepts{class}{EqualityComparable}@ T, size_t N>
    bool operator==(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, size_t N>
    bool operator!=(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator<(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator>(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator<=(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, size_t N>
    bool operator>=(const array<T,N>& x, const array<T,N>& y);
  template <@\changedConcepts{class}{Swappable}@ T, size_t N >
    void swap(array<T,N>& x, array<T,N>& y);

  template <@\changedConcepts{class}{ObjectType}@ T> class tuple_size;
  template <int I, @\changedConcepts{class}{ObjectType}@ T> 
    class tuple_element;
  template <@\changedConcepts{class}{ObjectType}@ T, size_t N>
    struct tuple_size<array<T, N> >;
  template <int I, class T, size_t N>
    @\addedConcepts{requires True<(I > 0 \&\& I < N)>}@
    struct tuple_element<I, array<T, N> >;
  template <int I, class T, size_t N>
    @\addedConcepts{requires True<(I > 0 \&\& I < N)>}@
    T& get(array<T, N>&); 
  template <int I, class T, size_t N>
    @\addedConcepts{requires True<(I > 0 \&\& I < N)>}@
    const T& get(const array<T, N>&);
}
\end{codeblock}

\synopsis{Header \tcode{<deque>}\ synopsis}%
\index{deque@\tcode{<deque>}}

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator = allocator<T> > class deque;
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator<(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator>(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>&& x, deque<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>& x, deque<T,Allocator>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<forward_list>} synopsis}%
\index{forward_list@\tcode{<forward_list>}}

\begin{codeblock}
namespace std {
  template <class T, class Allocator = allocator<T> > class forward_list; 
  template <class T, class Allocator> 
    bool operator==(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <class T, class Allocator> 
    bool operator< (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <class T, class Allocator> 
    bool operator!=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <class T, class Allocator> 
    bool operator> (const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <class T, class Allocator> 
    bool operator>=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <class T, class Allocator> 
    bool operator<=(const forward_list<T,Allocator>& x, const forward_list<T,Allocator>& y); 
  template <class T, class Allocator> 
    void swap(forward_list<T,Allocator>& x, forward_list<T,Allocator>& y); 
}
\end{codeblock}

\synopsis{Header \tcode{<list>}\ synopsis}%
\index{list@\tcode{<list>}}

\begin{codeblock}
namespace std {
  template <class T, class Allocator = allocator<T> > class list;
  template <class T, class Allocator>
    bool operator==(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator< (const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator!=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator> (const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator>=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    bool operator<=(const list<T,Allocator>& x, const list<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(list<T,Allocator>& x, list<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(list<T,Allocator>&& x, list<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(list<T,Allocator>& x, list<T,Allocator>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<queue>}\ synopsis}%
\index{queue@\tcode{<queue>}}

\begin{codeblock}
namespace std {
  template <class T, class Container = deque<T> > class queue;
  template <class T, class Container>
    bool operator==(const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Container>
    bool operator< (const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Container>
    bool operator> (const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const queue<T, Container>& x,const queue<T, Container>& y);
  template <class T, class Allocator>
    void swap(queue<T,Allocator>& x, queue<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(queue<T,Allocator>&& x, queue<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(queue<T,Allocator>& x, queue<T,Allocator>&& y);

  template <class T, class Container = vector<T>,
        class Compare = less<typename Container::value_type> >
  class priority_queue;
  template <class T, class Allocator>
    void swap(priority_queue<T,Allocator>& x, priority_queue<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(priority_queue<T,Allocator>&& x, priority_queue<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(priority_queue<T,Allocator>& x, priority_queue<T,Allocator>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<stack>}\ synopsis}%
\index{stack@\tcode{<stack>}}

\begin{codeblock}
namespace std {
  template <class T, class Container = deque<T> > class stack;
  template <class T, class Container>
    bool operator==(const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Container>
    bool operator< (const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Container>
    bool operator> (const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const stack<T, Container>& x,const stack<T, Container>& y);
  template <class T, class Allocator>
    void swap(stack<T,Allocator>& x, stack<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(stack<T,Allocator>&& x, stack<T,Allocator>& y);
  template <class T, class Allocator>
    void swap(stack<T,Allocator>& x, stack<T,Allocator>&& y);
}
\end{codeblock}

\synopsis{Header \tcode{<vector>}\ synopsis}%
\index{vector@\tcode{<vector>}}

\begin{codeblock}
namespace std {
  template <class T, @\addedConcepts{Allocator Alloc}@ = allocator<T> > 
    @\addedConcepts{where SameType<T, Alloc::value_type>}@ class vector;
  template <class T, class Alloc>
    @\addedConcepts{where EqualityComparable<T>}@
    bool operator==(const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);
  template <class T, class Alloc>
    @\addedConcepts{where LessThanComparable<T>}@
    bool operator< (const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);
  template <class T, class Alloc>
    @\addedConcepts{where EqualityComparable<T>}@
    bool operator!=(const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);
  template <class T, class Alloc>
    @\addedConcepts{where LessThanComparable<T>}@
    bool operator> (const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);
  template <class T, class Alloc>
    @\addedConcepts{where LessThanComparable<T>}@
    bool operator>=(const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);
  template <class T, class Alloc>
    @\addedConcepts{where LessThanComparable<T>}@
    bool operator<=(const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);

  // specialized algorithms:
  template <class T, @\changedConcepts{class}{Allocator}@ Alloc>
    void swap(vector<T,Alloc>& x, vector<T,Alloc>& y);
}
\end{codeblock}

\rSec2[array]{\marktr{}Class template \tcode{array}}
\index{array@\tcode{array}}%

\pnum
\index{array@\tcode{array}!contiguous storage}%
The header \tcode{<array>} defines a class template for storing fixed-size
sequences of objects. An \tcode{array} supports random access iterators. An
instance of \tcode{array<T, N>} stores \tcode{N} elements of type \tcode{T}, so that 
\tcode{size() == N} is an invariant. The elements of an \tcode{array} are stored contiguously,
meaning that if \tcode{a} is an \tcode{array<T, N>} then it obeys the identity 
\verb|&a[n] == &a[0] + n| for all \tcode{0 <= n < N}.

\pnum
\index{array@\tcode{array}!initialization}%
\index{array@\tcode{array}!as aggregate}%
An \tcode{array} is an aggregate~(\ref{dcl.init.aggr}) that can be
initialized with the syntax
\begin{codeblock}
array a = { initializer-list };
\end{codeblock}

where \textit{initializer-list} is a comma separated list of up
to \tcode{N} elements whose types are convertible to \tcode{T}.

\pnum
\index{requirements!Container}%
Unless otherwise specified, all \tcode{array} operations are as described
in~\ref{container.requirements}. Descriptions are provided here
only for operations on \tcode{array} that are not described in that clause
or for operations where there is additional semantic information.

\index{array@\tcode{array}}%
\index{array@\tcode{array}!begin@\tcode{begin}}%
\index{begin@\tcode{begin}!array@\tcode{array}}%
\index{array@\tcode{array}!end@\tcode{end}}%
\index{end@\tcode{end}!array@\tcode{array}}%
\index{array@\tcode{array}!size@\tcode{size}}%
\index{size@\tcode{size}!array@\tcode{array}}%
\index{array@\tcode{array}!max_size@\tcode{max_size}}%
\index{max_size@\tcode{max_size}!array@\tcode{array}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, size_t N >
  struct array {
    //  types:
    typedef T &                                   reference;
    typedef const T &                             const_reference;
    typedef @{\itshape implementation defined}@                iterator;
    typedef @{\itshape implementation defined}@                const_iterator;
    typedef size_t                                size_type;
    typedef ptrdiff_t                             difference_type;
    typedef T                                     value_type;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    T       elems[N];           // \expos

    // No explicit construct/copy/destroy for aggregate type

    @\addedConcepts{requires CopyAssignable<T>}@ void assign(const T& u);
    @\addedConcepts{requires Swappable<T>}@ void swap(array<T, N> &);

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;

    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // capacity:
    constexpr size_type size() const;
    constexpr size_type max_size() const;
    bool      empty() const;

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    T *       data();
    const T * data() const;
  };
}
\end{codeblock}

\pnum
\enternote\ The member variable \tcode{elems} is shown for exposition only,
to empahasize that \tcode{array} is a class aggregate.  The name \tcode{elems}
is not part of \tcode{array}'s interface. \exitnote\

\rSec3[array.cons]{\tcode{array} constructors, copy, and assignment}

\pnum
\index{array@\tcode{array}!initialization}%
\index{requirements!Container}%
The conditions for an aggregate~(\ref{dcl.init.aggr}) shall be
met. Class \tcode{array} relies on the implicitly-declared special
member functions~(\ref{class.ctor}, \ref{class.dtor}, and \ref{class.copy}) to
conform to the container requirements table in~\ref{container.requirements}.

\rSec3[array.special]{\tcode{array} specialized algorithms}

\index{array@\tcode{array}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!array@\tcode{array}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Swappable}@ T, size_t N> void swap(array<T,N>& x, array<T,N>& y);
\end{itemdecl}
\begin{itemdescr}
\pnum\effects\ 
\begin{codeblock}
swap_ranges(x.begin(), x.end(), y.begin() );
\end{codeblock}
\end{itemdescr}

\rSec3[array.size]{\tcode{array::size}}

\index{array@\tcode{array}!size@\tcode{size}}%
\index{size@\tcode{size}!array@\tcode{array}}%
\begin{itemdecl}
@\removedConcepts{template <class T, size_t N>}@ size_type @\removedConcepts{array<T,N>::}@size();
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{N}
\end{itemdescr}

\rSec3[array.data]{\tcode{array::data}}
\index{array@\tcode{array}!data@\tcode{data}}%
\index{data@\tcode{data}!array@\tcode{array}}%
\begin{itemdecl}
T *data();
const T *data() const;
\end{itemdecl}

\begin{itemdescr}
\pnum \returns\ \tcode{elems}.
\end{itemdescr}

\rSec3[array.zero]{Zero sized arrays}
\index{array@\tcode{array}!zero sized}%

\pnum\tcode{array} shall provide support for the special case \tcode{N == 0}.

\pnum In the case that \tcode{N == 0}, \tcode{begin() == end() ==} unique value.
The return value of \tcode{data()} is unspecified.

\pnum
The effect of calling \tcode{front()} or \tcode{back()} for a zero-sized array
is implementation defined.

\rSec3[array.tuple]{Tuple interface to class template \tcode{array}}
\index{array@\tcode{array}}%
\index{tuple@\tcode{tuple}}%
\index{tuple@\tcode{tuple}!and array@and \tcode{array}}%
\index{array@\tcode{array}!tuple interface to}%

\index{tuple_size@\tcode{tuple_size}}%
\begin{itemdecl}
tuple_size<array<T, N> >::value
\end{itemdecl}

\begin{itemdescr}
\pnum
\returntype\   integral constant expression.

\pnum
\cvalue\  \tcode{N}
\end{itemdescr}

\index{tuple_element@\tcode{tuple_element}}%
\begin{itemdecl}
tuple_element<I, array<T, N> >::type
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\  \tcode{0 <= I < N}.   The program is ill-formed if \tcode{I} is out of bounds.

\pnum
\cvalue\  The type T.
\end{itemdescr}

\index{array@\tcode{array}!get@\tcode{get}}%
\index{get@\tcode{get}!array@\tcode{array}}%
\begin{itemdecl}
template <int I, class T, size_t N> 
  @\addedConcepts{requires True<(I > 0 \&\& I < N)>}@
  T& get(array<T, N>& a); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{0 <= I < N}}. The program is ill-formed if \mbox{\tcode{I}} is out of bounds.}

\returns\  A reference to the \tcode{I}th element of \tcode{a}, 
where indexing is zero-based.
\end{itemdescr}

\index{array@\tcode{array}!get@\tcode{get}}%
\index{get@\tcode{get}!array@\tcode{array}}%
\begin{itemdecl}
template <int I, class T, size_t N> 
  @\addedConcepts{requires True<(I > 0 \&\& I < N)>}@
  const T& get(const array<T, N>& a); 
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{0 <= I < N}}. The program is ill-formed if \mbox{\tcode{I}} is out of bounds.}

\pnum
\returns\ A const reference to the \tcode{I}th element of \tcode{a}, 
where indexing is zero-based.
\end{itemdescr}

\rSec2[deque]{Class template \tcode{deque}}%

\pnum
\index{deque@\tcode{deque}}
A
\tcode{deque}\
is a sequence container that, like a
\tcode{vector}\
(\ref{vector}), supports random access iterators.
In addition, it supports constant time insert and erase operations at the beginning or the end;
insert and erase in the middle take linear time.
That is, a deque is especially optimized for pushing and popping elements at the beginning and end.
As with vectors, storage management is handled automatically.

\pnum
A
\tcode{deque}\
satisfies all of the requirements of a container, of a reversible container
(given in tables in~\ref{container.requirements}), of a sequence container,
including the optional sequence container requirements
(\ref{sequence.reqmts}), and of an allocator-aware container (Table~\ref{tab:containers.allocatoraware}).
Descriptions are provided here only for operations on
\tcode{deque}\
that are not described in one of these tables
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator = allocator<T> >
  class deque {
  public:
    // types:
    typedef typename Allocator::reference         reference;
    typedef typename Allocator::const_reference   const_reference;
    typedef @\impdef@                iterator;       // See \ref{container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{container.requirements}
    typedef @\impdef@                size_type;      // See \ref{container.requirements}
    typedef @\impdef@                difference_type;// See \ref{container.requirements}
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename Allocator::pointer           pointer;
    typedef typename Allocator::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{deque.cons} construct/copy/destroy:
    explicit deque(const Allocator& = Allocator());
    @\addedConcepts{requires DefaultConstructible<T>}@ explicit deque(size_type n);
    @\addedConcepts{requires CopyConstructible<T>}@ deque(size_type n, const T& value,const Allocator& = Allocator());
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<T, Iter::reference>}@ 
      deque(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last,const Allocator& = Allocator());
    @\addedConcepts{requires CopyConstructible<T>}@ deque(const deque<T,Allocator>& x);
    deque(deque&&);
    @\addedConcepts{requires CopyConstructible<T>}@ deque(const deque&, const Allocator&);
    deque(deque&&, const Allocator&);

   ~deque();
    @\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@ 
      deque<T,Allocator>& operator=(const deque<T,Allocator>& x);
    deque<T,Allocator>& operator=(const deque<T,Allocator>&& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasConstructor<T, Iter::reference> \&\& CopyAssignable<T, Iter::reference>}@
      void assign(InputIterator first, InputIterator last);
    @\addedConcepts{requires CopyAssignable<T> \&\& CopyConstructible<T>}@ void assign(size_type n, const T& t);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    const_iterator         cbegin() const;
    const_iterator         cend() const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend() const;

    // \ref{deque.capacity} capacity:
    size_type size() const;
    size_type max_size() const;
    @\addedConcepts{requires DefaultConstructible<T> \&\& MoveAssignable<T>}@ 
      void resize(size_type sz);
    @\addedConcepts{requires CopyConstructible<T> \&\& MoveAssignable<T>}@    
      void resize(size_type sz, const T& c);
    bool empty() const;

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    reference       at(size_type n);
    const_reference at(size_type n) const;
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // \ref{deque.modifiers} modifiers:
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
      void push_front(Args&&... args);
    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
      void push_back(Args&&... args);

    template <class... Args> 
      @\addedConcepts{requires HasConstructor<T, Args\&\&...> \&\& MoveAssignable<T>}@ 
      iterator emplace(const_iterator position, Args&&... args);

    @\addedConcepts{requires CopyConstructible<T> \&\& MoveAssignable<T>}@
      iterator insert(const_iterator position, const T& x);
    @\addedConcepts{requires MoveConstructible<T> \&\& MoveAssignable<T>}@
      iterator insert(const_iterator position, T&& x);
    @\addedConcepts{requires CopyConstructible<T> \&\& MoveAssignable<T>}@
      void insert(const_iterator position, size_type n, const T& x);
    template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
      @\addedConcepts{requires HasCopyAssign<T, Iter::reference> \&\& HasConstructor<T, Iter::reference>}@
               @\addedConcepts{\&\& MoveAssignable<T>}@
      void insert(const_iterator position, InputIterator first, InputIterator last);

    void pop_front();
    void pop_back();

    @\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator position);
    @\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator first, const_iterator last);
    void     swap(deque<T,Allocator>&&);
    void     clear();
  };

  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator< (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{EqualityComparable}@ T, class Allocator>
    bool operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator> (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
  template <@\changedConcepts{class}{LessThanComparable}@ T, class Allocator>
    bool operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

  // specialized algorithms:
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>&& x, deque<T,Allocator>& y);
  template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
    void swap(deque<T,Allocator>& x, deque<T,Allocator>&& y);

  template <class T, class Alloc
    struct constructible_with_allocator_suffix<deque<T, Alloc> >
      : true_type { };
}
\end{codeblock}

\rSec3[deque.cons]{\tcode{deque}\ constructors, copy, and assignment}

\begin{itemdecl}
explicit deque(const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an empty
\tcode{deque},
using the specified allocator.

\pnum
\complexity\ 
Constant.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T>}@ explicit deque(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{deque} with
\tcode{n} default constructed elements.

\pnum
@\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{DefaultConstructible}}.}@

\pnum
\complexity Linear in \farg{n}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T>}@
deque(size_type @\farg{n}@, const T& @\farg{value}@,
      const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs a
\tcode{deque}\
with \farg{n} copies of \farg{value},
using the specified allocator.

\pnum
@\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be \mbox{\tcode{CopyConstructible}}.}@

\pnum
\complexity\ 
Linear in \farg{n}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<T, Iter::reference>}@
  deque(@\changedConcepts{InputIterator}{Iter}@ @\farg{first}@, @\changedConcepts{InputIterator}{Iter}@ @\farg{last}@,
        const Allocator& = Allocator());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs a
\tcode{deque}\
equal to the the range
\range{\farg{first}}{\farg{last}},
using the specified allocator.

\pnum
\complexity\ 
\tcode{distance(\farg{first}, \farg{last})}.
\end{itemdescr}

\index{assign@\tcode{assign}!\tcode{deque}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasConstructor<T, Iter::reference> \&\& CopyAssignable<T, Iter::reference>}@
  void assign(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
erase(begin(), end());
insert(begin(), first, last);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T> \&\& CopyAssignable<T>}@
void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
erase(begin(), end());
insert(begin(), n, t);
\end{codeblock}
\end{itemdescr}

\rSec3[deque.capacity]{\tcode{deque}\ capacity}

\index{resize@\tcode{resize}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T> \&\& MoveAssignable<T>}@ 
  void resize(size_type sz);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects If \tcode{sz < size()}, equivalent to
\tcode{erase(begin() + sz, end());}. If \tcode{size() < sz},
appends \tcode{sz - size()} default constructed elements to the
sequence.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be
\mbox{\tcode{DefaultConstructible}}.}
\end{itemdescr}

\index{resize@\tcode{resize}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T> \&\& MoveAssignable<T>}@ 
  void resize(size_type sz, const T& c);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
if (sz > size())
  insert(end(), sz-size(), c);
else if (sz < size())
  erase(begin()+sz, end());
else
  ;                 // do nothing
\end{codeblock}

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} shall be
\mbox{\tcode{CopyConstructible}}.}
\end{itemdescr}

\rSec3[deque.modifiers]{\tcode{deque}\ modifiers}

\index{insert@\tcode{insert}!\tcode{deque}}%
\index{insert@\tcode{push_front}!\tcode{deque}}%
\index{insert@\tcode{push_back}!\tcode{deque}}%
\index{insert@\tcode{emplace}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T> \&\& MoveAssignable<T>}@
  iterator insert(const_iterator position, const T& x);
@\addedConcepts{requires MoveConstructible<T> \&\& MoveAssignable<T>}@
  iterator insert(const_iterator position, T&& x);
@\addedConcepts{requires CopyConstructible<T> \&\& MoveAssignable<T>}@
  void     insert(const_iterator position, size_type n, const T& x);
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\addedConcepts{requires HasCopyAssign<T, Iter::reference> \&\& HasConstructor<T, Iter::reference>}@
           @\addedConcepts{\&\& MoveAssignable<T>}@
  void insert(const_iterator position,
              @\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);

template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
  void push_front(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...>}@ 
  void push_back(Args&&... args);
template <class... Args> 
  @\addedConcepts{requires HasConstructor<T, Args\&\&...> \&\& MoveAssignable<T>}@ 
  iterator emplace(const_iterator position, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
An insertion in the middle of the deque invalidates all the iterators and
references to elements of the deque.
An insertion at either end of the
deque invalidates all the iterators to the deque, but has no effect on
the validity of references to elements of the deque.

\pnum
\notes\ 
If an exception is thrown other than by the
copy constructor or assignment operator of
\tcode{T}\
there are no effects.

\pnum
\complexity\ 
The complexity is linear in the number of elements inserted plus the lesser
of the distances to the beginning and end of the deque.
Inserting a single element either at the beginning or end of a deque always takes constant time
and causes a single call to a constructor of
\tcode{T}.
\end{itemdescr}

\index{erase@\tcode{erase}!\tcode{deque}}%
\begin{itemdecl}
@\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator position);
@\addedConcepts{requires MoveAssignable<T>}@ iterator erase(const_iterator first, const_iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
An erase in the middle of the deque invalidates all the iterators and
references to elements of the deque.
An erase at either end of the
deque invalidates only the iterators and the references to the erased elements.

\pnum
\complexity\ 
The number of calls to the destructor is the same as the
number of elements erased, but the number of the calls to the assignment operator is at most equal to the minimum
of the number of elements before the erased elements and the number of elements after the erased elements.

\pnum
\throws\ 
Nothing unless an exception is thrown by the copy constructor or assignment operator of
\tcode{T}.
\end{itemdescr}

\rSec3[deque.special]{\tcode{deque}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(deque<T,Allocator>&& x, deque<T,Allocator>& y);
template <@\changedConcepts{class}{ObjectType}@ T, class Allocator>
  void swap(deque<T,Allocator>& x, deque<T,Allocator>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
x.swap(y);
\end{codeblock}
\end{itemdescr}

\setcounter{subsection}{3}
\rSec2[lib.container.adaptors]{Container adaptors}

\pnum
The container adaptors each take a Container template parameter,
and each constructor takes a Container reference argument.
This
container is copied into the Container member of each adaptor.

\rSec3[lib.queue]{Class template \tcode{queue}}

\pnum
\index{queue@\tcode{queue}}%
Any \changedConcepts{sequence supporting operations
front(),
back(),
push_back()
and
pop_front()}{container that meets the requirements of the
Back Insertion Sequence and Front Insertion Sequence concepts}
can be used to instantiate
\tcode{queue}.
In particular,
\tcode{list}\
(\ref{lib.list})
and
\tcode{deque}\
(\ref{lib.deque})
can be used.

\rSec4[lib.queue.defn]{\tcode{queue} definition}

\begin{codeblock}
namespace std {
  template <class T, @\addedConcepts{FrontInsertionSequence Container}@ = deque<T> >
  @\addedConcepts{where BackInsertionSequence<Cont>}@
  class queue {
  public:
    typedef Container::value_type            value_type;
    typedef Container::reference             reference;
    typedef Container::const_reference       const_reference;
    typedef Container::size_type             size_type;
    typedef Container                        container_type;
  protected:
    Container c;

  public:
    explicit queue(const Container& = Container());

    bool              empty() const     { return c.empty(); }
    size_type         size()  const     { return c.size(); }
    reference         front()           { return c.front(); }
    const_reference   front() const     { return c.front(); }
    reference         back()            { return c.back(); }
    const_reference   back() const      { return c.back(); }
    void push(const value_type& x)      { c.push_back(x); }
    void pop()                          { c.pop_front(); }
  };

  template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container>}@
    bool operator==(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator< (const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container>}@
    bool operator!=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator> (const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator>=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator<=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
}
\end{codeblock}

\rSec4[lib.queue.ops]{\tcode{queue} operators}

\index{operator==@\tcode{operator==}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container>}@
    bool operator==(const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c == y.c}.
\end{itemdescr}

\index{operator"!=@\tcode{operator"!=}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container>}@
    bool operator!=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c != y.c}.
\end{itemdescr}

\index{operator<@\tcode{operator<}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator< (const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c < y.c}.
\end{itemdescr}

\index{operator<=@\tcode{operator<=}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator<=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c <= y.c}.
\end{itemdescr}

\index{operator>@\tcode{operator>}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator> (const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c > y.c}.
\end{itemdescr}

\index{operator>=@\tcode{operator>=}!queue@\tcode{queue}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container>}@
    bool operator>=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c >= y.c}.
\end{itemdescr}

\rSec3[lib.priority.queue]{Class template \tcode{priority_queue}}

\pnum
\index{priority_queue@\tcode{priority_queue}}%
Any sequence with random access iterator and supporting operations
\tcode{front()},
\tcode{push_back()}\
and
\tcode{pop_back()}\
can be used to instantiate
\tcode{priority_queue}.
In particular,
\tcode{vector}\
(\ref{lib.vector})
and
\tcode{deque}\
(\ref{lib.deque})
can be used.
Instantiating
\tcode{priority_queue}\
also involves supplying a function or function object for making priority comparisons;
the library assumes that the function or function object defines a strict
weak ordering (\ref{lib.alg.sorting}).

\begin{codeblock}
namespace std {
  template <class T, @\addedConcepts{RandomAccessSequence Container}@ = vector<T>,
            @\addedConcepts{BinaryPredicate<Container::value_type, Container::value_type>}@ Compare 
              = less<Container::value_type> >
  @\addedConcepts{where CopyConstructible<Compare>}@
  class priority_queue {
  public:
    typedef Container::value_type            value_type;
    typedef Container::reference             reference;
    typedef Container::const_reference       const_reference;
    typedef Container::size_type             size_type;
    typedef Container                        container_type;
  protected:
    Container c;
    Compare comp;

  public:
    explicit priority_queue(const Compare& x = Compare(),
                const Container& = Container());
    template <@\addedConcepts{InputIterator Iter}@>
      @\addedConcepts{where Convertible<Iter::value_type, value_type>}@
      priority_queue(Iter first, Iter last,
             const Compare& x = Compare(),
             const Container& = Container());

    bool      empty() const       { return c.empty(); }
    size_type size()  const       { return c.size(); }
    const_reference   top() const { return c.front(); }
    void push(const value_type& x);
    void pop();
  };
                // no equality is provided
}
\end{codeblock}

\rSec4[lib.priqueue.cons]{\tcode{priority_queue}\ constructors}

\index{priority_queue@\tcode{priority_queue}!\tcode{priority_queue}}%
\begin{itemdecl}
priority_queue(const Compare& x = Compare(),
               const Container& y = Container());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\ 
\farg{x}\ defines a strict weak ordering (\ref{lib.alg.sorting}).

\pnum
\effects\ 
Initializes
\tcode{comp}\ with
\tcode{x}\ and
\tcode{c}\ with
\tcode{y};
calls
\tcode{make_heap(c.begin(), c.end(), comp)}.
\end{itemdescr}

\begin{itemdecl}
template <@\addedConcepts{InputIterator Iter}@>
  @\addedConcepts{where Convertible<Iter::value_type, value_type>}@
  priority_queue(Iter first, Iter last,
                 const Compare& x = Compare(),
                 const Container& y = Container());
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires\ 
\farg{x}\ defines a strict weak ordering (\ref{lib.alg.sorting}).

\pnum
\effects\ 
Initializes
\tcode{c}\ with
\tcode{y}\ and
\tcode{comp}\ with
\tcode{x};
calls
\tcode{c.insert(c.end(), first, last)};
and finally calls
\tcode{make_heap(c.begin(), c.end(), comp)}.
\end{itemdescr}

\rSec4[lib.priqueue.members]{\tcode{priority_queue}\ members}

\index{push@\tcode{push}!\tcode{priority_queue}}%
\begin{itemdecl}
void push(const value_type& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
c.push_back(x);
push_heap(c.begin(), c.end(), comp);
\end{codeblock}
\end{itemdescr}

\index{pop@\tcode{pop}!\tcode{priority_queue}}%
\begin{itemdecl}
void pop();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
pop_heap(c.begin(), c.end(), comp);
c.pop_back();
\end{codeblock}
\end{itemdescr}

\rSec3[lib.stack]{Class template \tcode{stack}}

\pnum
\index{stack@\tcode{stack}}%
Any sequence supporting operations
\tcode{back()},
\tcode{push_back()}\
and
\tcode{pop_back()}\
can be used to instantiate
\tcode{stack}.
In particular,
\tcode{vector}\
(\ref{lib.vector}),
\tcode{list}\
(\ref{lib.list})
and
\tcode{deque}\
(\ref{lib.deque})
can be used.

\rSec4[lib.stack.defn]{\tcode{stack} definition}

\begin{codeblock}
namespace std {
  template <class T, @\addedConcepts{BackInsertionSequence Container}@ = deque<T> >
  class stack {
  public:
    typedef Container::value_type            value_type;
    typedef Container::reference             reference;
    typedef Container::const_reference       const_reference;
    typedef Container::size_type             size_type;
    typedef Container                        container_type;
  protected:
    Container c;

  public:
    explicit stack(const Container& = Container());

    bool      empty() const             { return c.empty(); }
    size_type size()  const             { return c.size(); }
    reference         top()             { return c.back(); }
    const_reference   top() const       { return c.back(); }
    void push(const value_type& x)      { c.push_back(x); }
    void pop()                          { c.pop_back(); }
  };

  template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container::value_type>}@
    bool operator==(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator< (const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container::value_type>}@
    bool operator!=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator> (const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator>=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
  template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator<=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
}
\end{codeblock}

\rSec4[lib.stack.ops]{\tcode{stack} operators}

\index{operator==@\tcode{operator==}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container::value_type>}@
    bool operator==(const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c == y.c}.
\end{itemdescr}

\index{operator"!=@\tcode{operator"!=}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where EqualityComparable<Container::value_type>}@
    bool operator!=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c != y.c}.
\end{itemdescr}

\index{operator<@\tcode{operator<}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator< (const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c < y.c}.
\end{itemdescr}

\index{operator<=@\tcode{operator<=}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator<=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c <= y.c}.
\end{itemdescr}

\index{operator>@\tcode{operator>}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator> (const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c > y.c}.
\end{itemdescr}

\index{operator>=@\tcode{operator>=}!stack@\tcode{stack}}%
\begin{itemdecl}
template <class T, class Container>
    @\addedConcepts{where LessThanComparable<Container::value_type>}@
    bool operator>=(const stack<T, Container>& x,
                    const stack<T, Container>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.c >= y.c}.
\end{itemdescr}

\rSec2[lib.vector]{Class template \tcode{vector}}

\pnum
\index{vector@\tcode{vector}}%
A
\tcode{vector}\
is a kind of sequence that supports random access iterators.
In addition, it supports (amortized) constant time insert and erase operations at the end;
insert and erase in the middle take linear time.
Storage management is handled automatically, though hints can be given
to improve efficiency.
The elements of a vector are stored contiguously, meaning that if
\tcode{v}\
is a
\tcode{vector<T, Alloc>}\
where
\tcode{T}\
is some type other than
\tcode{bool},
then it obeys the identity
\tcode{\&v[n] == \&v[0] + n}\
for all
\tcode{0 <= n < v.size()}.

\pnum
A
\tcode{vector}\
satisfies all of the requirements of a container and of a reversible container
\removedConcepts{(given in two tables in~23.1)} and of a sequence,
including most of the optional sequence requirements (\ref{lib.sequence.reqmts}).
The exceptions are the
\tcode{push_front}\
and
\tcode{pop_front}\
member functions, which are not provided.
\removedConcepts{In addition to the requirements on the stored object
  described in 23.1, the stored object shall meet the requirements
of Assignable.}
Descriptions are provided here only for operations on
\tcode{vector}\
that are not described in one of these \changedConcepts{tables}{concepts}
or for operations where there is additional semantic information.

\begin{codeblock}
namespace std {
  template <class T, @\changedConcepts{class}{Allocator}@ Alloc = allocator<T> >
  @\addedConcepts{where SameType<T, Alloc::value_type>}@
  class vector {
  public:
    // types:
    typedef typename Alloc::reference             reference;
    typedef typename Alloc::const_reference       const_reference;
    typedef @\impdef@                iterator;       // See \ref{lib.container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{lib.container.requirements}
    typedef @\impdef@                size_type;      // See \ref{lib.container.requirements}
    typedef @\impdef@                difference_type;// See \ref{lib.container.requirements}
    typedef T                                     value_type;
    typedef Alloc                                 allocator_type;
    typedef typename Alloc::pointer               pointer;
    typedef typename Alloc::const_pointer         const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // \ref{lib.vector.cons} construct/copy/destroy:
    explicit vector(const Alloc& = Alloc());
    @\addedConcepts{where CopyConstructible<T>}@
      explicit vector(size_type n, const T& value = T(), const Alloc& = Alloc());

    template <@\addedConcepts{InputIterator Iter}@>
      @\addedConcepts{where Convertible<Iter::value_type, T>}@
      vector(Iter first, Iter last, const Alloc& = Alloc());
    template <@\addedConcepts{ForwardIterator Iter}@>
      @\addedConcepts{where Convertible<Iter::value_type, T>}@
      vector(Iter first, Iter last, const Alloc& = Alloc());
    @\addedConcepts{where CopyConstructible<T>}@ vector(const vector<T,Alloc>& x);
   ~vector();
    @\addedConcepts{where CopyConstructible<T> \&\& Assignable<T>}@ 
      vector<T,Alloc>& operator=(const vector<T,Alloc>& x);
    template <@\addedConcepts{InputIterator Iter}@>
      @\addedConcepts{Convertible<Iter::value_type, T> \&\& CopyConstructible<T> \&\& Assignable<T>}@
      void assign(Iter first, Iter last);
    @\addedConcepts{where CopyConstructible<T> \&\& Assignable<T>}@ void assign(size_type n, const T& u);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // \ref{lib.vector.capacity} capacity:
    size_type size() const;
    size_type max_size() const;
    @\addedConcepts{where CopyConstructible<T> \&\& Assignable<T>}@ void resize(size_type sz, T c = T());
    size_type capacity() const;
    bool      empty() const;
    @\addedConcepts{where CopyConstructible<T>}@ void reserve(size_type n);

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    @\addedA{// \mbox{\ref{lib.vector.data}} data access}@
    @\addedA{pointer         data();}@
    @\addedA{const_pointer   data() const;}@

    // \ref{lib.vector.modifiers} modifiers:
    void push_back(const T& x);
    void pop_back();
    @\addedConcepts{where CopyConstructible<T> \&\& Assignable<T>}@ 
      iterator insert(iterator position, const T& x);
    @\addedConcepts{where CopyConstructible<T> \&\& Assignable<T>}@ 
      void insert(iterator position, size_type n, const T& x);
    template <@\addedConcepts{InputIterator Iter}@>
      @\addedConcepts{Convertible<Iter::value_type, T> \&\& CopyConstructible<T> \&\& Assignable<T>}@
      void insert(iterator position, Iter first, Iter last);
    template <@\addedConcepts{ForwardIterator Iter}@>
      @\addedConcepts{Convertible<Iter::value_type, T> \&\& CopyConstructible<T> \&\& Assignable<T>}@
      void insert(iterator position, Iter first, Iter last);
    @\addedConcepts{where Assignable<T>}@ iterator erase(iterator position);
    @\addedConcepts{where Assignable<T>}@ iterator erase(iterator first, iterator last);
    void     swap(vector<T,Alloc>&);
    void     clear();
  };

  template <class T, class Alloc>
    @\addedConcepts{where EqualityComparable<T>}@
    bool operator==(const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);
  template <class T, class Alloc>
    @\addedConcepts{where LessThanComparable<T>}@
    bool operator< (const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);
  template <class T, class Alloc>
    @\addedConcepts{where EqualityComparable<T>}@
    bool operator!=(const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);
  template <class T, class Alloc>
    @\addedConcepts{where LessThanComparable<T>}@
    bool operator> (const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);
  template <class T, class Alloc>
    @\addedConcepts{where LessThanComparable<T>}@
    bool operator>=(const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);
  template <class T, class Alloc>
    @\addedConcepts{where LessThanComparable<T>}@
    bool operator<=(const vector<T,Alloc>& x,
                    const vector<T,Alloc>& y);

  // specialized algorithms:
  template <class T, @\changedConcepts{class}{Allocator}@ Alloc>
    void swap(vector<T,Alloc>& x, vector<T,Alloc>& y);
}
\end{codeblock}%
\index{vector@\tcode{vector}!\tcode{operator==}}%
\index{vector@\tcode{vector}!\tcode{operator<}}

\rSec3[lib.vector.cons]{\tcode{vector}\ constructors, copy, and assignment}

\index{vector@\tcode{vector}!\tcode{vector}}
\begin{itemdecl}
vector(const Allocator& = Allocator());
@\addedConcepts{where CopyConstructible<T>}@
  explicit vector(size_type n, const T& value = T(), const Allocator& = Allocator());
template <@\addedConcepts{InputIterator Iter}@>
  @\addedConcepts{where Convertible<Iter::value_type, T>}@
  vector(Iter first, Iter last, const Allocator& = Allocator());
template <@\addedConcepts{ForwardIterator Iter}@>
  @\addedConcepts{where Convertible<Iter::value_type, T>}@
  vector(Iter first, Iter last, const Allocator& = Allocator());
@\addedConcepts{where CopyConstructible<T>}@ vector(const vector<T,Allocator>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\complexity\ 
The constructor
\addedConcepts{that accepts a forward iterator range}
makes only $N$
calls to the copy constructor of
\tcode{T}\
(where $N$
is the distance between
\tcode{first}\
and
\tcode{last})
and no reallocations if iterators
\removedConcepts{
first and last are of forward, bidirectional, or random access
categories}.
\changedConcepts{It}{The constructor that accepts an input iterator range}
 makes order
\tcode{N}\
calls to the copy constructor of
\tcode{T}\
and order
$\log(N)$
reallocations\removedConcepts{ if they are just input iterators}.
\end{itemdescr}

\index{assign@\tcode{assign}!\tcode{vector}}%
\begin{itemdecl}
template <@\addedConcepts{InputIterator Iter}@>
  @\addedConcepts{Convertible<Iter::value_type, T> \&\& CopyConstructible<T> \&\& Assignable<T>}@
  void assign(Iter first, Iter last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
  erase(begin(), end());
  insert(begin(), first, last);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{where CopyConstructible<T> \&\& Assignable<T>}@ void assign(size_type n, const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
  erase(begin(), end());
  insert(begin(), n, t);
\end{codeblock}
\end{itemdescr}

\rSec3[lib.vector.capacity]{\tcode{vector}\ capacity}

\index{capacity@\tcode{capacity}!\tcode{vector}}%
\begin{itemdecl}
size_type capacity() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
The total number of elements that the vector can hold
without requiring reallocation.
\end{itemdescr}

\index{reserve@\tcode{reserve}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{where CopyConstructible<T>}@ void reserve(size_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
A directive that informs a
\tcode{vector}\
of a planned change in size, so that it can manage the storage allocation accordingly.
After
\tcode{reserve()},
\tcode{capacity()}\
is greater or equal to the argument of
\tcode{reserve}\
if reallocation happens; and equal to the previous value of
\tcode{capacity()}\
otherwise.
Reallocation happens at this point if and only if the current capacity is less than the
argument of
\tcode{reserve()}.

\pnum
\complexity\ 
It does not change the size of the sequence and takes at most linear time in the size of the sequence.

\pnum
\throws\ 
\tcode{length_error}\
if
\tcode{\farg{n} > max_size()}.%
\footnote{
\tcode{reserve()}\
uses
\tcode{Allocator::allocate()}\
which may throw an appropriate exception.
}

\pnum
\notes\ 
Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence.
It is guaranteed that no reallocation takes place during insertions that happen
after a call to
\tcode{reserve()}\
until the time when an insertion would make the size of the vector
greater than the value of
\tcode{capacity()}.
\end{itemdescr}

\index{swap@\tcode{swap}!\tcode{vector}}%
\begin{itemdecl}
void swap(vector<T,Allocator>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
Exchanges the contents and
\tcode{capacity()}\
of
\tcode{*this}\
with that of \tcode{x}.

\pnum
\complexity\
Constant time.
\end{itemdescr}

\index{resize@\tcode{resize}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{where CopyConstructible<T> \&\& Assignable<T>}@ void resize(size_type sz, T c = T());
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
  if (sz > size())
    insert(end(), sz-size(), c);
  else if (sz < size())
    erase(begin()+sz, end());
  else
    ;                           // do nothing
\end{codeblock}
\end{itemdescr}

\rSec3[lib.vector.data]{\tcode{vector}\ data}
\index{data@\tcode{data}!\tcode{vector}}%
\begin{itemdecl}
@\addedA{pointer         data();}@
@\addedA{const_pointer   data() const;}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedA{\mbox{\returns}
A pointer such that \mbox{\range{data()}{data() + size()}} is a valid range. For a
non-empty vector, \mbox{\tcode{data()}} \mbox{\tcode{==}} \mbox{\tcode{\&front()}}.}

\pnum
\addedA{\mbox{\complexity}
Constant time.}

\pnum
\addedA{\mbox{\throws}
Nothing.}
\end{itemdescr}

\rSec3[lib.vector.modifiers]{\tcode{vector}\ modifiers}

\index{insert@\tcode{insert}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{where CopyConstructible<T> \&\& Assignable<T>}@
  iterator insert(iterator position, const T& x);
@\addedConcepts{where CopyConstructible<T> \&\& Assignable<T>}@
  void insert(iterator position, size_type n, const T& x);
template <@\addedConcepts{InputIterator Iter}@>
  @\addedConcepts{Convertible<Iter::value_type, T> \&\& CopyConstructible<T> \&\& Assignable<T>}@
  void insert(iterator position, Iter first, Iter last);
template <@\addedConcepts{ForwardIterator Iter}@>
  @\addedConcepts{Convertible<Iter::value_type, T> \&\& CopyConstructible<T> \&\& Assignable<T>}@
  void insert(iterator position, Iter first, Iter last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes\ 
Causes reallocation if the new size is greater than the old capacity.
If no reallocation happens, all the iterators and references before the insertion point remain valid.
If an exception is thrown other than by
the copy constructor or assignment operator of
\tcode{T}\ or by any \tcode{InputIterator} operation
there are no effects.

\pnum
\complexity\ 
If
\tcode{first}\
and
\tcode{last}\
are forward iterators\removedConcepts{bidirectional iterators, or random access
iterators}, the complexity is linear in the number of elements in the range
\range{first}{last}\
plus the distance to the end of the vector.
If they are input iterators, the complexity is proportional to
the number of elements in the range
\range{first}{last}\
times the distance to the end of the vector.
\end{itemdescr}

\index{erase@\tcode{erase}!\tcode{vector}}%
\begin{itemdecl}
@\addedConcepts{where Assignable<T>}@ iterator erase(iterator position);
@\addedConcepts{where Assignable<T>}@ iterator erase(iterator first, iterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Invalidates iterators and references at or after the point of the erase.

\pnum
\complexity\ 
The destructor of
\tcode{T}\
is called the number of times equal to the number of the elements erased,
but the assignment operator of
\tcode{T}\
is called the number of times equal to the number of elements in the vector after the erased elements.

\pnum
\throws\ 
Nothing unless an exception is thrown by the
copy constructor or assignment operator of
\tcode{T}.
\end{itemdescr}

\rSec3[lib.vector.special]{\tcode{vector}\ specialized algorithms}

\begin{itemdecl}
template <class T, @\addedConcepts{Allocator Alloc}@>
  void swap(vector<T,Alloc>& x, vector<T,Alloc>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
  x.swap(y);
\end{codeblock}
\end{itemdescr}

\rSec2[lib.vector.bool]{\addedConcepts{Deprecated} class \tcode{vector<bool>}}

\pnum
\index{vector<bool>@\tcode{vector<bool>}}%
To optimize space allocation, a specialization of vector for
\tcode{bool}
elements may be provided:

\begin{codeblock}
namespace std {
  template <@\addedConcepts{Allocator}@ Alloc> class vector<bool, Alloc> {
  public:
    // types:
    typedef bool                                  const_reference;
    typedef @\impdef@                iterator;       // See \ref{lib.container.requirements}
    typedef @\impdef@                const_iterator; // See \ref{lib.container.requirements}
    typedef @\impdef@                size_type;      // See \ref{lib.container.requirements}
    typedef @\impdef@                difference_type;// See \ref{lib.container.requirements}
    typedef bool                                  value_type;
    typedef Alloc                                 allocator_type;
    typedef @\impdef@                pointer;
    typedef @\impdef@                const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // bit reference:
    class reference {
     friend class vector;
     reference();
    public:
     ~reference();
      operator bool() const;
      reference& operator=(const bool x);
      reference& operator=(const reference& x);
      void flip();              // flips the bit
    };

    // construct/copy/destroy:
    explicit vector(const Alloc& = Alloc());
    explicit vector(size_type n, const bool& value = bool(),
                    const Alloc& = Alloc());
    template <@\addedConcepts{InputIterator Iter}@>
      @\addedConcepts{where Convertible<Iter::value_type, bool>}@
      vector(Iter first, Iter last, const Alloc& = Alloc());
    template <@\addedConcepts{ForwardIterator Iter}@>
      @\addedConcepts{where Convertible<Iter::value_type, bool>}@
      vector(Iter first, Iter last, const Alloc& = Alloc());
    vector(const vector<bool,Alloc>& x);
   ~vector();
    vector<bool,Alloc>& operator=(const vector<bool,Alloc>& x);
    template <@\addedConcepts{InputIterator Iter}@>
      @\addedConcepts{where Convertible<Iter::value_type, bool>}@
      void assign(Iter first, Iter last);
    template <@\addedConcepts{ForwardIterator Iter}@>
      @\addedConcepts{where Convertible<Iter::value_type, bool>}@
      void assign(Iter first, Iter last);
    void assign(size_type n, const @\changedA{T}{bool}@& t);
    allocator_type get_allocator() const;

    // iterators:
    iterator               begin();
    const_iterator         begin() const;
    iterator               end();
    const_iterator         end() const;
    reverse_iterator       rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator       rend();
    const_reverse_iterator rend() const;

    // capacity:
    size_type size() const;
    size_type max_size() const;
    void      resize(size_type sz, bool c = false);
    size_type capacity() const;
    bool      empty() const;
    void      reserve(size_type n);

    // element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // modifiers:
    void push_back(const bool& x);
    void pop_back();
    iterator insert(iterator position, const bool& x);
    void     insert (iterator position, size_type n, const bool& x);
    template <@\addedConcepts{InputIterator Iter}@>
      @\addedConcepts{Convertible<Iter::value_type, bool>}@
        void insert(iterator position, Iter first, Iter last);
    template <@\addedConcepts{ForwardIterator Iter}@>
      @\addedConcepts{Convertible<Iter::value_type, bool>}@
        void insert(iterator position, Iter first, Iter last);
    iterator erase(iterator position);
    iterator erase(iterator first, iterator last);
    void swap(vector<bool,Alloc>&);
    static void swap(reference x, reference y);
    void flip();                // flips all bits
    void clear();
  };

  // specialized algorithms:
  template <@\addedConcepts{Allocator Alloc}@>
    void swap(vector<bool,Alloc>& x, vector<bool,Alloc>& y);
}
\end{codeblock}%
\index{vector<bool>@\tcode{vector<bool>}!\tcode{operator==}}%
\index{vector<bool>@\tcode{vector<bool>}!\tcode{operator<}}

\pnum
\tcode{reference}
is a class that simulates the behavior of references of a single bit in
\tcode{vector<bool>}.

\pnum
\addedConcepts{The vector<bool> specialization meets all of the
  container and sequence requirements except that its iterators do not
  meet the ForwardIterator requirements.}

\bibliographystyle{plain}
\bibliography{../local}

\end{document}