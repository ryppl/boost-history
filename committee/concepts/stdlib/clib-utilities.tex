\documentclass[american,twoside]{book}
\usepackage{refbib}
\input{macros}

%%--------------------------------------------------
%% PDF

\usepackage[pdftex,
            pdftitle={Concepts for the C++0x Standard Library: Utilities},
            pdfsubject={C++ International Standard Proposal},
            pdfcreator={Douglas Gregor},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}

%%--------------------------------------------------
%% Set section numbering limit, toc limit
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{2}

%%--------------------------------------------------
%% Parameters that govern document appearance
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.6in}

%%--------------------------------------------------
%% Handle special hyphenation rules
\hyphenation{tem-plate ex-am-ple in-put-it-er-a-tor}

% Do not put blank pages after chapters that end on odd-numbered pages.
\def\cleardoublepage{\clearpage\if@twoside%
  \ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage%
  \if@twocolumn\hbox{}\newpage\fi\fi\fi}

\newsavebox\rebindbox

\begin{document}
\raggedbottom

\begin{titlepage}
\begin{center}
\huge
Concepts for the C++0x Standard Library: Utilities\\
(Revision 5)

\vspace{0.5in}

\normalsize
Douglas Gregor and Andrew Lumsdaine \\
Open Systems Laboratory \\
Indiana University \\
Bloomington, IN\ \  47405 \\
\{\href{mailto:dgregor@osl.iu.edu}{dgregor}, \href{mailto:lums@osl.iu.edu}{lums}\}@osl.iu.edu
\end{center}

\vspace{1in}
\par\noindent Document number: DRAFT\vspace{-6pt}
\par\noindent Revises document number: N2735=08-0245\vspace{-6pt}
\par\noindent Date: \today\vspace{-6pt}
\par\noindent Project: Programming Language \Cpp{}, Library Working Group\vspace{-6pt}
\par\noindent Reply-to: Douglas Gregor $<$\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}$>$\vspace{-6pt}

\section*{Introduction}
\libintrotext{Chapter 20}.

\section*{Changes since N2735}
\begin{itemize}
\item Applied the resolution of library issue 769.
\item Added missing \tcode{Convertible} constraints to
  \tcode{HasBitAnd}, \tcode{HasBitOr}, \tcode{HasBitXor}.
\item Fixed the requirements of some \tcode{pair} and \tcode{tuple}
  constructors, mainly for consistent use of \tcode{RvalueOf}.
\item Add a missing pair assignment operator, \tcode{operator=(const
    pair<U, V>\&)}. The operator is not present in the current working
  paper, which means that one could end up moving from pair lvalues
  (thanks to Alisdair Meredith for reporting this issue).
\end{itemize}

\end{titlepage}

\section*{Proposed Wording}
\paragraph*{Issues resolved by concepts}
The following LWG are resolved by concepts. These issues should be
resolved as NAD following the application of this proposal to the
wording paper:
\begin{description}
\item[Issue 769. std::function should use nullptr_t instead of "unspecified-null-pointer-type".] Applied the proposed resolution to \tcode{function}.
\item[Issue 811. Pair of pointers no longer works with literal 0.]  As
  mentioned in the discussion of the issue, making \tcode{pair} a
  constrained templates solves the problem of construction from a
  literal 0.
\item[Issue 823. \tcode{identity<void>} seems broken.] Applied the proposed resolution to \tcode{identity}, which constrains the function call operator with a \tcode{ReferentType} requirement.
\end{description}

%%--------------------------------------------------
%% Headers and footers
\pagestyle{fancy}
\fancyhead[LE,RO]{\textbf{\rightmark}}
\fancyhead[RE]{\textbf{\leftmark\hspace{1em}\thepage}}
\fancyhead[LO]{\textbf{\thepage\hspace{1em}\leftmark}}
\fancyfoot[C]{Draft}

\fancypagestyle{plain}{
\renewcommand{\headrulewidth}{0in}
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\fancyfoot{}
}

\renewcommand{\sectionmark}[1]{\markright{\thesection\hspace{1em}#1}}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

\setcounter{chapter}{19}
\rSec0[utilities]{General utilities library}
\setcounter{Paras}{1}
\textcolor{black}{\pnum}
The following clauses describe utility and allocator \changedConcepts{requirements}{concepts}, utility
components, \addedB{tuples, type traits templates,} function objects, dynamic
memory management utilities, and date/time utilities, as summarized in
Table~\ref{tab:util.lib.summary}.

\setcounter{table}{29}
\begin{libsumtab}{General utilities library summary}{tab:util.lib.summary}
\ref{utility.concepts}
\changedConcepts{Requirements}{Concepts}    &         \addedConcepts{\ttfamily <concepts>}                                          \\ \rowsep
\ref{utility} Utility components            &       \tcode{<utility>}       \\ \rowsep
\ref{tuple} \addedB{Tuples}         &       \tcode{\addedB{<tuple>}}        \\ \rowsep
\ref{meta} \addedB{Type traits}             &       \tcode{\addedB{<type_traits>}}  \\ \rowsep
\ref{function.objects} Function objects     &       \tcode{<functional>}\\ \rowsep
                                                                                        &       \tcode{<memory>}        \\
\ref{memory} Memory                                         &       \tcode{<cstdlib>}       \\
                                                                                        &       \tcode{<cstring>}       \\ \rowsep
\ref{date.time} Date and time                       &       \tcode{<ctime>}         \\
\end{libsumtab}

\rSec1[utility.concepts]{Concepts}

\editorial{This new section is specified in a separate document, ``Foundational Concepts for the C++0x Standard Library''.}

\rSec1[utility]{Utility components}

\pnum
This subclause contains some basic function and class templates that are used
throughout the rest of the library.

\synopsis{Header \tcode{<utility>}\ synopsis}
\index{utility@\tcode{<utility>}}%
\index{rel_ops@\tcode{rel_ops}}%

\begin{codeblock}
namespace std {
  // \ref{operators}, operators:
  namespace rel_ops {
    template<@\changedConcepts{class}{EqualityComparable}@ T> bool operator!=(const T&, const T&);
    template<@\changedConcepts{class}{LessThanComparable}@ T> bool operator> (const T&, const T&);
    template<@\changedConcepts{class}{LessThanComparable}@ T> bool operator<=(const T&, const T&);
    template<@\changedConcepts{class}{LessThanComparable}@ T> bool operator>=(const T&, const T&);
  }

  // \ref{forward}, forward/move:
  @\removedConcepts{template <class T> struct identity;}@
  template <@\changedConcepts{class}{IdentityOf}@ T> T&& forward(@\changedConcepts{typename identity<T>}{IdentityOf<T>}@::type&&);
  template <@\changedConcepts{class}{RvalueOf}@ T> @\changedConcepts{typename remove_reference<T>::type\&\&}{RvalueOf<T>::type}@ move(T&&);

  // \ref{pairs}, pairs:
  template <@\changedConcepts{class}{VariableType}@ T1,@\changedConcepts{class}{VariableType}@ T2> struct pair;
  template <@\changedConcepts{class}{EqualityComparable}@ T1, @\changedConcepts{class}{EqualityComparable}@ T2>
    bool operator==(const pair<T1,T2>&, const pair<T1,T2>&);
  template <@\changedConcepts{class}{LessThanComparable}@ T1, @\changedConcepts{class}{LessThanComparable}@ T2>
    bool operator< (const pair<T1,T2>&, const pair<T1,T2>&);
  template <@\changedConcepts{class}{EqualityComparable}@ T1, @\changedConcepts{class}{EqualityComparable}@ T2>
    bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&);
  template <@\changedConcepts{class}{LessThanComparable}@ T1, @\changedConcepts{class}{LessThanComparable}@ T2>
    bool operator> (const pair<T1,T2>&, const pair<T1,T2>&);
  template <@\changedConcepts{class}{LessThanComparable}@ T1, @\changedConcepts{class}{LessThanComparable}@ T2>
    bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&);
  template <@\changedConcepts{class}{LessThanComparable}@ T1, @\changedConcepts{class}{LessThanComparable}@ T2>
    bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&);
  template <@\changedConcepts{class}{Swappable}@ T1, @\changedConcepts{class}{Swappable}@ T2> 
    void swap(pair<T1,T2>&, pair<T1,T2>&); 
  template <@\changedConcepts{class}{Swappable}@ T1, @\changedConcepts{class}{Swappable}@ T2> 
    void swap(pair<T1,T2>&&, pair<T1,T2>&);
  template <@\changedConcepts{class}{Swappable}@ T1, @\changedConcepts{class}{Swappable}@ T2> 
    void swap(pair<T1,T2>&, pair<T1,T2>&&); 
  template <@\changedConcepts{class}{MoveConstructible}@ T1, @\changedConcepts{class}{MoveConstructible}@ T2> 
    pair<V1, V2> make_pair(T1&&, T2&&);

  // \ptr\ref{pairs}, tuple-like access to pair:
  template <@\changedConcepts{class}{ObjectType}@ T> class tuple_size;
  template <size_t I, @\changedConcepts{class}{ObjectType}@ T> class tuple_element;

  template <@\changedConcepts{class}{VariableType}@ T1, @\changedConcepts{class}{VariableType}@ T2> struct tuple_size<std::pair<T1, T2> >;
  template <@\changedConcepts{class}{VariableType}@ T1, @\changedConcepts{class}{VariableType}@ T2> struct tuple_element<0, std::pair<T1, T2> >;
  template <@\changedConcepts{class}{VariableType}@ T1, @\changedConcepts{class}{VariableType}@ T2> struct tuple_element<1, std::pair<T1, T2> >;

  template<size_t I, class T1, class T2> 
    @\addedConcepts{requires True<(I < 2)>}@
    P& get(std::pair<T1, T2>&);
  template<size_t I, class T1, class T2> 
    @\addedConcepts{requires True<(I < 2)>}@
    const P& get(const std::pair<T1, T2>&);
}
\end{codeblock}

\rSec2[operators]{Operators}

\editorial{By adding concept constraints to the operators in
  \tcode{rel_ops}, we eliminate nearly all of the problems with
  \tcode{rel_ops} that caused them to be banished. We could consider
  bringing them back into namespace \tcode{std}, if they are deemed
  useful.}

\pnum
To avoid redundant definitions of \tcode{operator!=} out of \tcode{operator==}
and operators \tcode{>}, \tcode{<=}, and \tcode{>=} out of \tcode{operator<},
the library provides the following:

\index{operator"!=@\tcode{operator"!=}}%
\begin{itemdecl}
template <@\changedConcepts{class}{EqualityComparable}@ T> bool operator!=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Requires:
Type T is EqualityComparable~(20.1.1).}

\pnum
\returns\ 
\tcode{!(x == y)}.
\end{itemdescr}

\index{operator>@\tcode{operator>}}%
\begin{itemdecl}
template <@\changedConcepts{class}{LessThanComparable}@ T> bool operator>(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Requires:
Type T is LessThanComparable~(20.1.2).}

\pnum
\returns\ 
\tcode{y < x}.
\end{itemdescr}

\index{operator<=@\tcode{operator<=}}%
\begin{itemdecl}
template <@\changedConcepts{class}{LessThanComparable}@ T> bool operator<=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Requires:
Type T is LessThanComparable~(20.1.2).}

\pnum
\returns\ 
\tcode{!(y < x)}.
\end{itemdescr}

\index{operator>=@\tcode{operator>=}}%
\begin{itemdecl}
template <@\changedConcepts{class}{LessThanComparable}@ T> bool operator>=(const T& x, const T& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Requires:
Type T is LessThanComparable~(20.1.2).}

\pnum
\returns\ 
\tcode{!(x < y)}.
\end{itemdescr}

\pnum
In this library, whenever a declaration is provided for an \tcode{operator!=},
\tcode{operator>}, \tcode{operator>=}, or \tcode{operator<=},
and requirements and semantics are not explicitly provided,
the requirements and semantics are as specified in this clause.

\rSec2[forward]{forward/move helpers}

\pnum
\addedD{The library provides templated helper functions to simplify
applying move semantics to an lvalue and to simplify the implementation
of forwarding functions.}

\editorial{\tcode{identity} is no longer used to make the argument
  type non-deduced. Instead, we use the \tcode{IdentityOf} concept and
  its associated type \tcode{type}, and have moved \tcode{identity}
  to~\ref{function.objects}.}

\index{forward@\tcode{forward}}%
\begin{itemdecl}
template <@\changedConcepts{class}{IdentityOf}@ T> T&& forward(@\changedConcepts{typename identity<T>}{IdentityOf<T>}@::type&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\enternote} The use of \changedConcepts{\mbox{\tcode{identity}}}{\mbox{\tcode{IdentityOf}}} in
\mbox{\tcode{forward}} forces users to explicitly specify the
template parameter. This is necessary to get the correct forwarding
semantics.\mbox{\exitnote}

\pnum
\addedD{\mbox{\returns} \mbox{\tcode{t}}.}
\end{itemdescr}

\setcounter{Paras}{6}
\index{move@\tcode{move}}%
\begin{itemdecl}
template <@\changedConcepts{class}{RvalueOf}@ T> @\changedConcepts{typename remove_reference<T>::type\&\&}{RvalueOf<T>::type}@ move(T&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedD{\mbox{\returns} \mbox{\tcode{t}}.}
\end{itemdescr}

\rSec2[pairs]{Pairs}

\pnum
The library provides a template for heterogeneous pairs of values.
The library also provides a matching function template to simplify
their construction and several templates that provide access to \tcode{pair}
objects as if they were \tcode{tuple} objects (see~\ref{tuple.helper}
and~\ref{tuple.elem}).%
\index{pair@\tcode{pair}}%
\index{pair@\tcode{pair}!tuple interface to}%
\index{tuple@\tcode{tuple}!and pair@and \tcode{pair}}%

\index{pair@\tcode{pair}}%
\begin{codeblock}
template <@\changedConcepts{class}{VariableType}@ T1, @\changedConcepts{class}{VariableType}@ T2>
struct pair {
  typedef T1 first_type;
  typedef T2 second_type;

  T1 first;
  T2 second;
  @\addedConcepts{requires DefaultConstructible<T1> \&\& DefaultConstructible<T2>}@ pair();
  @\addedConcepts{requires CopyConstructible<T1> \&\& CopyConstructible<T2>}@ pair(const T1& @\farg{x}@, const T2& @\farg{y}@);
  template<class @\farg{U}@, class @\farg{V}@>
    @\addedConcepts{requires Constructible<T1, U\&\&> \&\& Constructible<T2, V\&\&>}@ 
    pair(U&& @\farg{x}@, V&& @\farg{y}@);
  @\removedConcepts{pair(pair\&\& \mbox{\farg{p}});}@
  template<class @\farg{U}@, class @\farg{V}@> 
    @\addedConcepts{requires Constructible<T1, const U\&> \&\& Constructible<T2, const V\&>}@
    pair(const pair<@\farg{U}@, @\farg{V}@>& @\farg{p}@);
  template<class @\farg{U}@, class @\farg{V}@> 
    @\addedConcepts{requires Constructible<T1, RvalueOf<U>::type> \&\& Constructible<T2, RvalueOf<V>::type>}@
    pair(pair<@\farg{U}@, @\farg{V}@>&& @\farg{p}@);  
  template<class @\farg{U}@, class... @\farg{Args}@> 
    @\addedConcepts{requires Constructible<T1, U\&\&> \&\& Constructible<T2, Args\&\&...>}@
    pair(U&& @\farg{x}@, Args&&... @\farg{args}@);
  
  // allocator-extended constructors
  template<@\changedConcepts{class}{Allocator} Alloc@>
    @\addedConcepts{requires ConstructibleWithAllocator<T1, Alloc> \&\& ConstructibleWithAllocator<T2, Alloc>}@ 
    pair(allocator_arg_t, const Alloc& a);
  @\removedConcepts{template<class Alloc>}@
    @\removedConcepts{pair(allocator_arg_t, const Alloc\& a, const T1\& \mbox{\farg{x}}, const T2\& \mbox{\farg{y}});}@
  @\removedConcepts{template<class U, class V, class Alloc>}@
    @\removedConcepts{pair(allocator_arg_t, const Alloc\& a, U\&\& \mbox{\farg{x}}, V\&\& \mbox{\farg{y}});}@
  @\removedConcepts{template<class Alloc>}@
    @\removedConcepts{pair(allocator_arg_t, const Alloc\& a, pair\&\& \mbox{\farg{p}});}@
  template<class @\farg{U}@, class @\farg{V}@, @\changedConcepts{class}{Allocator} Alloc@> 
    @\addedConcepts{requires ConstructibleWithAllocator<T1, Alloc, const U\&>}@
          @\addedConcepts{\&\& ConstructibleWithAllocator<T2, Alloc, const V\&>}@
    pair(allocator_arg_t, const Alloc& a, const pair<@\farg{U}@, @\farg{V}@>& @\farg{p}@);
  template<class @\farg{U}@, class @\farg{V}@, @\changedConcepts{class}{Allocator} Alloc@> 
    @\addedConcepts{requires ConstructibleWithAllocator<T1, Alloc, RvalueOf<U>::type>}@
          @\addedConcepts{\&\& ConstructibleWithAllocator<T2, Alloc, RvalueOf<V>::type>}@
    pair(allocator_arg_t, const Alloc& a, pair<@\farg{U}@, @\farg{V}@>&& @\farg{p}@);  
  template<class @\farg{U}@, class... @\farg{Args}@, @\changedConcepts{class}{Allocator} Alloc@> 
    @\addedConcepts{requires ConstructibleWithAllocator<T1, Alloc, U\&\&>}@
          @\addedConcepts{\&\& ConstructibleWithAllocator<T2, Alloc, Args\&\&...>}@
    pair(allocator_arg_t, const Alloc& a, U&& @\farg{x}@, Args&&... @\farg{args}@);

  @\addedConcepts{template<class U , class V>}@
    @\addedConcepts{requires HasAssign<T1, const U\&> \&\& HasAssign<T2, const V\&>}@
    @\addedConcepts{pair\& operator=(const pair<U , V>\& p);}@
  @\addedConcepts{requires MoveAssignable<T1> \&\& MoveAssignable<T2>}@ pair& operator=(pair&& p ); 
  template<class U , class V> 
    @\addedConcepts{requires HasAssign<T1, RvalueOf<U>::type> \&\& HasAssign<T2, RvalueOf<V>::type>}@
    pair& operator=(pair<U , V>&& p);

  @\addedConcepts{requires Swappable<T1> \&\& Swappable<T2>}@ void swap(pair&& p ); 
};

@\removedConcepts{template <class T1, class T2, class Alloc>}@
  @\removedConcepts{struct uses_allocator<pair<T1, T2>, Alloc>;}@

@\addedConcepts{template <class T1, class T2, class Alloc>}@
  @\addedConcepts{concept_map UsesAllocator<pair<T1, T2>, Alloc> \{}@ 
    @\addedConcepts{typedef Alloc allocator_type;}@
  @\addedConcepts{\}}@

@\removedConcepts{template <class T1, class T2>}@
  @\removedConcepts{struct constructible_with_allocator_prefix<pair<T1, T2>{>};}@
\end{codeblock}

\begin{itemdecl}
@\removedConcepts{template <class T1, class T2, class Alloc>}@
  @\removedConcepts{struct uses_allocator<pair<T1, T2>, Alloc> : true_type \{ \};}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{Alloc}} shall be an \mbox{\tcode{Allocator}}~(\mbox{\ref{allocator.requirements}}).}

\pnum
\removedConcepts{\mbox{\enternote} Specialization of this trait informs other library components that \mbox{\tcode{pair}} can be constructed with an allocator, even though it does not have a nested \mbox{\tcode{allocator_type}}. \mbox{\exitnote}}
\end{itemdescr}

\begin{itemdecl}
@\removedConcepts{template <class T1, class T2>}@
  @\removedConcepts{struct constructible_with_allocator_prefix<pair<T1, T2> >}@
    @\removedConcepts{: true_type \{ \};}@
\end{itemdecl}

\begin{itemdescr}
\removedConcepts{\mbox{\enternote} Specialization of this trait informs other library components that \mbox{\tcode{pair}} can be constructed with an allocator prefix argument. \mbox{\exitnote}}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<T1> \&\& DefaultConstructible<T2>}@ pair();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Initializes its members as if implemented: \tcode{pair() : first(), second() \{\}}\
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<T1> \&\& CopyConstructible<T2>}@ pair(const T1& @\farg{x}@, const T2& @\farg{y}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
The constructor initializes \tcode{first} with \farg{x}\ and \tcode{second}
with \farg{y}.
\end{itemdescr}

\begin{itemdecl}
template<class @\farg{U}@, class @\farg{V}@>
  @\addedConcepts{requires Constructible<T1, U\&\&> \&\& Constructible<T2, V\&\&>}@ 
  pair(U&& @\farg{x}@, V&& @\farg{y}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\effects}
The constructor initializes \mbox{\tcode{first}} with
\mbox{\tcode{std::forward<U>(\farg{x})}} and \mbox{\tcode{second}}
with \mbox{\tcode{std::forward<V>(\farg{y})}}.
\end{itemdescr}

\begin{itemdecl}
@\removedConcepts{pair(pair\&\& \mbox{\farg{p}});}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\effects}
The constructor initializes \mbox{\tcode{first}} with
\mbox{\tcode{std::move(\farg{p}.first)}}
and \mbox{\tcode{second}} with
\mbox{\tcode{std::move(\farg{p}.second)}}.}
\end{itemdescr}

\begin{itemdecl}
template<class @\farg{U}@, class @\farg{V}@> 
  @\addedConcepts{requires Constructible<T1, const U\&> \&\& Constructible<T2, const V\&>}@
  pair(const pair<@\farg{U}@, @\farg{V}@> &@\farg{p}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Initializes members from the corresponding members of the argument,
performing implicit conversions as needed.
\end{itemdescr}

\begin{itemdecl}
template<class @\farg{U}@, class @\farg{V}@> 
  @\addedConcepts{requires Constructible<T1, RvalueOf<U>::type> \&\& Constructible<T2, RvalueOf<V>::type>}@
  pair(pair<@\farg{U}@, @\farg{V}@>&& @\farg{p}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\effects}
The constructor initializes \mbox{\tcode{first}} with
\mbox{\tcode{std::move(\farg{p}.first)}}
and \mbox{\tcode{second}} with
\mbox{\tcode{std::move(\farg{p}.second)}}.
\end{itemdescr}

\begin{itemdecl}
template<class U, class... Args> 
  @\addedConcepts{requires Constructible<T1, U\&\&> \&\& Constructible<T2, Args\&\&...>}@
  pair(U&& x, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The constructor initializes \tcode{first} with
\tcode{std::forward<U>(x)} and \tcode{second} with
\tcode{std::forward<Args>(args)...}
\end{itemdescr}

\begin{itemdecl}
template<@\changedConcepts{class}{Allocator} Alloc@>
  @\addedConcepts{requires ConstructibleWithAllocator<T1, Alloc> \&\& ConstructibleWithAllocator<T2, Alloc>}@ 
  pair(allocator_arg_t, const Alloc& a);
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\effects} The members \mbox{\tcode{first}} and
  \mbox{\tcode{second}} are each constructed as
  \mbox{\tcode{ConstructibleWithAllocator}} objects with constructor
  arguments \mbox{\tcode{(allocator_arg_t(), a)}}.}
\end{itemdescr}

\begin{itemdecl}
@\removedConcepts{template<class Alloc>}@
  @\removedConcepts{pair(allocator_arg_t, const Alloc\& a, const T1\& \mbox{\farg{x}}, const T2\& \mbox{\farg{y}});}@
@\removedConcepts{template<class U, class V, class Alloc>}@
  @\removedConcepts{pair(allocator_arg_t, const Alloc\& a, U\&\& \mbox{\farg{x}}, V\&\& \mbox{\farg{y}});}@
@\removedConcepts{template<class Alloc>}@
  @\removedConcepts{pair(allocator_arg_t, const Alloc\& a, pair\&\& \mbox{\farg{p}});}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{Alloc}} shall be an \mbox{\tcode{Allocator}}~(\mbox{\ref{allocator.requirements}}).}

\pnum
\removedConcepts{\mbox{\effects} The members \mbox{\tcode{first}} and \mbox{\tcode{second}} are both \mbox{\techterm{allocator constructed}}~(\mbox{\ref{allocator.concepts}}) with \mbox{\tcode{a}}.}
\end{itemdescr}

\begin{itemdecl}
template<class @\farg{U}@, class @\farg{V}@, @\changedConcepts{class}{Allocator} Alloc@> 
  @\addedConcepts{requires ConstructibleWithAllocator<T1, Alloc, const U\&>}@
        @\addedConcepts{\&\& ConstructibleWithAllocator<T2, Alloc, const V\&>}@
  pair(allocator_arg_t, const Alloc& a, const pair<@\farg{U}@, @\farg{V}@>& @\farg{p}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\effects} The members \mbox{\tcode{first}} and
  \mbox{\tcode{second}} are each constructed as
  \mbox{\tcode{ConstructibleWithAllocator}} objects with constructor
  arguments \mbox{\tcode{(allocator_arg_t(), a, p.first)}} and \mbox{\tcode{(allocator_arg_t(), a, p.second)}}, respectively.} 
\end{itemdescr}

\begin{itemdecl}
template<class @\farg{U}@, class @\farg{V}@, @\changedConcepts{class}{Allocator} Alloc@> 
  @\addedConcepts{requires ConstructibleWithAllocator<T1, Alloc, RvalueOf<U> \&\& ConstructibleWithAllocator<T2, Alloc, RvalueOf<V>::type>}@
  pair(allocator_arg_t, const Alloc& a, pair<@\farg{U}@, @\farg{V}@>&& @\farg{p}@);  
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\effects} The members \mbox{\tcode{first}} and
  \mbox{\tcode{second}} are each constructed as
  \mbox{\tcode{ConstructibleWithAllocator}} objects with constructor
  arguments \mbox{\tcode{(allocator_arg_t(), a, std::move(p.first))}} and \mbox{\tcode{(allocator_arg_t(), a,}}}\\
\addedConcepts{\mbox{\tcode{std::move(p.second))}}, respectively.}
\end{itemdescr}

\begin{itemdecl}
template<class @\farg{U}@, class... @\farg{Args}@, @\changedConcepts{class}{Allocator} Alloc@> 
  @\addedConcepts{requires ConstructibleWithAllocator<T1, Alloc, U\&\&>}@
        @\addedConcepts{\&\& ConstructibleWithAllocator<T2, Alloc, Args\&\&...>}@
  pair(allocator_arg_t, const Alloc& a, U&& @\farg{x}@, Args&&... @\farg{args}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\effects} The members \mbox{\tcode{first}} and
  \mbox{\tcode{second}} are each constructed as
  \mbox{\tcode{ConstructibleWithAllocator}} objects with constructor
  arguments \mbox{\tcode{(allocator_arg_t(), a, std::forward<U>(x))}} and \mbox{\tcode{(allocator_arg_t(), a,}}}\\
\addedConcepts{\mbox{\tcode{std::forward<Args>(args)...)}}, respectively.}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{template<class U , class V>}@
  @\addedConcepts{requires HasAssign<T1, const U\&> \&\& HasAssign<T2, const V\&>}@
  @\addedConcepts{pair\& operator=(const pair<U , V>\& p);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\effects}
Assigns to \mbox{\tcode{first}} with \mbox{\tcode{\farg{p}.first}}
and to \mbox{\tcode{second}} with \mbox{\tcode{\farg{p}.second}}.}

\pnum
\addedConcepts{\mbox{\returns} \mbox{\tcode{*this}}.}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires MoveAssignable<T1> \&\& MoveAssignable<T2>}@ pair& operator=(pair&& @\farg{p}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\effects}
Assigns to \mbox{\tcode{first}} with \mbox{\tcode{std::move(\farg{p}.first)}}
and to \mbox{\tcode{second}} with \mbox{\tcode{std::move(\farg{p}.second)}}.

\pnum
\mbox{\returns} \mbox{\tcode{*this}}.
\end{itemdescr}

\begin{itemdecl}
template<class @\farg{U}@, class @\farg{V}@> 
  @\addedConcepts{requires HasAssign<T1, RvalueOf<U>::type> \&\& MoveAssignable<T2, RvalueOf<V>::type>}@
  pair& operator=(pair<@\farg{U}@, @\farg{V}@>&& @\farg{p}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\effects}
Assigns to \mbox{\tcode{first}} with \mbox{\tcode{std::move(\farg{p}.first)}}
and to \mbox{\tcode{second}} with \mbox{\tcode{std::move(\farg{p}.second)}}.

\pnum
\mbox{\returns} \mbox{\tcode{*this}}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires Swappable<T1> \&\& Swappable<T2>}@ void swap(pair&& @\farg{p}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\effects} Swaps
\mbox{\tcode{first}} with \mbox{\tcode{\farg{p}.first}} and
\mbox{\tcode{second}} with \mbox{\tcode{\farg{p}.second}}.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{first_type}} and 
\mbox{\tcode{second_type}} must be \mbox{\tcode{Swappable}}.}
\end{itemdescr}

\index{operator==@\tcode{operator==}!\tcode{pair}}%
\begin{itemdecl}
template <@\changedConcepts{class}{EqualityComparable}@ T1, @\changedConcepts{class}{EqualityComparable}@ T2>
  bool operator==(const pair<T1, T2>& @\farg{x}@, const pair<T1, T2>& @\farg{y}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.first == y.first \&\& x.second == y.second}.
\end{itemdescr}

\index{operator<@\tcode{operator<}!\tcode{pair}}%
\begin{itemdecl}
template <@\changedConcepts{class}{LessThanComparable}@ T1, @\changedConcepts{class}{LessThanComparable}@ T2>
  bool operator<(const pair<T1, T2>& @\farg{x}@, const pair<T1, T2>& @\farg{y}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.first < y.first || (!(y.first < x.first) \&\& x.second < y.second)}.
\end{itemdescr}

\index{swap@\tcode{swap}!\tcode{pair}}%
\begin{itemdecl}
template<class @\farg{T1}@, class @\farg{T2}@>
  @\addedConcepts{requires Swappable<T1> \&\& Swappable<T2>}@ 
  void swap(pair<@\farg{T1}@, @\farg{T2}@>& @\farg{x}@, pair<@\farg{T1}@, @\farg{T2}@>& @\farg{y}@);
template<class @\farg{T1}@, class @\farg{T2}@> 
  @\addedConcepts{requires Swappable<T1> \&\& Swappable<T2>}@
  void swap(pair<@\farg{T1}@, @\farg{T2}@>&& @\farg{x}@, pair<@\farg{T1}@, @\farg{T2}@>& @\farg{y}@);
template<class @\farg{T1}@, class @\farg{T2}@> 
  @\addedConcepts{requires Swappable<T1> \&\& Swappable<T2>}@
  void swap(pair<@\farg{T1}@, @\farg{T2}@>& @\farg{x}@, pair<@\farg{T1}@, @\farg{T2}@>&& @\farg{y}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\effects} \mbox{\tcode{\farg{x}.swap(\farg{y})}}
\end{itemdescr}

\index{make_pair@\tcode{make_pair}}%
\begin{itemdecl}
template <@\changedConcepts{class}{MoveConstructible}@ T1, @\changedConcepts{class}{MoveConstructible}@ T2>
  pair<V1, V2> make_pair(T1&& @\farg{x}@, T2&& @\farg{y}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns

\begin{codeblock}
pair<V1, V2>(std::forward<T1>(x), std::forward<T2>(y));
\end{codeblock}

where \mbox{\tcode{V1}} and \mbox{\tcode{V2}} are determined as follows: Let \mbox{\tcode{Ui}} be \mbox{\tcode{decay<Ti>::type}} for each \mbox{\tcode{Ti}}. Then each \mbox{\tcode{Vi}} is \mbox{\tcode{X\&}} if \mbox{\tcode{Ui}} equals \mbox{\tcode{reference_wrapper<X>}}, otherwise \mbox{\tcode{Vi}} is \mbox{\tcode{Ui}}.

\pnum
\enterexample\ 
In place of:

\begin{codeblock}
  return pair<int, double>(5, 3.1415926);   // explicit types
\end{codeblock}

a \Cpp\ program may contain:

\begin{codeblock}
  return make_pair(5, 3.1415926);           // types are deduced
\end{codeblock}
\exitexample\ 
\end{itemdescr}

\index{tuple_size@\tcode{tuple_size}}%
\begin{itemdecl}
tuple_size<pair<T1, T2> >::value
\end{itemdecl}
\begin{itemdescr}
\pnum\returns\ integral constant expression.

\pnum\textit{Value:}\ 2.
\end{itemdescr}

\index{tuple_element@\tcode{tuple_element}}%
\begin{itemdecl}
tuple_element<0, pair<T1, T2> >::type
\end{itemdecl}
\begin{itemdescr}
\pnum\textit{Value:}\ the type \tcode{T1}.
\end{itemdescr}

\index{tuple_element@\tcode{tuple_element}}%
\begin{itemdecl}
@\ptr@tuple_element<1, pair<T1, T2> >::type
\end{itemdecl}
\begin{itemdescr}
\pnum\textit{Value:}\ the type T2.
\end{itemdescr}

\index{pair@\tcode{pair}!get@\tcode{get}}%
\index{get@\tcode{get}!pair@\tcode{pair}}%
\begin{itemdecl}
@\ptr@template<int I, class T1, class T2>
  @\addedConcepts{requires True<(I < 2)>}@
  P& get(pair<T1, T2>&);

@\ptr@template<int I, class T1, class T2>
  @\addedConcepts{requires True<(I < 2)>}@
  const P& get(const pair<T1, T2>&);
\end{itemdecl}
\begin{itemdescr}
\pnum\returntype\ If \tcode{I == 0} then \tcode{P} is \tcode{T1}, \changedConcepts{if
  \mbox{\tcode{I == 1}} then}{otherwise} \tcode{P} is \tcode{T2}\removedConcepts{, and otherwise the
  program is ill-formed}.

\pnum\returns\ If \tcode{I == 0} returns \tcode{p.first}, otherwise
  returns \tcode{p.second}.
\end{itemdescr}

\setcounter{section}{3}
\rSec1[tuple]{Tuples}

\pnum
\index{tuple@\tcode{tuple}}%
\ref{tuple} describes the tuple library that provides a tuple type as
the class template \tcode{tuple} that can be instantiated with any number
of arguments. Each template argument specifies
the type of an element in the \tcode{tuple}.  Consequently, tuples are
heterogeneous, fixed-size collections of values.

\pnum
\synopsis{Header \tcode{<tuple>} synopsis}

\index{tuple@\tcode{<tuple>}}%
\begin{codeblock}
namespace std {
  // \ref{tuple.tuple}, class template tuple:
  template <@\changedConcepts{class}{VariableType}@... Types> class tuple;

  // \ref{tuple.creation}, tuple creation functions:
  const @\textit{unspecified}@ ignore;

  template <@\changedConcepts{class}{MoveConstructible}@... Types>
    tuple<@\addedD{VTypes...}@> make_tuple(@\addedD{Types\&\&...}@);

  template<@\changedConcepts{class}{VariableType}@... Types>
    tuple<@\addedD{Types\&...}@> tie(@\addedD{Types\&...}@); 

  template <@\changedConcepts{class}{CopyConstructible}@... TTypes, @\changedConcepts{class}{CopyConstructible}@... UTypes>
    tuple<TTypes..., UTypes...> tuple_cat(const tuple<TTypes...>&, const tuple<UTypes...>&);
  template <@\changedConcepts{class}{MoveConstructible}@... TTypes, @\changedConcepts{class}{CopyConstructible}@... UTypes>
    tuple<TTypes..., UTypes...> tuple_cat(tuple<TTypes...>&&, const tuple<UTypes...>&);
  template <@\changedConcepts{class}{CopyConstructible}@... TTypes, @\changedConcepts{class}{MoveConstructible}@... UTypes>
    tuple<TTypes..., UTypes...> tuple_cat(const tuple<TTypes...>&, tuple<UTypes...>&&);
  template <@\changedConcepts{class}{MoveConstructible}@... TTypes, @\changedConcepts{class}{MoveConstructible}@... UTypes>
    tuple<TTypes..., UTypes...> tuple_cat(tuple<TTypes...>&&, tuple<UTypes...>&&);

  // \ref{tuple.helper}, tuple helper classes:
  template <@\changedConcepts{class}{ObjectType}@ T> class tuple_size;  // \addedD{undefined}
  template <@\changedConcepts{class}{VariableType}@... Types> class tuple_size<tuple<Types...> >;

  template <size_t I, @\changedConcepts{class}{ObjectType}@ T> class tuple_element;    // \addedD{undefined}
  template <size_t I, @\changedConcepts{class}{VariableType}@... Types>
    @\addedConcepts{requires True<(I < sizeof...(Types))>}@ class tuple_element<I, tuple<Types...> >;

  // \ref{tuple.elem}, element access:
  template <size_t I, @\changedConcepts{class}{VariableType}@... Types> 
    @\addedConcepts{requires True<(I < sizeof...(Types))>}@
    typename tuple_element<I, tuple<Types...> >::type& get(tuple<Types...>&);

  template <size_t I, @\changedConcepts{class}{VariableType}@... Types>
    @\addedConcepts{requires True<(I < sizeof...(Types))>}@
    typename tuple_element<I, tuple<Types...> >::type const& get(const tuple<Types...>&);

  // \ref{tuple.rel}, relational operators:
  template<class... TTypes, class... UTypes>
    @\addedConcepts{requires EqualityComparable<TTypes, UTypes>...}@
    bool operator==(const tuple<@\addedD{TTypes...}@>&, const tuple<@\addedD{UTypes...}@>&);

  template<@\addedD{class... TTypes, class... UTypes}@>
    @\addedConcepts{requires LessThanComparable<TTypes, UTypes>...}@
    bool operator<(const tuple<@\addedD{TTypes...}@>&, const tuple<@\addedD{UTypes...}@>&);

  template<@\addedD{class... TTypes, class... UTypes}@>
    @\addedConcepts{requires EqualityComparable<TTypes, UTypes>...}@
    bool operator!=(const tuple<@\addedD{TTypes...}@>&, const tuple<@\addedD{UTypes...}@>&);

  template<@\addedD{class... TTypes, class... UTypes}@>
    @\addedConcepts{requires LessThanComparable<UTypes, TTypes>...}@
    bool operator>(const tuple<@\addedD{TTypes...}@>&, const tuple<@\addedD{UTypes...}@>&);

  template<@\addedD{class... TTypes, class... UTypes}@>
    @\addedConcepts{requires LessThanComparable<UTypes, TTypes>...}@
    bool operator<=(const tuple<@\addedD{TTypes...}@>&, const tuple<@\addedD{UTypes...}@>&);

  template<@\addedD{class... TTypes, class... UTypes}@>
    @\addedConcepts{requires LessThanComparable<TTypes, UTypes>...}@
    bool operator>=(const tuple<@\addedD{TTypes...}@>&, const tuple<@\addedD{UTypes...}@>&);

} // namespace std
\end{codeblock}

\rSec2[tuple.tuple]{Class template \tcode{tuple}}

\index{tuple@\tcode{tuple}}%
\begin{codeblock}
template <@\changedConcepts{class}{VariableType}@... Types>
class tuple 
{
public:
  @\addedConcepts{requires DefaultConstructible<Types>...}@ tuple();
  @\removedConcepts{explicit tuple(const Types\&...);}@
  template <class... UTypes>
    @\addedConcepts{requires Constructible<Types, UTypes\&\&>...}@
    explicit tuple(UTypes&&...);

  @\addedConcepts{requires CopyConstructible<Types>...}@ tuple(const tuple&);
  @\removedConcepts{tuple(tuple\&\&);}@

  template <class... UTypes>
    @\addedConcepts{requires Constructible<Types, const UTypes\&>...}@
    tuple(const tuple<UTypes...>&);
  template <class... UTypes>
    @\addedConcepts{requires Constructible<Types, RvalueOf<UTypes>::type>...}@
    tuple(tuple<UTypes...>&&);

  template <@\changedConcepts{class U1, class U2}{class... UTypes}@>
    @\addedConcepts{requires Constructible<Types, const UTypes\&>...}@
    tuple(const pair<@\changedConcepts{U1, U2}{UTypes...}@>&);      @\removedConcepts{// iff \mbox{\tcode{sizeof...(Types) == 2}}}@
  template <@\changedConcepts{class U1, class U2}{class... UTypes}@>
    @\addedConcepts{requires Constructible<Types, RvalueOf<UTypes>::type>...}@
    tuple(pair<@\changedConcepts{U1, U2}{UTypes...}@>&&);           @\removedConcepts{// iff \mbox{\tcode{sizeof...(Types) == 2}}}@

  // allocator-extended constructors
  template <@\changedConcepts{class}{Allocator}@ Alloc>
    @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc>...}@ 
    tuple(allocator_arg_t, const Alloc& a);
  @\removedConcepts{template <class Alloc>}@
    @\removedConcepts{explicit tuple(allocator_arg_t, const Alloc\& a, const Types\&...);}@
  template <@\changedConcepts{class}{Allocator}@ Alloc, class... UTypes>
    @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc, UTypes\&\&>...}@
    explicit tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
  @\removedConcepts{template <class Alloc>}@
    @\removedConcepts{tuple(allocator_arg_t, const Alloc\& a, const tuple\&);}@
  @\removedConcepts{template <class Alloc>}@
    @\removedConcepts{tuple(allocator_arg_t, const Alloc\& a, tuple\&\&);}@
  template <@\changedConcepts{class}{Allocator}@ Alloc, class... UTypes>
    @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc, const UTypes\&>...}@
    tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
  template <@\changedConcepts{class}{Allocator}@ Alloc, class... UTypes>
    @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc, RvalueOf<UTypes>::type>...}@
    tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
  template <@\changedConcepts{class}{Allocator}@ Alloc, @\changedConcepts{class U1, class U2}{class... UTypes}@>
    @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc, const UTypes\&>...}@
    tuple(allocator_arg_t, const Alloc& a, const pair<@\changedConcepts{U1, U2}{UTypes...}@>&);
  template <@\changedConcepts{class}{Allocator}@ Alloc, @\changedConcepts{class U1, class U2}{class... UTypes}@>
    @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc, RvalueOf<UTypes>::type>...}@
    tuple(allocator_arg_t, const Alloc& a, pair<@\changedConcepts{U1, U2}{UTypes...}@>&&);

  @\addedConcepts{requires CopyAssignable<Types>...}@ tuple& operator=(const tuple&);
  @\removedConcepts{tuple\& operator=(tuple\&\&);}@

  template <class... UTypes>
    @\addedConcepts{requires HasAssign<Types, const UTypes\&>...}@
    tuple& operator=(const tuple<@\addedD{UTypes...}@>&);
  template <class... UTypes>
    @\addedConcepts{requires HasAssign<Types, RvalueOf<UTypes>::type>...}@
    tuple& operator=(tuple<UTypes...>&&);

  template <@\changedConcepts{class U1, class U2}{class... UTypes}@>
    @\addedConcepts{requires HasAssign<Types, const UTypes\&>...}@
    tuple& operator=(const pair<@\changedConcepts{U1, U2}{UTypes...}@>&);  @\removedConcepts{// iff \mbox{\tcode{sizeof...(Types) == 2}}}@
  template <@\changedConcepts{class U1, class U2}{class... UTypes}@>
    @\addedConcepts{requires HasAssign<Types, RvalueOf<UTypes>::type>...}@
    tuple& operator=(pair<@\changedConcepts{U1, U2}{UTypes...}@>&&);       @\removedConcepts{// iff \mbox{\tcode{sizeof...(Types) == 2}}}@
};

@\addedConcepts{template<class... Types, class Alloc>}@
  @\addedConcepts{concept_map UsesAllocator<tuple<Types...>, Alloc> \{}@
    @\addedConcepts{typedef Alloc allocator_type;}@
  @\addedConcepts{\}}@
\end{codeblock}

\rSec3[tuple.traits]{\removedConcepts{Tuple traits}}
\editorial{Remove the section [tuple.traits] completely}

\rSec3[tuple.cnstr]{Construction}

\index{tuple@\tcode{tuple}!tuple@\tcode{tuple}}%
\begin{itemdecl}
@\addedConcepts{requires DefaultConstructible<Types>...}@ tuple();
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} Each type in \mbox{\tcode{Types}} shall be default constructible.}

\pnum
\effects\  Default initializes each element.
\end{itemdescr}

\index{tuple@\tcode{tuple}!tuple@\tcode{tuple}}%
\begin{itemdecl}
@\removedConcepts{tuple(const Types\&...);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}  Each type in \mbox{\tcode{Types}}
shall be copy constructible.}

\pnum
\removedConcepts{\mbox{\effects}  Copy initializes each element with the value of the
corresponding parameter.}
\end{itemdescr}

\index{tuple@\tcode{tuple}!tuple@\tcode{tuple}}%
\begin{itemdecl}
@\addedD{template <class... UTypes>}@
  @\addedConcepts{requires Constructible<Types, UTypes\&\&>...}@
  @\addedD{tuple(UTypes\&\&... u);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} Each type in \mbox{\tcode{Types}} shall be move
constructible from the corresponding type in \mbox{\tcode{UTypes}}.
\mbox{\tcode{sizeof...(Types)}} \mbox{\tcode{==}}
\mbox{\tcode{sizeof...(UTypes)}}.}

\pnum
\addedD{\mbox{\effects} Initializes the elements in the tuple with the
corresponding value in \mbox{\tcode{std::forward<UTypes>(u)}}.}
\end{itemdescr}

\index{tuple@\tcode{tuple}!tuple@\tcode{tuple}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<Types>...}@ tuple(const tuple& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} Each type in \mbox{\tcode{Types}}
shall be copy constructible.}

\pnum
\effects\  Copy constructs each element of \tcode{*this} with the 
corresponding element of \tcode{u}.
\end{itemdescr}

\index{tuple@\tcode{tuple}!tuple@\tcode{tuple}}%
\begin{itemdecl}
@\removedConcepts{tuple(tuple\&\& u);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} Each type in \mbox{\tcode{Types}} shall be
move constructible.}

\pnum
\removedConcepts{\mbox{\effects} Move-constructs each element of \mbox{\tcode{*this}}
with the corresponding element of \mbox{\tcode{u}}.}
\end{itemdescr}

\index{tuple@\tcode{tuple}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template <@\addedD{class... UTypes}@> 
  @\addedConcepts{requires Constructible<Types, const UTypes\&>...}@
  tuple(const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}  Each type in \mbox{\tcode{Types}}
shall be constructible from the corresponding type
in \mbox{\tcode{UTypes}}.
\mbox{\tcode{sizeof...(Types)}} \mbox{\tcode{==}}
\mbox{\tcode{sizeof...(UTypes)}}.}

\pnum\effects\  Constructs each element of \tcode{*this} with the corresponding
element of \tcode{u}.

\pnum
\removedConcepts{\mbox{\enternote}
  \mbox{\tcode{enable_if}} can be used to
  make the converting constructor and assignment operator exist only
  in the cases where the source and target have the same number of
  elements.  \mbox{\exitnote}}
\end{itemdescr}

\index{tuple@\tcode{tuple}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template <class... UTypes> 
  @\addedConcepts{requires Constructible<Types, RvalueOf<UTypes>::type>...}@
  tuple(tuple<UTypes...>&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} Each type in \mbox{\tcode{Types}} shall be
move-constructible from the corresponding type in \mbox{\tcode{UTypes}}.
\mbox{\tcode{sizeof...(Types)}} \mbox{\tcode{==}}
\mbox{\tcode{sizeof...(UTypes)}}.}

\pnum
\addedD{\mbox{\effects} Move-constructs each element of \mbox{\tcode{*this}}
with the corresponding element of \mbox{\tcode{u}}.}

\addedD{\mbox{\enternote} \mbox{\tcode{enable_if}} can be used to make the
converting constructor and assignment operator exist only in the cases where
the source and target have the same number of elements. \mbox{\exitnote}}
\end{itemdescr}

\index{tuple@\tcode{tuple}!tuple@\tcode{tuple}}%
\index{pair@\tcode{pair}}%
\begin{itemdecl}
template <@\changedConcepts{class U1, class U2}{class... UTypes}@>
  @\addedConcepts{requires Constructible<Types, const UTypes\&>...}@
  tuple(const pair<@\changedConcepts{U1, U2}{UTypes...}@>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}  The first type in \mbox{\tcode{Types}}
shall be constructible from \mbox{\tcode{U1}} and
the second type in \mbox{\tcode{Types}}
shall be constructible from \mbox{\tcode{U2}}.
\mbox{\tcode{sizeof...(Types) == 2}}.}

\pnum
\effects\  Constructs the first element with \tcode{u.first} and the
second element with \tcode{u.second}.
\end{itemdescr}

\index{tuple@\tcode{tuple}!tuple@\tcode{tuple}}%
\index{pair@\tcode{pair}}%
\begin{itemdecl}
template <@\changedConcepts{class U1, class U2}{class... UTypes}@>
  @\addedConcepts{requires Constructible<Types, RvalueOf<UTypes>::type>...}@
  tuple(pair<@\changedConcepts{U1, U2}{UTypes...}@>&&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} The first type in \mbox{\tcode{Types}} shall be
move constructible from \mbox{\tcode{U1}} and the second type in
\mbox{\tcode{Types}} shall be move-constructible from \mbox{\tcode{U2}}.
\mbox{\tcode{sizeof...(Types) == 2}}.}

\pnum
\addedD{\mbox{\effects}  Constructs the first element with
\mbox{\tcode{std::move(u.first)}} and the
second element with \mbox{\tcode{std::move(u.second)}}.}
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator=@\tcode{operator=}}%
\index{operator=@\tcode{operator=}!tuple@\tcode{tuple}}%
\begin{itemdecl}
@\addedConcepts{requires CopyAssignable<Types>...}@ tuple& operator=(const tuple& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}  Each type in \mbox{\tcode{Types}}
shall be assignable.}

\pnum
\effects\  Assigns each element of \tcode{u} to the corresponding 
element of \tcode{*this}.

\pnum
\returns\  \tcode{*this}
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator=@\tcode{operator=}}%
\index{operator=@\tcode{operator=}!tuple@\tcode{tuple}}%
\begin{itemdecl}
@\addedConcepts{requires MoveAssignable<Types>...}@ @\addedD{tuple\& operator=(tuple\&\& u);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} Each type in \mbox{\tcode{Types}} shall be
move-assignable.}

\pnum
\addedD{\mbox{\effects} Move-assigns each element of \mbox{\tcode{u}} to
the corresponding element of \mbox{\tcode{*this}}.}

\pnum
\addedD{\mbox{\returns} \mbox{\tcode{*this}}.}
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator=@\tcode{operator=}}%
\index{operator=@\tcode{operator=}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template <@\addedD{class... UTypes}@>
  @\addedConcepts{requires CopyAssignable<Types, UTypes>...}@ 
  tuple& operator=(const tuple<@\addedD{UTypes...}@>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}  Each type in \mbox{\tcode{Types}}
shall be assignable from the corresponding type
in \mbox{\tcode{UTypes}}}.

\pnum
\effects\  Assigns each element of \tcode{u} to the corresponding element
of \tcode{*this}.

\pnum
\returns\  \tcode{*this}
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator=@\tcode{operator=}}%
\index{operator=@\tcode{operator=}!tuple@\tcode{tuple}}%
\begin{itemdecl}
@\addedD{template <class... UTypes>}@
  @\addedConcepts{requires MoveAssignable<Types, UTypes>...}@ 
  @\addedD{tuple\& operator=(tuple<UTypes...>\&\& u);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} Each type in \mbox{\tcode{Types}} shall be
move-assignable from the corresponding type in \mbox{\tcode{UTypes}}.
\mbox{\tcode{sizeof...(Types)}} \mbox{\tcode{==}}
\mbox{\tcode{sizeof...(UTypes)}}.}

\pnum
\addedD{\mbox{\effects} Move-assigns each element of \mbox{\tcode{u}}
to the corresponding element of \mbox{\tcode{*this}}.}

\pnum
\addedD{\mbox{\returns} \mbox{\tcode{*this}}.}
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator=@\tcode{operator=}}%
\index{operator=@\tcode{operator=}!tuple@\tcode{tuple}}%
\index{pair@\tcode{pair}}%
\begin{itemdecl}
template <@\changedConcepts{class U1, class U2}{class... UTypes}@>
  @\addedConcepts{requires HasAssign<Types, const UTypes\&>...}@
  tuple& operator=(const pair<@\changedConcepts{U1, U2}{UTypes...}@>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}  The first type in
\mbox{\tcode{Types}} shall be move assignable from \mbox{\tcode{U1}} and
the second type in \mbox{\tcode{Types}}
shall be move assignable from \mbox{\tcode{U2}}.
\mbox{\tcode{sizeof...(Types) == 2}}.}

\pnum
\effects\  Assigns \tcode{u.first} to the first element of \tcode{*this}
and \tcode{u.second} to the second element of \tcode{*this}.

\pnum
\returns\  \tcode{*this}

\pnum
\enternote\ There are rare conditions where the
  converting copy constructor is a better match than the element-wise
  construction, even though the user might intend differently.  An
  example of this is if one is constructing a one-element tuple where
  the element type is another tuple type \tcode{T} and if the parameter
  passed to the constructor is not of type \tcode{T}, but rather a tuple
  type that is convertible to \tcode{T}.  The effect of the converting copy
  construction is most likely the same as the effect of the
  element-wise construction would have been.  However, it it possible
  to compare the ``nesting depths'' of the source and target tuples and
  decide to select the element-wise constructor if the source nesting
  depth is smaller than the target nesting-depth.  This can be
  accomplished using an \tcode{enable_if} template or other tools for
  constrained templates.  
\exitnote\
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator=@\tcode{operator=}}%
\index{operator=@\tcode{operator=}!tuple@\tcode{tuple}}%
\index{pair@\tcode{pair}}%
\begin{itemdecl}
template <@\changedConcepts{class U1, class U2}{class... UTypes}@>
  @\addedConcepts{requires HasAssign<Types, RvalueOf<UTypes>::type>...}@
  tuple& operator=(pair<@\changedConcepts{U1, U2}{UTypes...}@>&&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} The first type in \mbox{\tcode{Types}} shall be
assignable from \mbox{\tcode{U1}} and the second type in \mbox{\tcode{Types}}
shall be assignable from \mbox{\tcode{U2}}. \mbox{\tcode{sizeof...(Types) == 2}}.}

\pnum
\addedD{\mbox{\effects} Assigns \mbox{\tcode{std::move(u.first)}} to the first
element of \mbox{\tcode{*this}} and \mbox{\tcode{std::move(u.second)}} to the
second element of \mbox{\tcode{*this}}.}

\pnum
\addedD{\mbox{\returns} \mbox{\tcode{*this}}.}
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class}{Allocator}@ Alloc>
  @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc>...}@ 
  tuple(allocator_arg_t, const Alloc& a);
@\removedConcepts{template <class Alloc>}@
  @\removedConcepts{explicit tuple(allocator_arg_t, const Alloc\& a, const Types\&...);}@
template <@\changedConcepts{class}{Allocator}@ Alloc, class... UTypes>
  @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc, UTypes\&\&>...}@
  explicit tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
@\removedConcepts{template <class Alloc>}@
  @\removedConcepts{tuple(allocator_arg_t, const Alloc\& a, const tuple\&);}@
@\removedConcepts{template <Allocator Alloc>}@
  @\removedConcepts{tuple(allocator_arg_t, const Alloc\& a, tuple\&\&);}@
template <@\changedConcepts{class}{Allocator}@ Alloc, class... UTypes>
  @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc, const UTypes\&>...}@
  tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
template <@\changedConcepts{class}{Allocator}@ Alloc, class... UTypes>
  @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc, RvalueOf<UTypes>::type>...}@
  tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
template <@\changedConcepts{class}{Allocator}@ Alloc, @\changedConcepts{class U1, class U2}{class... UTypes}@>
  @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc, const UTypes\&>...}@
  tuple(allocator_arg_t, const Alloc& a, const pair<@\changedConcepts{U1, U2}{UTypes...}@>&);
template <@\changedConcepts{class}{Allocator}@ Alloc, @\changedConcepts{class U1, class U2}{class... UTypes}@>
  @\addedConcepts{requires ConstructibleWithAllocator<Types, Alloc, RvalueOf<UTypes>::type>...}@
  tuple(allocator_arg_t, const Alloc& a, pair<@\changedConcepts{U1, U2}{UTypes...}@>&&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{Alloc}} shall be an \mbox{\tcode{Allocator}}~(\mbox{\ref{allocator.requirements}}).}

\pnum
\mbox{\effects} Equivalent to the preceding constructors except that the allocator argument is passed conditionally to the constructor of each element. Each member is \mbox{\techterm{allocator constructed}}~(\mbox{\ref{allocator.concepts}}) with \mbox{\tcode{a}}.
\end{itemdescr}

\rSec3[tuple.creation]{Tuple creation functions}

\index{make_tuple@\tcode{make_tuple}}%
\index{tuple@\tcode{tuple}!make_tuple@\tcode{make_tuple}}%
\begin{itemdecl}
template<@\changedConcepts{class}{MoveConstructible}@... Types>
  tuple<VTypes...> make_tuple(Types&&... t); 
\end{itemdecl}

\begin{itemdescr}
\pnum 
Let \mbox{\tcode{Ui}} be \mbox{\tcode{decay<Ti>::type}} for each \mbox{\tcode{Ti}} in \mbox{\tcode{Types}}. Then each \mbox{\tcode{Vi}} in \mbox{\tcode{VTypes}} is \mbox{\tcode{X\&}} if \mbox{\tcode{Ui}} equals \mbox{\tcode{reference_wrapper<X>}}, otherwise \mbox{\tcode{Vi}} is \mbox{\tcode{Ui}}.

\pnum
\returns\ \tcode{tuple<VTypes...>(std::forward<Types>(t)...)}.
 
\pnum
\enterexample\

\begin{codeblock}
int i; float j; 
make_tuple(1, ref(i), cref(j))
\end{codeblock}

creates a tuple of type 

\begin{codeblock}
tuple<int, int&, const float&>
\end{codeblock}

\exitexample\

\end{itemdescr}

\index{tie@\tcode{tie}}%
\index{tuple@\tcode{tuple}!tie@\tcode{tie}}%
\begin{itemdecl}
template<@\changedConcepts{class}{VariableType}@... Types>
  tuple<@\addedD{Types\&...}@> tie(@\addedD{Types\&... t}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\  \tcode{tuple<\addedD{Types\&}>(\addedD{t...})}.  When an
argument \changedD{ti}{in \mbox{\tcode{t}}} is \tcode{ignore}, assigning
any value to the corresponding tuple element has no effect.
 
\pnum
\enterexample\
\tcode{tie} functions allow one to create tuples that unpack 
tuples into variables. \tcode{ignore} can be used for elements that
are not needed:
\begin{codeblock}
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
// \tcode{i == 42}, \tcode{s == "C++"}
\end{codeblock}
\exitexample\
\end{itemdescr}

\editorial{I have collapsed the 8 paragraphs used to describe the four
  different variants of \tcode{tuple_cat} into a single paragraph of
  description, which eliminates a lot of redundancy and saves some
  space.}

\begin{itemdecl}
template <@\changedConcepts{class}{CopyConstructible}@... TTypes, @\changedConcepts{class}{CopyConstructible}@... UTypes>
  tuple<TTypes..., UTypes...> tuple_cat(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
template <@\changedConcepts{class}{MoveConstructible}@... TTypes, @\changedConcepts{class}{CopyConstructible}@... UTypes>
  tuple<TTypes..., UTypes...> tuple_cat(tuple<TTypes...>&& t, const tuple<UTypes...>& u);
template <@\changedConcepts{class}{CopyConstructible}@... TTypes, @\changedConcepts{class}{MoveConstructible}@... UTypes>
  tuple<TTypes..., UTypes...> tuple_cat(const tuple<TTypes...>& t, tuple<UTypes...>&& u);
template <@\changedConcepts{class}{MoveConstructible}@... TTypes, @\changedConcepts{class}{MoveConstructible}@... UTypes>
  tuple<TTypes..., UTypes...> tuple_cat(tuple<TTypes...>&& t, tuple<UTypes...>&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}
All the types in \mbox{\tcode{TTypes}} shall be MoveConstructible (Table~\mbox{\ref{moveconstructible}}).
All the types in \mbox{\tcode{UTypes}} shall be MoveConstructible (Table~\mbox{\ref{moveconstructible}}).}

\pnum
\returns A \tcode{tuple} object constructed by
\changedConcepts{move}{copy- or move-}constructing its first \tcode{sizeof...(TTypes)} elements from
the corresponding elements of \tcode{t} and \changedConcepts{move}{copy- or move-}constructing its
last \tcode{sizeof...(UTypes)} elements from the corresponding
elements of \tcode{u}.
\end{itemdescr}

\rSec3[tuple.helper]{Tuple helper classes}
\setcounter{Paras}{3}
\index{tuple_element@\tcode{tuple_element}}%
\begin{itemdecl}
template <size_t I, class... Types>
@\addedConcepts{requires True<(I < sizeof...(Types))>}@
class tuple_element<I, tuple<Types...> > {
public:
  typedef TI type;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}  \mbox{\addedD{\mbox{\tcode{I < sizeof...(Types)}}.}}
The program is ill-formed if \mbox{\tcode{I}} is out of bounds.}

\pnum
\changedD{\mbox{\tcode{Value}}:  The}{\mbox{\ctype} \mbox{\tcode{TI}} is the}
type of the \tcode{I}th element of \changedD{\mbox{\tcode{T}}}{\mbox{\tcode{Types}}},
where indexing is zero-based.
\end{itemdescr}


\rSec3[tuple.elem]{Element access}

\index{tuple@\tcode{tuple}!get@\tcode{get}}%
\index{get@\tcode{get}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template <size_t I, @\changedConcepts{class}{VariableType}@... Types> 
  @\addedConcepts{requires True<(I < sizeof...(Types))>}@
  typename tuple_element<I, tuple<Types...> >::type& get(tuple<Types...>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}  \mbox{\addedD{\mbox{\tcode{I < sizeof...(Types)}}.}}
The program is ill-formed if \mbox{\tcode{I}} is out of bounds.}

\pnum
\removedD{\mbox{\returntype}  \mbox{\tcode{RJ}}, where \mbox{\tcode{J=I+1}}.
If \mbox{\tcode{TJ}} is a
reference type, then \mbox{\tcode{RJ}}
is \mbox{\tcode{TJ}}, otherwise \mbox{\tcode{RJ}} is \mbox{\tcode{TJ\&}}.}

\pnum
\returns\  A reference to the \tcode{I}th element of \tcode{t}, where
indexing is zero-based.
\end{itemdescr}

\index{tuple@\tcode{tuple}!get@\tcode{get}}%
\index{get@\tcode{get}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template <size_t I, @\changedConcepts{class}{VariableType}@... Types> 
  @\addedConcepts{requires True<(I < sizeof...(Types))>}@
  typename tuple_element<I, tuple<Types...> >::type const& get(const tuple<Types...>& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}  \mbox{\addedD{\mbox{\tcode{I < sizeof...(Types)}}.}}
The program is ill-formed if \mbox{\tcode{I}} is out of bounds.}

\pnum
\removedD{\mbox{\returntype}  \mbox{\tcode{PJ}}, where \mbox{\tcode{J=I+1}}.
If \mbox{\tcode{TJ}} is a
reference type, then \mbox{\tcode{PJ}}
is \mbox{\tcode{TJ}}, otherwise \mbox{\tcode{PJ}} is \mbox{\tcode{const TJ\&}}.}

\pnum
\returns\  A const reference to the \tcode{I}th element of \tcode{t}, where
indexing is zero-based.

\pnum
\enternote\ Constness is shallow. If \changedD{\mbox{\tcode{TJ}}}{a \mbox{\tcode{T}}
in \mbox{\tcode{Types}}} is some
reference type \tcode{X\&}, the return type is \tcode{X\&}, not \tcode{const X\&}.
However, if the element type is non-reference type \tcode{T}, the return
type is \tcode{const T\&}.
This is consistent with how constness is defined to work 
for member variables of reference type. \exitnote]

\pnum
\enternote\ The reason \tcode{get} is a
nonmember function is that if this functionality had been
provided as a member function, code where the type
depended on a template parameter would have required using
the \tcode{template} keyword. \exitnote\
\end{itemdescr}

\rSec3[tuple.rel]{Relational operators}

\index{tuple@\tcode{tuple}!operator==@\tcode{operator==}}%
\index{operator==@\tcode{operator==}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template<@\addedD{class... TTypes, class... UTypes}@>
  @\addedConcepts{requires EqualityComparable<TTypes, UTypes>...}@
  bool operator==(const tuple<@\addedD{TTypes...}@>& t, const tuple<@\addedD{UTypes...}@>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires}  For all \mbox{\tcode{i}},
where \mbox{\tcode{0 <= i}} and
\mbox{\tcode{i < sizeof...(Types)}}, \mbox{\tcode{get<i>(t) == get<i>(u)}} is a valid expression
returning a type that is convertible to \mbox{\tcode{bool}}.
\mbox{\tcode{sizeof...(TTypes)}} \mbox{\tcode{==}}
\mbox{\tcode{sizeof...(UTypes)}}.}

\pnum
\returns\  \tcode{true} iff \tcode{get<i>(t) == get<i>(u)} for all \tcode{i}.
For any two zero-length tuples \tcode{e} and \tcode{f}, \tcode{e == f} returns \tcode{true}.

\pnum
\effects\  The elementary comparisons are performed in order from the
zeroth index upwards.  No comparisons or element accesses are
performed after the first equality comparison that evaluates to
\tcode{false}.
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator<@\tcode{operator<}}%
\index{operator<@\tcode{operator<}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template<@\addedD{class... TTypes, class... UTypes}@>
  @\addedConcepts{requires LessThanComparable<TTypes, UTypes>...}@
  bool operator<(const tuple<@\addedD{TTypes...}@>& t, const tuple<@\addedD{UTypes...}@>& u);
\end{itemdecl}

\begin{itemdescr}
\removedConcepts{\mbox{\requires}  For all \mbox{\tcode{i}},
where \mbox{\tcode{0 <= i}} and
\mbox{\tcode{i < sizeof...(Types)}}, \mbox{\tcode{get<i>(t) == get<i>(u)}} is a valid expression
returning a type that is convertible to \mbox{\tcode{bool}}.
\mbox{\tcode{sizeof...(TTypes)}} \mbox{\tcode{==}}
\mbox{\tcode{sizeof...(UTypes)}}.}

\pnum\returns\  The result of a lexicographical comparison
between \tcode{t} and \tcode{u}. The result is defined
as: \tcode{(bool)(get<0>(t) < get<0>(u)) ||
(!(bool)(get<0>(u) < get<0>(t)) \&\& t$_{\mathrm{tail}}$ <
u$_{\mathrm{tail}}$)}, where \tcode{r$_{\mathrm{tail}}$} for some
tuple \tcode{r} is a tuple containing all but the first element
of \tcode{r}.  For any two zero-length tuples \tcode{e}
and \tcode{f}, \tcode{e < f} returns \tcode{false}.
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator"!=@\tcode{operator"!=}}%
\index{operator"!=@\tcode{operator"!=}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template<@\addedD{class... TTypes, class... UTypes}@>
  @\addedConcepts{requires EqualityComparable<TTypes, UTypes>...}@
  bool operator!=(const tuple<@\addedD{TTypes...}@>& t, const tuple<@\addedD{UTypes...}@>& u);
\end{itemdecl}
\begin{itemdescr}
\pnum\returns\ \tcode{!(t == u)}.
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator>@\tcode{operator>}}%
\index{operator>@\tcode{operator>}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template<@\addedD{class... TTypes, class... UTypes}@>
  @\addedConcepts{requires LessThanComparable<UTypes, TTypes>...}@
  bool operator>(const tuple<@\addedD{TTypes...}@>& t, const tuple<@\addedD{UTypes...}@>& u);
\end{itemdecl}
\begin{itemdescr}
\pnum\returns\ \tcode{u < t}.
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator<=@\tcode{operator<=}}%
\index{operator<=@\tcode{operator<=}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template<@\addedD{class... TTypes, class... UTypes}@>
  @\addedConcepts{requires LessThanComparable<UTypes, TTypes>...}@
  bool operator<=(const tuple<@\addedD{TTypes...}@>& t, const tuple<@\addedD{UTypes...}@>& u);
\end{itemdecl}
\begin{itemdescr}
\pnum\returns\ \tcode{!(u < t)}
\end{itemdescr}

\index{tuple@\tcode{tuple}!operator>=@\tcode{operator>=}}%
\index{operator>=@\tcode{operator>=}!tuple@\tcode{tuple}}%
\begin{itemdecl}
template<@\addedD{class... TTypes, class... UTypes}@>
  @\addedConcepts{requires LessThanComparable<TTypes, UTypes>...}@
  bool operator>=(const tuple<@\addedD{TTypes...}@>& t, const tuple<@\addedD{UTypes...}@>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{!(t < u)}
\end{itemdescr}

\pnum \enternote\ The above definitions for comparison operators 
do not require \tcode{t$_{\mathrm{tail}}$} 
(or \tcode{u$_{\mathrm{tail}}$}) to be constructed. It may not 
even be possible, as \tcode{t} and \tcode{u} are not required to be copy
constructible. Also, all comparison operators are short circuited;
they do not perform element accesses beyond what is required to determine the
result of the comparison. \exitnote\

\setcounter{section}{5}
\rSec1[function.objects]{Function objects}

\pnum
Function objects are objects with an \tcode{operator()} defined.
In the places where one would expect to pass a pointer to a function to an
algorithmic template (clause \ref{algorithms}), the interface is specified to accept an object with an
\tcode{operator()}
defined.
This not only makes algorithmic templates work with pointers to functions, but
also enables them to work with arbitrary function objects.

\pnum
\synopsis{Header \tcode{<functional>} synopsis}
\index{functional@\tcode{<functional>}}%

\begin{codeblock}
namespace std {
  // \ref{base}, base:
  template <class Arg, class Result> struct unary_function;
  template <class Arg1, class Arg2, class Result> struct binary_function;

  // \marktr{}\ref{func.ret} result_of:
  template <class@\removedD{ FunctionCallType}@> class result_of;   // \addedD{undefined}
  @\addedD{template <class F, class... Args> class result_of<F(ArgTypes...)>;}@

  // \marktr{}\ref{refwrap}, reference_wrapper:
  template <@\changedConcepts{class}{ObjectType}@ T> class reference_wrapper; 

  template <@\changedConcepts{class}{ObjectType}@ T> reference_wrapper<T> ref(T&);
  template <@\changedConcepts{class}{ObjectType}@ T> reference_wrapper<const T> cref(const T&);

  template <@\changedConcepts{class}{ObjectType}@ T> reference_wrapper<T> ref(reference_wrapper<T>);
  template <@\changedConcepts{class}{ObjectType}@ T> reference_wrapper<const T> cref(reference_wrapper<T>);

  // \ref{identity.operation}, identity operation:
  @\addedConcepts{template <IdentityOf T> struct identity;}@

  //    \ref{arithmetic.operations}, arithmetic operations:
  template <@\changedConcepts{class}{ReferentType}@ T> struct plus;
  template <@\changedConcepts{class}{ReferentType}@ T> struct minus;
  template <@\changedConcepts{class}{ReferentType}@ T> struct multiplies;
  template <@\changedConcepts{class}{ReferentType}@ T> struct divides;
  template <@\changedConcepts{class}{ReferentType}@ T> struct modulus;
  template <@\changedConcepts{class}{ReferentType}@ T> struct negate;

  // \ref{comparisons}, comparisons:
  template <@\changedConcepts{class}{ReferentType}@ T> struct equal_to;
  template <@\changedConcepts{class}{ReferentType}@ T> struct not_equal_to;
  template <@\changedConcepts{class}{ReferentType}@ T> struct greater;
  template <@\changedConcepts{class}{ReferentType}@ T> struct less;
  template <@\changedConcepts{class}{ReferentType}@ T> struct greater_equal;
  template <@\changedConcepts{class}{ReferentType}@ T> struct less_equal;

  // \ref{logical.operations}, logical operations:
  template <@\changedConcepts{class}{ReferentType}@ T> struct logical_and;
  template <@\changedConcepts{class}{ReferentType}@ T> struct logical_or;
  template <@\changedConcepts{class}{ReferentType}@ T> struct logical_not;

  // \ref{bitwise.operations}, bitwise operations:
  template <@\changedConcepts{class}{ReferentType}@ T> struct bit_and;
  template <@\changedConcepts{class}{ReferentType}@ T> struct bit_or;
  template <@\changedConcepts{class}{ReferentType}@ T> struct bit_xor;

  // \ref{negators}, negators:
  template <class Predicate> class unary_negate;
  template <class Predicate>
    unary_negate<Predicate>  not1(const Predicate&);
  template <class Predicate> class binary_negate;
  template <class Predicate>
    binary_negate<Predicate> not2(const Predicate&);

  // \ref{bind}, bind:
  template<class T> struct is_bind_expression;
  template<class T> struct is_placeholder;

  template<@\changedConcepts{class}{CopyConstructible}@ Fn, @\changedConcepts{class}{CopyConstructible}@... Types>
    @\unspec@ bind(Fn, @\addedD{Types...}@);
  template<@\changedConcepts{class}{Returnable}@ R, @\changedConcepts{class}{CopyConstructible}@ Fn, @\changedConcepts{class}{CopyConstructible}@... Types>
    @\unspec@ bind(Fn, @\addedD{Types...}@);

  namespace placeholders {
    // M is the implementation-defined number of placeholders
    extern @\unspec@ _1;
    extern @\unspec@ _2;
                .
                .
                .
    extern @\unspec@ _M;
  }  

  // \ref{depr.lib.binders}, binders (deprecated):
  template <class Fn> class binder1st;
  template <class Fn, class T>
    binder1st<Fn> bind1st(const Fn&, const T&);
  template <class Fn> class binder2nd;
  template <class Fn, class T>
    binder2nd<Fn> bind2nd(const Fn&, const T&);

  // \ref{function.pointer.adaptors}, adaptors:
  template <@\changedConcepts{class}{CopyConstructible}@ Arg, @\changedConcepts{class}{Returnable}@ Result> 
    class pointer_to_unary_function;
  template <@\changedConcepts{class}{CopyConstructible}@ Arg, @\changedConcepts{class}{Returnable}@ Result>
    pointer_to_unary_function<Arg,Result> ptr_fun(Result (*)(Arg));
  template <@\changedConcepts{class}{CopyConstructible}@ Arg1, @\changedConcepts{class}{CopyConstructible}@ Arg2, @\changedConcepts{class}{Returnable}@ Result>
    class pointer_to_binary_function;
  template <@\changedConcepts{class}{CopyConstructible}@ Arg1, @\changedConcepts{class}{CopyConstructible}@ Arg2, @\changedConcepts{class}{Returnable}@ Result>
    pointer_to_binary_function<Arg1,Arg2,Result>
      ptr_fun(Result (*)(Arg1,Arg2));

  // \ref{member.pointer.adaptors}, adaptors:
  template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> class mem_fun_t;
  template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{MoveConstructible}@ A> class mem_fun1_t;
  template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T>
      mem_fun_t<S,T> mem_fun(S (T::*f)());
  template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{MoveConstructible}@ A>
      mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));
  template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> class mem_fun_ref_t;
  template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> class mem_fun1_ref_t;
  template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T>
      mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)());
  template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A>
      mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));

  template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> class const_mem_fun_t;
  template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> class const_mem_fun1_t;
  template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T>
    const_mem_fun_t<S,T> mem_fun(S (T::*f)() const);
  template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A>
    const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);
  template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> class const_mem_fun_ref_t;
  template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> class const_mem_fun1_ref_t;
  template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T>
    const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const);
  template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A>
    const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);

  // \marktr{}\ref{func.memfn}, member function adaptors:
  template<@\changedConcepts{class}{Returnable}@ R, class T> @\textit{unspecified}@ mem_fn(R T::*);
  @\addedConcepts{template<Returnable R, class T, CopyConstructible... Args>}@
    @\addedConcepts{\textit{unspecified} mem_fn(R (T::* pm)(Args...));}@
  @\addedConcepts{template<Returnable R, class T, CopyConstructible... Args>}@
    @\addedConcepts{\textit{unspecified} mem_fn(R (T::* pm)(Args...) const);}@
  @\addedConcepts{template<Returnable R, class T, CopyConstructible... Args>}@
    @\addedConcepts{\textit{unspecified} mem_fn(R (T::* pm)(Args...) volatile);}@
  @\addedConcepts{template<Returnable R, class T, CopyConstructible... Args>}@
    @\addedConcepts{\textit{unspecified} mem_fn(R (T::* pm)(Args...) const volatile);}@

  // \marktr{}\ref{func.wrap} polymorphic function wrappers:
  class bad_function_call;

  template<@\changedConcepts{class}{FunctionType}\removedD{ Function}@> class function; // \addedD{undefined}
  @\addedD{template<\changedConcepts{class}{Returnable} R, \changedConcepts{class}{CopyConstructible}... ArgTypes>}@
    class function<R(ArgTypes...)>;

  template<@\addedD{\changedConcepts{class}{Returnable} R, \changedConcepts{class}{CopyConstructible}... ArgTypes}@>
    void swap(function<@\addedD{R(ArgTypes...)}@>&, function<@\addedD{R(ArgTypes...)}@>&);

  template<@\addedD{\changedConcepts{class}{Returnable} R, \changedConcepts{class}{CopyConstructible}... ArgTypes}@>
    bool operator==(const function<@\addedD{R(ArgTypes...)}@>&, @\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@);
  template<@\addedD{\changedConcepts{class}{Returnable} R, \changedConcepts{class}{CopyConstructible}... ArgTypes}@>
    bool operator==(@\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@, const function<@\addedD{R(ArgTypes...)}@>&);
  template<@\addedD{\changedConcepts{class}{Returnable} R, \changedConcepts{class}{CopyConstructible}... ArgTypes}@>
    bool operator!=(const function<@\addedD{R(ArgTypes...)}@>&, @\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@);
  template<@\addedD{\changedConcepts{class}{Returnable} R, \changedConcepts{class}{CopyConstructible}... ArgTypes}@>
    bool operator!=(@\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@, const function<@\addedD{R(ArgTypes...)}@>&);

  // \marktr{}\ref{unord.hash}, hash function base template:
  template <@\changedConcepts{class}{ReferentType}@ T> struct hash;

  // Hash function specializations
  template <> struct hash<bool>;
  template <> struct hash<char>;
  template <> struct hash<signed char>;
  template <> struct hash<unsigned char>;
  @\addedD{template <> struct hash<char16_t>;}@
  @\addedD{template <> struct hash<char32_t>;}@
  template <> struct hash<wchar_t>;
  template <> struct hash<short>;
  template <> struct hash<unsigned short>;
  template <> struct hash<int>;
  template <> struct hash<unsigned int>;
  template <> struct hash<long>;
  @\addedC{template <> struct hash<long long>;}@
  template <> struct hash<unsigned long>;
  @\addedC{template <> struct hash<unsigned long long>;}@

  template <> struct hash<float>;
  template <> struct hash<double>;
  template <> struct hash<long double>;

  template<@\changedConcepts{class}{PointeeType}@ T> struct hash<T*>;

  template <> struct hash<std::string>;
  @\addedD{template <> struct hash<std::u16string>;}@
  @\addedD{template <> struct hash<std::u32string>;}@
  template <> struct hash<std::wstring>;
}
\end{codeblock}

\setcounter{subsection}{4}
\rSec2[refwrap]{\marktr{}Class template \tcode{reference_wrapper}}

\index{reference_wrapper@\tcode{reference_wrapper}}
\index{function objects!reference_wrapper@\tcode{reference_wrapper}}
\index{unary function}
\index{binary function}
\begin{codeblock}
template <@\changedConcepts{class}{ObjectType}@ T> class reference_wrapper 
  : public unary_function<T1, R>          // see below
  : public binary_function<T1, T2, R>     // see below
{ 
public :
  // types
  typedef T type;
  typedef @\textit{see below}@ result_type; // Not always defined

  // construct/copy/destroy
  explicit reference_wrapper(T&);
  reference_wrapper(const reference_wrapper<T>& x);

  // assignment
  reference_wrapper& operator=(const reference_wrapper<T>& x);

  // access
  operator T& () const;
  T& get() const;

  // tcode{}
  template <@\changedD{class T1, class T2, ..., class TN}{class... ArgTypes}@>
    @\addedConcepts{requires Callable<T, ArgTypes\&\&...>}@
    @\changedConcepts{typename result_of<T(ArgTypes...)>::type}{Callable<T, ArgTypes\&\&...>::result_type}@
  operator() (ArgTypes&&...) const;
}; 
\end{codeblock}

\setcounter{subsubsection}{3}
\rSec3[refwrap.invoke]{\tcode{reference_wrapper} invocation}
\index{reference_wrapper@\tcode{reference_wrapper}!operator()@\tcode{operator()}}%
\index{operator()@\tcode{operator()}!reference_wrapper@\tcode{reference_wrapper}}%
\begin{itemdecl}
template <@\changedD{class T1, class T2, ..., class TN}{class... ArgTypes}@>
  @\addedConcepts{requires Callable<T, ArgTypes\&\&...>}@
  @\changedConcepts{typename result_of<T(ArgTypes...)>::type}{Callable<T, ArgTypes\&\&...>::result_type}@
    operator()(@\changedD{T1\& a1, T2\& a1, ..., TN\& aN}{ArgTypes\&\&... args}@) const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{\textit{INVOKE}(get(), \changedD{a1, a2, ..., aN}{std::forward<ArgTypes>(args)...})}.
(\ref{func.require})

\pnum
\removedConcepts{\mbox{\note} \mbox{\tcode{operator()}} is described
  for exposition only. 
Implementations are not required to provide an actual 
\mbox{\tcode{reference_wrapper::operator()}}.  Implementations are
permitted to support \mbox{\tcode{reference_wrapper}} function invocation
through multiple overloaded operators or through other means.}

\end{itemdescr}

\rSec3[refwrap.helpers]{reference_wrapper helper functions}
\index{reference_wrapper@\tcode{reference_wrapper}!ref@\tcode{ref}}%
\index{ref@\tcode{ref}!reference_wrapper@\tcode{reference_wrapper}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T> reference_wrapper<T> ref(T& t); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{reference_wrapper<T>(t)}

\pnum\throws\ nothing. 
\end{itemdescr}

\index{reference_wrapper@\tcode{reference_wrapper}!ref@\tcode{ref}}%
\index{ref@\tcode{ref}!reference_wrapper@\tcode{reference_wrapper}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T> reference_wrapper<T> ref(reference_wrapper<T>t);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{ref(t.get())}

\pnum\throws\ nothing. 
\end{itemdescr}

\index{reference_wrapper@\tcode{reference_wrapper}!cref@\tcode{cref}}%
\index{cref@\tcode{cref}!reference_wrapper@\tcode{reference_wrapper}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T> reference_wrapper<const T> cref(const T& t); 
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{reference_wrapper <const T>(t)}

\pnum\throws\  nothing. 
\end{itemdescr}

\index{reference_wrapper@\tcode{reference_wrapper}!cref@\tcode{cref}}%
\index{cref@\tcode{cref}!reference_wrapper@\tcode{reference_wrapper}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ObjectType}@ T> reference_wrapper<const T> cref(reference_wrapper<T> t);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{cref(t.get());}

\pnum\throws\  nothing. 
\end{itemdescr}

\editorial{Add the following new section [identity.operation]}
\rSec2[identity.operation]{Identity operation}
\index{identity@\tcode{identity}}%
\begin{itemdecl}
template <@\changedConcepts{class}{IdentityOf}@ T> struct identity { 
  typedef T type;

  @\addedConcepts{requires ReferentType<T>}@
    const T& operator()(const T& x) const;
};
\end{itemdecl}

\begin{itemdecl}
@\addedConcepts{requires ReferentType<T>}@
  const T& operator()(const T& x) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\
\tcode{x}
\end{itemdescr}

\rSec2[arithmetic.operations]{Arithmetic operations}

\pnum
The library provides basic function object classes for all of the arithmetic
operators in the language (\ref{expr.mul}, \ref{expr.add}).

\index{plus@\tcode{plus}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct plus : binary_function<T,T,T> {
  @\addedConcepts{requires HasPlus<T, T> \&\& Convertible<T::result_type, T>}@
    T operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{\farg{x}\ + \farg{y}}.
\end{itemdescr}

\index{minus@\tcode{minus}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct minus : binary_function<T,T,T> {
  @\addedConcepts{requires HasMinus<T> \&\& Convertible<T::result_type, T>}@
    T operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{\farg{x}\ - \farg{y}}.
\end{itemdescr}

\index{multiplies@\tcode{multiplies}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct multiplies : binary_function<T,T,T> {
  @\addedConcepts{requires HasMultiply<T> \&\& Convertible<T::result_type, T>}@
    T operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{\farg{x}\ * \farg{y}}.
\end{itemdescr}

\index{divides@\tcode{divides}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct divides : binary_function<T,T,T> {
  @\addedConcepts{requires HasDivide<T> \&\& Convertible<T::result_type, T>}@
  T operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()}
returns
\tcode{\farg{x}\ / \farg{y}}.
\end{itemdescr}

\index{modulus@\tcode{modulus}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct modulus : binary_function<T,T,T> {
  @\addedConcepts{requires HasModulus<T> \&\& Convertible<T::result_type, T>}@
    T operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ \% \farg{y}}.
\end{itemdescr}

\index{negate@\tcode{negate}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct negate : unary_function<T,T> {
  @\addedConcepts{requires HasNegate<T> \&\& Convertible<T::result_type, T>}@
    T operator()(const T& @\farg{x}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{-\farg{x}}.
\end{itemdescr}

\rSec2[comparisons]{Comparisons}

\pnum
The library provides basic function object classes for all of the comparison
operators in the language (\ref{expr.rel}, \ref{expr.eq}).

\index{equal_to@\tcode{equal_to}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct equal_to : binary_function<T,T,bool> {
  @\addedConcepts{requires HasEqualTo<T, T>}@
    bool operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ == \farg{y}}.
\end{itemdescr}

\index{not_equal_to@\tcode{not_equal_to}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct not_equal_to : binary_function<T,T,bool> {
  @\addedConcepts{requires HasNotEqualTo<T, T>}@
    bool operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ != \farg{y}}.
\end{itemdescr}

\index{greater@\tcode{greater}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct greater : binary_function<T,T,bool> {
  @\addedConcepts{requires HasGreater<T, T>}@
    bool operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ > \farg{y}}.
\end{itemdescr}

\index{less@\tcode{less}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct less : binary_function<T,T,bool> {
  @\addedConcepts{requires HasLess<T, T>}@
    bool operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ < \farg{y}}.
\end{itemdescr}

\index{greater_equal@\tcode{greater_equal}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct greater_equal : binary_function<T,T,bool> {
  @\addedConcepts{requires HasGreaterEqual<T, T>}@
    bool operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ >= \farg{y}}.
\end{itemdescr}

\index{less_equal@\tcode{less_equal}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct less_equal : binary_function<T,T,bool> {
  @\addedConcepts{requires HasLessEqual<T, T>}@
    bool operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ <= \farg{y}}.
\end{itemdescr}

\pnum
For templates \tcode{greater}, \tcode{less}, \tcode{greater_equal}, and
\tcode{less_equal}, the specializations for any pointer type yield a total order,
even if the built-in operators \tcode{<}, \tcode{>}, \tcode{<=}, \tcode{>=}
do not.

\rSec2[logical.operations]{Logical operations}

\pnum
The library provides basic function object classes for all of the logical
operators in the language (\ref{expr.log.and}, \ref{expr.log.or}, \ref{expr.unary.op}).

\index{logical_and@\tcode{logical_and}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct logical_and : binary_function<T,T,bool> {
  @\addedConcepts{requires HasLogicalAnd<T, T>}@
    bool operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ \&\& \farg{y}}.
\end{itemdescr}

\index{logical_or@\tcode{logical_or}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct logical_or : binary_function<T,T,bool> {
  @\addedConcepts{requires HasLogicalOr<T, T>}@
    bool operator()(const T& @\farg{x}@, const T& @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ || \farg{y}}.
\end{itemdescr}

\index{logical_not@\tcode{logical_not}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct logical_not : unary_function<T,bool> {
  @\addedConcepts{requires HasLogicalNot<T>}@
    bool operator()(const T& @\farg{x}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{!\farg{x}}.
\end{itemdescr}

\rSec2[bitwise.operations]{Bitwise operations}

\pnum
The library provides basic function object classes for all of the bitwise
operators in the language (\ref{expr.bit.and}, \ref{expr.or}, \ref{expr.xor}).

\index{bit_and@\tcode{bit_and}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct bit_and : binary_function<T,T,T> {
  @\addedConcepts{requires HasBitAnd<T, T> \&\& Convertible<T::result_type, T>}@
    T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ \& \farg{y}}.
\end{itemdescr}

\index{bit_or@\tcode{bit_or}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct bit_or : binary_function<T,T,T> {
  @\addedConcepts{requires HasBitOr<T, T> \&\& Convertible<T::result_type, T>}@
    T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ | \farg{y}}.
\end{itemdescr}

\index{bit_xor@\tcode{bit_xor}}%
\begin{itemdecl}
template <@\changedConcepts{class}{ReferentType}@ T> struct bit_xor : binary_function<T,T,T> {
  @\addedConcepts{requires HasBitXor<T, T> \&\& Convertible<T::result_type, T>}@
    T operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{x}\ \^{} \farg{y}}.
\end{itemdescr}

\setcounter{subsection}{9}
\rSec2[bind]{\marktr{}Template function \tcode{bind}}

\pnum
The template function \tcode{bind} returns an object that binds a
function object passed as an argument to additional arguments.

\pnum
\removedConcepts{Binders \mbox{\tcode{bind1st}} and \mbox{\tcode{bind2nd}} take a function object
\mbox{\tcode{fn}} of two arguments and a value \mbox{\tcode{x}} and return
a function object of one argument constructed out of \mbox{\tcode{\changedB{f}{fn}}}
with the first or second argument correspondingly bound to \mbox{\tcode{x}}.}

\rSec3[func.bind]{\marktr{}Function object binders}

\index{function objects!binders|(}%

\setcounter{paragraph}{2}
\rSec4[func.bind.bind]{Function template \tcode{bind}}
\index{bind@\tcode{bind}|(}

\begin{itemdecl}
template<@\changedConcepts{class}{CopyConstructible}@ F, @\changedD{class T1, class T2, ...., class TN}{\changedConcepts{class}{CopyConstructible}... BoundArgs}@>
  @\unspec@ bind(F f, @\changedD{T1 t1, T2 t2, ..., TN tN}{BoundArgs... bound_args}@);
\end{itemdecl}

\begin{itemdescr}
\pnum\requires\ \removedConcepts{\mbox{\tcode{F}} and \mbox{\addedD{each}} \mbox{\tcode{Ti}}
\mbox{\addedD{in \mbox{\tcode{BoundArgs}}}} shall be
CopyConstructible.} \tcode{\textit{INVOKE} (f, w1, w2, ...,
wN)}~(\ref{func.require}) shall be a valid expression for some
values \textit{w1, w2, ..., wN}\addedD{, where
\mbox{\tcode{N == sizeof...(bound_args)}}}.

\pnum\returns\ A forwarding call wrapper \tcode{g} with a weak result
type~(\ref{func.require}). The effect of \tcode{g(u1, u2, ..., uM)} shall
be \tcode{\textit{INVOKE}(f, v1, v2, ..., vN, \changedConcepts{result_of}{Callable}<F \textit{cv}\changedConcepts{ (}{,}V1, V2, ..., VN\removedConcepts{)}>::\addedConcepts{result_}type)}, where \tcode{\textit{cv}} represents the
\textit{cv}-qualifiers of \tcode{g} and the values and types of the bound
arguments \tcode{v1, v2, ..., vN} are determined as specified below. 
\end{itemdescr}       

\begin{itemdecl}
template<@\changedConcepts{class}{Returnable}@ R, @\changedConcepts{class}{CopyConstructible}@ F, @\changedD{class T1, class T2, ...., class TN}{\changedConcepts{class}{CopyConstructible}... BoundArgs}@> 
  @\unspec@ bind(F f, @\changedD{T1 t1, T2 t2, ..., TN tN}{BoundArgs... bound_args}@);
\end{itemdecl}

\begin{itemdescr}
\pnum\requires\ \removedConcepts{\mbox{\tcode{F}} and \mbox{\addedD{each}} \mbox{\tcode{Ti}}
\mbox{\addedD{in \mbox{\tcode{BoundArgs}}}} shall be CopyConstructible.}
\tcode{\textit{INVOKE}(f, w1, w2, ..., wN)} shall be  a valid
expression for some
values \textit{w1, w2, ..., wN}\addedD{, where
\mbox{\tcode{N == sizeof...(bound_args)}}}.

\pnum\returns\ A forwarding call wrapper \tcode{g} with a nested  type
\tcode{result_type} defined as a synonym for \tcode{R}.  The effect of
\tcode{g(u1, u2, ..., uM)} shall be \tcode{\textit{INVOKE}(f, v1, v2,
..., vN, R)}, where the values and types of the bound
arguments \tcode{v1, v2, ..., vN} are determined as specified below. 
\end{itemdescr}

\rSec2[function.pointer.adaptors]{Adaptors for pointers to functions}

\pnum
To allow pointers to (unary and binary) functions to work with function adaptors
the library provides:

\index{pointer_to_unary_function@\tcode{pointer_to_unary_function}}%
\begin{itemdecl}
template <@\changedConcepts{class}{CopyConstructible}@ Arg, @\changedConcepts{class}{Returnable}@ Result>
class pointer_to_unary_function : public unary_function<Arg, Result> {
public:
  explicit pointer_to_unary_function(Result (*@\farg{f}@)(Arg));
  Result operator()(Arg @\farg{x}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{f}(\farg{x})}.
\end{itemdescr}

\index{ptr_fun@\tcode{ptr_fun}}%
\begin{itemdecl}
template <@\changedConcepts{class}{CopyConstructible}@ Arg, @\changedConcepts{class}{Returnable}@ Result>
  pointer_to_unary_function<Arg, Result> ptr_fun(Result (*@\farg{f}@)(Arg));
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{pointer_to_unary_function<Arg, Result>(\farg{f})}.
\end{itemdescr}

\index{pointer_to_binary_function@\tcode{pointer_to_binary_function}}%
\begin{itemdecl}
template <@\changedConcepts{class}{CopyConstructible}@ Arg1, @\changedConcepts{class}{CopyConstructible}@ Arg2, @\changedConcepts{class}{Returnable}@ Result>
class pointer_to_binary_function :
  public binary_function<Arg1,Arg2,Result> {
public:
  explicit pointer_to_binary_function(Result (*@\farg{f}@)(Arg1, Arg2));
  Result operator()(Arg1 @\farg{x}@, Arg2 @\farg{y}@) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} returns \tcode{\farg{f}(\farg{x},\farg{y})}.
\end{itemdescr}

\index{ptr_fun@\tcode{ptr_fun}}%
\begin{itemdecl}
template <@\changedConcepts{class}{CopyConstructible}@ Arg1, @\changedConcepts{class}{CopyConstructible}@ Arg2, @\changedConcepts{class}{Returnable}@ Result>
  pointer_to_binary_function<Arg1,Arg2,Result>
    ptr_fun(Result (*@\farg{f}@)(Arg1, Arg2));
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{pointer_to_binary_function<Arg1,Arg2,Result>(\farg{f})}.

\pnum
\enterexample\ 
\begin{codeblock}
int compare(const char*, const char*);
replace_if(v.begin(), v.end(),
    not1(bind2nd(ptr_fun(compare), "abc")), "def");
\end{codeblock}

replaces each \tcode{abc} with \tcode{def} in sequence \tcode{v}.
\exitexample\ 
\end{itemdescr}

\rSec2[member.pointer.adaptors]{Adaptors for pointers to members}

\pnum
The purpose of the following is to provide the same facilities for pointer to
members as those provided for pointers to functions
in~\ref{function.pointer.adaptors}.

\index{mem_fun_t@\tcode{mem_fun_t}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> class mem_fun_t
        : public unary_function<T*, S> {
public:
  explicit mem_fun_t(S (T::*p)());
  S operator()(T* p) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun_t} calls the member function it is initialized with given a pointer
argument.
\end{itemdescr}

\index{mem_fun1_t@\tcode{mem_fun1_t}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> class mem_fun1_t
      : public binary_function<T*, A, S> {
public:
  explicit mem_fun1_t(S (T::*p)(A));
  S operator()(T* p, A x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun1_t} calls the member function it is initialized with given
a pointer argument and an additional argument of the appropriate type.
\end{itemdescr}

\index{mem_fun@\tcode{mem_fun}}%
\begin{itemdecl}
template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> mem_fun_t<S,T>
   mem_fun(S (T::*f)());
template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> mem_fun1_t<S,T,A>
   mem_fun(S (T::*f)(A));
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun(\&X::f)} returns an object through which \tcode{X::f} can be
called given a pointer to an \tcode{X} followed by the argument required for
\tcode{f} (if any).
\end{itemdescr}

\index{mem_fun_ref_t@\tcode{mem_fun_ref_t}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> class mem_fun_ref_t
      : public unary_function<T, S> {
public:
  explicit mem_fun_ref_t(S (T::*p)());
  S operator()(T& p) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun_ref_t} calls the member function it is initialized with given
a reference argument.
\end{itemdescr}

\index{mem_fun1_ref_t@\tcode{mem_fun1_ref_t}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> class mem_fun1_ref_t
      : public binary_function<T, A, S> {
public:
  explicit mem_fun1_ref_t(S (T::*p)(A));
  S operator()(T& p, A x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun1_ref_t} calls the member function it is initialized with
given a reference argument and an additional argument of the appropriate type.
\end{itemdescr}

\index{mem_fun_ref@\tcode{mem_fun_ref}}%
\begin{itemdecl}
template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> mem_fun_ref_t<S,T>
   mem_fun_ref(S (T::*f)());
template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> mem_fun1_ref_t<S,T,A>
   mem_fun_ref(S (T::*f)(A));
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun_ref(\&X::f)} returns an object through which \tcode{X::f}
can be called given a reference to an \tcode{X} followed by the argument
required for \tcode{f} (if any).
\end{itemdescr}

\index{const_mem_fun_t@\tcode{const_mem_fun_t}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> class const_mem_fun_t
      : public unary_function<const T*, S> {
public:
  explicit const_mem_fun_t(S (T::*p)() const);
  S operator()(const T* p) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{const_mem_fun_t} calls the member function it is initialized with
given a pointer argument.
\end{itemdescr}

\index{const_mem_fun1_t@\tcode{const_mem_fun1_t}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> class const_mem_fun1_t
      : public binary_function<const T*, A, S> {
public:
  explicit const_mem_fun1_t(S (T::*p)(A) const);
  S operator()(const T* p, A x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{const_mem_fun1_t} calls the member function it is initialized with
given a pointer argument and an additional argument of the appropriate type.
\end{itemdescr}

\index{mem_fun@\tcode{mem_fun}}%
\begin{itemdecl}
template<c@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> const_mem_fun_t<S,T>
   mem_fun(S (T::*f)() const);
template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> const_mem_fun1_t<S,T,A>
   mem_fun(S (T::*f)(A) const);
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun(\&X::f)} returns an object through which \tcode{X::f} can be
called given a pointer to an \tcode{X} followed by the argument required for
\tcode{f} (if any).
\end{itemdescr}

\index{const_mem_fun_ref_t@\tcode{const_mem_fun_ref_t}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> class const_mem_fun_ref_t
      : public unary_function<T, S> {
public:
  explicit const_mem_fun_ref_t(S (T::*p)() const);
  S operator()(const T& p) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{const_mem_fun_ref_t} calls the member function it is initialized with
given a reference argument.
\end{itemdescr}

\index{const_mem_fun1_ref_t@\tcode{const_mem_fun1_ref_t}}%
\begin{itemdecl}
template <@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> class const_mem_fun1_ref_t
      : public binary_function<T, A, S> {
public:
  explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
  S operator()(const T& p, A x) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{const_mem_fun1_ref_t} calls the member function it is initialized
with given a reference argument and an additional argument of the appropriate
type.
\end{itemdescr}

\index{mem_fun_ref@\tcode{mem_fun_ref}}%
\begin{itemdecl}
template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T> const_mem_fun_ref_t<S,T>
   mem_fun_ref(S (T::*f)() const);
template<@\changedConcepts{class}{Returnable}@ S, @\changedConcepts{class}{ClassType}@ T, @\changedConcepts{class}{CopyConstructible}@ A> const_mem_fun1_ref_t<S,T,A>
    mem_fun_ref(S (T::*f)(A) const);
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{mem_fun_ref(\&X::f)} returns an object through which \tcode{X::f}
can be called given a reference to an \tcode{X} followed by the argument
required for \tcode{f} (if any).
\end{itemdescr}

\rSec2[func.memfn]{\marktr{}Function template \tcode{mem_fn}}
\index{function objects!mem_fn@\tcode{mem_fn}|(}

\index{mem_fn@\tcode{mem_fn}}%
\begin{itemdecl}
template<@\changedConcepts{class}{Returnable}@ R, class T> @\textit{unspecified}@ mem_fn(R T::* pm); 
@\addedConcepts{template<Returnable R, class T, CopyConstructible... Args>}@
  @\addedConcepts{\textit{unspecified} mem_fn(R (T::* pm)(Args...));}@
@\addedConcepts{template<Returnable R, class T, CopyConstructible... Args>}@
  @\addedConcepts{\textit{unspecified} mem_fn(R (T::* pm)(Args...) const);}@
@\addedConcepts{template<Returnable R, class T, CopyConstructible... Args>}@
  @\addedConcepts{\textit{unspecified} mem_fn(R (T::* pm)(Args...) volatile);}@
@\addedConcepts{template<Returnable R, class T, CopyConstructible... Args>}@
  @\addedConcepts{\textit{unspecified} mem_fn(R (T::* pm)(Args...) const volatile);}@
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ A simple call wrapper~([\ref{func.def}]) \tcode{fn}
such that the expression \tcode{fn(t, a2, ..., aN)} is equivalent
to \tcode{\textit{INVOKE}(pm, t, a2, ..., aN)}~([\ref{func.require}]).
\tcode{fn} shall have a nested type \tcode{result_type} that is a synonym
for the return type of \tcode{pm} when \tcode{pm} is a pointer to
member function.

\pnum\index{unary function}%
The simple call wrapper shall be derived
from \tcode{std::unary_function<\textit{cv} T*, \textit{Ret}>} when \tcode{pm} is
a pointer to member function with cv-qualifier \textit{cv} and taking no
arguments, where \textit{Ret} is \tcode{pm}'s return type.

\pnum\index{binary function}%
The simple call wrapper shall be derived from
\tcode{std::binary_function<\textit{cv} T*, T1, \textit{Ret}>} when \tcode{pm} is
a pointer to member function with cv-qualifier \textit{cv} and taking
one argument of type \tcode{T1}, where \textit{Ret} is \tcode{pm}'s return type.

\pnum\throws\ nothing.

\pnum\removedConcepts{\mbox{\notes} Implementations may implement \mbox{\tcode{mem_fn}} as a set of
overloaded function templates.}
\end{itemdescr}
\index{function objects!mem_fn@\tcode{mem_fn}|)}

\rSec2[func.wrap]{\marktr{}Polymorphic function wrappers}
\index{function objects!wrapper|(}%

\setcounter{subsubsection}{1}
\rSec3[func.wrap.func]{Class template \tcode{function}}
\index{function@\tcode{function}}

\begin{codeblock}
namespace std {
  template<@\changedConcepts{class}{FunctionType}\removedD{ Function}@> class function; // \addedD{undefined}

  @\addedD{template<\changedConcepts{class}{Returnable} R, \changedConcepts{class}{CopyConstructible}... ArgTypes>}@
  class function@\addedD{<R(ArgTypes...)>}@ 
    : public unary_function<T1, R>      // iff \addedD{\mbox{\tcode{sizeof...(ArgTypes) == 1}} and \mbox{\tcode{ArgTypes}} contains \mbox{\tcode{T1}}}
    : public binary_function<T1, T2, R> // iff \addedD{\mbox{\tcode{sizeof...(ArgTypes) == 2}} and \mbox{\tcode{ArgTypes}} contains \mbox{\tcode{T1}} and \mbox{\tcode{T2}}}
  {
  public:
    typedef R result_type;

    // \ref{func.wrap.func.con}, construct/copy/destroy:
    explicit function();
    function(@\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@);
    function(const function&);
    @\addedD{function(function\&\&);}@
    template<class F> 
      @\addedConcepts{requires CopyConstructible<F> \&\& Callable<F, ArgTypes...>}@
            @\addedConcepts{\&\& Convertible<Callable<F, ArgTypes...>::result_type, R>}@
      function(F);
    template<class F> 
      @\addedConcepts{requires CopyConstructible<F> \&\& Callable<F, ArgTypes...>}@ 
            @\addedConcepts{\&\& Convertible<Callable<F, ArgTypes...>::result_type, R>}@
      function(F&&);
    template<@\changedConcepts{class}{Allocator}@ A> 
      function(allocator_arg_t, const A&);
    template<@\changedConcepts{class}{Allocator}@ A> function(allocator_arg_t, const A&,
      @\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@);
    template<@\changedConcepts{class}{Allocator}@ A> function(allocator_arg_t, const A&,
      const function&);
    template<@\changedConcepts{class}{Allocator}@ A> function(allocator_arg_t, const A&,
      function&&);
    template<class F, @\changedConcepts{class}{Allocator}@ A> function(allocator_arg_t, const A&, F);
    template<class F, @\changedConcepts{class}{Allocator}@ A> function(allocator_arg_t, const A&, F&&);

    function& operator=(const function&);
    @\addedD{function\& operator=(function\&\&);}@
    function& operator=(@\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@);
    template<class F> 
      @\addedConcepts{requires CopyConstructible<F> \&\& Callable<F, ArgTypes..>}@ 
            @\addedConcepts{\&\& Convertible<Callable<F, ArgTypes...>::result_type}@
      function& operator=(F);
    template<class F> 
      @\addedConcepts{requires CopyConstructible<F> \&\& Callable<F, ArgTypes...>}@ 
            @\addedConcepts{\&\& Convertible<Callable<F, ArgTypes...>::result_type, R>}@
      function& operator=(F&&);
    template<class F> 
      @\addedConcepts{requires Callable<F, ArgTypes...> }@ 
            @\addedConcepts{\&\& Convertible<Callable<F, ArgTypes...>::result_type, R>}@
      function& operator=(reference_wrapper<F>);

    ~function();

    // \ref{func.wrap.func.mod}, function modifiers:
    void swap(function&);
    template<class F, @\changedConcepts{class}{Allocator}@ A> 
      @\addedConcepts{requires Callable<F, ArgTypes...> }@ 
            @\addedConcepts{\&\& Convertible<Callable<F, ArgTypes...>::result_type, R>}@
      void assign(F, const A&);

    // \ref{func.wrap.func.cap}, function capacity:
    explicit operator bool() const;

    // deleted overloads close possible hole in the type system
    template<class R2, class... ArgTypes2>
        bool operator==(const function<R2(ArgTypes2...)>&) = delete;
    template<class R2, class... ArgTypes2>
        bool operator!=(const function<R2(ArgTypes2...)>&) = delete;

    // \ref{func.wrap.func.inv}, function invocation:
    R operator()(@\changedD{T1, T2, ..., TN}{ArgTypes...}@) const;

    // \ref{func.wrap.func.targ}, function target access:
    const std::type_info& target_type() const;
    template <typename T> 
      @\addedConcepts{requires Callable<T, ArgTypes...> \&\& Convertible<Callable<T, ArgTypes...>::result_type, R>}@
      T* target();
    template <typename T> 
      @\addedConcepts{requires Callable<T, ArgTypes...> \&\& Convertible<Callable<T, ArgTypes...>::result_type, R>}@
      const T* target() const;

  private:
    // \ref{func.wrap.func.undef}, undefined operators:
    template<@\addedD{class R2, class... ArgTypes2}@> bool operator==(const function<@\addedD{R2(ArgTypes2...)}@>&);
    template<@\addedD{class R2, class... ArgTypes2}@> bool operator!=(const function<@\addedD{R2(ArgTypes2...)}@>&);
  };

@\addedConcepts{template <class R, class... Args>}@
  @\addedConcepts{concept_map UsesAllocator<function<R(Args...)>, Alloc> \{}@ 
    @\addedConcepts{typedef Alloc allocator_type;}@
  @\addedConcepts{\}}@

  // \ref{func.wrap.func.nullptr}, Null pointer comparisons:
  template <@\changedD{class Function}{\changedConcepts{class}{MoveConstructible} R, \changedConcepts{class}{MoveConstructible}... ArgTypes}@>
    bool operator==(const function<@\changedD{Function}{R(ArgTypes...)}@>&, @\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@);

  template <@\changedD{class Function}{\changedConcepts{class}{MoveConstructible} R, \changedConcepts{class}{MoveConstructible}... ArgTypes}@>
    bool operator==(@\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@, const function<@\changedD{Function}{R(ArgTypes...)}@>&);

  template <@\changedD{class Function}{\changedConcepts{class}{MoveConstructible} R, \changedConcepts{class}{MoveConstructible}... ArgTypes}@>
    bool operator!=(const function<@\changedD{Function}{R(ArgTypes...)}@>&, @\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@);

  template <@\changedD{class Function}{\changedConcepts{class}{MoveConstructible} R, \changedConcepts{class}{MoveConstructible}... ArgTypes}@>
    bool operator!=(@\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@, const function<@\changedD{Function}{R(ArgTypes...)}@>&);

  // \ref{func.wrap.func.alg}, specialized algorithms:
  template <@\changedD{class Function}{\changedConcepts{class}{MoveConstructible} R, \changedConcepts{class}{MoveConstructible}... ArgTypes}@>
    void swap(function<@\changedD{Function}{R(ArgTypes...)}@>&, function<@\changedD{Function}{R(ArgTypes...)}@>&);
} // namespace std
\end{codeblock}

\rSec4[func.wrap.func.con]{\tcode{function} construct/copy/destroy}
\index{function@\tcode{function}!function@\tcode{function}}
\setcounter{Paras}{7}
\begin{itemdecl}
template<class F> 
  @\addedConcepts{requires CopyConstructible<F> \&\& Callable<F, ArgTypes..> \&\&}@ 
           @\addedConcepts{Convertible<Callable<F, ArgTypes...>::result_type}@
  function(F f);
template<class F> 
  @\addedConcepts{requires CopyConstructible<F> \&\& Callable<F, ArgTypes..> \&\&}@ 
           @\addedConcepts{Convertible<Callable<F, ArgTypes...>::result_type}@
  function(F&& f);
\end{itemdecl}

\begin{itemdescr}
\pnum\removedConcepts{\mbox{\requires} \mbox{\tcode{f}} shall be callable for argument types
\mbox{\changedD{\mbox{\tcode{T1}}, \mbox{\tcode{T2}}, ..., \mbox{\tcode{T\textit{N}}}}
{\mbox{\tcode{ArgTypes}}}} and return type \mbox{\tcode{R}}.}

\pnum\postconditions\ \tcode{!*this} if any of the following hold:
\begin{itemize}
\item{\tcode{f} is a NULL function pointer.}
\item{\tcode{f} is a NULL member function pointer.}
\item{\tcode{F} is an instance of the \tcode{function} class template, and
  \tcode{!f}}
\end{itemize}

\pnum
Otherwise, \tcode{*this} targets a copy of \tcode{f}
\addedD{or \mbox{\tcode{std::move(f)}}} if \tcode{f} is
not a pointer to member function, and targets a copy
of \tcode{mem_fn(f)} if \tcode{f} is a pointer to member function.

\pnum\throws\ shall not throw exceptions when \tcode{f} is a function pointer 
or a \tcode{reference_wrapper<T>} for some \tcode{T}. Otherwise,
may throw \tcode{bad_alloc} or any exception thrown by \tcode{F}'s copy
\addedD{or move} constructor.
\end{itemdescr}

\setcounter{Paras}{18}
\index{function@\tcode{function}!operator=@\tcode{operator=}}%
\index{operator=@\tcode{operator=}!function@\tcode{function}}%
\begin{itemdecl}
template<class F> 
  @\addedConcepts{requires CopyConstructible<F> \&\& Callable<F, ArgTypes..>}@ 
        @\addedConcepts{\&\& Convertible<Callable<F, ArgTypes...>::result_type}@
  operator=(F f);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ \tcode{function(f).swap(*this);}

\pnum\returns\ \tcode{*this}
\end{itemdescr}

\index{function@\tcode{function}!operator=@\tcode{operator=}}%
\index{operator=@\tcode{operator=}!function@\tcode{function}}%
\begin{itemdecl}
template<class F> 
  @\addedConcepts{requires CopyConstructible<F> \&\& Callable<F, ArgTypes..>}@ 
        @\addedConcepts{\&\& Convertible<Callable<F, ArgTypes...>::result_type}@
  function& operator=(F&& f);
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedD{\mbox{\effects} Replaces the target of \mbox{\tcode{*this}}
with \mbox{\tcode{f}}, leaving \mbox{\tcode{f}} in a
valid but unspecified state. \mbox{\enternote} A valid implementation is
\mbox{\tcode{function(f).swap(*this)}}.}

\pnum
\addedD{\mbox{\returns} \mbox{\tcode{*this}}.}
\end{itemdescr}

\index{function@\tcode{function}!operator=@\tcode{operator=}}%
\index{operator=@\tcode{operator=}!function@\tcode{function}}%
\begin{itemdecl}
template<class F>
  @\addedConcepts{requires CopyConstructible<F> \&\& Callable<F, ArgTypes...>}@ 
        @\addedConcepts{\&\& Convertible<Callable<F, ArgTypes...>::result_type, R>}@
  function& operator=(reference_wrapper<F> f);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ \tcode{function(f).swap(*this);}

\pnum\returns\ \tcode{*this}

\pnum\throws\ nothing.
\end{itemdescr}

\setcounter{paragraph}{4}
\rSec4[func.wrap.func.targ]{function target access}

\index{function@\tcode{function}!target_type@\tcode{target_type}}%
\index{target_type@\tcode{target_type}!function@\tcode{function}}%
\begin{itemdecl}
const std::type_info& target_type() const;
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ If \tcode{*this} has a target of type \tcode{T}, 
  \tcode{typeid(T)}; otherwise, \tcode{typeid(void)}.

\pnum\throws\ nothing.
\end{itemdescr}

\index{function@\tcode{function}!target@\tcode{target}}%
\index{target@\tcode{target}!function@\tcode{function}}%
\begin{itemdecl}
template<typename T>
  @\addedConcepts{requires Callable<T, ArgTypes...> \&\& Convertible<Callable<T, ArgTypes...>::result_type, R>}@
  T* target(); 
template<typename T> 
  @\addedConcepts{requires Callable<T, ArgTypes...> \&\& Convertible<Callable<T, ArgTypes...>::result_type, R>}@
  const T* target() const; 
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{T}} is a function object type that is
Callable~(\mbox{\ref{func.wrap.func}}) for parameter types
\mbox{\tcode{ArgTypes}}
and return type \mbox{\tcode{R}}.}

\pnum\returns\ If \tcode{type() == typeid(T)}, a pointer to the
    stored function target; otherwise a null pointer.

\pnum\throws\ nothing.
\end{itemdescr}

\setcounter{paragraph}{6}
\rSec4[func.wrap.func.nullptr]{null pointer comparison operators}

\begin{itemdecl}
template <@\changedD{class Function}{\changedConcepts{class}{MoveConstructible} R, \changedConcepts{class}{MoveConstructible}... ArgTypes}@>
  bool operator==(const function<@\changedD{Function}{R(ArgTypes...)}@>& f, @\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@);

template <@\changedD{class Function}{\changedConcepts{class}{MoveConstructible} R, \changedConcepts{class}{MoveConstructible}... ArgTypes}@>
  bool operator==(@\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@, const function<@\changedD{Function}{R(ArgTypes...)}@>& f);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{!f}.

\pnum\throws\ nothing.
\end{itemdescr}

\begin{itemdecl}
template <@\changedD{class Function}{\changedConcepts{class}{MoveConstructible} R, \changedConcepts{class}{MoveConstructible}... ArgTypes}@>
  bool operator!=(const function<@\changedD{Function}{R(ArgTypes...)}@>& f, @\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@);

template <@\changedD{class Function}{\changedConcepts{class}{MoveConstructible} R, \changedConcepts{class}{MoveConstructible}... ArgTypes}@>
  bool operator!=(@\changedConcepts{\mbox{\unspecnull}}{nullptr_t}@, const function<@\changedD{Function}{R(ArgTypes...)}@>& f);
\end{itemdecl}

\begin{itemdescr}
\pnum\returns\ \tcode{ (bool) f}.

\pnum\throws\ nothing.
\end{itemdescr}

\rSec4[func.wrap.func.alg]{specialized algorithms}

\index{function@\tcode{function}!swap@\tcode{swap}}%
\index{swap@\tcode{swap}!function@\tcode{function}}%
\begin{itemdecl}
template<@\changedD{class Function}{\changedConcepts{class}{Returnable} R, \changedConcepts{class}{CopyConstructible}... ArgTypes}@>
  void swap(function<@\changedD{Function}{R(ArgTypes...)}@>& f1, function<@\changedD{Function}{R(ArgTypes...)}@>& f2);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\ \tcode{f1.swap(f2);}
\end{itemdescr}
\index{function objects!wrapper|)}%

\section*{Acknowledgments}
Daniel Kr\"ugler and Alisdair Meredith provided helpful comments and
corrections to this proposal. Pablo Halpern, Howard Hinnat, and Alan
Talbot all provided simplifications to the \tcode{pair} and
\tcode{tuple} constructors.

\bibliographystyle{plain}
\bibliography{local}

\end{document}
