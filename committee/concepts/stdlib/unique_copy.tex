\documentclass[american]{article}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{cite}
\usepackage{color}
\usepackage{soul}
\usepackage{babel}      % needed for iso dates
\usepackage[iso]{isodate} % use iso format for dates

\topmargin 0pt
\advance \topmargin by -\headheight
\advance \topmargin by -\headsep
     
\textheight 8.9in
     
\oddsidemargin 0pt
\evensidemargin \oddsidemargin
\marginparwidth 0.5in
     
\textwidth 6.5in

\definecolor{addclr}{rgb}{0,.6,.6}
\definecolor{remclr}{rgb}{1,0,0}
\newcommand{\added}[1]{\textcolor{addclr}{\ul{#1}}}
\newcommand{\removed}[1]{\textcolor{remclr}{\st{#1}}}
\newcommand{\changed}[2]{\removed{#1}\added{#2}}

\newcommand{\code}[1]{\lstinline[basicstyle=\sffamily,keywords={}]{#1}}
\newcommand{\func}[1]{\lstinline[basicstyle=\sffamily,keywords={}]{#1()}}
\newcommand{\concept}[1]{{\small \textsf{#1}}}
\newcommand{\keyword}[1]{\code{#1}}

% Colors we need
\definecolor{gray}{rgb}{.8,.8,.8}
\definecolor{white}{rgb}{1.0,1.0,1.0}

% \grammarbox should be used to illustrate the grammar of variadic
% templates
\newcommand{\grammarbox}[1]{\fcolorbox{black}{gray}{#1}}

\newcommand{\Cpp}{C\kern-0.05em\texttt{+\kern-0.03em+}}

% The default style for lstlisting, which highlights the concept
% keywords along with all of the other C++ keywords. We also make
% anything between ~'s white.
\lstdefinestyle{c++}{showstringspaces=false,columns=fullflexible,language=C++,
escapechar=@,xleftmargin=1pc,%
%basicstyle=\small\bfseries\itshape,%
%keywordstyle=\underbar,
basicstyle=\small\sffamily,
commentstyle=\mdseries,
moredelim=**[is][\color{white}]{~}{~},
literate={->}{{$\rightarrow\;$}}1 {<-}{{$\leftarrow\;$}}1 {=>}{{$\Rightarrow\;$}
}1,
literate={-}{{\text{-}}}1
}
\lstset{style=c++}

\lstdefinestyle{c++tilde}{showstringspaces=false,columns=fullflexible,language=C++,
escapechar=@,xleftmargin=1pc,%
%basicstyle=\small\bfseries\itshape,%
%keywordstyle=\underbar,
basicstyle=\small\sffamily,
commentstyle=\mdseries,
literate={->}{{$\rightarrow\;$}}1 {<-}{{$\leftarrow\;$}}1 {=>}{{$\Rightarrow\;$}
}1,
literate={-}{{\text{-}}}1
}

% Used in code samples to create a half a line space.
\newcommand{\halfline}{\vspace{-1.75ex}}

% Lame attempt at macro-compatibility with Pete's LaTeX
\newcommand{\tcode}[1]{\code{#1}}
\newcommand{\enternote}{[~\emph{Note}: }
\newcommand{\exitnote}{-- \emph{end note}~]}
\newcommand{\enterexample}{[~\emph{Example}: }
\newcommand{\exitexample}{-- \emph{end example}~]}
\newcommand{\techterm}[1]{\emph{#1}}

% Borrowed from Pete's LaTeX for the standard
\newcounter{Paras}
\makeatletter
\@addtoreset{Paras}{chapter}
\@addtoreset{Paras}{section}
\@addtoreset{Paras}{subsection}
\@addtoreset{Paras}{subsubsection}
\@addtoreset{Paras}{paragraph}
\@addtoreset{Paras}{subparagraph}
\def\pnum{\addtocounter{Paras}{1}\noindent\llap{{\footnotesize\arabic{Paras}}\hspace{\@totalleftmargin}\quad}}
\makeatother

% Also Pete's...
% Our usual abbreviation for 'listings'.  Comments are in 
% italics.  Arbitrary TeX commands can be used if they're 
% surrounded by @ signs.
\lstnewenvironment{codeblock}
{
 \lstset{escapechar=@}
}
{
}

% Permit use of '@' inside codeblock blocks (don't ask)
\makeatletter
\newcommand{\atsign}{@}
\makeatother

%%--------------------------------------------------
%% Bnf environments
\newlength{\BnfIndent}
\setlength{\BnfIndent}{\leftmargini}
\newlength{\BnfInc}
\setlength{\BnfInc}{\BnfIndent}
\newlength{\BnfRest}
\setlength{\BnfRest}{2\BnfIndent}
\newcommand{\BnfNontermshape}{\rmfamily\itshape\small}
\newcommand{\BnfTermshape}{\ttfamily\upshape\small}
\newcommand{\nonterminal}[1]{{\BnfNontermshape #1}}

\newenvironment{bnfbase}
 {
 \newcommand{\terminal}[1]{{\BnfTermshape ##1}}
 \newcommand{\descr}[1]{\normalfont{##1}}
 \newcommand{\bnfindentfirst}{\BnfIndent}
 \newcommand{\bnfindentinc}{\BnfInc}
 \newcommand{\bnfindentrest}{\BnfRest}
 \begin{minipage}{.9\hsize}
 \newcommand{\br}{\hfill\\}
 }
 {
 \end{minipage}
 }

\newenvironment{BnfTabBase}[1]
{
 \begin{bnfbase}
 #1
 \begin{indented}
 \begin{tabbing}
 \hspace*{\bnfindentfirst}\=\hspace{\bnfindentinc}\=\hspace{.6in}\=\hspace{.6in}\=\hspace{.6in}\=\hspace{.6in}\=\hspace{.6in}\=\hspace{.6in}\=\hspace{.6in}\=\hspace{.6in}\=\hspace{.6in}\=\hspace{.6in}\=\kill%
}
{
 \end{tabbing}
 \end{indented}
 \end{bnfbase}
}

\newenvironment{bnfkeywordtab}
{
 \begin{BnfTabBase}{\BnfTermshape}
}
{
 \end{BnfTabBase}
}

\newenvironment{bnftab}
{
 \begin{BnfTabBase}{\BnfNontermshape}
}
{
 \end{BnfTabBase}
}

\newenvironment{simplebnf}
{
 \begin{bnfbase}
 \BnfNontermshape
 \begin{indented}
}
{
 \end{indented}
 \end{bnfbase}
}

\newenvironment{bnf}
{
 \begin{bnfbase}
 \list{}
	{
	\setlength{\leftmargin}{\bnfindentrest}
	\setlength{\listparindent}{-\bnfindentinc}
	\setlength{\itemindent}{\listparindent}
	}
 \BnfNontermshape
 \item\relax
}
{
 \endlist
 \end{bnfbase}
}

% non-copied versions of bnf environments
\newenvironment{ncbnftab}
{
 \begin{bnftab}
}
{
 \end{bnftab}
}

\newenvironment{ncsimplebnf}
{
 \begin{simplebnf}
}
{
 \end{simplebnf}
}

\newenvironment{ncbnf}
{
 \begin{bnf}
}
{
 \end{bnf}
}

\begin{document}

\markboth{Doc. no: DRAFT}{Doc. no: DRAFT}
\pagestyle{myheadings}

\title{Simplifying \tcode{unique_copy}}
\author{}

\date{}
\maketitle
\vspace{-0.5in}
\par\noindent Author: Douglas Gregor, Indiana University
\par\noindent Author: David Abrahams, BoostPro Consulting
\par\noindent Document number: DRAFT 
\par\noindent Revises document number: N2742=08-0252
\par\noindent Date: \today
\par\noindent Project: Programming Language C++, Library Working Group
\par\noindent Reply-to: Douglas Gregor $<$\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}$>$

\section{Introduction}
This proposal simplifies \tcode{unique_copy}, by removing a mandated
optimization (in the form of iterator-category---dependent requirements)
in favor of a more direct specification, while retaining implementor's
freedom to optimize these cases.

\subsection{The Problem}
The \tcode{unique_copy} algorithm has by far the most complicated
concepts specification of any algorithm, to the point of being
embarrassing. The fundamental problem is
the following requirement in [alg.unique]p5:

\begin{quote}
  If neither InputIterator nor OutputIterator meets the requirements
  of forward iterator then the value type of InputIterator shall be
  CopyConstructible (34) and CopyAssignable (table 36). Otherwise
  CopyConstructible is not required.
\end{quote}

When these requirements were written, it was not known that \tcode{unique_copy}
could be implemented without either element copiability or an available lvalue
referenced by either the \tcode{InputIterator} or \tcode{OutputIterator}
arguments, thus the special CopyConstructible and CopyAssignable requirements.
We now know that \tcode{unique_copy} can be implemented for move-only value
types regardless of iterator category.

This formulation actually mandates three different implementations of
\tcode{unique_copy}: one for (input, output), one for (forward, output), and one
for (input, forward). With the predicate/\tcode{operator==} distinction, we end
up with six implementations hidden behind the two \tcode{unique_copy} signatures
shown in the specification. With concepts, however, we need to show each
signature because the requirements differ from one signature to another, leading
to the current concepts specification:

\begin{lstlisting}
template<InputIterator InIter, typename OutIter>
  requires OutputIterator<OutIter, InIter::reference>
        && OutputIterator<OutIter, const InIter::value_type&>
        && EqualityComparable<InIter::value_type> 
        && CopyAssignable<InIter::value_type>
        && CopyConstructible<InIter::value_type> 
        && !ForwardIterator<InIter> 
        && !ForwardIterator<OutIter>
  OutIter unique_copy(InIter first, InIter last, OutIter result);

template<ForwardIterator InIter, OutputIterator<auto, InIter::reference> OutIter>
  requires EqualityComparable<InIter::value_type>
  OutIter unique_copy(InIter first, InIter last, OutIter result);

template<InputIterator InIter, ForwardIterator OutIter>
  requires OutputIterator<OutIter, InIter::reference> 
        && HasEqualTo<OutIter::value_type, InIter::value_type>
        && !ForwardIterator<InIter>
  OutIter unique_copy(InIter first, InIter last, OutIter result);

template<InputIterator InIter, typename OutIter,
         EquivalenceRelation<auto, InIter::value_type> Pred>
  requires OutputIterator<OutIter, InIter::reference>
        && OutputIterator<OutIter, const InIter::value_type&>
        && CopyAssignable<InIter::value_type> 
        && CopyConstructible<InIter::value_type> 
        && CopyConstructible<Pred>
        && !ForwardIterator<InIter> 
        && !ForwardIterator<OutIter>
  OutIter unique_copy(InIter first, InIter last, OutIter result, Pred pred);

template<ForwardIterator InIter, OutputIterator<auto, InIter::reference> OutIter,
         EquivalenceRelation<auto, InIter::value_type> Pred>
  requires CopyConstructible<Pred>
  OutIter unique_copy(InIter first, InIter last, OutIter result, Pred pred);

template<InputIterator InIter, ForwardIterator OutIter,
         Predicate<auto, OutIter::value_type, InIter::value_type> Pred>
  requires OutputIterator<OutIter, InIter::reference> 
        && CopyConstructible<Pred>
        && !ForwardIterator<InIter>
  OutIter unique_copy(InIter first, InIter last, OutIter result, Pred pred);
\end{lstlisting}

The negative requirements above were needed to direct overload resolution, since
there is no natural ordering among these overloads.

\subsection{A Brief History}
In \Cpp98, the \tcode{unique_copy} algorithm was underspecified (it
did not mention \tcode{CopyAssignable} or \tcode{CopyConstructible}),
but the common practice was to provide all six implementations. The
resolution to DR 241 introduced the language that mandated six
implementations. 

\section{Proposed Resolution}
In the concepts-based standard library, replace the six overloads of
\tcode{unique_copy} with the following two signatures:

\begin{lstlisting}
template<InputIterator InIter, typename OutIter>
  requires OutputIterator<OutIter, RvalueOf<InIter::value_type>::type>
        && EqualityComparable<InIter::value_type>
        && HasAssign<InIter::value_type, InIter::reference>
        && Constructible<InIter::value_type, InIter::reference>
  OutIter unique_copy(InIter first, InIter last, OutIter result);

template<InputIterator InIter, typename OutIter,
         EquivalenceRelation<auto, InIter::value_type> Pred>
  requires OutputIterator<OutIter, RvalueOf<InIter::value_type>::type>
        && HasAssign<InIter::value_type, InIter::reference>
        && Constructible<InIter::value_type, InIter::reference>
        && CopyConstructible<Pred>
  OutIter unique_copy(InIter first, InIter last, OutIter result, Pred pred);
\end{lstlisting}

%% \noindent
%% In the pre-concepts standard library, modify [alg.unique]p5 as
%% follows:
%% 
%% \begin{quote}
%% \textit{Requires}: The ranges \tcode{[first,last)} and \tcode{[result,result+(last-first))} shall not overlap. The expression 
%% \tcode{*result = *first} shall be valid. \changed{If neither \mbox{\tcode{InputIterator}} nor \mbox{\tcode{OutputIterator}} meets the requirements 
%% of forward iterator then the}{The} value type of \tcode{InputIterator} shall be \tcode{CopyConstructible} (34) and \tcode{CopyAssignable}
%% (table 36). \removed{Otherwise \mbox{\tcode{CopyConstructible}} is not required.}
%% \end{quote}
%% 

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
