\documentclass[american,twoside]{book}
\usepackage{refbib}
\usepackage{pdfsync}
\input{macros}

%%--------------------------------------------------
%% PDF

\usepackage[pdftex,
            pdftitle={Concepts for the C++0x Standard Library: Numerics},
            pdfsubject={C++ International Standard Proposal},
            pdfcreator={Douglas Gregor},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}

%%--------------------------------------------------
%% Set section numbering limit, toc limit
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{1}

%%--------------------------------------------------
%% Parameters that govern document appearance
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.6in}

%%--------------------------------------------------
%% Handle special hyphenation rules
\hyphenation{tem-plate ex-am-ple in-put-it-er-a-tor}

% Do not put blank pages after chapters that end on odd-numbered pages.
\def\cleardoublepage{\clearpage\if@twoside%
  \ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage%
  \if@twocolumn\hbox{}\newpage\fi\fi\fi}

\begin{document}
\raggedbottom

\begin{titlepage}
\begin{center}
\huge
Concepts for the C++0x Standard Library: Numerics\\
(Revision 3)

\vspace{0.5in}

\normalsize
Douglas Gregor, and Andrew Lumsdaine \\
Open Systems Laboratory \\
Indiana University \\
Bloomington, IN\ \  47405 \\
\{\href{mailto:dgregor@osl.iu.edu}{dgregor}, \href{mailto:lums@osl.iu.edu}{lums}\}@osl.iu.edu

\end{center}

\vspace{1in}
\par\noindent Document number: N2736=08-0246\vspace{-6pt}
\par\noindent Revises document number: N2626=08-0136\vspace{-6pt}
\par\noindent Date: \today\vspace{-6pt}
\par\noindent Project: Programming Language \Cpp{}, Library Working Group\vspace{-6pt}
\par\noindent Reply-to: Douglas Gregor $<$\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}$>$\vspace{-6pt}

\section*{Introduction}
\libintrotext{Chapter 26}

\paragraph*{Changes from N2626}
\begin{itemize}
\item Updated requirements for \tcode{accumulate},
  \tcode{inner_product}, \tcode{partial_sum}, and
  \tcode{adjacent_difference} to cope with move semantics and changes
  to the foundational concepts.
\item The complex transcendentals and other non-member operations
  require \tcode{FloatingPointType}, which more accurately
  characterizes the actual requirements for the \tcode{complex} type.
\item Added \tcode{iota}, conceptualized by Daniel Kr\"ugler.
\end{itemize}

\paragraph*{Issues resolved in this paper}
The following issue has been applied to this paper and should be resolved as NAD:
\begin{itemize}
\item Issue 844: complex pow return type is ambiguous. Rather than add
  concepts to the \tcode{pow(complex, int)} function, which will be
  removed by the proposed resolution to issue 844, we have applied the
  proposed resolution to this document.
\end{itemize}
\end{titlepage}

%%--------------------------------------------------
%% Headers and footers
\pagestyle{fancy}
\fancyhead[LE,RO]{\textbf{\rightmark}}
\fancyhead[RE]{\textbf{\leftmark\hspace{1em}\thepage}}
\fancyhead[LO]{\textbf{\thepage\hspace{1em}\leftmark}}
\fancyfoot[C]{Draft}

\fancypagestyle{plain}{
\renewcommand{\headrulewidth}{0in}
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\fancyfoot{}
}

\renewcommand{\sectionmark}[1]{\markright{\thesection\hspace{1em}#1}}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

\color{black}

\setcounter{chapter}{25}
\rSec0[numerics]{Numerics library}
\begin{paras}

\pnum
This clause describes components that \Cpp\ programs may use to perform
seminumerical operations.

\pnum
The following subclauses describe components for
complex number types, \addedB{random number generation,}
numeric (%
\textit{n}-at-a-time)
arrays, generalized numeric algorithms,
and facilities included from the ISO C library,
as summarized in Table~\ref{tab:numerics.summary}.

\begin{libsumtab}{Numerics library summary}{tab:numerics.summary}
\ref{numeric.concepts} \changedConcepts{Requirements}{Concepts}	& \addedConcepts{\mbox{\tcode{<numeric_concepts>}}}						\\ \rowsep
\ref{complex.numbers} Complex Numbers	&	\tcode{<complex>}	\\ \rowsep
\ref{rand} \addedB{Random number generation} & \tcode{<random>} \\ \rowsep
\ref{numarray} Numeric arrays			&	\tcode{<valarray>}	\\ \rowsep
\ref{numeric.ops} Generalized numeric operations	&	\tcode{<numeric>}	\\ \rowsep
\ref{c.math} C library    				&	\tcode{<cmath>} 	\\
                                      & \tcode{<ctgmath>}	\\
                                      & \tcode{<tgmath.h>}\\
                                      & \tcode{<cstdlib>} \\
\end{libsumtab}

\rSec1[numeric.concepts]{Numeric type concepts}
\index{concepts!numeric type}
\editorial{The name of this section has been changed from ``Numeric type requirements'' to ``Numeric type concepts'', and the label has been changed from [numeric.requirements] to [numeric.concepts].}

\pnum
The
\tcode{complex}\
and
\tcode{valarray}\
components are parameterized by the type of information they contain and manipulate.
A \Cpp\ program shall instantiate these components only with a type
\tcode{T}\
that satisfies the
\changedConcepts{following requirements:}{\mbox{\tcode{Semiregular}} concept (\mbox{\ref{concept.regular}}).}%
\footnote{
\removedConcepts{In other words, value types.
These include built-in arithmetic types,
pointers, the library class
\mbox{\tcode{complex}},
and instantiations of
\mbox{\tcode{valarray}}\
for value types.
}}
\begin{itemize}
\item \removedConcepts{\mbox{\farg{T}}\ is not an abstract class (it has no pure virtual member functions);}
\item \removedConcepts{\mbox{\farg{T}}\ is not a reference type;}
\item \removedConcepts{\mbox{\farg{T}}\ is not cv-qualified;}
\item \removedConcepts{If \mbox{\farg{T}}\ is a class, it has a public default constructor;}
\item \removedConcepts{If \mbox{\farg{T}}\ is a class, it has a public copy constructor with the signature \mbox{\tcode{\farg{T}::\farg{T}(const \farg{T}\&)}}}\
\item \removedConcepts{If \mbox{\farg{T}}\ is a class, it has a public destructor;}
\item \removedConcepts{If \mbox{\farg{T}}\ is a class, it has a public assignment operator whose signature is either
\mbox{\tcode{\farg{T}\& \farg{T}::operator=(const \farg{T}\&)}}\
or
\mbox{\tcode{\farg{T}\& \farg{T}::operator=(\farg{T})}}}\
\item \removedC{If \mbox{\farg{T}}\ is a class, its assignment operator, copy and default constructors,
and destructor shall correspond to each other in the following sense:
Initialization of raw storage using the default constructor, followed by
assignment, is semantically equivalent to initialization of raw
storage using the copy constructor.
Destruction of an object, followed by
initialization of its raw storage using the copy constructor,
is semantically equivalent to assignment to the original object.}

\removedConcepts{\mbox{\enternote}\ 
This rule states that there shall not be any subtle differences in the semantics
of initialization versus assignment.
This gives an implementation
considerable flexibility in how arrays are initialized.}

\removedConcepts{\mbox{\enterexample}\ 
An implementation is allowed to initialize a
\mbox{\tcode{valarray}}\
by allocating storage using the
\mbox{\tcode{new}}\
operator (which
implies a call to the default constructor for each element) and then
assigning each element its value.
Or the implementation can allocate raw
storage and use the copy constructor to initialize each element.
\mbox{\exitexample}}

\removedConcepts{If the distinction between initialization and assignment is important
for a class, or if it fails to satisfy any of
the other conditions listed above, the programmer should use
\mbox{\tcode{vector}}\
(\mbox{\ref{vector}})\ instead of
\mbox{\tcode{valarray}}\
for that class;
\mbox{\exitnote}}
\item \removedConcepts{If \mbox{\farg{T}}\ is a class, it does not overload unary
\mbox{\tcode{operator\&}}.}
\end{itemize}

\pnum
If any operation on \farg{T}\ 
throws an exception the effects are undefined.

\pnum
In addition, many member and related functions of
\tcode{valarray<\farg{T}>}\
can be successfully instantiated
and will exhibit well-defined behavior if and only if
\farg{T}\ satisfies additional requirements specified for each such member
or related function.

\pnum
\enterexample\ 
It is valid to instantiate
\tcode{valarray<\farg{complex}>},
but
\tcode{operator>()}\
will not be successfully instantiated for
\tcode{valarray<\farg{complex}>}\
operands, since
\tcode{complex}\
does not have any ordering operators.
\exitexample\ 

\color{addclr}
\synopsis{Header \tcode{<numeric_concepts>}\ synopsis}
\begin{codeblock}
namespace std {
  auto concept HasAbs<typename T> @\textit{see below}@;  
  auto concept HasAcos<typename T> @\textit{see below}@;  
  auto concept HasAsin<typename T> @\textit{see below}@;  
  auto concept HasAtan<typename T> @\textit{see below}@;  
  auto concept HasAtan2<typename T> @\textit{see below}@;  
  auto concept HasCos<typename T> @\textit{see below}@;  
  auto concept HasCosh<typename T> @\textit{see below}@;  
  auto concept HasExp<typename T> @\textit{see below}@;  
  auto concept HasLog<typename T> @\textit{see below}@;  
  auto concept HasLog10<typename T> @\textit{see below}@;  
  auto concept HasPow<typename T> @\textit{see below}@;  
  auto concept HasSin<typename T> @\textit{see below}@;  
  auto concept HasSinh<typename T> @\textit{see below}@;  
  auto concept HasSqrt<typename T> @\textit{see below}@;  
  auto concept HasTan<typename T> @\textit{see below}@;  
  auto concept HasTanh<typename T> @\textit{see below}@;
}
\end{codeblock}

\editorial{These transcendental concepts are here to support the
  transcendental operations of \mbox{\tcode{valarray}} and
  \mbox{\tcode{complex}}. They are separate concepts---rather than a
  single \mbox{\tcode{Transcendental}} concept---because the
  \mbox{\tcode{valarray}} versions in C++03 specifically require only
  the corresponding operation.}

\begin{itemdecl}
auto concept HasAbs<typename T> {
  T abs(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which an absolute value can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasAcos<typename T> {
  T acos(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which an arc cosine.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasAsin<typename T> {
  T asin(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which an arc sine can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasAtan<typename T> {
  T atan(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which an arc tangent can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasAtan2<typename T> {
  T atan2(const T& y, const T& x);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which an arc tangent can be computed from \mbox{\farg{y}}/\mbox{\farg{x}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasCos<typename T> {
  T cos(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which a cosine can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasCosh<typename T> {
  T cosh(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which a hyperbolic cosine can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasExp<typename T> {
  T exp(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which the base-\mbox{\farg{e}} exponential can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLog<typename T> {
  T log(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which the natural logarithm can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLog10<typename T> {
  T log10(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which a base-10 logarithm can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasPow<typename T> {
  T pow(const T& x, const T& y);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which the exponential \mbox{$\farg{x}^\farg{y}$} can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasSin<typename T> {
  T sin(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which the sine can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasSinh<typename T> {
  T sinh(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which the hyperbolic sine can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasSqrt<typename T> {
  T sqrt(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which the square root can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasTan<typename T> {
  T tan(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which the tangent can be computed.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasTanh<typename T> {
  T tanh(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which the hyperbolic tangent can be computed.}
\end{itemdescr}
\color{black}

\setcounter{section}{2}
\rSec1[complex.numbers]{Complex numbers}

\pnum
The header
\index{complex@\tcode{<complex>}}%
\tcode{<complex>}
defines a
class template,
and numerous functions for representing and manipulating complex numbers.

\pnum
The effect of instantiating the template
\tcode{complex}\
for any type other than float, double or long double is unspecified.

\pnum
If the result of a function is not mathematically defined or not in
the range of representable values for its type, the behavior is
undefined.

\rSec2[complex.synopsis]{Header \tcode{<complex>}\ synopsis}

\index{complex@\tcode{<complex>}}%
\begin{codeblock}
namespace std {
  template<@\changedConcepts{class}{ArithmeticLike}@ T> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;

  // \ref{complex.ops} operators:
  template<@\changedConcepts{class}{ArithmeticLike}@ T>
    complex<T> operator+(const complex<T>&, const complex<T>&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator+(const complex<T>&, const T&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator+(const T&, const complex<T>&);

  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator-
    (const complex<T>&, const complex<T>&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator-(const complex<T>&, const T&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator-(const T&, const complex<T>&);

  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator*
    (const complex<T>&, const complex<T>&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator*(const complex<T>&, const T&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator*(const T&, const complex<T>&);

  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator/
    (const complex<T>&, const complex<T>&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator/(const complex<T>&, const T&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator/(const T&, const complex<T>&);

  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator+(const complex<T>&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator-(const complex<T>&);

  template<@\changedConcepts{class}{ArithmeticLike}@ T> bool operator==
    (const complex<T>&, const complex<T>&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> bool operator==(const complex<T>&, const T&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> bool operator==(const T&, const complex<T>&);

  template<@\changedConcepts{class}{ArithmeticLike}@ T> bool operator!=(const complex<T>&, const complex<T>&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> bool operator!=(const complex<T>&, const T&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> bool operator!=(const T&, const complex<T>&);

  template<class T, class charT, class traits>
  basic_istream<charT, traits>&
  operator>>(basic_istream<charT, traits>&, complex<T>&);

  template<class T, class charT, class traits>
  basic_ostream<charT, traits>&
  operator<<(basic_ostream<charT, traits>&, const complex<T>&);

  // \ref{complex.value.ops} values:
  template<@\changedConcepts{class}{ArithmeticLike}@ T> T real(const complex<T>&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> T imag(const complex<T>&);

  template<@\changedConcepts{class}{FloatingPointType}@ T> T abs(const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> T arg(const complex<T>&);
  template<@\changedConcepts{class}{ArithmeticLike}@ T> T norm(const complex<T>&);

  template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> conj(const complex<T>&);
  @\ptr@template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> fabs(const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> polar(const T&, const T& = 0);

  // \ref{complex.transcendentals} transcendentals:
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> acos(const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> asin(const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> atan(const complex<T>&);

  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> acosh(const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> asinh(const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> atanh(const complex<T>&);

  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> cos  (const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> cosh (const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> exp  (const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> log  (const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> log10(const complex<T>&);

  @\removedConcepts{template<class T> complex<T> pow(const complex<T>\&, int);}@
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> pow(const complex<T>&, const T&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> pow(const complex<T>&, const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> pow(const T&, const complex<T>&);

  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> sin  (const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> sinh (const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> sqrt (const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> tan  (const complex<T>&);
  template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> tanh (const complex<T>&);
}
\end{codeblock}

\rSec2[complex]{Class template \tcode{complex}}

\index{complex@\tcode{complex}}%
\begin{codeblock}
namespace std {
  template<@\changedConcepts{class}{ArithmeticLike}@ T>
  class complex {
  public:
    typedef T value_type;

    complex(const T& @\farg{re}@ = T(), const T& @\farg{im}@ = T());
    complex(const complex&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Constructible<T, X>}@
      complex(const complex<X>&);

    T real() const;
    T imag() const;

    complex<T>& operator= (const T&);
    complex<T>& operator+=(const T&);
    complex<T>& operator-=(const T&);
    complex<T>& operator*=(const T&);
    complex<T>& operator/=(const T&);

    complex& operator=(const complex&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, T>}@
      complex<T>& operator= (const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, T>}@
      complex<T>& operator+=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, T>}@
      complex<T>& operator-=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, T>}@
      complex<T>& operator*=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, T>}@
      complex<T>& operator/=(const complex<X>&);
  };

}
\end{codeblock}

\pnum
The class
\tcode{complex}\
describes an object that can
store the Cartesian components,
\tcode{real()}\
and
\tcode{imag()},
of a complex
number.

\rSec2[complex.special]{\tcode{complex}\ specializations}

\begin{codeblock}
  template<> class complex<float> {
  public:
    typedef float value_type;

    complex(float re = 0.0f, float im = 0.0f);
    explicit complex(const complex<double>&);
    explicit complex(const complex<long double>&);

    float real() const;
    float imag() const;

    complex<float>& operator= (float);
    complex<float>& operator+=(float);
    complex<float>& operator-=(float);
    complex<float>& operator*=(float);
    complex<float>& operator/=(float);

    complex<float>& operator=(const complex<float>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, float>}@
      complex<float>& operator= (const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, float>}@
      complex<float>& operator+=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, float>}@
      complex<float>& operator-=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, float>}@
      complex<float>& operator*=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, float>}@
      complex<float>& operator/=(const complex<X>&);
  };

  template<> class complex<double> {
  public:
    typedef double value_type;

    complex(double re = 0.0, double im = 0.0);
    complex(const complex<float>&);
    explicit complex(const complex<long double>&);

    double real() const;
    double imag() const;

    complex<double>& operator= (double);
    complex<double>& operator+=(double);
    complex<double>& operator-=(double);
    complex<double>& operator*=(double);
    complex<double>& operator/=(double);

    complex<double>& operator=(const complex<double>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, double>}@
      complex<double>& operator= (const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, double>}@
      complex<double>& operator+=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, double>}@
      complex<double>& operator-=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, double>}@
      complex<double>& operator*=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, double>}@
      complex<double>& operator/=(const complex<X>&);
  };

  template<> class complex<long double> {
  public:
    typedef long double value_type;

    complex(long double re = 0.0L, long double im = 0.0L);
    complex(const complex<float>&);
    complex(const complex<double>&);

    long double real() const;
    long double imag() const;

    complex<long double>& operator=(const complex<long double>&);
    complex<long double>& operator= (long double);
    complex<long double>& operator+=(long double);
    complex<long double>& operator-=(long double);
    complex<long double>& operator*=(long double);
    complex<long double>& operator/=(long double);

    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, long double>}@
      complex<long double>& operator= (const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, long double>}@
      complex<long double>& operator+=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, long double>}@
      complex<long double>& operator-=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, long double>}@
      complex<long double>& operator*=(const complex<X>&);
    template<@\changedConcepts{class}{ArithmeticLike}@ X> @\addedConcepts{requires Convertible<X, long double>}@
      complex<long double>& operator/=(const complex<X>&);
  };
\end{codeblock}

\rSec2[complex.members]{\tcode{complex}\ member functions}

\rSec2[complex.member.ops]{\tcode{complex}\ member operators}

\index{operator+=@\tcode{operator+=}!\tcode{complex}}%
\begin{itemdecl}
complex<T>& operator+=(const T& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Adds the scalar value \farg{rhs}\ to the real part of the complex value
\tcode{*this}\
and stores the result in the real part of
\tcode{*this},
leaving the imaginary part unchanged.

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\index{operator-=@\tcode{operator-=}!\tcode{complex}}%
\begin{itemdecl}
complex<T>& operator-=(const T& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Subtracts the scalar value \farg{rhs}\ from the real part of the complex value
\tcode{*this}\
and stores the result in the real part of
\tcode{*this},
leaving the imaginary part unchanged.

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\index{operator*=@\tcode{operator*=}!\tcode{complex}}%
\begin{itemdecl}
complex<T>& operator*=(const T& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Multiplies the scalar value \farg{rhs}\ by the complex value
\tcode{*this}\
and stores the result in
\tcode{*this}.

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\index{operator/=@\tcode{operator/=}!\tcode{complex}}%
\begin{itemdecl}
complex<T>& operator/=(const T& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Divides the scalar value \farg{rhs}\ into the complex value
\tcode{*this}\
and stores the result in
\tcode{*this}.

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\index{operator+=@\tcode{operator+=}!\tcode{complex}}%
\begin{itemdecl}
complex<T>& operator+=(const complex<T>& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Adds the complex value \farg{rhs}\ to the complex value
\tcode{*this}\
and stores the sum in
\tcode{*this}.

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\index{operator-=@\tcode{operator-=}!\tcode{complex}}%
\begin{itemdecl}
complex<T>& operator-=(const complex<T>& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Subtracts the complex value \farg{rhs}\ from the complex value
\tcode{*this}\
and stores the difference in
\tcode{*this}.

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\index{operator*=@\tcode{operator*=}!\tcode{complex}}%
\begin{itemdecl}
complex<T>& operator*=(const complex<T>& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Multiplies the complex value \farg{rhs}\ by the complex value
\tcode{*this}\
and stores the product in
\tcode{*this}.

\returns\ 
\tcode{*this}.
\end{itemdescr}

\index{operator/=@\tcode{operator/=}!\tcode{complex}}%
\begin{itemdecl}
complex<T>& operator/=(const complex<T>& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Divides the complex value \farg{rhs}\ into the complex value
\tcode{*this}\
and stores the quotient in
\tcode{*this}.

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\rSec2[complex.ops]{\tcode{complex}\ non-member operations}

\index{operator+@\tcode{operator+}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator+(const complex<T>& @\farg{lhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes\ 
unary operator.

\pnum
\returns\ 
\tcode{complex<T>(\farg{lhs})}.
\end{itemdescr}

\begin{codeblock}
template<@\changedConcepts{class}{ArithmeticLike}@ T>
  complex<T> operator+(const complex<T>& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator+(const complex<T>& @\farg{lhs}@, const T& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator+(const T& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
\end{codeblock}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{complex<T>(\farg{lhs}) += \farg{rhs}}.
\end{itemdescr}

\index{operator-@\tcode{operator-}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator-(const complex<T>& @\farg{lhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes\ 
unary operator.

\pnum
\returns\ 
\tcode{complex<T>(-\farg{lhs}.real(),-\farg{lhs}.imag())}.
\end{itemdescr}

\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T>
  complex<T> operator-(const complex<T>& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator-(const complex<T>& @\farg{lhs}@, const T& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator-(const T& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{complex<T>(\farg{lhs}) -= \farg{rhs}}.
\end{itemdescr}

\index{operator*@\tcode{operator*}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T>
  complex<T> operator*(const complex<T>& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator*(const complex<T>& @\farg{lhs}@, const T& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator*(const T& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{complex<T>(\farg{lhs}) *= \farg{rhs}}.
\end{itemdescr}

\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T>
  complex<T> operator/(const complex<T>& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator/(const complex<T>& @\farg{lhs}@, const T& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> operator/(const T& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{complex<T>(\farg{lhs}) /= \farg{rhs}}.
\end{itemdescr}

\index{operator==@\tcode{operator==}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T>
  bool operator==(const complex<T>& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> bool operator==(const complex<T>& @\farg{lhs}@, const T& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> bool operator==(const T& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{\farg{lhs}.real() == \farg{rhs}.real() \&\& \farg{lhs}.imag() == \farg{rhs}.imag()}.

\pnum
\notes\ 
The imaginary part is assumed to be
\tcode{T()},
or 0.0, for the
\tcode{T}\
arguments.
\end{itemdescr}

\index{operator"!=@\tcode{operator"!=}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T>
  bool operator!=(const complex<T>& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> bool operator!=(const complex<T>& @\farg{lhs}@, const T& @\farg{rhs}@);
template<@\changedConcepts{class}{ArithmeticLike}@ T> bool operator!=(const T& @\farg{lhs}@, const complex<T>& @\farg{rhs}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{\farg{rhs}.real() != \farg{lhs}.real() || \farg{rhs}.imag() != \farg{lhs}.imag()}.
\end{itemdescr}

\index{operator>>@\tcode{operator\shr}!\tcode{complex}}%
\begin{itemdecl}
template<class T, class charT, class traits>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& @\farg{is}@, complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Extracts a complex number \farg{x} of the form:
\tcode{u},
\tcode{(u)},
or
\tcode{(u,v)},
where
\tcode{u}\
is the real part and
\tcode{v}\
is the imaginary part (\ref{istream.formatted}).

\pnum
\requires\ 
The input values be convertible to
\tcode{T}.

If bad input is encountered, calls
\tcode{\farg{is}.setstate(ios::failbit)}\
(which may throw
\tcode{ios::failure}\
(\ref{iostate.flags}).

\pnum
\returns\ 
\farg{is}.

\pnum
\notes\ 
This extraction is performed as a series of simpler
extractions.
Therefore, the skipping of whitespace is specified to be
the same for each of the simpler extractions.
\end{itemdescr}

\index{operator<<@\tcode{operator\shl}!\tcode{complex}}%
\begin{itemdecl}
template<class T, class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& @\farg{o}@, const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
inserts the complex number \farg{x}\
onto the stream \farg{o}\ as if it were implemented as follows:

\begin{codeblock}
template<class T, class charT, class traits>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& o, const complex<T>& x)
{
	basic_ostringstream<charT, traits> s;
	s.flags(o.flags());
	s.imbue(o.getloc());
	s.precision(o.precision());
	s << '(' << x.real() << "," << x.imag() << ')';
	return o << s.str();
}
\end{codeblock}
\end{itemdescr}

\rSec2[complex.value.ops]{\tcode{complex}\ value operations}

\index{real@\tcode{real}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T> T real(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{\farg{x}.real()}.
\end{itemdescr}

\index{imag@\tcode{imag}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T> T imag(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{\farg{x}.imag()}.
\end{itemdescr}

\index{abs@\tcode{abs}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> T abs(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the magnitude of \farg{x}.
\end{itemdescr}

\index{arg@\tcode{arg}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> T arg(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the phase angle of \farg{x}, or \tcode{atan2(imag(\farg{x}), real(\farg{x}))}.
\end{itemdescr}

\index{norm@\tcode{norm}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T> T norm(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the squared magnitude of \farg{x}.
\end{itemdescr}

\index{conj@\tcode{conj}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> conj(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the complex conjugate of \farg{x}.
\end{itemdescr}

\index{fabs@\tcode{fabs}!\tcode{complex}}%
\index{cabs@\tcode{cabs}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{ArithmeticLike}@ T> complex<T> fabs(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\  Behaves the same as C99 function \tcode{cabs},
defined in subclause 7.3.8.1.
\end{itemdescr}

\index{polar@\tcode{polar}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> polar(const T& @\farg{rho}@, const T& @\farg{theta}@ = 0);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the
\tcode{complex}\
value corresponding
to a complex number whose magnitude is \farg{rho}\ and whose phase angle
is \farg{theta}.
\end{itemdescr}

\rSec2[complex.transcendentals]{\tcode{complex}\ transcendentals}

\index{acos@\tcode{acos}!\tcode{complex}}%
\index{cacos@\tcode{cacos}!\tcode{complex}}%
\begin{itemdecl}
@\ptr@template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> acos(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\  Behaves the same as C99 function \tcode{cacos},
defined in subclause 7.3.5.1.
\end{itemdescr}

\index{asin@\tcode{asin}!\tcode{complex}}%
\index{casin@\tcode{casin}!\tcode{complex}}%
\begin{itemdecl}
@\ptr@template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> asin(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\  Behaves the same as C99 function \tcode{casin},
defined in subclause 7.3.5.2.
\end{itemdescr}

\index{atan@\tcode{atan}!\tcode{complex}}%
\index{catan@\tcode{catan}!\tcode{complex}}%
\begin{itemdecl}
@\ptr@template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> atan(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\  Behaves the same as C99 function \tcode{catan},
defined in subclause 7.3.5.3.
\end{itemdescr}

\index{acosh@\tcode{acosh}!\tcode{complex}}%
\index{cacosh@\tcode{cacosh}!\tcode{complex}}%
\begin{itemdecl}
@\ptr@template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> acosh(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\  Behaves the same as C99 function \tcode{cacosh},
defined in subclause 7.3.6.1.
\end{itemdescr}

\index{asinh@\tcode{asinh}!\tcode{complex}}%
\index{casinh@\tcode{casinh}!\tcode{complex}}%
\begin{itemdecl}
@\ptr@template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> asinh(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\  Behaves the same as C99 function \tcode{casinh},
defined in subclause 7.3.6.2.
\end{itemdescr}

\index{atanh@\tcode{atanh}!\tcode{complex}}%
\index{catanh@\tcode{catanh}!\tcode{complex}}%
\begin{itemdecl}
@\ptr@template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> atanh(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum\effects\  Behaves the same as C99 function \tcode{catanh},
defined in subclause 7.3.6.3.
\end{itemdescr}

\index{cos@\tcode{cos}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> cos(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the complex cosine of \farg{x}.
\end{itemdescr}

\index{cosh@\tcode{cosh}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> cosh(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the complex hyperbolic cosine of \farg{x}.
\end{itemdescr}

\index{exp@\tcode{exp}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> exp(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the complex base e exponential of \farg{x}.
\end{itemdescr}

\index{log@\tcode{log}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> log(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes\ 
the branch cuts are along the negative real axis.

\pnum
\returns\ 
the complex natural (base e) logarithm of \farg{x},
in the range of a strip mathematically unbounded along the
real axis and in the interval \crange{-i times pi}{i times pi}\
along the imaginary axis.
When \farg{x} is a negative real
number,
\tcode{imag(log(\farg{x}))}\
is pi.
\end{itemdescr}

\index{log10@\tcode{log10}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> log10(const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes\ 
the branch cuts are along the negative real axis.

\pnum
\returns\ 
the complex common (base 10) logarithm of \farg{x}, defined as
\tcode{log(\farg{x})/log(10)}.
\end{itemdescr}

\index{pow@\tcode{pow}!\tcode{complex}}%
\begin{itemdecl}
@\removedConcepts{template<class T> complex<T> pow(const complex<T>\& \mbox{\farg{x}}, int \mbox{\farg{y}});}@
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> pow(const complex<T>& @\farg{x}@, const complex<T>& @\farg{y}@);
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> pow(const complex<T>& @\farg{x}@, const T& @\farg{y}@);
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> pow  (const T& @\farg{x}@, const complex<T>& @\farg{y}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes\ 
the branch cuts are along the negative real axis.

\pnum
\returns\ 
the complex power of base \farg{x}\ raised to the \farg{y}-th power,
defined as
\tcode{exp(\farg{y}*log(\farg{x}))}.
The value returned for
\tcode{pow(0,0)}
is implementation-defined.
\end{itemdescr}

\index{sin@\tcode{sin}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> sin  (const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the complex sine of \farg{x}.
\end{itemdescr}

\index{sinh@\tcode{sinh}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> sinh (const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the complex hyperbolic sine of \farg{x}.
\end{itemdescr}

\index{sqrt@\tcode{sqrt}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> sqrt (const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\notes\ 
the branch cuts are along the negative real axis.

\pnum
\returns\ 
the complex square root of \farg{x}, in the range of the right
half-plane.
If the argument is a negative real number, the
value returned lies on the positive imaginary axis.
\end{itemdescr}

\index{tan@\tcode{tan}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> tan  (const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the complex tangent of \farg{x}.
\end{itemdescr}

\index{tanh@\tcode{tanh}!\tcode{complex}}%
\begin{itemdecl}
template<@\changedConcepts{class}{FloatingPointType}@ T> complex<T> tanh (const complex<T>& @\farg{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
the complex hyperbolic tangent of \farg{x}.
\end{itemdescr}

\rSec2[cmplx.over]{\marktr{}Additional Overloads}

\pnum
\index{arg@\tcode{arg}}%
\index{conj@\tcode{conj}}%
\index{imag@\tcode{imag}}%
\index{norm@\tcode{norm}}%
\index{polar@\tcode{polar}}%
\index{real@\tcode{real}}%
The following function templates shall have additional overloads:
\begin{codeblock}
  arg                   norm 
  conj                  polar 
  imag                  real 
\end{codeblock}

\pnum
\index{overloads!floating point}%
The additional overloads shall be sufficient to ensure:

\begin{enumerate}
        \item{If the argument has type \tcode{long double}, then it is effectively 
              cast to \tcode{complex<long double>}.}
        \item{Otherwise, if the argument has type \tcode{double} or an integer type,
              then it is effectively cast to \tcode{complex<double>}.}
        \item{Otherwise, if the argument has type \tcode{float}, then it is 
              effectively cast to \tcode{complex<float>}.}
\end{enumerate}

\pnum
\index{pow@\tcode{pow}}%
Function template \tcode{pow} shall have additional overloads sufficient to
ensure, for a call with at least one argument of type \tcode{complex<T>}:

\begin{enumerate}

  \item{If either argument has type \tcode{complex<long double>} or type \tcode{long
        double}, then both arguments are effectively cast to
        \tcode{complex<long double>}.}
  \item{Otherwise, if either argument has type \tcode{complex<double>}, \tcode{double},
        or an integer type, then both arguments are effectively cast to
        \tcode{complex<double>}.}
  \item{Otherwise, if either argument has type \tcode{complex<float>} or \tcode{float},
        then both arguments are effectively cast to \tcode{complex<float>}.}
\end{enumerate}

\rSec2[ccmplx]{\marktr{}Header \tcode{<ccomplex>}}
\pnum
\index{ccomplex@\tcode{<ccomplex>}}%
The header behaves as if it simply includes the header \tcode{<complex>}.

\rSec2[cmplxh]{\marktr{}Header \tcode{<complex.h>}}
\pnum
\index{complex.h@\tcode{<complex.h>}}%
The header behaves as if it includes the header \tcode{<ccomplex>}, and provides
sufficient \textit{using} declarations to declare in the global namespace all
function and type names declared or defined in the neader \tcode{<complex>}.

\setcounter{section}{4}
\rSec1[numarray]{Numeric arrays}

\rSec2[valarray.synopsis]{Header \tcode{<valarray>}\ synopsis}
\index{valarray@\tcode{<valarray>}}%
\begin{codeblock}
namespace std {
  template<@\changedConcepts{class}{Semiregular}@ T> class valarray;         // An array of type \tcode{T}
  class slice;                              // a BLAS-like slice out of an array
  template<@\changedConcepts{class}{Semiregular}@ T> class slice_array;
  class gslice;                             // a generalized slice out of an array
  template<@\changedConcepts{class}{Semiregular}@ T> class gslice_array;
  template<@\changedConcepts{class}{Semiregular}@ T> class mask_array;       // a masked array
  template<@\changedConcepts{class}{Semiregular}@ T> class indirect_array;   // an indirected array

  template<@\changedConcepts{class}{Semiregular}@ T> void swap(valarray<T>&, valarray<T>&);
  template<@\changedConcepts{class}{Semiregular}@ T> void swap(valarray<T>&&, valarray<T>&);
  template<@\changedConcepts{class}{Semiregular}@ T> void swap(valarray<T>&, valarray<T>&&);

  template<class T> 
    @\addedConcepts{requires HasMultiply<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator* (const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasMultiply<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator* (const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasMultiply<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator* (const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasDivide<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator/ (const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasDivide<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator/ (const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasDivide<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator/ (const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasModulus<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator% (const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasModulus<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator% (const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasModulus<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator% (const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasPlus<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator+ (const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasPlus<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator+ (const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasPlus<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator+ (const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasMinus<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator- (const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasMinus<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator- (const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasMinus<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator- (const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasBitXor<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator^ (const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasBitXor<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator^ (const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasBitXor<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator^ (const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasBitAnd<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator& (const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasBitAnd<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator& (const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasBitAnd<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator& (const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasBitOr<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator| (const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasBitOr<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator| (const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasBitOr<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator| (const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasLeftShift<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator<<(const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasLeftShift<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator<<(const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasLeftShift<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator<<(const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasRightShift<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator>>(const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasRightShift<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator>>(const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasRightShift<T> \&\& Convertible<T::result_type, T>}@
    valarray<T> operator>>(const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasLogicalAnd<T>}@
    valarray<bool> operator&&(const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasLogicalAnd<T>}@
    valarray<bool> operator&&(const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasLogicalAnd<T>}@
    valarray<bool> operator&&(const T&, const valarray<T>&);

  template<class T> 
    @\addedConcepts{requires HasLogicalOr<T>}@
    valarray<bool> operator||(const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires HasLogicalOr<T>}@
    valarray<bool> operator||(const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires HasLogicalOr<T>}@
    valarray<bool> operator||(const T&, const valarray<T>&);

  template<class T>
    @\addedConcepts{requires EqualityComparable<T>}@
    valarray<bool> operator==(const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires EqualityComparable<T>}@
    valarray<bool> operator==(const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires EqualityComparable<T>}@
    valarray<bool> operator==(const T&, const valarray<T>&);
  template<class T>
    @\addedConcepts{requires EqualityComparable<T>}@
    valarray<bool> operator!=(const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires EqualityComparable<T>}@
    valarray<bool> operator!=(const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires EqualityComparable<T>}@
    valarray<bool> operator!=(const T&, const valarray<T>&);

  template<class T>
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator< (const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator< (const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator< (const T&, const valarray<T>&);
  template<class T>
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator> (const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator> (const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator> (const T&, const valarray<T>&);
  template<class T>
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator<=(const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator<=(const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator<=(const T&, const valarray<T>&);
  template<class T>
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator>=(const valarray<T>&, const valarray<T>&);
  template<class T> 
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator>=(const valarray<T>&, const T&);
  template<class T> 
    @\addedConcepts{requires LessThanComparable<T>}@
    valarray<bool> operator>=(const T&, const valarray<T>&);

  template<@\changedConcepts{class}{HasAbs}@ T> valarray<T> abs  (const valarray<T>&);
  template<@\changedConcepts{class}{HasAcos}@ T> valarray<T> acos (const valarray<T>&);
  template<@\changedConcepts{class}{HasAsin}@ T> valarray<T> asin (const valarray<T>&);
  template<@\changedConcepts{class}{HasAtan}@ T> valarray<T> atan (const valarray<T>&);

  template<@\changedConcepts{class}{Atan2}@ T> valarray<T> atan2
    (const valarray<T>&, const valarray<T>&);
  template<@\changedConcepts{class}{Atan2}@ T> valarray<T> atan2(const valarray<T>&, const T&);
  template<@\changedConcepts{class}{Atan2}@ T> valarray<T> atan2(const T&, const valarray<T>&);

  template<@\changedConcepts{class}{HasCos}@ T> valarray<T> cos  (const valarray<T>&);
  template<@\changedConcepts{class}{HasCosh}@ T> valarray<T> cosh (const valarray<T>&);
  template<@\changedConcepts{class}{HasExp}@ T> valarray<T> exp  (const valarray<T>&);
  template<@\changedConcepts{class}{HasLog}@ T> valarray<T> log  (const valarray<T>&);
  template<@\changedConcepts{class}{HasLog10}@ T> valarray<T> log10(const valarray<T>&);

  template<@\changedConcepts{class}{HasPow}@ T> valarray<T> pow(const valarray<T>&, const valarray<T>&);
  template<@\changedConcepts{class}{HasPow}@ T> valarray<T> pow(const valarray<T>&, const T&);
  template<@\changedConcepts{class}{HasPow}@ T> valarray<T> pow(const T&, const valarray<T>&);

  template<@\changedConcepts{class}{HasSin}@ T> valarray<T> sin  (const valarray<T>&);
  template<@\changedConcepts{class}{HasSinh}@ T> valarray<T> sinh (const valarray<T>&);
  template<@\changedConcepts{class}{HasSqrt}@ T> valarray<T> sqrt (const valarray<T>&);
  template<@\changedConcepts{class}{HasTan}@ T> valarray<T> tan  (const valarray<T>&);
  template<@\changedConcepts{class}{HasTanh}@ T> valarray<T> tanh (const valarray<T>&);
}
\end{codeblock}

\pnum
The header
\tcode{<valarray>}\
defines five
class templates
(\tcode{valarray},
\tcode{slice_array},
\tcode{gslice_array},
\tcode{mask_array},
and
\tcode{indirect_array}),
two classes (\tcode{slice}\
and
\tcode{gslice}),
and a series of related
function templates
for representing
and manipulating arrays of values.

\pnum
The
\tcode{valarray}\
array classes
are defined to be free of certain forms of aliasing, thus allowing
operations on these classes to be optimized.

\pnum
Any function returning a
\tcode{valarray<T>}\
is permitted to return an object of another type, provided all the
const member functions of
\tcode{valarray<T>}\
are also applicable to this type.
This return type shall not add
more than two levels of template nesting over the most deeply nested
argument type.%
\footnote{
Clause \ref{limits}\ recommends a minimum number of recursively nested template
instantiations.
This requirement thus indirectly suggests a minimum
allowable complexity for valarray expressions.
}

\pnum
Implementations introducing such replacement types shall provide
additional functions and operators as follows:
\begin{itemize}
\item
for every function taking a
\tcode{const valarray<T>\&},
identical functions taking the replacement types shall be added;
\item
for every function taking two
\tcode{const valarray<T>\&}\
arguments, identical functions taking every combination of
\tcode{const valarray<T>\&}\
and replacement types shall be added.
\end{itemize}

\pnum
In particular, an implementation shall allow a
\tcode{valarray<T>}\
to be constructed from such replacement types and shall allow assignments
and computed assignments of such types to
\tcode{valarray<T>},
\tcode{slice_array<T>},
\tcode{gslice_array<T>},
\tcode{mask_array<T>}
and
\tcode{indirect_array<T>}
objects.

\pnum
These library functions are permitted to throw a
\tcode{bad_alloc}\
(\ref{bad.alloc}) exception if there are not sufficient resources available
to carry out the operation.
Note that the exception is not mandated.

\rSec2[template.valarray]{Class template \tcode{valarray}}

\index{valarray@\tcode{valarray}}%
\begin{codeblock}
namespace std {
  template<@\changedConcepts{class}{Semiregular}@ @\farg{T}@> class valarray {
  public:
    typedef T value_type;

    // \ref{valarray.cons} construct/destroy:
    valarray();
    explicit valarray(size_t);
    valarray(const T&, size_t);
    valarray(const T*, size_t);
    valarray(const valarray&);
    @\addedD{valarray(valarray\&\&);}@
    valarray(const slice_array<T>&);
    valarray(const gslice_array<T>&);
    valarray(const mask_array<T>&);
    valarray(const indirect_array<T>&);
   ~valarray();

    // \ref{valarray.assign} assignment:
    valarray<T>& operator=(const valarray<T>&);
    @\addedD{valarray<T>\& operator=(valarray<T>\&\&);}@
    valarray<T>& operator=(const T&);
    valarray<T>& operator=(const slice_array<T>&);
    valarray<T>& operator=(const gslice_array<T>&);
    valarray<T>& operator=(const mask_array<T>&);
    valarray<T>& operator=(const indirect_array<T>&);

    // \ref{valarray.access} element access:
    const T&          operator[](size_t) const;
    T&                operator[](size_t);

    // \ref{valarray.sub} subset operations:
    valarray<T>       operator[](slice) const;
    slice_array<T>    operator[](slice);
    valarray<T>       operator[](const gslice&) const;
    gslice_array<T>   operator[](const gslice&);
    valarray<T>       operator[](const valarray<bool>&) const;
    mask_array<T>     operator[](const valarray<bool>&);
    valarray<T>       operator[](const valarray<size_t>&) const;
    indirect_array<T> operator[](const valarray<size_t>&);

    // \ref{valarray.unary} unary operators:
    @\addedConcepts{requires HasUnaryPlus<T> \&\& Convertible<T::result_type, T>}@ 
      valarray<T> operator+() const;
    @\addedConcepts{requires HasNegate<T> \&\& Convertible<T::result_type, T>}@ 
      valarray<T> operator-() const;
    @\addedConcepts{requires HasComplement<T> \&\& Convertible<T::result_type, T>}@ 
      valarray<T> operator~() const;
    @\addedConcepts{requires HasLogicalNot<T>}@ valarray<bool> operator!() const;

    // \ref{valarray.cassign} computed assignment:
    @\addedConcepts{requires HasMultiplyAssign<T>}@   valarray<T>& operator*= (const T&);
    @\addedConcepts{requires HasDivideAssign<T>}@     valarray<T>& operator/= (const T&);
    @\addedConcepts{requires HasModulusAssign<T>}@    valarray<T>& operator%= (const T&);
    @\addedConcepts{requires HasPlusAssign<T>}@       valarray<T>& operator+= (const T&);
    @\addedConcepts{requires HasMinusAssign<T>}@      valarray<T>& operator-= (const T&);
    @\addedConcepts{requires HasBitXorAssign<T>}@     valarray<T>& operator^= (const T&);
    @\addedConcepts{requires HasBitAndAssign<T>}@     valarray<T>& operator&= (const T&);
    @\addedConcepts{requires HasBitOrAssign<T>}@      valarray<T>& operator|= (const T&);
    @\addedConcepts{requires HasLeftShiftAssign<T>}@  valarray<T>& operator<<=(const T&);
    @\addedConcepts{requires HasRightShiftAssign<T>}@ valarray<T>& operator>>=(const T&);

    @\addedConcepts{requires HasMultiplyAssign<T>}@   valarray<T>& operator*= (const valarray<T>&);
    @\addedConcepts{requires HasDivideAssign<T>}@     valarray<T>& operator/= (const valarray<T>&);
    @\addedConcepts{requires HasModulusAssign<T>}@    valarray<T>& operator%= (const valarray<T>&);
    @\addedConcepts{requires HasPlusAssign<T>}@       valarray<T>& operator+= (const valarray<T>&);
    @\addedConcepts{requires HasMinusAssign<T>}@      valarray<T>& operator-= (const valarray<T>&);
    @\addedConcepts{requires HasBitXorAssign<T>}@     valarray<T>& operator^= (const valarray<T>&);
    @\addedConcepts{requires HasBitOrAssign<T>}@      valarray<T>& operator|= (const valarray<T>&);
    @\addedConcepts{requires HasBitAndAssign<T>}@     valarray<T>& operator&= (const valarray<T>&);
    @\addedConcepts{requires HasLeftShiftAssign<T>}@  valarray<T>& operator<<=(const valarray<T>&);
    @\addedConcepts{requires HasRightShiftAssign<T>}@ valarray<T>& operator>>=(const valarray<T>&);

    // \ref{valarray.members} member functions:
    @\addedD{void swap(valarray\&\&);}@

    size_t size() const;

    @\addedConcepts{requires HasPlusAssign<T>}@      T    sum() const;
    @\addedConcepts{requires LessThanComparable<T>}@ T    min() const;
    @\addedConcepts{requires LessThanComparable<T>}@ T    max() const;

    valarray<T> shift (int) const;
    valarray<T> cshift(int) const;
    valarray<T> apply(T func(T)) const;
    valarray<T> apply(T func(const T&)) const;
    void resize(size_t sz, T c = T());
  };
}
\end{codeblock}

\pnum
The
class template
\tcode{valarray<\farg{T}>}\
is a
one-dimensional smart array, with elements numbered sequentially from zero.
It is a representation of the mathematical concept
of an ordered set of values.
The illusion of higher dimensionality
may be produced by the familiar idiom of computed indices, together
with the powerful subsetting capabilities provided
by the generalized subscript operators.%
\footnote{
The intent is to specify an array template that has the minimum functionality
necessary to address aliasing ambiguities and the proliferation of
temporaries.
Thus, the
\tcode{valarray}
template is neither a
matrix class nor a field class.
However, it is a very useful building block for designing such classes.
}

\pnum
An implementation is permitted to qualify any of the functions declared in
\tcode{<valarray>}\
as
\tcode{inline}.

\rSec3[valarray.cons]{\tcode{valarray}\ constructors}

\index{valarray@\tcode{valarray}!\tcode{valarray}}%
\begin{itemdecl}
valarray();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Constructs an object of class
\tcode{valarray<\farg{T}>},%
\footnote{
For convenience, such objects are referred to as ``arrays'' throughout the
remainder of \ref{numarray}.
}
which has zero length until it is passed into a library function as a
modifiable lvalue or through a non-constant
\tcode{this}\
pointer.%
\footnote{
This default constructor is essential,
since arrays of
\tcode{valarray}\
are likely to prove useful.
There shall also be a way to change the size of an array after
initialization; this is supplied by the semantics of the
\tcode{resize}\
member function.
}
\end{itemdescr}

\begin{itemdecl}
explicit valarray(size_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
The array created by this constructor has a length equal to the value of the argument.
The elements of the array are constructed using the default constructor for the
instantiating type \farg{T}.
\end{itemdescr}

\begin{itemdecl}
valarray(const T&, size_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
The array created by this constructor has a length equal to the second
argument.
The elements of the array are initialized with the value of the first argument.
\end{itemdescr}

\begin{itemdecl}
valarray(const T*, size_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
The array created by this constructor has a length equal to the second
argument
\tcode{n}.
The values of the elements of the array are initialized with the
first
\tcode{n}\
values pointed to by the first argument.%
\footnote{
This constructor is the preferred method for converting a C array to a
\tcode{valarray}
object.
}
If the value of the second argument is greater than the number of values
pointed to by the first argument, the behavior is undefined.%
\index{undefined}
\end{itemdescr}

\begin{itemdecl}
valarray(const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The array created by this constructor has the same length as the argument
array.
The elements are initialized with the values of the corresponding
elements of the argument array.%
\footnote{
This copy constructor creates a distinct array rather than an alias.
Implementations in which arrays share storage are permitted, but they
shall implement a copy-on-reference mechanism to ensure that arrays are
conceptually distinct.
}
\end{itemdescr}

\begin{itemdecl}
@\addedD{valarray(valarray<T>\&\&);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedD{The array created by this constructor has the same length as the argument
array.
The elements are initialized with the values of the corresponding
elements of the argument array. After construction,
\mbox{\tcode{v}} is in a valid but unspecified state.}

\pnum
\addedD{\mbox{\complexity} Constant.}

\pnum
\addedD{\mbox{\throws} Nothing.}
\end{itemdescr}

\begin{itemdecl}
valarray(const slice_array<T>&);
valarray(const gslice_array<T>&);
valarray(const mask_array<T>&);
valarray(const indirect_array<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
These conversion constructors convert one of the four reference templates
to a
\tcode{valarray}.
\end{itemdescr}

\index{\~valarray@\tcode{$\sim$valarray}!valarray@\tcode{valarray}}%
\begin{itemdecl}
~valarray();
\end{itemdecl}

\begin{itemdescr}
\pnum
The destructor is applied to every element of
\tcode{*this};
an implementation may return all allocated memory.
\end{itemdescr}

\rSec3[valarray.assign]{\tcode{valarray}\ assignment}

\index{operator=@\tcode{operator=}!\tcode{valarray}}%
\begin{itemdecl}
valarray<T>& operator=(const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each element of the
\tcode{*this}\
array is assigned the value of the corresponding element of the argument
array.
The resulting behavior is undefined if the length of the argument
array is not equal to the length of the
\tcode{*this}\
array.
\end{itemdescr}

\index{operator=@\tcode{operator=}!\tcode{valarray}}%
\begin{itemdecl}
@\addedD{valarray<T>\& operator=(valarray<T>\&\&);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedD{\mbox{\effects} \mbox{\tcode{*this}} obtains the value of \mbox{\tcode{v}}.
After the assignment, \mbox{\tcode{v}} is in a valid but unspecified state.}

\pnum
\addedD{\mbox{\complexity} Constant.}

\pnum
\addedD{\mbox{\throws} Nothing.}
\end{itemdescr}

\index{operator=@\tcode{operator=}!\tcode{valarray}}%
\begin{itemdecl}
valarray<T>& operator=(const T&);
\end{itemdecl}

\begin{itemdescr}
\pnum
The scalar assignment operator causes each element of the
\tcode{*this}\
array to be assigned the value of the argument.
\end{itemdescr}

\begin{itemdecl}
valarray<T>& operator=(const slice_array<T>&);
valarray<T>& operator=(const gslice_array<T>&);
valarray<T>& operator=(const mask_array<T>&);
valarray<T>& operator=(const indirect_array<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
These operators allow the results of a generalized subscripting operation
to be assigned directly to a
\tcode{valarray}.

\pnum
If the value of an element in the left-hand side of a valarray assignment
operator depends on the value of another element in that left-hand side,
the resulting behavior is undefined.
\end{itemdescr}

\rSec3[valarray.access]{\tcode{valarray}\ element access}

\index{operator[]@\tcode{operator[]}!valarray@\tcode{valarray}}%
\begin{itemdecl}
const T&  operator[](size_t) const;
T& operator[](size_t);
\end{itemdecl}

\begin{itemdescr}
\pnum
When applied to a constant array, the subscript operator returns the value
of the corresponding element of the array.
When applied to a non-constant array, the subscript operator
returns a reference to the corresponding element of the array.

\pnum
Thus, the expression
\tcode{(a[i] = q, a[i]) == q}\
evaluates as true for any non-constant
\tcode{valarray<T> a},
any
\tcode{T q},
and for any
\tcode{size_t i}\
such that the value of
\tcode{i}\
is less than the length of
\tcode{a}.

\pnum
The expression
\tcode{\&a[i+j] == \&a[i] + j}\
evaluates as true for all
\tcode{size_t i}\
and
\tcode{size_t j}\
such that
\tcode{i+j}\
is less than the length of the non-constant
array
\tcode{a}.

\pnum
Likewise, the expression
\tcode{\&a[i] != \&b[j]}\
evaluates as
\tcode{true}\
for any two non-constant arrays
\tcode{a}\
and
\tcode{b}\
and for any
\tcode{size_t i}\
and
\tcode{size_t j}\
such that
\tcode{i}\
is less than the length of
\tcode{a}\
and
\tcode{j}\
is less than the length of
\tcode{b}.
This property indicates an absence of aliasing and may be used to
advantage by optimizing compilers.%
\footnote{
Compilers may take advantage of inlining, constant propagation, loop fusion,
tracking of pointers obtained from
\tcode{operator new},
and other
techniques to generate efficient
\tcode{valarray}s.
}

\pnum
The reference returned by the subscript operator for a non-constant array is
guaranteed to be valid until the member function
\tcode{resize(size_t, T)}\
(\ref{valarray.members}) is called for that array or until the lifetime of
that array ends, whichever happens first.

\pnum
If the subscript operator
is invoked with a
\tcode{size_t}\
argument whose value is not
less than the length of the array, the behavior is undefined.%
\index{undefined}
\end{itemdescr}

\rSec3[valarray.sub]{\tcode{valarray}\ subset operations}

\index{operator[]@\tcode{operator[]}!valarray@\tcode{valarray}}%
\begin{itemdecl}
valarray<T>       operator[](slice) const;
slice_array<T>    operator[](slice);
valarray<T>       operator[](const gslice&) const;
gslice_array<T>   operator[](const gslice&);
valarray<T>       operator[](const valarray<bool>&) const;
mask_array<T>     operator[](const valarray<bool>&);
valarray<T>       operator[](const valarray<size_t>&) const;
indirect_array<T> operator[](const valarray<size_t>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
Each of these operations returns a subset of the array.
The
\tcode{const}-qualified
versions return this subset as a new
\tcode{valarray}.
The
non-\tcode{const}
versions return a
class template object which has reference semantics to the original array.
\end{itemdescr}

\rSec3[valarray.unary]{\tcode{valarray}\ unary operators}

\index{operator+@\tcode{operator+}!\tcode{valarray}}%
\index{operator-@\tcode{operator-}!\tcode{valarray}}%
\index{operator\~{}@\tcode{operator\~{}}!\tcode{valarray}}%
\index{operator"!@\tcode{operator"!}!\tcode{valarray}}%
\begin{itemdecl}
@\addedConcepts{requires HasUnaryPlus<T> \&\& Convertible<T::result_type, T>}@ 
  valarray<T> operator+() const;
@\addedConcepts{requires HasNegate<T> \&\& Convertible<T::result_type, T>}@ 
  valarray<T> operator-() const;
@\addedConcepts{requires HasComplement<T> \&\& Convertible<T::result_type, T>}@ 
  valarray<T> operator~() const;
@\addedConcepts{requires HasLogicalNot<T>}@ valarray<bool> operator!() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Each of these operators may only be instantiated for a type \mbox{\farg{T}}\
to which the indicated operator can be applied and for which the indicated
operator returns a value which is of type \mbox{\farg{T}}\ (\mbox{\farg{bool}}\ for
\mbox{\farg{operator!}}) or which may be unambiguously converted to type
\mbox{\farg{T}}\ (\mbox{\farg{bool}} for \mbox{\farg{operator!}}).}

\pnum
Each of these operators returns an array whose length is equal to the length
of the array.
Each element of the returned array is initialized with the result of
applying the indicated operator to the corresponding element of the array.
\end{itemdescr}

\rSec3[valarray.cassign]{\tcode{valarray}\ computed assignment}

\index{operator*=@\tcode{operator*=}!valarray@\tcode{valarray}}%
\index{operator/=@\tcode{operator/=}!valarray@\tcode{valarray}}%
\index{operator\%=@\tcode{operator\%=}!valarray@\tcode{valarray}}%
\index{operator+=@\tcode{operator+=}!valarray@\tcode{valarray}}%
\index{operator-=@\tcode{operator-=}!valarray@\tcode{valarray}}%
\index{operator\^{}=@\tcode{operator\^{}=}!valarray@\tcode{valarray}}%
\index{operator\&=@\tcode{operator\&=}!valarray@\tcode{valarray}}%
\index{operator"|=@\tcode{operator"|=}!valarray@\tcode{valarray}}%
\index{operator<<=@\tcode{operator\shl=}!valarray@\tcode{valarray}}%
\index{operator>>=@\tcode{operator\shr=}!valarray@\tcode{valarray}}%
\begin{itemdecl}
@\addedConcepts{requires HasMultiplyAssign<T>}@   valarray<T>& operator*= (const valarray<T>&);
@\addedConcepts{requires HasDivideAssign<T>}@     valarray<T>& operator/= (const valarray<T>&);
@\addedConcepts{requires HasModulusAssign<T>}@    valarray<T>& operator%= (const valarray<T>&);
@\addedConcepts{requires HasPlusAssign<T>}@       valarray<T>& operator+= (const valarray<T>&);
@\addedConcepts{requires HasMinusAssign<T>}@      valarray<T>& operator-= (const valarray<T>&);
@\addedConcepts{requires HasBitXorAssign<T>}@     valarray<T>& operator^= (const valarray<T>&);
@\addedConcepts{requires HasBitAndAssign<T>}@     valarray<T>& operator&= (const valarray<T>&);
@\addedConcepts{requires HasBitOrAssign<T>}@      valarray<T>& operator|= (const valarray<T>&);
@\addedConcepts{requires HasLeftShiftAssign<T>}@  valarray<T>& operator<<=(const valarray<T>&);
@\addedConcepts{requires HasRightShiftAssign<T>}@ valarray<T>& operator>>=(const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Each of these operators may only be instantiated for a type \mbox{\farg{T}}\ 
to which the indicated operator can be applied.
Each of these operators
performs the indicated operation on each of its elements and the
corresponding element of the argument array.}

\pnum
The array is then returned by reference.

\pnum
If the array and the
argument array do not have the same length, the behavior is undefined.%
\index{undefined}\
The appearance of an array on the left-hand side of a computed assignment
does \farg{not}\ invalidate references or pointers.

\pnum
If the value of an element in the left-hand side of a valarray computed
assignment operator depends on the value of another element in that left
hand side, the resulting behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires HasMultiplyAssign<T>}@   valarray<T>& operator*= (const T&);
@\addedConcepts{requires HasDivideAssign<T>}@     valarray<T>& operator/= (const T&);
@\addedConcepts{requires HasModulusAssign<T>}@    valarray<T>& operator%= (const T&);
@\addedConcepts{requires HasPlusAssign<T>}@       valarray<T>& operator+= (const T&);
@\addedConcepts{requires HasMinusAssign<T>}@      valarray<T>& operator-= (const T&);
@\addedConcepts{requires HasBitXorAssign<T>}@     valarray<T>& operator^= (const T&);
@\addedConcepts{requires HasBitAndAssign<T>}@     valarray<T>& operator&= (const T&);
@\addedConcepts{requires HasBitOrAssign<T>}@      valarray<T>& operator|= (const T&);
@\addedConcepts{requires HasLeftShiftAssign<T>}@  valarray<T>& operator<<=(const T&);
@\addedConcepts{requires HasRightShiftAssign<T>}@ valarray<T>& operator>>=(const T&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Each of these operators may only be instantiated for a type \mbox{\farg{T}}\ 
to which the indicated operator can be applied.}

\pnum
Each of these operators applies the indicated operation to each element
of the array and the non-array argument.

\pnum
The array is then returned by reference.

\pnum
The appearance of an array on the left-hand side of a computed assignment
does
\textit{not}\ 
invalidate references or pointers to the elements of the array.
\end{itemdescr}

\rSec3[valarray.members]{\tcode{valarray}\ member functions}

\begin{itemdecl}
@\addedD{void swap(valarray\&\& v);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedD{\mbox{\effects} \mbox{\tcode{*this}} obtains the value of
\mbox{\tcode{v}}. \mbox{\tcode{v}} obtains the value of \mbox{\tcode{*this}}.}

\pnum
\addedD{\mbox{\complexity} Constant.}

\pnum
\addedD{\mbox{\throws} Nothing.}
\end{itemdescr}

\index{length@\tcode{length}!valarray@\tcode{valarray}}%
\begin{itemdecl}
size_t size() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function returns the number of elements in the array.
\end{itemdescr}

\index{sum@\tcode{sum}!valarray@\tcode{valarray}}%
\begin{itemdecl}
@\addedConcepts{requires HasPlusAssign<T>}@ T sum() const;
\end{itemdecl}

\begin{itemdescr}
\removedConcepts{This function may only be instantiated for a type \mbox{\farg{T}}\ to which
\mbox{\tcode{operator+=}}\
can be applied.}
This function returns the sum of all the elements of the array.

\pnum
If the array has length 0, the behavior is undefined.%
\index{undefined}
If the array has length 1,
\tcode{sum()}\
returns the value of element 0.
Otherwise, the returned value is calculated by applying
\tcode{operator+=}\
to a copy of an element of the array and
all other elements of the array in an unspecified order.%
\index{unspecified behavior}
\end{itemdescr}

\index{min@\tcode{min}!valarray@\tcode{valarray}}%
\begin{itemdecl}
@\addedConcepts{requires LessThanComparable<T>}@ T min() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function returns the minimum value contained in
\tcode{*this}.
The value returned for an array of length 0 is undefined.
For an array
of length 1, the value of element 0 is returned.
For all other array
lengths, the determination is made using
\tcode{operator<}.
\end{itemdescr}

\index{max@\tcode{max}!valarray@\tcode{valarray}}%
\begin{itemdecl}
@\addedConcepts{requires LessThanComparable<T>}@ T max() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function returns the maximum value contained in
\tcode{*this}.
The value returned for an array of length 0 is undefined.
For an array
of length 1, the value of element 0 is returned.
For all other array
lengths, the determination is made using
\tcode{operator<}.
\end{itemdescr}

\index{shift@\tcode{shift}!valarray@\tcode{valarray}}%
\begin{itemdecl}
valarray<T> shift(int @\farg{n}@) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function returns an object of class
\tcode{valarray<T>}\
of length
\tcode{size()},
each of whose elements
\textit{I}\ 
is
\tcode{(*this)[\farg{I}\ + \farg{n}]}
if
\tcode{\farg{I}\ + \farg{n}}
is non-negative and less than
\tcode{size()},
otherwise
\tcode{T()}.
Thus if element zero is taken as the leftmost element,
a positive value of \farg{n}\ shifts the elements left \farg{n}\
places, with zero fill.

\pnum
\enterexample\ 
If the argument has the value -2,
the first two elements of the result will be constructed using the default
constructor; the third element of the result will be assigned the value
of the first element of the argument; etc.
\exitexample\ 
\index{cshift@\tcode{cshift}!valarray@\tcode{valarray}}%
\begin{itemdecl}
valarray<T> cshift(int @\farg{n}@) const;
\end{itemdecl}

\pnum
This function returns an object of class
\tcode{valarray<T>},
of length
\tcode{size()},
each of whose elements
\textit{I}\ 
is
\tcode{(*this)[(\farg{I}\ + \farg{n}) \% size()]}.
Thus, if element zero is taken as the leftmost element,
a positive value of \farg{n}\ shifts the elements circularly
left \farg{n}\ places.
\end{itemdescr}

\index{apply@\tcode{apply}!valarray@\tcode{valarray}}%
\begin{itemdecl}
valarray<T> apply(T func(T)) const;
valarray<T> apply(T func(const T&)) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These functions return an array whose length is equal to the array.
Each element of the returned array is assigned
the value returned by applying the argument function to the
corresponding element of the array.

\index{resize@\tcode{resize}!valarray@\tcode{valarray}}%
\begin{itemdecl}
void resize(size_t sz, T c = T());
\end{itemdecl}

\pnum
This member function changes the length of the
\tcode{*this}\
array to
\tcode{sz}\
and then assigns to each element the value of the second argument.
Resizing invalidates all pointers and references to elements in the array.
\end{itemdescr}

\rSec2[valarray.nonmembers]{\tcode{valarray} non-member operations}

\rSec3[valarray.binary]{\tcode{valarray}\ binary operators}

\index{operator*@\tcode{operator*}!valarray@\tcode{valarray}}%
\index{operator/@\tcode{operator/}!valarray@\tcode{valarray}}%
\index{operator\%@\tcode{operator\%}!valarray@\tcode{valarray}}%
\index{operator+@\tcode{operator+}!valarray@\tcode{valarray}}%
\index{operator-@\tcode{operator-}!valarray@\tcode{valarray}}%
\index{operator\^{}@\tcode{operator\^{}}!valarray@\tcode{valarray}}%
\index{operator\&@\tcode{operator\&}!valarray@\tcode{valarray}}%
\index{operator"|@\tcode{operator"|}!valarray@\tcode{valarray}}%
\index{operator<<@\tcode{operator\shl}!valarray@\tcode{valarray}}%
\index{operator>>@\tcode{operator\shr}!valarray@\tcode{valarray}}%
\index{operator\&\&@\tcode{operator\&\&}!valarray@\tcode{valarray}}%
\index{operator||@\tcode{operator||}!valarray@\tcode{valarray}}%
\begin{itemdecl}
template<class T> 
  @\addedConcepts{requires HasMultiply<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator*(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasDivide<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator/(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasModulus<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator%(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasPlus<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator+(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasMinus<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator-(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasBitXor<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator^(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasBitAnd<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator&(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasBitOr<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator|(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasLeftShift<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator<<(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasRightShift<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator>>(const valarray<T>&, const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Each of these operators may only be instantiated for a type \mbox{\farg{T}}\ 
to which the indicated operator can be applied and for which the indicated
operator returns a value which is of type \mbox{\farg{T}}\ or which
can be unambiguously converted to type \mbox{\farg{T}}.}

\pnum
Each of these operators returns an array whose length is equal to the
lengths of the argument arrays.
Each element of the returned array is
initialized with the result of applying the indicated operator to the
corresponding elements of the argument arrays.

\pnum
If the argument arrays do not have the same length, the behavior is undefined.%
\index{undefined}
\end{itemdescr}

\begin{itemdecl}
template<class T> 
  @\addedConcepts{requires HasMultiply<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator* (const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasMultiply<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator* (const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasDivide<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator/ (const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasDivide<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator/ (const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasModulus<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator% (const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasModulus<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator% (const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasPlus<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator+ (const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasPlus<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator+ (const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasMinus<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator- (const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasMinus<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator- (const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasBitXor<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator^ (const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasBitXor<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator^ (const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasBitAnd<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator& (const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasBitAnd<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator& (const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasBitOr<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator| (const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasBitOr<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator| (const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasLeftShift<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator<<(const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasLeftShift<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator<<(const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasRightShift<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator>>(const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasRightShift<T> \&\& Convertible<T::result_type, T>}@
  valarray<T> operator>>(const T&, const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Each of these operators may only be instantiated for a type \mbox{\farg{T}}\ 
to which the indicated operator can be applied and for which
the indicated operator returns a value which is of type \mbox{\farg{T}}\ 
or which can be unambiguously converted to type \mbox{\farg{T}}.}

\pnum
Each of these operators returns an array whose length is equal to the
length of the array argument.
Each element of the returned array is
initialized with the result of applying the indicated operator to the
corresponding element of the array argument and the non-array argument.
\end{itemdescr}

\rSec3[valarray.comparison]{\tcode{valarray}\ logical operators}

\index{operator==@\tcode{operator==}!valarray@\tcode{valarray}}%
\index{operator"!=@\tcode{operator"!=}!valarray@\tcode{valarray}}%
\index{operator<@\tcode{operator<}!valarray@\tcode{valarray}}%
\index{operator>@\tcode{operator>}!valarray@\tcode{valarray}}%
\index{operator<=@\tcode{operator<=}!valarray@\tcode{valarray}}%
\index{operator>=@\tcode{operator>=}!valarray@\tcode{valarray}}%
\index{operator\&\&@\tcode{operator\&\&}!valarray@\tcode{valarray}}%
\index{operator||@\tcode{operator||}!valarray@\tcode{valarray}}%
\begin{itemdecl}
template<class T> 
  @\addedConcepts{requires EqualityComparable<T>}@
  valarray<bool> operator==(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires EqualityComparable<T>}@
  valarray<bool> operator!=(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator<(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator>(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator<=(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator>=(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasLogicalAnd<T>}@
  valarray<bool> operator&&(const valarray<T>&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasLogicalOr<T>}@
  valarray<bool> operator||(const valarray<T>&, const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Each of these operators may only be instantiated for a type \mbox{\farg{T}}\ 
to which the indicated operator can be applied and for which
the indicated operator returns a value which is of type \mbox{\farg{bool}}\ 
or which can be unambiguously converted to type \mbox{\farg{bool}}.}

\pnum
Each of these operators returns a \farg{bool}\ array whose length
is equal to the length of the array arguments.
Each element of the returned
array is initialized with the result of applying the indicated
operator to the corresponding elements of the argument arrays.

\pnum
If the two array arguments do not have the same length,
the behavior is undefined.%
\index{undefined}
\end{itemdescr}

\begin{itemdecl}
template<class T> 
  @\addedConcepts{requires EqualityComparable<T>}@
  valarray<bool> operator==(const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires EqualityComparable<T>}@
  valarray<bool> operator==(const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires EqualityComparable<T>}@
  valarray<bool> operator!=(const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires EqualityComparable<T>}@
  valarray<bool> operator!=(const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator< (const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator< (const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator> (const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator> (const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator<=(const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator<=(const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator>=(const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires LessThanComparable<T>}@
  valarray<bool> operator>=(const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasLogicalAnd<T>}@
  valarray<bool> operator&&(const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasLogicalAnd<T>}@
  valarray<bool> operator&&(const T&, const valarray<T>&);
template<class T> 
  @\addedConcepts{requires HasLogicalOr<T>}@
  valarray<bool> operator||(const valarray<T>&, const T&);
template<class T> 
  @\addedConcepts{requires HasLogicalOr<T>}@
  valarray<bool> operator||(const T&, const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Each of these operators may only be instantiated for a type \mbox{\farg{T}}\ 
to which the indicated operator can be applied and for which
the indicated operator returns a value which is of type \mbox{\farg{bool}}\ 
or which can be unambiguously converted to type \mbox{\farg{bool}}.}

\pnum
Each of these operators returns a \farg{bool}\ array whose
length is equal to the length of the array argument.
Each element
of the returned array is initialized with the result of applying the
indicated operator to the corresponding element of the array and the non-array argument.
\end{itemdescr}

\rSec3[valarray.transcend]{\tcode{valarray}\ transcendentals}

\index{abs@\tcode{abs}}%
\index{acos@\tcode{acos}}%
\index{asin@\tcode{asin}}%
\index{atan@\tcode{atan}}%
\index{atan2@\tcode{atan2}}%
\index{cos@\tcode{cos}}%
\index{cosh@\tcode{cosh}}%
\index{exp@\tcode{exp}}%
\index{log@\tcode{log}}%
\index{log10@\tcode{log10}}%
\index{pow@\tcode{pow}}%
\index{sin@\tcode{sin}}%
\index{sinh@\tcode{sinh}}%
\index{sqrt@\tcode{sqrt}}%
\index{tan@\tcode{tan}}%
\index{tanh@\tcode{tanh}}%
\begin{itemdecl}
template<@\changedConcepts{class}{HasAbs}@ T> valarray<T> abs  (const valarray<T>&);
template<@\changedConcepts{class}{HasAcos}@ T> valarray<T> acos (const valarray<T>&);
template<@\changedConcepts{class}{HasAsin}@ T> valarray<T> asin (const valarray<T>&);
template<@\changedConcepts{class}{HasAtan}@ T> valarray<T> atan (const valarray<T>&);
template<@\changedConcepts{class}{HasAtan2}@ T> valarray<T> atan2
    (const valarray<T>&, const valarray<T>&);
template<@\changedConcepts{class}{HasAtan2}@ T> valarray<T> atan2(const valarray<T>&, const T&);
template<@\changedConcepts{class}{HasAtan2}@ T> valarray<T> atan2(const T&, const valarray<T>&);
template<@\changedConcepts{class}{HasCos}@ T> valarray<T> cos  (const valarray<T>&);
template<@\changedConcepts{class}{HasCosh}@ T> valarray<T> cosh (const valarray<T>&);
template<@\changedConcepts{class}{HasExp}@ T> valarray<T> exp  (const valarray<T>&);
template<@\changedConcepts{class}{HasLog}@ T> valarray<T> log  (const valarray<T>&);
template<@\changedConcepts{class}{HasLog10}@ T> valarray<T> log10(const valarray<T>&);
template<@\changedConcepts{class}{HasPow}@ T> valarray<T> pow
    (const valarray<T>&, const valarray<T>&);
template<@\changedConcepts{class}{HasPow}@ T> valarray<T> pow  (const valarray<T>&, const T&);
template<@\changedConcepts{class}{HasPow}@ T> valarray<T> pow  (const T&, const valarray<T>&);
template<@\changedConcepts{class}{HasSin}@ T> valarray<T> sin  (const valarray<T>&);
template<@\changedConcepts{class}{HasSinh}@ T> valarray<T> sinh (const valarray<T>&);
template<@\changedConcepts{class}{HasSqrt}@ T> valarray<T> sqrt (const valarray<T>&);
template<@\changedConcepts{class}{HasTan}@ T> valarray<T> tan  (const valarray<T>&);
template<@\changedConcepts{class}{HasTanh}@ T> valarray<T> tanh (const valarray<T>&);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removedConcepts{Each of these functions may only be instantiated for a type \mbox{\farg{T}}\ 
to which a unique function with the indicated name can be applied (unqualified).
This function shall return a value which is of type \mbox{\farg{T}}\ 
or which can be unambiguously converted to type \mbox{\farg{T}}.}
\addedConcepts{Each 
element of the returned array is initialized with the result of applying the indicated function to the non-array argument (if any) and corresponding 
element of the array argument or arguments.}
\end{itemdescr}

\rSec3[valarray.special]{\tcode{valarray}\ specialized algorithms}

\begin{itemdecl}
template <@\changedConcepts{class}{Semiregular}@ T> void swap(valarray<T>& x, valarray<T>& y);
template <@\changedConcepts{class}{Semiregular}@ T> void swap(valarray<T>&& x, valarray<T>& y);
template <@\changedConcepts{class}{Semiregular}@ T> void swap(valarray<T>& x, valarray<T>&& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedD{\mbox{\effects} \mbox{\tcode{x.swap(y)}}.}
\end{itemdescr}


\rSec2[class.slice]{Class \tcode{slice}}

\rSec2[template.slice.array]{Class template \tcode{slice_array}}

\index{slice_array@\tcode{slice_array}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{Semiregular}@ T> class slice_array {
  public:
    typedef T value_type;

    void operator=  (const valarray<T>&) const;
    @\addedConcepts{requires HasMultiplyAssign<T>}@   void operator*= (const valarray<T>&) const;
    @\addedConcepts{requires HasDivideAssign<T>}@     void operator/= (const valarray<T>&) const;
    @\addedConcepts{requires HasModulusAssign<T>}@    void operator%= (const valarray<T>&) const;
    @\addedConcepts{requires HasPlusAssign<T>}@       void operator+= (const valarray<T>&) const;
    @\addedConcepts{requires HasMinusAssign<T>}@      void operator-= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitXorAssign<T>}@     void operator^= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitAndAssign<T>}@     void operator&= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitOrAssign<T>}@      void operator|= (const valarray<T>&) const;
    @\addedConcepts{requires HasLeftShiftAssign<T>}@  void operator<<=(const valarray<T>&) const;
    @\addedConcepts{requires HasRightShiftAssign<T>}@ void operator>>=(const valarray<T>&) const;

    slice_array(const slice_array&);
   ~slice_array();
    slice_array& operator=(const slice_array&);
    void operator=(const T&) const;
  private:
    slice_array();
  };
}
\end{codeblock}

\pnum
The
\tcode{slice_array}\
template is a helper template used by the
\tcode{slice}\
subscript operator

\begin{codeblock}
slice_array<T> valarray<T>::operator[](slice);
\end{codeblock}

It has reference semantics to a subset of an array specified by a
\tcode{slice}
object.

\pnum
\enterexample\ 
The expression
\tcode{a[slice(1, 5, 3)] = b;}\
has the effect of assigning the elements of
\tcode{b}\
to a slice of the elements in
\tcode{a}.
For the slice shown, the elements
selected from
\tcode{a}\
are 1, 4, ..., 13.
\exitexample\ 

\rSec3[cons.slice.arr]{\tcode{slice_array}\ constructors}

\index{slice_array@\tcode{slice_array}!\tcode{slice_array}}%
\begin{itemdecl}
slice_array();
\end{itemdecl}

\begin{itemdescr}
\pnum
This constructor is declared to be private.
This constructor need not be defined.
\end{itemdescr}

\rSec3[slice.arr.assign]{\tcode{slice_array}\ assignment}

\index{operator=@\tcode{operator=}!\tcode{slice_array}}%
\begin{itemdecl}
void         operator=(const valarray<T>&) const;
slice_array& operator=(const slice_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
These assignment operators have reference semantics,
assigning the values of the argument array elements to selected
elements of the
\tcode{valarray<T>}\
object to which the
\tcode{slice_array}\
object refers.
\end{itemdescr}

\rSec3[slice.arr.comp.assign]{\tcode{slice_array}\ computed assignment}

\index{operator*=@\tcode{operator*=}!\tcode{slice_array}}%
\index{operator/=@\tcode{operator/=}!\tcode{slice_array}}%
\index{operator\%=@\tcode{operator\%=}!\tcode{slice_array}}%
\index{operator+=@\tcode{operator+=}!\tcode{slice_array}}%
\index{operator-=@\tcode{operator-=}!\tcode{slice_array}}%
\index{operator\^{}=@\tcode{operator\^{}=}!\tcode{slice_array}}%
\index{operator\&=@\tcode{operator\&=}!\tcode{slice_array}}%
\index{operator"|=@\tcode{operator"|=}!\tcode{slice_array}}%
\index{operator<<=@\tcode{operator\shl=}!\tcode{slice_array}}%
\index{operator>>=@\tcode{operator\shr=}!\tcode{slice_array}}%
\begin{itemdecl}
@\addedConcepts{requires HasMultiplyAssign<T>}@   void operator*= (const valarray<T>&) const;
@\addedConcepts{requires HasDivideAssign<T>}@     void operator/= (const valarray<T>&) const;
@\addedConcepts{requires HasModulusAssign<T>}@    void operator%= (const valarray<T>&) const;
@\addedConcepts{requires HasPlusAssign<T>}@       void operator+= (const valarray<T>&) const;
@\addedConcepts{requires HasMinusAssign<T>}@      void operator-= (const valarray<T>&) const;
@\addedConcepts{requires HasBitXorAssign<T>}@     void operator^= (const valarray<T>&) const;
@\addedConcepts{requires HasBitAndAssign<T>}@     void operator&= (const valarray<T>&) const;
@\addedConcepts{requires HasBitOrAssign<T>}@      void operator|= (const valarray<T>&) const;
@\addedConcepts{requires HasLeftShiftAssign<T>}@  void operator<<=(const valarray<T>&) const;
@\addedConcepts{requires HasRightShiftAssign<T>}@ void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These computed assignments have reference semantics, applying the
indicated operation to the elements of the argument array
and selected elements of the
\tcode{valarray<T>}\
object to which the
\tcode{slice_array}\
object refers.
\end{itemdescr}

\rSec3[slice.arr.fill]{\tcode{slice_array}\ fill function}

\index{fill@\tcode{fill}!\tcode{slice_array}}%
\begin{itemdecl}
void operator=(const T&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its argument
to the elements of the
\tcode{valarray<T>}\
object to which the
\tcode{slice_array}\
object refers.
\end{itemdescr}

\rSec2[class.gslice]{The \tcode{gslice}\ class}

\rSec2[template.gslice.array]{Class template \tcode{gslice_array}}

\index{gslice_array@\tcode{gslice_array}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{Semiregular}@ T> class gslice_array {
  public:
    typedef T value_type;

    void operator=  (const valarray<T>&) const;
    @\addedConcepts{requires HasMultiplyAssign<T>}@   void operator*= (const valarray<T>&) const;
    @\addedConcepts{requires HasDivideAssign<T>}@     void operator/= (const valarray<T>&) const;
    @\addedConcepts{requires HasModulusAssign<T>}@    void operator%= (const valarray<T>&) const;
    @\addedConcepts{requires HasPlusAssign<T>}@       void operator+= (const valarray<T>&) const;
    @\addedConcepts{requires HasMinusAssign<T>}@      void operator-= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitXorAssign<T>}@     void operator^= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitAndAssign<T>}@     void operator&= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitOrAssign<T>}@      void operator|= (const valarray<T>&) const;
    @\addedConcepts{requires HasLeftShiftAssign<T>}@  void operator<<=(const valarray<T>&) const;
    @\addedConcepts{requires HasRightShiftAssign<T>}@ void operator>>=(const valarray<T>&) const;

    gslice_array(const gslice_array&);
   ~gslice_array();
    gslice_array& operator=(const gslice_array&);
    void operator=(const T&) const;
  private:
    gslice_array();
  };
}
\end{codeblock}

\pnum
This template is a helper template used by the
\tcode{slice}\
subscript operator

\index{gslice_array@\tcode{gslice_array}}%
\index{valarray@\tcode{valarray}}%
\begin{itemdecl}
gslice_array<T> valarray<T>::operator[](const gslice&);
\end{itemdecl}

\begin{itemdescr}
\pnum
It has reference semantics to a subset of an array specified by a
\tcode{gslice}\
object.

\pnum
Thus, the expression
\tcode{a[gslice(1, length, stride)] = b}\
has the effect of assigning the elements of
\tcode{b}\
to a
generalized slice of the elements in
\tcode{a}.
\end{itemdescr}

\rSec3[gslice.array.cons]{\tcode{gslice_array}\ constructors}

\index{gslice_array@\tcode{gslice_array}!\tcode{gslice_array}}%
\begin{itemdecl}
gslice_array();
\end{itemdecl}

\begin{itemdescr}
\pnum
This constructor is declared to be private.
This constructor need not be defined.
\end{itemdescr}

\rSec3[gslice.array.assign]{\tcode{gslice_array}\ assignment}

\index{operator=@\tcode{operator=}!\tcode{gslice_array}}%
\begin{itemdecl}
void operator=(const valarray<T>&) const;
gslice_array& operator=(const gslice_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
These assignment operators have reference semantics, assigning the values
of the argument array elements to selected elements of the
\tcode{valarray<T>}\
object to which the
\tcode{gslice_array}\
refers.
\end{itemdescr}

\rSec3[gslice.array.comp.assign]{\tcode{gslice_array}}

\index{operator*=@\tcode{operator*=}!\tcode{gslice_array}}%
\index{operator/=@\tcode{operator/=}!\tcode{gslice_array}}%
\index{operator\%=@\tcode{operator\%=}!\tcode{gslice_array}}%
\index{operator+=@\tcode{operator+=}!\tcode{gslice_array}}%
\index{operator-=@\tcode{operator-=}!\tcode{gslice_array}}%
\index{operator\^{}=@\tcode{operator\^{}=}!\tcode{gslice_array}}%
\index{operator\&=@\tcode{operator\&=}!\tcode{gslice_array}}%
\index{operator"|=@\tcode{operator"|=}!\tcode{gslice_array}}%
\index{operator<<=@\tcode{operator\shl=}!\tcode{gslice_array}}%
\index{operator>>=@\tcode{operator\shr=}!\tcode{gslice_array}}%
\begin{itemdecl}
@\addedConcepts{requires HasMultiplyAssign<T>}@   void operator*= (const valarray<T>&) const;
@\addedConcepts{requires HasDivideAssign<T>}@     void operator/= (const valarray<T>&) const;
@\addedConcepts{requires HasModulusAssign<T>}@    void operator%= (const valarray<T>&) const;
@\addedConcepts{requires HasPlusAssign<T>}@       void operator+= (const valarray<T>&) const;
@\addedConcepts{requires HasMinusAssign<T>}@      void operator-= (const valarray<T>&) const;
@\addedConcepts{requires HasBitXorAssign<T>}@     void operator^= (const valarray<T>&) const;
@\addedConcepts{requires HasBitAndAssign<T>}@     void operator&= (const valarray<T>&) const;
@\addedConcepts{requires HasBitOrAssign<T>}@      void operator|= (const valarray<T>&) const;
@\addedConcepts{requires HasLeftShiftAssign<T>}@  void operator<<=(const valarray<T>&) const;
@\addedConcepts{requires HasRightShiftAssign<T>}@ void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These computed assignments have reference semantics, applying the
indicated operation to the elements of the argument array and selected
elements of the
\tcode{valarray<T>}\
object to which the
\tcode{gslice_array}\
object refers.
\end{itemdescr}

\rSec3[gslice.array.fill]{\tcode{gslice_array}\ fill function}

\index{fill@\tcode{fill}!\tcode{gslice_array}}%
\begin{itemdecl}
void operator=(const T&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its argument
to the elements of the
\tcode{valarray<T>}\
object to which the
\tcode{gslice_array}\
object refers.
\end{itemdescr}

\rSec2[template.mask.array]{Class template \tcode{mask_array}}

\index{mask_array@\tcode{mask_array}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{Semiregular}@ T> class mask_array {
  public:
    typedef T value_type;

    void operator=  (const valarray<T>&) const;
    @\addedConcepts{requires HasMultiplyAssign<T>}@   void operator*= (const valarray<T>&) const;
    @\addedConcepts{requires HasDivideAssign<T>}@     void operator/= (const valarray<T>&) const;
    @\addedConcepts{requires HasModulusAssign<T>}@    void operator%= (const valarray<T>&) const;
    @\addedConcepts{requires HasPlusAssign<T>}@       void operator+= (const valarray<T>&) const;
    @\addedConcepts{requires HasMinusAssign<T>}@      void operator-= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitXorAssign<T>}@     void operator^= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitAndAssign<T>}@     void operator&= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitOrAssign<T>}@      void operator|= (const valarray<T>&) const;
    @\addedConcepts{requires HasLeftShiftAssign<T>}@  void operator<<=(const valarray<T>&) const;
    @\addedConcepts{requires HasRightShiftAssign<T>}@ void operator>>=(const valarray<T>&) const;

    mask_array(const mask_array&);
   ~mask_array();
    mask_array& operator=(const mask_array&);
    void operator=(const T&) const;
  private:
    mask_array();
  };
}
\end{codeblock}

\pnum
This template is a helper template used by the mask subscript operator:

\begin{itemdecl}
mask_array<T> valarray<T>::operator[](const valarray<bool>&).
\end{itemdecl}

\begin{itemdescr}
\pnum
It has reference semantics to a subset of an array specified by a boolean mask.
Thus, the expression
\tcode{a[mask] = b;}\
has the effect of assigning the elements of
\tcode{b}\
to the masked
elements in
\tcode{a}\
(those for which the corresponding element
in
\tcode{mask}\
is
\tcode{true}.)
\end{itemdescr}

\rSec3[mask.array.cons]{\tcode{mask_array}\ constructors}

\index{mask_array@\tcode{mask_array}!\tcode{mask_array}}%
\begin{itemdecl}
mask_array();
\end{itemdecl}

\begin{itemdescr}
\pnum
This constructor is declared to be private.
This constructor need not be defined.
\end{itemdescr}

\rSec3[mask.array.assign]{\tcode{mask_array}\ assignment}

\index{operator=@\tcode{operator=}!\tcode{mask_array}}%
\begin{itemdecl}
void operator=(const valarray<T>&) const;
mask_array& operator=(const mask_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
These assignment operators have reference semantics, assigning the values
of the argument array elements to selected elements of the
\tcode{valarray<T>}\
object to which it refers.
\end{itemdescr}

\rSec3[mask.array.comp.assign]{\tcode{mask_array}\ computed assignment}

\index{operator*=@\tcode{operator*=}!\tcode{mask_array}}%
\index{operator/=@\tcode{operator/=}!\tcode{mask_array}}%
\index{operator\%=@\tcode{operator\%=}!\tcode{mask_array}}%
\index{operator+=@\tcode{operator+=}!\tcode{mask_array}}%
\index{operator-=@\tcode{operator-=}!\tcode{mask_array}}%
\index{operator\^{}=@\tcode{operator\^{}=}!\tcode{mask_array}}%
\index{operator\&=@\tcode{operator\&=}!\tcode{mask_array}}%
\index{operator"|=@\tcode{operator"|=}!\tcode{mask_array}}%
\index{operator<<=@\tcode{operator\shl=}!\tcode{mask_array}}%
\index{operator>>=@\tcode{operator\shr=}!\tcode{mask_array}}%
\begin{itemdecl}
@\addedConcepts{requires HasMultiplyAssign<T>}@   void operator*= (const valarray<T>&) const;
@\addedConcepts{requires HasDivideAssign<T>}@     void operator/= (const valarray<T>&) const;
@\addedConcepts{requires HasModulusAssign<T>}@    void operator%= (const valarray<T>&) const;
@\addedConcepts{requires HasPlusAssign<T>}@       void operator+= (const valarray<T>&) const;
@\addedConcepts{requires HasMinusAssign<T>}@      void operator-= (const valarray<T>&) const;
@\addedConcepts{requires HasBitXorAssign<T>}@     void operator^= (const valarray<T>&) const;
@\addedConcepts{requires HasBitAndAssign<T>}@     void operator&= (const valarray<T>&) const;
@\addedConcepts{requires HasBitOrAssign<T>}@      void operator|= (const valarray<T>&) const;
@\addedConcepts{requires HasLeftShiftAssign<T>}@  void operator<<=(const valarray<T>&) const;
@\addedConcepts{requires HasRightShiftAssign<T>}@ void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These computed assignments have reference semantics, applying the
indicated operation to the elements of the argument array and selected elements
of the
\tcode{valarray<T>}\
object to which the mask object refers.
\end{itemdescr}

\rSec3[mask.array.fill]{\tcode{mask_array}\ fill function}

\index{fill@\tcode{fill}!\tcode{mask_array}}%
\begin{itemdecl}
void operator=(const T&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its
argument to the elements of the
\tcode{valarray<T>}\
object to which the
\tcode{mask_array}\
object refers.
\end{itemdescr}

\rSec2[template.indirect.array]{Class template \tcode{indirect_array}}

\index{indirect_array@\tcode{indirect_array}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{Semiregular}@ T> class indirect_array {
  public:
    typedef T value_type;

    void operator=  (const valarray<T>&) const;
    @\addedConcepts{requires HasMultiplyAssign<T>}@   void operator*= (const valarray<T>&) const;
    @\addedConcepts{requires HasDivideAssign<T>}@     void operator/= (const valarray<T>&) const;
    @\addedConcepts{requires HasModulusAssign<T>}@    void operator%= (const valarray<T>&) const;
    @\addedConcepts{requires HasPlusAssign<T>}@       void operator+= (const valarray<T>&) const;
    @\addedConcepts{requires HasMinusAssign<T>}@      void operator-= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitXorAssign<T>}@     void operator^= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitAndAssign<T>}@     void operator&= (const valarray<T>&) const;
    @\addedConcepts{requires HasBitOrAssign<T>}@      void operator|= (const valarray<T>&) const;
    @\addedConcepts{requires HasLeftShiftAssign<T>}@  void operator<<=(const valarray<T>&) const;
    @\addedConcepts{requires HasRightShiftAssign<T>}@ void operator>>=(const valarray<T>&) const;

    indirect_array(const indirect_array&);
   ~indirect_array();
    indirect_array& operator=(const indirect_array&);
    void operator=(const T&) const;
  private:
    indirect_array();
  };
}
\end{codeblock}

\pnum
This template is a helper template used by the indirect subscript operator

\begin{itemdecl}
indirect_array<T> valarray<T>::operator[](const valarray<size_t>&).
\end{itemdecl}

\begin{itemdescr}
\pnum
It has reference semantics to a subset of an array specified by an
\tcode{indirect_array}.
Thus the expression
\tcode{a[\brk{}indirect] = b;}\
has the effect of assigning the elements of
\tcode{b}\
to the elements in
\tcode{a}\
whose indices appear in
\tcode{indirect}.
\end{itemdescr}

\rSec3[indirect.array.cons]{\tcode{indirect_array}\ constructors}

\index{indirect_array@\tcode{indirect_array}!\tcode{indirect_array}}%
\begin{itemdecl}
indirect_array();
\end{itemdecl}

\begin{itemdescr}
\pnum
This constructor is declared to be private.
This constructor need not be defined.
\end{itemdescr}

\rSec3[indirect.array.assign]{\tcode{indirect_array}\ assignment}

\index{operator=@\tcode{operator=}!\tcode{indirect_array}}%
\begin{itemdecl}
void operator=(const valarray<T>&) const;
indirect_array& operator=(const indirect_array&);
\end{itemdecl}

\begin{itemdescr}
\pnum
These assignment operators have reference semantics, assigning the values
of the argument array elements to selected elements of the
\tcode{valarray<T>}\
object to which it refers.

\pnum
If the
\tcode{indirect_array}
specifies an element in the
\tcode{valarray<T>}\
object to which it refers more than once, the behavior is undefined.
\index{undefined}%

\pnum
\enterexample\ 
\begin{codeblock}
int addr[] = {2, 3, 1, 4, 4};
valarray<size_t> indirect(addr, 5);
valarray<double> a(0., 10), b(1., 5);
a[indirect] = b;
\end{codeblock}
results in undefined behavior since element 4 is specified twice in the
indirection.
\exitexample\ 
\end{itemdescr}

\rSec3[indirect.array.comp.assign]{\tcode{indirect_array}\ computed assignment}

\index{operator*=@\tcode{operator*=}!\tcode{indirect_array}}%
\index{operator*=@\tcode{operator*=}!\tcode{indirect_array}}%
\index{operator*=@\tcode{operator*=}!\tcode{indirect_array}}%
\index{operator/=@\tcode{operator/=}!\tcode{indirect_array}}%
\index{operator\%=@\tcode{operator\%=}!\tcode{indirect_array}}%
\index{operator+=@\tcode{operator+=}!\tcode{indirect_array}}%
\index{operator-=@\tcode{operator-=}!\tcode{indirect_array}}%
\index{operator\^{}=@\tcode{operator\^{}=}!\tcode{indirect_array}}%
\index{operator\&=@\tcode{operator\&=}!\tcode{indirect_array}}%
\index{operator"|=@\tcode{operator"|=}!\tcode{indirect_array}}%
\index{operator<<=@\tcode{operator\shl=}!\tcode{indirect_array}}%
\index{operator>>=@\tcode{operator\shr=}!\tcode{indirect_array}}%
\begin{itemdecl}
@\addedConcepts{requires HasMultiplyAssign<T>}@   void operator*= (const valarray<T>&) const;
@\addedConcepts{requires HasDivideAssign<T>}@     void operator/= (const valarray<T>&) const;
@\addedConcepts{requires HasModulusAssign<T>}@    void operator%= (const valarray<T>&) const;
@\addedConcepts{requires HasPlusAssign<T>}@       void operator+= (const valarray<T>&) const;
@\addedConcepts{requires HasMinusAssign<T>}@      void operator-= (const valarray<T>&) const;
@\addedConcepts{requires HasBitXorAssign<T>}@     void operator^= (const valarray<T>&) const;
@\addedConcepts{requires HasBitAndAssign<T>}@     void operator&= (const valarray<T>&) const;
@\addedConcepts{requires HasBitOrAssign<T>}@      void operator|= (const valarray<T>&) const;
@\addedConcepts{requires HasLeftShiftAssign<T>}@  void operator<<=(const valarray<T>&) const;
@\addedConcepts{requires HasRightShiftAssign<T>}@ void operator>>=(const valarray<T>&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
These computed assignments have reference semantics, applying the indicated
operation to the elements of the argument array and selected elements of the
\tcode{valarray<T>}\
object to which the
\tcode{indirect_array}\
object refers.

\pnum
If the
\tcode{indirect_array}\
specifies an element in the
\tcode{valarray<T>}\
object to which it refers more than once,
the behavior is undefined.
\index{undefined}
\end{itemdescr}

\rSec3[indirect.array.fill]{\tcode{indirect_array}\ fill function}

\index{fill@\tcode{fill}!\tcode{indirect_array}}%
\begin{itemdecl}
void operator=(const T&) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
This function has reference semantics, assigning the value of its argument
to the elements of the
\tcode{valarray<T>}\
object to which the
\tcode{indirect_array}\
object refers.
\end{itemdescr}

\setcounter{section}{5}

\rSec1[numeric.ops]{Generalized numeric operations}

\synopsis{Header \tcode{<numeric>}\ synopsis}
\index{numeric@\tcode{<numeric>}}%

\color{addclr}
\begin{codeblock}
namespace std {
  template <InputIterator Iter, MoveConstructible T>
    requires HasPlus<T, Iter::reference>
          && HasAssign<T, HasPlus<T, Iter::reference>::result_type>
    T accumulate(Iter @\farg{first}@, Iter @\farg{last}@, T @\farg{init}@);
  template <InputIterator Iter, MoveConstructible T, 
            Callable<auto, const T&, Iter::reference> BinaryOperation>
    requires HasAssign<T, BinaryOperation::result_type>
          && CopyConstructible<BinaryOperation>
    T accumulate(Iter @\farg{first}@, Iter @\farg{last}@, T @\farg{init}@,
  	         BinaryOperation @\farg{binary_op}@);
  template <InputIterator Iter1, InputIterator Iter2, MoveConstructible T>
    requires HasMultiply<Iter1::reference, Iter2::reference>
          && HasPlus<T, HasMultiply<Iter1::reference, Iter2::reference>::result_type>
          && HasAssign<
               T, 
               HasPlus<T, 
                       HasMultiply<Iter1::reference, Iter2::reference>::result_type>::result_type>
    T inner_product(Iter1 @\farg{first1}@, Iter1 @\farg{last1}@,
  		    Iter2 @\farg{first2}@, T @\farg{init}@);
  template <InputIterator Iter1, InputIterator Iter2, MoveConstructible T,
  	    class BinaryOperation1, 
            Callable<auto, Iter1::reference, Iter2::reference> BinaryOperation2>
    requires Callable<BinaryOperation1, const T&, BinaryOperation2::result_type>
          && HasAssign<T, BinaryOperation1::result_type>
          && CopyConstructible<BinaryOperation1>
          && CopyConstructible<BinaryOperation2>
    T inner_product(Iter1 @\farg{first1}@, Iter1 @\farg{last1}@,
  		    Iter2 @\farg{first2}@, T @\farg{init}@,
  		    BinaryOperation1 @\farg{binary_op1}@,
  		    BinaryOperation2 @\farg{binary_op2}@);
  template <InputIterator InIter, OutputIterator<auto, const InIter::value_type&> OutIter>
    requires HasPlus<InIter::value_type, _InIter::reference>
          && HasAssign<InIter::value_type, 
                       HasPlus<InIter::value_type, _InIter::reference>::result_type>
          && Constructible<InIter::value_type, _InIter::reference>
    OutIter partial_sum(InIter @\farg{first}@, InIter @\farg{last}@,
  	  	        OutIter @\farg{result}@);
  template<InputIterator InIter, OutputIterator<auto, const InIter::value_type&> OutIter, 
           Callable<auto, const InIter::value_type&, InIter::reference> BinaryOperation>
    requires HasAssign<InIter::value_type, BinaryOperation::result_type>
          && Constructible<InIter::value_type, InIter::reference>
          && CopyConstructible<BinaryOperation>
    OutIter partial_sum(InIter @\farg{first}@, InIter @\farg{last}@,
       		        OutIter @\farg{result}@, BinaryOperation @\farg{binary_op}@);
  template <InputIterator InIter, OutputIterator<auto, const InIter::value_type&> OutIter>
    requires HasMinus<InIter::value_type, InIter::value_type>
          && Constructible<InIter::value_type, InIter::reference>
          && OutputIterator<OutIter, HasMinus<InIter::value_type, InIter::value_type>::result_type>
          && MoveAssignable<InIter::value_type> 
    OutIter adjacent_difference(InIter @\farg{first}@, InIter @\farg{last}@,
     			        OutIter @\farg{result}@);
  template <InputIterator InIter, OutputIterator<auto, const InIter::value_type&> OutIter, 
            Callable<auto, const InIter::value_type&, const InIter::value_type&> BinaryOperation>
    requires Constructible<_InIter::value_type, _InIter::reference>
          && OutputIterator<OutIter, BinaryOperation::result_type>
          && MoveAssignable<InIter::value_type>
          && CopyConstructible<BinaryOperation>
    OutIter adjacent_difference(InIter @\farg{first}@, InIter @\farg{last}@,
  			        OutIter @\farg{result}@,
    			        BinaryOperation @\farg{binary_op}@);

  template <ForwardIterator Iter, HasPreincrement T>
    requires OutputIterator<Iter, const T&>
    void iota(Iter @\farg{first}@, Iter @\farg{last}@, T @\farg{value}@);
\end{codeblock}
\color{black}

\pnum
The requirements on the types of algorithms' arguments that are
described in the introduction to clause \ref{algorithms}\ also
apply to the following algorithms.

\rSec2[accumulate]{Accumulate}

\color{addclr}
\index{accumulate@\tcode{accumulate}}%
\begin{itemdecl}
template <InputIterator Iter, MoveConstructible T>
  requires HasPlus<T, Iter::reference>
        && HasAssign<T, HasPlus<T, Iter::reference>::result_type>
  T accumulate(Iter @\farg{first}@, Iter @\farg{last}@, T @\farg{init}@);
template <InputIterator Iter, MoveConstructible T, 
          Callable<auto, const T&, Iter::reference> BinaryOperation>
  requires HasAssign<T, BinaryOperation::result_type>
        && CopyConstructible<BinaryOperation>
  T accumulate(Iter @\farg{first}@, Iter @\farg{last}@, T @\farg{init}@,
               BinaryOperation @\farg{binary_op}@);
\end{itemdecl}
\color{black}

\begin{itemdescr}
\pnum
\effects\ 
Computes its result by initializing the accumulator
\tcode{acc}\
with the initial value
\tcode{init}\
and then modifies it with
\tcode{acc = acc + *i}\
or
\tcode{acc = binary_op(acc, *i)}\
for every iterator
\tcode{i}\
in the range \range{first}{last}\
in order.%
\footnote{
\tcode{accumulate}\
is similar to the APL reduction operator and Common Lisp reduce function, but it avoids the
difficulty of defining the result of reduction on an empty sequence by always requiring an initial value.
}

\pnum
\requires\ 
\removedConcepts{T shall meet the requirements of CopyConstructible (20.1.3)
and Assignable (21.3) types.}
In the range
\crange{first}{last},
\tcode{binary_op}\
shall neither modify elements nor invalidate iterators or subranges.%
\footnote{The use of fully closed ranges is intentional
}
\end{itemdescr}

\rSec2[inner.product]{Inner product}
\index{inner_product@\tcode{inner_product}}%

\color{addclr}
\begin{itemdecl}
template <InputIterator Iter1, InputIterator Iter2, MoveConstructible T>
  requires HasMultiply<Iter1::reference, Iter2::reference>
        && HasPlus<T, HasMultiply<Iter1::reference, Iter2::reference>::result_type>
        && HasAssign<
             T, 
             HasPlus<T, 
                     HasMultiply<Iter1::reference, Iter2::reference>::result_type>::result_type>
  T inner_product(Iter1 @\farg{first1}@, Iter1 @\farg{last1}@,
		  Iter2 @\farg{first2}@, T @\farg{init}@);
template <InputIterator Iter1, InputIterator Iter2, MoveConstructible T,
          class BinaryOperation1, 
          Callable<auto, Iter1::reference, Iter2::reference> BinaryOperation2>
  requires Callable<BinaryOperation1, const T&, BinaryOperation2::result_type>
        && HasAssign<T, BinaryOperation1::result_type>
        && CopyConstructible<BinaryOperation1>
        && CopyConstructible<BinaryOperation2>
  T inner_product(Iter1 @\farg{first1}@, Iter1 @\farg{last1}@,
		  Iter2 @\farg{first2}@, T @\farg{init}@,
		  BinaryOperation1 @\farg{binary_op1}@,
		  BinaryOperation2 @\farg{binary_op2}@);
\end{itemdecl}
\color{black}

\begin{itemdescr}
\pnum
\effects\ 
Computes its result by initializing the accumulator
\tcode{acc}\
with the initial value
\tcode{init}\
and then modifying it with
\tcode{acc = acc + (*i1) * (*i2)}\
or
\tcode{acc = binary_op1(acc, binary_op2(*i1, *i2))}\
for every iterator
\tcode{i1}\
in the range \range{first}{last}\
and iterator
\tcode{i2}\
in the range
\range{first2}{first2 + (last - first)}
in order.

\pnum
\requires\ 
\removedConcepts{T shall meet the requirements of CopyConstructible (20.1.3)
and Assignable (21.3) types.}
In the ranges
\crange{first}{last}\
and
\crange{first2}{first2 + (last - first)}\
\tcode{binary_op1}\
and
\tcode{binary_op2}\
shall neither modify elements nor invalidate iterators or subranges.%
\footnote{The use of fully closed ranges is intentional
}
\end{itemdescr}

\rSec2[partial.sum]{Partial sum}
\index{partial_sum@\tcode{partial_sum}}%
\color{addclr}
\begin{itemdecl}
template <InputIterator InIter, OutputIterator<auto, const InIter::value_type&> OutIter>
  requires HasPlus<InIter::value_type, _InIter::reference>
        && HasAssign<InIter::value_type, 
                     HasPlus<InIter::value_type, _InIter::reference>::result_type>
        && Constructible<InIter::value_type, _InIter::reference>
  OutIter partial_sum(InIter @\farg{first}@, InIter @\farg{last}@,
	  	      OutIter @\farg{result}@);
template<InputIterator InIter, OutputIterator<auto, const InIter::value_type&> OutIter, 
         Callable<auto, const InIter::value_type&, InIter::reference> BinaryOperation>
  requires HasAssign<InIter::value_type, BinaryOperation::result_type>
        && Constructible<InIter::value_type, InIter::reference>
        && CopyConstructible<BinaryOperation>
  OutIter partial_sum(InIter @\farg{first}@, InIter @\farg{last}@,
    		      OutIter @\farg{result}@, BinaryOperation @\farg{binary_op}@);
\end{itemdecl}
\color{black}

\begin{itemdescr}
\pnum
\effects\ 
Assigns to every element referred to by iterator
\tcode{i}\
in the range
\range{result}{result + (last - first)}
a value
correspondingly equal to

\begin{codeblock}
((...(*first + *(first + 1)) + ...) + *(first + (i - result)))
\end{codeblock}

or

\begin{codeblock}
binary_op(binary_op(...,
    binary_op(*first, *(first + 1)),...), *(first + (i - result)))
\end{codeblock}

\pnum
\returns\ 
\tcode{result + (last - first)}.

\pnum
\complexity\ 
Exactly
\tcode{(last - first) - 1}\
applications of
\tcode{binary_op}.

\pnum
\requires\ 
In the ranges
\crange{first}{last}\
and
\crange{result}{result + (last - first)}\
\tcode{binary_op}\
shall neither modify elements nor invalidate iterators or subranges.%
\footnote{The use of fully closed ranges is intentional.
}

\pnum
\notes\ 
\tcode{result}\
may be equal to
\tcode{first}.
\end{itemdescr}

\rSec2[adjacent.difference]{Adjacent difference}

\index{adjacent_difference@\tcode{adjacent_difference}}%
\color{addclr}
\begin{itemdecl}
template <InputIterator InIter, OutputIterator<auto, const InIter::value_type&> OutIter>
  requires HasMinus<InIter::value_type, InIter::value_type>
        && Constructible<InIter::value_type, InIter::reference>
        && OutputIterator<OutIter, HasMinus<InIter::value_type, InIter::value_type>::result_type>
        && MoveAssignable<InIter::value_type> 
  OutIter adjacent_difference(InIter @\farg{first}@, InIter @\farg{last}@,
   			      OutIter @\farg{result}@);
template <InputIterator InIter, OutputIterator<auto, const InIter::value_type&> OutIter, 
          Callable<auto, const InIter::value_type&, const InIter::value_type&> BinaryOperation>
  requires Constructible<_InIter::value_type, _InIter::reference>
        && OutputIterator<OutIter, BinaryOperation::result_type>
        && MoveAssignable<InIter::value_type>
        && CopyConstructible<BinaryOperation>
  OutIter adjacent_difference(InIter @\farg{first}@, InIter @\farg{last}@,
			      OutIter @\farg{result}@,
  			      BinaryOperation @\farg{binary_op}@);
\end{itemdecl}
\color{black}

\begin{itemdescr}
\pnum
\effects\ 
Assigns to every element referred to by iterator
\tcode{i}\
in the range
\range{result + 1}{result + (last - first)}
a value correspondingly equal to

\begin{codeblock}
*(first + (i - result)) - *(first + (i - result) - 1)
\end{codeblock}

or

\begin{codeblock}
binary_op(*(first + (i - result)), *(first + (i - result) - 1)).
\end{codeblock}

\tcode{result}
gets the value of
\tcode{*first}.

\pnum
\requires\ 
In the ranges
\crange{first}{last}\
and
\crange{result}{result + (last - first)},
\tcode{binary_op}\
shall neither modify elements nor invalidate iterators or subranges.%
\footnote{The use of fully closed ranges is intentional.
}

\pnum
\notes\ 
\tcode{result}\
may be equal to
\tcode{first}.

\pnum
\returns\ 
\tcode{result + (last - first)}.

\pnum
\complexity\ 
Exactly
\tcode{(last - first) - 1}\
applications of
\tcode{binary_op}.
\end{itemdescr}

\rSec2[numeric.iota]{Iota}
\index{iota@\tcode{iota}}%
\color{addclr}\begin{itemdecl}
template <ForwardIterator Iter, HasPreincrement T>
  requires OutputIterator<Iter, const T&>
  void iota(Iter @\farg{first}@, Iter @\farg{last}@, T @\farg{value}@);
\end{itemdecl}\color{black}

\begin{itemdescr}
\pnum
\removedConcepts{\requires 
\mbox{\tcode{T}} shall meet the requirements of \mbox{\tcode{CopyConstructible}} and \mbox{\tcode{Assignable}} types, and shall be convertible to \mbox{\tcode{ForwardIterator}}'s value type. The expression \mbox{\tcode{++val}}, where \mbox{\tcode{val}} has type \mbox{\tcode{T}}, shall be well formed.}

\pnum
\effects\
For each element referred to by the iterator \tcode{i} in the range \tcode{[first,last)}, assigns \tcode{*i = value} and increments value as if by \tcode{++value}.

\pnum
\complexity\
Exactly \tcode{last - first} increments and assignments.
\end{itemdescr}

\end{paras}

\section*{Acknowledgments}
Daniel Kr\"ugler provided conceptualized
versions of \tcode{iota} in N2666.

\bibliographystyle{plain}
\bibliography{local}

\end{document}