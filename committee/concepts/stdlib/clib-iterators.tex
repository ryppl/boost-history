\documentclass[american,twoside]{book}
\usepackage{refbib}
\usepackage{pdfsync}
\input{macros}

%%--------------------------------------------------
%% PDF

\usepackage[pdftex,
            pdftitle={Concepts for the C++0x Standard Library: Iterators},
            pdfsubject={C++ International Standard Proposal},
            pdfcreator={Douglas Gregor},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}

%%--------------------------------------------------
%% Set section numbering limit, toc limit
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{1}

%%--------------------------------------------------
%% Parameters that govern document appearance
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.6in}

\newcommand{\resetcolor}{\textcolor{addclr}{}}

%%--------------------------------------------------
%% Handle special hyphenation rules
\hyphenation{tem-plate ex-am-ple in-put-it-er-a-tor}

% Do not put blank pages after chapters that end on odd-numbered pages.
\def\cleardoublepage{\clearpage\if@twoside%
  \ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage%
  \if@twocolumn\hbox{}\newpage\fi\fi\fi}

\begin{document}
\raggedbottom

\begin{titlepage}
\begin{center}
\huge
Concepts for the C++0x Standard Library: Iterators \\
(Revision 4)
\vspace{0.5in}

\normalsize
Douglas Gregor and Andrew Lumsdaine \\
\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}, \href{mailto:lums@osl.iu.edu}{lums@osl.iu.edu}
\end{center}

\vspace{1in}
\par\noindent Document number: D2777=08-0287 \vspace{-6pt}
\par\noindent Revises document number: N2734=08-0244 \vspace{-6pt}
\par\noindent Date: \today\vspace{-6pt}
\par\noindent Project: Programming Language \Cpp{}, Library Working Group\vspace{-6pt}
\par\noindent Reply-to: Douglas Gregor $<$\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}$>$\vspace{-6pt}

\section*{Introduction}
\libintrotext{24}

\paragraph*{Changes from N2734}
\begin{itemize}
\item Fixed the \tcode{HasMinus} requirement on
  \tcode{reverse_iterator}'s \tcode{operator-}.
\item When using \tcode{decltype} in the return type of one of the
  iterator adaptors' \tcode{operator-} operations, use the
  \tcode{base()} function rather than \tcode{current} to retrieve the
  underlying iterator.
\item Fixed support for move-only types in \tcode{back_insert_iterator}, \tcode{front_insert_iterator}, and \tcode{insert_iterator}.
\end{itemize}
\end{titlepage}

%% --------------------------------------------------
%% Headers and footers
\pagestyle{fancy}
\fancyhead[LE,RO]{\textbf{\rightmark}}
\fancyhead[RE]{\textbf{\leftmark\hspace{1em}\thepage}}
\fancyhead[LO]{\textbf{\thepage\hspace{1em}\leftmark}}
\fancyfoot[C]{Draft}

\fancypagestyle{plain}{
\renewcommand{\headrulewidth}{0in}
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\fancyfoot{}
}

\renewcommand{\sectionmark}[1]{\markright{\thesection\hspace{1em}#1}}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

\setcounter{chapter}{23}
\rSec0[iterators]{Iterators library}

\begin{paras}

\setcounter{Paras}{1}

\textcolor{black}{\pnum}
The following subclauses describe
iterator \changedConcepts{requirements}{concepts}, and
components for
iterator primitives,
predefined iterators,
and stream iterators,
as summarized in Table~\ref{tab:iterators.lib.summary}.

\begin{libsumtab}{Iterators library summary}{tab:iterators.lib.summary}
\ref{iterator.concepts} \changedConcepts{Requirements}{Concepts}            &      \addedConcepts{\tt <iterator_concepts>}                                   \\ \rowsep
\ref{depr.lib.iterator.primitives} Iterator primitives       &       \tcode{<iterator>}              \\
\ref{predef.iterators} Predefined iterators         &                                                       \\
\ref{stream.iterators} Stream iterators                     &                                                       \\
\end{libsumtab}

\rSec1[iterator.concepts]{Iterator concepts}
\editorial{The proposed wording for this section is in the separate proposal, ``Iterator Concepts for the C++0x Standard Library''.}

\rSec1[iterator.synopsis]{Header \tcode{<iterator>}\ synopsis}

\index{iterator@\tcode{<iterator>}}%
\begin{codeblock}
namespace std {
  // \ref{depr.lib.iterator.primitives}, primitives:
  template<class Iterator> struct iterator_traits;
  template<class T> struct iterator_traits<T*>;

  template<class Category, class T, class Distance = ptrdiff_t,
       class Pointer = T*, class Reference = T&> struct iterator;

  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };

  // \ref{iterator.operations}, iterator operations:
  template <@\changedConcepts{class InputIterator}{InputIterator Iter}@@\removedConcepts{, class Distance}@>
    void advance(@\changedConcepts{InputIterator}{Iter}@& i, @\changedConcepts{Distance}{Iter::difference_type}@ n);
  @\addedConcepts{template <BidirectionalIterator Iter>}@
    @\addedConcepts{void advance(Iter\& i, Iter::difference_type n);}@
  @\addedConcepts{template <RandomAccessIterator Iter>}@
    @\addedConcepts{void advance(Iter\& i, Iter::difference_type n);}@
  template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
    @\changedConcepts{typename iterator_traits<InputIterator>::difference_type}{Iter::difference_type}@
    distance(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
  @\addedConcepts{template <RandomAccessIterator Iter>}@
    @\addedConcepts{Iter::difference_type}@
    @\addedConcepts{distance(Iter first, Iter last);}@
  template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
    @\changedConcepts{InputIterator}{Iter}@ next(@\changedConcepts{InputIterator}{Iter}@ x,
      @\changedConcepts{typename std::iterator_traits<InputIterator>::difference_type}{Iter::difference_type}@ n = 1);
  template <@\changedConcepts{class BidirectionalIterator}{BidirectionalIterator Iter}@>
    @\changedConcepts{BidirectionalIterator}{Iter}@ prev(@\changedConcepts{BidirectionalIterator}{Iter}@ x,
      @\changedConcepts{typename std::iterator_traits<BidirectionalIterator>::difference_type}{Iter::difference_type}@ n = 1);

  // \ref{predef.iterators}, predefined iterators:
  template <@\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@> class reverse_iterator;

  template <@\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasEqualTo<Iter1, Iter2>}@
    bool operator==(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasGreater<Iter1, Iter2>}@
    bool operator<(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasNotEqualTo<Iter1, Iter2>}@
    bool operator!=(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLess<Iter1, Iter2>}@
    bool operator>(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLessEqual<Iter1, Iter2>}@
    bool operator>=(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasGreaterEqual<Iter1, Iter2>}@
    bool operator<=(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasMinus<Iter2, Iter1>}@
    auto operator-(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y) -> decltype(y.base() - x.base());
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iterator>
    reverse_iterator<Iter@\removedConcepts{ator}@> operator+(
      @\changedConcepts{typename reverse_iterator<Iterator>::difference_type}{Iter::difference_type}@ n,
      const reverse_iterator<Iter@\removedConcepts{ator}@>& x);

  @\addedConcepts{template<BidirectionalIterator Iter>}@
  @\addedConcepts{concept_map BidirectionalIterator<reverse_iterator<Iter> > \{ \}}@

  @\addedConcepts{template<RandomAccessIterator Iter>}@
  @\addedConcepts{concept_map RandomAccessIterator<reverse_iterator<Iter> > \{ \}}@

  template <@\changedConcepts{class}{BackInsertionContainer}@ Cont@\removedConcepts{ainer}@> class back_insert_iterator;
  template <@\changedConcepts{class}{BackInsertionContainer}@ Cont@\removedConcepts{ainer}@>
    back_insert_iterator<Cont@\removedConcepts{ainer}@> back_inserter(Cont@\removedConcepts{ainer}@& x);
  @\addedConcepts{template<BackInsertionContainer Cont>}@
    @\addedConcepts{concept_map Iterator<back_insert_iterator<Cont> > \{ \}}@

  template <@\changedConcepts{class}{FrontInsertionContainer}@ Cont@\removedConcepts{ainer}@> class front_insert_iterator;
  template <@\changedConcepts{class}{FrontInsertionContainer}@ Cont@\removedConcepts{ainer}@>
    front_insert_iterator<Cont@\removedConcepts{ainer}@> front_inserter(Cont@\removedConcepts{ainer}@& x);
  @\addedConcepts{template<FrontInsertionContainer Cont>}@
    @\addedConcepts{concept_map Iterator<front_insert_iterator<Cont> > \{ \}}@

  template <@\changedConcepts{class}{InsertionContainer}@ Cont@\removedConcepts{ainer}@> class insert_iterator;
  template <@\changedConcepts{class}{InsertionContainer}@ Cont@\removedConcepts{ainer}@>
    insert_iterator<Cont@\removedConcepts{ainer}@> inserter(Cont@\removedConcepts{ainer}@& x, Cont@\removedConcepts{ainer}@::iterator i);
  @\addedConcepts{template<InsertionContainer Cont>}@
    @\addedConcepts{concept_map Iterator<insert_iterator<Cont> > \{ \}}@

  template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@> class move_iterator;
  template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasEqualTo<Iter1, Iter2>}@
    bool operator==(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasEqualTo<Iter1, Iter2>}@
    bool operator!=(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLess<Iter1, Iter2>}@
    bool operator<(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLess<Iter2, Iter1>}@
    bool operator<=(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLess<Iter2, Iter1>}@
    bool operator>(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLess<Iter1, Iter2>}@
    bool operator>=(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);

  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasMinus<Iter1, Iter2>}@
    auto operator-(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, 
      const move_iterator<Iter@\removedConcepts{ator}@2>& y) -> decltype(x.base() - y.base());
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iterator>
    move_iterator<Iterator> operator+(
      @\changedConcepts{typename move_iterator<Iterator>}{Iter}@::difference_type n, const move_iterator<Iterator>& x);
  template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@>
    move_iterator<Iter@\removedConcepts{ator}@> make_move_iterator(const Iterator& i);
  @\addedConcepts{template<InputIterator Iter>}@
    @\addedConcepts{concept_map InputIterator<move_iterator<Iter> > \{ \}}@
  @\addedConcepts{template<ForwardIterator Iter>}@
    @\addedConcepts{concept_map ForwardIterator<move_iterator<Iter> > \{ \}}@
  @\addedConcepts{template<BidirectionalIterator Iter>}@
    @\addedConcepts{concept_map BidirectionalIterator<move_iterator<Iter> > \{ \}}@
  @\addedConcepts{template<RandomAccessIterator Iter>}@
    @\addedConcepts{concept_map RandomAccessIterator<move_iterator<Iter> > \{ \}}@

  // \ref{stream.iterators}, stream iterators:
  template <class T, class charT = char, class traits = char_traits<charT>,
      class Distance = ptrdiff_t>
  class istream_iterator;
  template <class T, class charT, class traits, class Distance>
    bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
            const istream_iterator<T,charT,traits,Distance>& y);
  template <class T, class charT, class traits, class Distance>
    bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
            const istream_iterator<T,charT,traits,Distance>& y);

  template <class T, class charT = char, class traits = char_traits<charT> >
      class ostream_iterator;

  template<class charT, class traits = char_traits<charT> >
    class istreambuf_iterator;
  template <class charT, class traits>
    bool operator==(const istreambuf_iterator<charT,traits>& @\farg{a}@,
            const istreambuf_iterator<charT,traits>& @\farg{b}@);
  template <class charT, class traits>
    bool operator!=(const istreambuf_iterator<charT,traits>& @\farg{a}@,
            const istreambuf_iterator<charT,traits>& @\farg{b}@);

  template <class charT, class traits = char_traits<charT> >
    class ostreambuf_iterator;
}
\end{codeblock}

\rSec1[iterator.primitives]{Iterator primitives}
\setcounter{subsection}{3}
\rSec2[iterator.operations]{Iterator operations}

\pnum
Since only random access iterators provide
\tcode{+}\
and
\tcode{-}\
operators, the library provides two
function templates
\tcode{advance}\
and
\tcode{distance}.
These
function templates
use
\tcode{+}\
and
\tcode{-}\
for random access iterators (and are, therefore, constant
time for them); for input, forward and bidirectional iterators they use
\tcode{++}\
to provide linear time
implementations.

\index{advance@\tcode{advance}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@@\removedConcepts{, class Distance}@>
  void advance(@\changedConcepts{InputIterator}{Iter}@& i, @\changedConcepts{Distance}{Iter::difference_type}@ n);
@\addedConcepts{template <BidirectionalIterator Iter>}@
  @\addedConcepts{void advance(Iter\& i, Iter::difference_type n);}@
@\addedConcepts{template <RandomAccessIterator Iter>}@
  @\addedConcepts{void advance(Iter\& i, Iter::difference_type n);}@
\end{itemdecl}

\editorial{Note that we have eliminated the \tcode{Distance} parameter
  in favor of the \tcode{difference_type} of the iterator, which more
  accurately reflects how the iterator can move.}

\begin{itemdescr}
\pnum
\requires\ 
\tcode{n}\
shall be negative only for bidirectional and random access iterators.

\pnum
\effects\ 
Increments (or decrements for negative
\tcode{n})
iterator reference
\tcode{i}\
by
\tcode{n}.
\end{itemdescr}

\index{distance@\tcode{distance}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\changedConcepts{typename iterator_traits<InputIterator>::difference_type}{Iter::difference_type}@
  distance(@\changedConcepts{InputIterator}{Iter}@ first, @\changedConcepts{InputIterator}{Iter}@ last);
@\addedConcepts{template <RandomAccessIterator Iter>}@
  @\addedConcepts{Iter::difference_type}@
  @\addedConcepts{distance(Iter first, Iter last);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Returns the number of increments or decrements needed to get from
\tcode{first}\
to
\tcode{last}.

\pnum
\requires\ 
\tcode{last}\
shall be reachable from
\tcode{first}.
\end{itemdescr}

\index{next@\tcode{next}}%
\begin{itemdecl}
template <@\changedConcepts{class InputIterator}{InputIterator Iter}@>
  @\changedConcepts{InputIterator}{Iter}@ next(@\changedConcepts{InputIterator}{Iter}@ x,
    @\changedConcepts{typename std::iterator_traits<InputIterator>::difference_type}{Iter::difference_type}@ n = 1);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{advance(x, n); return x;}
\end{itemdescr}

\index{prev@\tcode{prev}}%
\begin{itemdecl}
template <@\changedConcepts{class BidirectionalIterator}{BidirectionalIterator Iter}@>
  @\changedConcepts{BidirectionalIterator}{Iter}@ prev(@\changedConcepts{BidirectionalIterator}{Iter}@ x,
    @\changedConcepts{typename std::iterator_traits<BidirectionalIterator>::difference_type}{Iter::difference_type}@ n = 1);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{advance(x, -n); return x;}
\end{itemdescr}

\rSec1[predef.iterators]{Predefined iterators}

\rSec2[reverse.iterators]{Reverse iterators}

\pnum
Bidirectional and random access iterators have corresponding reverse iterator adaptors that iterate through
the data structure in the opposite direction.
They have the same signatures as the corresponding iterators.
The fundamental relation between a reverse iterator and its corresponding iterator
\tcode{i}\
is established by the identity:
\tcode{\&*(reverse_iterator(i)) == \&*(i - 1)}.

\pnum
This mapping is dictated by the fact that while there is always a pointer past the end of an array, there might
not be a valid pointer before the beginning of an array.

\rSec3[reverse.iterator]{Class template \tcode{reverse_iterator}}

\index{reverse_iterator@\tcode{reverse_iterator}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@>
  class reverse_iterator @\removedConcepts{: public}@
        @\removedConcepts{iterator<typename iterator_traits<Iterator>::iterator_category,}@
        @\removedConcepts{typename iterator_traits<Iterator>::value_type,}@
        @\removedConcepts{typename iterator_traits<Iterator>::difference_type,}@
        @\removedConcepts{typename iterator_traits<Iterator>::pointer,}@
        @\removedConcepts{typename iterator_traits<Iterator>::reference>}@ {
  protected:
    Iter@\removedConcepts{ator}@ current;
  public:
    typedef Iter@\removedConcepts{ator}@ iterator_type;
    @\addedConcepts{typedef Iter::value_type value_type;}@
    typedef @\changedConcepts{typename iterator_traits<Iterator>::difference_type}{Iter::difference_type}@ difference_type;
    typedef @\changedConcepts{typename iterator_traits<Iterator>::reference}{Iter::reference}@ reference;
    typedef @\changedConcepts{typename iterator_traits<Iterator>::pointer}{Iter::pointer}@ pointer;

    reverse_iterator();
    explicit reverse_iterator(Iter@\removedConcepts{ator}@ x);
    template <class U> 
      @\addedConcepts{requires HasConstructor<Iter, const U\&>}@ 
      reverse_iterator(const reverse_iterator<U>& u);
    template <class U> 
      @\addedConcepts{requires HasAssign<Iter, const U\&>}@
      reverse_iterator operator=(const reverse_iterator<U>& u);

    Iter@\removedConcepts{ator}@ base() const;      // explicit
    reference operator*() const;
    pointer   operator->() const;

    reverse_iterator& operator++();
    reverse_iterator  operator++(int);
    reverse_iterator& operator--();
    reverse_iterator  operator--(int);

    @\addedConcepts{requires RandomAccessIterator<Iter>}@ reverse_iterator  operator+ (difference_type n) const;
    @\addedConcepts{requires RandomAccessIterator<Iter>}@ reverse_iterator& operator+=(difference_type n);
    @\addedConcepts{requires RandomAccessIterator<Iter>}@ reverse_iterator  operator- (difference_type n) const;
    @\addedConcepts{requires RandomAccessIterator<Iter>}@ reverse_iterator& operator-=(difference_type n);
    @\addedConcepts{requires RandomAccessIterator<Iter>}@ @\unspec@ operator[](difference_type n) const;
  };

  template <@\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasEqualTo<Iter1, Iter2>}@
    bool operator==(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasGreater<Iter1, Iter2>}@
    bool operator<(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasNotEqualTo<Iter1, Iter2>}@
    bool operator!=(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLess<Iter1, Iter2>}@
    bool operator>(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLessEqual<Iter1, Iter2>}@
    bool operator>=(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasGreaterEqual<Iter1, Iter2>}@
    bool operator<=(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasMinus<Iter2, Iter1>}@
    auto operator-(
      const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
      const reverse_iterator<Iter@\removedConcepts{ator}@2>& y) -> decltype(y.base() - x.base());
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iterator>
    reverse_iterator<Iter@\removedConcepts{ator}@> operator+(
      @\changedConcepts{typename reverse_iterator<Iterator>::difference_type}{Iter::difference_type}@ n,
      const reverse_iterator<Iter@\removedConcepts{ator}@>& x);

  @\addedConcepts{template<BidirectionalIterator Iter>}@
  @\addedConcepts{concept_map BidirectionalIterator<reverse_iterator<Iter> > \{ \}}@

  @\addedConcepts{template<RandomAccessIterator Iter>}@
  @\addedConcepts{concept_map RandomAccessIterator<reverse_iterator<Iter> > \{ \}}@
}
\end{codeblock}

\rSec3[reverse.iter.requirements]{\tcode{reverse_iterator}\ requirements}

\editorial{Remove [reverse.iter.requirements]}

\pnum
\removedConcepts{The template parameter
\mbox{\tcode{Iterator}}
shall meet all the requirements of a Bidirectional Iterator (\mbox{\ref{bidirectional.iterators}}).}

\pnum
\removedConcepts{Additionally,
\mbox{\tcode{Iterator}}
shall meet the requirements of a Random Access Iterator (\mbox{\ref{random.access.iterators}})
if any of the members
\mbox{\tcode{operator+}}
(\mbox{\ref{reverse.iter.op+}}),
\mbox{\tcode{operator-}}
(\mbox{\ref{reverse.iter.op-}}),
\mbox{\tcode{operator+=}}
(\mbox{\ref{reverse.iter.op+=}}),
\mbox{\tcode{operator-=}}
(\mbox{\ref{reverse.iter.op-=}}),
\mbox{\tcode{operator\,[]}}
(\mbox{\ref{reverse.iter.opindex}}),
or the global operators
\mbox{\tcode{operator<}}
(\mbox{\ref{reverse.iter.op<}}),
\mbox{\tcode{operator>}}
(\mbox{\ref{reverse.iter.op>}}),
\mbox{\tcode{operator\,<=}}
(\mbox{\ref{reverse.iter.op<=}}),
\mbox{\tcode{operator>=}}
(\mbox{\ref{reverse.iter.op>=}}),
\mbox{\tcode{operator-}}
(\mbox{\ref{reverse.iter.opdiff}})
or
\mbox{\tcode{operator+}}
(\mbox{\ref{reverse.iter.opsum}}).
is referenced in a way that requires instantiation (\mbox{\ref{temp.inst}}).}

\rSec3[reverse.iter.ops]{\tcode{reverse_iterator}\ operations}

\rSec4[reverse.iter.cons]{\tcode{reverse_iterator}\ constructor}

\index{reverse_iterator@\tcode{reverse_iterator}!\tcode{reverse_iterator}}%
\begin{itemdecl}
reverse_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\
Default initializes
\tcode{current}.
Iterator operations applied to the resulting iterator have defined behavior
if and only if the corresponding operations are defined on a default
constructed iterator of type
\tcode{Iterator}.
\end{itemdescr}

\begin{itemdecl}
explicit reverse_iterator(Iter@\removedConcepts{ator}@ x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Initializes
\tcode{current}\
with \farg{x}.
\end{itemdescr}

\begin{itemdecl}
template <class U> 
  @\addedConcepts{requires HasConstructor<Iter, const U\&>}@ 
  reverse_iterator(const reverse_iterator<U> &u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Initializes
\tcode{current}\
with
\tcode{\farg{u}.current}.
\end{itemdescr}

\rSec4[reverse.iter.op=]{\tcode{reverse_iterator::operator=}}

\index{operator=@\tcode{operator=}!\tcode{reverse_iterator}}%
\begin{itemdecl}
template <class U>
  @\addedConcepts{requires HasAssign<Iter, const U\&>}@
  reverse_iterator&
    operator=(const reverse_iterator<U>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Assigns \tcode{u.base()} to current.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[reverse.iter.conv]{Conversion}

\index{conversion!reverse_iterator@\tcode{reverse_iterator}}%
\begin{itemdecl}
Iter@\removedConcepts{ator}@ base() const;          // explicit
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{current}.
\end{itemdescr}

\rSec4[reverse.iter.op.star]{\tcode{operator*}}

\index{operator*@\tcode{operator*}!\tcode{reverse_iterator}}%
\begin{itemdecl}
reference operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
this->tmp = current;
--this->tmp;
return *this->tmp;
\end{codeblock}

\pnum
\enternote\
This operation must use an auxiliary member variable, rather than a
temporary variable, to avoid returning a reference that persists beyond
the lifetime of its associated iterator.
(See \ref{iterator.requirements}.)
The name of this member variable is shown for exposition only.
\exitnote\
\end{itemdescr}

\rSec4[reverse.iter.opref]{\tcode{operator->}}

\index{operator->@\tcode{operator->}!\tcode{reverse_iterator}}%
\begin{itemdecl}
pointer operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
&(operator*());
\end{codeblock}
\end{itemdescr}

\rSec4[reverse.iter.op++]{\tcode{operator++}}

\index{operator++@\tcode{operator++}!\tcode{reverse_iterator}}%
\begin{itemdecl}
reverse_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\tcode{\dcr current;}

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
reverse_iterator operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
reverse_iterator tmp = *this;
--current;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[reverse.iter.op\dcr]{\tcode{operator\dcr}}

\index{operator\dcr@\tcode{operator\dcr}!\tcode{reverse_iterator}}%
\begin{itemdecl}
reverse_iterator& operator--();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\tcode{++current}

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
reverse_iterator operator--(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
reverse_iterator tmp = *this;
++current;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[reverse.iter.op+]{\tcode{operator+}}

\index{operator+@\tcode{operator+}!\tcode{reverse_iterator}}%
\begin{itemdecl}
@\addedConcepts{requires RandomAccessIterator<Iter>}@
reverse_iterator
operator+(@\removedConcepts{typename reverse_iterator<Iterator>::}@difference_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{reverse_iterator(current-n)}.
\end{itemdescr}

\rSec4[reverse.iter.op+=]{\tcode{operator+=}}

\index{operator+=@\tcode{operator+=}!\tcode{reverse_iterator}}%
\begin{itemdecl}
@\addedConcepts{requires RandomAccessIterator<Iter>}@
reverse_iterator&
operator+=(@\removedConcepts{typename reverse_iterator<Iterator>::}@difference_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\tcode{current -= n;}\

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\rSec4[reverse.iter.op-]{\tcode{operator-}}

\index{operator-@\tcode{operator-}!\tcode{reverse_iterator}}%
\begin{itemdecl}
@\addedConcepts{requires RandomAccessIterator<Iter>}@
reverse_iterator
operator-(@\removedConcepts{typename reverse_iterator<Iterator>::}@difference_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{reverse_iterator(current+n)}.
\end{itemdescr}

\rSec4[reverse.iter.op-=]{\tcode{operator-=}}

\index{operator-=@\tcode{operator-=}!\tcode{reverse_iterator}}%
\begin{itemdecl}
@\addedConcepts{requires RandomAccessIterator<Iter>}@
reverse_iterator&
operator-=(@\removedConcepts{typename reverse_iterator<Iterator>::}@difference_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\tcode{current += n;}\

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\rSec4[reverse.iter.opindex]{\tcode{operator[]}}

\index{operator[]@\tcode{operator[]}!reverse_iterator@\tcode{reverse_iterator}}%
\begin{itemdecl}
@\addedConcepts{requires RandomAccessIterator<Iter>}@
@\unspec@ operator[](
    @\removedConcepts{typename reverse_iterator<Iterator>::}@difference_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{current[-n-1]}.
\end{itemdescr}

\rSec4[reverse.iter.op==]{\tcode{operator==}}

\index{operator==@\tcode{operator==}!\tcode{reverse_iterator}}%
\begin{itemdecl}
template <@\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasEqualTo<Iter1, Iter2>}@
  bool operator==(
    const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
    const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.current == y.current}.
\end{itemdescr}

\rSec4[reverse.iter.op<]{\tcode{operator<}}

\index{operator<@\tcode{operator<}!\tcode{reverse_iterator}}%
\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasGreater<Iter1, Iter2>}@
  bool operator<(
    const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
    const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.current > y.current}.
\end{itemdescr}

\rSec4[reverse.iter.op!=]{\tcode{operator!=}}

\index{operator"!=@\tcode{operator"!=}!\tcode{reverse_iterator}}%
\begin{itemdecl}
template <@\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{BidirectionalIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasNotEqualTo<Iter1, Iter2>}@
  bool operator!=(
    const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
    const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.current != y.current}.
\end{itemdescr}

\rSec4[reverse.iter.op>]{\tcode{operator>}}

\index{operator>@\tcode{operator>}!\tcode{reverse_iterator}}%
\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasLess<Iter1, Iter2>}@
  bool operator>(
    const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
    const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.current < y.current}.
\end{itemdescr}

\rSec4[reverse.iter.op>=]{\tcode{operator>=}}

\index{operator>=@\tcode{operator>=}!\tcode{reverse_iterator}}%
\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasLessEqual<Iter1, Iter2>}@
  bool operator>=(
    const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
    const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.current <= y.current}.
\end{itemdescr}

\rSec4[reverse.iter.op<=]{\tcode{operator<=}}

\index{operator<=@\tcode{operator<=}!\tcode{reverse_iterator}}%
\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasGreaterEqual<Iter1, Iter2>}@
  bool operator<=(
    const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
    const reverse_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{x.current >= y.current}.
\end{itemdescr}

\rSec4[reverse.iter.opdiff]{\tcode{operator-}}

\index{operator-@\tcode{operator-}!\tcode{reverse_iterator}}%
\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasMinus<Iter2, Iter1>}@
  auto operator-(
    const reverse_iterator<Iter@\removedConcepts{ator}@1>& x,
    const reverse_iterator<Iter@\removedConcepts{ator}@2>& y) -> decltype(y.base() - x.base());
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{y.current - x.current}.
\end{itemdescr}

\rSec4[reverse.iter.opsum]{\tcode{operator+}}

\index{operator+@\tcode{operator+}!\tcode{reverse_iterator}}%
\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iterator>
  reverse_iterator<Iter@\removedConcepts{ator}@> operator+(
    @\changedConcepts{typename reverse_iterator<Iterator>::difference_type}{Iter::difference_type}@ n,
    const reverse_iterator<Iter@\removedConcepts{ator}@>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{reverse_iterator<Iter\removedConcepts{ator}> (x.current - n)}.
\end{itemdescr}

\rSec3[reverse.iter.maps]{Concept maps}
\begin{itemdecl}
@\addedConcepts{template<BidirectionalIterator Iter>}@
@\addedConcepts{concept_map BidirectionalIterator<reverse_iterator<Iter> > \{ \}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\reallynote This concept map template states that reverse iterators are themselves bidirectional iterators.}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{template<RandomAccessIterator Iter>}@
@\addedConcepts{concept_map RandomAccessIterator<reverse_iterator<Iter> > \{ \}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\reallynote This concept map template states that reverse iterators are themselves random access iterators when the underlying iterator is a random access iterator.}
\end{itemdescr}

\rSec2[insert.iterators]{Insert iterators}

\pnum
To make it possible to deal with insertion in the same way as writing into an array, a special kind of iterator
adaptors, called
\techterm{insert iterators},
are provided in the library.
With regular iterator classes,

\begin{codeblock}
while (first != last) *result++ = *first++;
\end{codeblock}

causes a range \range{first}{last}\
to be copied into a range starting with result.
The same code with
\tcode{result}\
being an insert iterator will insert corresponding elements into the container.
This device allows all of the
copying algorithms in the library to work in the
\techterm{insert mode}\ 
instead of the \techterm{regular overwrite}\ mode.

\pnum
An insert iterator is constructed from a container and possibly one of its iterators pointing to where
insertion takes place if it is neither at the beginning nor at the end of the container.
Insert iterators satisfy the requirements of output iterators.
\tcode{operator*}\
returns the insert iterator itself.
The assignment
\tcode{operator=(const T\& x)}\
is defined on insert iterators to allow writing into them, it inserts
\tcode{x}\
right before where the insert iterator is pointing.
In other words, an insert iterator is like a cursor pointing into the
container where the insertion takes place.
\tcode{back_insert_iterator}\
inserts elements at the end of a container,
\tcode{front_insert_iterator}\
inserts elements at the beginning of a container, and
\tcode{insert_iterator}\
inserts elements where the iterator points to in a container.
\tcode{back_inserter},
\tcode{front_inserter},
and
\tcode{inserter}\
are three
functions making the insert iterators out of a container.

\rSec3[back.insert.iterator]{Class template \tcode{back_insert_iterator}}

\index{back_insert_iterator@\tcode{back_insert_iterator}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{BackInsertionContainer}@ Cont@\removedConcepts{ainer}@>
  class back_insert_iterator @\removedConcepts{:}@
    @\removedConcepts{public iterator<output_iterator_tag,void,void,void,void>}@ {
  protected:
    Cont@\removedConcepts{ainer}@* container;

  public:
    typedef Cont@\removedConcepts{ainer}@ container_type;
    @\addedConcepts{typedef void                             value_type;}@
    @\addedConcepts{typedef void                             difference_type;}@
    @\addedConcepts{typedef back_insert_iterator<Cont>\&      reference;}@
    @\addedConcepts{typedef void                             pointer;}@

    explicit back_insert_iterator(Cont@\removedConcepts{ainer}@& x);
    @\addedConcepts{requires CopyConstructible<Cont::value_type>}@
      back_insert_iterator<Cont@\removedConcepts{ainer}@>&
        operator=(@\changedConcepts{typename}{const}@ Cont@\removedConcepts{ainer}@::@\changedConcepts{const_reference}{value_type\&}@ value);
    back_insert_iterator<Cont@\removedConcepts{ainer}@>&
      operator=(@\removedConcepts{typename }@Cont@\removedConcepts{ainer}@::value_type&& value);

    back_insert_iterator<Cont@\removedConcepts{ainer}@>& operator*();
    back_insert_iterator<Cont@\removedConcepts{ainer}@>& operator++();
    back_insert_iterator<Cont@\removedConcepts{ainer}@>  operator++(int);
  };

  template <@\changedConcepts{class}{BackInsertionContainer}@ Cont@\removedConcepts{ainer}@>
    back_insert_iterator<Cont@\removedConcepts{ainer}@> back_inserter(Cont@\removedConcepts{ainer}@& x);

  @\addedConcepts{template<BackInsertionContainer Cont>}@
    @\addedConcepts{concept_map Iterator<back_insert_iterator<Cont> > \{ \}}@
}
\end{codeblock}

\rSec3[back.insert.iter.ops]{\tcode{back_insert_iterator}\ operations}

\rSec4[back.insert.iter.cons]{\tcode{back_insert_iterator}\ constructor}

\index{back_insert_iterator@\tcode{back_insert_iterator}!\tcode{back_insert_iterator}}%
\begin{itemdecl}
explicit back_insert_iterator(Cont@\removedConcepts{ainer}@& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Initializes
\tcode{container}\
with \tcode{\&\farg{x}}.
\end{itemdescr}

\rSec4[back.insert.iter.op=]{\tcode{back_insert_iterator::operator=}}

\index{operator=@\tcode{operator=}!\tcode{back_insert_iterator}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<Cont::value_type>}@
  back_insert_iterator<Cont@\removedConcepts{ainer}@>&
    operator=(@\changedConcepts{typename}{const}@ Cont@\removedConcepts{ainer}@::@\changedConcepts{const_reference}{value_type\&}@ value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\tcode{\removedConcepts{container->}push_back(\addedConcepts{*container, Cont::value_type(}value\addedConcepts{)});}\

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\index{operator=@\tcode{operator=}!\tcode{back_insert_iterator}}%
\begin{itemdecl}
back_insert_iterator<Cont@\removedConcepts{ainer}@>&
  operator=(@\removedConcepts{typename }@Cont@\removedConcepts{ainer}@::value_type&& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{\removedConcepts{container->}push_back(\addedConcepts{*container, }std::move(value));}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[back.insert.iter.op*]{\tcode{back_insert_iterator::operator*}}

\index{operator*@\tcode{operator*}!\tcode{back_insert_iterator}}%
\begin{itemdecl}
back_insert_iterator<Cont@\removedConcepts{ainer}@>& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\rSec4[back.insert.iter.op++]{\tcode{back_insert_iterator::operator++}}

\index{operator++@\tcode{operator++}!\tcode{back_insert_iterator}}%
\begin{itemdecl}
back_insert_iterator<Cont@\removedConcepts{ainer}@>& operator++();
back_insert_iterator<Cont@\removedConcepts{ainer}@>  operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\rSec4[back.inserter]{\ \tcode{back_inserter}}

\index{back_inserter@\tcode{back_inserter}}%
\begin{itemdecl}
template <@\changedConcepts{class}{BackInsertionContainer}@ Cont@\removedConcepts{ainer}@>
  back_insert_iterator<Cont@\removedConcepts{ainer}@> back_inserter(Cont@\removedConcepts{ainer}@& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{back_insert_iterator<Cont@\removedConcepts{ainer}@>(x)}.
\end{itemdescr}

\rSec4[back.insert.iter.maps]{Concept maps}
\begin{itemdecl}
@\addedConcepts{template<BackInsertionContainer Cont>}@
  @\addedConcepts{concept_map Iterator<back_insert_iterator<Cont> > \{ \}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\reallynote Declares that \mbox{\tcode{back_insert_iterator}} is an iterator.}
\end{itemdescr}

\rSec3[front.insert.iterator]{Class template \tcode{front_insert_iterator}}

\index{front_insert_iterator@\tcode{front_insert_iterator}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{FrontInsertionContainer}@ Cont@\removedConcepts{ainer}@>
  class front_insert_iterator @\removedConcepts{:}@
    @\removedConcepts{public iterator<output_iterator_tag,void,void,void,void>}@ {
  protected:
    Cont@\removedConcepts{ainer}@* container;

  public:
    typedef Cont@\removedConcepts{ainer}@ container_type;
    @\addedConcepts{typedef void                              value_type;}@
    @\addedConcepts{typedef void                              difference_type;}@
    @\addedConcepts{typedef front_insert_iterator<Cont>\&      reference;}@
    @\addedConcepts{typedef void                              pointer;}@

    explicit front_insert_iterator(Cont@\removedConcepts{ainer}@& x);
    @\addedConcepts{requires CopyConstructible<Cont::value_type>}@
      front_insert_iterator<Cont@\removedConcepts{ainer}@>&
        operator=(@\changedConcepts{typename}{const}@ Cont@\removedConcepts{ainer}@::@\changedConcepts{const_reference}{value_type\&}@ value);
    front_insert_iterator<Cont@\removedConcepts{ainer}@>&
      operator=(@\removedConcepts{typename}@ Cont@\removedConcepts{ainer}@::value_type&& value);

    front_insert_iterator<Cont@\removedConcepts{ainer}@>& operator*();
    front_insert_iterator<Cont@\removedConcepts{ainer}@>& operator++();
    front_insert_iterator<Cont@\removedConcepts{ainer}@>  operator++(int);
  };

  template <@\changedConcepts{class}{FrontInsertionContainer}@ Cont@\removedConcepts{ainer}@>
    front_insert_iterator<Cont@\removedConcepts{ainer}@> front_inserter(Cont@\removedConcepts{ainer}@& x);

  @\addedConcepts{template<FrontInsertionContainer Cont>}@
    @\addedConcepts{concept_map Iterator<front_insert_iterator<Cont> > \{ \}}@
}
\end{codeblock}

\rSec3[front.insert.iter.ops]{\tcode{front_insert_iterator}\ operations}

\rSec4[front.insert.iter.cons]{\tcode{front_insert_iterator}\ constructor}

\index{front_insert_iterator@\tcode{front_insert_iterator}!\tcode{front_insert_iterator}}%
\begin{itemdecl}
explicit front_insert_iterator(Cont@\removedConcepts{ainer}@& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Initializes
\tcode{container}
with \tcode{\&}\farg{x}.
\end{itemdescr}

\rSec4[front.insert.iter.op=]{\tcode{front_insert_iterator::operator=}}

\index{operator=@\tcode{operator=}!\tcode{front_insert_iterator}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<Cont::value_type>}@
  front_insert_iterator<Cont@\removedConcepts{ainer}@>&
    operator=(@\changedConcepts{typename}{const}@ Cont@\removedConcepts{ainer}@::@\changedConcepts{const_reference}{value_type\&}@ value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\tcode{\removedConcepts{container->}push_front(\addedConcepts{*container, Cont::value_type(}value\addedConcepts{)});}\

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\index{operator=@\tcode{operator=}!\tcode{front_insert_iterator}}%
\begin{itemdecl}
front_insert_iterator<Cont@\removedConcepts{ainer}@>&
  operator=(@\removedConcepts{typename }@Cont@\removedConcepts{ainer}@::value_type&& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{\removedConcepts{container->}push_front(\addedConcepts{*container, }std::move(value));}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[front.insert.iter.op*]{\tcode{front_insert_iterator::operator*}}

\index{operator*@\tcode{operator*}!\tcode{front_insert_iterator}}%
\begin{itemdecl}
front_insert_iterator<Cont@\removedConcepts{ainer}@>& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\rSec4[front.insert.iter.op++]{\tcode{front_insert_iterator::operator++}}

\index{operator++@\tcode{operator++}!\tcode{front_insert_iterator}}%
\begin{itemdecl}
front_insert_iterator<Cont@\removedConcepts{ainer}@>& operator++();
front_insert_iterator<Cont@\removedConcepts{ainer}@>  operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\rSec4[front.inserter]{\tcode{front_inserter}}

\index{front_inserter@\tcode{front_inserter}}%
\begin{itemdecl}
template <@\changedConcepts{class}{FrontInsertionContainer}@ Cont@\removedConcepts{ainer}@>
  front_insert_iterator<Cont@\removedConcepts{ainer}@> front_inserter(Cont@\removedConcepts{ainer}@& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{front_insert_iterator<Cont@\removedConcepts{ainer}@>(x)}.
\end{itemdescr}

\rSec4[front.insert.iter.maps]{Concept maps}
\begin{itemdecl}
@\addedConcepts{template<FrontInsertionContainer Cont>}@
  @\addedConcepts{concept_map Iterator<front_insert_iterator<Cont> > \{ \}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\reallynote Declares that \mbox{\tcode{front_insert_iterator}} is an iterator.}
\end{itemdescr}

\rSec3[insert.iterator]{Class template \tcode{insert_iterator}}

\index{insert_iterator@\tcode{insert_iterator}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{InsertionContainer}@ Cont@\removedConcepts{ainer}@>
  class insert_iterator @\removedConcepts{:}@
    @\removedConcepts{public iterator<output_iterator_tag,void,void,void,void>}@ {
  protected:
    Cont@\removedConcepts{ainer}@* container;
    @\removedConcepts{typename }@Cont@\removedConcepts{ainer}@::iterator iter;

  public:
    typedef Cont@\removedConcepts{ainer}@ container_type;
    @\addedConcepts{typedef void                        value_type;}@
    @\addedConcepts{typedef void                        difference_type;}@
    @\addedConcepts{typedef insert_iterator<Cont>\&      reference;}@
    @\addedConcepts{typedef void                        pointer;}@

    insert_iterator(Cont@\removedConcepts{ainer}@& x, @\removedConcepts{typename }@Cont@\removedConcepts{ainer}@::iterator i);
    @\addedConcepts{requires CopyConstructible<Cont::value_type>}@
      insert_iterator<Cont@\removedConcepts{ainer}@>&
        operator=(@\changedConcepts{typename}{const}@ Cont@\removedConcepts{ainer}@::@\changedConcepts{const_reference}{value_type\&}@ value);
    insert_iterator<Cont@\removedConcepts{ainer}@>&
      operator=(@\removedConcepts{typename }@Cont@\removedConcepts{ainer}@::value_type&& value);

    insert_iterator<Cont@\removedConcepts{ainer}@>& operator*();
    insert_iterator<Cont@\removedConcepts{ainer}@>& operator++();
    insert_iterator<Cont@\removedConcepts{ainer}@>& operator++(int);
  };

  template <@\changedConcepts{class}{InsertionContainer}@ Cont@\removedConcepts{ainer}@>
    insert_iterator<Cont@\removedConcepts{ainer}@> inserter(Cont@\removedConcepts{ainer}@& x, Cont@\removedConcepts{ainer}@::iterator i);

  @\addedConcepts{template<InsertionContainer Cont>}@
    @\addedConcepts{concept_map Iterator<insert_iterator<Cont> > \{ \}}@
}
\end{codeblock}

\rSec3[insert.iter.ops]{\tcode{insert_iterator}\ operations}

\rSec4[insert.iter.cons]{\tcode{insert_iterator}\ constructor}

\index{insert_iterator@\tcode{insert_iterator}!\tcode{insert_iterator}}%
\begin{itemdecl}
insert_iterator(Cont@\removedConcepts{ainer}@& x, @\removedConcepts{typename}@ Cont@\removedConcepts{ainer}@::iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
Initializes
\tcode{container}\
with \farg{\&x} and
\tcode{iter}\
with \farg{i}.
\end{itemdescr}

\rSec4[insert.iter.op=]{\tcode{insert_iterator::operator=}}

\index{operator=@\tcode{operator=}!\tcode{insert_iterator}}%
\begin{itemdecl}
@\addedConcepts{requires CopyConstructible<Cont::value_type>}@
  insert_iterator<Cont@\removedConcepts{ainer}@>&
    operator=(@\changedConcepts{typename}{const}@ Cont@\removedConcepts{ainer}@::@\changedConcepts{const_reference}{value_type\&}@ value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects\ 
\begin{codeblock}
iter = @\removedConcepts{container->}@insert(@\addedConcepts{*container, }@iter, @\addedConcepts{Cont::value_type(}@value@\addedConcepts{)}@);
++iter;
\end{codeblock}

\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\index{operator=@\tcode{operator=}!\tcode{insert_iterator}}%
\begin{itemdecl}
insert_iterator<Cont@\removedConcepts{ainer}@>&
  operator=(Cont@\removedConcepts{ainer}@::value_type&& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
iter = @\removedConcepts{container->}@insert(@\addedConcepts{*container, }@iter, std::move(value));
++iter;
\end{codeblock}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[insert.iter.op*]{\tcode{insert_iterator::operator*}}

\index{operator*@\tcode{operator*}!\tcode{insert_iterator}}%
\begin{itemdecl}
insert_iterator<Cont@\removedConcepts{ainer}@>& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\rSec4[insert.iter.op++]{\tcode{insert_iterator::operator++}}

\index{operator++@\tcode{operator++}!\tcode{insert_iterator}}%
\begin{itemdecl}
insert_iterator<Cont@\removedConcepts{ainer}@>& operator++();
insert_iterator<Cont@\removedConcepts{ainer}@>& operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{*this}.
\end{itemdescr}

\rSec4[inserter]{\tcode{inserter}}

\index{inserter@\tcode{inserter}}%
\begin{itemdecl}
template <@\changedConcepts{class}{InsertionContainer}@ Cont@\removedConcepts{ainer}@>
  insert_iterator<Cont@\removedConcepts{ainer}@> inserter(Cont@\removedConcepts{ainer}@& x, @\removedConcepts{typename }@Cont@\removedConcepts{ainer}@::iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns\ 
\tcode{insert_iterator<Cont@\removedConcepts{ainer}@>(x, i)}.
\end{itemdescr}

\rSec4[insert.iter.maps]{Concept maps}
\begin{itemdecl}
@\addedConcepts{template<InsertionContainer Cont>}@
  @\addedConcepts{concept_map Iterator<insert_iterator<Cont> > \{ \}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\reallynote Declares that \mbox{\tcode{insert_iterator}} is an iterator.}
\end{itemdescr}

\rSec2[move.iterators]{Move iterators}

\pnum
Class template \tcode{move_iterator} is an iterator adaptor
with the same behavior as the underlying iterator except that its
dereference operator implicitly converts the value returned by the
underlying iterator's dereference operator to an rvalue reference.
Some generic algorithms can be called with move iterators to replace
copying with moving.

\pnum
\enterexample

\begin{codeblock}
set<string> s;
// populate the set \tcode{s}
vector<string> v1(s.begin(), s.end());          // copies strings into \tcode{v1}
vector<string> v2(make_move_iterator(s.begin()),
                  make_move_iterator(s.end())); // moves strings into \tcode{v2}
\end{codeblock}

\exitexample

\rSec3[move.iterator]{Class template \tcode{move_iterator}}

\index{move_iterator@\tcode{move_iterator}}%
\begin{codeblock}
namespace std {
  template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@>
  class move_iterator {
  public:
    typedef Iter@\removedConcepts{ator}@                                              iterator_type;
    typedef @\changedConcepts{typename iterator_traits<Iterator>}{Iter}@::difference_type   difference_type;
    typedef Iterator                                              pointer;
    typedef @\changedConcepts{typename iterator_traits<Iterator>}{Iter}@::value_type        value_type;
    @\removedConcepts{typedef typename iterator_traits<Iterator>::iterator_category iterator_category;}@
    typedef value_type&&                                          reference;

    move_iterator();
    explicit move_iterator(Iter@\removedConcepts{ator}@ i);
    template <class U> 
      @\addedConcepts{requires HasConstructor<Iter, const U\&>}@ 
      move_iterator(const move_iterator<U>& u);
    template <class U> 
      @\addedConcepts{requires HasAssign<Iter, const U\&>}@ 
      move_iterator& operator=(const move_iterator<U>& u);

    iterator_type base() const;
    reference operator*() const;
    pointer operator->() const;

    move_iterator& operator++();
    move_iterator operator++(int);
    @\addedConcepts{requires BidirectionalIterator<Iter>}@ move_iterator& operator--();
    @\addedConcepts{requires BidirectionalIterator<Iter>}@ move_iterator operator--(int);

    @\addedConcepts{requires RandomAccessIterator<Iter>}@ move_iterator operator+(difference_type n) const;
    @\addedConcepts{requires RandomAccessIterator<Iter>}@ move_iterator& operator+=(difference_type n);
    @\addedConcepts{requires RandomAccessIterator<Iter>}@ move_iterator operator-(difference_type n) const;
    @\addedConcepts{requires RandomAccessIterator<Iter>}@ move_iterator& operator-=(difference_type n);
    @\addedConcepts{requires RandomAccessIterator<Iter>}@
      @\unspec@ operator[](difference_type n) const;

  private:
    Iter@\removedConcepts{ator}@ current;   // \expos
  };

  template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasEqualTo<Iter1, Iter2>}@
    bool operator==(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasEqualTo<Iter1, Iter2>}@
    bool operator!=(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLess<Iter1, Iter2>}@
    bool operator<(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLess<Iter2, Iter1>}@
    bool operator<=(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLess<Iter2, Iter1>}@
    bool operator>(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasLess<Iter1, Iter2>}@
    bool operator>=(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);

  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
    @\addedConcepts{requires HasMinus<Iter1, Iter2>}@
    auto operator-(
      const move_iterator<Iter@\removedConcepts{ator}@1>& x, 
      const move_iterator<Iter@\removedConcepts{ator}@2>& y) -> decltype(x.base() - y.base());
  template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@>
    move_iterator<Iter@\removedConcepts{ator}@> operator+(
      @\changedConcepts{typename move_iterator<Iterator>}{Iter}@::difference_type n, const move_iterator<Iter@\removedConcepts{ator}@>& x);
  template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@>
    move_iterator<Iter@\removedConcepts{ator}@> make_move_iterator(const Iter@\removedConcepts{ator}@& i);

  @\addedConcepts{template<InputIterator Iter>}@
    @\addedConcepts{concept_map InputIterator<move_iterator<Iter> > \{ \}}@
  @\addedConcepts{template<ForwardIterator Iter>}@
    @\addedConcepts{concept_map ForwardIterator<move_iterator<Iter> > \{ \}}@
  @\addedConcepts{template<BidirectionalIterator Iter>}@
    @\addedConcepts{concept_map BidirectionalIterator<move_iterator<Iter> > \{ \}}@
  @\addedConcepts{template<RandomAccessIterator Iter>}@
    @\addedConcepts{concept_map RandomAccessIterator<move_iterator<Iter> > \{ \}}@
}
\end{codeblock}

\rSec3[move.iter.requirements]{\tcode{move_iterator}\ requirements}

\editorial{Remove [move.iter.requirements]}

\pnum
\removedConcepts{The template parameter \mbox{\tcode{Iterator}} shall meet
the requirements for an Input Iterator~(\mbox{\ref{input.iterators}}).
Additionally, if any of the bidirectional or random access traversal
functions are instantiated, the template parameter shall meet the
requirements for a Bidirectional Iterator~(\mbox{\ref{bidirectional.iterators}})
or a Random Access Iterator~(\mbox{\ref{random.access.iterators}}), respectively.}

\rSec3[move.iter.ops]{\tcode{move_iterator}\ operations}

\rSec4[move.iter.op.const]{\tcode{move_iterator}\ constructors}

\index{move_iterator@\tcode{move_iterator}!\tcode{move_iterator}}%
\begin{itemdecl}
move_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_iterator}, default
initializing \tcode{current}.
\end{itemdescr}

\begin{itemdecl}
explicit move_iterator(Iter@\removedConcepts{ator}@ i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_iterator}, intializing
\tcode{current} with \tcode{i}.
\end{itemdescr}

\begin{itemdecl}
template <class U> 
  @\addedConcepts{requires HasConstructor<Iter, const U\&>}@ 
  move_iterator(const move_iterator<U>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_iterator}, initializing
\tcode{current} with \tcode{u.base()}.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{U}} shall be convertible to
\mbox{\tcode{Iterator}}.}
\end{itemdescr}

\rSec4[move.iter.op=]{\tcode{move_iterator::operator=}}

\begin{itemdecl}
template <class U> 
  @\addedConcepts{requires HasAssign<Iter, const U\&>}@ 
  move_iterator& operator=(const move_iterator<U>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{u.base()} to
\tcode{current}.

\pnum
\removedConcepts{\mbox{\requires} \mbox{\tcode{U}} shall be convertible to
\mbox{\tcode{Iterator}}.}
\end{itemdescr}

\rSec4[move.iter.op.conv]{\tcode{move_iterator}\ conversion}

\begin{itemdecl}
Iter@\removedConcepts{ator}@ base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current}.
\end{itemdescr}

\rSec4[move.iter.op.star]{\tcode{move_iterator::operator*}}

\begin{itemdecl}
reference operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*current}, implicitly converted
to an rvalue reference.
\end{itemdescr}

\rSec4[move.iter.op.ref]{\tcode{move_iterator::operator->}}

\begin{itemdecl}
pointer operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current}.
\end{itemdescr}

\rSec4[move.iter.op.incr]{\tcode{move_iterator::operator++}}

\begin{itemdecl}
move_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{++current}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
move_iterator& operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
move_iterator tmp = *this;
++current;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[move.iter.op.decr]{\tcode{move_iterator::operator-{-}}}

\begin{itemdecl}
@\addedConcepts{requires BidirectionalIterator<Iter>}@ move_iterator& operator--();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{\dcr{}current}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{requires BidirectionalIterator<Iter>}@ move_iterator& operator--(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
move_iterator tmp = *this;
--current;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[move.iter.op.+]{\tcode{move_iterator::operator+}}

\begin{itemdecl}
@\addedConcepts{requires RandomAccessIterator<Iter>}@ move_iterator operator+(difference_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{move_iterator(current + n)}.
\end{itemdescr}

\rSec4[move.iter.op.+=]{\tcode{move_iterator::operator+=}}

\begin{itemdecl}
@\addedConcepts{requires RandomAccessIterator<Iter>}@ move_iterator& operator+=(difference_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{current += n}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[move.iter.op.-]{\tcode{move_iterator::operator-}}

\begin{itemdecl}
@\addedConcepts{requires RandomAccessIterator<Iter>}@ move_iterator operator-(difference_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{move_iterator(current - n)}.
\end{itemdescr}

\rSec4[move.iter.op.-=]{\tcode{move_iterator::operator-=}}

\begin{itemdecl}
@\addedConcepts{requires RandomAccessIterator<Iter>}@ move_iterator& operator-=(difference_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \tcode{current -= n}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[move.iter.op.index]{\tcode{move_iterator::operator[]}}

\begin{itemdecl}
@\addedConcepts{requires RandomAccessIterator<Iter>}@ 
  @\unspec@ operator[](difference_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current[n]}, implicitly converted to
an rvalue reference.
\end{itemdescr}

\rSec4[move.iter.op.comp]{\tcode{move_iterator}\ comparisons}

\begin{itemdecl}
template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasEqualTo<Iter1, Iter2>}@
  bool operator==(const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.base() == y.base()}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasEqualTo<Iter1, Iter2>}@
  bool operator!=(const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasLess<Iter1, Iter2>}@
  bool operator<(const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.base() < y.base()}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasLess<Iter2, Iter1>}@
  bool operator<=(const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y < x)}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasLess<Iter2, Iter1>}@
  bool operator>(const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y < x}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasLess<Iter1, Iter2>}@
  bool operator>=(const move_iterator<Iter@\removedConcepts{ator}@1>& x, const move_iterator<Iter@\removedConcepts{ator}@2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x < y)}.
\end{itemdescr}

\rSec4[move.iter.nonmember]{\tcode{move_iterator}\ non-member functions}

\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@1, @\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@2>
  @\addedConcepts{requires HasMinus<Iter1, Iter2>}@
  auto operator-(
    const move_iterator<Iter@\removedConcepts{ator}@1>& x, 
    const move_iterator<Iter@\removedConcepts{ator}@2>& y) -> decltype(x.base() - y.base());
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.base() - y.base()}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class}{RandomAccessIterator}@ Iter@\removedConcepts{ator}@>
  move_iterator<Iter@\removedConcepts{ator}@> operator+(
    @\changedConcepts{typename move_iterator<Iterator>}{Iter}@::difference_type n, const move_iterator<Iter@\removedConcepts{ator}@>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x + n}.
\end{itemdescr}

\begin{itemdecl}
template <@\changedConcepts{class}{InputIterator}@ Iter@\removedConcepts{ator}@>
move_iterator<Iter@\removedConcepts{ator}@> make_move_iterator(const Iter@\removedConcepts{ator}@& i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{move_iterator<Iter\removedConcepts{ator}>(i)}.
\end{itemdescr}

\rSec4[move.iter.maps]{Concept maps}
\begin{itemdecl}
@\addedConcepts{template<InputIterator Iter>}@
  @\addedConcepts{concept_map InputIterator<move_iterator<Iter> > \{ \}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\reallynote Declares that a \mbox{\tcode{move_iterator}} is an input iterator.}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{template<ForwardIterator Iter>}@
  @\addedConcepts{concept_map ForwardIterator<move_iterator<Iter> > \{ \}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\reallynote Declares that a \mbox{\tcode{move_iterator}} is a forward iterator if its underlying iterator is a forward iterator.}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{template<BidirectionalIterator Iter>}@
  @\addedConcepts{concept_map BidirectionalIterator<move_iterator<Iter> > \{ \}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\reallynote Declares that a \mbox{\tcode{move_iterator}} is a bidirectional iterator if its underlying iterator is a bidirectional iterator.}
\end{itemdescr}

\begin{itemdecl}
@\addedConcepts{template<RandomAccessIterator Iter>}@
  @\addedConcepts{concept_map RandomAccessIterator<move_iterator<Iter> > \{ \}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\reallynote Declares that a \mbox{\tcode{move_iterator}} is a random access iterator if its underlying iterator is a random access iterator.}
\end{itemdescr}

\end{paras}

\section*{Acknowledgments}
Thanks to Daniel Kr\"ugler for many helpful comments and corrections.

\bibliographystyle{plain}
\bibliography{../local}

\end{document}