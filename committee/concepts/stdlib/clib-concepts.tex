\documentclass[american,twoside]{book}
\usepackage{refbib}
\usepackage{pdfsync}
\input{macros}

%%--------------------------------------------------
%% PDF

\usepackage[pdftex,
            pdftitle={Core Concepts for the C++0x Standard Library},
            pdfsubject={C++ International Standard Proposal},
            pdfcreator={Douglas Gregor},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}

%%--------------------------------------------------
%% Set section numbering limit, toc limit
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{1}

%%--------------------------------------------------
%% Parameters that govern document appearance
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.6in}

%%--------------------------------------------------
%% Handle special hyphenation rules
\hyphenation{tem-plate ex-am-ple in-put-it-er-a-tor}

% Do not put blank pages after chapters that end on odd-numbered pages.
\def\cleardoublepage{\clearpage\if@twoside%
  \ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage%
  \if@twocolumn\hbox{}\newpage\fi\fi\fi}

\newsavebox\rebindbox

\begin{document}
\raggedbottom

\begin{titlepage}
\begin{center}
\huge
Core Concepts for the C++0x Standard Library\\
(Revision 3)
\vspace{0.25in}

\normalsize
Douglas Gregor and Andrew Lumsdaine \\
Open Systems Laboratory \\
Indiana University \\
Bloomington, IN\ \  47405 \\
\{\href{mailto:dgregor@osl.iu.edu}{dgregor}, \href{mailto:lums@osl.iu.edu}{lums}\}@osl.iu.edu
\end{center}

\vspace{0.25in}
\par\noindent Document number: DRAFT\vspace{-6pt}
\par\noindent Revises document number: N2621=08-0131\vspace{-6pt}
\par\noindent Date: \today\vspace{-6pt}
\par\noindent Project: Programming Language \Cpp{}, Library Working Group\vspace{-6pt}
\par\noindent Reply-to: Douglas Gregor $<$\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}$>$\vspace{-6pt}

\section*{Introduction}
This document proposes basic support for concepts in the \Cpp0x
Standard Library. It describes a new header \tcode{<concepts>} that
contains concepts that require compiler support (such as
\tcode{SameType} and \tcode{ObjectType}) and concepts that describe
common type behaviors likely to be used in many templates, including
those in the Standard Library (such as \tcode{CopyConstructible} and
\tcode{EqualityComparable}). 

Within the proposed wording, text that has been added
\textcolor{addclr}{will be presented in blue} \addedConcepts{and
underlined when possible}. Text that has been removed will be
presented \textcolor{remclr}{in red},\removedConcepts{with
strike-through when possible}.  

\editorial{Purely editorial comments will be written in a separate,
  shaded box.}

\paragraph*{Changes from N2621}
\begin{itemize}
\item Applied the proposed resolutions of concepts issues 15, 32, and 33.
\end{itemize}

\end{titlepage}

%%--------------------------------------------------
%% Headers and footers
\pagestyle{fancy}
\fancyhead[LE,RO]{\textbf{\rightmark}}
\fancyhead[RE]{\textbf{\leftmark\hspace{1em}\thepage}}
\fancyhead[LO]{\textbf{\thepage\hspace{1em}\leftmark}}
\fancyfoot[C]{Draft}

\fancypagestyle{plain}{
\renewcommand{\headrulewidth}{0in}
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\fancyfoot{}
}

\renewcommand{\sectionmark}[1]{\markright{\thesection\hspace{1em}#1}}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

\setcounter{chapter}{19}
\rSec0[utilities]{General utilities library}
\setcounter{Paras}{1}
\textcolor{black}{\pnum}
The following clauses describe utility @\removedCC{and allocator} \changedConcepts{requirements}{concepts}, utility
components, \addedB{tuples, type traits templates,} function objects, dynamic
memory management utilities, and date/time utilities, as summarized in
Table~\ref{tab:util.lib.summary}.

\setcounter{table}{29}
\begin{libsumtab}{General utilities library summary}{tab:util.lib.summary}
\ref{utility.concepts}
\changedConcepts{Requirements}{Concepts}    &         \addedConcepts{\ttfamily <concepts>}                                          \\ \rowsep
\ref{utility} Utility components            &       \tcode{<utility>}       \\ \rowsep
\ref{tuple} \addedB{Tuples}         &       \tcode{\addedB{<tuple>}}        \\ \rowsep
\ref{meta} \addedB{Type traits}             &       \tcode{\addedB{<type_traits>}}  \\ \rowsep
\ref{function.objects} Function objects     &       \tcode{<functional>}\\ \rowsep
                                                                                        &       \tcode{<memory>}        \\
\ref{memory} Memory                                         &       \tcode{<cstdlib>}       \\
                                                                                        &       \tcode{<cstring>}       \\ \rowsep
\ref{date.time} Date and time                       &       \tcode{<ctime>}         \\
\end{libsumtab}

\noindent\editorial{Replace the section [utility.requirements] with
  the following section [utility.concepts]}

\color{addclr}
\rSec1[utility.concepts]{Concepts}

\pnum The \tcode{<concepts>} header describes requirements on template
arguments used throughout the \Cpp\ Standard Library.

\synopsis{Header \tcode{<concepts>}\ synopsis}
\begin{codeblock}
namespace std {
  // \ref{concept.support}, support concepts:
  concept Returnable<typename T> { }
  concept PointeeType<typename T> { }
  @\addedCC{concept MemberPointeeType<typename T> \mbox{\textit{see below}};}@
  concept ReferentType<typename T> { }
  concept VariableType<typename T> { }
  concept ObjectType<typename T> @\textit{see below}@;
  concept ClassType<typename T> @\textit{see below}@;
  concept Class<typename T> @\textit{see below}@;
  concept Union<typename T> @\textit{see below}@;
  concept TrivialType<typename T> @\textit{see below}@;
  concept StandardLayoutType<typename T> @\textit{see below}@;
  concept LiteralType<typename T> @\textit{see below}@;
  concept ScalarType<typename T> @\textit{see below}@;
  concept NonTypeTemplateParameterType<typename T> @\textit{see below}@;
  concept IntegralConstantExpressionType<typename T> @\textit{see below}@;
  concept IntegralType<typename T> @\textit{see below}@;
  concept EnumerationType<typename T> @\textit{see below}@;
  concept SameType<typename T, typename U> {  }
  concept DerivedFrom<typename Derived, typename Base> { }

  // \ref{concept.comparison}, comparisons:
  auto concept LessThanComparable<typename T> @\textit{see below}@;
  auto concept EqualityComparable<typename T> @\textit{see below}@;
  @\removedCC{auto}@ concept TriviallyEqualityComparable<typename T> @\textit{see below}@;

  // \ref{concept.destruct}, destruction:
  auto concept Destructible<typename T> @\textit{see below}@;
  concept TriviallyDestructible<typename T> @\textit{see below}@;

  // \ref{concept.construct}, construction:
  auto concept HasConstructor<typename T, typename... Args> @\textit{see below}@;
  auto concept DefaultConstructible<typename T> @\textit{see below}@;
  concept TriviallyDefaultConstructible<typename T> @\textit{see below}@;

  // \ref{concept.copymove}, copy and move:
  auto concept MoveConstructible<typename T> @\textit{see below}@;
  auto concept CopyConstructible<typename T> @\textit{see below}@;
  concept TriviallyCopyConstructible<typename T> @\textit{see below}@;
  auto concept MoveAssignable<typename T> @\textit{see below}@;
  auto concept CopyAssignable<typename T> @\textit{see below}@;
  concept TriviallyCopyAssignable<typename T> @\textit{see below}@;
  auto concept Swappable<typename T> @\textit{see below}@;

  // \ref{concept.memory}, memory allocation:
  auto concept FreeStoreAllocatable<typename T> @\textit{see below}@;

  // \ref{concept.regular}, regular types:
  auto concept Semiregular<typename T> @\textit{see below}@;
  auto concept Regular<typename T> @\textit{see below}@;

  // \ref{concept.convertible}, convertibility:
  auto concept ExplicitlyConvertible<typename T, typename U> @\textit{see below}@;
  auto concept Convertible<typename T, typename U> @\textit{see below}@;

  // \ref{concept.true}, true:
  concept True<bool> { }
  concept_map True<true> { }

  // \ref{concept.operator}, operator concepts:
  auto concept HasPlus<typename T, typename U = T> @\textit{see below}@;
  auto concept HasMinus<typename T, typename U = T> @\textit{see below}@;
  auto concept HasMultiply<typename T, typename U = T> @\textit{see below}@;
  auto concept HasDivide<typename T, typename U = T> @\textit{see below}@;
  auto concept HasModulus<typename T, typename U = T> @\textit{see below}@;
  auto concept HasUnaryPlus<typename T> @\textit{see below}@;
  auto concept HasNegate<typename T> @\textit{see below}@;
  auto concept HasLess<typename T, typename U = T> @\textit{see below}@;
  auto concept HasEqualTo<typename T, typename U = T> @\textit{see below}@;
  auto concept HasLogicalAnd<typename T, typename U = T> @\textit{see below}@;
  auto concept HasLogicalOr<typename T, typename U = T> @\textit{see below}@;
  auto concept HasLogicalNot<typename T> @\textit{see below}@;
  auto concept HasBitAnd<typename T, typename U = T> @\textit{see below}@;
  auto concept HasBitOr<typename T, typename U = T> @\textit{see below}@;
  auto concept HasBitXor<typename T, typename U = T> @\textit{see below}@;
  auto concept HasComplement<typename T> @\textit{see below}@;
  auto concept HasLeftShift<typename T, typename U = T> @\textit{see below}@;
  auto concept HasRightShift<typename T, typename U = T> @\textit{see below}@;
  auto concept Dereferenceable<typename T> @\textit{see below}@;
  auto concept Addressable<typename T> @\textit{see below}@;
  auto concept Callable<typename F, typename... Args> @\textit{see below}@;
  auto concept HasMoveAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasCopyAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasPlusAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasMinusAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasMultiplyAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasDivideAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasModulusAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasBitAndAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasBitOrAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasBitXorAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasLeftShiftAssign<typename T, typename U = T> @\textit{see below}@;
  auto concept HasRightShiftAssign<typename T, typename U = T> @\textit{see below}@;

  // \ref{concept.arithmetic}, arithmetic concepts:
  concept ArithmeticLike<typename T> @\textit{see below}@;
  concept IntegralLike<typename T> @\textit{see below}@;
  concept SignedIntegralLike<typename T> @\textit{see below}@;
  concept UnsignedIntegralLike<typename T> @\textit{see below}@;
  concept FloatingPointLike<typename T> @\textit{see below}@;

  // \ref{concept.predicate}, predicates:
  auto concept Predicate<typename F, typename... Args> @\textit{see below}@;
}
\end{codeblock}

\rSec2[concept.support]{Support concepts}
\pnum
The concepts in [concept.support] provide the ability to state
template requirements for C++ type classifications ([basic.types]) and
type relationships that cannot be expressed directly with concepts
([concept]). Concept maps for these concepts are implicitly defined.
A program shall not provide concept maps for any concept in
[concept.support].

\begin{itemdecl}
concept Returnable<typename T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} Describes types that can be used as the
  return type of a function.}

\pnum
\addedConcepts{\mbox{\requires} for every}
\addedCC{non-array}
\addedConcepts{type \mbox{\tcode{T}} that is
  \mbox{\techterm{cv}} \mbox{\tcode{void}} or that meets the
  requirement \mbox{\tcode{MoveConstructible<T>}}
  (\mbox{\ref{concept.copymove}}), the concept map
  \mbox{\tcode{Returnable<T>}} shall be implicitly defined in
  namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept PointeeType<typename T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote}
describes types to which a pointer can be
created.}

\pnum 
\addedConcepts{\mbox{\requires}
for every type \mbox{\tcode{T}} that is an object type,
  function type, or \mbox{\techterm{cv}} \mbox{\tcode{void}}, a
  concept map \mbox{\tcode{PointeeType}} shall be implicitly defined
  in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
@\addedCC{concept MemberPointeeType<typename T> : PointeeType<T> \{ \}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedCC{\mbox{\reallynote}
describes types to which a pointer-to-member can be
created.}

\pnum 
\addedCC{\mbox{\requires}
for every type \mbox{\tcode{T}} that is an object type or
  function type, a
  concept map \mbox{\tcode{MemberPointeeType}} shall be implicitly defined
  in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept ReferentType<typename T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote}
describes types to which a reference \removedCC{or pointer-to-member} can be
created.

\pnum 
\mbox{\requires}
for every type \mbox{\tcode{T}} that is an object type\changedCC{or}{, a}
  function type, \addedCC{or a reference type,} a
  concept map \mbox{\tcode{ReferentType}} shall be implicitly defined
  in namespace \mbox{\tcode{std}}.
\end{itemdescr}

\begin{itemdecl}
concept VariableType<typename T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that can be used to
  declare a variable.}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is an object type or reference type, a concept map
  \mbox{\tcode{VariableType<T>}} shall be implicitly defined in 
namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept ObjectType<typename T> : VariableType<T>@\addedCC{, MemberPointeeType<T>} { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes object types ([basic.types]),
  for which storage can be allocated.}

\pnum 
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is an object type, a concept map
  \mbox{\tcode{ObjectType<T>}} shall be implicitly defined in
  namespace \mbox{\tcode{std}}.}
\end{itemdescr}


\begin{itemdecl}
concept ClassType<typename T> : ObjectType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes class types (i.e., unions,
  classes, and structs).}

\pnum 
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a class type ([class]), a concept map \mbox{\tcode{ClassType<T>}}
  shall be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept Class<typename T> : ClassType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes classes and structs ([class]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a class or struct, a concept map
  \mbox{\tcode{Class<T>}} shall be implicitly defined in namespace
  \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept Union<typename T> : ClassType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes union types ([class.union]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a union, a concept map \mbox{\tcode{Union<T>}}
  shall be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept TrivialType<typename T> : ObjectType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes trivial types ([basic.types]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a trivial type, a concept map \mbox{\tcode{TrivialType<T>}} shall
  be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept StandardLayoutType<typename T> : ObjectType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes standard-layout types ([basic.types]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a standard-layout type, a concept map
  \mbox{\tcode{StandardLayoutType<T>}} shall be implicitly defined in 
namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept LiteralType<typename T> : ObjectType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes literal types ([basic.types]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a literal type, a concept map \mbox{\tcode{LiteralType<T>}} shall
  be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept ScalarType<typename T> 
  : TrivialType<T>, LiteralType<T>, StandardLayoutType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes scalar types ([basic.types]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a scalar type, a concept map \mbox{\tcode{ScalarType<T>}} shall
  be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept NonTypeTemplateParameterType<typename T> : VariableType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describess type that can
be used as the type of a non-type template parameter ([temp.param]).}

\pnum
\addedConcepts{\mbox{\requires}
for every type \mbox{\tcode{T}} that can be the type of a non-type
\mbox{\techterm{template-parameter}} ([temp.param]), a concept map
\mbox{\tcode{NonTypeTemplateParameterType<T>}} shall be implicitly defined in
namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept IntegralConstantExpressionType<typename T> 
  : ScalarType<T>, NonTypeTemplateParameterType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that
can be the type of an integral constant expression ([expr.const]).} 

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is an integral type or enumeration type, a concept map
  \mbox{\tcode{IntegralConstantExpressionType<T>}} shall be implicitly
  defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept IntegralType<typename T> : IntegralConstantExpressionType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes integral types
([basic.fundamental]).}

\pnum
\addedConcepts{\mbox{\requires}
for every type \mbox{\tcode{T}} that is an integral type, a concept map
\mbox{\tcode{IntegralType<T>}} shall be implicitly defined in
namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept EnumerationType<typename T> : IntegralConstantExpressionType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes enumeration types
([dcl.enum]).} 

\pnum
\addedConcepts{\mbox{\requires}
for every type \mbox{\tcode{T}} that is an enumeration type, a concept map
\mbox{\tcode{EnumerationType<T>}} shall be implicitly defined in namespace
\mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept SameType<typename T, typename U> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a same-type requirement
  ([temp.req]).}
\end{itemdescr}

\begin{itemdecl}
concept DerivedFrom<typename Derived, typename Base> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\requires}
for every pair of class types (\mbox{\tcode{T}}, \mbox{\tcode{U}}),
such that \mbox{\tcode{T}} is either the same as or publicly and
unambiguously derived from \mbox{\tcode{U}}, a concept map
\mbox{\tcode{DerivedFrom<T, U>}} shall be implicitly defined in namespace
\mbox{\tcode{std}}.
\end{itemdescr}

\rSec2[concept.comparison]{Comparisons}
\begin{itemdecl}
auto concept LessThanComparable<typename T> : HasLess<T> {
  bool operator>(T const& a, T const& b) { return b < a; }
  bool operator<=(T const& a, T const& b) { return !(b < a); }
  bool operator>=(T const& a, T const& b) { return !(a < b); }

  axiom Consistency(T a, T b) {
    (a > b) == (b < a);
    (a <= b) == !(b < a);
    (a >= b) == !(a < b);
  }

  axiom Irreflexivity(T a) { (a < a) == false; }

  axiom Antisymmetry(T a, T b) { 
    if (a < b) (b < a) == false;
  }

  axiom Transitivity(T a, T b, T c) {
    if (a < b && b < c) (a < c) == true;
  }

  axiom TransitivityOfEquivalence(T a, T b, T c) {
    if (!(a < b) && !(b < a) && !(b < c) && !(c < b))
      (!(a < c) && !(c < a)) == true;
  } 
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes types whose values can be
  ordered, where \mbox{\tcode{operator<}}
  is a strict weak ordering relation (\mbox{\ref{alg.sorting}}).}
\end{itemdescr}

\begin{itemdecl}
auto concept EqualityComparable<typename T> : HasEqualTo<T> {
  bool operator!=(T const& a, T const& b) { return !(a == b); }

  axiom Consistency(T a, T b) {
    (a == b) == !(a != b);
  }

  axiom Reflexivity(T a) { a == a; }

  axiom Symmetry(T a, T b) { if (a == b) b == a; }

  axiom Transitivity(T a, T b, T c) {
    if (a == b && b == c) a == c;
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types whose values can be
compared for equality with \mbox{\tcode{operator==}}, which is an
equivalence relation.}
\end{itemdescr}

\begin{itemdecl}
concept TriviallyEqualityComparable<typename T> : EqualityComparable<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes types whose equality comparison
  operators (\mbox{\tcode{==}}, \mbox{\tcode{!=}}) can be implemented
  via a bitwise equality comparison, as with \mbox{\tcode{memcmp}}.
\mbox{\enternote} such types should not have
padding, i.e. the size of the type is the sum of the sizes of its
elements. If padding exists, the comparison may provide false
negatives, but never false positives. \mbox{\exitnote}}

\pnum
\addedConcepts{\mbox{\requires} for every integral type
  \mbox{\tcode{T}} and pointer type, a concept map
  \mbox{\tcode{TriviallyEqualityComparable<T>}} shall be 
  defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\rSec2[concept.destruct]{Destruction}
\begin{itemdecl}
auto concept Destructible<typename T> : VariableType<T> {
  T::~T();
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that can be destroyed,
  including scalar types, references, and class types with a public
  destructor.}

\pnum
\addedConcepts{\mbox{\requires} following destruction of an object,}
\changedConcepts{All}{all} resources owned by the object are reclaimed.
\end{itemdescr}

\begin{itemdecl}
concept TriviallyDestructible<typename T> : Destructible<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types whose
destructors do not need to be executed when the object is destroyed.}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a trivial type ([basic.types]), reference, or class type with a
  trivial destructor ([class.dtor]), a concept map
  \mbox{\tcode{TriviallyDestructible<T>}} shall be implicitly 
  defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\rSec2[concept.construct]{Construction}
\begin{itemdecl}
auto concept HasConstructor<typename T, typename... Args> : Destructible<T> {
  T::T(Args...);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that can be constructed
  from a given set of arguments.}
\end{itemdescr}

\begin{itemdecl}
auto concept DefaultConstructible<typename T> : HasConstructor<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which an object
  can be constructed without initializing the object to any particular
  value.}
\end{itemdescr}

\begin{itemdecl}
@\addedZ{concept TriviallyDefaultConstructible<typename T> : DefaultConstructible<T> \{\}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedZ{\mbox{\reallynote} describes types whose default constructor is trivial.}

\pnum \addedZ{\mbox{\requires} for every type \mbox{\tcode{T}} that is
  a trivial type (\mbox{\ref{basic.types}}) or a class type with a
  trivial default constructor (\mbox{\ref{class.ctor}}), a concept map
  \mbox{\tcode{TriviallyDefaultConstructible<T>}} shall be implicitly
  defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\rSec2[concept.copymove]{Copy and move}
\begin{itemdecl}
auto concept MoveConstructible<typename T> : HasConstructor<T, T&&> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} 
describes types that can move-construct an
object from a value of the same type, possibly altering that
value.}
\end{itemdescr}

\begin{itemdecl}
T::T(T&& rv); // note: inherited from HasConstructor<T, T\&\&>
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\postcondition}
the constructed \mbox{\tcode{T}} object is equivalent to the value of
\mbox{\tcode{rv}} before the construction. 
\mbox{\enternote} there is no requirement on the value of
\mbox{\tcode{rv}} after the construction. \mbox{\exitnote}}
\end{itemdescr}

\begin{itemdecl}
auto concept CopyConstructible<typename T> : MoveConstructible<T>, HasConstructor<T, const T&> {
  axiom CopyPreservation(T x) {
    T(x) == x;
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes types with a public copy constructor.}
\end{itemdescr}

\begin{itemdecl}
concept TriviallyCopyConstructible<typename T> : CopyConstructible<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes types whose copy
constructor is equivalent to \mbox{\tcode{memcpy}}.}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a trivial type ([basic.types]), a reference, or a class type with
  a trivial copy constructor ([class.copy]), a concept map
  \mbox{\tcode{TriviallyCopyConstructible<T>}} 
shall be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept MoveAssignable<typename T> : HasMoveAssign<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with the ability
  to assign to an object from an rvalue, potentially altering the rvalue.}
\end{itemdescr}

\begin{itemdecl}
result_type T::operator=(T&& rv); // inherited from HasMoveAssign
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\postconditions}
the constructed \mbox{\tcode{T}} object is equivalent to the value of
\mbox{\tcode{rv}} before the assignment. 
\mbox{\enternote} there is no requirement on the value of
\mbox{\tcode{rv}} after 
the assignment. \mbox{\exitnote}}
\end{itemdescr}

\begin{itemdecl}
auto concept CopyAssignable<typename T> : MoveAssignable<T> {
  axiom CopyPreservation(T& x, T y) {
    (x = y, x) == y;
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with the ability to assign to an
object.}
\end{itemdescr}

\editorial{\textcolor{black}{The CopyAssignable requirements in N2461 specify that
  \tcode{operator=} must return a \tcode{T\&}. This is too strong a
  requirement for most of the uses of \tcode{CopyAssignable}, so we have
  weakened \tcode{CopyAssignable} to not require anything of its return
  type. When we need a \tcode{T\&}, we'll add that as an explicit
  requirement. See, e.g., the \tcode{IntegralLike} concept.}}

\begin{itemdecl}
concept TriviallyCopyAssignable<typename T> : CopyAssignable<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types whose copy-assignment
  operator is equivalent to \mbox{\tcode{memcpy}}.}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a trivial type ([basic.types]) or a 
class type with a trivial copy assignment operator ([class.copy]), a
concept map \mbox{\tcode{TriviallyCopyAssignable<T>}} shall be implicitly
defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept Swappable<typename T> {
  void swap(T&, T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which two values of
  that type can be swapped.}
\end{itemdescr}

\begin{itemdecl}
void swap(T& t, T& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\postconditions}
\mbox{\tcode{t}} has the value originally held by \mbox{\tcode{u}},
and \mbox{\tcode{u}} has the value originally held by \mbox{\tcode{t}}.}
\end{itemdescr}

\rSec2[concept.memory]{Memory allocation}
\begin{itemdecl}
auto concept FreeStoreAllocatable<typename T> {
  void* T::operator new(size_t size);
  void* T::operator new(size_t size, void*);
  void* T::operator new[](size_t size);
  void T::operator delete(void*);
  void T::operator delete[](void*);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which objects and
arrays of objects can be allocated on or freed from the free store with
\mbox{\tcode{new}} and \mbox{\tcode{delete}}.}
\end{itemdescr}

\rSec2[concept.regular]{Regular types}

\begin{itemdecl}
auto concept Semiregular<typename T> : CopyConstructible<T>, CopyAssignable<T>, FreeStoreAllocatable<T> { 
  requires SameType<CopyAssignable<T>::result_type, T&>;
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} collects several common
requirements supported by most types.}
\end{itemdescr}

\begin{itemdecl}
auto concept Regular<typename T> 
  : Semiregular<T>, DefaultConstructible<T>, EqualityComparable<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes semi-regular types that are default
constructible and have equality comparison operators.}
\end{itemdescr}

\rSec2[concept.convertible]{Convertibility}

\begin{itemdecl}
auto concept ExplicitlyConvertible<typename T, typename U> : VariableType<T> {
  explicit operator U(T const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a conversion (explicit
or implicit) from} \changedCC{one type to another}{\mbox{\tcode{T} to \tcode{U}}}\addedConcepts{.}
\end{itemdescr}

\begin{itemdecl}
auto concept Convertible<typename T, typename U> : ExplicitlyConvertible<T, U> {
  operator U(T const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an implicit conversion from} \changedCC{one type to another}{\mbox{\tcode{T} to \tcode{U}}}\addedConcepts{.}
\end{itemdescr}

\rSec2[concept.true]{True}

\begin{itemdecl}
concept True<bool> { }
concept_map True<true> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} used to express the requirement that a
  particular integral constant expression evaluate true.}

\pnum
\addedConcepts{\mbox{\requires} a program shall not provide a concept map for the
\mbox{\tcode{True}} concept.}
\end{itemdescr}

\rSec2[concept.operator]{Operator concepts}
\begin{itemdecl}
auto concept HasPlus<typename T, typename U = T> {
  typename result_type;
  result_type operator+(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a binary \mbox{\tcode{operator+}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasMinus<typename T, typename U = T> {
  typename result_type;
  result_type operator-(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a binary \mbox{\tcode{operator-}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasMultiply<typename T, typename U = T> {
  typename result_type;
  result_type operator*(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a binary \mbox{\tcode{operator*}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasDivide<typename T, typename U = T> {
  typename result_type;
  result_type operator/(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an \mbox{\tcode{operator/}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasModulus<typename T, typename U = T> {
  typename result_type;
  result_type operator%(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an \mbox{\tcode{operator\%}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasUnaryPlus<typename T> {
  typename result_type;
  result_type operator+(T const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with a unary \mbox{\tcode{operator+}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasNegate<typename T> {
  typename result_type;
  result_type operator-(T const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a unary \mbox{\tcode{operator-}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLess<typename T, typename U = T> {
  bool operator<(T const& a, U const& b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an
  \mbox{\tcode{operator<}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasEqualTo<typename T, typename U = T> {
  bool operator==(T const& a, U const& b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an
  \mbox{\tcode{operator==}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLogicalAnd<typename T, typename U = T> {
  bool operator&&(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a logical conjunction operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLogicalOr<typename T, typename U = T> {
  bool operator||(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a logical disjunction operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLogicalNot<typename T> {
  bool operator!(T const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a logical negation operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitAnd<typename T, typename U = T> {
  typename result_type;
  result_type operator&(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a binary \mbox{\tcode{operator\&}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitOr<typename T, typename U = T> {
  typename result_type;
  result_type operator|(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an \mbox{\tcode{operator|}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitXor<typename T, typename U = T> {
  typename result_type;
  result_type operator^(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an \mbox{\tcode{operator\^}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasComplement<typename T> {
  typename result_type;
  result_type operator~(T const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an
  \mbox{\tcode{operator\~}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLeftShift<typename T, typename U = T> {
  typename result_type;
  result_type operator<<(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$<<$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasRightShift<typename T, typename U = T> {
  typename result_type;
  result_type operator>>(T const&, U const&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$>>$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept Dereferenceable<typename T> {
  typename reference;
  reference operator*(T);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a dereferencing \mbox{\tcode{operator*}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept Addressable<typename T> {
  typename pointer;
  pointer operator&(T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an address-of \mbox{\tcode{operator\&}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept Callable<typename F, typename... Args> {
  typename result_type;
  result_type operator()(F&@\addedZ{\&}@, Args...);
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes function object types 
callable given arguments of types \mbox{\tcode{Args...}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasMoveAssign<typename T, typename U = T> {
  typename result_type;
  result_type T::operator=(U&&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedCC{\mbox{\reallynote} describes types with the ability
  to assign to an object from an rvalue (which may have a different
  type), potentially altering the rvalue.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasCopyAssign<typename T, typename U = T> : HasMoveAssign<T, U> {
  result_type T::operator=(const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedCC{\mbox{\reallynote} describes types with the ability to assign to an
object (which may have a different type).}
\end{itemdescr}

\begin{itemdecl}
auto concept HasPlusAssign<typename T, typename U = T> {
  typename result_type;
  result_type operator+=(T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$+=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasMinusAssign<typename T, typename U = T> {
  typename result_type;
  result_type operator-=(T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$-=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasMultiplyAssign<typename T, typename U = T> {
  typename result_type;
  result_type operator*=(T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$*=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasDivideAssign<typename T, typename U = T> {
  typename result_type;
  result_type operator/=(T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$/=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasModulusAssign<typename T, typename U = T> {
  typename result_type;
  result_type operator%=(T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$\%=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitAndAssign<typename T, typename U = T> {
  typename result_type;
  result_type operator&=(T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$\&=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitOrAssign<typename T, typename U = T> {
  typename result_type;
  result_type operator|=(T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$|=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitXorAssign<typename T, typename U = T> {
  typename result_type;
  result_type operator^=(T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator\^{}=}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasLeftShiftAssign<typename T, typename U = T> {
  typename result_type;
  result_type operator<<=(T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$<<=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasRightShiftAssign<typename T, typename U = T> {
  typename result_type;
  result_type operator>>=(T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$>>=$}}.
\end{itemdescr}

\rSec2[concept.arithmetic]{Arithmetic concepts}

\begin{itemdecl}
concept ArithmeticLike<typename T> 
  : Regular<T>, LessThanComparable<T>, HasPlus<T>, HasMinus<T>, HasMultiply<T>, HasDivide<T>, 
    HasUnaryPlus<T>, HasNegate<T> {
  T::T(@\changedCC{long long}{intmax_t}@);
  @\addedZ{T::T(uintmax_t);}@
  @\addedCC{T::T(long double);}@

  T& operator++(T&);
  T operator++(T& t, int) { T tmp(t); ++t; return tmp; }
  T& operator--(T&);
  T operator--(T& t, int) { T tmp(t); --t; return tmp; }

  requires Convertible<HasUnaryPlus<T>::result_type, T>
        && Convertible<HasNegate<T>::result_type, T>
        && Convertible<HasPlus<T>::result_type, T>
        && Convertible<HasMinus<T>::result_type, T>
        && Convertible<HasMultiply<T>::result_type, T>
        && Convertible<HasDivide<T>::result_type, T>;

  T& operator*=(T&, T);
  T& operator/=(T&, T);
  T& operator+=(T&, T);
  T& operator-=(T&, T);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that provide all of the
  operations available on arithmetic types ([basic.fundamental]).}
\end{itemdescr}

\begin{itemdecl}
concept IntegralLike<typename T> 
  : ArithmeticLike<T>, HasComplement<T>, HasModulus<T>, HasBitAnd<T>, HasBitXor<T>, HasBitOr<T>,
    HasLeftShift<T>, HasRightShift<T> {
  requires Convertible<HasComplement<T>::result_type, T>
        && Convertible<HasModulus<T>::result_type, T>
        && Convertible<HasBitAnd<T>::result_type, T>
        && Convertible<HasBitXor<T>::result_type, T>
        && Convertible<HasBitOr<T>::result_type, T>
        && Convertible<HasLeftShift<T>::result_type, T>
        && Convertible<HasRightShift<T>::result_type, T>;

  T& operator%=(T&, T);
  T& operator&=(T&, T);
  T& operator^=(T&, T);
  T& operator|=(T&, T);
  T& operator<<=(T&, T);
  T& operator>>=(T&, T);
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes types that provide all of the operations
  available on integral types.}
\end{itemdescr}

\begin{itemdecl}
concept SignedIntegralLike<typename T> : IntegralLike<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that provide all of the
  operations available on signed integral types.}

\pnum
\addedConcepts{\mbox{\requires} for every signed integral type
  \mbox{\tcode{T}} ([basic.fundamental]), including signed extended
  integral types, an empty concept map
  \mbox{\tcode{SignedIntegralLike<T>}} shall be defined in namespace
  \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept UnsignedIntegralLike<typename T> : IntegralLike<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that provide all of the
  operations available on unsigned integral types.}

\pnum
\addedConcepts{\mbox{\requires} for every unsigned integral type
  \mbox{\tcode{T}} ([basic.fundamental]), including unsigned extended
  integral types, an empty concept map
  \mbox{\tcode{UnsignedIntegralLike<T>}} shall be defined in namespace
  \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept FloatingPointLike<typename T> : ArithmeticLike<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes floating-point types.}

\pnum
\addedConcepts{\mbox{\requires}
for every floating point type \mbox{\tcode{T}} ([basic.fundamental]), 
an empty concept map \mbox{\tcode{FloatingPointLike<T>}} shall be defined
in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\rSec2[concept.predicate]{Predicates}

\begin{itemdecl}
auto concept Predicate<typename F, typename... Args> : Callable<F, Args...> {
  requires Convertible<result_type, bool>;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes function objects 
callable with some set of arguments, the result of which can be used in a
context that requires a \mbox{\tcode{bool}}.}

\pnum
\addedConcepts{\mbox{\requires} 
predicate function objects shall not apply any non-constant function
through the predicate arguments.}
\end{itemdescr}

\section*{Acknowledgments}
Daniel Kr\"ugler made many valuable suggestions that helper improve
this document. 

\end{document}
