\documentclass[american,twoside]{book}
\usepackage{refbib}
\usepackage{pdfsync}
\input{macros}

%%--------------------------------------------------
%% PDF

\usepackage[pdftex,
            pdftitle={Foundational Concepts for the C++0x Standard Library},
            pdfsubject={C++ International Standard Proposal},
            pdfcreator={Douglas Gregor},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}

%%--------------------------------------------------
%% Set section numbering limit, toc limit
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{1}

%%--------------------------------------------------
%% Parameters that govern document appearance
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.6in}

%%--------------------------------------------------
%% Handle special hyphenation rules
\hyphenation{tem-plate ex-am-ple in-put-it-er-a-tor}

% Do not put blank pages after chapters that end on odd-numbered pages.
\def\cleardoublepage{\clearpage\if@twoside%
  \ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage%
  \if@twocolumn\hbox{}\newpage\fi\fi\fi}

\newsavebox\rebindbox

\begin{document}
\raggedbottom

\begin{titlepage}
\begin{center}
\huge
Foundational Concepts for the C++0x Standard Library\\
(Revision 5)
\vspace{0.25in}
\end{center}

\normalsize
\vspace{0.25in}
\par\noindent Authors: 
\begin{tabular}[t]{l}
Douglas Gregor, Indiana University \\
Mat Marcus, Adobe Systems, Inc.\\
Thomas Witt, Zephyr Associates, Inc.\\
Andrew Lumsdaine, Indiana University
\end{tabular}\vspace{-6pt}

\par\noindent Document number: DRAFT\vspace{-6pt}
\par\noindent Revises document number: N2737=08-0247\vspace{-6pt}
\par\noindent Date: \today\vspace{-6pt}
\par\noindent Project: Programming Language \Cpp{}, Library Working Group\vspace{-6pt}
\par\noindent Reply-to: Douglas Gregor $<$\href{mailto:dgregor@osl.iu.edu}{dgregor@osl.iu.edu}$>$\vspace{-6pt}

\section*{Introduction}
This document proposes basic support for concepts in the \Cpp0x
Standard Library. It describes a new header \tcode{<concepts>} that
contains concepts that require compiler support (such as
\tcode{SameType} and \tcode{ObjectType}) and concepts that describe
common type behaviors likely to be used in many templates, including
those in the Standard Library (such as \tcode{CopyConstructible} and
\tcode{EqualityComparable}). 

Within the proposed wording, text that has been added
\textcolor{addclr}{will be presented in blue} \addedConcepts{and
  underlined when possible}. Text that has been removed will be
presented \textcolor{remclr}{in red},\removedConcepts{with
  strike-through when possible}.

\editorial{Purely editorial comments will be written in a separate,
  shaded box.}

\section*{Changes from N2737}
\begin{itemize}
\item Changed the \tcode{operator*} associated function in \tcode{HasDereference} from:
\begin{codeblock}
result_type operator*(const T&);
\end{codeblock}
to
\begin{codeblock}
result_type operator*(T&&);
\end{codeblock}
to better match with the dereference operator in \tcode{Iterator}. See
Daniel Kr\"ugler's message c++std-lib-22198 on the reflector for
rationale.

\item Several updates to properly cope with abstract classes, thanks
  to Daniel Kr\"ugler:
  \begin{itemize}
  \item Add a restriction to [concept.transform] that prohibits users
    from adding concept maps for these concepts.
  \end{itemize}
  \item Implicitly define \tcode{TriviallyEqualityComparable} concept
    maps for enumeration types.
  \item Change \tcode{ArithmeticLike} to refine from
    \tcode{LessThanComparable} rather than \tcode{HasLess},
    \tcode{HasGreater}, \tcode{HasLessEqual}, and
    \tcode{HasGreatEqual}. 
  \item Added the \tcode{HasSubscript} 
    concept, from Daniel Kr\"ugler, to finish providing concepts for
    all overloadable operators.
  \item Based on the resolution to library issue 402 (and the
    follow-on issue 866), there is no longer a need for the
    \tcode{HasPlacementNew} concept in the Standard Library, so it has
    been removed.
  \item Made the \tcode{intmax_t}, \tcode{uintmax_t}, and
    \tcode{long double} constructors in the arithmetic concept
    \tcode{explicit}, resolving concepts issue \#47.
  \item \tcode{MemberPointeeType} not longer refines
    \tcode{PointeeType}, because \tcode{void() const} is a
    \tcode{MemberPointeeType} but not a \tcode{PointeeType}. Also,
    \tcode{FunctionType} refines \tcode{MemberPointeeType} (not
    \tcode{PointeeType}), and both \tcode{PointeeType} and
    \tcode{ReferentType} are restricted to \emph{cv-qualified}
    function types. Thanks to
    Peter Dimov for the acute observation!
  \item Fixed the requirements when dealing with abstract classes:
    \begin{itemize}
    \item Abstract classes aren't \tcode{VariableType}s (concepts
      issue \#28) or \tcode{Returnable}.
    \item \tcode{ObjectType} is not a \tcode{VariableType}, because
      you can't have a variable with abstract class type. However, an
      \tcode{ObjectType} is a \tcode{ReferentType} and a
      \tcode{PointeeType}. 
    \item \tcode{HasDestructor} does not refine \tcode{VariableType},
      since abstract classes can have destructors (but aren't
      \tcode{VariableType}s). Similarly for
      \tcode{ExplicitlyConvertible}.
    \end{itemize}
  \item Added \tcode{ValueType} concept; see c++std-lib-22195. The
    concepts \tcode{Union}, \tcode{TrivialType},
    \tcode{StandardLayoutType}, and \tcode{LiteralType} all refine
    this new concept. 
  \item \tcode{VariableType} refines \tcode{ReferentType}.
  \item Added the \tcode{PolymorphicClass} concept (concepts issue
    \#27), which refines \tcode{Class} and is further refined by
    \tcode{HasVirtualDestructor}.
  \end{itemize}

\end{titlepage}

\section*{Proposed Wording}
\paragraph*{Issues resolved by concepts}
The following LWG are resolved by concepts. These issues should be
resolved as NAD following the application of this proposal to the
wording paper:
\begin{description}
\item[Issue 556. Is Compare a BinaryPredicate?] With concepts, we've
  specified exactly what "convertible to bool" means for predicates,
  and all Compare objects are predicates (since they refine the
  Predicate concept). Short-circuiting is taken care of because the
  Predicate concept forces conversion to bool inside all constrained
  templates.
\item[Issue 724. DefaultConstructible is not defined.]
The concepts proposal provides a \tcode{DefaultConstructible} concept.
\end{description}

%%--------------------------------------------------
%% Headers and footers
\pagestyle{fancy}
\fancyhead[LE,RO]{\textbf{\rightmark}}
\fancyhead[RE]{\textbf{\leftmark\hspace{1em}\thepage}}
\fancyhead[LO]{\textbf{\thepage\hspace{1em}\leftmark}}
\fancyfoot[C]{Draft}

\fancypagestyle{plain}{
\renewcommand{\headrulewidth}{0in}
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\fancyfoot{}
}

\renewcommand{\sectionmark}[1]{\markright{\thesection\hspace{1em}#1}}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

\setcounter{chapter}{19}
\rSec0[utilities]{General utilities library}
\setcounter{Paras}{1}
\textcolor{black}{\pnum}
The following clauses describe utility \removedConcepts{and allocator} \changedConcepts{requirements}{concepts}, utility
components, \addedB{tuples, type traits templates,} function objects, dynamic
memory management utilities, and date/time utilities, as summarized in
Table~\ref{tab:util.lib.summary}.

\setcounter{table}{29}
\begin{libsumtab}{General utilities library summary}{tab:util.lib.summary}
\ref{utility.concepts}
\changedConcepts{Requirements}{Concepts}    &         \addedConcepts{\ttfamily <concepts>}                                          \\ \rowsep
\ref{utility} Utility components            &       \tcode{<utility>}       \\ \rowsep
\ref{tuple} \addedB{Tuples}         &       \tcode{\addedB{<tuple>}}        \\ \rowsep
\ref{meta} \addedB{Type traits}             &       \tcode{\addedB{<type_traits>}}  \\ \rowsep
\ref{function.objects} Function objects     &       \tcode{<functional>}\\ \rowsep
                                                                                        &       \tcode{<memory>}        \\
\ref{memory} Memory                                         &       \tcode{<cstdlib>}       \\
                                                                                        &       \tcode{<cstring>}       \\ \rowsep
\ref{date.time} Date and time                       &       \tcode{<ctime>}         \\
\end{libsumtab}

\noindent\editorial{Replace the section [utility.requirements] with
  the following section [utility.concepts]}

\color{addclr}
\rSec1[utility.concepts]{Concepts}

\pnum
This subclause describes concepts that specify requirements on
template arguments used throughout the \Cpp\ Standard
Library. Concepts whose name is prefixed with \tcode{Has} provide
detection of a specific syntax (e.g., \tcode{HasConstructor}), but do
not imply the semantics of the corresponding operation. Concepts whose
name has the \tcode{able} or \tcode{ible} suffix (e.g.,
\tcode{Constructible}) require both a specific syntax and semantics of
the associated operations. These semantic concepts refine the
corresponding syntax-detection concepts, for example, the
\tcode{Constructible} concept refines the \tcode{HasConstructor}
concept.

\synopsis{Header \tcode{<concepts>}\ synopsis}
\begin{codeblock}
namespace std {
  // \ref{concept.support}, support concepts:
  concept Returnable<typename T> { }
  concept PointeeType<typename T> { }
  concept MemberPointeeType<typename T> { }
  concept ReferentType<typename T> { }
  concept VariableType<typename T> { }
  concept ObjectType<typename T> @\textit{see below}@;
  concept FunctionType<typename T> @\textit{see below}@;
  concept ValueType<typename T> @\textit{see below}@;
  concept ClassType<typename T> @\textit{see below}@;
  concept Class<typename T> @\textit{see below}@;
  concept PolymorphicClass<typename T> @\textit{see below}@;
  concept Union<typename T> @\textit{see below}@;
  concept TrivialType<typename T> @\textit{see below}@;
  concept StandardLayoutType<typename T> @\textit{see below}@;
  concept LiteralType<typename T> @\textit{see below}@;
  concept ScalarType<typename T> @\textit{see below}@;
  concept ArithmeticType<typename T> @\textit{see below}@;
  concept NonTypeTemplateParameterType<typename T> @\textit{see below}@;
  concept IntegralConstantExpressionType<typename T> @\textit{see below}@;
  concept IntegralType<typename T> @\textit{see below}@;
  concept EnumerationType<typename T> @\textit{see below}@;
  concept FloatingPointType<typename T> @\textit{see below}@;
  concept SameType<typename T, typename U> {  }
  concept DerivedFrom<typename Derived, typename Base> { }

  // \ref{concept.transform}, type transformations:
  auto concept IdentityOf<typename T> @\textit{see below}@;
  auto concept RvalueOf<typename T> @\textit{see below}@;
  template<typename T> concept_map RvalueOf<T&> @\textit{see below}@;

  // \ref{concept.true}, true:
  concept True<bool> { }
  concept_map True<true> { }

  // \ref{concept.operator}, operator concepts:
  auto concept HasPlus<typename T, typename U> @\textit{see below}@;
  auto concept HasMinus<typename T, typename U> @\textit{see below}@;
  auto concept HasMultiply<typename T, typename U> @\textit{see below}@;
  auto concept HasDivide<typename T, typename U> @\textit{see below}@;
  auto concept HasModulus<typename T, typename U> @\textit{see below}@;
  auto concept HasUnaryPlus<typename T> @\textit{see below}@;
  auto concept HasNegate<typename T> @\textit{see below}@;
  auto concept HasLess<typename T, typename U> @\textit{see below}@;
  auto concept HasGreater<typename T, typename U> @\textit{see below}@;
  auto concept HasLessEqual<typename T, typename U> @\textit{see below}@;
  auto concept HasGreaterEqual<typename T, typename U> @\textit{see below}@;
  auto concept HasEqualTo<typename T, typename U> @\textit{see below}@;
  auto concept HasNotEqualTo<typename T, typename U> @\textit{see below}@;
  auto concept HasLogicalAnd<typename T, typename U> @\textit{see below}@;
  auto concept HasLogicalOr<typename T, typename U> @\textit{see below}@;
  auto concept HasLogicalNot<typename T> @\textit{see below}@;
  auto concept HasBitAnd<typename T, typename U> @\textit{see below}@;
  auto concept HasBitOr<typename T, typename U> @\textit{see below}@;
  auto concept HasBitXor<typename T, typename U> @\textit{see below}@;
  auto concept HasComplement<typename T> @\textit{see below}@;
  auto concept HasLeftShift<typename T, typename U> @\textit{see below}@;
  auto concept HasRightShift<typename T, typename U> @\textit{see below}@;
  auto concept HasDereference<typename T> @\textit{see below}@;
  auto concept HasAddressOf<typename T> @\textit{see below}@;
  auto concept HasSubscript<typename T, typename U> @\textit{see below}@;
  auto concept Callable<typename F, typename... Args> @\textit{see below}@;
  auto concept HasAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasPlusAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasMinusAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasMultiplyAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasDivideAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasModulusAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasBitAndAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasBitOrAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasBitXorAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasLeftShiftAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasRightShiftAssign<typename T, typename U> @\textit{see below}@;
  auto concept HasPreincrement<typename T> @\textit{see below}@;
  auto concept HasPostincrement<typename T> @\textit{see below}@;
  auto concept HasPredecrement<typename T> @\textit{see below}@;
  auto concept HasPostdecrement<typename T> @\textit{see below}@;
  auto concept HasComma<typename T, typename U> @\textit{see below}@;

  // \ref{concept.predicate}, predicates:
  auto concept Predicate<typename F, typename... Args> @\textit{see below}@;

  // \ref{concept.comparison}, comparisons:
  auto concept LessThanComparable<typename T> @\textit{see below}@;
  auto concept EqualityComparable<typename T> @\textit{see below}@;
  concept TriviallyEqualityComparable<typename T> @\textit{see below}@;
  auto concept StrictWeakOrder<typename F, typename T> @\textit{see below}@;
  auto concept EquivalenceRelation<typename F, typename T> @\textit{see below}@;

  // \ref{concept.construct}, construction:
  auto concept HasConstructor<typename T, typename... Args> @\textit{see below}@;
  auto concept Constructible<typename T, typename... Args> @\textit{see below}@;
  auto concept DefaultConstructible<typename T> @\textit{see below}@;
  concept TriviallyDefaultConstructible<typename T> @\textit{see below}@;

  // \ref{concept.destruct}, destruction:
  auto concept HasDestructor<typename T> @\textit{see below}@;
  auto concept HasVirtualDestructor<typename T> @\textit{see below}@;
  auto concept NothrowDestructible<typename T> @\textit{see below}@;
  concept TriviallyDestructible<typename T> @\textit{see below}@;

  // \ref{concept.copymove}, copy and move:
  auto concept MoveConstructible<typename T> @\textit{see below}@;
  auto concept CopyConstructible<typename T> @\textit{see below}@;
  concept TriviallyCopyConstructible<typename T> @\textit{see below}@;
  auto concept MoveAssignable<typename T> @\textit{see below}@;
  auto concept CopyAssignable<typename T> @\textit{see below}@;
  concept TriviallyCopyAssignable<typename T> @\textit{see below}@;
  auto concept HasSwap<typename T, typename U> @\textit{see below}@;
  auto concept Swappable<typename T> @\textit{see below}@;

  // \ref{concept.memory}, memory allocation:
  auto concept FreeStoreAllocatable<typename T> @\textit{see below}@;

  // \ref{concept.regular}, regular types:
  auto concept Semiregular<typename T> @\textit{see below}@;
  auto concept Regular<typename T> @\textit{see below}@;

  // \ref{concept.convertible}, convertibility:
  auto concept ExplicitlyConvertible<typename T, typename U> @\textit{see below}@;
  auto concept Convertible<typename T, typename U> @\textit{see below}@;


  // \ref{concept.arithmetic}, arithmetic concepts:
  concept ArithmeticLike<typename T> @\textit{see below}@;
  concept IntegralLike<typename T> @\textit{see below}@;
  concept SignedIntegralLike<typename T> @\textit{see below}@;
  concept UnsignedIntegralLike<typename T> @\textit{see below}@;
  concept FloatingPointLike<typename T> @\textit{see below}@;
}
\end{codeblock}

\rSec2[concept.support]{Support concepts}
\pnum
\addedConcepts{The concepts in [concept.support] provide the ability to state
template requirements for C++ type classifications ([basic.types]) and
type relationships that cannot be expressed directly with concepts
([concept]). Concept maps for these concepts are implicitly defined.
A program shall not provide concept maps for any concept in
[concept.support].}

\begin{itemdecl}
concept Returnable<typename T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} Describes types that can be used as the
  return type of a function.}

\pnum
\addedConcepts{\mbox{\requires} for every}
\addedConcepts{non-array}
\addedConcepts{type \mbox{\tcode{T}} that is
  \mbox{\techterm{cv}} \mbox{\tcode{void}} or that meets the
  requirement \mbox{\tcode{MoveConstructible<T>}}
  (\mbox{\ref{concept.copymove}}) and is not an abstract class,
  the concept map 
  \mbox{\tcode{Returnable<T>}} shall be implicitly defined in
  namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept PointeeType<typename T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote}
describes types to which a pointer can be
created.}

\pnum 
\addedConcepts{\mbox{\requires}
for every type \mbox{\tcode{T}} that is an object type,
  cv-unqualified function type, or \mbox{\techterm{cv}} \mbox{\tcode{void}}, a
  concept map \mbox{\tcode{PointeeType}} shall be implicitly defined
  in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept MemberPointeeType<typename T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote}
describes types to which a pointer-to-member can be
created.}

\pnum 
\addedConcepts{\mbox{\requires}
for every type \mbox{\tcode{T}} that is an object type or
  function type, a
  concept map \mbox{\tcode{MemberPointeeType}} shall be implicitly defined
  in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept ReferentType<typename T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote}
\addedConcepts{describes types to which a reference can be
created, including reference types (since references to
  references can be formed during substitution of template
  arguments).}

\pnum 
\mbox{\requires}
for every type \mbox{\tcode{T}} that is an object type, a
  cv-unqualified function type, or a reference type, a
  concept map \mbox{\tcode{ReferentType}} shall be implicitly defined
  in namespace \mbox{\tcode{std}}.
\end{itemdescr}

\begin{itemdecl}
concept VariableType<typename T> : ReferentType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that can be used to
  declare a variable.}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is an object type or reference type, but not an abstract class, a concept map
  \mbox{\tcode{VariableType<T>}} shall be implicitly defined in 
namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept ObjectType<typename T> : ReferentType<T>, PointeeType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes object types (\mbox{\ref{basic.types}}),
  for which storage can be allocated.}

\pnum 
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is an object type, a concept map
  \mbox{\tcode{ObjectType<T>}} shall be implicitly defined in
  namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept FunctionType<typename T> : MemberPointeeType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes function types (\mbox{\ref{dcl.fct}}).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that is a function type, a concept map \mbox{\tcode{FunctionType<T>}} shall be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept ValueType<typename T> : ObjectType<T>, VariableType<T>, MemberPointeeType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes value types, for which
  objects, variables, references, pointers, and pointers-to-members
  can be created.}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is an object type but not an abstract class, a concept map
  \mbox{\tcode{ValueType<T>}} shall be implicitly defined in namespace
  \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept ClassType<typename T> : ObjectType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes class types (i.e., unions,
  classes, and structs).}

\pnum 
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a class type ([class]), a concept map \mbox{\tcode{ClassType<T>}}
  shall be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept Class<typename T> : ClassType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes classes and structs ([class]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a class or struct, a concept map
  \mbox{\tcode{Class<T>}} shall be implicitly defined in namespace
  \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept PolymorphicClass<typename T> : Class<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes polymorphic class types (\mbox{\ref{class.virtual}}).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a polymorphic class, a concept map
  \mbox{\tcode{PolymorphicClass<T>}} shall be implicitly defined in namespace
  \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept Union<typename T> : ClassType<T>, ValueType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes union types ([class.union]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a union, a concept map \mbox{\tcode{Union<T>}}
  shall be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept TrivialType<typename T> : ValueType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes trivial types ([basic.types]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a trivial type, a concept map \mbox{\tcode{TrivialType<T>}} shall
  be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept StandardLayoutType<typename T> : ValueType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes standard-layout types ([basic.types]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a standard-layout type, a concept map
  \mbox{\tcode{StandardLayoutType<T>}} shall be implicitly defined in 
namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept LiteralType<typename T> : ValueType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes literal types ([basic.types]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a literal type, a concept map \mbox{\tcode{LiteralType<T>}} shall
  be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept ScalarType<typename T> 
  : TrivialType<T>, LiteralType<T>, StandardLayoutType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes scalar types ([basic.types]).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a scalar type, a concept map \mbox{\tcode{ScalarType<T>}} shall
  be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept ArithmeticType<typename T> : ScalarType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes arithmetic types (\mbox{\ref{basic.fundamental}}).}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is an arithmetic type, a concept map \mbox{\tcode{ArithmeticType<T>}} shall
  be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept NonTypeTemplateParameterType<typename T> : VariableType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes type that can
be used as the type of a non-type template parameter ([temp.param]).}

\pnum
\addedConcepts{\mbox{\requires}
for every type \mbox{\tcode{T}} that can be the type of a non-type
\mbox{\techterm{template-parameter}} ([temp.param]), a concept map
\mbox{\tcode{NonTypeTemplateParameterType<T>}} shall be implicitly defined in
namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept IntegralConstantExpressionType<typename T> 
  : ScalarType<T>, NonTypeTemplateParameterType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that
can be the type of an integral constant expression ([expr.const]).} 

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is an integral type or enumeration type, a concept map}\\
  \addedConcepts{\mbox{\tcode{IntegralConstantExpressionType<T>}} shall be implicitly
  defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept IntegralType<typename T> 
  : IntegralConstantExpressionType<T>, ArithmeticType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes integral types
([basic.fundamental]).}

\pnum
\addedConcepts{\mbox{\requires}
for every type \mbox{\tcode{T}} that is an integral type, a concept map
\mbox{\tcode{IntegralType<T>}} shall be implicitly defined in
namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept EnumerationType<typename T> : IntegralConstantExpressionType<T> { 
  IntegralType underlying_type;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes enumeration types
([dcl.enum]). \mbox{\tcode{underlying_type}} is the underlying type of
the enumeration type.}

\pnum
\addedConcepts{\mbox{\requires}
for every type \mbox{\tcode{T}} that is an enumeration type, a concept map
\mbox{\tcode{EnumerationType<T>}} shall be implicitly defined in namespace
\mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept FloatingPointType<typename T> : ArithmeticType<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes floating point types
(\mbox{\ref{basic.fundamental}}).} 

\pnum
\addedConcepts{\mbox{\requires}
for every type \mbox{\tcode{T}} that is a floating point type, a concept map
\mbox{\tcode{FloatingPointType<T>}} shall be implicitly defined in namespace
\mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept SameType<typename T, typename U> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes a same-type requirement
  ([temp.req]).}
\end{itemdescr}

\begin{itemdecl}
concept DerivedFrom<typename Derived, typename Base> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\requires}
for every pair of class types (\mbox{\tcode{T}}, \mbox{\tcode{U}}),
such that \mbox{\tcode{T}} is either the same as or publicly and
unambiguously derived from \mbox{\tcode{U}}, a concept map
\mbox{\tcode{DerivedFrom<T, U>}} shall be implicitly defined in namespace
\mbox{\tcode{std}}.
\end{itemdescr}

\rSec2[concept.transform]{Type transformations}
\pnum
\addedConcepts{The concepts in [concept.transform] provide simple type
  transformations that can be used within constrained templates.}

\pnum
\addedConcepts{A program shall not provide concept maps for any concept in
[concept.transform].}

\begin{itemdecl}
auto concept IdentityOf<typename T> {
  typename type = T;
  requires SameType<type, T>;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} concept form of the \mbox{\tcode{identity}} type metafunction (\mbox{\ref{forward}}).} 
\end{itemdescr}

\begin{itemdecl}
auto concept RvalueOf<typename T> {
  typename type = T&&;
  requires Convertible<T&, type> && Convertible<T&&, type>;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes the rvalue reference type
  for an arbitrary type \mbox{\tcode{T}}.} 
\end{itemdescr}

\begin{itemdecl}
template<typename T> concept_map RvalueOf<T&> {
  typedef T&& type;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} provides the appropriate rvalue
  reference type for the rvalue an lvalue reference type. \enternote this
  concept map is required to circumvent reference collapsing for
  lvalue references. \exitnote}
\end{itemdescr}

\rSec2[concept.true]{True}

\begin{itemdecl}
concept True<bool> { }
concept_map True<true> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} used to express the requirement that a
  particular integral constant expression evaluate true.}

\pnum
\addedConcepts{\mbox{\requires} a program shall not provide a concept map for the
\mbox{\tcode{True}} concept.}
\end{itemdescr}

\rSec2[concept.operator]{Operator concepts}
\begin{itemdecl}
auto concept HasPlus<typename T, typename U> {
  typename result_type;
  result_type operator+(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a binary \mbox{\tcode{operator+}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasMinus<typename T, typename U> {
  typename result_type;
  result_type operator-(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a binary \mbox{\tcode{operator-}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasMultiply<typename T, typename U> {
  typename result_type;
  result_type operator*(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a binary \mbox{\tcode{operator*}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasDivide<typename T, typename U> {
  typename result_type;
  result_type operator/(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an \mbox{\tcode{operator/}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasModulus<typename T, typename U> {
  typename result_type;
  result_type operator%(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an \mbox{\tcode{operator\%}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasUnaryPlus<typename T> {
  typename result_type;
  result_type operator+(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with a unary \mbox{\tcode{operator+}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasNegate<typename T> {
  typename result_type;
  result_type operator-(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a unary \mbox{\tcode{operator-}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLess<typename T, typename U> {
  bool operator<(const T& a, const U& b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an
  \mbox{\tcode{operator<}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasGreater<typename T, typename U> {
  bool operator>(const T& a, const U& b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an
  \mbox{\tcode{operator>}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLessEqual<typename T, typename U> {
  bool operator<=(const T& a, const U& b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an
  \mbox{\tcode{operator<=}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasGreaterEqual<typename T, typename U> {
  bool operator>=(const T& a, const U& b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an
  \mbox{\tcode{operator>=}}.}
\end{itemdescr}

\pnum
\addedConcepts{For the concepts \mbox{\tcode{HasLess}},
  \mbox{\tcode{HasGreater}}, \mbox{\tcode{HasLessEqual}}, and
  \mbox{\tcode{HasGreaterEqual}}, the concept maps in namespace
  \mbox{\tcode{std}} for any pointer type yield a total order, even if
  the built-in operators \mbox{\tcode{<}}, \mbox{\tcode{>}},
  \mbox{\tcode{<=}}, \mbox{\tcode{>=}} do not.}

\begin{itemdecl}
auto concept HasEqualTo<typename T, typename U> {
  bool operator==(const T& a, const U& b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an
  \mbox{\tcode{operator==}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasNotEqualTo<typename T, typename U> {
  bool operator!=(const T& a, const U& b);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an
  \mbox{\tcode{operator!=}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLogicalAnd<typename T, typename U> {
  bool operator&&(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a logical conjunction operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLogicalOr<typename T, typename U> {
  bool operator||(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a logical disjunction operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLogicalNot<typename T> {
  bool operator!(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a logical negation operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitAnd<typename T, typename U> {
  typename result_type;
  result_type operator&(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a binary \mbox{\tcode{operator\&}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitOr<typename T, typename U> {
  typename result_type;
  result_type operator|(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an \mbox{\tcode{operator|}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitXor<typename T, typename U> {
  typename result_type;
  result_type operator^(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an \mbox{\tcode{operator\^}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasComplement<typename T> {
  typename result_type;
  result_type operator~(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an
  \mbox{\tcode{operator\~}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasLeftShift<typename T, typename U> {
  typename result_type;
  result_type operator<<(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$<<$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasRightShift<typename T, typename U> {
  typename result_type;
  result_type operator>>(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$>>$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasDereference<typename T> {
  typename result_type;
  result_type operator*(T&&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a dereferencing \mbox{\tcode{operator*}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasAddressOf<typename T> {
  typename result_type;
  result_type operator&(T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an address-of \mbox{\tcode{operator\&}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasSubscript<typename T, typename U> {
  typename result_type;
  result_type operator[](T&&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a subscript \mbox{\tcode{operator[].}}}
\end{itemdescr}

\begin{itemdecl}
auto concept Callable<typename F, typename... Args> {
  typename result_type;
  result_type operator()(F&&, Args...);
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes function object types 
callable given arguments of types \mbox{\tcode{Args...}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasAssign<typename T, typename U> {
  typename result_type;
  result_type T::operator=(U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an assignment operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasPlusAssign<typename T, typename U> {
  typename result_type;
  result_type operator+=(T&, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$+=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasMinusAssign<typename T, typename U> {
  typename result_type;
  result_type operator-=(T&, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$-=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasMultiplyAssign<typename T, typename U> {
  typename result_type;
  result_type operator*=(T&, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$*=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasDivideAssign<typename T, typename U> {
  typename result_type;
  result_type operator/=(T&, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$/=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasModulusAssign<typename T, typename U> {
  typename result_type;
  result_type operator%=(T&, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$\%=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitAndAssign<typename T, typename U> {
  typename result_type;
  result_type operator&=(T&, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$\&=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitOrAssign<typename T, typename U> {
  typename result_type;
  result_type operator|=(T&, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$|=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasBitXorAssign<typename T, typename U> {
  typename result_type;
  result_type operator^=(T&, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator\^{}=}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasLeftShiftAssign<typename T, typename U> {
  typename result_type;
  result_type operator<<=(T&, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$<<=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasRightShiftAssign<typename T, typename U> {
  typename result_type;
  result_type operator>>=(T&, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\mbox{\reallynote} describes types with an \mbox{\tcode{operator$>>=$}}.
\end{itemdescr}

\begin{itemdecl}
auto concept HasPreincrement<typename T> {
  typename result_type;
  result_type operator++(T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a pre-increment operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasPostincrement<typename T> {
  typename result_type;
  result_type operator++(T&, int);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a post-increment operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasPredecrement<typename T> {
  typename result_type;
  result_type operator--(T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a pre-decrement operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasPostdecrement<typename T> {
  typename result_type;
  result_type operator--(T&, int);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a post-decrement operator.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasComma<typename T, typename U> {
  typename result_type
  result_type operator,(const T&, const U&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a comma operator.}
\end{itemdescr}

\rSec2[concept.predicate]{Predicates}

\begin{itemdecl}
auto concept Predicate<typename F, typename... Args> : Callable<F, const Args&...> {
  requires Convertible<result_type, bool>;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes function objects 
callable with some set of arguments, the result of which can be used in a
context that requires a \mbox{\tcode{bool}}.}

\pnum
\addedConcepts{\mbox{\requires} 
predicate function objects shall not apply any non-constant function
through the predicate arguments.}
\end{itemdescr}

\rSec2[concept.comparison]{Comparisons}
\begin{itemdecl}
auto concept LessThanComparable<typename T> : HasLess<T, T> {
  bool operator>(const T& a, const T& b) { return b < a; }
  bool operator<=(const T& a, const T& b) { return !(b < a); }
  bool operator>=(const T& a, const T& b) { return !(a < b); }

  axiom Consistency(T a, T b) {
    (a > b) == (b < a);
    (a <= b) == !(b < a);
    (a >= b) == !(a < b);
  }

  axiom Irreflexivity(T a) { (a < a) == false; }

  axiom Antisymmetry(T a, T b) { 
    if (a < b) 
      (b < a) == false;
  }

  axiom Transitivity(T a, T b, T c) {
    if (a < b && b < c) 
      (a < c) == true;
  }

  axiom TransitivityOfEquivalence(T a, T b, T c) {
    if (!(a < b) && !(b < a) && !(b < c) && !(c < b))
      (!(a < c) && !(c < a)) == true;
  } 
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes types whose values can be
  ordered, where \mbox{\tcode{operator<}}
  is a strict weak ordering relation (\mbox{\ref{alg.sorting}}).}
\end{itemdescr}

\begin{itemdecl}
auto concept EqualityComparable<typename T> : HasEqualTo<T, T> {
  bool operator!=(const T& a, const T& b) { return !(a == b); }

  axiom Consistency(T a, T b) {
    (a == b) == !(a != b);
  }

  axiom Reflexivity(T a) { a == a; }

  axiom Symmetry(T a, T b) { 
    if (a == b) 
      b == a; 
  }

  axiom Transitivity(T a, T b, T c) {
    if (a == b && b == c) 
      a == c;
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types whose values can be
compared for equality with \mbox{\tcode{operator==}}, which is an
equivalence relation.}
\end{itemdescr}

\begin{itemdecl}
concept TriviallyEqualityComparable<typename T> : EqualityComparable<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes types whose equality comparison
  operators (\mbox{\tcode{==}}, \mbox{\tcode{!=}}) can be implemented
  via a bitwise equality comparison, as with \mbox{\tcode{memcmp}}.
\mbox{\enternote} such types should not have
padding, i.e. the size of the type is the sum of the sizes of its
elements. If padding exists, the comparison may provide false
negatives, but never false positives. \mbox{\exitnote}}

\pnum
\addedConcepts{\mbox{\requires} for every integral, pointer, or enumeration type
  \mbox{\tcode{T}}, a concept map
  \mbox{\tcode{TriviallyEqualityComparable<T>}} shall be 
  defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept StrictWeakOrder<typename F, typename T> : Predicate<F, T, T> {

  axiom Irreflexivity(F f, T a) { f(a, a) == false; }

  axiom Antisymmetry(F f, T a, T b) { 
    if (f(a, b)) 
      f(b, a) == false;
  }

  axiom Transitivity(F f, T a, T b, T c) {
    if (f(a, b) && f(b, c)) 
      f(a, c) == true;
  }

  axiom TransitivityOfEquivalence(F f, T a, T b, T c) {
    if (!f(a, b) && !f(b, a) && !f(b, c) && !f(c, b))
      (!f(a, c) && !f(c, a)) == true;
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes a strict weak ordering
  relation (\mbox{\ref{alg.sorting}}), \mbox{\tcode{F}}, on a type \mbox{\tcode{T}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept EquivalenceRelation<typename F, typename T> : Predicate<F, T, T> {
  axiom Reflexivity(F f, T a) { f(a, a) == true; }

  axiom Symmetry(F f, T a, T b) { 
    if (f(a, b)) 
      f(b, a) == true; 
  }

  axiom Transitivity(F f, T a, T b, T c) {
    if (f(a, b) && f(b, c))
      f(a, c) == true;
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes an equivalence relation, \mbox{\tcode{F}}, on a type \mbox{\tcode{T}}.}
\end{itemdescr}

\rSec2[concept.construct]{Construction}
\begin{itemdecl}
auto concept HasConstructor<typename T, typename... Args> {
  T::T(Args...);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that can be constructed
  from a given set of arguments.}
\end{itemdescr}

\begin{itemdecl}
auto concept Constructible<typename T, typename... Args> {
  : HasConstructor<T, Args...>, NothrowDestructible<T> { }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that can be constructed
  from a given set of arguments that also have a no-throw destructor.}
\end{itemdescr}

\begin{itemdecl}
auto concept DefaultConstructible<typename T> : Constructible<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which an object
  can be constructed without initializing the object to any particular
  value.}
\end{itemdescr}

\begin{itemdecl}
concept TriviallyDefaultConstructible<typename T> : DefaultConstructible<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types whose default constructor is trivial.}

\pnum \addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that is
  a trivial type (\mbox{\ref{basic.types}}) or a class type with a
  trivial default constructor (\mbox{\ref{class.ctor}}), a concept map
  \mbox{\tcode{TriviallyDefaultConstructible<T>}} shall be implicitly
  defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\rSec2[concept.destruct]{Destruction}
\begin{itemdecl}
auto concept HasDestructor<typename T> {
  T::~T();
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that can be destroyed. These are scalar types, references, and class types with a public non-deleted destructor.}
\end{itemdescr}

\begin{itemdecl}
concept HasVirtualDestructor<typename T> : HasDestructor<T>, PolymorphicClass<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\reallynote describes types with a virtual destructor.}

\pnum
\addedConcepts{\requires for every class type \mbox{\tcode{T}} that has a virtual destructor, a concept map \mbox{\tcode{HasVirtualDestructor<T>}} shall be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept NothrowDestructible<typename T> : HasDestructor<T> { }
\end{itemdecl}

\begin{itemdescr}
\begin{codeblock}
T::~T() // inherited from HasDestructor<T>
\end{codeblock}
\pnum
\addedConcepts{\mbox{\requires} no exception is propagated.}
\end{itemdescr}

\begin{itemdecl}
concept TriviallyDestructible<typename T> : NothrowDestructible<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types whose
destructors do not need to be executed when the object is destroyed.}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a trivial type ([basic.types]), reference, or class type with a
  trivial destructor ([class.dtor]), a concept map
  \mbox{\tcode{TriviallyDestructible<T>}} shall be implicitly 
  defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\rSec2[concept.copymove]{Copy and move}
\begin{itemdecl}
auto concept MoveConstructible<typename T> : Constructible<T, T&&> { 
  requires RvalueOf<T> && Constructible<T, RvalueOf<T>::type>;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} 
describes types that can move-construct an
object from a value of the same type, possibly altering that
value.}
\end{itemdescr}

\begin{itemdecl}
T::T(T&& rv); // note: inherited from HasConstructor<T, T\&\&>
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\postcondition}
the constructed \mbox{\tcode{T}} object is equivalent to the value of
\mbox{\tcode{rv}} before the construction. 
\mbox{\enternote} there is no requirement on the value of
\mbox{\tcode{rv}} after the construction. \mbox{\exitnote}}
\end{itemdescr}

\begin{itemdecl}
auto concept CopyConstructible<typename T> : MoveConstructible<T>, Constructible<T, const T&> {
  axiom CopyPreservation(T x) {
    T(x) == x;
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes types with a public copy constructor.}
\end{itemdescr}

\begin{itemdecl}
concept TriviallyCopyConstructible<typename T> : CopyConstructible<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes types whose copy
constructor is equivalent to \mbox{\tcode{memcpy}}.}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a trivial type ([basic.types]), a reference, or a class type with
  a trivial copy constructor ([class.copy]), a concept map
  \mbox{\tcode{TriviallyCopyConstructible<T>}} 
shall be implicitly defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept MoveAssignable<typename T> : HasAssign<T, T&&> { 
  requires RvalueOf<T> && HasAssign<T, RvalueOf<T>::type>;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with the ability
  to assign to an object from an rvalue, potentially altering the rvalue.}
\end{itemdescr}

\begin{itemdecl}
result_type T::operator=(T&& rv); // inherited from HasAssign<T, T\&\&>
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\postconditions}
the constructed \mbox{\tcode{T}} object is equivalent to the value of
\mbox{\tcode{rv}} before the assignment. 
\mbox{\enternote} there is no requirement on the value of
\mbox{\tcode{rv}} after 
the assignment. \mbox{\exitnote}}
\end{itemdescr}

\begin{itemdecl}
auto concept CopyAssignable<typename T> : HasAssign<T, const T&>, MoveAssignable<T> {
  axiom CopyPreservation(T& x, T y) {
    (x = y, x) == y;
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with the ability to assign to an
object.}
\end{itemdescr}

\editorial{\textcolor{black}{The CopyAssignable requirements in N2461 specify that
  \tcode{operator=} must return a \tcode{T\&}. This is too strong a
  requirement for most of the uses of \tcode{CopyAssignable}, so we have
  weakened \tcode{CopyAssignable} to not require anything of its return
  type. When we need a \tcode{T\&}, we'll add that as an explicit
  requirement. See, e.g., the \tcode{IntegralLike} concept.}}

\begin{itemdecl}
concept TriviallyCopyAssignable<typename T> : CopyAssignable<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types whose copy-assignment
  operator is equivalent to \mbox{\tcode{memcpy}}.}

\pnum
\addedConcepts{\mbox{\requires} for every type \mbox{\tcode{T}} that
  is a trivial type ([basic.types]) or a 
class type with a trivial copy assignment operator ([class.copy]), a
concept map \mbox{\tcode{TriviallyCopyAssignable<T>}} shall be implicitly
defined in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept HasSwap<typename T, typename U> {
  void swap(T, U);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that have a swap operation.}
\end{itemdescr}

\begin{itemdecl}
auto concept Swappable<typename T> : HasSwap<T&, T&> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which two values of
  that type can be swapped.}
\end{itemdescr}

\begin{itemdecl}
void swap(T& t, T& u); // inherited from HasSwap<T, T>
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\postconditions}
\mbox{\tcode{t}} has the value originally held by \mbox{\tcode{u}},
and \mbox{\tcode{u}} has the value originally held by \mbox{\tcode{t}}.}
\end{itemdescr}

\rSec2[concept.memory]{Memory allocation}
\begin{itemdecl}
auto concept FreeStoreAllocatable<typename T> {
  void* T::operator new(size_t size);
  void T::operator delete(void*);

  void* T::operator new[](size_t size) {
    return T::operator new(size);
  }

  void T::operator delete[](void* ptr) {
    T::operator delete(ptr);
  }

  void* T::operator new(size_t size, const nothrow_t&) {
    try {
      return T::operator new(size);
    } catch(...) {
      return 0;
    }
  }

  void* T::operator new[](size_t size, const nothrow_t&) {
    try {
      return T::operator new[](size);
    } catch(...) {
      return 0;
    }
  }

  void T::operator delete(void* ptr, const nothrow_t&) {
    T::operator delete(ptr);
  }

  void T::operator delete[](void* ptr, const nothrow_t&) {
    T::operator delete[](ptr);
  }
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types for which objects and
arrays of objects can be allocated on or freed from the free store with
\mbox{\tcode{new}} and \mbox{\tcode{delete}}.}
\end{itemdescr}

\rSec2[concept.regular]{Regular types}

\begin{itemdecl}
auto concept Semiregular<typename T> 
  : CopyConstructible<T>, CopyAssignable<T>, FreeStoreAllocatable<T> { 
  requires SameType<CopyAssignable<T>::result_type, T&>;
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} collects several common
requirements supported by most types.}
\end{itemdescr}

\begin{itemdecl}
auto concept Regular<typename T> 
  : Semiregular<T>, DefaultConstructible<T>, EqualityComparable<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes semi-regular types that are default
constructible and have equality comparison operators.}
\end{itemdescr}

\rSec2[concept.convertible]{Convertibility}

\begin{itemdecl}
auto concept ExplicitlyConvertible<typename T, typename U> {
  explicit operator U(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with a conversion (explicit
or implicit) from}
\addedConcepts{\mbox{\tcode{T} to \tcode{U}}.}
\end{itemdescr}

\begin{itemdecl}
auto concept Convertible<typename T, typename U> : ExplicitlyConvertible<T, U> {
  operator U(const T&);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types with an implicit conversion from \mbox{\tcode{T} to \tcode{U}}.}
\end{itemdescr}

\rSec2[concept.arithmetic]{Arithmetic concepts}

\begin{itemdecl}
concept ArithmeticLike<typename T> 
  : Regular<T>, LessThanComparable<T>, HasUnaryPlus<T>, HasNegate<T>,
    HasPlus<T, T>, HasMinus<T, T>, HasMultiply<T, T>, HasDivide<T, T>, 
    HasPreincrement<T>, HasPostincrement<T>, HasPredecrement<T>, HasPostdecrement<T>,
    HasPlusAssign<T, const T&>, HasMinusAssign<T, const T&>,
    HasMultiplyAssign<T, const T&>, HasDivideAssign<T, const T&> {
  explicit T::T(intmax_t);
  explicit T::T(uintmax_t);
  explicit T::T(long double);

  requires Convertible<HasUnaryPlus<T>::result_type, T>
        && Convertible<HasNegate<T>::result_type, T>
        && Convertible<HasPlus<T, T>::result_type, T>
        && Convertible<HasMinus<T, T>::result_type, T>
        && Convertible<HasMultiply<T, T>::result_type, T>
        && Convertible<HasDivide<T, T>::result_type, T>
        && SameType<HasPreincrement<T>::result_type, T&>
        && SameType<HasPostincrement<T>::result_type, T>
        && SameType<HasPredecrement<T>::result_type, T&>
        && SameType<HasPostdecrement<T>::result_type, T>
        && SameType<HasPlusAssign<T, const T&>::result_type, T&>
        && SameType<HasMinusAssign<T, const T&>::result_type, T&>
        && SameType<HasMultiplyAssign<T, const T&>::result_type, T&>
        && SameType<HasDivideAssign<T, const T&>::result_type, T&>;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that provide all of the
  operations available on arithmetic types ([basic.fundamental]).}
\end{itemdescr}

\begin{itemdecl}
concept IntegralLike<typename T> 
  : ArithmeticLike<T>, LessThanComparable<T>,
    HasComplement<T>, HasModulus<T, T>, HasBitAnd<T, T>, HasBitXor<T, T>, HasBitOr<T, T>,
    HasLeftShift<T, T>, HasRightShift<T, T> 
    HasModulusAssign<T, const T&>, HasLeftShiftAssign<T, const T&>, HasRightShiftAssign<T, const T&>
    HasBitAndAssign<T, const T&>, HasBitXorAssign<T, const T&>, HasBitOrAssign<T, const T&> {
  requires Convertible<HasComplement<T>::result_type, T>
        && Convertible<HasModulus<T, T>::result_type, T>
        && Convertible<HasBitAnd<T, T>::result_type, T>
        && Convertible<HasBitXor<T, T>::result_type, T>
        && Convertible<HasBitOr<T, T>::result_type, T>
        && Convertible<HasLeftShift<T, T>::result_type, T>
        && Convertible<HasRightShift<T, T>::result_type, T>
        && SameType<HasModulusAssign<T, const T&>::result_type, T&>
        && SameType<HasLeftShiftAssign<T, const T&>::result_type, T&>
        && SameType<HasRightShiftAssign<T, const T&>::result_type, T&>
        && SameType<HasBitAndAssign<T, const T&>::result_type, T&>
        && SameType<HasBitXorAssign<T, const T&>::result_type, T&>
        && SameType<HasBitOrAssign<T, const T&>::result_type, T&>;
}
\end{itemdecl}

\begin{itemdescr}
\pnum 
\addedConcepts{\mbox{\reallynote} describes types that provide all of the operations
  available on integral types.}
\end{itemdescr}

\begin{itemdecl}
concept SignedIntegralLike<typename T> : IntegralLike<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that provide all of the
  operations available on signed integral types.}

\pnum
\addedConcepts{\mbox{\requires} for every signed integral type
  \mbox{\tcode{T}} ([basic.fundamental]), including signed extended
  integral types, an empty concept map
  \mbox{\tcode{SignedIntegralLike<T>}} shall be defined in namespace
  \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept UnsignedIntegralLike<typename T> : IntegralLike<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes types that provide all of the
  operations available on unsigned integral types.}

\pnum
\addedConcepts{\mbox{\requires} for every unsigned integral type
  \mbox{\tcode{T}} ([basic.fundamental]), including unsigned extended
  integral types, an empty concept map
  \mbox{\tcode{UnsignedIntegralLike<T>}} shall be defined in namespace
  \mbox{\tcode{std}}.}
\end{itemdescr}

\begin{itemdecl}
concept FloatingPointLike<typename T> : ArithmeticLike<T> { }
\end{itemdecl}

\begin{itemdescr}
\pnum
\addedConcepts{\mbox{\reallynote} describes floating-point types.}

\pnum
\addedConcepts{\mbox{\requires}
for every floating point type \mbox{\tcode{T}} ([basic.fundamental]), 
an empty concept map \mbox{\tcode{FloatingPointLike<T>}} shall be defined
in namespace \mbox{\tcode{std}}.}
\end{itemdescr}

\section*{Acknowledgments}
Daniel Kr\"ugler made many valuable suggestions that helped improve
this document. 

\end{document}
