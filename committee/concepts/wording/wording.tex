\documentclass[american]{book}
\usepackage{refbib}
\usepackage{pdfsync}

\input{macros}

%%--------------------------------------------------
%% PDF

\usepackage[pdftex,
            pdftitle={Proposed Wording for Concepts},
            pdfsubject={C++ International Standard Proposal},
            pdfcreator={Douglas Gregor},
            bookmarks=true,
            bookmarksnumbered=true,
            pdfpagelabels=true,
            pdfpagemode=UseOutlines,
            pdfstartview=FitH,
            linktocpage=true,
            colorlinks=true,
            linkcolor=blue,
            plainpages=false
           ]{hyperref}

%%--------------------------------------------------
%% Set section numbering limit, toc limit
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{3}

%%--------------------------------------------------
%% Parameters that govern document appearance
\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.6in}

%%--------------------------------------------------
%% Handle special hyphenation rules
\hyphenation{tem-plate ex-am-ple in-put-it-er-a-tor name-space name-spaces}

\definecolor{editbackground}{rgb}{.8,.8,.8}
\newcommand{\einline}[1]{\colorbox{editbackground}{#1}}
\newcommand{\editorial}[1]{\colorbox{editbackground}{\begin{minipage}{\linewidth
}#1\end{minipage}}}

\begin{document}
\raggedbottom

\begin{titlepage}
\huge
\begin{center}
Proposed Wording for Concepts\\
(Revision 7)
\end{center}

\normalsize
\vspace{0.25in}
\par\noindent Authors: 
\begin{tabular}[t]{l}
Douglas Gregor, Indiana University \\
Bjarne Stroustrup, Texas A\&M University \\
James Widman, Gimpel Software \\
Jeremy Siek, University of Colorado at Boulder
\end{tabular}\vspace{-6pt}

\par\noindent Document number:  D2710=08-0220\vspace{-6pt}
\par\noindent Revises document number: N2676=08-0186 \vspace{-6pt}
\par\noindent Date: \today\vspace{-6pt}
\par\noindent Project: Programming Language \Cpp{}, Core Working Group\vspace{-6pt}
\par\noindent Reply-to: Douglas Gregor $<$\href{mailto:doug.gregor@gmail.com}{doug.gregor@gmail.com}$>$

\section*{Introduction}
This document provides proposed wording for concepts. Readers
unfamiliar with concepts are encouraged to read the complete
proposal~\cite{GregorStroustrup06:concepts_rev_1}. 
%
It is recommended that readers ``tour'' this concepts wording using
N2399=07-0259, which provides an examples-directed view of the major
language features involved in concepts, cross-referenced with this
document.  
%
This document
provides wording for changes to the core language. Changes to the
standard library are discussed in separate documents:

\begin{itemize}
\item N2618=08-0128: Concepts for the C++0x Standard Library: Introduction (Revision 1)
\item N2619=08-0129: Concepts for the \Cpp{}0x Standard Library:
  Language Support Library
\item N2620=08-0130: Concepts for the C++0x Standard Library:
  Diagnostics library
\item N2677=08-0187: Foundational Concepts for the C++0x Standard Library
  (Revision 3)
\item N2622=08-0132: Concepts for the C++0x Standard Library:
  Utilities (Revision 3)
\item N2694=08-0204: Concepts for the C++0x Standard Library:
  Containers (Revision 2)
\item N2695=08-0205: Iterator Concepts for the C++0x Standard Library
  (Revision 3)
\item N2696=08-0206: Concepts for the C++0x Standard Library:
  Algorithms (Revision 3)
\item N2626=08-0136: Concepts for the C++0x Standard Library: Numerics
  (Revision 2)
\item N2654=08-0161: Allocator Concepts (Revision 1)
\end{itemize}

\section*{Changes from N2676}
\begin{itemize}
\item Deprecate the \tcode{late_check} feature, which is meant only as
  an evolutionary tool.
\item Clarify where concept semantics occur only within a constrained
  context, rather than within a complete constrained template.
\end{itemize}

\section*{Typographical conventions}
Within the proposed wording, text that has been added
\textcolor{addclr}{will be presented in blue} \addedConcepts{and
underlined when possible}. Text that has been removed will be
presented \textcolor{remclr}{in red},\removedConcepts{with
strike-through when possible}. Wording new to this revision will be 
\addedCC{underlined in green}. Take \emph{that}, angry fruit salad.

\editorial{Purely editorial comments will be written in a separate,
  shaded box.}
\end{titlepage}

%%--------------------------------------------------
%% Headers and footers
\pagestyle{fancy}
\fancyhead[LE,RO]{\textbf{\rightmark}}
\fancyhead[RE]{\textbf{\leftmark\hspace{1em}\thepage}}
\fancyhead[LO]{\textbf{\thepage\hspace{1em}\leftmark}}

\fancypagestyle{plain}{
\renewcommand{\headrulewidth}{0in}
\fancyhead[LE,RO]{}
\fancyhead[RE,LO]{}
\fancyfoot{}
}

\renewcommand{\sectionmark}[1]{\markright{\thesection\hspace{1em}#1}}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

\rSec0[intro]{General}

\begin{paras}
\setcounter{section}{2}
\rSec1[intro.defs]{Definitions}
\setcounter{Paras}{10}
\index{signature}%
\definition{signature}{defns.signature}
\changedD{the information about a function
that participates in overload resolution (\mbox{\ref{over.match}}):
its parameter-type-list (\mbox{\ref{dcl.fct}}) and,
if the function is a class member,
the
\mbox{\textit{cv-}}
qualifiers (if any) on the function itself and
the class in which the member function is declared.%
\remfootnoteD{
Function signatures do not include return type,
because that does not participate in overload resolution.
}
The signature of a
function template
specialization includes the
types of its template arguments (\mbox{\ref{temp.over.link}}).
}
{the name and the \techterm{parameter-type-list}
(\mbox{\ref{dcl.fct}}) of a function, as well as the class\addedConcepts{,
  concept, concept map,} or namespace 
of which it is a member. If a function or function template is a class
member its signature additionally includes the
\mbox{\textit{cv}}-qualifiers (if any) and the
\techterm{ref-qualifier} (if any) on the function or function
template itself.
 The signature of a function template additionally
includes its return type\mbox{\changedConcepts{ and}{,}} its template parameter 
list\mbox{\addedConcepts{, and its template requirements (if any)}}.
The signature
of a function template specialization includes the signature of the
template of which it is a specialization and its template arguments
(whether explicitly specified or deduced). \mbox{\enternote}Signatures
are used as a basis for name mangling and linking.\mbox{\exitnote} }
\end{paras}

\rSec0[lex]{Lexical conventions}
\begin{paras}
\setcounter{section}{10}
\rSec1[key]{Keywords}

\pnum
The identifiers shown in Table~\ref{tab:keywords}
are reserved for use
as keywords (that is, they are unconditionally treated as keywords in
phase 7):

% Synchronized with N2135
\setcounter{table}{2}

% Added axiom, concept, concept_map, late_check, requires
\begin{floattable}{keywords}{tab:keywords}
{lllll}
\topline

\tcode{asm}                     &       \tcode{continue}                &       \tcode{friend}                  &       \tcode{register}                &       \tcode{throw}                   \\
\tcode{auto}                    &       \tcode{default}                 &       \tcode{goto}                    &       \tcode{reinterpret_cast}        &       \tcode{true}                    \\
\addedConceptsC{axiom}          &       \tcode{delete}                  &       \tcode{if}                      &       \addedConceptsC{requires}       &       \tcode{try}                     \\
\tcode{bool}                    &       \tcode{do}                      &       \tcode{inline}                  &       \tcode{return}                  &       \tcode{typedef}                 \\
\tcode{break}                   &       \tcode{double}                  &       \tcode{int}                     &       \tcode{short}                   &       \tcode{typeid}                  \\
\tcode{case}                    &       \tcode{dynamic_cast}            &       \addedConceptsC{late_check}     &       \tcode{signed}                  &       \tcode{typename}                \\
\tcode{catch}                   &       \tcode{else}                    &       \tcode{long}                    &       \tcode{sizeof}                  &       \tcode{union}                   \\
\tcode{char}                    &       \tcode{enum}                    &       \tcode{mutable}                 &       \tcode{static}                  &       \tcode{unsigned}                \\
\tcode{char16_t}                &       \tcode{explicit}                &       \tcode{namespace}               &       \tcode{static_assert}           &       \tcode{using}                   \\
\tcode{char32_t}                &       \tcode{export}                  &       \tcode{new}                     &       \tcode{static_cast}             &       \tcode{virtual}                 \\
\tcode{class}                   &       \tcode{extern}                  &       \tcode{operator}                &       \tcode{struct}                  &       \tcode{void}                    \\
\addedConceptsC{concept}        &       \tcode{false}                   &       \tcode{private}                 &       \tcode{switch}                  &       \tcode{volatile}                \\
\addedConceptsC{concept_map}    &       \tcode{float}                   &       \tcode{protected}               &       \tcode{template}                &       \tcode{wchar_t}                 \\
\tcode{const}                   &       \tcode{for}                     &       \tcode{public}                  &       \tcode{this}                    &       \tcode{while}                   \\
\tcode{const_cast}              &                                       &                                       &                                       &                                       \\
\end{floattable}
\end{paras}

\rSec0[basic]{Basic concepts}
\begin{paras}


\setcounter{Paras}{2}
\textcolor{black}{\pnum}
\index{name}%
\index{declaration}%
\index{type}%
\index{object}%
\index{storage~class}%
\index{scope}%
\index{linkage}%
\index{region!declarative}%
An
\techterm{entity}\ 
\index{entity}%
is a value, object, subobject, base class subobject,
array element, variable,
function, instance of a function,
enumerator, type, class member, template,
namespace, \removedConcepts{or }parameter pack\addedConcepts{,
  concept, or concept map}. 

\setcounter{Paras}{5}
\pnum
Some names denote types, classes, \addedConcepts{concepts,}
\addedConcepts{concept map names,}
enumerations, or templates. 
In general, it is necessary to determine whether or not
a name denotes one of these entities before parsing the program
that contains it.
The process that determines this is called
\techterm{name lookup}\ 
(\ref{basic.lookup}).
\index{lookup!name}%

\setcounter{section}{1}
\rSec1[basic.def.odr]{One definition rule}
\pnum
No translation unit shall contain more than one definition of any
variable, function, class type, \addedConcepts{concept, concept map,}
enumeration type or template. 

\setcounter{Paras}{4}
\pnum
There can be more than one definition of a class type (clause \ref{class}),
\addedConcepts{concept (\mbox{\ref{concept}}), concept map (\mbox{\ref{concept.map}}),}
enumeration type ([dcl.enum]),
inline function with external linkage ([dcl.fct.spec]),
class template (clause \ref{temp}), non-static function template (\ref{temp.fct}),
static data member of a class template ([temp.static]),
member function
of a class template
([temp.mem.func]), or
template specialization for which some template parameters are not specified
(\ref{temp.spec}, \ref{temp.class.spec}) in a program
provided that each definition appears in a different translation unit,
and provided the definitions satisfy the following requirements.
Given such an entity named
\tcode{D}\ 
defined in more than one translation unit, then


\rSec1[basic.scope]{Declarative regions and scopes}
\rSec2[basic.scope.pdecl]{Point of declaration}
\setcounter{Paras}{9}

\pnum
\addedConcepts{The point of declaration for a concept (\mbox{\ref{concept}}) is
immediately after the identifier in the \mbox{\techterm{concept-definition}}. The point
of declaration for a concept map (\mbox{\ref{concept.map}}) is
immediately after the \mbox{\techterm{concept-id}} in the
\mbox{\techterm{concept-map-definition}}.}

\noindent\editorial{Add the following new sections to 3.3 [basic.scope] after [basic.scope.class]:}

\color{addclr}
\setcounter{subsection}{7}
\rSec2[basic.scope.concept]{Concept scope}
\pnum
\index{scope!concept}%
\addedConcepts{The following rules describe the scope of names declared in concepts
and concept maps.}

\begin{enumeraten}
\item %
\addedConcepts{The potential scope of a name declared in a concept or concept map
consists not only of the declarative region
following the name's point of declaration,
but also of all associated function bodies
in that concept or concept map.}
\item %
\addedConcepts{A name
\mbox{\tcode{N}} 
used in a concept or concept map
\mbox{\tcode{S}}
shall refer to the same declaration in its context and when re-evaluated in
the completed scope of
\mbox{\tcode{S}}.
No diagnostic is required for a violation of this rule.}
\item %
\addedConcepts{If reordering declarations in a concept or concept map yields an
alternate valid program under (1), the program is ill-formed,
no diagnostic is required.}
\item %
\addedConcepts{A name declared within an associated function definition hides a declaration of the same name
whose scope extends to or past the end of the associated function's concept or
concept map.}
\end{enumeraten}

\pnum
\addedConcepts{The name of a concept member shall only be used in the
  scope of its concept (as described above).}

\rSec2[basic.scope.req]{Requirements scope}
\pnum
\addedConcepts{In a constrained }
 \changedCCC{template}{context} 
\addedConcepts{ (\mbox{\ref{temp.constrained}}),
the names of all associated functions inside the concepts named 
by the concept requirements in the template's requirements
are visible in the scope of the template
declaration. 
\mbox{\enterexample}}
\begin{codeblock}
concept Integral<typename T> {
  T::(const T&);
  T operator-(T);
}

concept RAIterator<typename Iter> {
  Integral difference_type;
  difference_type operator-(Iter, Iter);
}

template<RAIterator Iter>
RAIterator<Iter>::difference_type distance(Iter first, Iter last) {
  return -(first - last); // okay: name lookup for operator- finds RAIterator<Iter>::operator- 
                          // and Integral<RAIterator<Iter>::difference_type>::operator-
                          // overload resolution picks the appropriate operator for both uses of -
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{\mbox{\enternote} Function names can be found within the
  concept map archetypes ([temp.archetype]) corresponding to a
  template's requirements. \mbox{\enterexample}}
\begin{codeblock}
concept A<class B> {
 void g( const B& );
}

template< class T, class U >
requires A<U>
void f( T & x, U & y ) {
   g( y ); // binds to A<U'>::g( const U' \& )
   g( x ); // error: no overload of g takes T' values.
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}\mbox{\exitnote}}

\color{black}

\rSec2[basic.scope.hiding]{Name hiding}
\index{hiding;~see~name~hiding}%

\pnum
\index{name~hiding}%
\index{hiding;~see~name~hiding}%
A name can be hidden by an explicit declaration of that same name
in a nested declarative region\addedConcepts{, refining concept
  (\mbox{\ref{concept.refine}}),} or derived class
(\ref{class.member.lookup}).

\editorial{Add the following new paragraph:}
\setcounter{Paras}{5}

\pnum 
\addedConcepts{In an associated function definition, the declaration
  of a local name hides the declaration of a member of the concept or
  concept map with the same name; see \mbox{\ref{basic.scope.concept}}.}

\rSec1[basic.lookup]{Name lookup}
\index{lookup!name}%
\index{summary!scope rules}%

\pnum
The name lookup rules apply uniformly to all names (including
\techterm{typedef-names}\ 
([dcl.typedef]),
\techterm{namespace-names}\ 
([basic.namespace])\addedConcepts{, \mbox{\techterm{concept-names}}
  (\mbox{\ref{concept}}),} 
\addedConcepts{\mbox{\techterm{concept-map-names}} (\mbox{\ref{concept.map}}),}
and
\techterm{class-names}\ 
([class.name]) wherever the grammar allows such names in the context
discussed by a particular rule.
Name lookup associates the use of a name \textcolor{black}{}with a declaration
([basic.def]) of that name.
Name lookup shall find an unambiguous declaration for the name
(see [class.member.lookup]).
Name lookup may associate more than one declaration with a name if it finds
the name to be a function name;
the declarations are said to form a set of overloaded functions
(\ref{over.load}).
Overload resolution (\ref{over.match}) takes place after name lookup has
succeeded.
The access rules (clause \ref{class.access}) are considered only once
name 
\textcolor{black}{lookup} and
function overload resolution (if applicable) have succeeded.
Only after name lookup, function overload resolution (if applicable) and
access checking have succeeded are the attributes introduced by the name's
declaration used further in expression processing (clause \ref{expr}).

\rSec2[basic.lookup.unqual]{Unqualified name lookup}
\editorial{Add the following new paragraphs:}
\setcounter{Paras}{15}

\color{addclr}
\pnum
\addedConcepts{A name used in the definition of a concept or concept map \mbox{\tcode{X}}
outside of an associated function body shall be declared in one of the following
ways:}

\begin{itemize}
\item %
\addedConcepts{before its use in the concept or concept map
\mbox{\tcode{X}} or be a member of a refined concept of
\mbox{\tcode{X}}, or}
\item %
\addedConcepts{if
\mbox{\tcode{X}}\ 
is a member of namespace
\mbox{\tcode{N}},
before the definition of concept or concept map
\mbox{\tcode{X}}\ 
in namespace
\mbox{\tcode{N}}\ 
or in one of
\mbox{\tcode{N}}'s
enclosing namespaces.}
\end{itemize}
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept Callable<class F, class T1> {
  result_type operator() (F&, T1);
  typename result_type; // error result_type used before declared
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{A name used in the definition of
an associated function
(\mbox{\ref{concept.fct}})
of a concept or concept map
\mbox{\tcode{X}}\ 
following the associated function's
\mbox{\techterm{declarator-id}} %
shall be declared in one of the following ways:}

\begin{itemize}
\item %
\addedConcepts{before its use in the block in which it is used or in an
enclosing block (\mbox{\ref{stmt.block}}), or}
\item %
\addedConcepts{shall be a member of concept or concept map
\mbox{\tcode{X}}\ 
or be a member of a refined concept of
\mbox{\tcode{X}}, or}
\item %
\addedConcepts{if
\mbox{\tcode{X}}\ 
is a member of namespace
\mbox{\tcode{N}},
before the associated function definition,
in namespace
\mbox{\tcode{N}}\ 
or in one of
\mbox{\tcode{N}}'s
enclosing namespaces.}
\end{itemize}
\color{black}

\setcounter{subsection}{2}
\rSec2[basic.lookup.qual]{Qualified name lookup}

\pnum
\index{name!qualified}%
\index{qualification!explicit}%
The name of a class\addedConcepts{, concept map (but not concept),} or
namespace member 
or enumerator can be referred to after the
\tcode{::}\ 
scope resolution operator (\ref{expr.prim}) applied to a
\techterm{nested-name-specifier}\ 
that nominates its class\addedConcepts{, concept map,} namespace, or
enumeration.
During the lookup for a name preceding the
\tcode{::}\ 
scope resolution operator,
object, function, and enumerator names are ignored.
If the name found does not designate a namespace\addedConcepts{, concept map, }
or a class, enumeration, or dependent type, the program is ill-formed.


\editorial{Add the following paragraph to Qualified name lookup [basic.lookup.qual]}

\setcounter{Paras}{5}
\color{addclr}
\pnum
\addedConcepts{In a constrained template (\mbox{\ref{temp.constrained}}), a name prefixed by
a \mbox{\techterm{nested-name-specifier}} that nominates a template type
parameter \mbox{\tcode{T}} is looked up as follows:
for each template requirement 
    \mbox{\tcode{C<$args$>}}
whose template argument list
references T, the name is looked up as if the
\mbox{\techterm{nested-name-specifier}} referenced
\mbox{\tcode{C<$args$>}} instead of T (\mbox{\ref{concept.qual}}), except
that only the names of associated types are visible during this lookup.
If an associated type of at least one requirement is found, then each name
found shall refer to the same type.  Otherwise, if the reference to the
name occurs within a constrained context, the name is looked up within the
scope of the archetype associated with T (and no special restriction on
name visibility is in effect for this lookup). \mbox{\enternote}\
Otherwise, the name is a member of an unknown specialization
\mbox{\ref{temp.dep.type}} \mbox{\exitnote}\ 
}
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> {
  typename assoc_type;
}

template<typename T, typename U> requires C<T> && C<U>
  T::assoc_type     // okay: refers to C<T>::assoc_type
  f();
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\color{black}

\editorial{Add the following subsection to Qualified name lookup [basic.lookup.qual]}

\color{addclr}
\setcounter{subsubsection}{2}
\rSec3[concept.qual]{Concept map members}

\pnum
\addedConcepts{If the
\mbox{\techterm{nested-name-specifier}}\ 
of a
\mbox{\techterm{qualified-id}}\ 
nominates a concept instance,
the name specified after the
\mbox{\techterm{nested-name-specifier}}\ 
is looked up as follows:}
\begin{itemize}
\additemConcepts{
If the template argument list of the concept instance references a
template parameter or associated type of a requirement, and if the name,
when looked up within the scope of the concept of the concept instance,
unambiguously refers to an associated type or class template, the result
of name lookup is the associated type or class template as a member of the
requirement.
    \mbox{\enternote}\ this implies that, given two distinct type parameters
    T and U, C<T>::type and C<U>::type are distinct types (though they may
    refer to the same archetype).  Also, the mere lookup of 'type' within C<T>
    and C<U> does not require the creation of a concept map archetype for
    C<T> or C<U>.
    \mbox{\exitnote}\ }
\additemConcepts{
Otherwise, concept map lookup (\mbox{\ref{temp.req.sat}}) first determines
which concept map is referred to by the nested-name-specifier.  Then
concept member lookup (\mbox{\ref{concept.member.lookup}}) is used to find
the name within the scope of the concept map.  The name shall represent
one or more members of that concept map or the concept maps corresponding
to the concept refinements.
    \mbox{\enternote}\ 
    this lookup requires a concept map definition, so if the template
    argument list of the concept instance references a template parameter
    or associated type of a requirement, a concept map archetype
    definition is required.
    \mbox{\exitnote}\ 
}
\end{itemize}
\addedConcepts{ \mbox{\enternote} Outside of a constrained context, this means
      that one or more
      requirement members (\mbox{\ref{concept.map}}) will be found, and since
      those names are synonyms for sets of other names, the result of
      name lookup is the union of each of those sets.
  \mbox{\exitnote}}
\addedConcepts{.
\mbox{\enternote}\
a concept map member can be referred to using a
\mbox{\techterm{qualified-id}}\ 
at any point in its potential scope (\mbox{\ref{basic.scope.concept}}).
\mbox{\enterexample}}
\begin{codeblock}
concept Callable1<typename F, typename T1> {
  typename result_type;
  result_type operator()(F&, T1);
@\textcolor{addclr}{}@}

template<typename F, typename T1>
requires Callable1<F, T1>
Callable1<F, T1>::result_type
forward(F& f, const T1& t1) {
  return f(t1);
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}\
\mbox{\exitnote}} 

\pnum
\addedConcepts{A concept map member name hidden by a name in a nested
  declarative region}
\addedConcepts{or by the name of a refining concept member}
\addedConcepts{can still be found
if qualified by the name of its concept map followed by the
\mbox{\tcode{::}}
operator.}
\color{black}
\end{paras}

\rSec1[basic.link]{Program and linkage}
\begin{paras}
\setcounter{Paras}{4}
\pnum
In addition, a member function, static data member, a named class or
enumeration of class scope, or an unnamed class or enumeration defined
in a class-scope typedef declaration such that the class or enumeration
has the typedef name for linkage purposes (\ref{dcl.typedef}), has external
linkage if the name of the class has external linkage.
\end{paras}

\setcounter{section}{8}
\rSec1[basic.types]{Types}
\begin{paras}
\pnum
\enternote\ 
\ref{basic.types} and the subclauses thereof
impose requirements on implementations regarding the representation
of types.
There are two kinds of types: fundamental types and compound types.
Types describe objects (\ref{intro.object}),
references (\ref{dcl.ref}),
or functions (\ref{dcl.fct}).
\addedConcepts{In a constrained context (\mbox{\ref{temp.constrained}}),
  type archetypes can behave like various kinds of types, e.g.,
  object types, scalar types, literal types, etc.}
\exitnote\ 

\end{paras}

\setcounter{chapter}{4}
\rSec0[expr]{Expressions}
\begin{paras}

\rSec1[expr.prim]{Primary expressions}

\setcounter{Paras}{6}
\pnum
\index{identifier}%
An
\techterm{identifier}\ 
is an
\techterm{id-expression}\ 
provided it has been
suitably declared (clause \ref{dcl.dcl}).
\enternote\ 
for
\techterm{operator-function-id}s,
see \ref{over.oper};
for
\techterm{conversion-function-id}s,
see \ref{class.conv.fct};
for
\techterm{template-id}s,
see \ref{temp.names}.
A
\techterm{class-name}\ 
prefixed by
\tcode{$\sim$}
denotes a destructor; see \ref{class.dtor}.
Within the definition of a non-static
member function, an
\techterm{identifier}\ 
that names a non-static member is transformed to a class member access
expression (\ref{class.mfct.non-static}).
\exitnote\ 
The type of the expression is the type of the
\techterm{identifier}.
The result is the entity denoted by the identifier.
The result is an lvalue if the entity is a function, variable, or data member.

\begin{bnf}
\index{operator!scope~resolution}%
\index{::@\tcode{::}|see{scope~resolution~operator}}%
\index{qualified-id@\techterm{qualified-id}}%
qualified-id:\br
    \terminal{::}\opt\ nested-name-specifier \terminal{template}\opt\ unqualified-id\br
    \terminal{::}\ identifier\br
    \terminal{::}\ operator-function-id\br
    \terminal{::}\ template-id\br
\end{bnf}

\begin{bnf}
\index{operator!scope~resolution}%
\index{name~hiding}%
\index{nested-name-specifier@\techterm{nested-name-specifier}}%
nested-name-specifier:\br
    type-name \terminal{::}\br
    namespace-name \terminal{::}\br
    nested-name-specifier identifier \terminal{::}\br
    nested-name-specifier \terminal{template}\opt\ template-id \terminal{::}\br
    \textcolor{addclr}{nested-name-specifier\opt\ concept-id \terminal{::}}
\end{bnf}
\end{paras}

\rSec1[expr.post]{Postfix expressions}
\setcounter{subsection}{1}
\rSec2[expr.call]{Function call}

\rSec1[expr.unary]{Unary expressions}

\rSec2[expr.unary.op]{Unary operators}
\setcounter{Paras}{1}
\pnum
\index{name!address~of cv-qualified}%
\index{expression!pointer~to~member constant}%
The result of the unary
\tcode{\&}
operator is a pointer to its operand.
The operand shall be an lvalue or a
\techterm{qualified-id}.
In the first case, if the type of the expression is ``\tcode{T},''
the type of the result is ``pointer to
\tcode{T}.''
In particular, the address of an object of type ``\textit{cv}\ \tcode{T}''
is ``pointer to \textit{cv}\ \tcode{T},'' with the same cv-qualifiers.
% UK issue 471
% .E[
% the address of an object of type
% ``\tcode{const int}''
% has type
% ``pointer to \tcodeconst int}.''
% .E] e
\index{member!type~of @\tcode{static}}%
For a
\techterm{qualified-id},
if the member is a static member of type ``\tcode{T}'',
the type of the result is plain ``pointer to
\tcode{T}.''
If the member is a non-static member of class
\tcode{C}
of type
\tcode{T},
the type of the result is
``pointer to member of \tcode{class C}\ of type
\tcode{T}.''
\addedConcepts{The address of a member of a concept map
(\mbox{\ref{concept.map}}) shall not be taken, either implicitly or
explicitly, nor shall a member of a concept map be bound to
a reference.}
\enterexample\ 

\begin{codeblock}
struct A { int i; };
struct B : A { };
... &B::i ...                 // has type \tcode{int A::*}
\end{codeblock}
\exitexample\ 
\enternote\ 
a pointer to member formed from a
\tcode{mutable}
non-static data member (\ref{dcl.stc}) does not reflect the
\tcode{mutable}
specifier associated with the non-static data member.
\exitnote\ 

\setcounter{section}{18}
\rSec1[expr.const]{Constant expressions}

\setcounter{Paras}{2}
\pnum
A constant expression is an \techterm{integral constant expression} if
it is of integral or enumeration type\addedConcepts{, or, in a
  constrained template (\mbox{\ref{temp.constrained}}), if it is of
  a type \mbox{\techterm{cv}} \mbox{\tcode{T}} that is an archetype
  and if the concept requirement
  \mbox{\tcode{IntegralConstantExpressionType<T>}} (\mbox{\ref{concept.support}})
  is part of the template's requirements.}  \enternote\ such
expressions may be used as array bounds (8.3.4, 5.3.4), as case
expressions (6.4.2), as bit-field lengths (9.6), as enumerator
initializers (7.2), as static member initializers (9.4.2), and as
integral or enumeration non-type template arguments (14.3). \exitnote\


\rSec0[stmt.stmt]{Statements}

\begin{paras}

\pnum
\index{statement}%
\textcolor{black}{}Except as indicated, statements are executed in sequence.
\index{sequence!statement}%

\begin{bnf}
\index{statement@\techterm{statement}}%
statement:\br
    labeled-statement\br
    expression-statement\br
    compound-statement\br
    selection-statement\br
    iteration-statement\br
    jump-statement\br
    declaration-statement\br
    try-block\br
    \addedConcepts{late-check-block}
\end{bnf}

\color{addclr}
\setcounter{section}{8}
\rSec1[stmt.late]{Late-checked block}

\pnum
\addedConcepts{In a constrained context 
  (\mbox{\ref{temp.constrained}}), a late-checked block treats the
  enclosed statements as if they were in an unconstrained
context. Outside of a constrained context, the late-checked block
  has no effect. \mbox{\enternote} in a late-checked block, template
  parameters do not behave as if they were replaced with their
  corresponding archetypes. Thus, template parameters imply the
  existence of dependent types, type-dependent expressions, and
  dependent names as in an unconstrained template.  }
\addedCC{
Furthermore, names at requirements scope (\mbox{\ref{basic.scope.req}})
are not visible.
}
\addedConcepts{ \mbox{\exitnote}} 
  
\begin{bnf}
late-check-block:\br
    \terminal{late_check} compound-statement
\end{bnf}

\pnum
\enterexample\
\begin{codeblock}
concept Semigroup<typename T> {
  T::T(const T&);
  T operator+(T, T);
}

concept_map Semigroup<int> {
  int operator+(int x, int y) { return x * y; }
}

template<Semigroup T> 
T add(T x, T y) { 
  T r = x + y; // uses Semigroup<T>::operator+
  late_check {
    r = x + y; // uses operator+ found at instantiation time (not considering Semigroup<T>::operator+)
  }
  @\textcolor{addclr}{}@return r;
}
\end{codeblock}
\exitexample\
% \addedCC{
% \mbox{\enternote}
% this demonstrates the kind of template whose instantiations may
%     suffer from the dreaded ``dropped concept maps'' pitfall.
% \mbox{\exitnote} 
% }


\pnum
\addedCC{
\mbox{\enternote}
within a late-checked block,
    users should prefer to avoid using operations which,
    if written outside of the late-checked block and in the nearest
        enclosing unconstrained context,
    would bind to a member of a concept map archetype.
If said avoidance is not practical,
    those operations should be clearly documented.
For example, the author of \mbox{\tcode{add(T,T)}} should warn other users
against satisfying \
\mbox{\tcode{Semigroup<T>::operator+}} with anything other than the
\mbox{\tcode{operator+}} that would normally be selected for a given type
\mbox{\tcode{T}}.
\mbox{\exitnote} 
}

\pnum
\addedCC{
The use of \mbox{\tcode{late\_check}} is deprecated.
}

\pnum
\addedCC{
\mbox{\enternote}
a late-checked block should generally be used only when certain suitably
constrained versions of templates are not yet available for use from
within the body of a constrained template definition and the only viable
alternative is the use of an unconstrained template.
\mbox{\tcode{late\_check}} is regarded as an evolutionary tool only,
and it was added to the language only after several debates and careful
deliberation.
In the end,
    it was decided that migrating a template library toward the use of
    concepts would be prohibitively difficult in too many cases without
    the ability to use an unconstrained template from within a constrained
    template.
So there are times when \mbox{\tcode{late\_check}} is a ``necessary
evil''.
But it is still
``evil'' (because it can lead to dangers associated with ``dropped concept
maps'' as in the \mbox{\tcode{Semigroup}} example above---not to mention
the general loss of type-checking).
Therefore users are encouraged to remove a use of
\mbox{\tcode{late\_check}} when it is reasonable to do so.
\mbox{\exitnote} 
}

\color{black}

\end{paras}

\rSec0[dcl.dcl]{Declarations}

\begin{paras}

\pnum
\index{declaration}%
Declarations specify how names are to be interpreted.
Declarations have the form

\begin{bnf}
\index{declaration@\techterm{declaration}}%
declaration-seq:\br
        declaration\br
        declaration-seq declaration
\end{bnf}

\begin{bnf}
declaration:\br
        block-declaration\br
        function-definition\br
        template-declaration\br
        explicit-instantiation\br
        explicit-specialization\br
        linkage-specification\br
        namespace-definition\br
        \addedConcepts{concept-definition}\br
        \addedConcepts{concept-map-definition}
\end{bnf}

\begin{bnf}
block-declaration:\br
        simple-declaration\br
        asm-definition\br
        namespace-alias-definition\br
        using-declaration\br
        using-directive\br
        static_assert-declaration\br
        alias-declaration
\end{bnf}

\begin{bnf}
alias-declaration:\br
        \terminal{using} identifier = type-id

simple-declaration:\br
        decl-specifier-seq\opt\ init-declarator-list\opt\ \terminal{;}

\index{static_assert@\techterm{static_assert}}%
static_assert-declaration:\br
  \terminal{static_assert} \terminal{(} constant-expression \terminal{,} string-literal \terminal{)} \terminal{;}
\end{bnf}

\enternote\ 
\techterm{asm-definition}s
are described in \ref{dcl.asm}, and
\techterm{linkage-specification}s
are described in \ref{dcl.link}.
\techterm{Function-definition}s
are described in \ref{dcl.fct.def} and
\techterm{template-declaration}s
are described in clause \ref{temp}.
\techterm{Namespace-definition}s
are described in \ref{namespace.def},
\addedConcepts{\mbox{\techterm{concept-definition}}s
are described in \mbox{\ref{concept.def}},
\mbox{\techterm{concept-map-definition}}s
are described in \mbox{\ref{concept.map}}},
\techterm{using-declaration}s
are described in \ref{namespace.udecl} and
\techterm{using-directive}s
are described in \ref{namespace.udir}.
\exitnote\ 
The
\techterm{simple-declaration}\ 

\begin{ncsimplebnf}
decl-specifier-seq\opt\ init-declarator-list\opt\ \terminal{;}
\end{ncsimplebnf}

\textcolor{black}{}is divided into two parts:
\techterm{decl-specifier}s,
the components of a
\techterm{decl-specifier-seq},
are described in \ref{dcl.spec} and
\techterm{declarator}s,
the components of an
\techterm{init-declarator-list},
are described in clause \ref{dcl.decl}.

\pnum
A declaration occurs in a scope (\ref{basic.scope});
the scope rules are summarized in \ref{basic.lookup}.
A declaration that declares a function or defines a class,
\addedConcepts{concept, concept map,} namespace, template, 
or function also has one or more scopes nested within it.
These nested \textcolor{black}{scopes}, in
turn, can have declarations nested within them.
Unless otherwise stated,
utterances in clause \ref{dcl.dcl} about components in, of, or contained by a
declaration or subcomponent thereof refer only to those components of the
declaration that are
\textit{not}\ 
nested within scopes nested within the declaration.

\setcounter{section}{3}
\setcounter{subsection}{2}
\rSec2[namespace.udecl]{The \tcode{using} declaration}

\pnum
A \emph{using-declaration} introduces a name into the declarative
region in which the \emph{using-declaration} appears. That name is a
synonym for the name of some entity declared elsewhere.

\begin{bnf}
using-declaration:\br
      \terminal{using} \terminal{typename}\opt \terminal{::}\opt\ nested-name-specifier unqualified-id \terminal{;}\br
      \terminal{using} \terminal{::} unqualified-id \terminal{;}\br
      \addedConcepts{\mbox{\terminal{using} \terminal{::}\opt\ nested-name-specifier\opt\  \terminal{concept_map} \terminal{::}\opt\ nested-name-specifier\opt\ concept-id \terminal{;}}}\br
      \addedConcepts{\mbox{\terminal{using} \terminal{::}\opt\ nested-name-specifier\opt\  \terminal{concept_map} \terminal{::}\opt\ nested-name-specifier\opt\ concept-name\opt\ \terminal{;}}}\br
      \addedConcepts{\mbox{\terminal{using} \terminal{::}\opt\ nested-name-specifier\opt\  concept-name \terminal{;}}}
\end{bnf}

\setcounter{Paras}{20}

\pnum 
\addedConcepts{A \mbox{\techterm{using-declaration}} for a concept map
  is an alias to 
the concept map}
\changedCCC{that matches (\mbox{\ref{temp.concept.map}}) the
concept instance corresponding to the}{determined by concept map lookup (\mbox{\ref{temp.req.sat}}) of the}
\addedConcepts{\mbox{\techterm{concept-id}} from the specified
  namespace.
\mbox{\enterexample}}
%
\color{addclr}
\begin{codeblock}
namespace N1 {
  concept C<typename T> { }
}
namespace N2 {
  concept_map N1::C<int> { } // A
  template<typename T> concept_map N1::C<T*> { } // B
}
namespace N3 {
  using N2::concept_map N1::C<int>;  // aliases A
  using N2::concept_map N1::C<int*>; // aliases B, instantiated with T=int
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}


\pnum 
\addedConcepts{A \mbox{\emph{using-declaration}} for a concept map
  that specifies a 
\mbox{\techterm{concept-name}} (and not a
\mbox{\techterm{concept-id}}) brings all 
of the concept maps and concept map templates from the specified
namespace for the given concept into the scope in which the
\mbox{\techterm{using-declaration}} appears.
\mbox{\enterexample}}
\begin{codeblock}
namespace N1 {
  concept C<typename T> { }
  template<C T> void f(T) { }
}
namespace N2 {
  concept_map N1::C<int> { } // A
  template<typename T> concept_map N1::C<T*> { } // B
}
namespace N3 {
  using N2::concept_map N1::C; // aliases A and B
  @\textcolor{addclr}{}@void g() {
    f(1); // uses concept map N1::C<int> from A
    f(new int); // uses concept map N1::C<int*> instantiated from B with T=int
  @\textcolor{addclr}{\}}@
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum 
\addedConcepts{If no concept is specified in the concept map using declaration,
    the following rule applies.
Let \mbox{\tcode{X}} be the namespace specified in the \mbox{\techterm{nested-name-specifier}} of
    the \mbox{\techterm{using-declaration}}.
Let \mbox{\tcode{S}} be the set of all names of concept maps and concept map templates in
    \mbox{\tcode{X}} and in the transitive closure of all namespaces nominated by
    \mbox{\techterm{using-directives}} in \mbox{\tcode{X}} and its used namespaces,
    except that \mbox{\techterm{using-directives}} that nominate non-inline namespaces
    (\mbox{\ref{namespace.memdef}}) are ignored in any namespace,
    including \mbox{\tcode{X}},
    directly containing one or more names of a concept map or concept map
    template.
No namespace is considered more than once to see if it contains a concept
map or concept map template.
If \mbox{\tcode{S}} is the empty set,
    the program is ill-formed.
For each element in \mbox{\tcode{S}},
    a name is introduced into the declarative region in which the
    \mbox{\techterm{using-declaration}} appears.
The name is a synonym for the referent concept map or concept map template.
}
\addedConcepts{
\mbox{\enterexample}}
\begin{codeblock}
namespace N1 {
  concept C<typename T> { }
  template<C T> void f(T) { }
}
namespace N2 {
  concept D<typename T> { }
}
namespace N3 {
  concept_map N1::C<int> { } // A
  template<typename T> concept_map N1::C<T*> { } // B
  concept_map N2::D<int> { } // C
}
namespace N4 {
  using N3::concept_map; // aliases A, B, and C
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum 
\addedConcepts{If the second \mbox{\emph{nested-name-specifier}} is
  specified but no 
concept is specified, then all concept maps in the namespace specified
by the first \mbox{\emph{nested-name-specifier}} for all concepts in the
namespace specified by the second \mbox{\emph{nested-name-specifier}} are
brought into scope.}

\pnum
\addedConcepts{\mbox{\enternote}
a \mbox{\emph{using-directive}} for a namespace brings the concept
maps of that namespace into scope, just like other entities.
\mbox{\exitnote}
\mbox{\enterexample}}
\begin{codeblock}
namespace N1 {
  concept C<typename T> { }
}
namespace N2 {
  concept_map N1::C<int> { }
}
namespace N3 {
  using namespace N2;

  template<N1::C T> void foo(T) { };

  void bar() {
    foo(17); // ok, finds the concept map from N2
  }
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\color{black}
\end{paras}

\setcounter{chapter}{7}
\rSec0[dcl.decl]{Declarators}
\setcounter{section}{2}
\rSec1[dcl.meaning]{Meaning of declarators}
\begin{paras}

\setcounter{Paras}{6}
\pnum
\addedConcepts{In a constrained }
 \changedCCC{template}{context} 
\addedConcepts{ (\mbox{\ref{temp.constrained}}),
  a type archetype \mbox{\techterm{cv} \tcode{T}} shall only
  be used as the type of a variable if the template has a concept
  requirement \mbox{\tcode{VariableType<T>}}.}

\rSec2[dcl.ptr]{Pointers}
\setcounter{Paras}{4}
\pnum
\addedConcepts{In a constrained }
 \changedCCC{template}{context} 
\addedConcepts{ (\mbox{\ref{temp.constrained}}),
  a type archetype \mbox{\techterm{cv} \tcode{T}} shall only
  be used to form a type ``pointer to \mbox{\techterm{cv} \tcode{T}}''
    if the template has a concept requirement 
  \mbox{\tcode{PointeeType<T>}}.}

\rSec2[dcl.ref]{References}
\setcounter{Paras}{5}
\pnum
\addedConcepts{In a constrained }
 \changedCCC{template}{context} 
\addedConcepts{ (\mbox{\ref{temp.constrained}}), a
  type archetype \mbox{\techterm{cv} \tcode{T}} shall only be
  used to form a type ``reference to \mbox{\techterm{cv} \tcode{T}}''
  if the 
  template has a concept requirement \mbox{\tcode{ReferentType<T>}}.}

\rSec2[dcl.mptr]{Pointers to members}
\setcounter{Paras}{2}
\pnum
A pointer to member shall not point to a static member
of a class (\ref{class.static}),
a member with reference type,
or
``\textit{cv}\
\tcode{void}.''
\addedConcepts{In a constrained }
 \changedCCC{template}{context} 
\addedConcepts{ (\mbox{\ref{temp.constrained}}), a
  pointer to member shall only point to a type archetype \mbox{\techterm{cv}
    \tcode{T}} if the template has a concept
  requirement \mbox{\tcode{MemberPointeeType<T>}}.}
% San Jose motion \#4
\enternote\ 
see also \ref{expr.unary} and \ref{expr.mptr.oper}.
The type ``pointer to member'' is distinct from the type ``pointer'',
that is, a pointer to member is declared only by the pointer to member
declarator syntax, and never by the pointer declarator syntax.
There is no ``reference-to-member'' type in \Cpp.
\exitnote\ 

\rSec2[dcl.array]{Arrays}
\setcounter{Paras}{1}
\pnum
An array can be constructed from one of the fundamental types
(except
\tcode{void}),
from a pointer,
from a pointer to member, from a class,
from an enumeration type,
or from another array.
\addedConcepts{In a constrained }
 \changedCCC{template}{context} 
\addedConcepts{ (\mbox{\ref{temp.constrained}}), an
  array shall only be constructed from a type archetype \mbox{\techterm{cv}
    \tcode{T}} if the template has a concept
  requirement \mbox{\tcode{ObjectType<T>}}.}

\rSec2[dcl.fct]{Functions}

\setcounter{Paras}{5}
\pnum
If the type of a parameter includes a type of the form
``pointer to array of unknown bound of \tcode{T}'' or
``reference to array of unknown bound of \tcode{T},''
the program is ill-formed.%
\footnote{
This excludes parameters of type
``\nonterminal{ptr-arr-seq}\ \tcode{T2}'' where \tcode{T2}\ is
``pointer to array of unknown bound of \tcode{T}'' and where
\nonterminal{ptr-arr-seq}\ means any sequence of ``pointer to'' and
``array of'' derived declarator types.
This exclusion applies to the parameters of the function,
and if a parameter is a pointer to function
or pointer to member function then to its
parameters also, etc.
}
\index{function~return~type|see{return~type}}%
\index{return~type}%
Functions shall not have a return type of type array or function,
although they may have a return type of type pointer or reference to such things.
There shall be no arrays of functions, although there can be arrays of pointers
to functions.
\addedConcepts{In a constrained }
 \changedCCC{template}{context} 
\addedConcepts{ (\mbox{\ref{temp.constrained}}), a
  type archetype \mbox{\techterm{cv}} \mbox{\tcode{T}} shall
  only be used as the return type of a function type if the template
  has a concept requirement \mbox{\tcode{Returnable<T>}}.}
Types shall not be defined in return or parameter types.
The type of a parameter or the return type for a function
definition shall not be an incomplete class type (possibly
cv-qualified) unless the function definition is nested
within the
\techterm{member-specification}\ 
for that class (including definitions in nested classes
defined within the class).
\end{paras}

\setcounter{chapter}{8}
\rSec0[class]{Classes}
\begin{paras}
\setcounter{section}{1}
\rSec1[class.mem]{Class members}

\index{member|seealso{base~class~member}}%
\index{class~member|see{also~member}}%
\index{data~member|see{member}}%
\index{declaration!member}%

\begin{bnf}
\index{member-specification@\techterm{member-specification}}%
member-specification:\br
        member-declaration member-specification\opt\br
        access-specifier \terminal{:}\ member-specification\opt
\end{bnf}

\begin{bnf}
\index{member-declaration@\techterm{member-declaration}}%
\index{declaration!class member}%
member-declaration:\br
        \addedConcepts{member-requirement\mbox{\opt}} decl-specifier-seq\opt\ member-declarator-list\opt\ \terminal{;}\br
        \addedConcepts{\mbox{member-requirement\opt}} function-definition \terminal{;\opt}\br
        \terminal{::\opt}\ nested-name-specifier \terminal{template\opt}\ unqualified-id \terminal{;}\br
        using-declaration\br
        static_assert-declaration\br
        template-declaration\br
\end{bnf}

\begin{bnf}
\index{member-requirement@\techterm{member-requirement}}%
\addedConcepts{member-requirement:}\br
        \addedConcepts{requires-clause}
\end{bnf}

\begin{bnf}
member-declarator-list:\br
        member-declarator\br
        member-declarator-list \terminal{,}\ member-declarator
\end{bnf}

\begin{bnf}
\index{member-declarator@\techterm{member-declarator}}%
member-declarator:\br
        declarator pure-specifier\opt\br
        declarator constant-initializer\opt\br
        identifier\opt\ \terminal{:}\ constant-expression
\end{bnf}

\begin{bnf}
\index{pure~specifier}%
\index{pure-specifier@\techterm{pure-specifier}}%
pure-specifier:\br
        \terminal{= 0}
\end{bnf}

\begin{bnf}
\index{initializer!constant}%
\index{constant-initializer@\techterm{constant-initializer}}%
constant-initializer:\br
        \terminal{=}\ constant-expression
\end{bnf}

\noindent\editorial{Add the following new paragraphs to 9 [class]}
\setcounter{Paras}{18}
\pnum
\addedConcepts{A non-template \mbox{\techterm{member-declaration}}
  that has a 
\mbox{\techterm{member-requirement}} (\mbox{\ref{temp.req}}) is a
\mbox{\techterm{constrained member}} and shall only occur in a class
template (\mbox{\ref{temp.class}}) or nested class thereof.
The \mbox{\techterm{member-declaration}} for a constrained
  member shall declare a member function.
A constrained member is
treated as a constrained template (\mbox{\ref{temp.constrained}})
whose template requirements include the requirements
  specified in its \mbox{\techterm{member-requirement}} clause.}
\end{paras}

\setcounter{chapter}{11}
\rSec0[special]{Special member functions}
\begin{paras}

\rSec1[class.ctor]{Constructors}
\setcounter{Paras}{4}

\pnum
\index{constructor!inheritance~of}%
\index{default~constructor}%
\index{constructor!non-trivial}%
A
\techterm{default}\ 
constructor for a class
\tcode{X}
is a constructor of class
\tcode{X}
that can be called without an argument.
\index{implicitly-declared~default~constructor}%
If there is no user-declared constructor for class
\tcode{X},
a constructor having no parameters is implicitly declared.
An implicitly-declared default constructor is an
\tcode{inline}
\tcode{public}
member of its class.
\removedConcepts{For a union-like class that has a variant member with a
  non-trivial default constructor, an implicitly-declared default
  constructor is defined as deleted (\mbox{\ref{dcl.fct.def}}).}
A default constructor is
\techterm{trivial}\ 
if it is implicitly-declared and if:

\begin{itemize}
\item
its class has no virtual functions (\ref{class.virtual}) and no virtual base
classes (\ref{class.mi}), and
\item
all the direct base classes of its class have trivial default constructors, and
\item
for all the non-static data members of its class that are of class
type (or array thereof), each such class has a trivial default constructor.
\end{itemize}
\addedConcepts{An implicitly-declared default constructor for class
  \mbox{\tcode{X}} is deleted if:}
\begin{itemize}
\additemConcepts{\mbox{\tcode{X}} is a union-like class that has a variant
  member with a non-trivial default constructor,}
\additemConcepts{any non-static data member is of reference type,}
\additemConcepts{any non-static data member of const-qualified type (or array
thereof) does not have a user-provided default constructor, or}
\additemConcepts{any non-static data member or direct or virtual base class has
class type \mbox{\tcode{M}} (or array thereof) and \mbox{\tcode{M}}
has no default constructor, or if overload resolution
(\mbox{\ref{over.match}}) as applied to \mbox{\tcode{M}}'s default
constructor, results in an ambiguity or a function that is deleted or
inaccessible from the implicitly-declared default constructor.} 
\end{itemize}

\setcounter{Paras}{6}
\pnum
A non-user-provided default constructor for a class is
\techterm{implicitly}\ 
\techterm{defined}\ 
when it is used (\ref{basic.def.odr})
to create an object of its class type (\ref{intro.object}).
The implicitly-defined or explicitly-defaulted default constructor
performs the set of
initializations of the class that would be performed by a
user-written default constructor for that class with an empty
\techterm{mem-initializer-list}\ 
(\ref{class.base.init}) and an empty function
body.
\addedConcepts{If the implicitly-defined copy constructor
is explicitly defaulted, but the corresponding implicit declaration
would have been deleted, the program is ill-formed.}
If that 
user-written default constructor would satisfy the requirements of a
constexpr constructor (\ref{decl.constexpr}), the implicitly-defined  
default constructor is constexpr. 
Before the non-user-provided default constructor for a class is
implicitly defined,
all the non-user-provided default constructors for its base classes and
its non-static data members shall have been implicitly defined.
\enternote\ 
an implicitly-declared default constructor has an
\techterm{exception-specification}~(\ref{except.spec}).
An explicitly-defaulted definition has no implicit
\techterm{exception-specification}.
\exitnote\ 

\setcounter{section}{2}
\rSec1[class.conv]{Conversions}
\setcounter{subsection}{1}
\rSec2[class.conv.fct]{Conversion functions}
\pnum
\index{fundamental~type~conversion|see{conversion, user-defined conversion}}%
\index{conversion!user-defined}%
\index{conversion operator|see{conversion~function}}%
\index{function!conversion}%
A member function of a class
\tcode{X}
\addedConcepts{having no parameters}
\addedConcepts{or an associated function of a concept whose sole
  parameter is of type \mbox{\tcode{X}}, and}
with a name of the form

% San Jose, Motion 35:\br
\begin{bnf}
\index{conversion-function-id@\techterm{conversion-function-id}}%
conversion-function-id:\br
	\terminal{operator}\ conversion-type-id
\end{bnf}

\begin{bnf}
conversion-type-id:\br
	type-specifier-seq conversion-declarator\opt
\end{bnf}

\begin{bnf}
conversion-declarator:\br
	ptr-operator conversion-declarator\opt
\end{bnf}

specifies a conversion from
\tcode{X}
to the type specified by the
\techterm{conversion-type-id}.
Such \removedConcepts{member} functions are called conversion functions.
Classes, enumerations, and
\techterm{typedef-name}s
shall not be declared in the
\techterm{type-specifier-seq}.
\changedConcepts{Neither parameter types nor}{No} return type can be specified.
\index{conversion!type~of}%
The type of a conversion function (\ref{dcl.fct}) is
``function taking no parameter \addedConcepts{(if the conversion
  function is a member function) or a parameter of type
  \mbox{\tcode{X}} (if the conversion function is an associated
  function)} returning
\techterm{conversion-type-id}.''
A conversion function is never used to convert a (possibly cv-qualified) object
to the (possibly cv-qualified) same object type (or a reference to it),
to a (possibly cv-qualified) base class of that type (or a reference to it),
or to (possibly cv-qualified) void.%
\footnote{
Even though never directly called to perform a conversion,
such conversion functions can be declared and can potentially
be reached through a call to a virtual conversion function in a base class
}

\enterexample\ 

\begin{codeblock}
class X {
    // ...
public:
    operator int();
};

void f(X a)
{
    int i = int(a);
    i = (int)a;
    i = a;
}
\end{codeblock}

In all three cases the value assigned will be converted by
\tcode{X::operator\ int()}.
\exitexample\ 

\rSec1[class.dtor]{Destructors}

\setcounter{Paras}{2}
\pnum
\index{generated~destructor|see{default destructor}}%
\index{destructor!default}%
\index{destructor!non-trivial}%
If a class has no user-declared
destructor, 
a destructor is declared implicitly.
An implicitly-declared destructor is an
\tcode{inline}
\tcode{public}
member of its class. 
\removedConcepts{If the class is a union-like class that has a variant
  member with a non-trivial destructor, an implicitly-declared
  destructor is defined as delected (\mbox{\ref{dcl.fct.def}}).}
A destructor is
\techterm{trivial}\ 
if it is implicitly-declared and if:

\begin{itemize}
\item
all of the direct base classes of its class have trivial destructors and
\item
for all of the non-static data members of its class that are of class
type (or array thereof), each such class has a trivial destructor.
\end{itemize}
\addedConcepts{An implicitly-declared destructor for a class
  \mbox{\tcode{X}} is deleted if:}
\begin{itemize}
\additemConcepts{\mbox{\tcode{X}} is a union-like class that has a variant
  member with a non-trivial destructor,}
\additemConcepts{any of the non-static data members has class type
  \mbox{\tcode{M}} (or array thereof) and
  \mbox{\tcode{M}} has an deleted destructor} \addedConcepts{or a destructor
  that is inaccessible from the implicitly-declared destructor}\addedConcepts{, or}
\additemConcepts{any direct or virtual base class has a deleted
  destructor} \addedConcepts{or a destructor that is inaccessible from the
  implicitly-declared destructor.}
\end{itemize}

\setcounter{Paras}{4}
\pnum
An implicitly-declared destructor is
\techterm{implicitly}\ 
\techterm{defined}\ 
when it is used to destroy an object of its class type (\ref{basic.stc}).
A program is ill-formed
\changedConcepts{if the class for which a destructor is implicitly
defined has:}{if the implicitly-defined destructor is explicitly
defaulted, but the corresponding implicit declaration would have been deleted.}

\begin{itemize}
\item
\removedConcepts{a non-static data member of class type (or array thereof) with an
inaccessible destructor, or}
\item
\removedConcepts{a base class with an inaccessible destructor.}
\end{itemize}

Before the implicitly-declared destructor for a class is implicitly defined,
all the implicitly-declared destructors for its base classes and
its non-static data members shall have been implicitly defined.
\enternote\ 
an implicitly-declared destructor has an
\techterm{exception-specification}~(\ref{except.spec}).
\exitnote\ 

\setcounter{section}{7}
\rSec1[class.copy]{Copying class objects}

\setcounter{Paras}{3}
\pnum
\index{copy~constructor!implicitly-declared}%
If the class definition does not explicitly declare a copy constructor,
one is declared
\techterm{implicitly}. \removedConcepts{If the class is a union-like class
  that has a variant member with a non-trivial copy constructor, an
  implicitly-declared copy constructor is defined as deleted
  (\mbox{\ref{dcl.fct.def}}).}
Thus, for the class definition

\begin{codeblock}
struct X {
	X(const X&, int);
};
\end{codeblock}

a copy constructor is implicitly-declared.
If the user-declared constructor is later defined as

\begin{codeblock}
X::X(const X& x, int i =0) { /* ... */ }
\end{codeblock}

then any use of
\tcode{X}'s
copy constructor is ill-formed because of the ambiguity;
no diagnostic is required.

\setcounter{Paras}{4}
\pnum
The implicitly-declared copy constructor for a class
\tcode{X}
will have the form

\begin{codeblock}
X::X(const X&)
\end{codeblock}

if

\begin{itemize}
\item
each direct or virtual base class
\tcode{B}
of
\tcode{X}
has a copy constructor whose first parameter is of type
\tcode{const}
\tcode{B\&}
or
\tcode{const}
\tcode{volatile}
\tcode{B\&},
and
\item
for all the non-static data members of
\tcode{X}
that are of a class type
\tcode{M}
(or array thereof),
each such class type has a copy constructor whose first parameter is of type
\tcode{const}
\tcode{M\&}
or
\tcode{const}
\tcode{volatile}
\tcode{M\&}.%
\footnote{
This implies that the reference parameter of the
implicitly-declared copy constructor
cannot bind to a
\tcode{volatile}
lvalue; see \ref{diff.special}.
}
\end{itemize}

Otherwise, the implicitly declared copy constructor will have the form

\begin{codeblock}
X::X(X&)
\end{codeblock}

An implicitly-declared copy constructor is an
\tcode{inline}
\tcode{public}
member of its class.
\addedConcepts{An implicitly-declared copy constructor for a class
  \mbox{\tcode{X}} is deleted if \mbox{\tcode{X}} has:}
\begin{itemize}
\additemConcepts{a variant member with a non-trivial copy constructor and
  \mbox{\tcode{X}} is a union-like class,}
\additemConcepts{a non-static data member of class type
  \mbox{\tcode{M}} (or array thereof) that cannot be copied because
  overload resolution (\mbox{\ref{over.match}}), as applied to
  \mbox{\tcode{M}}'s 
  copy constructor, results in an ambiguity or 
  a function that is deleted or inaccessible from the
  implicitly-declared copy constructor, or}
\additemConcepts{a direct or virtual base class \mbox{\tcode{B}} that cannot
  be copied because overload resolution (\mbox{\ref{over.match}}), as applied to
  \mbox{\tcode{B}}'s copy constructor, results in an ambiguity
  or a function that is deleted or
  inaccessible from the implicitly-declared copy constructor.}
\end{itemize}
\end{paras}

\setcounter{Paras}{6}
\pnum
A non-user-provided copy constructor is
\techterm{implicitly}\ 
\techterm{defined}\ 
if it is used to initialize an object of its class type from a copy of an
object of its class type or of a class type derived from its class type%
\footnote{
See \ref{dcl.init} for more details on direct and copy initialization.
}.
\enternote\ 
the copy constructor is implicitly defined even if the implementation elided
its use (\ref{class.temporary}).
\exitnote\ 
\index{restriction!copy constructor}%
A program is ill-formed \changedConcepts{if the class for which a copy constructor is
implicitly defined or explicitly defaulted has:}{if the
implicitly-defined copy constructor is explicitly defaulted, but the 
corresponding implicit declaration would have been deleted.}

\begin{itemize}
\item
\removedConcepts{a non-static data member of class type (or array thereof) with an inaccessible
or ambiguous copy constructor, or}
\item
\removed{a base class with an inaccessible or ambiguous copy constructor.}
\end{itemize}

Before the non-user-provided copy constructor for a class is
implicitly defined,
all non-user-provided copy constructors for its direct and
virtual base classes and its non-static data members
shall have been implicitly defined.
\enternote\ 
an implicitly-declared copy constructor has an
\techterm{exception-specification}~(\ref{except.spec}).
An explicitly-defaulted definitions has no implicit \emph{exception-specifion}.
\exitnote\ 

\setcounter{Paras}{9}
\pnum
\index{copy~assignment~operator!implicitly-declared}%
If the class definition does not explicitly declare a copy assignment operator,
one is declared
\techterm{implicitly}.
\removedConcepts{If the class is 
a union-like class that has a variant member with a non-trivial copy
assignment operator, an implicitly-declared copy  
assignment operator is defined as deleted (\mbox{\ref{dcl.fct.def}}).}
The implicitly-declared copy assignment operator for a class
\tcode{X}
will have the form

\begin{codeblock}
X& X::operator=(const X&)
\end{codeblock}

if

\begin{itemize}
\item
each direct base class
\tcode{B}
of
\tcode{X}
has a copy assignment operator whose parameter is of type
\tcode{const}
\tcode{B\&},
\tcode{const}
\tcode{volatile}
\tcode{B\&}
or
\tcode{B},
and
\item
for all the non-static data members of
\tcode{X}
that are of a class type
\tcode{M}
(or array thereof),
each such class type has a copy assignment operator whose parameter is of type
\tcode{const}
\tcode{M\&},
\tcode{const}
\tcode{volatile}
\tcode{M\&}
or
\tcode{M}.%
\footnote{
This implies that the reference parameter of the
implicitly-declared copy assignment operator cannot bind to a
\tcode{volatile}
lvalue; see \ref{diff.special}.
}
\end{itemize}

Otherwise, the implicitly declared copy
assignment operator
will have the form

\begin{codeblock}
X& X::operator=(X&)
\end{codeblock}

The implicitly-declared copy assignment operator for class
\tcode{X}
has the return type
\tcode{X\&};
it returns the object for which the assignment operator is invoked, that is,
the object assigned to.
An implicitly-declared copy assignment operator is an
\tcode{inline}
\tcode{public}
member of its class.
\addedConcepts{An implicitly-declared copy assignment operator for
  class \mbox{\tcode{X}} is deleted if \mbox{\tcode{X}} has:}
\begin{itemize}
\additemConcepts{a variant member with a non-trivial copy constructor and
  \mbox{\tcode{X}} is a union-like class,}
\additemConcepts{a non-static data member of \mbox{\tcode{const}} non-class
  type (or array thereof), or}
\additemConcepts{a non-static data member of reference type, or}
\additemConcepts{a non-static data member of class type \mbox{\tcode{M}}
  (or array thereof) that cannot be copied because overload resolution
  (\mbox{\ref{over.match}}), as applied to \mbox{\tcode{M}}'s copy
  assignment operator, results in an ambiguity or
  a function that is deleted or inaccessible from the
  implicitly-declared copy assignment operator, or}
\additemConcepts{a direct or virtual base class \mbox{\tcode{B}} that cannot
  be copied because overload resolution 
  (\mbox{\ref{over.match}}), as applied to \mbox{\tcode{B}}'s copy
  assignment operator, results in an ambiguity or
  a function that is deleted or inaccessible from the
  implicitly-declared copy assignment operator.}
\end{itemize}
Because a copy assignment operator is implicitly declared for a class
if not declared by the user,
a base class copy assignment operator is always hidden
by the copy assignment operator of a derived class (\ref{over.ass}).
% USA CD2-core 1-5 core-672
% Using-declarations cannot introduce copy-assignment operators
A
\techterm{using-declaration}\ 
(\ref{namespace.udecl}) that brings in from a base class an assignment operator
with a parameter type that could be that of a copy-assignment operator for the
derived class is not considered an explicit declaration of a copy-assignment
operator and does not suppress the implicit declaration of the derived class
copy-assignment operator;
the operator introduced by the
\techterm{using-declaration}\ 
is hidden by the implicitly-declared copy-assignment operator in the derived
class.

\setcounter{Paras}{11}
\pnum
A non-user-provided copy assignment operator is
\techterm{implicitly}\ 
\techterm{defined}\ 
when an object of its class type is assigned a value of its class type or
a value of a class type derived from its class type.
\index{restriction!copy assignment~operator}%
A program is ill-formed \changedConcepts{if the class for which a copy assignment operator
is implicitly defined has:}{if the implicitly-defined copy assignment operator
is explicitly defaulted, but the corresponding implicit 
declaration would have been deleted.}

\begin{itemize}
\item
\removedConcepts{a non-static data member of
\mbox{\tcode{const}}
type, or}
\item
\removedConcepts{a non-static data member of reference type, or}
\item
\removedConcepts{a non-static data member of class type (or array thereof) with an inaccessible
copy assignment operator, or}
\item
\removedConcepts{a base class with an inaccessible copy assignment operator.}
\end{itemize}

Before the non-user-provided copy assignment operator for a class is
implicitly defined,
all non-user-provided copy assignment operators for
its direct base classes and
its non-static data members shall have been implicitly defined.
\enternote\ 
an implicitly-declared copy assignment operator has an
\techterm{exception-specification}~(\ref{except.spec}).
An explicitly-defaulted 
definition has no implicit \techterm{exception-specification}.
\exitnote\ 

\rSec1[class.inhctor]{Inheriting Constructors}
\setcounter{Paras}{1}
\pnum
The \techterm{constructor characteristics} of a constructor or
constructor template are
\begin{itemize}
\item the template parameter list (\ref{temp.param}), if any,
\additemConcepts{the template requirements (\mbox{\ref{temp.req}}), if any,}
\item the \techterm{parameter-type-list} (\ref{decl.fct}),
\item the \techterm{exception-specification} (\ref{except.spec}),
\item absence or presence of \tcode{explicit} (\ref{class.conv.ctor}), and
\item absence or presence of \tcode{constexpr} (\ref{dcl.constexpr}).
\end{itemize}

\setcounter{chapter}{12}
\rSec0[over]{Overloading}

\rSec1[over.load]{Overloadable declarations}
\setcounter{Paras}{1}

\pnum
Certain function declarations cannot be overloaded:

\begin{itemize}
\item
\index{return~type!overloading~and}%
Function declarations that differ only in the return type cannot be
overloaded.
\item
\index{static@\tcode{static}!overloading~and}%
Member function declarations with the same name\changedConcepts{ and}{,} the same
\techterm{parameter-type-list}\addedConcepts{ and the same template requirements (if
  any)}, the same  cannot be overloaded if any of them is a 
\tcode{static}
member function declaration (\ref{class.static}).
Likewise, member function template declarations with the same name,
the same parameter-type-list, \removedConcepts{and} the same template
parameter lists\addedConcepts{, and the same template requirements (if any)} cannot be
overloaded if any of them is a
\tcode{static}
member function template declaration.
The types of the implicit object parameters constructed for the member
functions for the purpose of overload resolution (\ref{over.match.funcs})
are not considered when comparing parameter-type-lists for enforcement of
this rule.
In contrast, if there is no
\tcode{static}
member function declaration among a set of member function
declarations with the same name and the same parameter-type-list, then
these member function declarations can be overloaded if they differ in
the type of their implicit object parameter.
\enterexample\ 
the following illustrates this distinction:

\begin{codeblock}
class X {
    static void f();
    void f();                   // ill-formed
    void f() const;             // ill-formed
    void f() const volatile;    // ill-formed
    void g();
    void g() const;             // OK: no static \tcode{g}
    void g() const volatile;    // OK: no static \tcode{g}
};
\end{codeblock}
\exitexample\

\item
Member function declarations with the same name and the same \techterm{parameter-type-list} as well as member function 
template declarations with the same name, the same
\techterm{parameter-type-list}, \removedConcepts{and} the same template
parameter lists\addedConcepts{, and the same template requirements}, 
cannot be overloaded if any of them, but not all, have a
\techterm{ref-qualifier} (\ref{dcl.fct}). \enterexample\
\begin{codeblock}
class Y { 
    void h() &; 
    void h() const &; // OK 
    void h() &&; // OK, all declarations have a ref-qualifier 
    void i() &; 
    void i() const; // ill-formed, prior declaration of i 
                    @\textcolor{black}{}@// has a ref-qualifier 
}; 
\end{codeblock}
\exitexample\

\end{itemize}

\setcounter{section}{2}
\rSec1[over.match]{Overload resolution}
\rSec2[over.match.funcs]{Candidate functions and argument lists}
\pnum
The subclauses of \ref{over.match.funcs} describe
the set of candidate functions and the argument list submitted to
overload resolution in each of the seven contexts in which
overload resolution is used.
\addedConcepts{\mbox{\enternote} With concepts (\mbox{\ref{concept}}) and
  constrained templates, the set of candidate functions can be
  determined by an associated function candidate set or a retained
  candidate set (\mbox{\ref{temp.constrained.set}}). \mbox{\exitnote}}
The source transformations and constructions defined
in these subclauses are only for the purpose of describing the
overload resolution process.
An implementation is not required
to use such transformations and constructions.


\setcounter{section}{4}
\rSec1[over.oper]{Overloaded operators}

\setcounter{subsection}{3}
\rSec2[over.call]{Function call}

\pnum
\index{function~call~operator!overloaded}%
\addedConcepts{If declared in a class type,}
\tcode{operator()}
shall be a non-static member function with an arbitrary number of
parameters.
It can have default arguments.
It implements the function call syntax

\begin{ncsimplebnf}
postfix-expression \terminal{(}\ expression-list\opt\ \terminal{)}
\end{ncsimplebnf}

where the
\techterm{postfix-expression}\ 
evaluates to a class object and the possibly empty
\techterm{expression-list}\ 
matches the parameter list of an
\tcode{operator()}
member function of the class.
Thus, a call
\tcode{x(arg1,...)}
is interpreted as
\tcode{x.op\-er\-a\-tor()(arg1, ...)}
for a class object
\tcode{x}
of type
\tcode{T}
if
\tcode{T::operator()(T1,}
\tcode{T2,}
\tcode{T3)}
exists and if the operator is selected as the best match function by
the overload resolution mechanism (\ref{over.match.best}).

\pnum
\index{function~call~operator!overloaded}%
\addedConcepts{If declared in a concept}
\addedConcepts{or concept map}\addedConcepts{, \mbox{\tcode{operator()}}
shall be a non-member associated function with one or more parameters.}
\addedConcepts{It implements the function call syntax}

\color{addclr}
\begin{ncsimplebnf}
postfix-expression \terminal{(}\ expression-list\opt\ \terminal{)}
\end{ncsimplebnf}
\color{black}

\addedConcepts{where the
\mbox{\techterm{postfix-expression}}
evaluates to an object and the possibly empty
\mbox{\techterm{expression-list}}
matches the parameter list of the
\mbox{\tcode{operator()}}
associated function after the first parameter of the parameter list
has been removed.
Thus, a call
\mbox{\tcode{x(arg1,...)}}
is interpreted as
\mbox{\tcode{op\-er\-a\-tor()(x, arg1, ...)}}
for an object
\mbox{\tcode{x}}
of type
\mbox{\tcode{T}}
if
\mbox{\tcode{operator()(T, T1,}}
\mbox{\tcode{T2,}}
\mbox{\tcode{T3)}}
exists and if the operator is selected as the best match function by
the overload resolution mechanism (\mbox{\ref{over.match.best}}).}

\rSec2[over.sub]{Subscripting}

\pnum
\index{subscripting~operator!overloaded}%
\addedConcepts{If declared in a class type,}
\tcode{operator[]}
shall be a non-static member function with exactly one parameter.
It implements the subscripting syntax

\begin{ncsimplebnf}
postfix-expression \terminal{[}\ expression \terminal{]}
\end{ncsimplebnf}

Thus, a subscripting expression
\tcode{x[y]}
is interpreted as
\tcode{x.operator[](y)}
for a class object
\tcode{x}
of type
\tcode{T}
if
\tcode{T::op\-er\-a\-tor[]\-(T1)}
exists and if the operator is selected as the best match function by
the overload resolution mechanism (\ref{over.match.best}).

\pnum
\addedConcepts{If declared in a concept}
\addedConcepts{or concept map}\addedConcepts{, \mbox{\tcode{operator[]}}
shall be a non-member associated function with exactly two parameters.
It implements the subscripting syntax}

\color{addclr}
\begin{ncsimplebnf}
postfix-expression \terminal{[}\ expression \terminal{]}
\end{ncsimplebnf}
\color{black}

\addedConcepts{Thus, a subscripting expression
\mbox{\tcode{x[y]}}
is interpreted as
\mbox{\tcode{operator[](x, y)}}
for an object
\mbox{\tcode{x}}
of type
\mbox{\tcode{T}}
if
\mbox{\tcode{op\-er\-a\-tor[]\-(T, T1)}}
exists and if the operator is selected as the best match function by
the overload resolution mechanism (\mbox{\ref{over.match.best}}).}

\rSec2[over.ref]{Class member access}

\pnum
\index{member~access~~operator!overloaded}%
\addedConcepts{If declared in a class type,}
\tcode{operator->}
shall be a non-static member function taking no parameters.
It implements class member access using
\tcode{->}

\begin{ncsimplebnf}
postfix-expression \terminal{->}\ id-expression
\end{ncsimplebnf}

An expression
\tcode{x->m}
is interpreted as
\tcode{(x.operator->())->m}
for a class object
\tcode{x}
of type
\tcode{T}
if
\tcode{T::operator->()}
exists and if the operator is selected as the best match function by
the overload resolution mechanism (\ref{over.match}).

\pnum
\index{member~access~~operator!overloaded}%
\addedConcepts{If declared in a concept}
\addedConcepts{or concept map}\addedConcepts{,
\mbox{\tcode{operator->}}
shall be a non member associated function taking exactly one parameter.
It implements class member access using
\mbox{\tcode{->}}}

\color{addclr}
\begin{ncsimplebnf}
postfix-expression \terminal{->}\ id-expression
\end{ncsimplebnf}
\color{black}

\addedConcepts{An expression
\mbox{\tcode{x->m}}
is interpreted as
\mbox{\tcode{(operator->(x))->m}}
for an object
\mbox{\tcode{x}}
of type
\mbox{\tcode{T}}
if
\mbox{\tcode{operator->(T)}}
exists and if the operator is selected as the best match function by
the overload resolution mechanism (\mbox{\ref{over.match}}).}

\setcounter{section}{5}
\rSec1[over.built]{Built-in operators}

\pnum
The candidate operator functions that represent the built-in operators
defined in clause \ref{expr} are specified in this subclause.
These candidate
functions participate in the operator overload resolution process as
described in \ref{over.match.oper} and are used for no other purpose.
\addedConcepts{No built-in operators are defined for archetypes
  (\mbox{\ref{temp.archetype}}), even though 
  template requirements naming compiler-supported concepts
  (\mbox{\ref{concept.support}}) can classify archetypes as non-class
  types.}
\enternote\ 
because built-in operators take only operands with non-class type,
and operator overload resolution occurs only when an operand expression
originally has class or enumeration type,
operator overload resolution can resolve to a built-in operator only
when an operand has a class type that has a user-defined conversion to
a non-class type appropriate for the operator, or when an operand has
an enumeration type that can be converted to a type appropriate
for the operator.
Also note that some of the candidate operator functions given in this subclause are
more permissive than the built-in operators themselves.
As
described in \ref{over.match.oper}, after a built-in operator is selected
by overload resolution the expression is subject to the requirements for
the built-in operator given in clause \ref{expr}, and therefore to any
additional semantic constraints given there.
If there is a user-written
candidate with the same name and parameter types as a built-in
candidate operator function, the built-in operator function
is hidden and is not included in the set of candidate functions.
\exitnote\ 

\rSec0[temp]{Templates}
\begin{paras}

\textcolor{black}{\pnum}
\index{template}%
\index{parameterized~type|see{template}}%
\index{type~generator|see{template}}%
\index{export}%
A
\techterm{template}\ 
defines a family of classes\changedConcepts{or functions}{, functions,
  or concept maps}, or an alias for a family of types.

\begin{bnf}
\index{template-declaration@\techterm{template-declaration}}%
\index{template@\tcode{template}}%
template-declaration:\br
  \terminal{export\opt} \terminal{template <}\ template-parameter-list \terminal{>}\ \textcolor{addclr}{requires-clause\opt} declaration
\end{bnf}

\begin{bnf}
\index{template-parameter-list@\techterm{template-parameter-list}}%
template-parameter-list:\br
  template-parameter\br
  template-parameter-list \terminal{,}\ template-parameter
\end{bnf}

The
\techterm{declaration}\ 
in a
\techterm{template-declaration}\ 
shall

\begin{itemize}
\item
declare or define a function or a class, or
\item
define a member function, a member class or a static data member of a class
template or of a class nested within a class template, or
\item
define a member template of a class or class template, or
\item be an \techterm{alias-declaration}\changedConcepts{.}{, or}
\additemConcepts{define a concept map.}
\end{itemize}

A
\techterm{template-declaration}\ 
is a
\techterm{declaration}.
\index{template!definition~of}%
A
\techterm{template-declaration}\ 
is also a definition if its
\techterm{declaration}\ 
defines a function, a class, \addedConcepts{a concept map,}
or a static data member.

\setcounter{Paras}{4}
\pnum
A class template shall not have the same name as any other
template, class, \addedConcepts{concept,} function, object, enumeration, enumerator, namespace, or
type in the same scope (\ref{basic.scope}), except as specified in (\ref{temp.class.spec}).
Except that a function template can be overloaded either by (non-template)
functions with the same name or by other function templates
with the same name (\ref{temp.over}),
a template name declared in namespace scope or in class scope shall be unique
in that scope.

\noindent\editorial{Add the following new paragraphs to [temp]:}
\setcounter{Paras}{11}
\pnum
\addedConcepts{A \mbox{\techterm{template-declaration}} with a 
\mbox{\tcode{requires}} keyword is a constrained
  template (\mbox{\ref{temp.constrained}}). The 
\mbox{\techterm{requires-clause}}
  specifies template requirements (\mbox{\ref{temp.req}}).}

\rSec1[temp.param]{Template parameters}
\pnum
The syntax for
\techterm{template-parameter}s
is:

\begin{bnf}
\index{template-parameter@\techterm{template-parameter}}%
template-parameter:\br
  type-parameter\br
  parameter-declaration\br
  \addedConcepts{constrained-template-parameter}
\end{bnf}

\begin{bnf}
\index{type-parameter@\techterm{type-parameter}}%
type-parameter:\br
  \terminal{class}\ \terminal{...}\opt\ identifier\opt\br
  \terminal{class}\ identifier\opt\ \terminal{=}\ type-id\br
  \terminal{typename}\ \terminal{...}\opt\ identifier\opt\br
  \terminal{typename}\ identifier\opt\ \terminal{=}\ type-id\br
  \terminal{template <}\ template-parameter-list \terminal{> class}\ \terminal{...}\opt\ identifier\opt\br
  \terminal{template <}\ template-parameter-list \terminal{> class}\ identifier\opt\ \terminal{=}\ id-expression\br

\index{constrained-template-parameter@\techterm{constrained-template-parameter}}%
\addedConcepts{constrained-template-parameter:}\br
    \addedConcepts{\mbox{\terminal{::}}\mbox{\opt} nested-name-specifier\mbox{\opt} concept-name \mbox{\terminal{...}}\mbox{\opt} identifier\mbox{\opt}}\br
    \addedConcepts{\mbox{\terminal{::}\opt} nested-name-specifier\mbox{\opt} concept-name identifier\mbox{\opt} constrained-default-argument\mbox{\opt}}\br
    \addedConcepts{\mbox{\terminal{::}\opt} nested-name-specifier\mbox{\opt} concept-name \mbox{\terminal{<}}} \addedConcepts{simple-requirement-argument-list} \addedConcepts{\mbox{\terminal{>}} \mbox{\terminal{...}\opt} identifier} \br
    \addedConcepts{\mbox{\terminal{::}\opt} nested-name-specifier\mbox{\opt} concept-name \mbox{\terminal{<}}} \addedConcepts{simple-requirement-argument-list} \addedConcepts{\mbox{\terminal{>}}} \addedConcepts{identifier} \addedConcepts{constrained-default-argument\mbox{\opt}}\br

\index{constrained-default-argument@\techterm{constrained-default-argument}}%
\addedConcepts{constrained-default-argument:}\br
    \addedConcepts{\mbox{\terminal{=}} type-id}\br
    \addedConcepts{\mbox{\terminal{=}} assignment-expression }\br
    \addedConcepts{\mbox{\terminal{=}} id-expression }\br

\addedConcepts{simple-requirement-argument-list}:\br
  \addedConcepts{\mbox{\terminal{auto}}}\br
  \addedConcepts{\mbox{\terminal{auto}} \mbox{\terminal{,}} template-argument-list}
\end{bnf}

\setcounter{Paras}{3}
\pnum
A non-type \techterm{template-parameter} shall have one of the
following (optionally \techterm{cv-qualified}) types:
\begin{itemize}
\item integral or enumeration type,
\item pointer to object or pointer to function,
\item reference to object or reference to function,
\item pointer to member\changedConcepts{.}{, or}
\additemConcepts{in a constrained template
(\mbox{\ref{temp.constrained}}), a type archetype \mbox{\tcode{T}}
for which the concept requirement
\\\mbox{\tcode{NonTypeTemplateParameterType<T>}} (\mbox{\ref{concept.support}}) is
part of the template's requirements.}
\end{itemize}

\noindent\editorial{Add the following new paragraph to 14.1 [temp.param]}
\setcounter{Paras}{17}
\color{addclr}
\pnum
\addedConcepts{A \mbox{\techterm{template-parameter}} declared with a
  \mbox{\techterm{concept-name}}
is a template type, non-type or template
parameter or parameter pack that specifies a
template requirement (\mbox{\ref{temp.req}}) using the \mbox{\techterm{simple form}}
of template requirements. The kind (type, non-type or template) of the
parameter is 
that of the first template parameter of the concept named in the
\mbox{\techterm{constrained-template-parameter}}.  For a non-type parameter,
the type is that of the first template parameter of the concept named in the
\mbox{\techterm{constrained-template-parameter}}.  For a template parameter,
the template parameter list is that of the first template parameter of the
concept named in the \mbox{\techterm{constrained-template-parameter}}. 
A template parameter or parameter pack written 
\mbox{\tcode{\BnfTermshape{::}\opt\
  \BnfNontermshape{nested-name-specifier}\opt\ C ...\opt\ T}}, where \mbox{\tcode{C}} is a \mbox{\techterm{concept-name}}, is
equivalent to a template 
parameter or parameter pack \mbox{\tcode{T}} declared as a
\mbox{\techterm{type-parameter}} or
\mbox{\techterm{parameter-declaration}}
with the template requirement or pack expansion \mbox{\tcode{\BnfTermshape{::}\opt\
  \BnfNontermshape{nested-name-specifier}\opt}} \mbox{\tcode{C<T> ...\opt}} added to
the template requirements.}
%
\addedConcepts{A template parameter or parameter pack written
\mbox{\tcode{\BnfTermshape{::}\opt\
  \BnfNontermshape{nested-name-specifier}\opt}}
\mbox{\tcode{C<auto, T2, T3, ..., T$N$>...\opt\
  T}}, is equivalent to a template parameter or
parameter pack \mbox{\tcode{T}} declared as a
\mbox{\techterm{type-parameter}} or
\mbox{\techterm{parameter-declaration}}
with the template requirement
\mbox{\tcode{\BnfTermshape{::}\opt\
  \BnfNontermshape{nested-name-specifier}\opt\}}} \mbox{\tcode{C<T, T2, T3, ...,
  T$N$>...\opt}} added to the template requirements.
}
\begin{codeblock}
concept C<typename T> { ... }
concept D<typename T, typename U> { ... }
concept E<typename T, typename U, typename V = U> { ... }

template<C T, D<auto, T> P> void f(T, P);
// equivalent to
template<class T, class P> requires C<T> && D<P, T> void f(T, P);

template<C T, E<auto, T> P> void f(T, P);
// equivalent to
template<class T, class P> requires C<T> && E<P, T, T> void f(T, P);
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\addedConcepts{When the \mbox{\techterm{type-parameter}} is a template type parameter pack,
the equivalent requirement is a pack expansion (\mbox{\ref{temp.variadic}}). 
\mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> { }

template<C... Args> void g(Args const&...);
// equivalent to
template<typename... Args> requires C<Args>... void g(Args const&...);
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\color{black}

\setcounter{section}{3}
\rSec1[temp.type]{Type equivalence}
\setcounter{Paras}{1}

\noindent\editorial{Add the following new paragraph to 14.4
  [temp.type]}
\pnum
\addedConcepts{In a constrained context
(\mbox{\ref{temp.constrained}}), two types are the
same type if some same-type requirement makes them
equivalent (\mbox{\ref{temp.req}}).}

\rSec1[temp.decls]{Template declarations}

\rSec2[temp.class]{Class templates}

\noindent\editorial{Add the following new paragraph to 14.5.1
  [temp.class]}
\setcounter{Paras}{4}
\color{addclr}
\pnum
\addedConcepts{A constrained member (\mbox{\ref{class.mem}}) in a class template is
declared only in class template specializations in which its
template requirements (\mbox{\ref{temp.req}}) are satisfied. If there exist multiple
overloads of the constrained member with identical signatures, ignoring
  the template requirements, only the most specialized
  overload, as determined by partial ordering of the template requirements
  (\mbox{\ref{temp.func.order}}), will be declared in the instantiation. If
  partial ordering results in an ambiguity, a deleted function with
  the given signature (without
    any template requirements) will be declared in the instantiation.
\mbox{\enterexample}}
\begin{codeblock}
auto concept LessThanComparable<typename T> {
  bool operator<(T, T);
}

concept Radix<T> : LessThanComparable<T> { /* ... */ }

template<typename T>
class list {
  requires LessThanComparable<T> void sort(); // \#1
  requires Radix<T> void sort(); // \#2
};

struct X { };
concept_map Radix<int> { /* ... */ }

void f(list<float> lf, list<int> li, list<X> lX) 
{
  lf.sort(); // okay: LessThanComparable<float> implicitly defined, calls \#1
  li.sort(); // okay: calls \#2, which is more specialized than \#1
  lX.sort(); // error: no 'sort' member in list<X>
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}
\color{black}

\rSec2[temp.mem]{Member templates}

\setcounter{Paras}{9}
\pnum
\addedConcepts{A member template of a constrained class template is itself a
  constrained template
  (\mbox{\ref{temp.constrained}}). \mbox{\enternote} The template
  requirements of the member template are the template requirements of
its enclosing constrained template and any requirements specified or
implied by the member template itself. \mbox{\exitnote}}

\rSec2[temp.variadic]{Variadic templates}
\pnum
A \mbox{\techterm{template parameter pack}} is a template parameter
that accepts zero or more template arguments. \mbox{\enterexample}

\begin{codeblock}
template<class ... Types> struct Tuple { };

Tuple<> t0;             // \tcode{Types} contains no arguments
Tuple<int> t1;          // \tcode{Types} contains one argument: \tcode{int}
Tuple<int, float> t2;   // \tcode{Types} contains two arguments: \tcode{int} and \tcode{float}
Tuple<0> eror;          // error: 0 is not a type
\end{codeblock}

\mbox{\exitexample}

\addedConcepts{\mbox{\enternote} a template parameter pack can also occur in a concept's template parameter list
(\mbox{\ref{concept.def}}). \mbox{\enterexample}} \color{addclr}
\begin{codeblock}
@\textcolor{addclr}{auto}@ concept Callable<typename F, typename... Args> {
  typename result_type;
  result_type operator()(F&, Args...);
}
\end{codeblock}
\color{black}\addedConcepts{\mbox{\exitexample\ \exitnote}}

\setcounter{Paras}{3}
\pnum
\textcolor{black}{A} \techterm{pack expansion} is a sequence of tokens that
names one or more parameter packs, followed by an ellipsis. The sequence
of tokens is called the \techterm{pattern of the expansion}; its
syntax depends on the context in which the expansion occurs. Pack
expansions can occur in the following contexts:

\begin{itemize}
\item In an \mbox{\techterm{expression-list}}~(\mbox{\ref{expr.post}});
the pattern is an \mbox{\techterm{assignment-expression}}.
\item In an \mbox{\techterm{initializer-list}}~(\mbox{\ref{dcl.init}});
the pattern is an \mbox{\techterm{initializer-clause}}.
\item In a \mbox{\techterm{base-specifier-list}}~(\mbox{\ref{class.derived}});
the pattern is a \mbox{\techterm{base-specifier}}.
\item In a \mbox{\techterm{mem-initializer-list}}~(\mbox{\ref{class.base.init}});
the pattern is a \mbox{\techterm{mem-initializer}}.
\item In a \mbox{\techterm{template-argument-list}}~(\mbox{\ref{temp.arg}});
the pattern is a \mbox{\techterm{template-argument}}.
\item In an \mbox{\techterm{exception-specification}}~(\mbox{\ref{except.spec}});
the pattern is a \mbox{\techterm{type-id}}.
\additemConcepts{In a
  \mbox{\techterm{requirement-list}}~(\mbox{\ref{temp.req}});
the pattern is a \mbox{\techterm{requirement}}.}
\end{itemize}

\setcounter{Paras}{5}
\pnum
The instantiation of an expansion produces a \removedConcepts{comma-separated}
list $\texttt{E}_1$\changedConcepts{,}{\mbox{$\oplus$}} $\texttt{E}_2$\changedConcepts{,}{\mbox{$\oplus$}} $...$\changedConcepts{,}{\mbox{$\oplus$}} $\texttt{E}_N$, where
$N$ is the number of elements in the pack expansion
parameters\addedConcepts{ and \mbox{$\oplus$} is the
  syntactically-appropriate separator for the list}. Each
\mbox{$\texttt{E}_i$} is generated by instantiating the pattern and
replacing each pack expansion parameter with its \mbox{$i$}th element.
All of the \mbox{$\texttt{E}_i$} become elements in the enclosing list.
\mbox{\enternote} The variety of list varies with the context:
\mbox{\techterm{expression-list}},
\mbox{\techterm{base-specifier-list}},
\mbox{\techterm{template-argument-list}}, 
\addedConcepts{\mbox{\techterm{requirement-list}}, } etc. \mbox{\exitnote}

\setcounter{subsection}{4}
\rSec2[temp.class.spec]{Class template partial specializations}
\setcounter{Paras}{8}

\textcolor{black}{}\pnum
Within the argument list of a class template partial specialization,
the following restrictions apply:

\begin{itemize}
\item
A partially specialized non-type argument expression shall not involve
a template parameter of the partial specialization except when the argument
expression is a simple
\techterm{identifier}.
\enterexample\ 
\begin{codeblock}
template <int I, int J> struct A {};
template <int I> struct A<I+5, I*2> {}; // error

template <int I, int J> struct B {};
template <int I> struct B<I, I> {};     // OK
\end{codeblock}
\exitexample\ 
\item
% L6987 USA Core3 1.9 Editorial box 6 / 14.5.4p6 [temp.class.spec]
% Fix restrictions on non-type template args in specialization arg lists.
The type of a template parameter corresponding to a specialized non-type argument
shall not be dependent on a parameter of the specialization.
\enterexample\ 

\begin{codeblock}
template <class T, T t> struct C {};
template <class T> struct C<T, 1>;              // error

template< int X, int (*array_ptr)[X] > class A {};
@\textcolor{black}{int}@ array[5];
template< int X > class A<X,&array> { };        // error
\end{codeblock}

\exitexample\ 
\item
The argument list of the specialization shall not be identical to the
implicit argument list of the primary template\addedConcepts{, unless
  the specialization contains template requirements
  that are more specific (\mbox{\ref{temp.func.order}}) than the primary
  template's requirements}. \color{addclr} \enterexample\
\begin{codeblock}
concept Hashable<typename T> { int hash(T); }

template<typename T> class X { /* ... */ }; // \#6
template<typename T> requires Hashable<T> class X<T> { /* ... */ }; //\#7, okay
\end{codeblock}
\exitexample\
\color{black}

The template parameter list of a specialization shall not contain default
template argument values.%
\footnote{
There is no way in which they could be used.
}
\item
An argument shall not contain an unexpanded parameter pack. If
an argument is a pack expansion~(\mbox{\ref{temp.variadic}}), it shall be
the last argument in the template argument list.
\end{itemize}

\pnum \addedConcepts{The template requirements 
  of a primary class template are implied
  (\mbox{\ref{temp.req.impl}}) in its class template partial
  specializations that are constrained templates.  \mbox{\enterexample} } \color{addclr}
\begin{codeblock}
concept LessThanComparable<typename T> { /* ... */ }
concept Hashable<typename T> { /* ... */ }

template<typename T> requires LessThanComparable<T> class Y { /* ... */ };
template<typename T> 
  @\textcolor{addclr}{}@requires Hashable<T> // same as requires LessThanComparable<T> \&\& Hashable<T>
  class Y<T> { /* ... */ }; 
\end{codeblock}
\color{black}
\addedConcepts{\mbox{\exitexample}}

\rSec3[temp.class.spec.match]{Matching of class template partial specializations}
\setcounter{Paras}{1}
\pnum
A partial specialization matches a given actual template argument
list if the template arguments of the partial specialization can be
deduced from the actual template argument list (\ref{temp.deduct})
\addedConcepts{and the deduced template arguments satisfy the
  partial specialization's template requirements (if any)}.
\enterexample\ 

\begin{codeblock}
A<int, int, 1>   a1;            // uses \#1
A<int, int*, 1>  a2;            // uses \#2, \tcode{T}\ is \tcode{int}, \tcode{I}\ is \tcode{1}
A<int, char*, 5> a3;            // uses \#4, \tcode{T}\ is \tcode{char}
A<int, char*, 1> a4;            // uses \#5, \tcode{T1}\ is \tcode{int}, \tcode{T2}\ is \tcode{char}, \tcode{I}\ is \tcode{1}
A<int*, int*, 2> a5;            // ambiguous: matches \#3 and \#5
\end{codeblock}
\color{addclr}
\begin{codeblock}
concept_map Hashable<int> { /* ... */ }
struct Y { };

@\textcolor{addclr}{X}@<int> x1;                     // uses \#7
X<Y> x2;                       // uses \#6
\end{codeblock}
\color{black}
\exitexample\ 

\setcounter{Paras}{3}
\pnum
In a type name that refers to a class template specialization, (e.g.,
\tcode{A<int, int, 1>})
the argument list must match the template parameter list of the primary
template. \addedConcepts{If the primary template has template
  requirements, the arguments shall satisfy those requirements.}
The template arguments of a specialization are deduced from the arguments
of the primary template.

\rSec3[temp.class.order]{Partial ordering of class template specializations}
\setcounter{Paras}{1}
\pnum
\enterexample\ 
\begin{codeblock}
@\textcolor{addclr}{concept Con1<typename T> \{ \}}@
@\textcolor{addclr}{concept Con2<typename T> : Con1<T> \{ \}}@
template<int I, int J, class T> class X { };
template<int I, int J>          class X<I, J, int> { }; // \#1
template<int I>                 class X<I, I, int> { }; // \#2
@\textcolor{addclr}{template<int I, int J, class T> requires Con1<T> class X<I, J, T> \{ \}; // \#3}@
@\textcolor{addclr}{template<int I, int J, class T> requires Con2<T> class X<I, J, T> \{ \}; // \#4}@

template<int I, int J> void f(X<I, J, int>);            // \removedConcepts{\#}A
template<int I>        void f(X<I, I, int>);            // \removedConcepts{\#}B
@\textcolor{addclr}{template<int I, int J, class T> requires Con1<T> void f(X<I, J, T>);      // C}@
@\textcolor{addclr}{template<int I, int J, class T> requires Con2<T> void f(X<I, J, T>);      // D}@
\end{codeblock}

The partial specialization
\tcode{\#2}
is more specialized than the partial specialization
\tcode{\#1}
because the function template
\removedConcepts{\#}\tcode{B}
is more specialized than the function template
\removedConcepts{\#}\tcode{A}
according to the ordering rules for function templates.
\addedConcepts{The partial specialization
\mbox{\tcode{\#4}}
is more specialized than the partial specialization
\mbox{\tcode{\#3}}
because the function template
\mbox{\tcode{D}}
is more specialized \mbox{\textcolor{addclr}{than}} the function template
\mbox{\tcode{C}}
according to the partial ordering rules for function templates.}
\exitexample\ 

\rSec2[temp.fct]{Function templates}

\setcounter{Paras}{6}
\pnum
Two function templates are
\techterm{equivalent}\ 
if they are declared in the same scope, have the same name, have
identical template parameter lists, \addedConcepts{have identical
  template requirements}, and have return types
  and parameter 
lists that are equivalent using the rules described above to compare
expressions involving
template parameters.
Two function templates are
\techterm{functionally}\ 
\techterm{equivalent}\ 
if they are equivalent except that one or more
expressions
that involve template parameters in the return types\addedConcepts{,} \removedConcepts{and} parameter
lists\addedConcepts{, and template requirements (if any)} are functionally equivalent using the rules described above to
compare expressions involving
template parameters.
If a program contains declarations of function templates that are
functionally equivalent but not equivalent, the program is ill-formed;
no diagnostic is required.

\setcounter{subsubsection}{1}

\rSec3[temp.func.order]{Partial ordering of function templates}
\setcounter{Paras}{1}
\pnum
Partial ordering selects which of two function templates is more
specialized than the other by transforming each template in turn
(see next paragraph) and performing template argument deduction
using the function parameter types, or in the case of a conversion
function the return type. 
\addedConcepts{\mbox{\enternote}}
\addedConcepts{if template argument deduction succeeds, the deduced
  arguments were used to determine if the requirements of the template
  are satisfied.}
\addedConcepts{\mbox{\exitnote}}
The deduction process determines whether
one of the templates is more specialized than the other. If so, the
more specialized template is the one chosen by the partial ordering
process.

\textcolor{black}{\pnum}
To produce the transformed template, for each type, non-type, or template
template parameter (including template parameter packs thereof)
synthesize a unique type, value, or class template 
respectively and substitute it for each occurrence of that parameter
in the function type of the template.
\addedConcepts{When the template is a constrained template,
  the unique type is an archetype
  and concept map archetypes for each of the
  requirements stated in or implied by its template requirements
  are also synthesized; see \mbox{\ref{temp.constrained}}.
  \mbox{\enternote}
  because the unique types are archetypes, two template type
  parameters may share the same archetype due to same-type constraints.
  \mbox{\exitnote}}

\pnum
\textcolor{black}{Using} the transformed function template's function parameter list, or
in the case of a conversion function its transformed return type,
perform type deduction against the function parameter list (or return
type) of the other function. The mechanism for performing these
deductions is given in~\ref{temp.deduct.partial}. 

\enterexample\ 

\begin{codeblock}
template<class T> struct A { A(); };

template<class T> void f(T);
template<class T> void f(T*);
template<class T> void f(const T*);

template<class T> void g(T);
template<class T> void g(T&);

template<class T> void h(const T&);
template<class T> void h(A<T>&);
void m() {
  int *p;
  f(p);                   // \tcode{f(const T*)}\ is more specialized than \tcode{f(T)}\ or \tcode{f(T*)}
  float x;
  g(x);                   // Ambiguous: \tcode{g(T)}\ or \tcode{g(T\&)}
  @\textcolor{black}{}@A<int> z;
  h(z);                   // overload resolution selects \tcode{h(A<T>\&)}
  const A<int> z2;
  h(z2);                  // \tcode{h(const T\&)}\ is called because \tcode{h(A<T>\&)}\ is not callable
}
\end{codeblock}
\textcolor{black}{}\exitexample\ 

\color{addclr}
\addedConcepts{\mbox{\enternote} when two constrained templates have
  identical signatures (ignoring template requirements), the
  partial ordering is based on those template requirements. Similarly,
  a constrained template is more specialized than an unconstrained
  template because it has more stringent requirements. \mbox{\exitnote}}
\enterexample\
\begin{codeblock}
auto concept CopyConstructible<typename T> { 
  T::T(const T&); 
}

template<CopyConstructible T> struct A { A(); };

concept C<typename T> { }
concept D<typename T> : C<T> { }
concept_map C<int*> { }
concept_map D<float> { }
template<typename T> concept_map D<A<T>> { }

template<class T> requires C<T> void f(T&) { } // \#1
template<class T> requires D<T> void f(T&) { } // \#2
template<class T> requires C<A<T>> void f(A<T>&) { } // \#3
template<class T> void f(T&); // \#4

void m() {
  int *p;
  f(p);          // calls \#1: template argument deductions fails \#2 and \#3, and \#1 is more specialized than \#4
  float x;
  f(x);          // \#2 is called because \#3 is not callable and \#2 is more specialized than \#1 and \#4
  A<int> z;
  f(z);          // ambiguous: no partial ordering between \#2 and \#3
}
\end{codeblock}
\exitexample\
\color{black}

\noindent\editorial{Add the following new subsection to Template
  declarations [temp.decls]}
\color{addclr}
\setcounter{subsection}{7}
\rSec2[temp.concept.map]{Concept map templates}
\pnum
\addedConcepts{A \mbox{\techterm{concept map template}} defines an
  unbounded set of concept 
  maps with a common set of associated function,
  associated type, and associated class template
  definitions. \mbox{\enterexample}}
\begin{codeblock}
concept F<typename T> {
  typename type;
  type f(T);
}

template<typename T>
concept_map F<T*> {
  typedef T& type;
  T& f(T*);
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{A concept map template is a constrained template (\mbox{\ref{temp.constrained}})
\mbox{\enternote} a concept map template is a constrained template even
if it does not have template requirements.  \mbox{\exitnote}}

\pnum
\addedConcepts{Within the \mbox{\techterm{template-argument-list}} of the
\mbox{\techterm{concept-id}} in a concept map template (including nested
template argument lists),
the following restrictions apply:}

\begin{itemize}
\item
\addedConcepts{A non-type argument expression shall not involve
a template parameter of the concept map except when the argument
expression is a simple
\mbox{\techterm{identifier}}.}

\item
\addedConcepts{The type of a template parameter corresponding to a non-type argument
shall not be dependent on a parameter of the concept map.}

\item
\addedConcepts{The template parameter list of a concept map template shall not contain default
template argument values.%
\footnote{
There is no way in which they could be used.
}}
\end{itemize}

\pnum 
\addedConcepts{During concept map lookup (\mbox{\ref{temp.req.sat}}),
  concept map matching determines whether a 
particular concept map template can be used. Concept map matching
matches the template arguments in the
\mbox{\techterm{concept instance}} to the 
template arguments in the concept map template, using matching of class
template partial specializations (\mbox{\ref{temp.class.spec.match}}).}

\pnum
\addedConcepts{For two concept map templates, the first is at least as
  specialized as the second if, given the following rewrite to two
  class template partial specializations of an invented class template
  \mbox{\tcode{X}}, the first class template partial specialization is
  at least as specialized as the second according to the rules for
  partial ordering of class template partial specializations
  (\mbox{\ref{temp.class.order}}). The primary class template \mbox{\tcode{X}}
  has the same template parameters as the concept of the
  concept map templates. The class template partial
  specializations are constrained templates, even if the corresponding
concept map templates have no requirements specified.}
\begin{itemize}
\additemConcepts{the first class template partial specialization has the
  same template parameters and template arguments as the first concept
  map template, and}
\additemConcepts{the second class template has the same template
  parameters and template arguments as the second concept map template.}
\end{itemize}
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> { }
concept Ptr<typename T> { }
template<typename T> concept_map Ptr<T*> { /* ... */ }

template<typename T> requires Ptr<T*> concept_map C<T*> { /* ... */ } // \#1
template<typename T> requires Ptr<T> concept_map C<T> { /* ... */ } // \#2

template<typename T> class X;
template<typename T> requires Ptr<T*> class X<T*>; // A
template<typename T> requires Ptr<T> class X<T>; // B
\end{codeblock}
\addedConcepts{The concept map template \#1 is more specialized than the concept map
template \#2 because the class template partial specialization A is
more specialized than the class template partial specialization B
according to the ordering rules for class template partial specializations.}
\addedConcepts{\mbox{\exitexample}}

% \addedConcepts{When writing a template
%   constrained; please keep your arguments plain; since with a type
%   pattern, adaptation will shatter; tho' the compiler will never
%   complain.}

\pnum
\addedConcepts{A concept map template shall satisfy the requirements
  of its corresponding concept (\mbox{\ref{concept.map}}) at the time of definition of the concept
map template. \mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> { }

concept F<typename T> {
  void f(T);
}

template<C T> struct X;

template<F T> void f(X<T>); // \#1

template<typename T>
concept_map F<X<T>> { } // error: requirement for f(X<T>) not satisfied

@\textcolor{addclr}{}@template<F T>
concept_map F<X<T>> { } // okay: uses \#1 to satisfy requirement for f(X<T>)
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{If the definition of a concept map template uses an instantiated archetype
(\mbox{\ref{temp.archetype}}), and instantiation of the 
concept map template 
results in a different specialization of that class
template with an incompatible definition, the program is
ill-formed. The specialization is considered to have an incompatible
definition if the specialization's definition causes a different
definition of any associated type or associated class template in the
concept map, if its definition causes any of the associated
function definitions to be ill-formed, or if the resulting concept map
fails to satisfy the axioms of the corresponding concept. 
\mbox{\enterexample}}
\begin{codeblock}
concept Stack<typename X> {
  typename value_type;
  value_type& top(X&);
  // ...
}

template<typename T> struct dynarray {
  @\textcolor{addclr}{T}@& top();
};

template<> struct dynarray<bool> {
  bool top();
};

template<typename T>
concept_map Stack<dynarray<T>> {
  typedef T value_type;
  @\textcolor{addclr}{T}@& top(dynarray<T>& x) { return x.top(); }
}

template<Stack X>
void f(X& x) {
  @\textcolor{addclr}{}@X::value_type& t = top(x);
}

void g(dynarray<int>& x1, dynarray<bool>& x2) {
  f(x1); // okay
  f(x2); // error: Stack<dynarray<bool> > uses the dynarray<bool> class specialization
         // rather than the dynarray primary class template, and the two
         // have incompatible signatures for top()
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{A concept map template shall be declared before the first use of a
concept map that would make use of the concept map template
as the result of an instantiation
in every translation unit in which such a use occurs; no diagnostic is
required.}

\color{black}

\rSec1[temp.res]{Name resolution}

\setcounter{Paras}{2}
\pnum
When a \techterm{qualified-id} is intended to refer to a type that is not a member of the current instantiation (14.6.2.1) and its 
\techterm{nested-name-specifier} 
\addedConcepts{is not a concept instance (\mbox{\ref{concept}}) and}
depends on a \techterm{template-parameter} (14.6.2), it shall be prefixed by the keyword \tcode{typename}, forming a 
\techterm{typename-specifier}. If the \techterm{qualified-id} in a
\techterm{typename-specifier} does not denote a type, the program is
ill-formed. 
\addedConcepts{When the \mbox{\techterm{nested-name-specifier}} refers to a
  concept instance, name lookup into the corresponding concept
  determines whether the \mbox{\techterm{qualified-id}} refers to a
  type or a value.}


\setcounter{subsection}{2}
\rSec2[temp.nondep]{Non-dependent names}
\noindent\editorial{Add the following new paragraph to Non-dependent
  names [temp.nondep]}
\setcounter{Paras}{1}
\pnum
\addedConcepts{
\mbox{\enternote}\ if a template contains template requirements, name
lookup of non-dependent names in its constrained contexts
  (\mbox{\ref{temp.constrained}})
can find the
names of associated functions in the
requirements scope (\mbox{\ref{basic.scope.req}}). \mbox{\exitnote}}

\rSec1[temp.spec]{Template instantiation and specialization}
\pnum
\index{specialization!template}%
The act of instantiating a function, a class, \addedConcepts{a concept
  map}, a member of a class template or
a member template is referred to as
\techterm{template instantiation}.

\pnum
A function instantiated from a function template is called an instantiated
function.
A class instantiated from a class template is called an instantiated
class.
\addedConcepts{A concept map instantiated from a concept map template
  is called an instantiated concept map.}
A member function, a member class, or a static data member of a class template
instantiated from the member definition of the class template is called,
respectively, an instantiated member function, member class or static data
member.
A member function instantiated from a member function template is called an
instantiated member function.
A member class instantiated from a member class template is called an
instantiated member class.

\rSec2[temp.inst]{Implicit instantiation}

\setcounter{Paras}{4}
\pnum
If the overload resolution process can determine the correct function to
call without instantiating a class template definition\addedConcepts{ or concept map template definition}, it is unspecified
whether that instantiation actually takes place.
\enterexample\ 

\begin{codeblock}
template <class T> struct S {
  operator int();
};

void f(int);
void f(S<int>&);
void f(S<float>);

void g(S<int>& sr) {
  f(sr);                  // instantiation of \tcode{S<int>}\ allowed but not required
        // instantiation of \tcode{S<float>}\ allowed but not required
};
\end{codeblock}
\exitexample\ 

\setcounter{Paras}{8}
\textcolor{black}{\pnum}
An implementation shall not implicitly instantiate a function template,
a member template, a non-virtual member function,
\addedConcepts{concept map template,} a member class or a
static data member of a class template that does not require instantiation.
It is unspecified whether or not an implementation implicitly instantiates a
virtual member function of a class template if the virtual member function would
not otherwise be instantiated.
% USA editorial comment, from core3 issue 3.32
% A name referenced in a default argument is not "used" unless the default
% argument is used.
The use of a template specialization in a default argument
shall not cause the template to be implicitly instantiated except that a
class template may be instantiated where its complete type is needed to determine
the correctness of the default argument.
The use of a default argument in a
function call causes specializations in the default argument to be implicitly
instantiated.

\pnum
Implicitly instantiated class\addedConcepts{, concept map,} and function template specializations are placed
in the namespace where the template is defined.
Implicitly instantiated specializations for members of a class template are
placed in the namespace \textcolor{black}{}where the enclosing class template is defined.
Implicitly instantiated member templates are placed in the namespace where the
enclosing class or class template is defined.
\enterexample\ 

\begin{codeblock}
namespace N {
  template<class T> class List {
  public:
    T* get();
  // ...
  };
}

template<class K, class V> class Map {
  N::List<V> lt;
  V get(K);
  // ...
};

void g(Map<char*,int>& m)
{
  int i = m.get("Nicholas");
  // ...
}
\end{codeblock}

a call of
\tcode{lt.get()}
from
\tcode{Map<char*,int>::get()}
would place
\tcode{List<int>::get()}
in the namespace
\tcode{N}
rather than in the global namespace.
\exitexample\ 

\noindent\editorial{Add the following new paragraph to [temp.inst]}
\setcounter{Paras}{14}
\pnum
\addedConcepts{If no concept map exists for a given
concept instance, and there 
exists a concept map template that matches the
concept instance, the concept map is implicitly instantiated when the concept 
map is referenced in a context that requires the concept map
definition, either to satisfy a concept requirement
(\mbox{\ref{temp.req}}) 
or when the
\mbox{\techterm{nested-name-specifier}} of a
\mbox{\techterm{qualified-id}} references a concept instance
(\mbox{\ref{concept.qual}}).}

\rSec2[temp.expl.spec]{Explicit specialization}

\noindent\editorial{Add the following new paragraph to [temp.expl.spec]:}

\setcounter{Paras}{22}
\color{addclr}
\pnum
\addedConcepts{\mbox{\enternote}\ The template arguments provided for an explicit specialization shall
satisfy the template requirements of the primary
template (\mbox{\ref{temp.class.spec.match}}). \mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> { }
concept_map C<float> { }

template<typename T> requires C<T> void f(T);

template<> void f<float>(float); // okay: concept_map C<float> satisfies requirement
template<> void f<int>(int); // ill-formed: no concept map satisfies the requirement for C<int>
\end{codeblock}
\addedConcepts{\mbox{\exitexample} \mbox{\exitnote}}
\color{black}

\rSec1[temp.fct.spec]{Function template specializations}

\setcounter{subsection}{1}
\rSec2[temp.deduct]{Template argument deduction}
\setcounter{Paras}{1}
\pnum
\addedConcepts{
If the reference to the template occurs within a constrained context
(\mbox{\ref{temp.constrained}}) and the template is an unconstrained
template, type deduction fails.
}

\pnum
When an explicit template argument list is specified, the template
arguments must be compatible with the template parameter list and must
result in a valid function type as described below; otherwise type
deduction fails.  Specifically, the following steps are performed when
evaluating an explicitly specified template argument list with respect
to a given function template:

\begin{itemize}
\item
The specified template arguments must match the template parameters in
kind (i.e., type, non-type, template). There must not be more
arguments than there are parameters, unless at least one parameter is
a template parameter pack, and there shall be an argument for each
non-pack parameter. Otherwise type deduction fails.
\item
Non-type arguments must match the types of the corresponding non-type
template parameters, or must be convertible to the types of the
corresponding non-type parameters as specified in
\ref{temp.arg.nontype}, otherwise type deduction fails.
\item
All references in the function type \addedConcepts{and template requirements} of the function template to the
corresponding template parameters are replaced by the specified
template argument values.  If a substitution in a template
parameter\addedConcepts{, the template requirements (if any),}
or in the function type of the function template results in an invalid
type, type deduction fails.  [Note: The equivalent substitution in
exception specifications is done only when the function is
instantiated, at which point a program is ill-formed if the
substitution results in an invalid type.] Type deduction may fail for
the following reasons:

\begin{itemize}
\item
Attempting to instantiate a pack expansion containing
multiple parameter packs of differing lengths.

\item
Attempting to create an array with an element type that is \tcode{void}, a
function type, a reference type, or an abstract class type, or attempting
to create an array with a size that is zero or negative.
\enterexample\ 

\begin{codeblock}
template <class T> int f(T[5]);
int I = f<int>(0);
int j = f<void>(0);             // invalid array
\end{codeblock}
\exitexample\ 
\item
Attempting to use a type that is not a class type in a qualified name.
\enterexample\ 

\begin{codeblock}
template <class T> int f(typename T::B*);
int i = f<int>(0);
\end{codeblock}
\exitexample\ 
\item
Attempting to use a type in a nested-name-specifier of a qualified-id when
that type does not contain the specified member, or
\begin{itemize}
\item
the specified member is not a type where a type is required, or
\item
the specified member is not a template where a template is required, or
\item
the specified member is not a non-type where a non-type is
required.
\end{itemize}
\enterexample\ 

\begin{codeblock}
template <int I> struct X { };
template <template <class T> class> struct Z { };
template <class T> void f(typename T::Y*){}
template <class T> void g(X<T::N>*){}
template <class T> void h(Z<T::template TT>*){}
struct A {};
struct B { int Y; };
struct C {
    typedef int N;
};
struct D {
    typedef int TT;
};

@\textcolor{black}{int}@ main()
{
    // Deduction fails in each of these cases:
    f<A>(0);  // \tcode{A}\ does not contain a member \tcode{Y}
    f<B>(0);  // The \tcode{Y}\ member of \tcode{B}\ is not a type
    g<C>(0);  // The \tcode{N}\ member of \tcode{C}\ is not a non-type
    h<D>(0);  // The \tcode{TT}\ member of \tcode{D}\ is not a template
}
\end{codeblock}
\exitexample\ 
\item
Attempting to create a pointer to reference type.
\item
Attempting to create a reference to \tcode{void}.
\item
Attempting to create ``pointer to member of \tcode{T}'' when \tcode{T}\ is not a
class type.
\enterexample\ 

\begin{codeblock}
template <class T> int f(int T::*);
int i = f<int>(0);
\end{codeblock}
\exitexample\ 
\item
Attempting to give an invalid type to a non-type template parameter.
\enterexample\
\begin{codeblock}
template <class T, T> struct S {};
template <class T> int f(S<T, T()>*);
struct X {};
int i0 = f<X>(0);
\end{codeblock}
\exitexample\
\item
Attempting to perform an invalid conversion in either a template
argument expression, or an expression used in the function
declaration.
\enterexample\ 

\begin{codeblock}
@\textcolor{black}{template@} <class T, T*> int f(int);
int i2 = f<int,1>(0);           // can't conv \tcode{1}\ to \tcode{int*}
\end{codeblock}
\textcolor{black}{\exitexample}
\item
Attempting to create a function type in which a parameter has a type
of \tcode{void}.

\item
\addedConcepts{Attempting to use a type in a
  \mbox{\techterm{nested-name-specifier}} of a
  \mbox{\techterm{qualified-id}} that refers to a member in a concept
  instance, for which concept map lookup
  (\mbox{\ref{temp.req.sat}}) does not find a
  concept map corresponding to that
  concept instance.}

\additemConcepts{Attempting to use a class or function template with
  template arguments that do not satisfy that template's
  requirements. \mbox{\enterexample}}
\color{addclr}
\begin{codeblock}
concept C<typename T> { /* ... */ }

template<typename T> requires C<T> class X { /* ... */ };

template<typename T> int f(X<T>*); // \#1
template<typename> int f(...); // \#2
int i0 = f<int>(0); // okay: calls \#2
\end{codeblock}
\color{black}
\addedConcepts{\mbox{\exitexample}}

\end{itemize}

\end{itemize}

\setcounter{Paras}{5}
\pnum
When
\changedConcepts{
    all template arguments have}{
        each template argument has}
 been \addedConcepts{explicitly specified,} deduced or obtained from default
template arguments,
\changedConcepts{all uses of template parameters in non-deduced
contexts are}{
    each use of a template parameter in the
    function type and in each template requirement is} replaced with
  the corresponding \removedConcepts{deduced or default} 
argument value\removedConcepts{s}. If the substitution results in an invalid
type, as described above, type deduction fails.
\addedConcepts{If a substituted requirement cannot be satisfied
(\mbox{\ref{temp.req.sat}}), type deduction fails.}

\noindent\editorial{Add the following new sections to 14 [temp]:}

\setcounter{section}{8}
\color{addclr}

\rSec1[concept]{Concepts}

\pnum
\addedConcepts{Concepts describe an abstract interface that can be used to
constrain templates (\mbox{\ref{temp.constrained}}). Concepts state certain
syntactic and semantic requirements (\mbox{\ref{concept.def}}) on a set of
template type, non-type, and template template
parameters.}

\begin{bnf}
\index{concept-id@\techterm{concept-id}}%
\addedConcepts{concept-id:}\br
         \addedConcepts{concept-name \mbox{\terminal{<}} template-argument-list\mbox{\opt}\ \mbox{\terminal{>}}}\br

\addedConcepts{concept-name:}\br
         \addedConcepts{identifier}
\end{bnf}

\pnum
\addedConcepts{A \mbox{\techterm{concept-id}} names a specific use of
  a concept by its 
\mbox{\techterm{concept-name}} and a set of 
template arguments. The concept and its template arguments,
  together, are referred to as a \mbox{\techterm{concept instance}}.
\mbox{\enterexample}\ \mbox{\tcode{CopyConstructible<int>}} is a
\mbox{\techterm{concept-id}} if name lookup (\mbox{\ref{basic.lookup}}) determines
that the identifier \mbox{\tcode{CopyConstructible}} refers to a
\mbox{\techterm{concept-name}}; then,
  \mbox{\tcode{CopyConstructible<int>}} is a concept instance that
  refers to the \mbox{\tcode{CopyConstructible}} concept used with the
  type \mbox{\tcode{int}}. \mbox{\exitexample}}

\pnum
\addedConcepts{A concept is a \mbox{\techterm{constrained template}}
  (\mbox{\ref{temp.constrained}}). The template requirements for the
  concept consist of a concept requirement for the concept's concept
  instance (\mbox{\ref{temp.req}}) and the template requirements
  implied by that concept requirement (\mbox{\ref{temp.req.impl}}).}

\rSec2[concept.def]{Concept definitions}

\pnum
\addedConcepts{The grammar for a \mbox{\techterm{concept-definition}} is:}

\begin{bnf}
\index{concept-definition@\techterm{concept-definition}}%
\addedConcepts{concept-definition}:\br
         \addedConcepts{\mbox{\terminal{auto}\opt}\ \mbox{\terminal{concept}} identifier \mbox{\terminal{<}} template-parameter-list \mbox{\terminal{>}} refinement-clause\mbox{\opt}\ concept-body \mbox{\terminal{;}\opt}} \br
\end{bnf}

\pnum 
\addedConcepts{\mbox{\techterm{Concept-definition}}s are used to declare
\mbox{\techterm{concept-name}}s. A \mbox{\techterm{concept-name}} is inserted into
the scope in which it is declared immediately after the
\mbox{\techterm{concept-name}} is seen. A concept is considered defined after
the closing brace of its \mbox{\techterm{concept-body}}. A \mbox{\techterm{full
  concept name}} is an identifier that is treated as if it were
composed of the concept name and the sequence of its enclosing namespaces.}

\pnum 
\addedConcepts{Concepts shall only be defined at namespace scope.}

\pnum
\addedConcepts{A \mbox{\techterm{concept-definition}} that starts with \mbox{\tcode{auto}} defines an \mbox{\techterm{implicit concept}}, otherwise it defines an
\mbox{\techterm{explicit concept}}.}

\pnum 
\addedConcepts{The \mbox{\techterm{template-parameter-list}} of a
\mbox{\techterm{concept-definition}} shall not contain any requirements
specified in the simple form (\mbox{\ref{temp.req}}).}

\pnum

\begin{bnf}
\addedConcepts{concept-body:}\br
         \addedConcepts{\mbox{\terminal{\{}} concept-member-specification\mbox{\opt}\ \mbox{\terminal{\}}}}\br

\addedConcepts{concept-member-specification:}\br
         \addedConcepts{concept-member-specifier concept-member-specification\mbox{\opt}} \br

\addedConcepts{concept-member-specifier:}\br
         \addedConcepts{associated-function}\br
         \addedConcepts{type-parameter \mbox{\terminal{;}}}\br
         \addedConcepts{associated-requirements}\br
         \addedConcepts{axiom-definition}
\end{bnf}

\addedConcepts{The body of a concept contains associated functions
(\mbox{\ref{concept.fct}}), associated types (\mbox{\ref{concept.assoc}}),
associated class templates, 
associated requirements (\mbox{\ref{concept.req}}), and axioms
(\mbox{\ref{concept.req}}). A name \mbox{\tcode{x}} declared in the body of a
concept shall refer to only one of: an associated type, an associated
class template, an axiom, or one or more associated
functions that have been overloaded (clause~\mbox{\ref{over}}).}

\rSec3[concept.fct]{Associated functions}

\pnum
\addedConcepts{Associated functions describe functions, member functions, or
operators (including templates thereof)
that specify the functional behavior of the concept's template
arguments and associated types and class
templates (\mbox{\ref{concept.assoc}}). A
concept map
(\mbox{\ref{concept.map}}) for a given concept must satisfy
each associated function in the concept (\mbox{\ref{concept.map.fct}}).}

\begin{bnf}
\addedConcepts{associated-function:}\br
         \addedConcepts{simple-declaration}\br
         \addedConcepts{function-definition}\br
         \addedConcepts{template-declaration}
\end{bnf}

\pnum 
\addedConcepts{An \mbox{\techterm{associated-function}} shall declare a
function or function template. If the \mbox{\techterm{declarator-id}} of
the declaration is a \mbox{\techterm{qualified-id}}, its
\mbox{\techterm{nested-name-specifier}} shall name a template parameter of
the enclosing concept; the declaration declares a member function or
member function template.}
%
\addedConcepts{An associated function shall not be
  \mbox{\tcode{extern}}, inline}
\addedZ{or \mbox{\tcode{virtual}}}
\addedConcepts{(\mbox{\ref{dcl.fct.spec}}), explicitly-defaulted or deleted
(\mbox{\ref{dcl.fct.def}}), or a friend function (\mbox{\ref{class.friend}}). An 
associated function shall not contain an
\mbox{\techterm{exception-specification}} (\mbox{\ref{except.spec}}).}

\pnum
\addedConcepts{Associated functions may specify requirements for non-member functions and
operators. \mbox{\enterexample}}
\begin{codeblock}
concept Monoid<typename T> {
  T operator+(T, T);
  T identity();
}
\end{codeblock} \addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{With the exception of the assignment operator (\mbox{\ref{over.ass}}) 
and operators \mbox{\tcode{new}}, \mbox{\tcode{new[]}},
  \mbox{\tcode{delete}}, and \mbox{\tcode{delete[]}},
associated functions shall specify requirements for operators as non-member 
functions. \mbox{\enternote} This restriction applies even to the operators
\mbox{\tcode{()}}, \mbox{\tcode{[]}}, and \mbox{\tcode{->}}, which
can otherwise only be declared as non-static member functions
(\mbox{\ref{over.oper}}): \mbox{\enterexample}}
\begin{codeblock}
concept Convertible<typename T, typename U> {
  operator U(T); // okay: conversion from T to U
  T::operator U*() const; // error: cannot specify requirement for member operator
}
\end{codeblock} 
\addedConcepts{\mbox{\exitexample} \mbox{\exitnote}}

\pnum
\addedConcepts{Associated functions may specify requirements for static or non-static
member functions, constructors, and destructors. \mbox{\enterexample}}
\begin{codeblock}
concept Container<typename X> {
  X::X(int n);
  X::~X();
  bool X::empty() const;
  static size_t X::max_size();
}
\end{codeblock} 
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{Associated functions may specify requirements for
  \mbox{\tcode{new}} and \mbox{\tcode{delete}}. \mbox{\enterexample}}
\begin{codeblock}
concept HeapAllocatable<typename T> {
  void* T::operator new(std::size_t);
  void* T::operator new[](std::size_t);
  void T::operator delete(void*);
  void T::operator delete[](void*);
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{Associated functions may specify requirements for function templates
and member function templates. \mbox{\enterexample}}
\begin{codeblock}
concept Sequence<typename X> {
  typename value_type;

  template<InputIterator Iter> 
    requires Convertible<InputIterator<Iter>::value_type, Sequence<X>::value_type>
    X::X(Iter first, Iter last);
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{Concepts may contain overloaded associated functions (clause~\mbox{\ref{over}}). \mbox{\enterexample}}
\begin{codeblock}
concept C<typename X> {
  void f(X);
  void f(X, X); // okay
  int f(X, X); // error: differs only by return type
}
\end{codeblock} 
\addedConcepts{\mbox{\exitexample}}

\pnum 
\addedConcepts{Associated member functions with the same name and the
  same \mbox{\techterm{parameter-type-list}}, as well as associated
  member function templates with the same name, the same
  \mbox{\techterm{parameter-type-list}}, the same template
  parameter lists, and the same template requirements (if any), cannot
  be overloaded if any of them, but not all,
  have a \mbox{\techterm{ref-qualifier}} (\mbox{\ref{dcl.fct}}).}

\pnum
\addedConcepts{Associated functions may have a default implementation. This
implementation will be instantiated when used. A default implementation of an
associated function is a constrained template
(\mbox{\ref{temp.constrained}}). \mbox{\enterexample}}
\begin{codeblock}
concept EqualityComparable<typename T> {
  bool operator==(T, T);
  bool operator!=(T x, T y) { return !(x == y); }
}

class X {};
bool operator==(const X&, const X&);

concept_map EqualityComparable<X> { } // okay, operator!= uses default
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\rSec3[concept.assoc]{Associated types and class templates}

\pnum
\addedConcepts{Associated types and associated class
templates are types and class templates,
respectively, defined in the concept body and used in the
description of the concept.}

\pnum
\addedConcepts{An associated type specifies a type in a concept
body. Associated types are typically used to express the parameter and
return types of associated functions. \mbox{\enterexample}}
\begin{codeblock}
concept Callable1<typename F, typename T1> {
  typename result_type;
  result_type operator()(F&&, T1);
}
\end{codeblock}\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{An associated class template specifies a
class template in a concept. \mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> {
  template<ObjectType U> class X;
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}
\color{addclr}

\pnum
\addedConcepts{Associated types and class
templates may be provided with a default value. The
default value will be used to satisfy
the associated type or class
template requirement when no
corresponding definition is provided in a concept map
(\mbox{\ref{concept.map.assoc}}). \mbox{\enterexample}}
\begin{codeblock}
concept Iterator<typename Iter> {
  typename difference_type = int;
}

concept_map Iterator<int*> { } // okay, difference_type is int
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{Associated types and class templates
may use the simple form to specify requirements 
(\mbox{\ref{temp.req}}) on the associated type
or class template. The simple
form is equivalent to a declaration of the associated type
or class template followed by an associated requirement
  (\mbox{\ref{concept.req}}) stated using
the general form (\mbox{\ref{temp.req}}). \mbox{\enterexample}}
\begin{codeblock}
concept InputIterator<typename Iter> { /* ... */ }

concept Container<typename X> {
  InputIterator iterator; // same as \tcode{typename iterator; requires InputIterator<iterator>;}
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\rSec3[concept.req]{Associated requirements}

\pnum
\addedConcepts{Associated requirements place additional requirements on the concept's template
parameters, associated types, and associated class templates. Associated
requirements have the
same form and behavior as template requirements in a constrained
template (\mbox{\ref{temp.constrained}}).}

\begin{bnf}
\addedConcepts{associated-requirements:}\br
         \addedConcepts{requires-clause \mbox{\terminal{;}}}
\end{bnf}

\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept Iterator<typename Iter> {
  typename difference_type;
  requires SignedIntegral<difference_type>;
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\rSec3[concept.axiom]{Axioms}

\pnum
\addedConcepts{Axioms allow the expression of the semantic properties of concepts.}

\begin{bnf}
\addedConcepts{axiom-definition:}\br
         \addedConcepts{requires-clause\mbox{\opt}\ \mbox{\terminal{axiom}} identifier \mbox{\terminal{(}} parameter-declaration-clause \mbox{\terminal{)}} axiom-body}\br

\addedConcepts{axiom-body:}\br
         \addedConcepts{\mbox{\terminal{\{}} axiom-seq\mbox{\opt}\ \mbox{\terminal{\}}}}\br

\addedConcepts{axiom-seq:}\br
         \addedConcepts{axiom axiom-seq\mbox{\opt}}\br

\addedConcepts{axiom:}\br
         \addedConcepts{expression-statement}\br
         \addedConcepts{\mbox{\terminal{if}} \mbox{\terminal{(}} expression \mbox{\terminal{)}} expression-statement}
\end{bnf}

\addedConcepts{An \mbox{\techterm{axiom-definition}} defines a new semantic axiom whose name
is specified by its \mbox{\techterm{identifier}}. \mbox{\enterexample}}
\begin{codeblock}
concept Semigroup<typename Op, typename T> : CopyConstructible<T> {
  T operator()(Op, T, T);

  axiom Associativity(Op op, T x, T y, T z) {
    op(x, op(y, z)) == op(op(x, y), z);  
  }
}

concept Monoid<typename Op, typename T> : Semigroup<Op, T> {
  T identity_element(Op);
 
  axiom Identity(Op op, T x) {
    op(x, identity_element(op)) == x;
    op(identity_element(op), x) == x;
  }
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum 
\addedConcepts{Within the body of an \mbox{\techterm{axiom-definition}}, equality
(\mbox{\tcode{==}}) and inequality (\mbox{\tcode{!=}}) operators are available for
each concept type parameter and associated type \mbox{\tcode{T}}. These
implicitly-defined operators have the form:}
\begin{codeblock}
bool operator==(const T&, const T&);
bool operator!=(const T&, const T&);
\end{codeblock}
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept CopyConstructible<typename T> {
  T::T(const T&);

  axiom CopyEquivalence(T x) {
    T(x) == x; // okay, uses implicit ==
  }
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{Name lookup within an axiom will only find the implicitly-declared
\mbox{\tcode{==}} and \mbox{\tcode{!=}} operators if the corresponding operation is
not declared as an associated function (\mbox{\ref{concept.fct}}) in
the concept, one of the concepts it refines
(\mbox{\ref{concept.refine}}), or in an associated requirement
(\mbox{\ref{concept.req}}). \mbox{\enterexample}}
\begin{codeblock}
concept EqualityComparable<typename T> {
  bool operator==(T, T);
  bool operator!=(T, T);

  axiom Reflexivity(T x) {
    x == x; // okay: refers to EqualityComparable<T>::operator==
  }
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{Where axioms state the equality of two expressions, implementations
are permitted to replace one expression with the other. \mbox{\enterexample}}
\begin{codeblock}
template<typename Op, typename T> requires Monoid<Op, T>
  T identity(const Op& op, const T& t) {
    return op(t, identity_element(op)); // equivalent to ``return t;''
  }
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum 
\addedConcepts{Axioms can state conditional semantics using \mbox{\tcode{if}}
statements. The \mbox{\techterm{expression}} is contextually
  converted to \mbox{\tcode{bool}} (clause~\mbox{\ref{conv}}). When the condition
can be proven true, and the 
\mbox{\textit{expression-statement}} states the equality of two expressions,
implementations are permitted to replace one expression with the
other. \mbox{\enterexample}}
\begin{codeblock}
concept TotalOrder<typename Op, typename T> {
  bool operator()(Op, T, T);

  axiom Antisymmetry(Op op, T x, T y) { if (op(x, y) && op(y, x)) x == y; }
  axiom Transitivity(Op op, T x, T y, T z) { if (op(x, y) && op(y, z)) op(x, z) == true; }
  axiom Totality(Op op, T x, T y) { (op(x, y) || op(y, x)) == true; }
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{An axiom containing a \mbox{\techterm{requires-clause}} only applies when the
specified template requirements are satisfied. \mbox{\enterexample}}
\begin{codeblock}
concept EqualityComparable2<typename T, typename U = T> {
  bool operator==(T, U);
  bool operator!=(T, U);

  requires SameType<T, U> axiom Reflexivity(T x) {
      x == x; // okay: T and U have the same type
    }
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{Whether an implementation replaces any expression according to an
axiom is implementation-defined.  With the exception of such
substitutions, the presence of an axiom shall have no effect on the
observable behavior of the program.
\mbox{\enternote}\
the intent of axioms is to provide a mechanism to express
the semantics of concepts. Such semantic information can be used for
optimization, software verification, software testing, and other
program analyses and transformations, all of which are outside the
scope of this International Standard.
\mbox{\exitnote}}


\rSec2[concept.map]{Concept maps}

\pnum
\addedConcepts{The grammar for a \mbox{\techterm{concept-map-definition}} is:}

\begin{bnf}
\index{concept-map-definition@\techterm{concept-map-definition}}%
\addedConcepts{concept-map-definition:}\br
         \addedConcepts{\mbox{\terminal{concept_map}} \mbox{\terminal{::}\opt}\ nested-name-specifier\mbox{\opt}\ concept-id \mbox{\terminal{\{}} concept-map-member-specification\mbox{\opt}\ \mbox{\terminal{\}}} \mbox{\terminal{;}\opt}} \br

\addedConcepts{concept-map-member-specification:}\br
         \addedConcepts{concept-map-member concept-map-member-specification\mbox{\opt}} \br

\addedConcepts{concept-map-member:}\br
         \addedConcepts{simple-declaration} \br
         \addedConcepts{function-definition} \br
         \addedConcepts{template-declaration}
\end{bnf}

\pnum
\addedConcepts{Concept maps describe how a set of template arguments satisfy the
requirements stated in the body of a concept definition
(\mbox{\ref{concept.def}}). For template argument
deduction (\mbox{\ref{temp.deduct.type}}) against a constrained template to succeed,
each of the template's requirements shall be satisfied (\mbox{\ref{temp.req.set}}).}
%
\addedConcepts{The concept map is inserted into the scope in
which the concept map or concept map template (\mbox{\ref{temp.concept.map}})
is defined immediately after the \mbox{\techterm{concept-id}} is seen. The
name of the concept map is the full concept name of the concept in the
corresponding concept instance.}
%
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
class student_record { 
public: 
  std::string id; 
  std::string name; 
  std::string address; 
}; 

concept EqualityComparable<typename T> {
  bool operator==(T, T);
}

concept_map EqualityComparable<student_record> {
  bool operator==(const student_record& a, const student_record& b) { 
    return a.id == b.id; 
  }
} 

template<typename T> requires EqualityComparable<T> void f(T);

f(student_record()); // okay, have concept_map EqualityComparable<student_record>
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum 
\addedConcepts{
    A concept map may contain two kinds of members:
    \mbox{\techterm{requirement members}} and members that satisfy
requirement members.  The latter may be explicitly declared within the
concept, explicitly declared within a refinement, or generated implicitly
from a default implementation from the concept or refinement of the
concept.}
    
\pnum 
\addedConcepts{
     A requirement member represents a requirement to satisfy (as
     described below) a single associated function
     (\mbox{\ref{concept.fct}}), associated type or associated class
   template
    (\mbox{\ref{concept.assoc}}) from the corresponding concept.  The set
    of requirement members is the set of associated functions, associated
    types and associated class templates from the concept after
    substitution of 
    the concept's template parameters with the corresponding template arguments.
    \mbox{\enternote}
        There is no way to explicitly declare a requirement member.
    \mbox{\exitnote} 
    }

\pnum 
\addedConcepts{
    After a requirement is satisfied, the requirement member serves as a
    synonym for the set of entities that satisfies the requirement
    (\mbox{\ref{concept.map.fct}}, \mbox{\ref{concept.map.assoc}}).
    That entity is said to be the \mbox{\techterm{satisfier}} of
    the requirement member. Each requirement member is visible during
    qualified name lookup (\mbox{\ref{concept.qual}}).
    \mbox{\enternote} A satisfier need not be a member of a
    concept map. \mbox{\exitnote}}

\pnum
    \addedConcepts{
    A concept map member that satisfies a requirement member
     cannot be found by any form of name lookup
    (\mbox{\ref{basic.lookup}}).}

\pnum 
\addedConcepts{
    A concept map archetype (\mbox{\ref{temp.archetype}}) is
    considered to have satisfiers (generated from the 
    concept) for each of its requirement members.}

\pnum
\addedConcepts{Concept maps shall satisfy every associated function (\mbox{\ref{concept.fct}}),
associated type and associated class template requirement
(\mbox{\ref{concept.assoc}}) of its concept instance and
all of the requirements inherited from its refined
concept instances (\mbox{\ref{concept.refine}}). \mbox{\enterexample}}
\begin{codeblock}
concept C<typename T, typename U> { T f(T); U f(U); }

concept_map C<int, int> {
  int f(int); // okay: matches requirement for f in concept instance C<int, int>
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{Concept maps shall not contain declarations that do not satisfy any
requirement in their corresponding concept or its refined
concepts. \mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> { }

concept_map C<int> {
  int f(int); // error: no requirement for function f
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum 
\addedConcepts{At the point of definition of a concept map, all associated
requirements (\mbox{\ref{concept.req}}) of the corresponding
concept and its refined concepts (\mbox{\ref{concept.refine}}) shall be
satisfied (\mbox{\ref{temp.req.sat}}). \mbox{\enterexample}}
\begin{codeblock}
concept SignedIntegral<typename T> { /* ... */ }

concept ForwardIterator<typename Iter> {
  typename difference_type;
  requires SignedIntegral<difference_type>;
}

concept_map SignedIntegral<ptrdiff_t> { }

concept_map ForwardIterator<int*> {
  typedef ptrdiff_t difference_type;
} // okay: there exists a concept_map SignedIntegral<ptrdiff_t>

class file_iterator { ... };

concept_map ForwardIterator<file_iterator> {
  typedef long difference_type;
} // error: no concept_map SignedIntegral<long> if ptrdiff_t is not long
\end{codeblock} 
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{A concept map for an implicit concept is implicitly defined when it is
needed} \addedConcepts{by concept map lookup (\mbox{\ref{temp.req.sat}})}\addedConcepts{.}
\addedConcepts{If any requirement of the concept or its refinements is not
  satisfied by the implicitly-defined concept map, the concept map is not
  implicitly defined.
The implicitly-defined concept map is defined in the
  namespace of the concept. \mbox{\enterexample}}
\begin{codeblock}
auto concept Addable<typename T> {
  T::T(const T&);
  T operator+(T, T);
}

template<typename T>
requires Addable<T>
T add(T x, T y) {
  return x + y;
}

int f(int x, int y) {
  return add(x, y); // okay: concept map Addable<int> implicitly defined
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{\mbox{\enternote} Failure to implicitly define a
concept map does not necessarily
imply that the program is ill-formed
(\mbox{\ref{temp.deduct}}). \mbox{\exitnote}\ 
\mbox{\enterexample}}
\begin{codeblock}
auto concept F<typename T> {
  void f(T);
}

auto concept G<typename T> {
  void g(T);
}

template<typename T> requires F<T> void h(T); // \#1
template<typename T> requires G<T> void h(T); // \#2

struct X { };
void g(X);

void func(X x) {
  h(x); // okay: implicit concept map F<X> fails, causing template argument deduction to fail for \#1; calls \#2
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{A concept map or
concept map template shall be defined before the first use of a
concept instance that would make use of the concept map or concept map
template in every translation unit in which such a use occurs; no 
diagnostic is required. If the introduction of a concept map
or concept map template
changes a previous result (e.g., in template argument deduction
(\mbox{\ref{temp.deduct}})), the program is ill-formed, no diagnostic
required. Concept map templates must be
instantiated if doing so would affect the semantics of the program.}
%
\addedConcepts{A concept map for a particular concept instance shall not be
  defined both implicitly and explicitly in the same namespace in a
  program. If one translation unit of a program contains an
  explicitly-defined concept map for that concept instance, and a
  different translation contains an implicitly-defined concept map for
  that concept instance, then the program is ill-formed, no diagnostic
  required.}

\pnum
\addedConcepts{The implicit or explicit definition of a concept map asserts that the
axioms (\mbox{\ref{concept.axiom}}) stated in its corresponding concept (and
the refinements of that concept) hold, permitting an
  implementation to perform the transformations described in~\mbox{\ref{concept.axiom}}. If an axiom is violated, the behavior of
  the program is undefined.}

\rSec3[concept.map.fct]{Associated function definitions}

\pnum
\addedConcepts{Function definitions in the concept map can be used to adapt the
syntax of the concept's template arguments
to the syntax expected by the concept. \mbox{\enterexample}}
\begin{codeblock}
concept Stack<typename S> { 
  typename value_type;
  bool empty(S const&);
  void push(S&, value_type);
  void pop(S&);
  value_type& top(S&);
}

// Make a vector behave like a stack
template<Regular T>
concept_map Stack<std::vector<T> > {
  typedef T value_type;
  bool empty(std::vector<T> const& vec) { return vec.empty(); }
  void push(std::vector<T>& vec, value_type const& value) { 
    vec.push_back(value); 
  }
  void pop(std::vector<T>& vec) { vec.pop_back(); }  
  value_type& top(std::vector<T>& vec) { return vec.back(); }
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{A function or function template defined in a concept
  map is inline.}

\pnum
\addedConcepts{An associated function (or function template) requirement is
  satisfied as follows. Given an associated function (call it
  \mbox{\tcode{f}}), let \mbox{\tcode{R}}
  be the return type of \mbox{\tcode{f}}, after substitution of
  the concept's template arguments for their corresponding concept
  parameters. Construct an expression \mbox{\tcode{E}}
(as defined below)
in the scope of
  the concept map. Then, the associated function requirement is
  satisfied:}
\begin{itemize}
\additemConcepts{if \mbox{\tcode{R}} is \mbox{\techterm{cv} \tcode{void}}
  and the expression \mbox{\tcode{E}} is well-formed,}
\additemConcepts{if \mbox{\tcode{R}} is not \mbox{\techterm{cv}
    \tcode{void}} and the expression ``\mbox{\tcode{E}} implicitly
  converted to \mbox{\tcode{R}}'' is well-formed, or}
\additemConcepts{if \mbox{\tcode{f}} has a default implementation.}
\end{itemize}

\pnum 
\addedConcepts{The expression \mbox{\tcode{E}} is defined differently
  depending on the associated function and the concept map
  definition. Let \mbox{\tcode{parm1}}, \mbox{\tcode{parm2}}, ...,
  \mbox{\tcode{parm$N$}} be the parameters 
  of \mbox{\tcode{f}} (after substitution of the concept map
  arguments) and \mbox{\tcode{parm1$'$}},
  \mbox{\tcode{parm2$'$}}, ..., \mbox{\tcode{parm$N'$}} be
  expressions, where each \mbox{\tcode{parm$i'$}} is an
  \mbox{\techterm{id-expression}} naming \mbox{\tcode{parm$i$}}. If
  the declared type of \mbox{\tcode{parm$i$}} is an lvalue reference
  type, then \mbox{\tcode{parm$i'$}} is treated as an lvalue,
  otherwise, \mbox{\tcode{parm$i'$}} is treated as an rvalue.}

\addedConcepts{For an associated member function (or member function
  template) in a type \mbox{\tcode{X}} (after substitution of the concept
  map arguments into the associated member function or
  member function template), let \mbox{\tcode{x}} be an object of type
  \mbox{$cv$ \tcode{X}}, where \mbox{$cv$} are the
  \mbox{\techterm{cv-qualifiers}} on the associated member function
  (or member function template). If the requirement has no
  \mbox{\techterm{ref-qualifier}} or if its
  \mbox{\techterm{ref-qualifier}} is \mbox{\tcode{\&}},
  \mbox{\tcode{x}} is an lvalue; otherwise, \mbox{\tcode{x}} is an
  rvalue.}

\addedConcepts{The expression \mbox{\tcode{E}} is defined as follows:}
\begin{itemize}
\additemConcepts{If \mbox{\tcode{f}} is an associated non-member function or
  function template and the concept map contains one or more function or
    function template definitions with the same name as
    \mbox{\tcode{f}}, 
    \mbox{\tcode{E}} is \mbox{\tcode{f(parm1$'$, parm2$'$,
        ..., parm$N'$)}}, and the overload set of entities
    \mbox{\tcode{f}} consists of the definitions of \mbox{\tcode{f}} in
    the concept map (and unqualified lookup
    \mbox{\ref{basic.lookup.unqual}} and argument dependent lookup
    \mbox{\ref{basic.lookup.argdep}} are suppressed),}

\additemConcepts{if \mbox{\tcode{f}} is a non-static associated member
  function and the concept map contains one or more member function
    or member function template definitions in the type
    \mbox{\tcode{X}} and with the same name as \mbox{\tcode{f}},
    \mbox{\tcode{E}} is \mbox{\tcode{x.f(parm1$'$, parm2$'$,
        ...,}} \mbox{\tcode{parm$N'$)}}, where name lookup of \mbox{\tcode{x.f}} refers
    to the definitions of \mbox{\tcode{X::f}} in the concept map,}

\additemConcepts{if \mbox{\tcode{f}} is a static associated member function
  and the concept map contains one or more member function
    or member function template definitions in the type
    \mbox{\tcode{X}} and with the same name as \mbox{\tcode{f}},
    \mbox{\tcode{E}} is \mbox{\tcode{X::f(parm1$'$, parm2$'$,
        ..., parm$N'$)}}, where name lookup of \mbox{\tcode{X::f}} refers
    to the static definitions of \mbox{\tcode{X::f}} in the concept map,}

\additemConcepts{if the associated function or function template
    is a prefix unary operator \mbox{\tcode{Op}},
    \mbox{\tcode{E}} is \mbox{\tcode{Op parm1$'$}},}

\additemConcepts{if the associated function or function template is a
  postfix unary 
  operator \mbox{\tcode{Op}}, \mbox{\tcode{E}} is
  \mbox{\tcode{parm1$'$ Op}}},
  
\additemConcepts{if the associated function or function template is a binary operator
  \mbox{\tcode{Op}}, \mbox{\tcode{E}} is
  \mbox{\tcode{parm1$'$ Op parm2$'$}}, }

\additemConcepts{if the associated function or function template is
  the function call 
  operator, \mbox{\tcode{E}} is}\\
  \addedConcepts{\mbox{\tcode{parm1$'$(parm2$'$, parm3$'$, ..., parm$N'$)}},}

\additemConcepts{if the associated function is a conversion operator, 
  \mbox{\tcode{E}} is \mbox{\tcode{parm1$'$}} if the
  conversion operator requirement is not \mbox{\tcode{explicit}} and
  \mbox{\tcode{(R)parm1$'$}} if the conversion operator requirement is
  \mbox{\tcode{explicit}}, where \mbox{\tcode{R}} is the return type
  of the conversion operator,}

\additemConcepts{if the associated function or function template
  is a non-member function or function template, 
  \mbox{\tcode{E}} is an unqualified
  call \mbox{\tcode{f(\tcode{parm1$'$}, \tcode{parm2$'$}, ...,
  \tcode{parm$N'$})}},}

\additemConcepts{if the associated function or function template is a static
  member function or function template in the type \mbox{\tcode{X}},
  \mbox{\tcode{E}} is a call
  \mbox{\tcode{X::f(\tcode{parm1$'$}, \tcode{parm2$'$}, ...,
      \tcode{parm$N'$})}},}

\item \addedConcepts{if the associated
    function is a constructor or constructor template that is
    \mbox{\tcode{explicit}} or has \mbox{$N \neq
      1$} parameters,} \addedConcepts{\mbox{\tcode{E}} is
    \mbox{\tcode{X(parm1$'$, parm2$'$, ..., parm$N'$)}}.}
  \addedConcepts{\enterexample}
\begin{codeblock}
concept TwoIntConstructible<typename T> {
  T::T(int, int);
}

struct X { X(long, int); };
concept_map TwoIntConstructible<X> { } // okay: X has a constructor that can accept two ints 
                                       // (the first is converted to a long)
\end{codeblock}
\addedConcepts{\exitexample}

\item \addedConcepts{if the associated
    function is a constructor or constructor template that has one
    parameter (and is not \mbox{\tcode{explicit}}),
  \mbox{\tcode{E}} is ``\mbox{\tcode{parm1$'$}} implicitly converted to
      \mbox{\tcode{X}}''.}
    \addedConcepts{\enterexample}
\begin{codeblock}
concept IC<typename T> {
  T::T(int);
}

concept EC<typename T> {
  explicit T::T(int);
}

struct X {
  X(int);
};

struct Y {
  explicit Y(int);
};

concept_map IC<X> { } // okay
concept_map EC<X> { } // okay
concept_map IC<Y> { } // error: cannot copy-initialize Y from an int
concept_map EC<Y> { } // okay
\end{codeblock}
\addedConcepts{\exitexample}

\additemConcepts{if the associated function is a destructor,
  \mbox{\tcode{E}} is \mbox{\tcode{x.$\sim$X()}}.}\addedConcepts{\enterexample}
\begin{codeblock}
concept Destructible<typename T> {
  T::~T();
}

concept_map Destructible<int> { } // okay: int is not a class type

struct X { };
concept_map Destructible<X> { } // okay: X has implicitly-declared, public destructor

struct Y { private: ~Y(); };
concept_map Destructible<Y> { } // error: Y's destructor is inaccessible
\end{codeblock}
\addedConcepts{\exitexample}

\item \addedConcepts{if the associated member function requirement is a
  requirement for an operator \mbox{\tcode{new}} or \mbox{\tcode{new[]}},
  \mbox{\tcode{E}} is \\\mbox{\tcode{operator
      new(parm1$'$, parm2$'$, 
      ..., parm$N'$)}} or \mbox{\tcode{operator new[](parm1$'$)}},
    respectively.}
\addedConcepts{Name lookup for the allocation function occurs in the scope
  of \mbox{\tcode{X}}; if this lookup fails to
  find the name, the allocation function's name is looked up in the
  global scope.}

\item \addedConcepts{if the associated member function requirement is a
  requirement for an operator \mbox{\tcode{delete}} or \mbox{\tcode{delete[]}},
  \mbox{\tcode{E}} is \mbox{\tcode{operator delete(parm1$'$, parm2$'$, 
      ..., parm$N'$)}} or \mbox{\tcode{operator
      delete[](parm1$'$)}}, respectively.}
\addedConcepts{Name lookup for the deallocation function occurs in the scope
  of \mbox{\tcode{X}}; if this lookup fails to
  find the name, the deallocation function's name is looked up in the
  global scope.}

\additemConcepts{otherwise, \mbox{\tcode{E}} is
\mbox{\tcode{x.f(parm1$'$, parm2$'$, ..., parm$N'$)}}.}
\end{itemize}

\pnum
\addedConcepts{Each satisfied associated function (or function template)
  requirement has a corresponding associated function candidate
  set. An \mbox{\techterm{associated function candidate set}} is a
  candidate set (\mbox{\ref{temp.constrained.set}}) representing the
  functions or operations used to satisfy the requirement. The
  seed of the associated function candidate set is determined based on
  the expression \mbox{\tcode{E}} used to 
  determine that the requirement was satisfied.}
\begin{itemize}
  \additemConcepts{if the evaluation of \mbox{\tcode{E}} involves overload
    resolution at the top level, the seed is the candidate function 
    (\mbox{\ref{over.match.funcs}}) determined by the outermost
    application of overload resolution (clause~\mbox{\ref{over}}), or}
  \additemConcepts{if \mbox{\tcode{E}} is a pseudo destructor call
    (\mbox{\ref{expr.pseudo}}), the seed is a
    \mbox{\techterm{pseudo-destructor-name}}, otherwise}
  \additemConcepts{the seed is the initialization of an object.}
\end{itemize}


\rSec3[concept.map.assoc]{Associated type and template definitions}

\pnum
\addedConcepts{Definitions in the concept map provide types and templates
that satisfy requirements for associated types and templates
(\mbox{\ref{concept.assoc}}), respectively.}

\pnum
\addedConcepts{Associated type parameter requirements are satisfied by type definitions in the
body of a concept map. \mbox{\enterexample}}
\begin{codeblock}
concept ForwardIterator<typename Iter> {
  typename difference_type;
}

concept_map ForwardIterator<int*> {
  typedef ptrdiff_t difference_type;
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{Associated class
template requirements are satisfied by class template
definitions or template aliases (\mbox{\ref{temp.alias}}) in the body of the concept map. \mbox{\enterexample}}
\begin{codeblock}
concept Allocator<typename Alloc> {
  template<class T> class rebind;
}

template<typename T>
concept_map Allocator<my_allocator<T>> {
  template<class U>
    class rebind {
    public:
      typedef my_allocator<U> type;
    };
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{A concept map member that satisfies an associated type
  or class
template requirement can be implicitly defined using template
  argument deduction (\mbox{\ref{temp.deduct}}) with one or more
  associated function requirements
  (\mbox{\ref{concept.map.fct}}), if the associated type or
  class template requirement does not have a default
  value}\addedConcepts{.
  The definition of the associated type or class template is
  determined using the rules of template argument deduction from a
  type (\mbox{\ref{temp.deduct.type}}). Let
  \mbox{\tcode{P}} be the return type of an associated function after
  substitution of the concept's template parameters specified by the concept map
  with their template arguments, and where each undefined associated
  type and associated class
template has been replaced with a newly invented
  type or template template parameter, respectively. Let
  \mbox{\tcode{A}} be the return type of the seed in the associated
  function candidate set
  corresponding to the associated function. If the deduction fails, no
  concept map members are implicitly defined by that associated
  function. If the results of
  deduction produced by different associated functions yield more than
  one possible value, that associated type or class template is
  not implicitly defined. \mbox{\enterexample}}
\begin{codeblock}
auto concept Dereferenceable<typename T> {
  typename value_type;
  value_type& operator*(T&);
}

template<typename T> requires Dereferenceable<T> void f(T&);

void g(int* x) {
  f(x); // okay: Dereferenceable<int*> implicitly defined
        // implicitly-defined Dereferenceable<int*>::operator* calls built-in * for integer pointers
        // implicitly-defined Dereferenceable<int*>::value_type is int
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{If an associated type or class template
  (\mbox{\ref{concept.assoc}}) has a default value, a concept map member
  satisfying the associated
type or class template requirement shall be implicitly defined by
  substituting the 
concept map arguments into the default value. If this substitution
does not produce a valid type or template (\mbox{\ref{temp.deduct}}), the
concept map member is not implicitly defined. \mbox{\enterexample}}
\begin{codeblock}
auto concept A<typename T> {
  typename result_type = typename T::result_type;
}

auto concept B<typename T> {
  T::T(const T&);
}

template<typename T> requires A<T> void f(const T&); // \#1
template<typename T> requires B<T> void f(const T&); // \#2

struct X {};
void g(X x) {
  f(x); // okay: A<X> cannot satisfy result_type requirement, and is not implicitly defined, calls \#2
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\rSec2[concept.refine]{Concept refinement}

\pnum
\addedConcepts{The grammar for a \mbox{\techterm{refinement-clause}} is:}

\begin{bnf}
\addedConcepts{refinement-clause:}\br
         \addedConcepts{\mbox{\terminal{:}} refinement-specifier-list}\br

\addedConcepts{refinement-specifier-list:}\br
         \addedConcepts{refinement-specifier \mbox{\terminal{,}} refinement-specifier-list}\br
         \addedConcepts{refinement-specifier}\br

\addedConcepts{refinement-specifier:}\br
         \addedConcepts{\mbox{\terminal{::}\opt}\ nested-name-specifier\mbox{\opt}\ concept-id}
\end{bnf}

\pnum 
\addedConcepts{Refinements specify an inheritance
relationship among concepts. }
%
\addedConcepts{A concept \mbox{\tcode{B}} named in a \mbox{\techterm{refinement-specifier}} of
concept \mbox{\tcode{D}} is a \mbox{\techterm{refined concept}} of \mbox{\tcode{D}} and
\mbox{\tcode{D}} is a \mbox{\techterm{refining concept}} of \mbox{\tcode{B}}.}
%
\addedConcepts{A concept refinement inherits all
requirements in the body of a concept (\mbox{\ref{concept.def}}), such that
the requirements of the refining concept are a superset of the
requirements of the refined concept.}
%
\addedConcepts{\mbox{\enternote}\ 
when a concept \mbox{\tcode{D}} refines
a concept \mbox{\tcode{B}}, every set of template arguments that satisfies the
requirements of \mbox{\tcode{D}} also satisfies the requirements of
\mbox{\tcode{B}}. The refinement relationship is transitive.
\mbox{\exitnote}}
%
\addedConcepts{\mbox{\enterexample} In the following example,
\mbox{\tcode{EquilateralPolygon}} refines
\mbox{\tcode{Polygon}}. Thus, every
\mbox{\tcode{EquilateralPolygon}} is a \mbox{\tcode{Polygon}}, and constrained
templates (\mbox{\ref{temp.constrained}}) that are well-formed with a
\mbox{\tcode{Polygon}} constraint are well-formed when given an
\mbox{\tcode{EquilateralPolygon}}.}
\begin{codeblock}
concept Polygon<typename P> { /* ... */ }

concept EquilateralPolygon<typename P> : Polygon<P> { /* ... */ }
\end{codeblock} \exitexample\

\pnum
\addedConcepts{A \mbox{\techterm{refinement-specifier}} shall refer to
  a previously defined concept. \mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> : C<vector<T>> {/* ... */ } // error: concept C is not defined
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{The \mbox{\techterm{template-argument-list}} of a
\mbox{\techterm{refinement-specifier}}'s \mbox{\techterm{concept-id}} shall refer to at
  least one of the template parameters, and no template
  parameter shall be used in a way that establishes an
  archetype. \mbox{\enterexample}}
\begin{codeblock}
concept InputIterator<typename Iter> 
  : Incrementable<int>  // error: Incrementable<int> uses no template parameters
{
  // ...
}
\end{codeblock} 
\addedConcepts{\mbox{\exitexample}}

\pnum 
\addedConcepts{Within the definition of a concept, a concept map archetype
(\mbox{\ref{temp.archetype}}) is synthesized for each
\mbox{\techterm{refinement-specifier}} in the concept's
\mbox{\techterm{refinement-clause}} (if any).}

\rSec3[concept.member.lookup]{Concept member lookup}

\pnum
\addedConcepts{Concept member lookup determines the meaning of a name
in concept scope
(\mbox{\ref{basic.scope.concept}}). The following steps define the result of
name lookup for a member name \mbox{\tcode{f}} in concept scope
\mbox{\tcode{C}}. \mbox{\tcode{C$_R$}} is the set of concept scopes corresponding to
the concepts refined by the concept whose scope is \mbox{\tcode{C}}.}

\pnum
\addedConcepts{If the name \mbox{\tcode{f}} is declared in concept scope \mbox{\tcode{C}}, and
\mbox{\tcode{f}} refers to an associated type or class template
(\mbox{\ref{concept.assoc}}), then the result of name lookup is the
associated type or class template.}

\pnum
\addedConcepts{If the name \mbox{\tcode{f}} is declared in concept scope \mbox{\tcode{C}}, and
\mbox{\tcode{f}} refers to one or more associated functions
(\mbox{\ref{concept.fct}}), then the result of name lookup is the set
consisting of the associated functions in \mbox{\tcode{C}} in addition to the
associated functions in each concept scope
in \mbox{\tcode{C$_R$}} for which
name lookup of \mbox{\tcode{f}} results in a set
  of associated functions. \mbox{\enterexample}}
\begin{codeblock}
concept C1<typename T> : CopyConstructible<T> {
  T f(T); // \#1
}

concept C2<typename T> {
  typename f;
}

concept D<typename T> : C1<T>, C2<T> {
  T f(T, T); // \#2
}

template<typename T> 
requires D<T>
void f(T x) 
{
  D<T>::f(x); // name lookup finds \#1 and \#2, overload resolution selects \#1
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{If the name \mbox{\tcode{f}} is not declared in \mbox{\tcode{C}}, name lookup
searches for \mbox{\tcode{f}} in the scopes of each of the refined concepts
(\mbox{\tcode{C$_R$}}). If name lookup of \mbox{\tcode{f}} is ambiguous in any
concept scope \mbox{\tcode{C$_R$}}, name lookup of \mbox{\tcode{f}} in \mbox{\tcode{C}} is
ambiguous. Otherwise, the set of concept scopes \mbox{\tcode{C$_{R'}$}} is a
subset of \mbox{\tcode{C$_R$}} containing only those concept scopes for which
name lookup finds \mbox{\tcode{f}}. The result of name lookup for \mbox{\tcode{f}}
in \mbox{\tcode{C}} is defined by:}

\begin{itemize}
\additemConcepts{if \mbox{\tcode{C$_{R'}$}} is empty, name lookup of \mbox{\tcode{f}} in \mbox{\tcode{C}}
  returns no result, or}

\additemConcepts{if \mbox{\tcode{C$_{R'}$}} contains only a single concept scope, name
  lookup for \mbox{\tcode{f}} in \mbox{\tcode{C}} is the result of name lookup for
  \mbox{\tcode{f}} in that concept scope, or}

\additemConcepts{if \mbox{\tcode{f}} refers to one or more
    functions in all of the concept scopes in \mbox{\tcode{C$_{R'}$}}, then
  \mbox{\tcode{f}}
  refers to the set consisting of
  all associated functions from all of the concept scopes in \mbox{\tcode{C$_{R'}$}}, or}

\additemConcepts{if \mbox{\tcode{f}} refers to an associated type in all concept
  scopes in \mbox{\tcode{C$_{R'}$}}, and all of the associated types are
  equivalent (\mbox{\ref{temp.req}}), the result is the associated
  type \mbox{\tcode{f}} found first by a depth-first traversal of the
  refinement clauses,}

\additemConcepts{otherwise, name lookup of \mbox{\tcode{f}} in \mbox{\tcode{C}} is ambiguous.}
\end{itemize}

\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept A<typename T> { typename t; }

concept B<typename T> { typename t; }

concept C<typename T> :  A<T>, B<T> {
  f(t); // error: ambiguous, the two t's are not equivalent
  f(A<T>::t); // okay
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{When name lookup in a concept scope \mbox{\tcode{C}} results in a set of associated functions, duplicate associated
functions are removed from the 
set.}
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept A<typename T> {
  T f(T); // \#1a
}

concept B<typename T> {
  T f(T); // \#1b
  T g(T); // \#2a
}

concept C<typename T> : A<T>, B<T> {
  T g(T); // \#2b
}

template<typename T>
requires C<T>
void h(T x) {
  C<T>::f(x); // overload set contains \#1a; \#1b was removed as a duplicate
  C<T>::g(x); // overload set contains \#2b; \#2a was removed as a duplicate
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\rSec3[concept.refine.maps]{Implicit concept maps for refined concepts}

\pnum
\addedConcepts{When a concept map is defined for a concept
  \mbox{\tcode{C}} that has a refinement clause, concept maps for each
  of the concept instances in the
  refinement clause of
\mbox{\tcode{C}}
will be defined
in the namespace of which the
concept map is a member.
If a concept map for a given concept instance in the
  refinement clause has not be defined in the namespace of the
  refining concept map, it is defined implicitly.
\mbox{\enterexample}}
\begin{codeblock}
concept A<typename T> { }
concept B<typename T> : A<T> { }

concept_map B<int> { } // implicitly defines concept map A<int>
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{When a concept map is implicitly defined for a refinement,
definitions in the concept map for the refining concept are
used to 
satisfy the requirements of the refined concept (\mbox{\ref{concept.map}}).
\mbox{\enternote} a single function definition in a concept
  map can be used to satisfy multiple requirements. \mbox{\exitnote}
\mbox{\enterexample} in this example, the concept map \mbox{\tcode{D<int>}}
implicitly defines the concept map \mbox{\tcode{C<int>}}.}
\begin{codeblock}
concept C<typename T> {
  T f(T);
  void g(T);
}

concept D<typename T> : C<T> { 
  void g(T);
}

concept_map D<int> {
  int f(int x) { return -x; } // satisfies requirement for C<int>::f
  void g(int x) { } // satisfies requirement for C<int>::g and D<int>::g
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{Concept map templates (\mbox{\ref{temp.concept.map}}) are implicitly defined
only for certain refinements of the concept corresponding to the
concept map template. A concept map template for a particular refined
concept is defined}
\addedConcepts{in the namespace of the concept map}
\addedConcepts{if all of the template parameters of the refining
concept map template can be deduced from the
\mbox{\techterm{template-argument-list}} of
the \mbox{\techterm{refinement-specifier}}'s
corresponding concept instance
(\mbox{\ref{temp.deduct.type}}). If template argument deduction fails, then a
concept map template corresponding to the refined concept shall
have been defined}
\addedConcepts{in the namespace of the concept map}\addedConcepts{.
\mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> { }
concept D<typename T, typename U> : C<T> { }

template<typename T> struct A { };

template<typename T> concept_map D<A<T>, T> { }
// implicitly defines:
template<typename T> concept_map C<A<T>> { }

template<typename T, typename U> 
  concept_map D<T, A<U>> { } // ill-formed: cannot deduce template parameter U from C<T>
                             // and there is no concept map template C<T>
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum 
\addedConcepts{Each concept map or concept map template shall have satisfiers
that are compatible with the satisfiers of
the
concept map or concept map template named by the refinement. A satisfier of
the refining concept map or concept map template is
compatible with its corresponding satisfier of
the refined concept
map or concept map template if}
\begin{itemize}
\additemConcepts{the satisfiers correspond to an associated function
  requirement (\mbox{\ref{concept.fct}}) and their associated function
candidate sets have the same seed or}
\additemConcepts{the satisfiers satisfy an associated type or class
template requirement (\mbox{\ref{concept.assoc}}) and
both satisfiers name the same type or template, respectively.}
\end{itemize}
\addedConcepts{If a program contains satisfiers of
a concept map or concept
map template that are not compatible with their corresponding satisfiers of
a refined concept map or concept map template, the
program is ill-formed.}
\addedConcepts{if the concept maps or concept map templates with satisfiers
that are not compatible occur in different translation
units, no diagnostic is required. \mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> {
  typename assoc;
  assoc f(T);
}

concept D<typename T> : C<T> { 
  int g(T);
}

concept E<typename T> : D<T> { }

concept_map C<int> {
  typedef int assoc;
  int f(int x) { return x; }
}

concept_map D<int> {
  typedef int assoc; // okay: same type as C<int>::assoc
  // okay: f is not defined in D<int>
  int g(int x) { return -x; } // okay: satisfies D<int>::g
} 

concept_map E<int> {
  typedef float assoc; // error: E<int>::assoc and D<int>::assoc are not the same type
  // okay: f is not defined in D<int>
  int g(int x) { return x; } // error: D<int>::g already defined in concept map D<int>
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\rSec1[temp.constrained]{Constrained templates}

\pnum
\addedConcepts{A template that has a \mbox{\techterm{requires-clause}}
  (or declares any 
template type parameters using the simple form of requirements
(\mbox{\ref{temp.param}})) is a \mbox{\techterm{constrained
  template}}. A constrained template can only be instantiated with
template arguments that satisfy its template requirements. 
The template definitions of constrained templates are
similarly constrained, requiring names to be 
found through name lookup at template definition time
(\mbox{\ref{basic.lookup}}). \mbox{\enternote}
Names can be found in the template requirements of a
  constrained template (\mbox{\ref{basic.scope.req}}). The practical effect of constrained templates is that they provide
improved diagnostics at template definition time, such that any use of
the constrained template that satisfies the template's requirements is
likely to result in a well-formed instantiation. \mbox{\exitnote}}

\pnum
\addedConcepts{A template that is not a constrained template is an
\mbox{\techterm{unconstrained template}}.}

\pnum \addedConcepts{A \mbox{\techterm{constrained context}} is a part of a
  constrained template in which all name lookup is resolved at
  template definition time. Names that would be dependent outside of a
  constrained context shall be found in the current scope, which includes
  the template requirements of the constrained template
  (\mbox{\ref{basic.scope.req}}). \mbox{\enternote} Within a constrained
  context, template parameters behave as if aliased to their
  corresponding archetypes
  (\mbox{\ref{temp.archetype}}) so there are no dependent types
  (\mbox{\ref{temp.dep.type}}), and no type-dependent values
  (\mbox{\ref{temp.dep.expr}}) or dependent names (\mbox{\ref{temp.dep}}).
  Instantiation in constrained contexts (\mbox{\ref{temp.constrained.inst}})
  still substitutes types, templates and values for template
  parameters. \mbox{\exitnote} A constrained
  context is any part of a constrained template that is not an
  unconstrained context (described  below).}

\pnum
\addedConcepts{Any context that is not a constrained context is an
  \mbox{\techterm{unconstrained context}}. Within a constrained
  context, several constructs provide unconstrained contexts:}
\begin{itemize}
  \additemConcepts{a late-checked block (\mbox{\ref{stmt.late}}),}
  \additemConcepts{a default template argument in a
    \mbox{\techterm{template-parameter}},}
\end{itemize}

\pnum
\removedCCC{If a type or expression within the signature of a constrained
template, the \mbox{\techterm{template-parameter-list}} of a
constrained template, or the \mbox{\techterm{requires-clause}} of a
constrained template (if any) would be ill-formed if the associated
context were a constrained context, the program is
ill-formed. \mbox{\enterexample} [removed example] \mbox{\exitexample}}

\pnum
\addedConcepts{Within a constrained context, a program shall not refer to an
  unconstrained template.}

\rSec2[temp.req]{Template requirements}
\pnum
\addedConcepts{A template has \mbox{\techterm{template requirements}} if it contains a
\mbox{\techterm{requires-clause}} or any of its template parameters is
specified using the simple form of requirements
(\mbox{\ref{temp.param}}). Template requirements state the conditions under
which the template can be used.}

\begin{bnf}
\addedConcepts{requires-clause:}\br
         \addedConcepts{\mbox{\terminal{requires}} requirement-list}\br
         \addedConcepts{\mbox{\terminal{requires (}} requirement-list \mbox{\terminal{)}}}\br

\addedConcepts{requirement-list:}\br
         \addedConcepts{requirement \mbox{\terminal{...}\opt\ \terminal{\&\&}} requirement-list}\br
         \addedConcepts{requirement \mbox{\terminal{...}\opt}} \br

\addedConcepts{requirement:}\br
         \addedConcepts{\mbox{\terminal{::}\opt\ nested-name-specifier\opt\ concept-id}}\br
         \addedConcepts{\mbox{\terminal{!} \terminal{::}\opt\ nested-name-specifier\opt\ concept-id}}
\end{bnf}

\pnum
\addedConcepts{A \mbox{\techterm{requires-clause}} contains a list of
  requirements, all of which must be satisfied by the template
  arguments for the template.}
\addedConcepts{\mbox{\enternote} Requirement satisfaction is described in~\mbox{\ref{temp.req.sat}}. \mbox{\exitnote}}
\addedConcepts{A \mbox{\techterm{requirement}} not
  containing a \mbox{\tcode{!}} is a \mbox{\techterm{concept
      requirement}}. A \mbox{\techterm{requirement}} containing a
  \mbox{\tcode{!}} is a \mbox{\techterm{negative requirement}}.}

\pnum
\addedConcepts{A concept requirement that refers to the
\mbox{\tcode{SameType}} concept (\mbox{\ref{concept.support}}) is a
\mbox{\techterm{same-type requirement}}. A same-type requirement is satisfied
when its two template arguments refer to the same type (including the
same \mbox{\techterm{cv}} qualifiers). In a 
constrained template (\mbox{\ref{temp.constrained}}), a same-type requirement
\mbox{\tcode{SameType<T1, T2>}} makes the types \mbox{\tcode{T1}} and \mbox{\tcode{T2}}
equivalent. \mbox{\enternote} type equivalence is a
congruence relation, thus}
\begin{itemize}
\item \addedConcepts{\mbox{\tcode{SameType<T1, T2>}} implies \mbox{\tcode{SameType<T2, T1>}},}
\item \addedConcepts{\mbox{\tcode{SameType<T1, T2>}} and \mbox{\tcode{SameType<T2, T3>}} implies
  \mbox{\tcode{SameType<T1, T3>}},}
\item \addedConcepts{\mbox{\tcode{SameType<T1, T1>}} is trivially true,}
\item \addedConcepts{\mbox{\tcode{SameType<T1*, T2*>}} implies \mbox{\tcode{SameType<T1, T2>}} and
  \mbox{\tcode{SameType<T1**, T2**>}}, etc.}
\end{itemize}
\addedConcepts{\mbox{\exitnote}
\mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> {
  typename assoc;
  assoc a(T);
}

concept D<typename T> {
  T::T(const T&);
  T operator+(T, T);
}

template<typename T, typename U>
requires C<T> && C<U> && SameType<C<T>::assoc, C<U>::assoc> && D<C<T>::assoc>
C<T>::assoc f(T t, U u) {
  return a(t) + a(u); // okay: C<T>::assoc and C<U>::assoc are the same type
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{A \mbox{\techterm{requirement}} followed by an ellipsis is a pack expansion
(\mbox{\ref{temp.variadic}}). Requirement pack expansions place requirements
on all of the arguments in one or more template parameter
packs. \mbox{\enterexample}}
\begin{codeblock}
auto concept OutputStreamable<typename T> {
  std::ostream& operator<<(std::ostream&, const T&);
}

template<typename T, typename... Rest>
requires OutputStreamable<T> && OutputStreamable<Rest>...
void print(const T& t, const Rest&... rest) {
  std::cout << t;
  print(rest);
}

template<typename T>
requires OutputStreamable<T>
void print(const T& t) {
  std::cout << t;
}

void f(int x, float y) {
  print(17, ", ", 3.14159); // okay: implicitly-generated OutputStreamable<int>, OutputStreamable<const char[3]>,
                              // and OutputStreamable<double>
  print(17, " ", std::cout); // error: no concept map OutputStreamable<std::ostream>
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{If the requirements of a template are inconsistent, such that
no set of template arguments can satisfy all of the requirements, the
program is ill-formed, no diagnostic required. \mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> { }

template<typename T>
requires C<T> && !C<T>
void f(const T&); // error: no type can satisfy both C<T> \&\& !C<T>, no diagnostic required
\end{codeblock}
\addedConcepts{\exitexample}

\rSec3[temp.req.sat]{Requirement satisfaction}

\pnum
\addedConcepts{During template argument deduction (\mbox{\ref{temp.deduct}})
  against a constrained template, it is necessary to determine whether
  each of the requirements of the constrained template can be
  satisfied by the template arguments.}

\pnum
\addedConcepts{A concept requirement is \mbox{\techterm{satisfied}} if
    concept map lookup (described below) finds a
    unique concept map with the same full concept name as the
    concept named by the concept requirement and whose template
    argument list is the same as the template 
    argument list of the concept requirement, after substitution of the
    constrained template's template arguments into the concept
    requirement's template argument list. Concept maps used to satisfy
    a concept requirement can be defined
    explicitly (\mbox{\ref{concept.map}}), instantiated from a concept
    map template (\mbox{\ref{temp.concept.map}}), or defined
    implicitly (\mbox{\ref{concept.map}}).}
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept A<typename T> { }
auto concept B<typename T> { T operator+(T, T); }
concept C<typename T> { }
concept D<typename T> { }

concept_map A<float> { }
concept_map B<float> { }
template<typename T> concept_map C<T*> { }
template<typename T> requires B<T> concept_map D<T> { }

template<typename T> requires A<T> void f(T);
template<typename T> requires B<T> void g(T);
template<typename T> requires C<T> void h(T);
template<typename T> requires D<T> void i(T);

struct X { };
void h(float x, int y, int X::* p, int *q) {
  f(x); // okay: uses concept map \tcode{A<float>}
  f(y); // error: no concept map \tcode{A<int>}; requirement not satisfied
  g(x); // okay: uses concept map \tcode{B<float>}
  g(y); // okay: implicitly defines and uses concept map \tcode{B<int>}
  g(p); // error: no implicit definition of concept map \tcode{B<int X::*>}; requirement not satisfied
  h(q); // okay: instantiates concept map \tcode{C<T*>} with \tcode{T=int} to satisfy requirement \tcode{C<T>}
  i(p); // error: \tcode{i} can't get no satisfaction; the concept map template \tcode{D<T>} does not apply because \tcode{B<int X::*>} is not satisfied
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum 
\addedConcepts{A negative requirement is satisfied if concept map
  lookup fails to find a concept map that would satisfy the
  corresponding concept requirement. \mbox{\enternote} If concept map
  lookup results in an ambiguity, concept map lookup halts and the
  negative requirement is not satisfied. \mbox{\exitnote}}
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept A<typename T> { }
auto concept B<typename T> { T operator+(T, T); }

concept_map A<float> { }
concept_map B<float> { }

template<typename T> requires !A<T> void f(T);
template<typename T> requires !B<T> void g(T);

struct X { };
void h(float x, int y, int X::* p) {
  f(x); // error: concept map A<float> has been defined
  f(y); // okay: no concept map A<int>
  g(x); // error: concept map B<float> has been defined
  g(y); // error: implicitly defines concept map B<int>, requirement not satisfied
  g(p); // okay: concept map B<int X::*> cannot be implicitly defined
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{\mbox{\techterm{Concept map lookup}} attempts to find a
  concept map that corresponds to the concept instance (call it
  \mbox{\tcode{I}}) 
  formed from the concept of a requirement and its template argument list
  after substitution of template arguments for their corresponding
  template parameters.  There
  is an associated full concept name} 
\addedZ{(\mbox{\ref{concept.def}})}
\addedConcepts{of \mbox{\tcode{I}}; call it
  \mbox{\tcode{N}}. Concept map lookup searches an ordered sequence
  \mbox{\tcode{Q}} (defined below) where each element is a set of
  concept maps called
  \mbox{\tcode{S}}. For each element in \mbox{\tcode{Q}} (progressing
  from the lowest to the highest-numbered element of
  \mbox{\tcode{Q}}), concept map lookup attempts to find within
  \mbox{\tcode{S}}}

\begin{itemize}
  \additemConcepts{exactly one matching non-template concept map or, if one does not
    exist,}

  \additemConcepts{exactly one most-specific matching concept map template
    according to concept map matching rules
    (\mbox{\ref{temp.concept.map}}).}
\end{itemize}

\addedConcepts{If no matching concept map is found within a set
  \mbox{\tcode{S}} in \mbox{\tcode{Q}}, concept map lookup proceeds to
  the next set in \mbox{\tcode{Q}}. If partial ordering of concept
    map templates results in an ambiguity, concept map lookup returns
    no result.}

\pnum
\addedConcepts{When concept map lookup is performed during template argument
    deduction during partial ordering
    (\mbox{\ref{temp.deduct.partial}}),
    \mbox{\tcode{Q}} is defined as
    containing only one element \mbox{\tcode{S}}, where \mbox{\tcode{S}}
    is the set of concept map archetypes synthesized from the requirements
    of the argument template
    (\mbox{\ref{temp.func.order}},\mbox{\ref{temp.deduct.partial}}).}

\pnum
\addedConcepts{When concept map lookup is performed during the
  instantiation of a constrained template
  (\mbox{\ref{temp.constrained.inst}}), \mbox{\tcode{Q}} is defined as
  the following ordered sequence:}

\begin{enumerate}
  \additemConcepts{\mbox{\tcode{S}} is the set of concept maps, each with 
      name \mbox{\tcode{N}}, that have replaced the concept map
      archetypes used in the constrained template.}
    
  \additemConcepts{\mbox{\tcode{S}} is the set of concept maps and
    concept map templates found by
      searching for \mbox{\tcode{N}} in the namespaces of which a subset of the
      concept maps in (1) (described below)
      are members and in the associated namespaces
      of those namespaces (\mbox{\ref{namespace.def}});
      \mbox{\techterm{using-directives}} in those namespaces are not
      followed during this search. Only those concept maps in (1) that
    were explicitly defined or were instantiated from concept map
    templates are considered when determining which namespaces to search.}

  \additemConcepts{If a concept map for \mbox{\tcode{I}} can be implicitly
    defined from an implicit concept
  (\mbox{\ref{concept.map}}), \mbox{\tcode{S}}
    contains the concept map generated from the implicit
    concept. Otherwise, \mbox{\tcode{S}} is empty.}
\end{enumerate}

\mbox{\enterexample}
\begin{codeblock}
concept C<typename T> { }
concept D<typename T> { }

namespace N1 {
  concept_map C<int> { }
  concept_map D<int> { }
}
namespace N2 {
  template<C T> void f(T);                // \#1
  template<C T> requires D<T> void f(T);  // \#2
  template<C T> void g(T x) {
    f(x);
  }
  using N1::concept_map C<int>;
  void h() {
    g(1); // inside g's call to f, concept map lookup for D<int> finds N1::D<int>; calls \#2
  }
}

\end{codeblock}
\exitexample\
     
\pnum
\addedConcepts{In all other cases, \mbox{\tcode{Q}} is defined as the
ordered sequence:}

\begin{enumerate}
  \additemConcepts{\mbox{\tcode{S}} is formed by performing unqualified name
    lookup (\mbox{\ref{basic.lookup.unqual}}) for \mbox{\tcode{N}}.}

  \additemConcepts{\mbox{\tcode{S}} is the set of concept maps
  and concept map templates found by
    searching for \mbox{\tcode{N}} in the namespace of which the
    concept of \mbox{\tcode{I}} is a member and its associated
      namespaces (\mbox{\ref{namespace.def}});
    \mbox{\techterm{using-directives}} in these namespaces are not
    followed during this search and all names found by way of
    \mbox{\techterm{using-declarations}} are ignored.}

  \additemConcepts{If a concept map for \mbox{\tcode{I}} can be implicitly
    defined (\mbox{\ref{concept.map}}), \mbox{\tcode{S}}
    contains the implicitly-defined concept map for
    \mbox{\tcode{I}}. Otherwise, \mbox{\tcode{S}} is empty.}
\end{enumerate}
   
\addedConcepts{\mbox{\enternote} When concept map lookup is performed
  within a constrained context (\mbox{\ref{temp.constrained}}),
  concept map archetypes, whose names are placed at the same scope as
  template parameters, can be found by unqualified lookup.
  \mbox{\exitnote}}
   
\pnum 
\addedConcepts{If concept map lookup finds a matching concept map in a set
  \mbox{\tcode{S}} within \mbox{\tcode{Q}}, concept map lookup
  succeeds and the remaining elements of
  \mbox{\tcode{Q}} are ignored. \mbox{\enternote} The ordering of name-finding
  methods in \mbox{\tcode{Q}} can effect a kind of "concept map
  hiding" behavior. \mbox{\enterexample}}
\begin{codeblock}
namespace N1 {
  concept C<typename T> { }
  concept_map C<int> { } // \#1

  template<C T> void f(T x);
}
namespace N2 {
  concept_map N1::C<int> { } // \#2

  namespace N3 {
    concept_map N1::C<int> { } // \#3

    void g() { 
      N1::f(1); // uses \#3 to satisfy concept requirement N1::C<int>
    }
  }
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample} \mbox{\exitnote}}

\pnum 
\addedConcepts{\mbox{\enternote} Concept maps declared in the namespace of the
  concept itself will be found last by concept map lookup.}
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
namespace N1 {
  concept C<typename T> { }
  concept_map C<int> { }
}
template<N1::C T> void f(T x);
void g() { 
  f(1); // Ok, finds N1::concept_map C<int> because it is in the same namespace as concept N1::C.
} 
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}\addedConcepts{\mbox{\exitnote}}

\pnum
\addedConcepts{If a concept requirement appears (directly or indirectly)
multiple times in the requirements of the template, and
if the concept maps (\mbox{\ref{concept.map}}) used to satisfy the multiple
occurrences of the concept requirement are not the same concept map
or are different from the concept map that would be
  determined by concept map lookup
(\mbox{\ref{temp.req.sat}}),
then the template arguments do not
  satisfy the requirements of the template. \mbox{\enterexample}}
\color{addclr}
\begin{codeblock}
concept A<typename T> { }
concept B<typename T> {
  typename X;
  requires A<X>;
}
concept C<typename T> {
  typename X;
  requires A<X>;
}
namespace N1 {
  concept_map A<int> { }  // \#1
  concept_map B<int> { }  // uses \#1 to satisfy the requirement for A<int>
}
namespace N2 {
  concept_map A<int> { }  // \#2
  concept_map C<int> { }  // uses \#2 to satisfy the requirement for A<int>
}
template<typename T> requires B<T> && C<T>
struct S { };
using N1::concept_map B<int>;
using N2::concept_map C<int>;
S<int> s; // ill-formed, two different concept maps for A<int>, \#1 and \#2
\end{codeblock}
\color{black}
\addedConcepts{\mbox{\exitexample}}

\rSec3[temp.req.impl]{Requirement implication}
\pnum
\addedConcepts{The declaration of a constrained template implies additional template
requirements that are available within the body of the template. A
requirement is \mbox{\techterm{implied}} if the absence of that requirement
would render the constrained template declaration ill-formed. Template
requirements are implied from:}
\begin{itemize}
\additemConcepts{the type of a constrained function template,}
\additemConcepts{the template arguments of a constrained class template partial
  specialization,}
\additemConcepts{the template arguments of a concept map template,}
\additemConcepts{the template parameters of a constrained template,}
\additemConcepts{the requirements of a constrained template (including
  implied requirements),}
\additemConcepts{the associated requirements} \addedConcepts{and
  refinements}
\addedConcepts{of a concept, and}
\additemConcepts{the type of an associated function requirement.}
\end{itemize}

\pnum
\addedConcepts{For every concept requirement in a template's
requirements (including implied requirements), requirements for the 
refinements and associated requirements of the concept named by the
concept instance (\mbox{\ref{concept.refine}}, \mbox{\ref{concept.req}}) are
implied.}

\pnum 
\addedConcepts{The formation of types within the declaration of a
  constrained template implies the template requirements needed to
  ensure that the types themselves are well-formed within any
  instantiation. The following type constructions imply template
  requirements:}
\begin{itemize}
\additemConcepts{For every \mbox{\techterm{template-id} \tcode{X<A1,
      A2, ..., A$N$>}}, where 
\mbox{\tcode{X}} is a constrained template, the requirements of
\mbox{\tcode{X}} (after substitution of the
arguments \mbox{\tcode{A1}}, \mbox{\tcode{A2}}, ...,
\mbox{\tcode{A$N$}}) are implied.}
\enterexample\
\begin{codeblock}
template<LessThanComparable T> class set { /* ... */ };

template<CopyConstructible T>
void maybe_add_to_set(std::set<T>& s, const T& value); 
// use of std::set<T> implicitly adds requirement LessThanComparable<T>
\end{codeblock}
\exitexample\

\additemConcepts{If the formation of a type containing an archetype
  \mbox{\tcode{T}} will be ill-formed due to a missing requirement
  \mbox{\tcode{C<T>}}, where \mbox{\tcode{C}} is a compiler-supported
  concept (\mbox{\ref{concept.support}}), the requirement \mbox{\tcode{C<T>}} is
  implied. \mbox{\enterexample}}
\begin{codeblock}
concept C<typename T> { typename assoc; }

template<typename T>
requires C<T>
C<T>::assoc  // implies Returnable<C<T>::assoc>
f(T*, T&); // implies PointeeType<T> and ReferentType<T>
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\additemConcepts{For every \mbox{\techterm{qualified-id}} that names
  an associated type or class template, a concept requirement for the
  concept instance 
containing that associated type or class template is implied.
\mbox{\enterexample}}
\begin{codeblock}
concept Addable<typename T, typename U> {
  CopyConstructible result_type;
  result_type operator+(T, U);
}

template<CopyConstructible T, CopyConstructible U>
Addable<T, U>::result_type // implies Addable<T, U>
add(T t, U u) { 
  return t + u; 
}
\end{codeblock}

\additemConcepts{For every type archetype \mbox{\tcode{T}} that is the type
  of a parameter in a function type, the requirement
  \mbox{\tcode{MoveConstructible<T>}} is implied.}
\addedConcepts{\exitexample}

\end{itemize}

\pnum
\addedConcepts{In the definition of a}
\addedConcepts{constrained}
\addedConcepts{class template partial specialization, the
requirements of its primary class template (\mbox{\ref{temp.class.spec}}),
after substitution of the template arguments of the class template partial
specialization, are implied.}
\addedConcepts{If this substitution results
in a requirement that does not depend on any template parameter, then
the requirement must be satisfied (\mbox{\ref{temp.req}}); otherwise, the
program is ill-formed.
\mbox{\enterexample}}
\begin{codeblock}
template<typename T>
requires EqualityComparable<T>
class simple_set { };

template<std::ObjectType T>
class simple_set<T*> // implies \tcode{EqualityComparable<T*>}
{
};
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{The template requirements for two templates are \mbox{\techterm{identical}}
if they contain the same concept, negative, and
same-type requirements in arbitrary order. Two requirements are the
same if they have the same kind, name the same concept, and have the
same template argument lists.}

\rSec2[temp.archetype]{Archetypes}
\pnum
\addedConcepts{An \mbox{\techterm{archetype}} is a non-dependent
type, template, or value whose behavior is defined 
by the template requirements (\mbox{\ref{temp.req}}) of its constrained
template. Within a constrained context
  (\mbox{\ref{temp.constrained}}), a template parameter behaves as if it
were its archetype. \mbox{\enternote} this substitution of
archetypes (which are not dependent) for their corresponding
types, templates, or values (which would be dependent in an
unconstrained template)
effectively treats all types and templates (and therefore both
expressions and names) 
in a constrained context as ``non-dependent''. \mbox{\exitnote}}

\pnum
\addedConcepts{The archetype of a type is a type,
the archetype of a template is a class template, and the archetype of
a value is a value. }

\pnum
\addedConcepts{A type in a constrained }
 \changedCCC{template}{context} 
\addedConcepts{ aliases an archetype if it is:}
\begin{itemize}
\item \addedConcepts{a template type parameter (\mbox{\ref{temp.param}}),}
\item \addedConcepts{an associated type (\mbox{\ref{concept.assoc}}), or}
\item \addedConcepts{a class template specialization involving one or more
  archetypes.}
\end{itemize}

\pnum
\addedConcepts{A template in a constrained }
 \changedCCC{template}{context} 
\addedConcepts{ aliases an archetype if it is:}
\begin{itemize}
\additemConcepts{a template template parameter (\mbox{\ref{temp.param}}) or}
\additemConcepts{an associated class template (\mbox{\ref{concept.assoc}}).}
\end{itemize}

\pnum
\addedConcepts{A value in a constrained }
 \changedCCC{template}{context} 
\addedConcepts{ aliases an archetype if it is a
  \mbox{\techterm{constant-expression}} (\mbox{\ref{expr.const}})
  whose value depends on a template parameter.} 

\pnum 
\addedConcepts{If two types, \mbox{\tcode{T1}} and \mbox{\tcode{T2}},
  both alias archetypes and are 
the same (e.g., due to one or more same-type requirements
(\mbox{\ref{temp.req}})), then \mbox{\tcode{T1}} and \mbox{\tcode{T2}}
alias the same 
archetype \mbox{\tcode{T$'$}}. \mbox{\enternote} there is no
  mechanism to specify the relationships between different value
  archetypes, because such a mechanism would introduce the need for equational
  reasoning within the translation process. \mbox{\exitnote}}

\pnum
\addedConcepts{An archetype does not exist until it is
  \mbox{\techterm{established}}. 
  An archetype becomes established under the
  following circumstances:}
\begin{itemize}
\additemConcepts{a type that aliases the archetype has been used in the
    template argument list of a class template specialization or
    concept instance whose definition is required,}
\additemConcepts{a type that aliases the archetype is provided as an argument to a
  \mbox{\tcode{sizeof}} or \mbox{\tcode{alignof}} expression
  (\mbox{\ref{expr.sizeof}}, \mbox{\ref{expr.alignof}}),}
\additemConcepts{at the end of the function declarator in a function
  declaration in which one or more
  parameters use a type that aliases the archetype, or}
\additemConcepts{the archetype has been committed (described below).}
\end{itemize}

\pnum
\addedConcepts{If a same-type requirement attempts to make two types
  equivalent that both alias established archetypes but do not alias the
  same archetype, the program is ill-formed.}

\pnum 
\addedConcepts{A type archetype that has been \mbox{\techterm{committed}} has
  been defined as described below. Once an archetype has been
  committed, its definition can no longer be changed by the
  introduction of additional concept requirements. A program that
  specifies or implies concept requirements that use a committed
  archetype is ill-formed. An archetype is committed when:}
\begin{itemize}
\additemConcepts{the definition of the archetype is required, or}
\additemConcepts{name lookup finds an associated function with a parameter that uses
  a type that aliases the archetype.}
\end{itemize}

\pnum
\addedConcepts{In the declaration of a constrained member,  member
  template, or nested class, archetypes are established and committed
  as if it were the only member of its class. \mbox{\enternote} This
  means that members that come before the constrained member, member
  template, or nested class cannot prevent the expression of
  additional requirements on template parameters from enclosing
  scopes. \mbox{\exitnote} \mbox{\enterexample} Given:}
\color{ccadd}
\begin{codeblock}
concept C1<typename T> { }
concept C2<typename T> { }
concept C3<typename T> { }

template <C1 T> class X {
  requires C2<T> void g(T) {}
  class B {
    void g(T) {}
    requires C3<T> void f(T) {}
  };
};
\end{codeblock}

\noindent
\addedConcepts{\mbox{\tcode{X::g}} is evaluated as if in the context}

\begin{codeblock}
template <C1 T> class X {
  requires C2<T> void g(T) {}
};
\end{codeblock}

\noindent
\addedConcepts{and \mbox{\tcode{X::B::g}} is evaluated as if in the context}

\begin{codeblock}
template <C1 T> class X {
  class B {
    requires C3<T> void f(T) {}
  };
};
\end{codeblock} \addedConcepts{\mbox{\exitexample}}
\color{addclr}

\pnum
\addedConcepts{An archetype \mbox{\tcode{T$'$}} for a type
  \mbox{\tcode{T}} is}
\begin{itemize}
\additemConcepts{an object type ([intro.object]), if the template
  contains the requirement \mbox{\tcode{ObjectType<T>}},}
\additemConcepts{a class type (clause~\mbox{\ref{class}}), if the 
  template contains the requirement
  \mbox{\tcode{ClassType<T>}},}
\additemConcepts{a class (clause~\mbox{\ref{class}}), if the 
  template contains the requirement \mbox{\tcode{Class<T>}},}
\additemConcepts{a union ([class.union]), if the template contains
  the requirement \mbox{\tcode{Union<T>}}},
\additemConcepts{a trivial type (\mbox{\ref{basic.types}}), if the 
  template contains the requirement
  \mbox{\tcode{TrivialType<T>}},}
\additemConcepts{a standard layout type (\mbox{\ref{basic.types}}), if the
  template contains the requirement
  \mbox{\tcode{StandardLayoutType<T>}},}
\additemConcepts{a literal type (\mbox{\ref{basic.types}}), if the 
  template contains the requirement
  \mbox{\tcode{LiteralType<T>}},}
\additemConcepts{a scalar type (\mbox{\ref{basic.types}}), if the 
  template contains the requirement
  \mbox{\tcode{ScalarType<T>}},}
\additemConcepts{an integral type ([basic.fundamental]), if the 
  template contains the requirement
  \mbox{\tcode{IntegralType<T>}}, and}
\additemConcepts{an enumeration type ([dcl.enum]), if the template
  contains the requirement \mbox{\tcode{EnumerationType<T>}}.}
\end{itemize}

\pnum
\addedConcepts{The archetype \mbox{\tcode{T$'$}} of \mbox{\tcode{T}} contains a public member
function or member function template
corresponding to each member function or member function template of
each concept map archetype corresponding
to a concept 
requirement that names \mbox{\tcode{T}} (\mbox{\ref{temp.req}}).
\mbox{\enterexample}}
\begin{codeblock}
concept CopyConstructible<typename T> {
  T::T(const T&);
}

concept MemSwappable<typename T> {
  void T::swap(T&);
}

template<typename T>
requires CopyConstructible<T> && MemSwappable<T>
void foo(T& x) {
  // archetype T$'$ of $T$ contains a copy constructor T$'$::T$'$(const T$'$\&) from CopyConstructible<T>
  // and a member function void swap(T$'$\&) from MemSwappable<T>
  T y(x);
  y.swap(x);
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{If no requirement specifies a copy constructor for a type
\mbox{\tcode{T}}, a copy constructor is implicitly declared
(\mbox{\ref{class.copy}}) in the archetype of \mbox{\tcode{T}} with the following
signature:}
\begin{codeblock}
  T(const T&) = delete;
\end{codeblock}
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept DefaultConstructible<typename T> {
  T::T();
}

concept MoveConstructible<typename T> {
  T::T(T&&);
}

template<typename T>
requires DefaultConstructible<T> && MoveConstructible<T>
void f(T x) {
  T y = T(); // okay: move-constructs y from default-constructed T
  T z(x); // error: overload resolution selects implicitly-declared
          // copy constructor, which is deleted
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{If no requirement specifies a copy assignment operator for a type
\mbox{\tcode{T}}, a copy assignment operator is implicitly
declared (\mbox{\ref{class.copy}}) in the archetype of \mbox{\tcode{T}} with the
following signature:}
\begin{codeblock}
  T& T::operator=(const T&) = delete;
\end{codeblock}

\pnum
\addedConcepts{If no requirement specifies a destructor for a type \mbox{\tcode{T}},
a destructor is implicitly declared (\mbox{\ref{class.dtor}})
in the archetype of \mbox{\tcode{T}} with the following signature:}
\begin{codeblock}
  ~T() = delete;
\end{codeblock}

\pnum
\addedConcepts{If no requirement specifies a unary \mbox{\tcode{\&}} operator for a type
\mbox{\tcode{T}}, a unary member operator \mbox{\tcode{\&}} is implicitly declared in the
archetype of \mbox{\tcode{T}} for each \mbox{\techterm{cv}} that is a valid
\mbox{\techterm{cv-qualifier-seq}}:}
\begin{codeblock}
  @\techterm{cv}@ T* operator&() @\techterm{cv}@ = delete;
\end{codeblock}

\pnum 
\addedConcepts{For each of the allocation functions \mbox{\tcode{new}}, \mbox{\tcode{new[]}},
\mbox{\tcode{delete}}, and \mbox{\tcode{delete[]}} (\mbox{\ref{class.free}}), if no requirement
specifies the corresponding operator with a signature below, that
allocation function is
implicitly declared as a member function in the archetype \mbox{\tcode{T$'$}}
of \mbox{\tcode{T}} with the
corresponding signature from the following list:}
\begin{codeblock}
  static void* T@$'$@::operator new(std::size_t) = delete;
  static void* T@$'$@::operator new(std::size_t, void*) = delete;
  static void* T@$'$@::operator new(std::size_t, const std::nothrow_t&) throw() = delete;
  static void* T@$'$@::operator new[](std::size_t) = delete;
  static void* T@$'$@::operator new[](std::size_t, void*) = delete;
  static void* T@$'$@::operator new[](std::size_t, const std::nothrow_t&) throw() = delete;
  static void T@$'$@::operator delete(void*) = delete;
  static void T@$'$@::operator delete(void*, void*) = delete;
  static void T@$'$@::operator delete(void*, const std::nothrow_t&) throw() = delete;
  static void T@$'$@::operator delete[](void*) = delete;
  static void T@$'$@::operator delete[](void*, void*) = delete;
  static void T@$'$@::operator delete[](void*, const std::nothrow_t&) throw() = delete; 
\end{codeblock}

\pnum
\addedConcepts{If the template requirements contain a requirement
\mbox{\tcode{DerivedFrom<T, Base>}}, then the archetype of
\mbox{\tcode{T}} is publicly derived from the archetype of \mbox{\tcode{Base}}. 
If the same \mbox{\tcode{DerivedFrom<T, Base>}} requirement occurs more than once
within the template requirements, the repeated \mbox{\tcode{DerivedFrom<T,
  Base>}} requirements are ignored.}

\pnum
\addedConcepts{If two associated member function or member function template
requirements that name a constructor or destructor for a type
\mbox{\tcode{T}} have the same signature, the duplicate signature is ignored.}

\pnum
\addedConcepts{If a class template specialization is
an archetype that does not appear as a template argument of any
explicitly-specified requirement in the template requirements and
whose template is not itself an archetype, then the archetype is an 
instantiated archetype. An \mbox{\techterm{instantiated archetype}} is
an archetype whose definition is provided by the instantiation of its
template with its template arguments (which involve archetypes).
The template shall not be an unconstrained
template. \mbox{\enternote} Partial ordering of class
template partial specializations (\mbox{\ref{temp.class.order}}) will depend
on the properties of the archetypes, as defined by the requirements
of the constrained template. When the constrained template is
instantiated (\mbox{\ref{temp.constrained.inst}}),  partial ordering of class
template partial specializations will occur a second time based on the
actual template arguments. \mbox{\exitnote} \mbox{\enterexample}}
\begin{codeblock}
template<EqualityComparable T>
struct simple_multiset {
  bool includes(const T&);
  void insert(const T&);
  // ...
};

template<LessThanComparable T>
struct simple_multiset<T> { // A
  bool includes(const T&);
  void insert(const T&);
  // ...
};

template<LessThanComparable T>
bool first_access(const T& x) {
  static simple_multiset<T> set; // instantiates \tcode{simple_multiset<T$'$>}, where \tcode{T$'$} is the archetype of \tcode{T} ,
                                 // from the partial specialization of simple_multiset marked 'A'
  return set.includes(x)? false : (set.insert(x), true);
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\addedConcepts{\mbox{\enternote} Class template specializations for which
  template requirements are specified behave as normal
  archetypes. \mbox{\exitnote} \mbox{\enterexample}}
\begin{codeblock}
auto concept CopyConstructible<typename T> {
  T::T(const T&);
}

template<CopyConstructible T> struct vector;

auto concept VectorLike<typename X> {
  typename value_type = typename X::value_type;
  X::X();
  void X::push_back(const value_type&);
  value_type& X::front();
}

template<CopyConstructible T>
requires VectorLike<vector<T>> // vector<T> is an archetype (but not an instantiated archetype)
void f(const T& value) {
  vector<T> x; // okay: default constructor in VectorLike<vector<T> >
  x.push_back(value); // okay: push_back in VectorLike<vector<T> >
  VectorLike<vector<T>>::value_type& val = x.front(); // okay: front in VectorLike<vector<T>>
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\pnum
\addedConcepts{\mbox{\enternote} Constrained class templates involving
  recursive definitions are ill-formed if the recursive class template
  specialization is an instantiated archetype. Constrained class
  templates involving recursive definitions can be specified by
  adding template requirements on the recursive class template
  specializations, making them archetypes that are not instantiated
  archetypes. \mbox{\enterexample}}
\begin{codeblock}
template<CopyConstructible... T> class tuple;

template<CopyConstructible Head, CopyConstructible... Tail>
class tuple<Head, Tail...> : tuple<Tail...> // ill-formed: tuple<Tail...> is an instantiated archetype, 
                                            // but it is an incomplete type
{
  Head head;
  // ...
};

template<> class tuple<> { /* ... */ };

\end{codeblock}
\addedConcepts{\mbox{\exitexample\exitnote}}

\pnum
\addedConcepts{In a constrained context, for each concept requirement
that is stated in or implied by the corresponding requirements,
a \mbox{\techterm{concept map archetype}} for that
requirement is synthesized by 
substituting the archetype of \mbox{\tcode{T}} for each occurrence of
\mbox{\tcode{T}} within the template arguments of the requirement. The
concept map archetype acts as a concept
map, and is used to resolve name 
lookup into
requirements scope (\mbox{\ref{basic.scope.req}}) and satisfy the
requirements of templates used inside the constrained context.}
%
\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
concept SignedIntegral<typename T> {
  T::T(const T&);
  T operator-(T);
}
concept RandomAccessIterator<typename T> {
  SignedIntegral difference_type;
  difference_type operator-(T, T);
}
template<SignedIntegral T> T negate(const T& t) { return -t; }

template<RandomAccessIterator Iter>
RandomAccessIterator<Iter>::difference_type distance(Iter f, Iter l) {
  typedef RandomAccessIterator<Iter>::difference_type D;
  D dist = f - l;  // okay: - operator resolves to synthesized operator- in
                  // the concept map archetype RandomAccessIterator<Iter$'$>,  
                  // where Iter$'$ is the archetype of Iter
  return negate(dist); // okay, concept map archetype RandomAccessIterator<Iter$'$>
                       // implies the concept map archetype SignedIntegral<D$'$>,
                       // where D$'$ is the archetype of D}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}

\rSec2[temp.constrained.set]{Candidate sets}
\pnum
\addedConcepts{A \mbox{\techterm{candidate set}} is a set containing
  functions and function templates that is defined in a constrained 
}
\changedCCC{template }{context}
\addedConcepts{
   (a \mbox{\techterm{retained}} \mbox{\techterm{candidate
      set}},~\mbox{\ref{temp.constrained.inst}}) or as the result of
  satisfying an associated function requirement in a concept map (an
  \mbox{\techterm{associated}} \mbox{\techterm{function}} \mbox{\techterm{candidate
      set}},~\mbox{\ref{concept.map.fct}}). Candidate sets are used to
  capture a set of candidate functions that will be used in the
  instantiation of a constrained template
  (\mbox{\ref{temp.constrained.inst}}) or when referring to members in
  a concept map (\mbox{\ref{concept.map}}). \mbox{\enternote} For the
  purposes of this section, candidate operator functions 
  (\mbox{\ref{over.built}}) are considered functions. \exitnote}

\pnum
\addedConcepts{Each candidate set has a \mbox{\techterm{seed}},
  which provides the basis for the candidate set itself. All 
  functions and function templates that are consistent
  with the seed are contained in the candidate set. The seed is
  determined as part of the definition of 
  the candidate set, and will be one of:} 
\begin{itemize}
\additemConcepts{a function,}
\additemConcepts{the initialization of an object (\mbox{\ref{dcl.init}}), or}
\additemConcepts{a \mbox{\techterm{pseudo-destructor-name}}
  (\mbox{\ref{expr.pseudo}}).}
\end{itemize}

\pnum 
\addedConcepts{A function is \mbox{\techterm{consistent with}} the seed if}
\begin{itemize}
\item \addedConcepts{it has the same name as the seed,}
\item \addedConcepts{its enclosing namespace is the same as the enclosing
    namespace of the seed,}
\item \addedConcepts{the seed has a return type of \mbox{\techterm{cv}
      \tcode{void}} or the function has the same return type as the seed, after the
    reference (if any) 
    and then top-level \mbox{\techterm{cv-qualifiers}} (if any) have been
    removed from the return types of the seed and the function, and}
\additemConcepts{it has the same \mbox{\techterm{parameter-type-list}} as
  the seed, after making the following adjustments to both
  \mbox{\techterm{parameter-type-list}}s:} 
\begin{itemize}
  \additemConcepts{for a non-static member function, add the implicit
    object parameter (\mbox{\ref{over.match.funcs}}) as the first
    parameter in the \mbox{\techterm{parameter-type-list}},}
  \additemConcepts{for each parameter type, remove the top-level reference
    (if any) and then top-level \mbox{\techterm{cv-qualifiers}} (if
    any),} 
  \additemConcepts{if the function has \mbox{$M$} parameters, the seed has
    \mbox{$N$} parameters, and \mbox{$M > N$}, remove each of the last
    \mbox{$M-N$} parameters that has a default argument from the
    \mbox{\techterm{parameter-type-list}}, and}
  \additemConcepts{remove the ellipsis, if any.}
\end{itemize}
\end{itemize}
\addedConcepts{\enternote No function or function template is consistent
  with a non-function seed. A seed that is a function is consistent
  with itself. \exitnote}

\pnum
\addedConcepts{A function template is consistent with the seed if: }
\begin{itemize}
\additemConcepts{it has the same name as the seed, and}
\additemConcepts{its enclosing namespace is the same as the enclosing
    namespace of the seed.}
\end{itemize}

\pnum
\addedConcepts{A candidate set is a set of overloaded
  functions. Overload resolution (\mbox{\ref{over.match}}) for a
  candidate set is subject to the following additional conditions:}
\begin{itemize}
\item
\addedConcepts{the set of candidate functions for overload resolution is the
set of functions in the candidate set, and}

\item
\addedConcepts{if template argument deduction on a candidate function
  produces a function template specialization that is not consistent
  with the seed of the candidate set, the function template
  specialization is not a viable function
  (\mbox{\ref{over.match.viable}}).}
\end{itemize}

\rSec2[temp.constrained.inst]{Instantiation of constrained templates}
\pnum
\addedConcepts{Instantiation of a constrained template replaces each template
parameter within the definition of the template with its corresponding
template argument, using the same process as for unconstrained
templates (\mbox{\ref{temp.spec}}).}

\pnum
\addedConcepts{Instantiation of a constrained template also replaces each 
concept map archetype with
the concept map that satisfied the corresponding template
requirement.  
\mbox{\enternote} A concept member that had resolved to a member of a
concept map archetype now refers to a
member of the corresponding concept map. \mbox{\exitnote}}

\pnum
\addedConcepts{In the instantiation of a constrained template, a call
  to a function that resolves to an associated
  function in a concept map archetype (\mbox{\ref{temp.archetype}})
  will be instantiated as a call to the associated function candidate set
  (\mbox{\ref{temp.constrained.set}}) that satisfies the
  corresponding associated function requirement in the concept map
  that replaces the concept map archetype. \mbox{\enterexample}} 
\begin{codeblock}
concept F<typename T> {
  T::T();
  void f(T const&);
}

template<typename T> requires F<T>
void g(T const& x) {
  f(x);    // calls F<T>::f. When instantiated with T=X, calls \#1
  f(T());  // calls F<T>::f. When instantiated with T=X, calls \#2
}

struct X {};
void f(X const&); // \#1
void f(X&&); // \#2 

concept_map F<X> { } // associated function candidate set for f(X const\&) contains \#1 and \#2, seed is \#1

void h(X const& x) {
  g(x);
}
\end{codeblock}
\exitexample\

\pnum
\addedConcepts{A function template specialization in a constrained
  template instantiates to a reference to that function template
  specialization's retained candidate set. The
  \mbox{\techterm{retained candidate set}} is a candidate set
  (\mbox{\ref{temp.constrained.set}}) whose seed is determined by the
  function template specialization from the definition of the
  constrained template, after substitution of the constrained
  template's template arguments for their corresponding template
  parameters. \mbox{\enterexample}}
\begin{codeblock}
concept InputIterator<typename Iter> { 
  typename difference_type;
}
concept BidirectionalIterator<typename Iter> : InputIterator<Iter> { }
concept RandomAccessIterator<typename Iter> : BidirectionalIterator<Iter> { }

template<InputIterator Iter> void advance(Iter& i, Iter::difference_type n); // \#1
template<BidirectionalIterator Iter> void advance(Iter& i, Iter::difference_type n); // \#2

template<BidirectionalIterator Iter> void f(Iter i) {
  advance(i, 1); // seed function is \#2
}

concept_map RandomAccessIterator<int*> { 
  typedef std::ptrdiff_t difference_type;
}

template<RandomAccessIterator Iter> void advance(Iter& i, Iter::difference_type n); // \#3

void g(int* i) {
  f(i); // in the call to advance(), \#1 is the seed of the retained candidate set, the retained candidate set contains \#1, \#2, 
        // and \#3, and partial ordering of function templates selects \#3.
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}\mbox{\exitnote}}

\pnum
\addedConcepts{In the instantiation of a constrained template, a template
specialization whose template arguments involve the constrained
template's template parameters
(\mbox{\ref{temp.archetype}}) will be replaced by the
  template specialization
that results from substituting the constrained template's template
arguments for their corresponding template parameters.
\mbox{\enternote} If the template specialization is a
  template alias (\mbox{\ref{temp.alias}}), the substitution will occur
  in the \mbox{\techterm{type-id}} of the template alias. \mbox{\exitnote}}
\addedConcepts{The resulting type (call it \mbox{\tcode{A}}) 
shall be compatible with the type involving
the template parameters (call it \mbox{\tcode{A$'$}}) that it
replaced, otherwise the program is ill-formed. The template
specializations are compatible if all of the following conditions hold:}
\begin{itemize}
\item \addedConcepts{for each function, function template, or data member \mbox{\tcode{m}} of
  \mbox{\tcode{A$'$}} referenced 
  by the constrained template, there exists a member named
  \mbox{\tcode{m}} in \mbox{\tcode{A}} that is accessible from the constrained
  template and whose type, storage specifiers, template parameters (if
  any), and template requirements (if any) are the same as the
  those of 
  \mbox{\tcode{A$'$::m}} after substituting the constrained
  template's template arguments for the corresponding template parameters,}

\item \addedConcepts{for each member type \mbox{\tcode{t}} of \mbox{\tcode{A$'$}} referenced 
  by the constrained template, there exists a member type \mbox{\tcode{t}} in
  \mbox{\tcode{A}} that is accessible from the constrained
  template and is compatible with the member type
    \mbox{\tcode{A$'$::t}} as specified herein, and}

\item \addedConcepts{for each base class \mbox{\tcode{B}$'$ of \tcode{A$'$}} referenced
  by a derived-to-base conversion (\mbox{\ref{conv.ptr}}) in the constrained
  template, there exists an unambiguous base class 
  \mbox{\tcode{B}} of \mbox{\tcode{A}} that is accessible from the constrained
  template, where \mbox{\tcode{B}} is the type produced by
  substituting the constrained 
    template's template parameters with the corresponding template arguments
in \mbox{\tcode{B}$'$}.}
\end{itemize}

\addedConcepts{\mbox{\enterexample}}
\begin{codeblock}
auto concept CopyConstructible<typename T> {
  T::T(const T&);
@\textcolor{addclr}{}@}

template<CopyConstructible T> 
struct vector { // A
  vector(int, T const &);
  T& front();
};

template<typename T> 
struct vector<T*> { // B
  vector(int, T* const &);
  T*& front();
};

template<>
struct vector<bool> { // C
  vector(int, bool);
  bool front();
};

template<CopyConstructible T>
void f(const T& x) {
  vector<T> vec(1, x);
  T& ref = vec.front();
@\textcolor{addclr}{}@}

void g(int i, int* ip, bool b) {
  f(i); // okay: instantiation of f<int> uses vector<int>, instantiated from A
  f(ip); // okay: instantiation of f<int*> uses vector<int*>, instantiated from B
  f(b); // ill-formed, detected in the instantiation of f<bool>, which uses the vector<bool> specialization C:
        // vector<bool>::front is not compatible with vector<T>::front (where T=bool)
@\textcolor{addclr}{}@}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}
\color{black}
\end{paras}

\appendix
\setcounter{chapter}{1}
\infannex{implimits}{Implementation quantities}

\begin{paras}

\editorial{Add the following bullet to paragraph 2}:
\begin{itemize}
\item%
\addedConcepts{Recursively nested implicit concept map definitions [1024]}
\end{itemize}
\end{paras}

\section*{Acknowledgments}
The effort to introduce concepts into \Cpp{} has been shaped by
many. The authors of the ``Indiana'' and ``Texas'' concepts proposals
have had the most direct impact on concepts: Gabriel Dos~Reis, Ronald
Garcia, Jaakko J\"arvi, Andrew Lumsdaine, Jeremy Siek, and Jeremiah
Willcock. Other major contributors to the introduction of concepts in
\Cpp{} include David Abrahams, Matthew Austern, Mat Marcus, David
Musser, Sean Parent, Sibylle Schupp, Alexander Stepanov, and Marcin
Zalewski.
%
Howard Hinnant helped introduce support for rvalue references.
%
Stephen Adamczyk, Daniel Kr\"ugler, Jens Maurer, John Spicer, and James
Widman provided extremely
detailed feedback on various drafts and prior revisions of this
wording, and the wording itself has benefited greatly from their
efforts and the efforts of the \Cpp{} committee's Core Working Group. 

\bibliographystyle{abbrv}
\bibliography{local}

\end{document}

Look into this issue from Dave Musser:

The following concept definitions are added to concepts.h: 
auto __concept UnderlyingType<typename T> { 
typename _underlying_type = T::_underlying_type; 
__where DefaultConstructible<_underlying_type>; 
} 
auto __concept Movable<typename T> 
{ 
__where UnderlyingType<T>; 
void _save_raw(T&, UnderlyingType<T>::_underlying_type&); 
void _move_raw(T&, T&); 
void _restore_raw(UnderlyingType<T>::_underlying_type&, T&); 
}
In [7], the identifier move raw is overloaded to name all three of these operations, but 
early experiments with this approach resulted in compilation errors-reports of ambi- 
guities stemming from multiple ways of satisfying the Movable concept in cases where 
the underlying type was the type itself. Whether this problem could be solved by an 
alternative way of defining or using the Movable concept remains to be investigated. 


Disembodied examples:

\mbox{\enterexample}
\begin{codeblock}
concept C<typename X> {
  void f(X const&);
}

struct Y {};
concept_map C<Y> {
  void f(Y const&) { } // okay: matches required signature void f(Y const\&)
}

concept_map C<int> {
  void f(int) { } // error: does not match required signature void f(int const\&)
}
\end{codeblock} 
\exitexample\


\enterexample\
\begin{codeblock}
concept InputIterator<typename Iter> {
  typename value_type;
  // ...
}

concept C<typename X> {
  typename value_type;

  template<InputIterator Iter>  
    requires Convertible<Iter::value_type, value_type>
    void assign(X&, Iter first, Iter last); // \#1
}

concept_map C<MyContainer> {
  typedef int value_type;

  template<InputIterator Iter>  
    requires Convertible<Iter::value_type, int>
    void assign(MyContainer&, Iter first, Iter last) 
    { ... } // matches \#1
}
\end{codeblock}
\exitexample\

\mbox{\enterexample}
\begin{codeblock}
concept Swappable<typename T> {
  void T::swap(T&);
}

struct X { };

concept_map Swappable<X> {
  void X::swap(X& other) { /* ... */ }
}
\end{codeblock}
\addedConcepts{\mbox{\exitexample}}
