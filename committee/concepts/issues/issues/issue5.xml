<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="5" status="New">
<title>Inconsistent naming between concepts and type traits</title>
<section><sref ref="[utility.concepts]"/></section>
<submitter>LWG</submitter>
<date>27 Feb 2008</date>

<discussion>
<p>General issue: many of these core concepts, including
  <tt>CopyConstructible</tt>, <tt>TriviallyCopyConstructible</tt>,
and <tt>ObjectType</tt>, mirror existing type traits
names. Essentially, type traits are a mechanism used in unconstrained
templates and concepts express something very similar in constrained
code. We should consider a uniform naming convention, in places where
the correspondence exists, to make the connection clearer. This is one
  motivation for using Has* and Is* uniformly.
</p>
</discussion>

<resolution>
  <p>The table provides the proposed mapping between type traits and concepts.</p>
  <table border="1">
    <tr>
      <th bgcolor="#ffffcc">Type trait</th>
      <th bgcolor="#ffffcc">Concept</th>
    </tr>
    <tr>
      <td><code>is_void</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_integral</code></td>
      <td><code>IntegralType</code></td>
    </tr>
    <tr>
      <td><code>is_floating_point</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_array</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_pointer</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_lvalue_reference</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_rvalue_reference</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_member_object_pointer</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_member_function_pointer</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_enum</code></td>
      <td><code>EnumerationType</code></td>
    </tr>
    <tr>
      <td><code>is_union</code></td>
      <td><code>Union</code></td>
    </tr>
    <tr>
      <td><code>is_class</code></td>
      <td><code>Class</code></td>
    </tr>
    <tr>
      <td><code>is_function</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_reference</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_arithmetic</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_fundamental</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_object</code></td>
      <td><code>ObjectType</code></td>
    </tr>
    <tr>
      <td><code>is_scalar</code></td>
      <td><code>ScalarType</code></td>
    </tr>
    <tr>
      <td><code>is_compound</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_member_pointer</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_const</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_volatile</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_trivial</code></td>
      <td><code>TrivialType</code></td>
    </tr>
    <tr>
      <td><code>is_standard_layout</code></td>
      <td><code>StandardLayoutType</code></td>
    </tr>
    <tr>
      <td><code>is_pod</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_empty</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_polymorphic</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_abstract</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>has_trivial_default_constructor</code></td>
      <td><code>TriviallyDefaultConstructible</code></td>
    </tr>
    <tr>
      <td><code>has_trivial_copy_constructor</code></td>
      <td><code>TriviallyCopyConstructible</code></td>
    </tr>
    <tr>
      <td><code>has_trivial_assign</code></td>
      <td><code>TriviallyCopyAssignable</code></td>
    </tr>
    <tr>
      <td><code>has_trivial_destructor</code></td>
      <td><code>TriviallyDestructible</code></td>
    </tr>
    <tr>
      <td><code>has_nothrow_default_constructor</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>has_nothrow_copy_constructor</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>has_nothrow_assign</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>has_virtual_destructor</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_signed</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_unsigned</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>alignment_of</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>rank</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>extend</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code>is_same</code></td>
      <td><code>SameType</code></td>
    </tr>
    <tr>
      <td><code>is_base_of</code></td>
      <td><code>DerivedFrom</code></td>
    </tr>
    <tr>
      <td><code>is_convertible</code></td>
      <td><code>Convertible</code></td>
    </tr>
    <tr>
      <td bgcolor="#ffffcc" colspan="2" align="center">Transformation/modification traits don't make sense with concepts</td>
    </tr>
  </table>
</resolution>

</issue>
