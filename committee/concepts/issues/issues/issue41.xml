<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="41" status="New">
<title><code>MoveConstructible</code> constructor should be <code>explicit</code></title>
<section><sref ref="[concept.copymove]"/></section>
<submitter>LWG</submitter>
<date>9 Jun 2008</date>

<discussion>
  <p>Users are permitted to use types with explicit copy and move
  constructors with the C++98 standard library. To support this use
  case with concepts, the constructor requirements
  in <code>MoveConstructible</code> and <code>CopyConstructible</code>
  need to be <code>explicit</code>.</p>
</discussion>

<resolution>
  <p>Modify [concept.copymove] paragraphs 1-3 as follows:</p>
  <pre>
auto concept MoveConstructible&lt;typename T&gt; <del>: HasConstructor&lt;T, T&amp;&amp;&gt;</del> { 
  <ins>explicit T::T(T&amp;&amp);</ins>
}
  </pre>
  <ol>
    <li><i>Note</i>: describes types that can move-construct an object
    from a value of the same type, possibly altering that value.</li>
  </ol>
  <pre>
T::T(T&amp;&amp; rv); <del>// note: inherited from HasConstructor&lt;T, T&amp;&amp;&gt;</del>
  </pre>
  <ol start="2">
    <li><i>Postcondition</i>: the constructed <code>T</code> object is equivalent to the value of <code>rv</code> before the construction. [ <i>Note</i>: there is no 
      requirement on the value of <code>rv</code> after the construction. - <i>end note</i> ]</li>
  </ol>

  <pre>
auto concept CopyConstructible&lt;typename T&gt; : MoveConstructible&lt;T&gt;<del>, HasConstructor&lt;T, const T&amp;</del>&gt; { 
  <ins>T::T(const T&amp;);</ins>

  axiom CopyPreservation(T x) { 
    T(x) == x; 
  } 
}
  </pre>
</resolution>
</issue>
