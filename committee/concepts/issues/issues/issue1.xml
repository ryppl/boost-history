<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="1" status="WP">
  <title>Naming and symmetry in EqualityComparable</title> 
  <section><sref ref="[concept.comparison]"/></section>
  <submitter>LWG</submitter>
  <date>27 Feb 2008</date>

  <discussion>
    <p>Another way to characterize the problem with EqualityComparable:
    the name suggests that it's a concept with semantics, one that's
    based on some kind of mathematical notion. At the Bloomington
    discussion there was a different naming convention for concepts
    that are purely syntactic; e.g. HasPlus, as opposed to "Addable",
    for a concept that doesn't mean anything more than that a +
    exists. The two-parameter EqualityComparable really falls into
    that category, since all it really means is that there's some kind
    of operation spelled == and we're not saying what it does. The
    one-parameter version of EqualityComparable really is
      EqualityComparable, though, and it does have mathematical axioms.</p>

    <p>General issue: do we accept the naming convention that purely
      syntactic concepts should be named Has*?</p>

    <p>If we do have a two-parameter HasEqualTo, do we also want it to
      provide != ? In other words, does it have any kind of semantic
      coherency?  </p>

    <p>Can we make the two-parameter HasEqualTo symmetrical? That is:
      if we say that there is a HasEqualTo for types T and U, and if t
      and u are variables of the appropriate types, can we at least
      say that t == u and u == t are both allowed and both mean the
      same thing? Is there any way to write defaults in the concept
      definition that won't ever give us an infinite loop?</p>
  </discussion>

  <resolution>
    <p>Split the <code>EqualityComparable</code>
    and <code>LessThanComparable</code> concepts into purely syntactic
    concepts (<code>HasEqualTo</code>, <code>HasLessThan</code>) and
    semantic concepts that refine them
    (<code>EqualityComparable</code>, <code>LessThanComparable</code>). In
    [utility.concepts], update the &lt;concepts&gt; header synopsis as
    follows:
      <pre>
<i>// 20.1.2, comparisons:</i>
auto concept LessThanComparable&lt;typename T<del>, typename U = T</del>&gt; <i>see below</i>;
auto concept EqualityComparable&lt;typename T<del>, typename U = T</del>&gt; <i>see below</i>;
auto concept TriviallyEqualityComparable&lt;typename T&gt; <i>see below</i>; 

<i>...</i>
<i>// 20.1.10, operator concepts:</i>
<i>...</i>

auto concept HasNegate&lt;typename T&gt; <i>see below</i>;
<ins>auto concept HasLess&lt;typename T, typename U = T&gt; <i>see below</i>;</ins>
<ins>auto concept HasEqualTo&lt;typename T, typename U = T&gt; <i>see below</i>;</ins>
auto concept HasLogicalAnd&lt;typename T, typename U = T&gt; <i>see below</i>;
      </pre>
    </p>
    
    <p>Change [concept.comparison] paragraph 1 as follows:
    <pre>
auto concept LessThanComparable&lt;typename T<del>, typename U = T</del>&gt;<ins> : HasLess&lt;T&gt;</ins> { 
  <del>bool operator&lt;(T const&amp; a, U const&amp; b);</del>
  bool operator&gt;(<del>U</del><ins>T</ins> const&amp; a, T const&amp; b) { return b &lt; a; } 
  bool operator&lt;=(<del>U</del><ins>T</ins> const&amp; a, T const&amp; b) { return !(b &lt; a); } 
  bool operator&gt;=(T const&amp; a, <del>U</del><ins>T</ins> const&amp; b) { return !(a &lt; b); } 

  <ins>axiom Consistency(T a, T b) {
    (a &gt; b) == (b &lt; a);
    (a &lt;= b) == !(b &lt; a);
    (a &gt;= b) == !(a &lt; b);
  }

  axiom Irreflexivity(T a) { (a &lt; a) == false; }

  axiom Antisymmetry(T a, T b) { 
    if (a &lt; b) (b &lt; a) == false;
  }

  axiom Transitivity(T a, T b, T c) {
    if (a &lt; b &amp;&amp; b &lt; c) (a &lt; c) == true;
  }

  axiom TransitivityOfEquivalence(T a, T b, T c) {
    if (!(a &lt; b) &amp;&amp; !(b &lt; a) &amp;&amp; !(b &lt; c) &amp;&amp; !(c &lt; b))
      (!(a &lt; c) &amp;&amp; !(c &lt; a)) == true;
  }</ins> 
}
    </pre>
<ol>
  <li>&nbsp;&nbsp;&nbsp;&nbsp;<i>Note</i>: describes types whose
      values can be ordered<del> via an inequality operator</del><ins>, where <code>operator&lt;</code> is a strict weak ordering relation ([alg.sorting])</ins>.</li>

  <li>&nbsp;&nbsp;&nbsp;&nbsp;<del><i>Requires</i>: <code>operator&lt;</code> is a strict weak ordering relation ([alg.sorting]).</del></li>
</ol>
</p>

    <p>Change [concept.comparison] paragraphs 3 and 4 as follows:
      <pre>
auto concept EqualityComparable&lt;typename T<del>, typename U = T</del>&gt;<ins> : HasEqualTo&lt;T&gt;</ins> { 
 <del>bool operator==(T const&amp; a, U const&amp; b);</del> 
 bool operator!=(T const&amp; a, <del>U</del><ins>T</ins> const&amp; b) { return !(a == b); } 

  <ins>axiom Consistency(T a, T b) {
    (a == b) == !(a != b);
  }

  axiom Reflexivity(T a) { a == a; }

  axiom Symmetry(T a, T b) { if (a == b) b == a; }

  axiom Transitivity(T a, T b, T c) {
    if (a == b &amp;&amp; b == c) a == c;
  }</ins>
}
      </pre>
<ol start="3">
  <li>&nbsp;&nbsp;&nbsp;&nbsp;<i>Note</i>: describes types whose
    values can be compared for equality with <code>operator==</code><ins>, which is an equivalence relation</ins>.</li>

  <li>&nbsp;&nbsp;&nbsp;&nbsp;<del><i>Requires</i>: when <code>T</code> and <code>U</code> are identical, <code>operator==</code> is an equivalence relation that is, it has the following properties:</del>
      <ul>
        <li><del>For all a, a == a.</del></li>
        <li><del>If a == b, then b == a.</del></li>
        <li><del>If a == b and b == c, then a == c.</del></li>
      </ul>
  </li>
</ol>
    </p>

    <p>Add to [concept.operator]:
      <pre>
<ins>auto concept HasLess&lt; typename T, typename U = T&gt; {
  bool operator&lt;(const T&amp; a, const U&amp; b);
}</ins>
      </pre>
      <ol start="8">
        <li>&nbsp;&nbsp;&nbsp;&nbsp;<ins><i>Note</i>: describes types with an <code>operator&lt;</code></ins></li>
      </ol>

      <pre>
<ins>auto concept HasEqualTo&lt; typename T, typename U = T&gt; {
  bool operator==(const T&amp; a, const U&amp; b);
}</ins>
      </pre>
      <ol start="9">
        <li>&nbsp;&nbsp;&nbsp;&nbsp;<ins><i>Note</i>: describes types with an <code>operator==</code></ins></li>
      </ol>
    </p>

    <p>Note that this change also requires renaming two-parameter uses
    of <code>EqualityComparable</code>
    and <code>LessThanComparable</code> to <code>HasEqualTo</code>
    and <code>HasLess</code>, respectively.</p>
  </resolution>
</issue>
