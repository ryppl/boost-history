

* Docs: The simplified syntax removes the function name repetition. However, to supoprt recursion (and nesting) the body cannot be static (to access the member functor variable with the local function name defined by the NAME macro). Therefore the limitation that no compiler error if `this` is used instead of `this_` as a pointer within the body (if not used as pointer, compiler will most likely error because `this` is the functor which has a rather different structure than the user's object `this_`).

* Docs: `inline` does not apply to local function which are already inlined (because they are defined where they are declared).

* Docs: PARAMS cannot appear on same line because they use __LINE__ to generate unique IDs (there's no way around this because this macro doesn't know the function name).

* Docs: `this` can never be bound by ref (as usual in C++).

* Docs: If `, default ...` syntax seems strange for C99, programmers can always use `#define WITH_DEFAULT(x) , default x` or similar macro instead.

* Docs: Add D-Stype Scope Guards examples to docs.

* Docs: Document that nesting is (now) possible.


* Code: Optimize macro expansion code for C++0x, C++03, etc. From John Bytheway:
> Yes, in C++0x local structs can be passed as template parameters.
> Obviously, in C++0x there are lambdas too, so you might think your
> library is useless, but I'd expect most compilers to support passing
> local structs as template parameters before they support lambdas, so
> there is some advantage in having this intermediate implementation.
> Also, your macros would allow writing code that worked in C++0x and
> C++03, with the virtual function business in only those compilers/modes
> where it is necessary.


