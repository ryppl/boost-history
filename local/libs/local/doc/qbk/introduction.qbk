
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the ]
[/ Boost Software License, Version 1.0 ]
[/ (see accompanying file LICENSE_1_0.txt or a copy at ]
[/ http://www.boost.org/LICENSE_1_0.txt). ]

[section:Introduction Introduction]

/Local functions/ are a form of /information hiding/ and are useful for dividing procedural tasks into subtasks which are only meaningful locally, avoiding cluttering other parts of the program with functions, variables, etc unrelated to those parts.
Local functions therefore complement other structuring possibilities such as namespaces and classes.
Local functions are a feature of many programming languages, notably [@http://en.wikipedia.org/wiki/Nested_function#An_example Pascal] and [@http://en.wikipedia.org/wiki/Nesting_(computing)#In_programming Ada], yet lacking from C++ (see also __N2511__).

This library supports the following features for local functions (see the __Alternatives__ section for a comparison between this library and features offered by C++ local class members, __CPP0x_lambda__ functions, __Boost_Lambda__, __Boost_Phoenix__, and __Boost_ScopeExit__):

* Local functions can access, or better [@http://en.wikipedia.org/wiki/Name_binding /bind/], any of the variables from the enclosing scope.
Furthermore, local functions defined within a member function can bind the enclosing object `this`.
* The local function body is programmed using the usual C++ syntax.
* Local functions can be passed as template parameters (so they can be conveniently passed to STL algorithms, etc).
* However, local functions must be defined within a declarative context (e.g., at a point in the code where local variables can be declared) thus they cannot be defined within an expression.

In addition to local functions, this library also supports the following features:

* /Local blocks/ which define blocks of code that bind variables from the enclosing scope.
Local blocks allow programmers to bind variables as constants (/constant binding/) so to prevent local chunks of code from modifying selected variables.
* /Local exits/ which define blocks of code that are executed when the enclosing scope is exited (again with support for constant binding and binding of the object `this`).

[h5 An Example]

The following example illustrates a simple use of this library and it starts introducing the library API (see the __Tutorial__ section for more details on how to use this library):

* A local function is passed to the STL `std::for_each` algorithm to add together the values of an array.
Variables in scope are bound to the local function by both constant value and non-constant reference.
* A local exit is used to automatically release the array's memory at scope exit.
* A local block is used to assert the correct final value of the summation in a constant-correct context (therefore preventing the assertion from mistakenly changing any of the variables in scope).

[table
[ [Notes] [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [ [add_callouts_cpp] ] [ [add_va_cpp] ] [ [add_cpp] ] ]
]

Where the notes refer to the following comments:

# Include the header files for this library local functions, local blocks, and local exits.
# The *local function* parameter macro takes a __Boost_Preprocessor__ sequence of tokens listing each parameter type and name wrapped within round parenthesis [^(['parameter-type parameter-name])['...]] (default parameter values can also specified using a special syntax, see the __Tutorial__ section).
On C99 and later preprocessors which support variadic macros, the same parameter macro also allows to specify the parameters separated by commas instead that wrapped within parenthesis [^['parameter-type parameter-name],['...]] so to provide a syntax more similar to the normal C++ syntax for function parameter lists.
The local function result type is specified just before the parameter macro.
# This library macros introduce the special "keyword" `bind` which can be used instead of the parameter type to bind variables in scope.
Variables can be bound by value, reference, constant value, and constant reference plus the object `this` can be bound from within a non-static member function scope (see the __Tutorial__ section).
For example, the variable `factor` is bound by constant value so it cannot be mistakenly modified by the local function body.
The variable `sum` is instead bound by non-constant reference because the local function needs to change its value to report the summation result to the enclosing scope.
# The local function body is programmed outside the macros and using normal C++ syntax.
Eventual compiler error messages and line numbers retain their usual meaning.
Exceptions specifications can be programmed outside the macro and just before the body code block `{...}` as usual (see the __Tutorial__ section).
# The macro ending the local function definition specifies the local function name.
# The local function macros declare a functor object local to the enclosing scope named `add`. The functor `add` has `void` result type, it can be called by specifying one parameter of type `double`, and it has access to the variables in scope `factor` (by constant value) and `sum` (by reference).
# The *local exit* declaration macro only specifies the variables in scope to bind (by reference or value and eventually as constants).
Exceptions specifications can be programmed outside the macro and just before the body code block `{...}` as usual (see the __Tutorial__ section).
# The local exit code will be automatically executed when the enclosing scope is exited.
# Local exits are anonymous so their ending macro takes no argument.
# The local function `add` can also be passed as a template parameter (for example, to the STL `std::for_each` algorithm).
# The *local block* declaration macro only specifies the variables in scope to bind (by reference or value and eventually as constants).
# The local block code is executed "in place" where it is programmed like a usual C++ block of code `{ ... }`.
In this example, the compiler will correctly generate an error if the assignment operator `=` is mistakenly used instead of the equality operator `==` because the variable `sum` is bound by constant reference so it cannot be modified.
# Local blocks are anonymous so their ending macro takes no argument.

[endsect]

