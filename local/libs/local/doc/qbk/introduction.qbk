
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the Boost Software ]
[/ License, Version 1.0 (see accompanying file LICENSE_1_0.txt or a ]
[/ copy at http://www.boost.org/LICENSE_1_0.txt). ]

[section:Introduction Introduction]

/Local functions/ are a form of /information hiding/ and are useful for dividing procedural tasks into subtasks which are only meaningful locally, avoiding cluttering other parts of the program with functions, variables, etc unrelated to those parts.
Local functions therefore complement other structuring possibilities such as namespaces and classes.
Local functions are a feature of many programming languages, notably [@http://en.wikipedia.org/wiki/Nested_function#An_example Pascal] and [@http://en.wikipedia.org/wiki/Nesting_(computing)#In_programming Ada], yet lacking from C++ (see also __N2511__).
This library supports the following features for local functions (see the __Alternatives__ section for a comparison between this library and the features offered by other C++ libraries and constructs):

* Local functions can access, or better [@http://en.wikipedia.org/wiki/Name_binding /bind/], any of the variables from the enclosing scope.
Furthermore, local functions defined within a member function can bind the enclosing object `this`.
* The local function body is programmed using the usual C++ syntax (as a consequence, compiler error messages and related line numbers retain their usual meaning).
* Local functions can be passed as template parameters (so they can be conveniently passed to STL algorithms, etc).
* However, local functions must be defined within a declarative context (e.g., at a point in the code where local variables can be declared) thus they cannot be defined within an expression.

In addition to local functions, this library also supports the following features:

* /Local blocks/ which define blocks of code that bind variables from the enclosing scope.
Local blocks allow programmers to bind variables as constants (/constant binding/) so to prevent local chunks of code from modifying selected variables.
* /Local exits/ which define blocks of code that are executed when the enclosing scope is exited (again with support for constant binding and binding of the object `this`).

[h5 Two Syntaxes]

This library uses macros to declare the local functions, local blocks, and local exits.
These macros support two different syntaxes:

* The /sequencing macro syntax/ is fully compliant with the ISO C++ standard and supported on all C++ compilers.
This syntax requires to wrap the local function parameters and bound variables between round parenthesis `()`.
* The /variadic macro synstax/ is available only on C++ compilers that support [@http://en.wikipedia.org/wiki/Variadic_macro variadic macros] (variadic macros are now supported by essentially all modern C++ compilers including GCC and MSVC).
This syntax allows to use commas `,` to separate macro parameters therefore resembling the usual C++ syntax for function parameter declaration.

The same library macros accept both syntaxes on compilers that support variadic macros and only the sequencing macro syntax on compilers that do not support variadic macros.
The use of the variadic macro syntax might lead to more readable code however it should only be used when programmers know that their code will be compiled with variadic macros support to avoid portability issues.
Most of the examples presented in this documentation provide a side-by-side comparison of both syntaxes.

[h5 An Example]

In the following example, a local function is passed to the STL `std::for_each` algorithm to add together the values of an array (variables in scope are bound to the local function by both constant value and non-constant reference).
A local exit is used to automatically release the array's memory when the enclosing function exits.
A local block is used to assert the correct final value of the summation in a constant-correct context (therefore preventing the assertion from mistakenly changing any of the variables in scope).
See the __Tutorial__ section for more details.

[table
[ [Notes] [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_function_block_exit_callouts_cpp] ] [ [add_function_block_exit_va_cpp] ] [ [add_function_block_exit_cpp] ] ]
]

Notes:

# Include the header files for this library local functions, local blocks, and local exits.
# The *local function* parameter macro takes a __Boost_Preprocessor__ sequence of tokens listing each parameter type and name wrapped within round parenthesis [^(['parameter-type parameter-name])['...]] (default parameter values can also be specified using a special syntax, see the __Tutorial__ section).
On C99 and later preprocessors which support variadic macros, the same parameter macro also allows to specify the parameters separated by commas instead that wrapped within parenthesis [^['parameter-type parameter-name],['...]] so to support a syntax similar to the usual C++ syntax for function parameter lists.
The local function result type is specified just before the parameter macro.
# This library macros introduce the special "keyword" `bind` which can be used instead of the parameter type to bind variables in scope.
Variables can be bound by value, by reference, by constant value, and by constant reference.
In addition, the object `this` can be bound (eventually by constant value but never by reference or constant reference) from within a non-static member function (see the __Tutorial__ section).
For example, the variable `factor` is bound by constant value so it cannot be mistakenly modified by the local function body.
The variable `sum` is instead bound by non-constant reference because the local function needs to change its value to report the summation result to the enclosing scope.
# The local function body is programmed outside the macros with the usual C++ syntax.
Eventual compiler error messages and related line numbers retain their usual meaning.
Exceptions specifications can be programmed outside the macro and just before the body code block `{...}` as usual.
Finally, within the local function body the type of a bound variable can be accessed using [^__BOOST_LOCAL_TYPEOF__(['bound-variable-name])] (see the __Advanced_Topics__ section).
# The macro ending the local function definition specifies the local function name.
No semicolon `;` is required after the ending macro.
# The local function macros declare a functor object local to the enclosing scope named `add`.
The functor `add` has `void` result type, it can be called by specifying one parameter of type `double`, and it has access to the variables in scope `factor` (by constant value) and `sum` (by reference).
# The *local exit* declaration macro only specifies the variables in scope to bind (by reference or value and eventually as constants).
Exceptions specifications can be programmed outside the macro and just before the body code block `{...}` as usual.
# The local exit code will be automatically executed when the enclosing scope is exited.
# Local exits are anonymous so their ending macro takes no argument.
No semicolon `;` is required after the ending macro.
# The local function `add` can also be passed as a template parameter (for example, to the STL `std::for_each` algorithm).
# The *local block* declaration macro only specifies the variables in scope to bind (by reference or value and eventually as constants).
Exceptions specifications can be programmed outside the macro and just before the body code block `{...}` as usual.
# The local block code is executed "in place" where it is programmed like a usual C++ block of code.
In this example, the compiler will correctly generate an error if the assignment operator `=` is mistakenly used instead of the equality operator `==` because the variable `sum` is bound by constant reference so it cannot be modified within the local block.
# Local blocks are anonymous so their ending macro takes no argument.
No semicolon `;` is required after the ending macro.

[endsect]

