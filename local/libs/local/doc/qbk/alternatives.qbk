
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the Boost Software ]
[/ License, Version 1.0 (see accompanying file LICENSE_1_0.txt or a ]
[/ copy at http://www.boost.org/LICENSE_1_0.txt). ]

[section:Alternatives Appendix: Alternatives]

This section compares the features offered by this library with similar features offered by other libraries and by the new C++0x standard.

[section Local Functions]

The following table compares local function features.

[table
[
    [ Local Function Feature ]
    [ This Library ]
    [ Local Classes ]
    [ __CPP0x_lambda__ ]
    [ __Boost_Lambda__ ]
    [ __Boost_Phoenix__ ]
]
[
    [ ['Program body using usual C++ syntax] ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
    [ No. ]
    [ No. ]
]
[
    [ ['Can be passed as template parameter (e.g., to STL algorithms)] ]
    [ Yes. ]
    [ No (see "local class" in __StroustrupGlossary__). ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
]
[
    [ ['Bind variables in scope] ]
    [ Yes, bind by value, constant value, reference, and constant reference (also bind the object `this`).
However, the names of the bound variables must be repeated one by one.]
    [ No. ]
    [ Yes, plus there is short-hand syntax to bind all variables in scope at once (by value or by reference).
However, there is no bind by constant value nor by constant reference. ]
    [ No. ]
    [ Yes. ]
]
[
    [ ['Can be defined within expressions] ]
    [ No, defined only within declarations. ]
    [ No, defined only within declarations. ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
]
[
    [ Examples ]
    [``
    int main() {
        double sum = 0.0;
        int factor = 10;

        void BOOST_LOCAL_FUNCTION_PARAMS(
                (double num) (bind& sum)
                (const bind& factor) ) {
            sum += factor * num;
            std::clog << "Summed: " <<
                    sum << std::endl;
        } BOOST_LOCAL_FUNCTION_NAME(add)

        double nums[3] = {1, 2, 3};
        std::for_each(nums, nums + 3, add);
        return 0;
    }
    ``]
    [``
    int main() {
        double sum = 0.0;
        int factor = 10;

        struct local {
            static void add(double num,
                    // Unfortunately, cannot bind
                    // (so specify variable types).
                    double& sum,
                    const int& factor) {
                sum += factor * num;
                std::clog << "Summed: " <<
                        sum << std::endl;
            }
        };

        double nums[3] = {1, 2, 3};
        // Unfortunately, cannot pass as
        // template parameter to `std::for_each`.
        for (size_t i = 0; i < 3; ++i) {
            // Unfortunately, explicitly pass
            // variables `sum` and `factor`.
            local::add(nums[i], sum, factor);
        }
        return 0;
    }
    ``]
    [``
    int main() {
        double sum = 0.0;
        int factor = 10;

        double numes[3] = {1, 2, 3};
        std::for_each(nums, nums + 3,
            // Lambdas are defined at expression
            // level. Unfortunately, cannot bind
            // `factor` by `const&`.
            [&sum, factor](double num) {
                sum += factor * num;
                std::clog << "Summed: " <<
                        sum << std::endl;
            }
        );
        return 0;
    }
    ``]
    [ The body of `add` is too complex to be programmed using __Boost_Lambda__. ]
    [``
    int main() {
        double sum = 0.0;
        int factor = 10;

        boost::function<void(double)> add=(
            // Unfortunately, body cannot use
            // usual C++ syntax.
            ref(sum) += factor * _1,
            std::clog << var("Summed: ") <<
                    sum << std::endl
        );

        double nums[3] = {1, 2, 3};
        std::for_each(nums, nums + 3, add);
        return 0;
    }
    ``]
]
]

[endsect]

[section Local Blocks]

The authors know of no other library or language feature that supports local blocks (i.e., with the ability to bind by constant value or reference).

[endsect]

[section Local Exits]

This library local exits provide a functionality very similar to the one provided by __Boost_ScopeExit__ but with the following additional features:

* Bind by constant (value or reference).
* Bind the object `this`.

[endsect]

[endsect]

