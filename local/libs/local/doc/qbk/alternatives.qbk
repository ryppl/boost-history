
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the Boost Software ]
[/ License, Version 1.0 (see accompanying file LICENSE_1_0.txt or a ]
[/ copy at http://www.boost.org/LICENSE_1_0.txt). ]

[section:Alternatives Appendix: Alternatives]

This section compares the features offered by this library with similar features offered by other libraries and by the new C++0x standard.

[section Local Functions]

The following table compares local function features.

[table
[
    [ Local Function Feature ]
    [ Boost.Local (this library) ]
    [ Local Functor ]
    [ Global Functor (not local) ]
    [ __CPP0x_Lambda__ (not ISO C++) ]
    [ __Boost_Lambda__ ]
    [ __Boost_Phoenix__ ]
]
[
    [ ['Can be defined locally] ]
    [ Yes. ]
    [ Yes. ]
    [ No.
Therefore this not really an alternative implementation of local functions but it is listed here just for comparison. ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
]
[
    [ ['Can be defined using C++ statement syntax] ]
    [ Yes.
Plus eventual compiler errors follow the usual format of C++ statement errors. ]
    [ Yes.
Plus eventual compiler errors follow the usual format of C++ statement errors. ]
    [ Yes.
Plus eventual compiler errors follow the usual format of C++ statement errors. ]
    [ Yes.
Plus eventual compiler errors follow the usual format of C++ statement errors. ]
    [ No (it uses C++ __expression_template__ syntax). ]
    [ No (it uses C++ __expression_template__ syntax). ]
]
[
    [ ['Can be defined within expressions] ]
    [ No. It can be defined only within declarations. ]
    [ No. It can be defined only within declarations. ]
    [ No. It can be defined only within declarations. ]
    [ Yes (plus the local function can be unnamed). ]
    [ Yes (plus the local function can be unnamed). ]
    [ Yes (plus the local function can be unnamed). ]
]
[
    [ ['Can be passed as template parameter (e.g., to STL algorithms)] ]
    [ Yes.
The ISO C++ standard does not allow to pass local types as template parameters (see __N2657__) but this library implements a "trick" to get around this limitation (see the __Implementation__ section). ]
    [ No on ISO C++ compilers (but yes on C++0x compilers and some compilers like MSVC 8.0, see __N2657__). ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
]
[
    [ ['Access variables in scope] ]
    [ Yes.
The variable names are repeated in the function declaration so they can be bound by value, by constant value, by reference, and by constant reference (the object `this` can also be bound). ]
    [ No.
Programmers must manually manage functor member variables and explicitly specify their types to access variables in scope. ]
    [ No.
Programmers must manually manage functor member variables and explicitly specify their types to access variables in scope. ]
    [ Yes.
The variable names are repeated in the function declaration (plus there is a short-hand syntax to bind all variables in scope at once) so they can be bound by constant value and by reference (the object `this` can also be bound).
However, variables cannot be bound by constant references and non-constant value (see below). ]
    [ Yes (variables in scope are accessible as usual within expressions). ]
    [ Yes (variables in scope are accessible as usual within expressions) plus `boost::phoenix::let` can be used to bind variables by constant reference. ]
]
[
    [ ['[@http://en.wikipedia.org/wiki/Type_polymorphism#Parametric_polymorphism Polymorphic] in the unbound parameter types] ]
    [ No (local functions cannot be function templates). ]
    [ No (local classes cannot have member function templates). ]
    [ Yes. ]
    [ No (C++0x lambdas cannot be function templates). ]
    [ Yes. ]
    [ Yes. ]
]
]

[h5 Comparison with __CPP0x_Lambda__ Functions]

__CPP0x_lambda__ functions have most of the features that __Boost_Local__ local functions have, key pro and cons of the two approaches are:

* __CPP0x_lambda__ functions can be defined within expressions while __Boost_Local__ local functions can only be defined within declarations.
* __CPP0x_lambda__ functions are only supported by the C++0x standard so they are not supported by all C++ compilers.
__Boost_Local__ local functions use only ISO C++ compliant features so they are supported on all C++ compliant compilers.
* __CPP0x_lambda__ do not allow to bind variables in scope by constant reference or by non-constant value.
Because a variable cannot be bound by constant reference, __CPP0x_lambda__ functions can bind a variable by constant only if the variable is copyable and the binding requires a (potentially expensive) extra copy operation.
Both constant reference and non-constant value binding are instead supported by __Boost_Local__.

For example, for non-copyable objects:

[table
[ [__CPP0x_Lambda__] [__Boost_Local__ __Variadic_Macro_Syntax__] [__Boost_Local__ __Sequencing_Macro_Syntax__] ]
[ [ [noncopyable_0x_lambda_cpp] ] [ [noncopyable_boost_local_va_cpp] ] [ [noncopyable_boost_local_cpp] ] ]
]

Or, for objects with expensive copy operations:

[table
[ [__CPP0x_Lambda__] [__Boost_Local__ __Variadic_Macro_Syntax__] [__Boost_Local__ __Sequencing_Macro_Syntax__] ]
[ [ [expensive_copy_0x_lambda_cpp] ] [ [expensive_copy_boost_local_va_cpp] ] [ [expensive_copy_boost_local_cpp] ] ]
]

[h5 Examples]

The same example is rewritten here for all the different alternatives to local functions so programmers can get a sense of the different syntaxes and programming styles that the alternatives require.
The following example adds together all the elements of a vector using this library local functions:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_using_boost_local_va_cpp] ] [ [add_using_boost_local_cpp] ] ]
]

Or using C++ local functors:

[add_using_local_functor_cpp]

Or using C++ global functors (but these do not allow to define the function locally so they are not a real alternative implementation of local functions):

[add_using_global_functor_cpp]

Or using __CPP0x_lambda__ functions (but not part of the ISO C++ standard):

[add_using_cpp0x_lambda_cpp]

Or using __Boost_Lambda__ functions:

[add_using_boost_lambda_cpp]

Or using __Boost_Phoenix__:

[add_using_boost_phoenix_cpp]

[h5 Profiling]

The following tables compare run-time, binary size, and compile-time for the different alternatives presented for local functions.

Overall, this library has compile-times and generates binary sizes similar to the ones of the other approaches.
This library run-times on ISO C++ compliant compilers (see "__Boost_Local__ Compliant" below) were measured to be larger than other approaches when compiler optimization is enabled (using `bjam release ...`).
However, on compilers that allow to pass local types as template parameters (e.g., MSVC 8.0 or GCC 4.5.1 with C++0x features enabled, see also __N2657__) this library automatically generates optimized code that runs as fast as the fastest of the other approaches (see "__Boost_Local__" below).
When this library local function is specified `inline` (see "__Boost_Local__ Inline For-Loop" below and the __Advanced_Topics__ section) its run-times are always comparable to both the "Local Functor" and "Global Functor" approaches (but in this case the local function cannot be portably passed as template parameter, see __N2657__, so `std::for_each` is replaced by a for-loop).
Finally, this library run-times are always among the fastest when no compiler optimization is enabled (using `bjam debug ...`).

[note
The run-time performances of this library local functions are explained because on ISO C++ compliant compilers (e.g., GCC 4.3.4) this library needs to use a function pointer in order to pass the local function class as a template parameter (see __N2657__ and the __Implementation__ section).
For all tested compilers, this function pointer prevents the compiler optimization algorithms from inlining the local function calls.
Instead, the functors used by other approaches like "__Boost_Lambda__" and "__Boost_Phoenix__" have been observed to allow all tested compilers to inline all the function calls for optimization.
This run-time performance cost is not present on compilers that allow to pass local types as template parameters (e.g., MSVC 8.0 or GCC 4.5.1 with C++0x features enabled) because this library does not have to use the extra function pointer to implement the local function call (it directly passes the local class type as template parameter).
]

This run-time performance cost on ISO C++ compliant compilers might or might not be an issue depending on the performance requirements of specific applications.
For example, an application might already be using a number of indirect function calls (function pointers, virtual functions, etc) for which the overhead added by using the one extra function pointer required by the local function call might not be noticeable within the overall program run-time.

Finally, note that only a very simple local function body with just a single instruction was used for the anaylsis presented here (see the `profile_...` source files linked below).
The authors have not studied how this library and the other approaches will perform with respect to each other when a more complex set of instructions is programmed for the local function body (e.g., /if/ a more complex set of instructions in the local function body were to inhibit some compilers from inlining functor objects also other approaches like __Boost_Lambda__ and __Boost_Phoenix__ /could/ start to show higher run-times even when optimization is enabled).

[table
[ [ Legend, Source Files, and Commands ] ]
[ [ [$../../example/profile_legend.png [width 13in] [height 10in]] ] ]
[ [
The local function was called =1e8= times to add together all the elements of a vector and the run-time was measured using __Boost_Chrono__ averaging over =10= executions of the vector summation (see source files
[@../../example/profile_boost_local.cpp =profile_boost_local.cpp=],
[@../../example/profile_boost_local_inline.cpp =profile_boost_local_inline.cpp=],
[@../../example/profile_local_functor.cpp =profile_local_functor.cpp=],
[@../../example/profile_global_functor.cpp =profile_global_functor.cpp=],
[@../../example/profile_0x_lambda.cpp =profile_0x_lambda.cpp=],
[@../../example/profile_boost_lambda.cpp =profile_boost_lambda.cpp=], and
[@../../example/profile_boost_phoenix.cpp =profile_boost_phoenix.cpp=]).
] ]
[ [
The following commands were executed from the library example directory to measure compile-time, binary size, and run-time respectively:
``
> python chrono.py bjam {release|debug} <PROGRAM> # compile-time
> size <PROGRAM> # binary size (Linux and Gygwin)
> <PROGRAM> # run-time
``
] ]
]

[table
[ [
GCC 4.5.1 With C++0x Lambdas and "Local Types as Template Parameters" ([^bjam cxxflags=-std=c++0x ...]) on Ubuntu Linux 10
] ]
[ [ 
[*Compiled with =bjam release ...= for maximum optimization (=-O3 -finline-functions=)]
[$../../example/profile_gcc-4.5.1-0x_release.png [width 13in] [height 10in]]
] ]
[ [ 
[*Compiled with =bjam debug ...= for no optimization (=-O0 -fno-inline=)]
[$../../example/profile_gcc-4.5.1-0x_debug.png [width 13in] [height 10in]]
] ]
]

[table
[ [
MSVC 8.0 With "Local Types as Template Parameters" (Without C++0x Lambdas) on Windows XP
] ]
[ [ 
[*Compiled with =bjam release ...= for maximum optimization (=/O2 /Ob2=)]
[$../../example/profile_msvc-8.0_release.png [width 13in] [height 10in]]
] ]
[ [ 
[*Compiled with =bjam debug ...= for no optimization (=/Od /Ob0=)]
[$../../example/profile_msvc-8.0_debug.png [width 13in] [height 10in]]
] ]
]

[table
[ [
GCC 4.3.4 With ISO C++ Only (Without C++0x Lambdas and Without "Local Types as Template Parameters) on Cygwin
] ]
[ [ 
[*Compiled with =bjam release ...= for maximum optimization (=-O3 -finline-functions=)]
[$../../example/profile_gcc-4.3.4_release.png [width 13in] [height 10in]]
] ]
[ [ 
[*Compiled with =bjam debug ...= for no optimization (=-O0 -fno-inline=)]
[$../../example/profile_gcc-4.3.4_debug.png [width 13in] [height 10in]]
] ]
]

[endsect]

[section Local Blocks]

The authors know of no other library or C++ language feature that supports local blocks (i.e., with the ability to bind by constant value or constant reference).

[endsect]

[section Local Exits]

This library local exits provide functionalities very similar to the ones already provided by __Boost_ScopeExit__ but with the following additional features:

* Bind by constant (value or reference).
* Bind the object `this`.

[endsect]

[endsect]

