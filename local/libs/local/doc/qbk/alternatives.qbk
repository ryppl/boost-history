
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the Boost Software ]
[/ License, Version 1.0 (see accompanying file LICENSE_1_0.txt or a ]
[/ copy at http://www.boost.org/LICENSE_1_0.txt). ]

[section:Alternatives Appendix: Alternatives]

This section compares the features offered by this library with similar features offered by other libraries and by the new C++0x standard.

[section Local Functions]

The following table compares local function features.

[table
[
    [ Local Function Feature ]
    [ Boost.Local (this library) ]
    [ Local Functor ]
    [ Global Functor (not local) ]
    [ __CPP0x_lambda__ (not ISO C++) ]
    [ __Boost_Lambda__ ]
    [ __Boost_Phoenix__ ]
]
[
    [ ['Can be defined locally] ]
    [ Yes. ]
    [ Yes. ]
    [ No.
Therefore so this not really an alternative implementation of local functions but it is listed here just for comparison. ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
]
[
    [ ['Can be defined using regular C++ statements] ]
    [ Yes.
Moreover, eventual compiler errors follow the usual format of C++ statement errors.]
    [ Yes.
Moreover, eventual compiler errors follow the usual format of C++ statement errors.]
    [ Yes.
Moreover, eventual compiler errors follow the usual format of C++ statement errors.]
    [ Yes.
Moreover, eventual compiler errors follow the usual format of C++ statement errors.]
    [ No. ]
    [ No. ]
]
[
    [ ['Can be defined within expressions] ]
    [ No. It can be defined only within declarations. ]
    [ No. It can be defined only within declarations. ]
    [ No. It can be defined only within declarations. ]
    [ Yes (plus the local function can be unnamed). ]
    [ Yes (plus the local function can be unnamed). ]
    [ Yes (plus the local function can be unnamed). ]
]
[
    [ ['Can be passed as template parameter (e.g., to STL algorithms)] ]
    [ Yes.
The ISO C++ standard does not allow to pass local types as template parameters (see __N2657__) but this library implements a "trick" to get around this limitation (see the __Implementation__ section). ]
    [ No on ISO C++ compilers but yes on C++0x compilers and some compilers like MSVC (see __N2657__). ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
]
[
    [ ['Access variables in scope] ]
    [ Yes.
The variables names are repeated in the function declaration so they can be bound by value, constant value, reference, and constant reference (also it can bind the object `this`). ]
    [ No.
Programmers must manually manage functor member variables with explicit types to access variables in scope. ]
    [ No.
Programmers must manually manage functor member variables with explicit types to access variables in scope. ]
    [ Yes.
The variables names are repeated in the function declaration so they can be bound by value, constant value, and reference (also it can bind the object `this`).
However, variables cannot be bound by constant reference.
In addition, there is "short-hand" syntax to bind all variables in scope at once (by value or by reference). ]
    [ Yes (variables in scope are accessible as usual within expressions). ]
    [ Yes (variables in scope are accessible as usual within expressions).
In addition, `boost::phoenix::let` can be used to bind variables by constant reference. ]
]
]

[h5 Examples]

The same example is rewritten here for all the different alternatives to local functions so programmers can get a sense of the different syntaxes and programming styles that the alternatives require.
The following example adds together all the elements of a vector using this library local functions:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_using_boost_local_va_cpp] ] [ [add_using_boost_local_cpp] ] ]
]

Or using C++ local functors:

[add_using_local_functor_cpp]

Or using C++ global functors (but these do not allow to define the function locally so they are not an alternative implementation of local functions):

[add_using_global_functor_cpp]

Or using __CPP0x_lambda__ functions (but not part of ISO C++ standard):

[add_using_cpp0x_lambda_cpp]

Or using __Boost_Lambda__ functions:

[add_using_boost_lambda_cpp]

Or using __Boost_Phoenix__:

[add_using_boost_phoenix_cpp]

[h5 Profiling]

The following tables compare run-time, binary size, and compile-time for the different alternatives to local functions.

Overall, this library has compile-times and generates binary sizes similar to the ones of the other approaches.
This library run-times on ISO C++ compliant compilers (see "__Boost_Local__ Compliant" below) were measured to be larger than other approaches when compiler optimization is enabled (using `bjam release ...`).
However, on compilers that allow to pass local types as template parameters (e.g., MSVC 8.0 or GCC 4.5.1 with C++0x features enabled, see also __N2657__) this library generates optimized code that runs as fast as the fastest of the other approaches (see "__Boost_Local__" below).
When this library local function is specified `inline` (see "__Boost_Local__ Inline For-Loop" below) its run-times are always comparable to both the "Local Functor" and "Global Functor" approaches (for all these approaches, the local function cannot be portably passed as template parameter, see __N2657__, so `std::for_each` is replaced by a for-loop).
Finally, this library run-times are always among the fastest when no compiler optimization is enabled (using `bjam debug ...`).

[note
The run-time performance of this library local function is explained because on ISO C++ compliant compilers (e.g., GCC 4.3.4) this library needs to use a function pointer in order to pass the local functor class as a template parameter (see __N2657__ and the __Implementation__ section).
For all tested compilers, this function pointer prevents the compiler optimization algorithms from inlining all the function calls.
Instead, the functor objects used by other approaches like "__Boost_Lambda__" and "__Boost_Phoenix__" have been observed to allow all tested compilers to inline all the function calls for optimization.
This run-time performance cost is not present on compilers that allow to pass local types as template parameters (e.g., MSVC 8.0 or GCC 4.51 with C++0x features enabled) because this library does not have to use the extra function pointer to implement the local function call.

This run-time performance cost on ISO C++ compliant compilers might or might not be an issue depending on the performance requirements of specific applications.
For example, an application might already be using a number of indirect function calls (function pointers, virtual functions, etc) for which the overhead added by using the one extra function pointer required by the local function call might not be noticeable within the overall program run-time.
]

Finally, note that only a very simple local function body with just a single instruction was used for the anaylsis presented here (see the profile program source files linked below).
The authors have not studied how this library and the other approaches will perform with respect to each other when a more complex set of instructions is programmed for the local function body (e.g., /if/ a more complex set of instructions in the local function body were to inhibit some compilers from inlining functor objects also other approaches like __Boost_Lambda__ and __Boost_Phoenix__ /could/ start to show higher run-times even when optimization is enabled).

[table
[ [ Legend, Source Files, and Commands ] ]
[ [ [$../../example/profile_legend.png [width 13in] [height 10in]] ] ]
[ [
The local function was called =1e8= times to add together all the elements of a vector and the run-time was measured using __Boost_Chrono__ averaging over =10= executions of the vector summation (see source files at
[@../../example/profile_boost_local.cpp =profile_boost_local.cpp=],
[@../../example/profile_boost_local_inline.cpp =profile_boost_local_inline.cpp=],
[@../../example/profile_local_functor.cpp =profile_local_functor.cpp=],
[@../../example/profile_global_functor.cpp =profile_global_functor.cpp=],
[@../../example/profile_0x_lambda.cpp =profile_0x_lambda.cpp=],
[@../../example/profile_boost_lambda.cpp =profile_boost_lambda.cpp=], and
[@../../example/profile_boost_phoenix.cpp =profile_boost_phoenix.cpp=]).
] ]
[ [
The following commands were executed from the library example directory to measure compile-time, binary size, and run-time respectively:
``
> python chrono.py bjam {release|debug} <PROGRAM> # compile-time
> size <PROGRAM> # binary size (Linux and Gygwin)
> <PROGRAM> # run-time
``
] ]
]

[table
[ [
GCC 4.5.1 With C++0x Lambdas and "Local Types as Template Parameters" ([^bjam cxxflags=-std=c++0x ...]) on Ubuntu Linux 10
] ]
[ [ 
[*Compiled with =bjam release ...= for maximum optimization (=-O3 -finline-functions=)]
[$../../example/profile_gcc-4.5.1-0x_release.png [width 13in] [height 10in]]
] ]
[ [ 
[*Compiled with =bjam debug ...= for no optimization (=-O0 -fno-inline=)]
[$../../example/profile_gcc-4.5.1-0x_debug.png [width 13in] [height 10in]]
] ]
]

[table
[ [
MSVC 8.0 With "Local Types as Template Parameters" on Windows XP
] ]
[ [ 
[*Compiled with =bjam release ...= for maximum optimization (=/O2 /Ob2=)]
[$../../example/profile_msvc-8.0_release.png [width 13in] [height 10in]]
] ]
[ [ 
[*Compiled with =bjam debug ...= for no optimization (=/Od /Ob0=)]
[$../../example/profile_msvc-8.0_debug.png [width 13in] [height 10in]]
] ]
]

[table
[ [
GCC 4.3.4 With No C++0x Features on Cygwin
] ]
[ [ 
[*Compiled with =bjam release ...= for maximum optimization (=-O3 -finline-functions=)]
[$../../example/profile_gcc-4.3.4_release.png [width 13in] [height 10in]]
] ]
[ [ 
[*Compiled with =bjam debug ...= for no optimization (=-O0 -fno-inline=)]
[$../../example/profile_gcc-4.3.4_debug.png [width 13in] [height 10in]]
] ]
]

[endsect]

[section Local Blocks]

The authors know of no other library or C++ language feature that supports local blocks (i.e., with the ability to bind by constant value or reference).

[endsect]

[section Local Exits]

This library local exits provide a functionality very similar to the one provided by __Boost_ScopeExit__ but with the following additional features:

* Bind by constant (value or reference).
* Bind the object `this`.

[endsect]

[endsect]

