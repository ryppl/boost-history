
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the Boost Software ]
[/ License, Version 1.0 (see accompanying file LICENSE_1_0.txt or a ]
[/ copy at http://www.boost.org/LICENSE_1_0.txt). ]

[section:Alternatives Appendix: Alternatives]

This section compares the features offered by this library with similar features offered by other libraries and by the new C++0x standard.

[section Local Functions]

The following table compares local function features.

[table
[
    [ Local Function Feature ]
    [ Boost.Local (this library) ]
    [ Local Functor ]
    [ Global Functor (not local) ]
    [ __CPP0x_lambda__ (not ISO C++) ]
    [ __Boost_Lambda__ ]
    [ __Boost_Phoenix__ ]
]
[
    [ ['Can be defined locally] ]
    [ Yes. ]
    [ Yes. ]
    [ No so this not an alternative implementation of local functions. ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
]
[
    [ ['Can be defined using regular C++ statements] ]
    [ Yes (also reporting compiler error messages usual for function statements). ]
    [ Yes (also reporting compiler error messages usual for function statements). ]
    [ Yes (also reporting compiler error messages usual for function statements). ]
    [ Yes (also reporting compiler error messages usual for function statements). ]
    [ No. ]
    [ No. ]
]
[
    [ ['Can be defined within expressions] ]
    [ No, defined only within declarations. ]
    [ No, defined only within declarations. ]
    [ No, defined only within declarations. ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
]
[
    [ ['Can be passed as template parameter (e.g., to STL algorithms)] ]
    [ Yes. ]
    [ No with ISO C++ standard (see "local class" in __StroustrupGlossary__). (Yes with C++0x standard and some compilers like MSVC.) ]
    [ No. ]
    [ Yes. ]
    [ Yes. ]
    [ Yes. ]
]
[
    [ ['Bind variables in scope] ]
    [ Yes, bind by value, constant value, reference, and constant reference (also bind the object `this`).
However, the names of the bound variables must be repeated one by one.]
    [ No, programmers must manually manage functor member variable and specify their types. ]
    [ No, programmers must manually manage functor member variable and specify their types. ]
    [ Yes, plus there is short-hand syntax to bind all variables in scope at once (by value or by reference).
However, there is no bind by constant reference. ]
    [ No. ]
    [ Yes, using `let` which also allows to bind by constant reference. ]
]
]

[h5 Examples]

For example, using this library local functions:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_using_boost_local_va_cpp] ] [ [add_using_boost_local_cpp] ] ]
]

Or using C++ local functors:

[add_using_local_functor_cpp]

Or using C++ global functors (but these do not allow to define the function locally so they are not an alternative implementation of local functions):

[add_using_global_functor_cpp]

Or using __CPP0x_lambda__ functions (but not part of ISO C++ standard):

[add_using_cpp0x_lambda_cpp]

Or using __Boost_Lambda__ functions:

[add_using_boost_lambda_cpp]

Or using __Boost_Phoenix__:

[add_using_boost_phoenix_cpp]

[h5 Profiling]

The following table compares compile-time, binary size, and run-time among the different alternatives.

This library has compile-times and generates binary sizes similar to the ones of the other approaches.
This library run-times on ISO C++ compliant compilers (see "__Boost_Local__ Compliant" below) were measured to be similar to "Local Functor" but larger than other approaches like "Global Functor", "__Boost_Lambda__", or "__Boost_Phoenix__" when compiler optimization is enabled.
However, on C++03 compilers (e.g., MSVC) this library generates optimized code (see "__Boost_Local__" below) that runs as fast as the fastest of the other approaches.
Finally, this library run-times are always among the fastest when no compiler optimization is used.

[note
This is because on non C++03 compilers (e.g., GCC) this library needs to use a function pointer in order to pass the local functor class as a template parameter (see the __Implementation__ section).
This function pointer prevents the compiler from inlining all the function calls while the functors used by other approaches like "__Boost_Lambda__" and "__Boost_Phoenix__" allows the compiler to inline all the function calls.

This run-time performance cost on non C++03 compilers might or not be a problem depending on the performance requirements of your application.
For example, your application might already be using a number of indirect function calls (function pointers, virtual functions, etc) for which the overhead added by using the one extra function pointer required by the local function call might not be noticeable within your overall program run-time.
]

Finally, note that a very simple local function body with only one instruction was used for the profiling presented here (see files
[@../../example/profile_boost_local.cpp =profile_boost_local.cpp=],
[@../../example/profile_boost_local_for_loop.cpp =profile_boost_local_for_loop.cpp=],
[@../../example/profile_boost_local_optimized.cpp =profile_boost_local_optimized.cpp=],
[@../../example/profile_local_functor.cpp =profile_local_functor.cpp=],
[@../../example/profile_global_functor.cpp =profile_global_functor.cpp=],
[@../../example/profile_0x_lambda.cpp =profile_0x_lambda.cpp=],
[@../../example/profile_boost_lambda.cpp =profile_boost_lambda.cpp=], and
[@../../example/profile_boost_phoenix.cpp =profile_boost_phoenix.cpp=]).
The authors have not studied how this library and the other approaches will perform with respect to each other when a more complex set of instructions is programmed for the local function body.

[table
[
    [ =bjam release= on MSVC 8.0 (maximum optimization =/O2 /Ob2=)]
    [ =bjam debug= on MSVC 8.0 (no optimization =/O0 /Ob0=)]
]
[
    [
The local function was called =1e8= times to add together all the elements of a vector.
The run-time was measured using __Boost_Chrono__ and averaged over =100= executions of the vector summation (see the relative =profile_...= example files).
    ]
    [
The local function was called =1e8= times to add together all the elements of a vector.
The run-time was measured using __Boost_Chrono__ and averaged over =1= execution of the vector summation (see the relative =profile_...= example files).
    ]
]
[
    [ [$../../example/profile_msvc-8.0_release.png [width 7in] [height 10in]] ]
    [ [$../../example/profile_msvc-8.0_debug.png [width 7in] [height 10in]] ]
]
[
    [
Commands used to measure compile-time, binary size, and run-time from the library example directory:
``
> python chrono.py bjam release <PROGRAM>
> size <PROGRAM>    # Cygwin command
> <PROGRAM> 100000000 100
``
    ] 
    [
Commands used to measure compile-time, binary size, and run-time from the library example directory:
``
> python chrono.py bjam debug <PROGRAM>
> size <PROGRAM>    # Cygwin command
> <PROGRAM> 100000000 1
``
    ] 
]
]

[endsect]

[section Local Blocks]

The authors know of no other library or language feature that supports local blocks (i.e., with the ability to bind by constant value or reference).

[endsect]

[section Local Exits]

This library local exits provide a functionality very similar to the one provided by __Boost_ScopeExit__ but with the following additional features:

* Bind by constant (value or reference).
* Bind the object `this`.

[endsect]

[endsect]

