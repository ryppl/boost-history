
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the Boost Software ]
[/ License, Version 1.0 (see accompanying file LICENSE_1_0.txt or a ]
[/ copy at http://www.boost.org/LICENSE_1_0.txt). ]

[section:Advanced_Topics Advanced Topics]

This section illustrates advanced usage of this library.
At the end of this section there is also a list of knwon limitations of this library.

[section Commas and Symbols in Macro Parameters]

The C++ preprocessor does not allow commas `,` within macro parameters unless they are wrapped by the round parenthesis `()`.
Therefore, using commas within the local function parameters and bindings will generate (cryptic) preprocessor errors unless they are wrapped within extra round parenthesis `()` as explained here.

[note
*Macro parameters with commas* which are already wrapped by round parenthesis `()` are fine (function calls, etc).
However, macro parameters with commas that are not wrapped by round parenthesis need to be wrapped by an extra set of round parenthesis `()` as described here.
Also macro parameters with commas wrapped by angular parenthesis `<>` (templates, etc) or square parenthesis `[]` (multidimensional array access, etc) need to be wrapped by the extra round parenthesis `()` as explained here (this is because the preprocessor only recognizes the round parenthesis and it does not recognize angular, square, or any other type of parenthesis).
]

In addition, local function parameter types cannot start with non-alphanumeric symbols (alphanumeric symbols are `A-Z`, `a-z`, and `0-9`).
[footnote
*Rationale.*
This limitation derives from the fact that `__BOOST_LOCAL_FUNCTION_PARAMS__` uses preprocessor token concatenation to inspect the parameter type token to see if the token is a parameter or a bound variable.
The C++ preprocessor does not allow to concatenate non-alphanumeric tokens.
]
The library will generate (cryptic) preprocessor errors if a parameter type starts with a non-alphanumeric symbol.

Let's consider the following example:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        const std::map<std::string, size_t>& m,                 // (1) Error.
        ::sign_t sign,                                          // (2) Error.
        const size_t& factor, default
                key_size<std::string, size_t>::value,           // (3) Error.
        const std::string& separator, default cat(":", " "),    // (4) OK.
    ) ...
``] [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        (const std::map<std::string, size_t>& m)                // (1) Error.
        (::sign_t sign)                                         // (2) Error.
        (const size_t& factor)(default
                key_size<std::string, size_t>::value)           // (3) Error.
        (const std::string& separator)(default cat(":", " "))   // (4) OK.
    ) ...
``] ]
]

[*(1)] The parameter type `const std::map<std::string, size_t>&` contains a comma `,` after the first template parameter `std::string`.
This comma is not wrapped by any round parenthesis `()` (the outer parenthesis `()` that make the sequencing macro syntax do not count) thus it will cause a preprocessor error.
The macro `__BOOST_IDENTITY_TYPE__(`/parenthesized-type/`)` can be used to wrap a type within extra parenthesis `()` so to overcome this issue:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        __BOOST_IDENTITY_TYPE__((const std::map<std::string, size_t>&)) m,  // OK.
        ...
    ) ...
``] [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        (__BOOST_IDENTITY_TYPE__((const std::map<std::string, size_t>&)) m) // OK.
        ...
    ) ...
``] ]
]

This macro expands to an expression that evaluates (at compile-time) exactly to the specified type.
Note that a total of two set of parenthesis `()` are added:

# Parenthesis to invoke the `__BOOST_IDENTITY_TYPE__` macro.
# Parenthesis to wrap the type expression (and therefore any commas `,` that it contains) passed as parameter to the `__BOOST_IDENTITY_TYPE__` macro.
[footnote
*Rationale.*
Using variadic macros, this extra set of parenthesis could be eliminated requiring only the parenthesis to invoke the `__BOOST_IDENTITY_TYPE__` macro.
However, this feature is currently not implemented and the double parenthesis are always needed when invoking this macro.
]

[*(2)] The parameter type `::sign_t` start with the non-alphanumeric symbols `::` thus it will generate preprocessor errors if used as a local function parameter type.
The macros `__BOOST_IDENTITY_TYPE__` can also be used to overcome this issue:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        __BOOST_IDENTITY_TYPE__((::sign_t)) sign,  // OK.
        ...
    ) ...
``] [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        (__BOOST_IDENTITY_TYPE__((::sign_t)) sign) // OK.
        ...
    ) ...
``] ]
]

Often, there might be better ways to overcome this limitation that lead to code which is more readable than the one using the `__BOOST_IDENTITY_TYPE__` macro.
For example, in this case the symbols `::` could have been simply dropped to obtain the following valid and more readable code:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        sign_t sign,  // OK.
        ...
    ) ...
``] [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        (sign_t sign) // OK.
        ...
    ) ...
``] ]
]

[*(3)] The default parameter value `key_size<std::string, size_t>::value` contains a comma `,` after the first template parameter `std::string`.
Again, this comma is not wrapped by any parenthesis `()` so it will cause a preprocessor error.
Because this is a value expression (and not a type expression), it can be simply wrapped within an extra set of round parenthesis `()`:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        const size_t& factor, default
                (key_size<std::string, size_t>::value), // OK.
        ...
    ) ...
``] [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        (const size_t& factor)(default
                (key_size<std::string, size_t>::value)) // OK.
        ...
    ) ...
``] ]
]


[note
Alternatively, the macro `__BOOST_IDENTITY_VALUE__(`/parenthesized-value/`)` could have been used.
This macro expands to an expression that evaluates (at run-time) exactly to the specified value -- but it adds overhead compared with simply using the extra parenthesis `()`.
Note that, similarly to `__BOOST_IDENTITY_TYPE__`, the `__BOOST_IDENTITY_VALUE__` macro also requires two sets of extra parenthesis one set for invoking the macro and another set to wrap the value expression passed as the macro parameter.
]

[*(4)] The default parameter value `cat(":", " ")` is instead fine because it contains a comma `,` which is already wrapped by the parenthesis `()` of the function call `cat(...)`.

[important
The `__BOOST_IDENTITY_TYPE__` macro must be prefixed by the `typename` keyword when used within templates.
]

Consider the following complete example:
[footnote
The authors recognize that the use of the /identity macros/ adds extra parenthesis to the already significant number of parenthesis required by the sequencing macro syntax.
However, macro parameters usually do not contain unwrapped commas `,` (unless template metaprogramming is being used) so this is usually not a problem.
]

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [ [print_map_va_cpp] ] [ [print_map_cpp] ] ]
]

[endsect]

[section Deducing Bound Types (concepts, etc)]

While the ISO C++ standard does not allow for member functions of local classes to have template parameters, this library allows to call template functions from within a local function, a local block, or a local exit passing bound variables without explicitly specifying their types.
This essentially allows local functions, local blocks, and local exits to be [@http://en.wikipedia.org/wiki/Type_polymorphism polymorphic] in the type of the bound variables (like a template is polymorphic in the type of its template parameters).

Furthermore, this library allow to access the type of the bound variables from within the local function, local block, or local exit using the following macro:

    #include <boost/local/typeof.hpp>

    ... // Within a local function, local block, or local exit.
    __BOOST_LOCAL_TYPEOF__(``/bound-variable/``) ...
    ...

This macro expands to a type expression that evaluates (at compile-time) to the fully qualified type of the specified bound variable.

[note
This type expression is fully qualified in the sense that it will be constant if the variable is bound by constant and it will also be a reference is the variable is bound by reference (if needed, programmers can strip away the `const` and `&` qualifiers using `boost::remove_const` and `boost::remove_reference`, or similar template metafunctions).
]

The deduced bound type can be used within the body to declare a local variable, to check concepts, etc.
For example:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [ [typeof_va_cpp] ] [ [typeof_cpp] ] ]
]

Within templates, `__BOOST_LOCAL_TYPEOF__` does not require to be prefixed by the `typename` keyword but eventual type manipulations need the `typename` prefix as usual:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [ [typeof_tpl_va_cpp] ] [ [typeof_tpl_cpp] ] ]
]

[endsect]

[section Passing Local Functions]

Local functions can be used as functors.
For example, it is possible to assign a local function to a functor parameter (using `boost::function`, etc) in order to pass the local function to another function.
However, it is in general recommended to use the `boost::local::__function__` functor because it supports default parameters.

[important
When assigning a local function to a functor, programmers need to make sure that the *local function survives the scope of the functor* otherwise the functor will be invalid and its use will generate a run-time error (as usual with C++ functors).
]

The `boost::local::__function__` template takes two parameters (see the __Reference__ section):

    template<typename F, size_t defaults = 0> class __function__;

[variablelist
[ [F] [
The template parameter `F` is a function type specifying the function signature using the same syntax as __Boost_Function__'s preferred syntax.
For example:``
    __function__<int()>                   // Returns `int` and takes no parameter.
    __function__<int(double, char)>       // Returns `int`and takes two parameters: a `double` followed by a `char`.
``] ]
[ [defaults] [
The template parameter `defaults` is a non-negative integer number specifying the number of defaults parameters (counting from the last parameter as usual): `0` if no parameter is optional, `1` if the last parameter is optional, `2` if the last two parameters are optional, etc.
The `defaults` template parameter must be between `0` and the total number of parameters as specified by `F`, it is optional and it is `0` by default.
For example:``  
    __function__<int(double, char)>       // No default: All parameters must be specified.
    __function__<int(double, char), 1>    // 1 default: The last `char` parameter is optional.
    __function__<int(double, char), 2>    // 2 defaults: All parameters are optional.
``] ]
]

For example:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [ [doit_va_cpp] ] [ [doit_cpp] ] ]
]

In addition, a local function can bind and call another local function.
For example, the following local function `inc_sum` binds the local function `inc` so `inc_sum` can call `inc`:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [ [transform_va_cpp] ] [ [transform_cpp] ] ]
]

[endsect]

[section Exception Specifications]

It is possible to program exception specifications for local functions, local blocks, and local exits.
Exception specifications are programmed outside the macros and just before the body definition as usual in C++.

[important
However, note that the exception specifications only apply to the body code specified by programmers and they do not apply to the rest of the code automatically generated by the macro expansions to implement local functions, local blocks, and local exits.
For example, even if the body code is specified to throw no exception using `throw () { ... }`, the execution of the library code automatically generated by the macros could still throw (if there is no memory, etc).
]

For example:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [ [add_except_va_cpp] ] [ [add_except_cpp] ] ]
]

[endsect]

[section Storage Classifiers (`auto` and `register`)]

Local function parameters support the storage classifiers as usual in C++.
The `auto` storage classifier is specified as:

	auto ``/parameter-type parameter-name/``

and the `register` storage classifier is specified as:

	register ``/parameter-type parameter-name/``

For example:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [ [add_optimizers_va_cpp] ] [ [add_optimizers_cpp] ] ]
]

[endsect]

[section Recursive Local Functions]

A local function can recursively call itself as usual with C++ functions.

For example, the following local function is used to recursively calculate and print the factorial of the specified numbers:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [ [factorial_va_cpp] ] [ [factorial_cpp] ] ]
]

[endsect]

[section Nested Declarations]

It is possible to nest local function, local block, and local exit declarations into one another.

For example:

[table
[ [Variadic Macro Syntax (C99 and later compilers)] [Sequencing Macro Syntax (all C++ compilers)] ]
[ [ [nesting_va_cpp] ] [ [nesting_cpp] ] ]
]

[endsect]

[section Limitations (overloading, operators, etc)]

The following table summarizes all the usual C++ function features that are not supported for local functions.

[table
[
    [ C++ Function Feature ]
    [ Local Function Support ]
    [ Reason ]
]
[
    [ `export` ]
    [ No ]
    [ This is not supported because local functions cannot be templates (plus most C++ compilers do not implement `export`). ]
]
[
    [ `template<`/template-parameter-list/`>` ]
    [ No ]
    [ This is not supported because local functions are implemented using local classes and C++ local classes cannot be templates. ]
]
[
    [ `explicit` ]
    [ No ]
    [ This is not supported because local functions are not constructors. ]
]
[
    [ `inline` ]
    [ No ]
    [ Local functions are always defined together with their declarations so they are always inlined and there is no need to specify them `inline`. ]
]
[
    [ `extern` ]
    [ No ]
    [ This is not supported because local functions are always defined locally within the enclosing scope and together with their declarations. ]
]
[
    [ `static` ]
    [ No ]
    [ This is not supported because local functions are not member functions. ]
]
[
    [ `virtual` ]
    [ No ]
    [ This is not supported because local functions are not member functions.

In theory, it would be possible for a local functor class to inherit from another local functor class.
The parenthesized syntax could be extended to specify the eventual base local functor class within the parenthesized signature (e.g., using `... (extends)(`/base/`)`).
However, this "inheritance" feature is not implemented because it seems of [@http://lists.boost.org/Archives/boost/2010/09/170895.php no use] given that local functions can be bound to one another thus they can simply call each other directly without recurring to dynamic binding or base function call.
    ]
]
[
    [ [^/result-type/] ]
    [ Yes ]
    [ This is supported (see the __Tutorial__ section). ]
]
[
    [ [^/function-name/] ]
    [ Yes ]
    [ This is supported but it cannot be overloaded and it cannot be an operator (see the __Tutorial__ and __Advanced_Topics__ sections). ]
]
[
    [ [^/parameter-list/] ]
    [ Yes ]
    [ This is supported and it also supports the `auto` and `register` storage classifiers, default parameters, and binding of variables in scope (see the __Tutorial__ and __Advanced_Topics__ sections). ]
]
[
    [ Trailing `const` qualifier ]
    [ No ]
    [ This is not supported because local functions are not member functions. ]
]
[
    [ Trailing `volatile` qualifier ]
    [ No ]
    [ This is not supported because local functions are not member functions. ]
]
]

[h5 Overloading]

It is not possible to overload local functions.
Declaring multiple local functions with the same name within the same enclosing scope generates a compile-time error (even if the different declarations specify different parameters).
[footnote
*Rationale.*
This is because a local function is a functor object declared as a local variable within the enclosing scope.
Therefore, declaring two local functions with the same name within the same enclosing scope declares two local variables with the same name within the same scope and that is not allowed in C++.
]

For example, the following code will *not* compile:

    void f() {
    	void __BOOST_LOCAL_FUNCTION_PARAMS__( (const int& i) ) {
            ...
        } __BOOST_LOCAL_FUNCTION_NAME__(l)

        void __BOOST_LOCAL_FUNCTION_PARAMS__( (const double& d) ) {
            ...
        } __BOOST_LOCAL_FUNCTION_NAME__(l) // Error: Cannot overload.

        ...
    }

[h5 Operators]

Local functions cannot be operators.
Naming a local function `operator...` will generate a compile-time error.
[footnote
*Rationale.*
This is the because a local function name must be a valid local variable name (the local variable to hold the local functor object) and operators cannot be used as local variable names.
]

For example, the following code will *not* compile:

    void f() {
        struct point {
            double x;
            double y;
        };

        bool __BOOST_LOCAL_FUNCTION_PARAMS__(
                (const point&)(p) (const point&)(q) ) {
            return p.x == q.x && p.y == q.y;
        ) __BOOST_LOCAL_FUNCTION_NAME__(operator==) // Error: Cannot be `operator==`.

        ...
    }

[endsect]

[endsect]

