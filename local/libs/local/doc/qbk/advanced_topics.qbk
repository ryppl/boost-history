
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the Boost Software ]
[/ License, Version 1.0 (see accompanying file LICENSE_1_0.txt or a ]
[/ copy at http://www.boost.org/LICENSE_1_0.txt). ]

[section:Advanced_Topics Advanced Topics]

This section illustrates advanced usages of this library.
At the end of this section there is also a list of knwon limitations of this library.

[section Commas and Symbols in Macro Parameters]

The C++ preprocessor does not allow commas `,` within macro parameters unless they are wrapped by round parenthesis `()`.
Therefore, using commas within the local function parameters and bindings will generate (cryptic) preprocessor errors unless they are wrapped with an extra set of round parenthesis `()` as explained here.

[note
Macro parameters with commas which are already wrapped by round parenthesis `()` are fine (function calls, etc).
However, macro parameters with commas that are not wrapped by round parenthesis need to be wrapped by an extra set of round parenthesis `()` as described here.
Also macro parameters with commas wrapped by angular parenthesis `<>` (templates, etc) or square parenthesis `[]` (multidimensional array access, etc) need to be wrapped by the extra round parenthesis `()` as explained here (this is because the preprocessor only recognizes the round parenthesis and it does not recognize angular, square, or any other type of parenthesis).
]

In addition, local function parameter types cannot start with non-alphanumeric symbols (alphanumeric symbols are `A-Z`, `a-z`, and `0-9`).
[footnote
*Rationale.*
This limitation derives from the fact that `__BOOST_LOCAL_FUNCTION_PARAMS__` uses preprocessor token concatenation to inspect the parameter type token to see if the token is a parameter or a bound variable.
The C++ preprocessor does not allow to concatenate non-alphanumeric tokens.
]
The library will generate (cryptic) preprocessor errors if a parameter type starts with a non-alphanumeric symbol.

Let's consider the following example:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        const std::map<std::string, size_t>& m,                 // (1) Error.
        ::sign_t sign,                                          // (2) Error.
        const size_t& factor, default
                key_size<std::string, size_t>::value,           // (3) Error.
        const std::string& separator, default cat(":", " "),    // (4) OK.
    ) ...
``] [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        (const std::map<std::string, size_t>& m)                // (1) Error.
        (::sign_t sign)                                         // (2) Error.
        (const size_t& factor)(default
                key_size<std::string, size_t>::value)           // (3) Error.
        (const std::string& separator)(default cat(":", " "))   // (4) OK.
    ) ...
``] ]
]

[*(1)] The parameter type `const std::map<std::string, size_t>&` contains a comma `,` after the first template parameter `std::string`.
This comma is not wrapped by any round parenthesis `()` (the outer parenthesis `()` that make the sequencing macro syntax do not count) thus it will cause a preprocessor error.
The macro `__BOOST_IDENTITY_TYPE__(`/parenthesized-type/`)` can be used to wrap a type within extra parenthesis `()` so to overcome this issue:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        __BOOST_IDENTITY_TYPE__((const std::map<std::string, size_t>&)) m,  // OK.
        ...
    ) ...
``] [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        (__BOOST_IDENTITY_TYPE__((const std::map<std::string, size_t>&)) m) // OK.
        ...
    ) ...
``] ]
]

This macro expands to an expression that evaluates (at compile-time) exactly to the specified type.

[important
The `__BOOST_IDENTITY_TYPE__` macro must be prefixed by the `typename` keyword when used within templates as in `typename __BOOST_IDENTITY_TYPE__(`/parenthesized-type/`)`.
]

Note that a total of two set of parenthesis `()` are added:

# Parenthesis to invoke the `__BOOST_IDENTITY_TYPE__` macro.
# Parenthesis to wrap the type expression (and therefore any commas `,` that it contains) passed as parameter to the `__BOOST_IDENTITY_TYPE__` macro.
[footnote
*Rationale.*
Using variadic macros, this extra set of parenthesis could be eliminated requiring only the parenthesis to invoke the `__BOOST_IDENTITY_TYPE__` macro.
However, this feature is currently not implemented and the double parenthesis are always needed when invoking this macro.
]

[note
Often, there might be better ways to overcome this limitation that lead to code which is more readable than the one using the `__BOOST_IDENTITY_TYPE__` macro.
For example, in this case a `typedef` could have been used to obtain the following valid and perhaps more readable code:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [``
    typedef std::map<std::string, size_t> map_type;
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        const map_type& m,  // OK.
        ...
    ) ...
``] [``
    typedef std::map<std::string, size_t> map_type;
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        (const map_type& m) // OK.
        ...
    ) ...
``] ]
]
]

[*(2)] The parameter type `::sign_t` starts with the non-alphanumeric symbols `::` thus it will generate preprocessor errors if used as a local function parameter type.
The macros `__BOOST_IDENTITY_TYPE__` can also be used to overcome this issue:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        __BOOST_IDENTITY_TYPE__((::sign_t)) sign,  // OK.
        ...
    ) ...
``] [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        (__BOOST_IDENTITY_TYPE__((::sign_t)) sign) // OK.
        ...
    ) ...
``] ]
]

[note
Often, there might be better ways to overcome this limitation that lead to code which is more readable than the one using the `__BOOST_IDENTITY_TYPE__` macro.
For example, in this case the symbols `::` could have been simply dropped to obtain the following valid and perhaps more readable code:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        sign_t sign,  // OK.
        ...
    ) ...
``] [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        (sign_t sign) // OK.
        ...
    ) ...
``] ]
]
]

[*(3)] The default parameter value `key_size<std::string, size_t>::value` contains a comma `,` after the first template parameter `std::string`.
Again, this comma is not wrapped by any parenthesis `()` so it will cause a preprocessor error.
Because this is a value expression (and not a type expression), it can be simply wrapped within an extra set of round parenthesis `()`:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        const size_t& factor, default
                (key_size<std::string, size_t>::value), // OK.
        ...
    ) ...
``] [``
    ... __BOOST_LOCAL_FUNCTION_PARAMS__(
        ...
        (const size_t& factor)(default
                (key_size<std::string, size_t>::value)) // OK.
        ...
    ) ...
``] ]
]


[note
Alternatively, the macro `__BOOST_IDENTITY_VALUE__(`/parenthesized-value/`)` could have been used.
This macro expands to an expression that evaluates (at run-time) exactly to the specified value (but it adds run-time overhead compared with simply using the extra parenthesis `()`).
Note that, similarly to `__BOOST_IDENTITY_TYPE__`, the `__BOOST_IDENTITY_VALUE__` macro also requires two sets of extra parenthesis one set for invoking the macro and another set to wrap the value expression passed as the macro parameter.
]

[*(4)] The default parameter value `cat(":", " ")` is instead fine because it contains a comma `,` which is already wrapped by the parenthesis `()` of the function call `cat(...)`.

Consider the following complete example:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [print_map_va_cpp] ] [ [print_map_cpp] ] ]
]

[endsect]

[section Assigning Local Functions]

Local functions are functors so it is possible to assign them to other functors (like `__boost__function__`) in order to store the local function into a variable or to pass it as a parameter to another function.

[important
When assigning a local function to a functor, programmers need to make sure that the local function survives the scope of the functor otherwise the functor will be invalid and its use will generate a run-time error (as usual with C++ functors).
]

For example:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [doit_va_cpp] ] [ [doit_cpp] ] ]
]

In addition, a local function can bind and call another local function.
For example, the following local function `inc_sum` binds the local function `inc` so `inc_sum` can call `inc`:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [transform_va_cpp] ] [ [transform_cpp] ] ]
]

[endsect]

[section Deducing Bound Types (concepts, etc)]

This library never requires to explicitly specify the type of the bound variables.
From within local functions, local blocks, and local exits, programmers can access the type of the bound variables using the following macro:

    #include <boost/local/typeof.hpp>

    ... // Within a local function, local block, or local exit.
    __BOOST_LOCAL_TYPEOF__(``/bound-variable/``) ...
    ...

This macro expands to a type expression that evaluates (at compile-time) to the fully qualified type of the bound variable with the specified name.

[note
This type expression is fully qualified in the sense that it will be constant if the variable is bound by constant and it will also be a reference is the variable is bound by reference (if needed, programmers can strip away the `const` and `&` qualifiers using `boost::remove_const` and `boost::remove_reference`, or similar template metafunctions, see __Boost_TypeTraits__).
]

The deduced bound type can be used within the body to declare a local variable, to check concepts, etc.
For example:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [typeof_va_cpp] ] [ [typeof_cpp] ] ]
]

Within templates, `__BOOST_LOCAL_TYPEOF__` does not require to be prefixed by the `typename` keyword but eventual type manipulations need the `typename` prefix as usual:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [typeof_tpl_va_cpp] ] [ [typeof_tpl_cpp] ] ]
]

[endsect]

[section Specifying Bound Types]

While not required, it is possible to explicitly specify the type of the bound variables.
When the bound variable type is explicitly specified by the programmers, the library will not use __Boost_Typeof__ to automatically deduce such a type.
However, the library implementation will still internally use __Boost_Typeof__ to deduce the local function result and functor types (see the __Implementation__ section) even when __Boost_Typeof__ is not used to deduce any of the bound variable types.

When specified, the bound variable type must follow the `bind` "keyword" and it must be wrapped within round parenthesis `()`:

    bind(``/variable-type/``) ``/variable-name/``           // Bind by value with explicit type.
    bind(``/variable-type/``)& ``/variable-name/``          // Bind by reference with explicit type.
    const bind(``/variable-type/``) ``/variable-name/``     // Bind by constant value with explicit type.
    const bind(``/variable-type/``)& ``/variable-name/``    // Bind by constant reference with explicit type.
    bind(``/class-type/``*) this                      // Bind object `this` with type.
    const bind(``/class-type/``*) this                // Bind object `this` by constant with type.

The following example explicitly specifies the type of all bound variables (it is also possible to explicitly specify the type only for some of the bound variables in which case the library will automatically deduce the type of the rest of the bound variables using __Boost_Typeof__ as usual):

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_this_typed_va_cpp] ] [ [add_this_typed_cpp] ] ]
]

Within the local function, local block, and local exit body it is possible to abstract the access to the type of a bound variable as usual using `__BOOST_LOCAL_TYPEOF__` (even if the bound variable type is specified explicitly).

[endsect]

[section Inlining Local Functions]

Local functions can be declared inlined to increase the chances that the compiler will be able to reduce the local function call run-time by inlining the generated assembly code.
A local function is declared inlined by prefixing the local function name passed to the `__BOOST_LOCAL_FUNCTION_NAME__` macro with the "keyword" `inline`:

    ... __BOOST_LOCAL_FUNCTION_PARAMS__( ... ) {
        ...
    } __BOOST_LOCAL_FUNCTION_NAME__(inline ``/name/``)

On ISO C++ compliant compilers, inlined local functions always have a run-time comparable to their equivalent implementation that uses local functors (see the __Alternatives__ section).
However, inlined local functions have the limitation that they cannot be assigned to other functors (like `__boost__function__`) and they cannot be passed as template parameters.
[footnote
*Rationale.*
This library uses an indirect function call via a function pointer in order to pass the local function as a template parameter (see the __Implementation__ section).
No compiler has yet been observed to be able to inline function calls when they use such indirect function pointer calls.
Therefore, inlined local functions do not use such indirect function pointer call (so they are more likely to be optimized) but because of that they cannot be passed as template parameters.
The indirect function pointer call is needed on ISO C++ but it is not needed on C++0x (see __N2657__) thus this library automatically generates local function calls that can be inlined on C++0x compilers (even when the local function is not declared inlined).
]
On C++0x compilers, `inline` has no effect because this library will automatically generate code that uses C++0x specific features to inline the local function calls whenever possible even if the local function is not declared inlined (unless the `__BOOST_LOCAL_CONFIG_COMPLIANT__` configuration macro is defined).
Furthermore, non C++0x local functions can always be passes as template parameters even when they are declared inlined.

[important
It is recommended to not declare a local function inlined unless it is strictly necessary for optimizing pure ISO C++ compliant code (because in all other cases this library will automatically take advantage of C++0x features to optimize the local function calls while always allowing to pass the local function as a template parameter).
]

For example, the following local function is declared inlined (thus a for-loop needs to be used for portability instead of passing the local function as a template parameter to the `std::for_each` algorithm):

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_function_inline_va_cpp] ] [ [add_function_inline_cpp] ] ]
]

[endsect]

[section Recursive Local Functions]

Local functions can be declared [@http://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_procedures recursive] so a local function can recursively call itself from its body (as usual with C++ functions).
A local function is declared recursive by prefixing the local function name passed to `__BOOST_LOCAL_FUNCTION_NAME__` macro with the "keyword" `recursive`:

    ... __BOOST_LOCAL_FUNCTION_PARAMS__( ... ) {
        ...
    } __BOOST_LOCAL_FUNCTION_NAME__(recursive ``/name/``)

For example, the following local function is used to recursively calculate and print the factorials of all the numbers in the specified vector:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [factorial_va_cpp] ] [ [factorial_cpp] ] ]
]

Compilers have not been observed to be able to inline recursive local function calls (not even when the recursive local function is also declared inlined).

[endsect]

[section Overloading Local Functions]

It is possible to overload local functions by creating a `__boost__local__function__overload__` functor that aggregates together calls to different local functions with different signatures.
Note that the header file [headerref boost/local/function/overload.hpp] needs to be included when using the `__boost__local__function__overload__` functor.

In the following example, the overloaded functor `print` can be called with signatures from either the local function `print_string`, or the local function `print_double`, or the local function `print_double` with the extra default parameter `name`, or the function pointer `print_add`:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [overload_va_cpp] ] [ [overload_cpp] ] ]
]

The implementation of the `__boost__local__function__overload__` functor is equivalent to the following:

    namespace boost { namespace local { namespace function {

    template<typename F0, typename F1, ...>
    class overload {
    public:
        overload(const boost::function<F0>& f0, const boost::function<F1>& f1, ...):
                f0_(f0), f1_(f1), ... {}

        result_type<F0> operator()(arg0_type<F0> a0, arg1_type<F0> a1, ...) const {
            return f0_(a0, a1, ...);
        }
        result_type<F1> operator()(arg0_type<F1> a0, arg1_type<F1> a1, ...) const {
            return f1_(a0, a1, ...);
        }
        ...

    private:
        const boost::function<F0> f0_;
        const boost::function<F1> f1_;
        ...
    };

    }}} // namespace boost::local::function

A `__boost__local__function__overload__` functor can be constructed from any function type that can be converted to a `__boost__function__` type (i.e., local functions but also function pointers and other function objects).
[footnote
The `__boost__local__function__overload__` functor can aggregate any functor and it is not at all specific to local functions.
Therefore, it might be preferable to move `__boost__local__function__overload__` from __Boost_Local__ to __Boost_Function__ and to rename it as `boost::function::overload`.
]
The `__boost__local__function__overload__` functor provides overloaded call operators `operator()` that match the signatures of all the specified function types.

The maximum number of function types that can be specified for overloading is controlled at compile-time by the configuration macro `__BOOST_LOCAL_CONFIG_OVERLOAD_MAX__`.
The maximum number of parameters that can be passed to each of the overloaded function type is controlled at compile-time by the configuration macro `__BOOST_LOCAL_CONFIG_FUNCTION_ARITY_MAX__`.

[endsect]

[section Nesting Local Constructs]

It is possible to nest local function, local block, and local exit declarations into one another.

For example:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [nesting_va_cpp] ] [ [nesting_cpp] ] ]
]

[endsect]

[section Exception Specifications]

It is possible to program exception specifications for local functions, local blocks, and local exits.
Exception specifications are programmed outside the macros and just before the body definition.

[important
Note that the exception specifications only apply to the body code specified by programmers and they do not apply to the rest of the code automatically generated by the macro expansions to implement local functions, local blocks, and local exits.
For example, even if the body code is specified to throw no exception using `throw () { ... }`, the execution of the library code automatically generated by the macros could still throw (if there is no memory, etc).
]

For example:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_except_va_cpp] ] [ [add_except_cpp] ] ]
]

[endsect]

[section Storage Classifiers (`auto` and `register`)]

Local function parameters support the storage classifiers as usual in ISO C++.
The `auto` storage classifier is specified as:
[footnote
The `auto` storage classifier is part of the ISO C++ standard and therefore supported by this library.
However, the meaning and usage of the `auto` keyword changed in C++0x.
Therefore, use the `auto` storage classifier with the usual care in order to avoid writing ISO C++ code that might not work on C++0x.
]

	auto ``/parameter-type parameter-name/``

The `register` storage classifier is specified as:

	register ``/parameter-type parameter-name/``

For example:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_optimizers_va_cpp] ] [ [add_optimizers_cpp] ] ]
]

[endsect]

[section Limitations (operators, etc)]

The following table summarizes all C++ function features indicating those features that are not supported by this library for local functions.

[table
[
    [ C++ Function Feature ]
    [ Local Function Support ]
    [ Reason ]
]
[
    [ `export` ]
    [ No ]
    [ This is not supported because local functions cannot be templates (plus most C++ compilers do not implement `export`). ]
]
[
    [ `template<`/template-parameter-list/`>` ]
    [ No ]
    [ This is not supported because local functions are implemented using local classes and ISO C++ local classes cannot be templates. ]
]
[
    [ `explicit` ]
    [ No ]
    [ This is not supported because local functions are not constructors. ]
]
[
    [ `inline` ]
    [ Yes ]
    [ Local functions can be specified `inline` to improve the chances that ISO C++ standard compilers can optimize the local function call run-time (but `inline` local functions cannot be passes as template parameters on ISO C++ standard compilers). ]
]
[
    [ `extern` ]
    [ No ]
    [ This is not supported because local functions are always defined locally within the enclosing scope and together with their declarations. ]
]
[
    [ `static` ]
    [ No ]
    [ This is not supported because local functions are not member functions. ]
]
[
    [ `virtual` ]
    [ No ]
    [ This is not supported because local functions are not member functions.
[footnote
*Rationale.*
It would be possible to make a local function class inherit from another local function class.
However, this "inheritance" feature is not implemented because it seemed of [@http://lists.boost.org/Archives/boost/2010/09/170895.php no use] given that local functions can be bound to one another thus they can simply call each other directly without recurring to dynamic binding or base function call.
]
    ]
]
[
    [ [^/result-type/] ]
    [ Yes ]
    [ This is supported (see the __Tutorial__ section). ]
]
[
    [ [^/function-name/] ]
    [ Yes ]
    [ Local functions are named and they can call themselves recursively but they cannot be overloaded and they cannot be operators (see the __Tutorial__ and __Advanced_Topics__ sections). ]
]
[
    [ [^/parameter-list/] ]
    [ Yes ]
    [ This is supported and it also supports the `auto` and `register` storage classifiers, default parameters, and binding of variables in scope (see the __Tutorial__ and __Advanced_Topics__ sections). ]
]
[
    [ Trailing `const` qualifier ]
    [ No ]
    [ This is not supported because local functions are not member functions. ]
]
[
    [ Trailing `volatile` qualifier ]
    [ No ]
    [ This is not supported because local functions are not member functions. ]
]
]

[h5 Operators]

Local functions cannot be operators.
Naming a local function `operator...` will generate a compile-time error.
[footnote
*Rationale.*
This is the because a local function name must be a valid local variable name (the local variable to hold the local functor) and operators cannot be used as local variable names.
]

For example, the following code will *not* compile:

    void f() {
        struct point {
            double x;
            double y;
        };

        bool __BOOST_LOCAL_FUNCTION_PARAMS__(
                (const point& p) (const point& q) ) {
            return p.x == q.x && p.y == q.y;
        ) __BOOST_LOCAL_FUNCTION_NAME__(operator==) // Error: Cannot use `operator==`.

        ...
    }

[h5 Goto]

It is not possible to jump with a `goto` from within a local function, local block, or local exit to a label defined in the enclosing scope.

For example, the following will *not* compile:

    int f() {
        void __BOOST_LOCAL_FUNCTION_PARAMS__( (boost error) ) {
            if (error) goto failure;    // Error: Cannot jump to enclosing label `failure`.
            else goto success;          // Ok: Can jump within enclosing scope.

        success:
            std::cout << "done" << std::endl;
        } __BOOST_LOCAL_FUNCTION_NAME__(l)

        l(true);

        return 0;
    failure:
        std::cout << "error" << std::endl;
        return -1;
    }

[endsect]

[endsect]

