
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the Boost Software ]
[/ License, Version 1.0 (see accompanying file LICENSE_1_0.txt or a ]
[/ copy at http://www.boost.org/LICENSE_1_0.txt). ]

[section:Rationale Appendix: Rationale]

This section discusses rationale behind library design decisions in addition to the rationale already provided throughout the rationale footnotes in the rest of this documentation.

[section Parenthesized Syntax Rationale]

This section discusses the rationale behind parenthesized syntax design decisions.

[section C99 Preprocessor]

The C99 preprocessor (and therefore the C++0x preprocessor) allows for additional features like specifying empty macro parameters and variadic macro parameters which are not supported by the ISO C++ standard preprocessor.
The additional features of the C99 preprocessor can be used to simplify the parenthesized syntax mainly by removing extra parenthesis and making it look more like normal C++ syntax.

Most (and maybe all) modern compilers support the C99 preprocessor at this time and all new C++0x compilers will support the C99 preprocessor in the future.
Therefore, the library macros have been programmed to automatically detect the presence of the C99 preprocessor and accept the simplified parenthesized syntax in these cases.
The same macro will only accept the parenthesized syntax on non C99 preprocessor but will accept both the parenthesized syntax and the simplified parenthesized syntax on C99 preprocessors.
This way, programmers that can afford to write C99 specific code can benefit from the simplifications of the parenthesized syntax.

[endsect]

[section Parameter Type and Name Separation]

C++ allows to specify parameter names within function types:

    void (int x, double& y)

Therefore, the parenthesized syntax for local functions does not have to separate the function parameter type and name tokens:

[table Parameter Types and Names
[ [Normal C++ Syntax] [C++ Parenthesized Syntax] [C99-Only Parenthesized Syntax] ]
[ [
`void f(int x, double&y)`
] [
`(void) (f)( (int x) (double& y) ) // Is this better than its general version below selected by the authors? Local functions don't need the generality...`
] [ 
`(void) (f)(int x, double& y) // Authors' choice.`
] ]
]

Note that a more general form of the parenthesized syntax would have been instead:
[table Separated Parameter Types and Names
[ [Normal C++ Syntax] [C++ Parenthesized Syntax] [C99-Only Parenthesized Syntax] ]
[ [
`void f(int x, double& y)`
] [
`(void) (f)( (int)(x) (double&)(y) ) // Authors' choice.`
] [
`(void) (f)(int, x, double&, y)` /-or-/

`(void) (f)( (int, x) , (double&, y) )` /-or-/

`(void) (f)( (int)(x) , (double&)(y) )`
] ]
]

This more general form makes available the parameter types and names as separate tokens for preprocessor metaprogramming.
In fact, there is no way for the preprocessor to split `(int x)` into the parameter type `int` and name `x` while it can split `(int)(x)`.
The parameter types can be split at compile-time (for example to force some parameters to be constant, references, etc):
    
    typedef arg_type<void (int x, double& y), 0>::type arg_type0; // int
    typedef arg_type<void (int x, double& y), 1>::type arg_type1; // double&

But the parameter name `x` remains inaccessible as a token separately from its type.
However, local function do not need to access parameter types separately from their types so this lack of generality is not an issue for local function and the less general syntax (e.g., `(int x)`) is preferred over the more general one (e.g., `(int)(x)`) because it is simpler as it uses a smaller number of parenthesis and resembles more closely the normal C++ syntax for function parameters.

[note *Overloaded functions.*
An example where parameter names need to be accessed separately from their types is to support overloading.
For example, if the macro need to expand to support code for an overloaded function, they might need to generate unique identifiers for symbols within the support code.
Assume also `__LINE__` cannot be used in this context because the unique identifiers need to be referred by another macro expanding on a different line (so the unique identifier need to be generated upon the function syntactic elements -- function name, parameter names, etc).
Such identifiers cannot simply use the function name because the same function name is used multiple times when the function is overloaded and therefore the identifiers will not be unique.
The parameter names can be concatenated by the preprocessor together with the function name to generate such unique identifiers (with the limitation that overloaded function need to used different parameter names and not just different parameter types).
]

[endsect]

[section Empty Function Parameters]

The C++ preprocessor does not allow to specify an empty macro parameter as a consequence preprocessor sequences cannot contain empty elements `()`.
Therefore the following parenthesized syntax for a function with no parameter `void f()` is not valid for the C++ preprocessor:

    (void) (f)() // Error, cannot use empty `()`.

This syntax is instead valid for the C99 preprocessor because it can instead accept empty macro parameter.

C++ also allow to specify an empty parameter list using `void`:
    
    void f(void)
    
This leads to the valid parenthesized syntax:

    (void) (f)( (void) )

In summary:

[table Empty Function Parameters
[ [Normal C++ Syntax] [C++ Parenthesized Syntax] [C99-Only Parenthesized Syntax] ]
[ [
`void f()`
] [
`(void) (f)( (void) ) // Authors' choice.`
] [
`(void) (f)() // Authors' choice.`
] ]
]

[endsect]

[section Default Parameter Values]

C++ does not allow to specify default parameter values within function types thus the following is not valid:

    void (int x = -1, double y = -1.23) // Error, can't specify default parameters within function types.

Therefore, the following parenthesized syntax cannot be used:

    (void) (f)( (int x = -1) (double y = -1.23) )

Because:

# It does not allow to strip the default parameter values from the parameter type and name in order to construct and manipulate the local function type.
# Default parameter values are not part of the type so it is not possible to program a metafunction that counts the number of default parameter values at compile-time but such information is also needed by the local functions in order to properly support default parameters.
[footnote
Specifically, the number of default parameter value is needed at compile-time to instantiate the proper `function_ref<typename F, size_t default_parameter_count` template to hold the local function.
The `function_ref` functor is needed to implement the trick that allows local functions to be passed as template parameters (see [@http://lists.boost.org/Archives/boost/2010/09/170888.php]).
]

Default parameters can be separated by the rest of the parameter expression using:

    (void) (f)( (int x)(default -1) (double y)(default -1.23) )

Note that the `=` symbol needs to be replaced with the alphanumeric keyword `default` because parenthesized syntax elements cannot start with a non alphanumeric symbol like `=`.
[footnote
This is because the parenthesized syntax needs to check if its token matches a keyword like `void`, `inline`, etc.
This checking is done by concatenating from the front the token with a special library-defined symbol that generates a new macro that will ultimately expand to `1` if and only if the element matches the searched keyword.
The preprocessor does not allow to concatenate non-alphanumeric tokens so the parenthesized syntax tokens cannot start with a non-alphanumeric token otherwise the concatenation will generate a preprocessor error (see [@http://lists.boost.org/Archives/boost/2010/08/169859.php]).
]

For C99, some or all the parenthesis can be replaced by commas.

[table Default Parameter Values
[ [Normal C++ Syntax] [C++ Parenthesized Syntax] [C99-Only Parenthesized Syntax] ]
[ [
`void f(inx x = -1, double y = -1.23)`
] [
`(void) (f)( (int x)(default -1) (double y)(default -1.23) )`
] [
`(void) (f)(int x, default -1, double y, default -1.23)` /-or-/ `// Authors' choice.`

`(void) (f)( (int x, default -1) , (double y, default -1.23) )` /-or-/

`(void) (f)( (int x)(default -1) , (double y)(default -1.23) )`
] ]
]

[section Function Name, Result, Inline, Etc]
[endsect]

[section Variable Binding]
[endsect]

[endsect]

[endsect]

[endsect]

