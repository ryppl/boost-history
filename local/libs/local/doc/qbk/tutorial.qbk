
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the ]
[/ Boost Software License, Version 1.0 ]
[/ (see accompanying file LICENSE_1_0.txt or a copy at ]
[/ http://www.boost.org/LICENSE_1_0.txt). ]

[section:Tutorial Tutorial]

This section illustrates basic usages of local functions, local blocks, and local exits.

[section Parenthesized Syntax]

The /parenthesized syntax/ is used to pass the syntactic elements of a function signature as macro parameters in a way that resembles the usual C++ syntax.
All the function signature elements are wrapped within round parenthesis `()` to form a __Boost_Preprocessor__ sequence called /parenthesized signature/.
This allows to program preprocessor macros that can parse the parenthesized syntax expanding differently based on the different elements that are specified in the signature (if the function has parameters or not, if the result type token matches the `void` keyword or not, etc).

[important
The *general rules to program the parenthesized signature* are:

1. Wrap all the signature syntactic elements within parenthesis `()`.
[footnote
The parenthesized syntax owes its name to the indeed large number of parenthesis `()` that are required to wrap its elements.
Programmers might notice some similarities between the parenthesized syntax and the syntax of the __LISP__ programming language.
However, these similarities are not intentional in that they were not a design choice but rather a consequence of the fact that both __LISP__ sequences and __Boost_Preprocessor__ sequences are formed by wrapping tokens within round parenthesis `()`.
]

2. If a token does not start with an alphanumeric symbol (i.e., `a-z`, `A-Z`, or `0-9`), replace the token with its alphanumeric equivalent (as indicated in the __Grammar__ section).
[footnote
*Rationale.*
This constraint comes form the fact that the C++ preprocessor can only concatenate =##= alphanumeric symbols.
]

3. Empty parenthesis `()` are not allowed.
[footnote
*Rationale.*
This constraint comes from the fact that the ISO C++ standard preprocessor forbids empty macro parameters (this is different for C99 and other more recent preprocessors).
]

4. Spaces and newlines do not matter and they can be used anywhere.
]

For example, let's rewrite the following C++ function signature using the parenthesized syntax:

    int l(double& y, const double& x = 0.0)

[*Step 1.]
We start by wrapping all the syntactic elements within round parenthesis `()`:

    (int) (l)( (double&)(y) (,) (const double&)(x)(=)(0.0) ) ``[*=/* wrap all elements within parenthesis `()` */=]``

Note how parameter types are wrapped within parenthesis separately from parameter names.
However, all the tokens of a parameter type are wrapped together within a single set of parenthesis because the parameter type is one single syntactic element of the function signature.
For example, `x`'s type is specified by `(const double&)` and not by `(const)(double)(&)`.

[*Step 2.]
We note that the element `(,)` wraps the non-alphanumeric symbol "`,`" so it needs to be replaced.
The parenthesized syntax requires no special delimiter to separate function parameters (see the __Grammar__ section) so `(,)` can simply be removed (if you like, you can use a space or a newline to separate the function parameters):

    (int) (l)( (double&)(y) ``[*=/* use spaces or newlines instead of commas to separate parameters */=]`` (const double&)(x)(=)(0.0) )

[*Step 3.]
We note also that the element `(=)` wraps the non-alphanumeric symbol "`=`" so it also needs to be replaced.
The parenthesized syntax uses the keyword `default` to specify a parameter default value (see the __Grammar__ section) so `(=)` is replaced by `(default)`:

    (int) (l)( (double&)(y) (const double&)(x)``*(default)*``(0.0) )

We are done.
The following is the valid parenthesized signature:

    (int) (l)( (double&)(y) (const double&)(x)(default)(0.0) )

for a function:

* With `int` result type.
* Named `l`.
* With one required parameter of type `double&` and named `y`.
* With an optional parameter of type `const double&`, named `x`, and with default value `0.0`.

[warning
Unfortunately, there are intrinsic limitations to the amount of syntactic error checking that can be done by the parsing macros implemented using the preprocessor.
As a consequence, an error in using the parenthesized syntax might result in *cryptic preprocessor errors*.
The best way to identify and correct these errors is usually to visually inspect the signature comparing it with the parenthesized syntax grammar (see the __Grammar__ section).
When syntactic errors can be detected by the parsing macros, they are raised at compile-time using error messages of the form `ERROR_`/description_text/.
[footnote
While there are fundamental limitations to the amount of parenthesized syntax error checking that can be done using the preprocessor (e.g., there is no way to gracefully detect and report a missing parenthesis "`)`"), the current implementation of the parsing macros does not perform all the error checking that could be done.
Improving the parenthesized syntax error checking is a work in progress.
Programmers are encouraged to report cryptic error messages they experience because of parenthesized syntax errors so to help this development effort.
]
]

[h5 Functions With No Parameters]

Let's rewrite the following C++ signature for a function with no parameters using the parenthesized syntax:

    int l()

If we wrap all the elements within parenthesis we have:

    (int) (l)``*()*`` // Error: Empty parenthesis `()` cannot be used.

However, this is not a valid parenthesized signature because it contains the empty parenthesis `()`.

[note
This limitation applies to the ISO C++ standard preprocessor but it does not apply to the C99 and other more recent preprocessors.
This library allows the *use of empty parenthesis* `()` if the preprocessor used supports empty macro parameters.
However, programmers should be well aware that if they use empty parenthesis in the parenthesized syntax, the code is not C++ ISO standard compliant and it will be less portable (that is why the use of empty parenthesis is excluded by the __Grammar__ section).
]

C++ also allows to use the keyword `void` to specify empty parameter lists.
Therefore, the original C++ function signature can be equivalently rewritten as:

    int l(void)

If we now wrap all the elements within parenthesis we obtain the valid parenthesized signature:

    (int) (l)( (void) ) // OK: Use `(void)` for empty parameter lists.

In conclusion, the parenthesized syntax requires to use `(void)` to indicate an empty parameter list (see the __Grammar__ section).

[endsect]

[section Local Functions]

Local functions are defined using the following macros (see the __Reference__ section) from within a declarative context (this is a limitation with respect to __CPP0x_lambda__ functions which can instead appear within expressions):

    { // Some declarative context.
        ...

        __BOOST_LOCAL_FUNCTION__(
        ``/parenthesized-signature/``
        ) {
            ``/local-function-body/``
        } __BOOST_LOCAL_FUNCTION_END__(``/local-function-name/``)

        ...
    }

This creates a functor object with the local function name that can be called from the enclosing scope.
Note that:

* The usual C++ scope visibility rules apply to local functions for which a local function is visible and can be called only within the enclosing scope in which it is defined.
* The local function signature is expressed using the parenthesized syntax and passed to the `__BOOST_LOCAL_FUNCTION__` macro.
* The local function body is defined in a code block `{ ... }` using the usual C++ syntax.
The body is specified outside any of the macros so eventual compiler error messages and line numbers retain their usual meaning.
[footnote
*Rationale.*
If the local function body were instead passed as a macro parameter, it would be expanded on a single line of code (because macros always expand as a single line of code).
Therefore, eventual compiler error line numbers would all have the same value and would no longer be useful to pinpoint the error.
]
* The macro `__BOOST_LOCAL_FUNCTION_END__` is used to end the local function definition and it must repeat the local function name.
[footnote
*Rationale.*
The local function name must be passed to the ending macro `__BOOST_LOCAL_FUNCTION_END__` so this macro can declare a local variable with the local function name to hold the local functor object.
At the same time, the local function name must also be passed to the declaration macro `__BOOST_LOCAL_FUNCTION__` to allow the local function to recursively call itself.
The local function declaration and ending macros are kept as two separate macros so that the local function body does not have to be passed as a macro parameter (otherwise, the compiler error line numbers will all appear on the same line and they will no longer be useful to pinpoint the errors).
]
The compiler will generate an error if the name specified by this macro does not match the one from the local function signature (see `__BOOST_LOCAL_FUNCTION_END_RENAME__` to remove this constraint).

For example, let's program a local function `add` similar to the one in the example from the __Introduction__ section.
We start by rewriting its signature:

    void add(double num)

using the parenthesized syntax:

    (void) (add)( (double)(num) )

For simplicity, we will not bind any of the variables in scope just yet (binding is explained later in this section).

Then we pass the parenthesized signature to the `__BOOST_LOCAL_FUNCTION__` macro, we implement a simple body that prints the number, and we pass the local function name `add` to the `__BOOST_LOCAL_FUNCTION_END__` macro:

[add_num_cpp]

This creates a local function `add` that can be called from within the enclosing scope as for example by the `add(100.0);` instruction.

[endsect]

[section Binding]

Variables in scope (local variables, enclosing function parameters, member variables, the object `this`, etc) can be bound to a local function declaration.
Variables in scope can be bound by reference, by constant reference, by value, or by constant value.
The types of bound variables are automatically deduced by this library using __Boost_Typeof__.
[footnote
*Rationale.*
By binding a variable in scope, the local function declaration is specifying that such a variable should be accessible within the local function body regardless of its type.
Semantically, this binding should be seen as an "extension" of the scope of the bound variable from the enclosing scope to the scope of the local function body.
Contrary to the semantics of a function parameter passing, in-scope variable binding does not depend on the variable type but just on the variable name: "The variable in scope named /x/ should be accessible within the local function named /l/".
This is especially useful for maintenance so if a bound variable type is changed, the local function declaration does not have to change.
]

[important
User defined *types need to be manually registered* as usual when using __Boost_Typeof__ (see __Boost_Typeof__ documentation and the Local Exit example from the __Examples__ section).
]

The parenthesized syntax introduces the additional "keyword" `bind` which is used to list all the bound variable names wrapped within parenthesis at the end of the local function parameter list (see the __Grammar__ section):

    (``/result-type/``) (``function-name``)( ``/parameters/`` ``*(bind)(*``(``/var1/``)(``/var2/``)``/.../``(``/varN/``)``*)*`` )

Where /var/ is the name of the variable in scope to bind and it is prefixed by `&` if the variable is bound by reference, otherwise is it bound by value.

For example, let's assume we want to bind two variables in scope `a` and `b` to the local function `l` shown before.
Let's also assume we want to bind `a` by value and `b` by reference.
Then we use the following parenthesized signature for the local function:

    (int) (l)( (double&)(y) (const double&)(x)(default)(0.0) (bind)((a)(&b)) )

If a variable is bound by value, then a copy of the variable value is taken at the point of the local function declaration.
If a variable is bound by reference instead, the variable will refer to the value it has at the point of the local function call.
Furthermore, it is the programmers' responsibility to ensure that variables bound by reference survive the scope of declaration of the local function otherwise the bound references will be invalid causing run-time errors (in other words, the usual care in using C++ references must be used for variables in scope bound by reference).
It is also possible to bind a local function to another local function as shown in the STL Transform example from the __Examples__ section (note that local functions cannot be copied so they are always bound by reference even if `&` is not specified).

The type of bound variables is automatically deduced and it is the exact same type used to declare such variables in the enclosing scope.
Therefore:

* If a bound variable was declared constant using the `const` qualifier then it will be bound by constant value or reference.
* If a bound variable was not declared constant then it will not be bound as constant.
This library allows to force constant biding even for variables that are not originally declared constant using `(const bind)(...)` as explained below.
* You might want to bind variables of complex types by (constant) reference instead than by value to avoid expensive copy operations when these variables are automatically passed to the local function (as usual with C++ function parameter passing).

For example, let's continue to program a local function `add` similar to the one from the example in __Introduction__ section.
We bind the local variable `sum` by (non-constant) reference and update the body to perform the summation:

[add_num_sum_cpp]

[h5 Constant Binding]

Constant binding allows to bind variables in scope by constant reference or constant value (constant binding is not supported by __CPP0x_lambda__ functions).
[footnote
An historical note: Constant binding of variables in scope was the main use case that originally motivated the authors in developing this library.
The authors needed to locally create a chuck of code to assert some correctness conditions while these assertions were not supposed to modify any of the variables they were using (see the __Contractpp__ library).
This was achieved by binding by constant reference the variables needed by the assertions and then by programming the local function body to check the assertions (or more conveniently by using `__BOOST_LOCAL_BLOCK__`).
This way if any of the assertions mistakenly changes a bound variable (for example confusing the operator `==` with `=`), the compiler correctly generates an error because the bound variable is of `const` type within the local function body.
]

The parenthesized syntax uses the "keywords" `const bind` to list constant bound variables wrapped within parenthesis at the end of the function parameter list (see the __Grammar__ section):

    (``/result-type/``) (``function-name``)( ``/parameters/`` ``*(const bind)(*``(``/cvar1/``)(``/cvar2/``)``/.../``(``/cvarM/``)``*)*`` )

Where /cvar/ is the name of the variable in scope to bind by constant and it is prefixed by `&` if the variable is bound by constant reference, otherwise it is bound by constant value.
If both constant and plain bindings are used, constant bindings must be specified before plain bindings (see the __Grammar__ section):

    (``/result-type/``) (``function-name``)( ``/parameters/`` (const bind)((``/cvar1/``)(``/cvar2/``)``/.../``(``/cvarM/``)) (bind)((``/var1/``)(``/var2/``)``/.../``(``/varN/``)) ) /* `(const bind)(...)` before `(bind)(...)` */

For example, let's assume we want to bind two variables in scope `c` and `d` to the local function `l` shown before.
Let's also assume we want to bind `c` by constant value and `b` by costant reference.
Then we use the following parenthesized signature for the local function:

    (int) (l)( (double&)(y) (const double&)(x)(default)(0.0) (const bind)((c)(&d)) )
    
If the variables in scope `a` and `b` are also bound but by (plain) value and reference respectively then the parenthesized signature becomes:
    
    (int) (l)( (double&)(y) (const double&)(x)(default)(0.0) (const bind)((c)(&d)) (bind)((a)(&b)) )

Note how `(const bind)(...)` must always be used before `(bind)(...)` when they are both present.

For example, let's continue to program a local function `add` similar to the one in the example from the __Introduction__ section.
We bind the local variable `factor` by constant value and update the body to perform the factor scaling:

[add_num_factor_sum_cpp]

[h5 Binding the Object `this`]

It is also possible to bind the object `this` when it is in scope (from enclosing member functions, etc).
This is done by using `this` as the name of the variable to bind and by using the special symbol `this_` (instead of `this`) to access the object within the local function body.
Note that:

* The object `this` can be bound by value using `(bind)((this)...)`.
In this case the local function will be able to modify the object when the enclosing scope is a non-constant member, or it will not be able to modify the object when the enclosing scope is a constant member.
* The object `this` can be bound by constant value `(const bind)((this)...)`.
In this case the local function will never be able to modify the object (regardless of whether the enclosing scope is a constant member or not).
* Finally, the object `this` can never be bound by reference because C++ does not allow to get a reference to `this`.
You will get a compile-time error if you try to use `(bind)((&this)...)` or `(const bind)((&this)...)`.
However, `this` is a pointer so the object is not copied even if it is bound by value.
(Note that it is not possible to bind `*this` because it starts with `*` and it is not a variable name.)

[important
When the object `this` is bound to a local function, the local function *body must use the special symbol* `this_` (instead of `this`) to access the bound object.
[footnote
*Rationale.*
This limitation comes from the fact that `this` is a reserved C++ keyword so it cannot be used as the name of the internal parameter passing the bound object to the local function body.
It would be possible to use `this` (instead of `this_`) within the local function body either at the expenses of copying the bound object (which would introduce run-time overhead and also the stringent requirement that the bound object must have a deep copy constructor) or by relying on an [@http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/d3a86f27277f713b undefined behaviour of `static_cast`] (which might not work on all platforms at the cost of portability).
]
Using `this` within the local function body will generate a compile-time error so programmers cannot mistakenly confuse the use of `this_` with `this`.
[footnote
*Rationale.*
This is because the body function is implemented as static function of the local functor class.
]
]

For example, let's rewrite a local function `add` similar to the one in the example from the __Introduction__ section but using a member function to illustrate how to bind the object `this`:

[add_this_cpp]

[endsect]

[section Local Blocks]

Local blocks are defined using the following macros within a declarative context (see the __Reference__ section):

    { // Some declarative context.
        ...

        __BOOST_LOCAL_BLOCK__( ``/parenthesized-binding/`` ) {
            ``/block-body/``
        } __BOOST_LOCAL_BLOCK_END__

        ...
    }

This expands to code that executes the body instructions in place where the block is defined.
However, only bound variables specified by the /parenthesized-binding/ are accessible from within the local block body.

Adopting a parenthesized syntax similar to the one used for local functions (see the __Grammar__ section), the /parenthesized-binding/ can specify to bind no variable:

    (void)

Or, to bind variables by constant type only:

    (const bind)((``/cvar1/``)(``/cvar2/``)``/.../``(``/cvarM/``))

Or, to bind variables by plain type only:

    (bind)((``/var1/``)(``/var2/``)``/.../``(``/varN/``))

Or, to bind variables by both constant and plain types:

    (const bind)((``/cvar1/``)(``/cvar2/``)``/.../``(``/cvarM/``)) (bind)((``/var1/``)(``/var2/``)``/.../``(``/varN/``))

Where /cvar/ and /var/ are the names of the variables in scope to bind.
They can be prefixed by `&` to bind by reference instead of by value, and one of them can be `this` to bind the object when it is in scope.

[important
A `return;` instruction from within a local block jumps to the end of the local block body and *it does not return the enclosing scope*.
[footnote
*Rationale.*
Programmers might expect `return;` to exit the enclosing function instead of the local block (or local exit), especially if the enclosing function has a `void` result type.
However, using `return;` to exit local blocks (and local exits) seemed to follow a more natural syntax and also it is the same syntax already provided by __Boost_ScopeExit__ (in fact, `return;` is used by __Boost_ScopeExit__ to exit the local scope and not to exit the enclosing scope).
However, if programmers were to find this use of `return;` confusing, this library API could be changed to forbid the use of `return` from within local blocks (and local exits) generating a compile-time error, and to use a different instruction (e.g., `break;` or a special macro instruction like `BOOST_LOCAL_RETURN;`) to exit local blocks (and local exits).
]
]

For example, let's program a local block similar to the one in the example from the __Introduction__ section:

[add_block_cpp]

[endsect]

[section Local Exits]

Local exits are defined using the following macros within a declarative context (see the __Reference__ section):

    { // Some declarative context.
        ...

        __BOOST_LOCAL_EXIT__( ``/parenthesized-binding/`` ) {
            ``/exit-body/``
        } __BOOST_LOCAL_EXIT_END__

        ...
    }

This expands to code that executes the body instructions when the enclosing scope is exited (i.e., at the very end of the enclosing scope).
If multiple local exits are defined within the same scope, their bodies will be executed in the reverse order in which they have been defined.
Only bound variables specified by /parenthesized-binding/ are accessible from within the local exit body.
The /parenthesized-biding/ is specified following the exact same syntax as for the one used by local blocks.

[note
A `return;` instruction from within a local exit jumps to the end of the local exit body and *it does not return the enclosing scope*.
]

For example, let's program a local exit similar to the one in the example from the __Introduction__ section:

[add_exit_cpp]

Local exits are very similar to the functionality already provided by __Boost_ScopeExit__ with the addition that they also support constant binding and the binding of the object `this`.
[footnote
*Rationale.*
This library could be merged together with __Boost_ScopeExit__ into a new library named Boost.Scope (from the meaning of the word "[@http://en.wikipedia.org/wiki/Scope_(programming) scope]" in computer programming).
This would be justified by the fact that `__BOOST_LOCAL_EXIT__` simply extends the functionality already provided by `BOOST_SCOPE_EXIT`.
The headers will be `"boost/scope/function.hpp"`, `"boost/scope/block.hpp"`, and `"boost/scope/exit.hpp"`.
For backward compatibility with __Boost_ScopeExit__, the header `"boost/scope_exit.hpp"` could also be kept and it would be equivalent to including `"boost/scope/exit.hpp"`.
In addition and again for backward compatibility, the `BOOST_SCOPE_EXIT` macro could be extended to accept either the original __Boost_ScopeExit__ sequence of `(var1)...(varN)` without the `bind` "keyword" (which would be equivalent to plain binding) or the parenthesized binding sequence with the `(bind)(...)` and `(const bind)(...)` "keywords" plus the binding of the object `this`.
Local blocks would be named "scope blocks" and they would be provided by the `BOOST_SCOPE_BLOCK...` macros.
However, local functions would have to be named "scope functions" and they would be provided by the `BOOST_SCOPE_FUNCTION...` macros.
This might not be ideal because local functions are not known under the name of "scope functions" (they are indeed known by the name of "local functions" or "[@http://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html nested functions]").
]

[endsect]

[section Templates]

When local functions, local blocks, and local exits are programmed within templates, they need to be declared using the following special macros ending with the `TPL` postfix (see the __Reference__ section):
[footnote
*Rationale.*
Within templates, this library needs to use `typename` to explicitly indicate that some expressions evaluate to a type.
Because C++ does not allow this use of `typename` outside templates, the special `TPL` macros are used to indicate that the enclosing scope is a template so this library can safety use `typename` to resolve expression type ambiguities.
]

    __BOOST_LOCAL_FUNCTION_TPL__( ``/parenthesized-signature/`` )
    __BOOST_LOCAL_BLOCK_TPL__( ``/parenthesized-binding/`` )
    __BOOST_LOCAL_EXIT_TPL__( ``/parenthesized-binding/`` )

These macros have the exact same API as their equivalents without the `TPL` postfix that we have seen so far.
The local function, local block, and local exit ending macros (with the `END` postfix) can be used unchanged within templates.

For example, let's rewrite an example similar to the one from the __Introduction__ section but wrapped within a template:

[add_template_cpp]

[endsect]

[endsect]

