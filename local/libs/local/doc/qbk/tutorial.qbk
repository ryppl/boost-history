
[/ Copyright (C) 2009-2011 Lorenzo Caminiti ]
[/ Use, modification, and distribution is subject to the Boost Software ]
[/ License, Version 1.0 (see accompanying file LICENSE_1_0.txt or a ]
[/ copy at http://www.boost.org/LICENSE_1_0.txt). ]

[section:Tutorial Tutorial]

This section illustrates basic usages of local functions, local blocks, and local exits.

[section Local Functions]

Local functions are defined using the following macros (see the __Reference__ section) from within a declarative context (this is a limitation with respect to __CPP0x_lambda__ functions which can instead be declared within expressions):

    #include <boost/local/function.hpp>

    ...
    { // Some declarative context.
        ...
        ``/result-type/`` __BOOST_LOCAL_FUNCTION_PARAMS__(``/parameters/``) {
            ``/body-code/``
        } __BOOST_LOCAL_FUNCTION_NAME__(``/name/``)
        ...
    }

The expansion of this macros declares a functor object with the local function name that can be called from the enclosing scope.
The usual C++ scope visibility rules apply to local functions for which a local function is visible only within the enclosing scope in which it is declared.

The local function parameters are passed to the `__BOOST_LOCAL_FUNCTION_PARAMS__` macro either using the /sequencing macro syntax/ (which separates the parameters by wrapping them within round parenthesis `()` and it is supported on all C++ compilers) or using the /variadic macro syntax/ (which separates the parameters using commas `,` but it is supported only on C99 and later compilers):

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [
`__BOOST_LOCAL_FUNCTION_PARAMS__(`[^/parameter-type1 parameter-name1/]`,` [^/parameter-type2 parameter-name2, .../]`)`
] [
`__BOOST_LOCAL_FUNCTION_PARAMS__( (`[^/parameter-type1 parameter-name1/]`) (`[^/parameter-type2 parameter-name2/]`)` [^/.../]`)`
] ]
]

The local function body is specified in a code block `{ ... }` using the usual C++ syntax.
The body is specified outside any of the macros so eventual compiler error messages and related line numbers retain their usual meaning and format.
[footnote
*Rationale.*
If the local function body were instead passed as a macro parameter, it would be expanded on a single line of code (because macros always expand as a single line of code).
Therefore, eventual compiler error line numbers would all report the same value and would no longer be useful to pinpoint the error.
]

The macro `__BOOST_LOCAL_FUNCTION_NAME__` is used to end the local function definition and to specify the local function name.
[footnote
*Rationale.*
The local function name must be passed to the macro `__BOOST_LOCAL_FUNCTION_NAME__` ending the function definition so this macro can declare a local variable with the local function name to hold the local function object.
]

For example, let's program a local function named `add` that adds together two integer numbers `x` and `y` -- for simplicity, we will not bind any of the variables in scope just yet (binding is explained later in this section):

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_x_y_va_cpp] ] [ [add_x_y_cpp] ] ]
]

The maximum number of parameters that can be passed to a local function (excluding eventual bound variables) is controlled at compile-time by the configuration macro `__BOOST_LOCAL_CONFIG_FUNCTION_ARITY_MAX__`.
The variadic macro syntax is always disabled when the configuration macro `__BOOST_LOCAL_CONFIG_COMPLIANT__` is defined.

[endsect]

[section:Empty_Parameters Empty Parameters]

C++ allows to specify a function with no parameters using the empty parenthesis `()`.
For example, let's program a function `ten` which takes no parameter and returns the integer number `10`:

    int ten() {
        return 10;
    }

The ISO C++ standard does not allow pass empty parameters to a macro so the macro `__BOOST_LOCAL_FUNCTION_PARAMS__` cannot be invoked with an empty set of parenthesis `()` unless programmers use compiler extensions that support empty macro parameters (e.g., C99 and other modern compilers).
However, C++ also allows to specify an empty parameter list using the keyword `void`:

    int ten(void) {
        return 10;
    }

Therefore, on all C++ compilers the macro `__BOOST_LOCAL_FUNCTION_PARAMS__` can be invoked passing one parameter `(void)` to specify an empty parameter list.
In addition, on compilers that support variadic macros, the macro `__BOOST_LOCAL_FUNCTION_PARAMS__` can be invoked passing one parameter `void` (without the extra parenthesis).
In summary, depending on your compiler support for empty macro parameters and variadic macros, this library accepts the following syntaxes to specify an empty parameter list:

[table
[ [__Empty_Macro_Syntax__] [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [
`__BOOST_LOCAL_FUNCTION_PARAMS__()`
] [
`__BOOST_LOCAL_FUNCTION_PARAMS__(void)`
] [
`__BOOST_LOCAL_FUNCTION_PARAMS__( (void) )`
] ]
]

For example, let's program the function `ten` as a local function:

[table
[ [__Empty_Macro_Syntax__] [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [ten_ep_cpp] ] [ [ten_va_cpp] ] [ [ten_cpp] ] ]
]

Note that not all compilers that support variadic macros also support empty macro parameters.
Both the empty macro syntax and variadic macro syntax are always disabled when the configuration macro `__BOOST_LOCAL_CONFIG_COMPLIANT__` is defined.

[endsect]

[section Default Parameters]

This library also allows to specify default values for the local function parameters.
However, the usual C++ syntax for default parameters that uses the assignment symbol `=` cannot be used.
[footnote
[*Rationale.] The assignment symbol `=` cannot be used to specify default parameter values because default values are not part of the parameter type so they cannot be handled using template metaprogamming.
Default parameter values need to be separated from the rest of the parameter declaration using the preprocessor.
Specifically, this library needs to use preprocessor mataprogramming to remove default values when constructing the local function type and then to count the number of default values to provide the correct set of call operators for the local functor.
Therefore, the symbol `=` cannot be used because it cannot be handled by preprocessor metaprogramming (specifically, such a non-alphanumeric symbol cannot be detected by preprocessor metaprogramming because it cannot be concatenated by the preprocessor).
]
The keyword `default` is used instead:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [
[^/parameter-type parameter-name/]`, default` [^/parameter-default-value/]`,` [^/.../]
] [
`(`[^/parameter-type parameter-name/]`)(default` [^/parameter-default-value/]`)` [^/.../]
] ]
]

For example, let's program a local function `add(x, y)` similar to the one programmed before but where the second parameter `y` is optional and has a default value of `2`:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_x_y_default_va_cpp] ] [ [add_x_y_default_cpp] ] ]
]

If this variadic macro syntax seems strange, programmers can define a `WITH_DEFAULT` macro similar to the following (if they think that improves readability):

[table
[ [__Variadic_Macro_Syntax__] ]
[ [ [add_x_y_default_with_va_cpp] ] ]
]

[endsect]

[section:Binding Binding]

Variables in scope (local variables, enclosing function parameters, member variables, the object `this`, etc) can be bound to a local function declaration.
The types of bound variables are automatically deduced by this library using __Boost_Typeof__.
[footnote
*Rationale.*
By binding a variable in scope, the local function declaration is specifying that such a variable should be accessible within the local function body regardless of its type.
Semantically, this binding should be seen as an "extension" of the scope of the bound variable from the enclosing scope to the scope of the local function body.
Therefore, contrary to the semantic of passing a function parameter, the semantic of binding a variable not depend on the variable type but just on the variable name: "The variable in scope named /x/ should be accessible within the local function named /l/".
For example, this is useful for maintenance because if a bound variable type is changed, the local function declaration does not have to change.
]

[important
User defined types need to be manually registered as usual when using __Boost_Typeof__ (see the __Boost_Typeof__ documentation and the __Examples_Boost_Typeof_for_User_Defined_Types__ example).
]

This library introduces the new "keyword" `bind`
[footnote
Obviously, the token `bind` is not a keyword of the C++ language.
This library parses the token `bind` during macro expansion using preprocessor metaprogramming (see the __Implementation__ section).
Therefore, `bind` can be considered a new "keyword" only at the preprocessor metaprogramming level within the syntax defined by the macros of this library -- thus it is referred to as a "keyword" only within quotes.
]
which is used in place of the parameter type to specify the name of a variable in scope to bind.
The variable can be bound by value:
    
    bind ``/variable-name/`` // Bind by value.
    
Or by reference prefixing the variable name with `&`:

    bind& ``/variable-name/`` // Bind by reference.
    
Furthermore, the "keyword" `bind` can be prefixed by `const` to bind the variable by constant value:
    
    const bind ``/variable-name/`` // Bind by constant value.

Or by constant reference:
    
    const bind& ``/variable-name/`` // Bind by constant value.

Note that when `const` is used, it must always precede `bind`.
[footnote
*Rationale.*
The library macros could have been implemented to accept both syntaxes `const bind ...` and `bind const ...` equivalently.
However, handling both syntaxes would have complicated the macro implementation without adding any feature so only one syntax (`const bind ...`) is supported.
]
    
If a variable is bound by value, then a copy of the variable value is taken at the point of the local function declaration.
If a variable is bound by reference instead, the variable will refer to the value it has at the point of the local function call.
Furthermore, it is the programmers' responsibility to ensure that variables bound by reference survive the declaration scope of the local function otherwise the bound references will be invalid causing run-time errors (in other words, the usual care in using C++ references must be taken for variables bound by reference).

The type of a bound variable is automatically deduced and it is the exact same type used to declare such a variable in the enclosing scope.

* If a bound variable was declared constant in the enclosing scope, it will be always bound by constant value or constant reference even if `bind ...` is used instead of `const bind ...` .
However, if a bound variable was not declared constant in the enclosing scope then it will not be bound as constant unless constant binding is forced using `const bind ...`. (Note that binding by constant reference is not supported by __CPP0x_lambda__ functions but it is supported by this library.)
[footnote
An historical note: Constant binding of variables in scope was the main use case that originally motivated the authors in developing this library.
The authors needed to locally create a chuck of code to assert some correctness conditions while these assertions were not supposed to modify any of the variables they were using (see the __Contractpp__ library).
This was achieved by binding by constant reference the variables needed by the assertions and then by programming the local function body to check the assertions (or more conveniently by using `__BOOST_LOCAL_BLOCK__`).
This way if any of the assertions mistakenly changes a bound variable (for example confusing the operator `==` with `=`), the compiler correctly generates an error because the bound variable is of `const` type within the local function body.
]
* If a bound variable was declared as a reference in the enclosing scope, it will still be bound by value unless it is explicitly bound by reference using `bind& ...` or `const bind& ...`.
[footnote
*Rationale.*
Variables originally declared as references are bound by value unless `[const] bind&` is used so that references can be bound by both value `[const] bind` and reference `[const] bind&` (this is the same binding semantic adopted by __Boost_ScopeExit__).
On the other hand, variables originally declared as constants should never loose their `const` qualifier (to prevent their modification not just in the enclosing scope but also in the local scope) thus they are always bound by constant even if `bind[&]` is used instead of `const bind[&]`.
]

As with passing parameters to usual C++ functions, programmers might want to bind variables of complex types by (constant) reference instead than by value to avoid expensive copy operations when these variables are bound to a local function.

For example, let's program a local function `add` similar to the one in the example from the __Introduction__ section.
We bind the local variable `factor` by constant value, the local variable `sum` by (non-constant) reference, and program the body to perform the summation:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_function_va_cpp] ] [ [add_function_cpp] ] ]
]

[h5 Binding the Object `this`]

It is also possible to bind the object `this` when it is in scope (e.g., from an enclosing member function).
This is done by using `this` as the name of the variable to bind in the local function declaration and by using the special symbol `this_`
[footnote
*Rationale.*
The special name `this_` was chosen following [@http://boost.2283326.n4.nabble.com/local-this-or-this-td3423912.html Boost practises] which postfix with an underscore identifiers that are named after keywords (the C++ keyword `this` in this case).
]
(instead of `this`) to access the object within the local function body.

The object `this` can be bound by value:

    bind this // Bind the object `this` by value.

In this case the local function will be able to modify the object when the enclosing scope is not a constant member, or it will not be able to modify the object when the enclosing scope is a constant member.
Otherwise, the object `this` can be bound by constant value:

    const bind this // Bind the object `this` by constant value.

In this case the local function will never be able to modify the object (regardless of whether the enclosing scope is a constant member or not).

Note that the object `this` can never be bound by reference because C++ does not allow to obtain a reference to `this` (the library will generate a compile-time error if programmers try to use `bind& this` or `const bind& this`).
Note that `this` is a pointer so the pointed object is never copied even if `this` is bound by value (also it is not allowed to directly bind `*this` because `*this` is an expression and not a valid name of a variable in scope).

[warning
When the object `this` is bound to a local function, the local function body must use the special symbol `this_` (instead of `this`) to access the bound object.
[footnote
*Rationale.*
This limitation comes from the fact that `this` is a reserved C++ keyword so it cannot be used as the name of the internal parameter that passes the bound object to the local function body.
It would have been possible to use `this` (instead of `this_`) within the local function body either at the expenses of copying the bound object (which would introduce run-time overhead and also the stringent requirement that the bound object must have a deep copy constructor) or by relying on an [@http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/d3a86f27277f713b undefined behaviour of `static_cast`] (which might not work on all platforms at the cost of portability).
]

Unfortunately, mistakenly using `this` within the local function body instead of `this_` will not necessarily generate a compile-time error.
[footnote
*Rationale.*
The local function body cannot be a static member function of the local functor object in order to support recursion (because the local function name is specified by the `__BOOST_LOCAL_FUNCTION_NAME__` macro only after the body so it must be made available via a functor member variable named after the local function and local classes cannot have static member variables in C++) and nesting (because the argument binding variable must be declared as a member variable so it is visible in a local function nested within the body member function) -- see the __Implementation__ section.
Therefore, from within the local function body the variable `this` is visible but it refers to the local functor and not to the bound object.
]
Programmers are responsible to make sure that `this` is never used within a local function body which should only use the special symbol `this_`.
]

For example, let's program a local function `add` similar to the one in the example from the __Introduction__ section but using a member function to illustrate how to bind the object `this`:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_this_va_cpp] ] [ [add_this_cpp] ] ]
]

The special name `this_` used to replace the bound object name `this` is controlled at compile-time by the configuration macro `__BOOST_LOCAL_CONFIG_THIS_PARAM_NAME__`.

[endsect]

[section Local Blocks]

Local blocks are defined using the following macros within a declarative context (see the __Reference__ section):

    #include <boost/local/block.hpp>

    ...
    { // Some declarative context.
        ...
        __BOOST_LOCAL_BLOCK__(``/bindings/``) {
            ``/body-code/``
        } __BOOST_LOCAL_BLOCK_END__
        ...
    }

These macros expand to code that executes the body instructions "in place" where the block is defined.

Only bound variables specified by [^/bindings/] are accessible from within the local block body.
Following the same syntax used for local functions, [^['bindings]] can either be empty (using `(void)`, `void`, or an empty macro parameter depending on your compiler, see __Tutorial_Empty_Parameters__), or they can list the variables to bind using the "keyword" `bind` in place of the parameter type, using `const bind` for constant binding, prefixing the bound variable name with `&` to bind by reference, and using `this` to bind the object in scope (see __Tutorial_Binding__).

[important
A `return;` instruction from within a local block jumps to the end of the local block body and it does not return the enclosing function.
[footnote
*Rationale.*
Programmers might expect `return;` to exit the enclosing function instead of the local block (or local exit), especially if the enclosing function has a `void` result type.
However, using `return;` to exit local blocks (and local exits) seemed to follow a natural syntax and also it is the same syntax already provided by __Boost_ScopeExit__ (in fact, `return;` is used by __Boost_ScopeExit__ to exit the local scope and not to exit the enclosing scope).
If programmers were to find this use of `return;` confusing, this library API could be changed to forbid the use of `return` from within local blocks (and local exits) generating a compile-time error, and to use a different instruction (e.g., `break;` or a special macro instruction like `BOOST_LOCAL_RETURN;`) to exit local blocks (and local exits).
]
]

For example, let's program a local block similar to the one in the example from the __Introduction__ section:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_block_va_cpp] ] [ [add_block_cpp] ] ]
]

[endsect]

[section Local Exits]

Local exits are defined using the following macros within a declarative context (see the __Reference__ section):

    #include <boost/local/exit.hpp>

    ...
    { // Some declarative context.
        ...
        __BOOST_LOCAL_EXIT__(``/bindings/``) {
            ``/body-code/``
        } __BOOST_LOCAL_EXIT_END__
        ...
    }

These macros expand to code that executes the body instructions when the enclosing scope is exited (e.g., at the very end of the enclosing scope).
If multiple local exits are declared within the same scope, their bodies will be executed in the reverse order in which they have been declared.

[note
The execution of the local exit body code is guaranteed only if the program does not terminate because of an uncaught exception.
[footnote
*Rationale.*
This library (as well as __Boost_ScopeExit__) uses the destructor of a local variable to automatically execute the local exit code upon exit of the enclosing scope.
However, in C++ it is no possible to (portably) ensure the execution of the destructor of all objects if the main program terminates because of an uncaught exception.
(This is different from the D programming language which executes the scope exit code even if the main program terminates because of an uncaught exception.)
]
]

Only bound variables specified by [^['bindings]] are accessible from within the local exit body.
Following the same syntax used for local functions, [^['bindings]] can either be empty (using `(void)`, `void`, or an empty macro parameter depending on your compiler, see __Tutorial_Empty_Parameters__), or they can list the variables to bind using the "keyword" `bind` in place of the parameter type, using `const bind` for constant binding, prefixing the bound variable name with `&` to bind by reference, and using `this` to bind the object in scope (see __Tutorial_Binding__).

[important
A `return;` instruction from within a local exit jumps to the end of the local exit body and it does not return the enclosing function.
]

For example, let's program a local exit similar to the one in the example from the __Introduction__ section:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_exit_va_cpp] ] [ [add_exit_cpp] ] ]
]

Local exits are very similar to the /scope exits/ provided by __Boost_ScopeExit__ with the addition that they also support constant binding and binding of the object `this`.
[footnote
*Rationale.*
This library could be merged together with __Boost_ScopeExit__ into a new library named Boost.Scope (from the meaning of the word "[@http://en.wikipedia.org/wiki/Scope_(programming) scope]" in computer programming).
This would be justified by the fact that `__BOOST_LOCAL_EXIT__` simply extends the functionality already provided by `BOOST_SCOPE_EXIT`.
The headers will be `"boost/scope/function.hpp"`, `"boost/scope/block.hpp"`, and `"boost/scope/exit.hpp"` (for backward compatibility with __Boost_ScopeExit__, the header `"boost/scope_exit.hpp"` could also be kept and it would be equivalent to including `"boost/scope/exit.hpp"`).
However, the new `BOOST_SCOPE_EXIT` macro will not be backward compatible with the current __Boost_ScopeExit__ macro because it will require to prefix the bound variable with `bind` or `const bind` (in order to differentiate from constant and non-constant binding and to prevent the bound tokens from ever starting with a non-alphanumeric symbol like `&`).
Local blocks would be named "scope blocks" and they would be provided by the `BOOST_SCOPE_BLOCK...` macros (the "scope block" name seems reasonably expressive).
However, local functions would have to be named "scope functions" and they would be provided by the `BOOST_SCOPE_FUNCTION...` macros.
This name might not be expressive enough because local functions are not known under the name of "scope functions" -- they are indeed known by either the name of "local functions" or by the name of "[@http://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html nested functions]" (GCC compiler extension).
]
Local exits can be used to emulate the __D_Programming_Language__ /scope guards/ (see the __Examples_Emulating_Ds_Scope_Guards__ example).

[endsect]

[section Templates]

When local functions, local blocks, and local exits are programmed within templates, they need to be declared using the following special macros ending with the `TPL` postfix (see the __Reference__ section):
[footnote
*Rationale.*
Within templates, this library needs to use `typename` to explicitly indicate that some expressions evaluate to a type.
Because C++ does not allow this use of `typename` outside templates, the special `TPL` macros are used to indicate that the enclosing scope is a template so this library can safety use `typename` to resolve expression type ambiguities.
]

    __BOOST_LOCAL_FUNCTION_PARAMS_TPL__(``/parameters/``)
    __BOOST_LOCAL_BLOCK_TPL__(``/bindings/``)
    __BOOST_LOCAL_EXIT_TPL__(``/bindings/``)

These macros have the exact same API as their equivalent macros without the `TPL` postfix that we have seen so far.

For example, let's rewrite a local function, a local exit, and a local block similar to the ones from the __Introduction__ section but wrapped within a template:

[table
[ [__Variadic_Macro_Syntax__] [__Sequencing_Macro_Syntax__] ]
[ [ [add_template_va_cpp] ] [ [add_template_cpp] ] ]
]

[endsect]

[endsect]

