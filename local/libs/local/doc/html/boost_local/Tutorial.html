<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Tutorial</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../index.html" title="Boost.Local 0.1.1">
<link rel="up" href="../index.html" title="Boost.Local 0.1.1">
<link rel="prev" href="Starting.html" title="Starting">
<link rel="next" href="Advanced.html" title="Advanced">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="Starting.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="Advanced.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_local.Tutorial"></a><a class="link" href="Tutorial.html" title="Tutorial">Tutorial</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="Tutorial.html#boost_local.Tutorial.parenthesized_syntax">Parenthesized
      Syntax</a></span></dt>
<dt><span class="section"><a href="Tutorial.html#boost_local.Tutorial.local_functions">Local Functions</a></span></dt>
<dt><span class="section"><a href="Tutorial.html#boost_local.Tutorial.binding">Binding</a></span></dt>
<dt><span class="section"><a href="Tutorial.html#boost_local.Tutorial.local_blocks">Local Blocks</a></span></dt>
<dt><span class="section"><a href="Tutorial.html#boost_local.Tutorial.local_exits">Local Exits</a></span></dt>
<dt><span class="section"><a href="Tutorial.html#boost_local.Tutorial.templates">Templates</a></span></dt>
</dl></div>
<p>
      This section illustrates basic usages of local functions, local blocks, and
      local exits.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_local.Tutorial.parenthesized_syntax"></a><a class="link" href="Tutorial.html#boost_local.Tutorial.parenthesized_syntax" title="Parenthesized Syntax">Parenthesized
      Syntax</a>
</h3></div></div></div>
<p>
        The <span class="emphasis"><em>parenthesized syntax</em></span> is used to pass the syntactic
        elements of a function signature as macro parameters in a way that resembles
        the usual C++ syntax. All the function signature elements are wrapped within
        round parenthesis <code class="computeroutput"><span class="special">()</span></code> to form
        a <a href="http://www.boost.org/doc/libs/release/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
        sequence called <span class="emphasis"><em>parenthesized signature</em></span>. This allows
        to program preprocessor macros that can parse the parenthesized syntax expanding
        differently based on the different elements that are specified in the signature
        (if the function has parameters or not, if the result type token matches
        the <code class="computeroutput"><span class="keyword">void</span></code> keyword or not, etc).
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../../../../doc/src/images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top">
<p>
          The <span class="bold"><strong>general rules to program the parenthesized signature</strong></span>
          are:
        </p>
<p>
          1. Wrap all the signature syntactic elements within parenthesis <code class="computeroutput"><span class="special">()</span></code>. <sup>[<a name="id865394" href="#ftn.id865394" class="footnote">2</a>]</sup>
        </p>
<p>
          2. If a token does not start with an alphanumeric symbol (i.e., <code class="computeroutput"><span class="identifier">a</span><span class="special">-</span><span class="identifier">z</span></code>,
          <code class="computeroutput"><span class="identifier">A</span><span class="special">-</span><span class="identifier">Z</span></code>, or <code class="computeroutput"><span class="number">0</span><span class="special">-</span><span class="number">9</span></code>), replace
          the token with its alphanumeric equivalent (as indicated in the <a class="link" href="Grammar.html" title="Appendix: Grammar">Grammar</a>
          section). <sup>[<a name="id865521" href="#ftn.id865521" class="footnote">3</a>]</sup>
        </p>
<p>
          3. Empty parenthesis <code class="computeroutput"><span class="special">()</span></code> are
          not allowed. <sup>[<a name="id865557" href="#ftn.id865557" class="footnote">4</a>]</sup>
        </p>
<p>
          4. Spaces and newlines do not matter and they can be used anywhere.
        </p>
</td></tr>
</table></div>
<p>
        For example, let's rewrite the following C++ function signature using the
        parenthesized syntax:
      </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">l</span><span class="special">(</span><span class="keyword">double</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">double</span><span class="special">&amp;</span> <span class="identifier">x</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">)</span>
</pre>
<p>
        <span class="bold"><strong>Step 1.</strong></span> We start by wrapping all the syntactic
        elements within round parenthesis <code class="computeroutput"><span class="special">()</span></code>:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">(</span><span class="identifier">l</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">y</span><span class="special">)</span> <span class="special">(,)</span> <span class="special">(</span><span class="keyword">const</span> <span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">x</span><span class="special">)(=)(</span><span class="number">0.0</span><span class="special">)</span> <span class="special">)</span> <span class="bold"><strong><code class="literal">/* wrap all elements within parenthesis `()` */</code></strong></span>
</pre>
<p>
        Note how parameter types are wrapped within parenthesis separately from parameter
        names. However, all the tokens of a parameter type are wrapped together within
        a single set of parenthesis because the parameter type is one single syntactic
        element of the function signature. For example, <code class="computeroutput"><span class="identifier">x</span></code>'s
        type is specified by <code class="computeroutput"><span class="special">(</span><span class="keyword">const</span>
        <span class="keyword">double</span><span class="special">&amp;)</span></code>
        and not by <code class="computeroutput"><span class="special">(</span><span class="keyword">const</span><span class="special">)(</span><span class="keyword">double</span><span class="special">)(&amp;)</span></code>.
      </p>
<p>
        <span class="bold"><strong>Step 2.</strong></span> We note that the element <code class="computeroutput"><span class="special">(,)</span></code> wraps the non-alphanumeric symbol "<code class="computeroutput"><span class="special">,</span></code>" so it needs to be replaced. The parenthesized
        syntax requires no special delimiter to separate function parameters (see
        the <a class="link" href="Grammar.html" title="Appendix: Grammar">Grammar</a> section) so <code class="computeroutput"><span class="special">(,)</span></code> can simply be removed (if you like, you
        can use a space or a newline to separate the function parameters):
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">(</span><span class="identifier">l</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">y</span><span class="special">)</span> <span class="bold"><strong><code class="literal">/* use spaces or newlines instead of commas to separate parameters */</code></strong></span> <span class="special">(</span><span class="keyword">const</span> <span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">x</span><span class="special">)(=)(</span><span class="number">0.0</span><span class="special">)</span> <span class="special">)</span>
</pre>
<p>
        <span class="bold"><strong>Step 3.</strong></span> We note also that the element <code class="computeroutput"><span class="special">(=)</span></code> wraps the non-alphanumeric symbol "<code class="computeroutput"><span class="special">=</span></code>" so it also needs to be replaced. The
        parenthesized syntax uses the keyword <code class="computeroutput"><span class="keyword">default</span></code>
        to specify a parameter default value (see the <a class="link" href="Grammar.html" title="Appendix: Grammar">Grammar</a>
        section) so <code class="computeroutput"><span class="special">(=)</span></code> is replaced
        by <code class="computeroutput"><span class="special">(</span><span class="keyword">default</span><span class="special">)</span></code>:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">(</span><span class="identifier">l</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">y</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">x</span><span class="special">)</span><span class="bold"><strong>(default)</strong></span><span class="special">(</span><span class="number">0.0</span><span class="special">)</span> <span class="special">)</span>
</pre>
<p>
        We are done. The following is the valid parenthesized signature:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">(</span><span class="identifier">l</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">y</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">x</span><span class="special">)(</span><span class="keyword">default</span><span class="special">)(</span><span class="number">0.0</span><span class="special">)</span> <span class="special">)</span>
</pre>
<p>
        for a function:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            With <code class="computeroutput"><span class="keyword">int</span></code> result type.
          </li>
<li class="listitem">
            Named <code class="computeroutput"><span class="identifier">l</span></code>.
          </li>
<li class="listitem">
            With one required parameter of type <code class="computeroutput"><span class="keyword">double</span><span class="special">&amp;</span></code> and named <code class="computeroutput"><span class="identifier">y</span></code>.
          </li>
<li class="listitem">
            With an optional parameter of type <code class="computeroutput"><span class="keyword">const</span>
            <span class="keyword">double</span><span class="special">&amp;</span></code>,
            named <code class="computeroutput"><span class="identifier">x</span></code>, and with default
            value <code class="computeroutput"><span class="number">0.0</span></code>.
          </li>
</ul></div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          Unfortunately, there are intrinsic limitations to the amount of syntactic
          error checking that can be done by the parsing macros implemented using
          the preprocessor. As a consequence, an error in using the parenthesized
          syntax might result in <span class="bold"><strong>cryptic preprocessor errors</strong></span>.
          The best way to identify and correct these errors is usually to visually
          inspect the signature comparing it with the parenthesized syntax grammar
          (see the <a class="link" href="Grammar.html" title="Appendix: Grammar">Grammar</a> section). When
          syntactic errors can be detected by the parsing macros, they are raised
          at compile-time using error messages of the form <code class="computeroutput"><span class="identifier">ERROR_</span></code><span class="emphasis"><em>description_text</em></span>.
          <sup>[<a name="id866504" href="#ftn.id866504" class="footnote">5</a>]</sup>
        </p></td></tr>
</table></div>
<a name="boost_local.Tutorial.parenthesized_syntax.functions_with_no_parameters"></a><h6>
<a name="id866543"></a>
        <a class="link" href="Tutorial.html#boost_local.Tutorial.parenthesized_syntax.functions_with_no_parameters">Functions
        With No Parameters</a>
      </h6>
<p>
        Let's rewrite the following C++ signature for a function with no parameters
        using the parenthesized syntax:
      </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">l</span><span class="special">()</span>
</pre>
<p>
        If we wrap all the elements within parenthesis we have:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">(</span><span class="identifier">l</span><span class="special">)</span><span class="bold"><strong>()</strong></span> <span class="comment">// Error: Empty parenthesis `()` cannot be used.
</span></pre>
<p>
        However, this is not a valid parenthesized signature because it contains
        the empty parenthesis <code class="computeroutput"><span class="special">()</span></code>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          This limitation applies to the ISO C++ standard preprocessor but it does
          not apply to the C99 and other more recent preprocessors. This library
          allows the <span class="bold"><strong>use of empty parenthesis</strong></span> <code class="computeroutput"><span class="special">()</span></code> if the preprocessor used supports empty
          macro parameters. However, programmers should be well aware that if they
          use empty parenthesis in the parenthesized syntax, the code is not C++
          ISO standard compliant and it will be less portable (that is why the use
          of empty parenthesis is excluded by the <a class="link" href="Grammar.html" title="Appendix: Grammar">Grammar</a>
          section).
        </p></td></tr>
</table></div>
<p>
        C++ also allows to use the keyword <code class="computeroutput"><span class="keyword">void</span></code>
        to specify empty parameter lists. Therefore, the original C++ function signature
        can be equivalently rewritten as:
      </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">l</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
</pre>
<p>
        If we now wrap all the elements within parenthesis we obtain the valid parenthesized
        signature:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">(</span><span class="identifier">l</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">)</span> <span class="comment">// OK: Use `(void)` for empty parameter lists.
</span></pre>
<p>
        In conclusion, the parenthesized syntax requires to use <code class="computeroutput"><span class="special">(</span><span class="keyword">void</span><span class="special">)</span></code> to indicate
        an empty parameter list (see the <a class="link" href="Grammar.html" title="Appendix: Grammar">Grammar</a>
        section).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_local.Tutorial.local_functions"></a><a class="link" href="Tutorial.html#boost_local.Tutorial.local_functions" title="Local Functions">Local Functions</a>
</h3></div></div></div>
<p>
        Local functions are defined using the following macros (see the <a href="../reference.html" target="_top">Reference</a>
        section) from within a declarative context (this is a limitation with respect
        to <a href="http://en.wikipedia.org/wiki/C%2B%2B0x#Lambda_functions_and_expressions" target="_top">C++0x
        lambda</a> functions which can instead appear within expressions):
      </p>
<pre class="programlisting"><span class="special">{</span> <span class="comment">// Some declarative context.
</span>    <span class="special">...</span>

    <code class="computeroutput">BOOST_LOCAL_FUNCTION</code><span class="special">(</span>
    <span class="emphasis"><em>parenthesized-signature</em></span>
    <span class="special">)</span> <span class="special">{</span>
        <span class="emphasis"><em>local-function-body</em></span>
    <span class="special">}</span> <code class="computeroutput">BOOST_LOCAL_FUNCTION_END</code><span class="special">(</span><span class="emphasis"><em>local-function-name</em></span><span class="special">)</span>

    <span class="special">...</span>
<span class="special">}</span>
</pre>
<p>
        This creates a functor object with the local function name that can be called
        from the enclosing scope. Note that:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            The usual C++ scope visibility rules apply to local functions for which
            a local function is visible and can be called only within the enclosing
            scope in which it is defined.
          </li>
<li class="listitem">
            The local function signature is expressed using the parenthesized syntax
            and passed to the <code class="computeroutput">BOOST_LOCAL_FUNCTION</code>
            macro.
          </li>
<li class="listitem">
            The local function body is defined in a code block <code class="computeroutput"><span class="special">{</span>
            <span class="special">...</span> <span class="special">}</span></code>
            using the usual C++ syntax. The body is specified outside any of the
            macros so eventual compiler error messages and line numbers retain their
            usual meaning. <sup>[<a name="id867024" href="#ftn.id867024" class="footnote">6</a>]</sup>
          </li>
<li class="listitem">
            The macro <code class="computeroutput">BOOST_LOCAL_FUNCTION_END</code>
            is used to end the local function definition and it must repeat the local
            function name. <sup>[<a name="id867054" href="#ftn.id867054" class="footnote">7</a>]</sup> The compiler will generate an error if the name specified
            by this macro does not match the one from the local function signature
            (see <code class="computeroutput">BOOST_LOCAL_FUNCTION_END_RENAME</code>
            to remove this constraint).
          </li>
</ul></div>
<p>
        For example, let's program a local function <code class="computeroutput"><span class="identifier">add</span></code>
        similar to the one in the example from the <a class="link" href="../index.html#boost_local.Introduction" title="Introduction">Introduction</a>
        section. We start by rewriting its signature:
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">add</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">num</span><span class="special">)</span>
</pre>
<p>
        using the parenthesized syntax:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">add</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">double</span><span class="special">)(</span><span class="identifier">num</span><span class="special">)</span> <span class="special">)</span>
</pre>
<p>
        For simplicity, we will not bind any of the variables in scope just yet (binding
        is explained later in this section).
      </p>
<p>
        Then we pass the parenthesized signature to the <code class="computeroutput">BOOST_LOCAL_FUNCTION</code>
        macro, we implement a simple body that prints the number, and we pass the
        local function name <code class="computeroutput"><span class="identifier">add</span></code> to
        the <code class="computeroutput">BOOST_LOCAL_FUNCTION_END</code>
        macro:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">local</span><span class="special">/</span><span class="identifier">function</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_PARAMS</span><span class="special">(</span> <span class="special">(</span><span class="keyword">double</span> <span class="identifier">num</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">clog</span> <span class="special">&lt;&lt;</span> <span class="identifier">num</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME</span><span class="special">(</span><span class="identifier">add</span><span class="special">)</span>

    <span class="identifier">add</span><span class="special">(</span><span class="number">100.0</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        This creates a local function <code class="computeroutput"><span class="identifier">add</span></code>
        that can be called from within the enclosing scope as for example by the
        <code class="computeroutput"><span class="identifier">add</span><span class="special">(</span><span class="number">100.0</span><span class="special">);</span></code> instruction.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_local.Tutorial.binding"></a><a class="link" href="Tutorial.html#boost_local.Tutorial.binding" title="Binding">Binding</a>
</h3></div></div></div>
<p>
        Variables in scope (local variables, enclosing function parameters, member
        variables, the object <code class="computeroutput"><span class="keyword">this</span></code>,
        etc) can be bound to a local function declaration. Variables in scope can
        be bound by reference, by constant reference, by value, or by constant value.
        The types of bound variables are automatically deduced by this library using
        <a href="http://www.boost.org/doc/libs/release/doc/html/typeof.html" target="_top">Boost.Typeof</a>.
        <sup>[<a name="id867618" href="#ftn.id867618" class="footnote">8</a>]</sup>
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../../../../doc/src/images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
          User defined <span class="bold"><strong>types need to be manually registered</strong></span>
          as usual when using <a href="http://www.boost.org/doc/libs/release/doc/html/typeof.html" target="_top">Boost.Typeof</a>
          (see <a href="http://www.boost.org/doc/libs/release/doc/html/typeof.html" target="_top">Boost.Typeof</a>
          documentation and the Local Exit example from the <a class="link" href="Examples.html" title="Appendix: Examples">Examples</a>
          section).
        </p></td></tr>
</table></div>
<p>
        The parenthesized syntax introduces the additional "keyword" <code class="computeroutput"><span class="identifier">bind</span></code> which is used to list all the bound
        variable names wrapped within parenthesis at the end of the local function
        parameter list (see the <a class="link" href="Grammar.html" title="Appendix: Grammar">Grammar</a>
        section):
      </p>
<pre class="programlisting"><span class="special">(</span><span class="emphasis"><em>result-type</em></span><span class="special">)</span> <span class="special">(</span>function-name<span class="special">)(</span> <span class="emphasis"><em>parameters</em></span> <span class="bold"><strong>(bind)(</strong></span><span class="special">(</span><span class="emphasis"><em>var1</em></span><span class="special">)(</span><span class="emphasis"><em>var2</em></span><span class="special">)</span><span class="emphasis"><em>...</em></span><span class="special">(</span><span class="emphasis"><em>varN</em></span><span class="special">)</span><span class="bold"><strong>)</strong></span> <span class="special">)</span>
</pre>
<p>
        Where <span class="emphasis"><em>var</em></span> is the name of the variable in scope to bind
        and it is prefixed by <code class="computeroutput"><span class="special">&amp;</span></code>
        if the variable is bound by reference, otherwise is it bound by value.
      </p>
<p>
        For example, let's assume we want to bind two variables in scope <code class="computeroutput"><span class="identifier">a</span></code> and <code class="computeroutput"><span class="identifier">b</span></code>
        to the local function <code class="computeroutput"><span class="identifier">l</span></code> shown
        before. Let's also assume we want to bind <code class="computeroutput"><span class="identifier">a</span></code>
        by value and <code class="computeroutput"><span class="identifier">b</span></code> by reference.
        Then we use the following parenthesized signature for the local function:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">(</span><span class="identifier">l</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">y</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">x</span><span class="special">)(</span><span class="keyword">default</span><span class="special">)(</span><span class="number">0.0</span><span class="special">)</span> <span class="special">(</span><span class="identifier">bind</span><span class="special">)((</span><span class="identifier">a</span><span class="special">)(&amp;</span><span class="identifier">b</span><span class="special">))</span> <span class="special">)</span>
</pre>
<p>
        If a variable is bound by value, then a copy of the variable value is taken
        at the point of the local function declaration. If a variable is bound by
        reference instead, the variable will refer to the value it has at the point
        of the local function call. Furthermore, it is the programmers' responsibility
        to ensure that variables bound by reference survive the scope of declaration
        of the local function otherwise the bound references will be invalid causing
        run-time errors (in other words, the usual care in using C++ references must
        be used for variables in scope bound by reference). It is also possible to
        bind a local function to another local function as shown in the STL Transform
        example from the <a class="link" href="Examples.html" title="Appendix: Examples">Examples</a> section
        (note that local functions cannot be copied so they are always bound by reference
        even if <code class="computeroutput"><span class="special">&amp;</span></code> is not specified).
      </p>
<p>
        The type of bound variables is automatically deduced and it is the exact
        same type used to declare such variables in the enclosing scope. Therefore:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            If a bound variable was declared constant using the <code class="computeroutput"><span class="keyword">const</span></code>
            qualifier then it will be bound by constant value or reference.
          </li>
<li class="listitem">
            If a bound variable was not declared constant then it will not be bound
            as constant. This library allows to force constant biding even for variables
            that are not originally declared constant using <code class="computeroutput"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)(...)</span></code> as explained below.
          </li>
<li class="listitem">
            You might want to bind variables of complex types by (constant) reference
            instead than by value to avoid expensive copy operations when these variables
            are automatically passed to the local function (as usual with C++ function
            parameter passing).
          </li>
</ul></div>
<p>
        For example, let's continue to program a local function <code class="computeroutput"><span class="identifier">add</span></code>
        similar to the one from the example in <a class="link" href="../index.html#boost_local.Introduction" title="Introduction">Introduction</a>
        section. We bind the local variable <code class="computeroutput"><span class="identifier">sum</span></code>
        by (non-constant) reference and update the body to perform the summation:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">local</span><span class="special">/</span><span class="identifier">function</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">double</span> <span class="identifier">sum</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_PARAMS</span><span class="special">(</span> <span class="special">(</span><span class="keyword">double</span> <span class="identifier">num</span><span class="special">)</span> <span class="special">(</span><span class="identifier">bind</span><span class="special">&amp;</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="identifier">sum</span> <span class="special">+=</span> <span class="identifier">num</span><span class="special">;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">clog</span> <span class="special">&lt;&lt;</span> <span class="string">"Summed: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">sum</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME</span><span class="special">(</span><span class="identifier">add</span><span class="special">)</span>

    <span class="identifier">add</span><span class="special">(</span><span class="number">100.0</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<a name="boost_local.Tutorial.binding.constant_binding"></a><h6>
<a name="id868521"></a>
        <a class="link" href="Tutorial.html#boost_local.Tutorial.binding.constant_binding">Constant Binding</a>
      </h6>
<p>
        Constant binding allows to bind variables in scope by constant reference
        or constant value (constant binding is not supported by <a href="http://en.wikipedia.org/wiki/C%2B%2B0x#Lambda_functions_and_expressions" target="_top">C++0x
        lambda</a> functions). <sup>[<a name="id868545" href="#ftn.id868545" class="footnote">9</a>]</sup>
      </p>
<p>
        The parenthesized syntax uses the "keywords" <code class="computeroutput"><span class="keyword">const</span>
        <span class="identifier">bind</span></code> to list constant bound variables
        wrapped within parenthesis at the end of the function parameter list (see
        the <a class="link" href="Grammar.html" title="Appendix: Grammar">Grammar</a> section):
      </p>
<pre class="programlisting"><span class="special">(</span><span class="emphasis"><em>result-type</em></span><span class="special">)</span> <span class="special">(</span>function-name<span class="special">)(</span> <span class="emphasis"><em>parameters</em></span> <span class="bold"><strong>(const bind)(</strong></span><span class="special">(</span><span class="emphasis"><em>cvar1</em></span><span class="special">)(</span><span class="emphasis"><em>cvar2</em></span><span class="special">)</span><span class="emphasis"><em>...</em></span><span class="special">(</span><span class="emphasis"><em>cvarM</em></span><span class="special">)</span><span class="bold"><strong>)</strong></span> <span class="special">)</span>
</pre>
<p>
        Where <span class="emphasis"><em>cvar</em></span> is the name of the variable in scope to bind
        by constant and it is prefixed by <code class="computeroutput"><span class="special">&amp;</span></code>
        if the variable is bound by constant reference, otherwise it is bound by
        constant value. If both constant and plain bindings are used, constant bindings
        must be specified before plain bindings (see the <a class="link" href="Grammar.html" title="Appendix: Grammar">Grammar</a>
        section):
      </p>
<pre class="programlisting"><span class="special">(</span><span class="emphasis"><em>result-type</em></span><span class="special">)</span> <span class="special">(</span>function-name<span class="special">)(</span> <span class="emphasis"><em>parameters</em></span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)((</span><span class="emphasis"><em>cvar1</em></span><span class="special">)(</span><span class="emphasis"><em>cvar2</em></span><span class="special">)</span><span class="emphasis"><em>...</em></span><span class="special">(</span><span class="emphasis"><em>cvarM</em></span><span class="special">))</span> <span class="special">(</span><span class="identifier">bind</span><span class="special">)((</span><span class="emphasis"><em>var1</em></span><span class="special">)(</span><span class="emphasis"><em>var2</em></span><span class="special">)</span><span class="emphasis"><em>...</em></span><span class="special">(</span><span class="emphasis"><em>varN</em></span><span class="special">))</span> <span class="special">)</span> <span class="comment">/* `(const bind)(...)` before `(bind)(...)` */</span>
</pre>
<p>
        For example, let's assume we want to bind two variables in scope <code class="computeroutput"><span class="identifier">c</span></code> and <code class="computeroutput"><span class="identifier">d</span></code>
        to the local function <code class="computeroutput"><span class="identifier">l</span></code> shown
        before. Let's also assume we want to bind <code class="computeroutput"><span class="identifier">c</span></code>
        by constant value and <code class="computeroutput"><span class="identifier">b</span></code> by
        costant reference. Then we use the following parenthesized signature for
        the local function:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">(</span><span class="identifier">l</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">y</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">x</span><span class="special">)(</span><span class="keyword">default</span><span class="special">)(</span><span class="number">0.0</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)((</span><span class="identifier">c</span><span class="special">)(&amp;</span><span class="identifier">d</span><span class="special">))</span> <span class="special">)</span>
</pre>
<p>
        If the variables in scope <code class="computeroutput"><span class="identifier">a</span></code>
        and <code class="computeroutput"><span class="identifier">b</span></code> are also bound but
        by (plain) value and reference respectively then the parenthesized signature
        becomes:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">(</span><span class="identifier">l</span><span class="special">)(</span> <span class="special">(</span><span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">y</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="keyword">double</span><span class="special">&amp;)(</span><span class="identifier">x</span><span class="special">)(</span><span class="keyword">default</span><span class="special">)(</span><span class="number">0.0</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)((</span><span class="identifier">c</span><span class="special">)(&amp;</span><span class="identifier">d</span><span class="special">))</span> <span class="special">(</span><span class="identifier">bind</span><span class="special">)((</span><span class="identifier">a</span><span class="special">)(&amp;</span><span class="identifier">b</span><span class="special">))</span> <span class="special">)</span>
</pre>
<p>
        Note how <code class="computeroutput"><span class="special">(</span><span class="keyword">const</span>
        <span class="identifier">bind</span><span class="special">)(...)</span></code>
        must always be used before <code class="computeroutput"><span class="special">(</span><span class="identifier">bind</span><span class="special">)(...)</span></code>
        when they are both present.
      </p>
<p>
        For example, let's continue to program a local function <code class="computeroutput"><span class="identifier">add</span></code>
        similar to the one in the example from the <a class="link" href="../index.html#boost_local.Introduction" title="Introduction">Introduction</a>
        section. We bind the local variable <code class="computeroutput"><span class="identifier">factor</span></code>
        by constant value and update the body to perform the factor scaling:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">local</span><span class="special">/</span><span class="identifier">function</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">double</span> <span class="identifier">sum</span> <span class="special">=</span> <span class="number">0.0</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">factor</span> <span class="special">=</span> <span class="number">10</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_PARAMS</span><span class="special">(</span> <span class="special">(</span><span class="keyword">double</span> <span class="identifier">num</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span> <span class="identifier">factor</span><span class="special">)</span>
            <span class="special">(</span><span class="identifier">bind</span><span class="special">&amp;</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="identifier">sum</span> <span class="special">+=</span> <span class="identifier">factor</span> <span class="special">*</span> <span class="identifier">num</span><span class="special">;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">clog</span> <span class="special">&lt;&lt;</span> <span class="string">"Summed: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">sum</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME</span><span class="special">(</span><span class="identifier">add</span><span class="special">)</span>

    <span class="identifier">add</span><span class="special">(</span><span class="number">100.0</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<a name="boost_local.Tutorial.binding.binding_the_object__code__phrase_role__keyword__this__phrase___code_"></a><h6>
<a name="id869810"></a>
        <a class="link" href="Tutorial.html#boost_local.Tutorial.binding.binding_the_object__code__phrase_role__keyword__this__phrase___code_">Binding
        the Object <code class="computeroutput"><span class="keyword">this</span></code></a>
      </h6>
<p>
        It is also possible to bind the object <code class="computeroutput"><span class="keyword">this</span></code>
        when it is in scope (from enclosing member functions, etc). This is done
        by using <code class="computeroutput"><span class="keyword">this</span></code> as the name of
        the variable to bind and by using the special symbol <code class="computeroutput"><span class="identifier">this_</span></code>
        (instead of <code class="computeroutput"><span class="keyword">this</span></code>) to access
        the object within the local function body. Note that:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            The object <code class="computeroutput"><span class="keyword">this</span></code> can be bound
            by value using <code class="computeroutput"><span class="special">(</span><span class="identifier">bind</span><span class="special">)((</span><span class="keyword">this</span><span class="special">)...)</span></code>. In this case the local function
            will be able to modify the object when the enclosing scope is a non-constant
            member, or it will not be able to modify the object when the enclosing
            scope is a constant member.
          </li>
<li class="listitem">
            The object <code class="computeroutput"><span class="keyword">this</span></code> can be bound
            by constant value <code class="computeroutput"><span class="special">(</span><span class="keyword">const</span>
            <span class="identifier">bind</span><span class="special">)((</span><span class="keyword">this</span><span class="special">)...)</span></code>.
            In this case the local function will never be able to modify the object
            (regardless of whether the enclosing scope is a constant member or not).
          </li>
<li class="listitem">
            Finally, the object <code class="computeroutput"><span class="keyword">this</span></code>
            can never be bound by reference because C++ does not allow to get a reference
            to <code class="computeroutput"><span class="keyword">this</span></code>. You will get a
            compile-time error if you try to use <code class="computeroutput"><span class="special">(</span><span class="identifier">bind</span><span class="special">)((&amp;</span><span class="keyword">this</span><span class="special">)...)</span></code>
            or <code class="computeroutput"><span class="special">(</span><span class="keyword">const</span>
            <span class="identifier">bind</span><span class="special">)((&amp;</span><span class="keyword">this</span><span class="special">)...)</span></code>.
            However, <code class="computeroutput"><span class="keyword">this</span></code> is a pointer
            so the object is not copied even if it is bound by value. (Note that
            it is not possible to bind <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> because it starts with <code class="computeroutput"><span class="special">*</span></code> and it is not a variable name.)
          </li>
</ul></div>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../../../../doc/src/images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
          When the object <code class="computeroutput"><span class="keyword">this</span></code> is bound
          to a local function, the local function <span class="bold"><strong>body must
          use the special symbol</strong></span> <code class="computeroutput"><span class="identifier">this_</span></code>
          (instead of <code class="computeroutput"><span class="keyword">this</span></code>) to access
          the bound object. <sup>[<a name="id870165" href="#ftn.id870165" class="footnote">10</a>]</sup> Using <code class="computeroutput"><span class="keyword">this</span></code> within
          the local function body will generate a compile-time error so programmers
          cannot mistakenly confuse the use of <code class="computeroutput"><span class="identifier">this_</span></code>
          with <code class="computeroutput"><span class="keyword">this</span></code>. <sup>[<a name="id870268" href="#ftn.id870268" class="footnote">11</a>]</sup>
        </p></td></tr>
</table></div>
<p>
        For example, let's rewrite a local function <code class="computeroutput"><span class="identifier">add</span></code>
        similar to the one in the example from the <a class="link" href="../index.html#boost_local.Introduction" title="Introduction">Introduction</a>
        section but using a member function to illustrate how to bind the object
        <code class="computeroutput"><span class="keyword">this</span></code>:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">local</span><span class="special">/</span><span class="identifier">function</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">algorithm</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">adder</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">adder</span><span class="special">():</span> <span class="identifier">sum_</span><span class="special">(</span><span class="number">0.0</span><span class="special">)</span> <span class="special">{}</span>

    <span class="keyword">double</span> <span class="identifier">sum</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;&amp;</span> <span class="identifier">nums</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">int</span><span class="special">&amp;</span> <span class="identifier">factor</span> <span class="special">=</span> <span class="number">10</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_PARAMS</span><span class="special">(</span> <span class="special">(</span><span class="keyword">double</span> <span class="identifier">num</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span> <span class="identifier">factor</span><span class="special">)</span>
                <span class="special">(</span><span class="identifier">bind</span> <span class="keyword">this</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
            <span class="identifier">this_</span><span class="special">-&gt;</span><span class="identifier">sum_</span> <span class="special">+=</span> <span class="identifier">factor</span> <span class="special">*</span> <span class="identifier">num</span><span class="special">;</span> <span class="comment">// Use `this_` instead of `this`.
</span>            <span class="identifier">std</span><span class="special">::</span><span class="identifier">clog</span> <span class="special">&lt;&lt;</span> <span class="string">"Summed: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">this_</span><span class="special">-&gt;</span><span class="identifier">sum_</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME</span><span class="special">(</span><span class="identifier">add</span><span class="special">)</span>

        <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span><span class="identifier">nums</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">nums</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">add</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">sum_</span><span class="special">;</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">double</span> <span class="identifier">sum_</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">(</span><span class="number">3</span><span class="special">);</span>
    <span class="identifier">v</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="number">100.0</span><span class="special">;</span> <span class="identifier">v</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="number">90.5</span><span class="special">;</span> <span class="identifier">v</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">=</span> <span class="number">7.0</span><span class="special">;</span>

    <span class="identifier">adder</span> <span class="identifier">a</span><span class="special">;</span>
    <span class="comment">// sum = 10 * 100.0 + 10 * 90.5 + 10 * 7.0 = 1975.0
</span>    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">a</span><span class="special">.</span><span class="identifier">sum</span><span class="special">(</span><span class="identifier">v</span><span class="special">)</span> <span class="special">==</span> <span class="number">1975.0</span><span class="special">);</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_local.Tutorial.local_blocks"></a><a class="link" href="Tutorial.html#boost_local.Tutorial.local_blocks" title="Local Blocks">Local Blocks</a>
</h3></div></div></div>
<p>
        Local blocks are defined using the following macros within a declarative
        context (see the <a href="../reference.html" target="_top">Reference</a> section):
      </p>
<pre class="programlisting"><span class="special">{</span> <span class="comment">// Some declarative context.
</span>    <span class="special">...</span>

    <code class="computeroutput">BOOST_LOCAL_BLOCK</code><span class="special">(</span> <span class="emphasis"><em>parenthesized-binding</em></span> <span class="special">)</span> <span class="special">{</span>
        <span class="emphasis"><em>block-body</em></span>
    <span class="special">}</span> <code class="computeroutput">BOOST_LOCAL_BLOCK_END</code>

    <span class="special">...</span>
<span class="special">}</span>
</pre>
<p>
        This expands to code that executes the body instructions in place where the
        block is defined. However, only bound variables specified by the <span class="emphasis"><em>parenthesized-binding</em></span>
        are accessible from within the local block body.
      </p>
<p>
        Adopting a parenthesized syntax similar to the one used for local functions
        (see the <a class="link" href="Grammar.html" title="Appendix: Grammar">Grammar</a> section), the
        <span class="emphasis"><em>parenthesized-binding</em></span> can specify to bind no variable:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
</pre>
<p>
        Or, to bind variables by constant type only:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)((</span><span class="emphasis"><em>cvar1</em></span><span class="special">)(</span><span class="emphasis"><em>cvar2</em></span><span class="special">)</span><span class="emphasis"><em>...</em></span><span class="special">(</span><span class="emphasis"><em>cvarM</em></span><span class="special">))</span>
</pre>
<p>
        Or, to bind variables by plain type only:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="identifier">bind</span><span class="special">)((</span><span class="emphasis"><em>var1</em></span><span class="special">)(</span><span class="emphasis"><em>var2</em></span><span class="special">)</span><span class="emphasis"><em>...</em></span><span class="special">(</span><span class="emphasis"><em>varN</em></span><span class="special">))</span>
</pre>
<p>
        Or, to bind variables by both constant and plain types:
      </p>
<pre class="programlisting"><span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)((</span><span class="emphasis"><em>cvar1</em></span><span class="special">)(</span><span class="emphasis"><em>cvar2</em></span><span class="special">)</span><span class="emphasis"><em>...</em></span><span class="special">(</span><span class="emphasis"><em>cvarM</em></span><span class="special">))</span> <span class="special">(</span><span class="identifier">bind</span><span class="special">)((</span><span class="emphasis"><em>var1</em></span><span class="special">)(</span><span class="emphasis"><em>var2</em></span><span class="special">)</span><span class="emphasis"><em>...</em></span><span class="special">(</span><span class="emphasis"><em>varN</em></span><span class="special">))</span>
</pre>
<p>
        Where <span class="emphasis"><em>cvar</em></span> and <span class="emphasis"><em>var</em></span> are the names
        of the variables in scope to bind. They can be prefixed by <code class="computeroutput"><span class="special">&amp;</span></code> to bind by reference instead of by value,
        and one of them can be <code class="computeroutput"><span class="keyword">this</span></code>
        to bind the object when it is in scope.
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../../../../doc/src/images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
          A <code class="computeroutput"><span class="keyword">return</span><span class="special">;</span></code>
          instruction from within a local block jumps to the end of the local block
          body and <span class="bold"><strong>it does not return the enclosing scope</strong></span>.
          <sup>[<a name="id871709" href="#ftn.id871709" class="footnote">12</a>]</sup>
        </p></td></tr>
</table></div>
<p>
        For example, let's program a local block similar to the one in the example
        from the <a class="link" href="../index.html#boost_local.Introduction" title="Introduction">Introduction</a> section:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">local</span><span class="special">/</span><span class="identifier">block</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">double</span> <span class="identifier">sum</span> <span class="special">=</span> <span class="number">1975.0</span><span class="special">;</span>

    <span class="identifier">BOOST_LOCAL_BLOCK</span><span class="special">(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)((&amp;</span><span class="identifier">sum</span><span class="special">))</span> <span class="special">)</span> <span class="special">{</span>
        <span class="identifier">assert</span><span class="special">(</span><span class="identifier">sum</span> <span class="special">==</span> <span class="number">1975.0</span><span class="special">);</span> <span class="comment">// OK: Complier error if `==` confused with `=`.
</span>        <span class="identifier">std</span><span class="special">::</span><span class="identifier">clog</span> <span class="special">&lt;&lt;</span> <span class="string">"Asserted summation: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">sum</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

        <span class="keyword">return</span><span class="special">;</span> <span class="comment">// Return this local block (and not the enclosing scope).
</span>        <span class="identifier">assert</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span> <span class="comment">// OK: Never executed.
</span>    <span class="special">}</span> <span class="identifier">BOOST_LOCAL_BLOCK_END</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_local.Tutorial.local_exits"></a><a class="link" href="Tutorial.html#boost_local.Tutorial.local_exits" title="Local Exits">Local Exits</a>
</h3></div></div></div>
<p>
        Local exits are defined using the following macros within a declarative context
        (see the <a href="../reference.html" target="_top">Reference</a> section):
      </p>
<pre class="programlisting"><span class="special">{</span> <span class="comment">// Some declarative context.
</span>    <span class="special">...</span>

    <code class="computeroutput">BOOST_LOCAL_EXIT</code><span class="special">(</span> <span class="emphasis"><em>parenthesized-binding</em></span> <span class="special">)</span> <span class="special">{</span>
        <span class="emphasis"><em>exit-body</em></span>
    <span class="special">}</span> <code class="computeroutput">BOOST_LOCAL_EXIT_END</code>

    <span class="special">...</span>
<span class="special">}</span>
</pre>
<p>
        This expands to code that executes the body instructions when the enclosing
        scope is exited (i.e., at the very end of the enclosing scope). If multiple
        local exits are defined within the same scope, their bodies will be executed
        in the reverse order in which they have been defined. Only bound variables
        specified by <span class="emphasis"><em>parenthesized-binding</em></span> are accessible from
        within the local exit body. The <span class="emphasis"><em>parenthesized-biding</em></span>
        is specified following the exact same syntax as for the one used by local
        blocks.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          A <code class="computeroutput"><span class="keyword">return</span><span class="special">;</span></code>
          instruction from within a local exit jumps to the end of the local exit
          body and <span class="bold"><strong>it does not return the enclosing scope</strong></span>.
        </p></td></tr>
</table></div>
<p>
        For example, let's program a local exit similar to the one in the example
        from the <a class="link" href="../index.html#boost_local.Introduction" title="Introduction">Introduction</a> section:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">local</span><span class="special">/</span><span class="identifier">exit</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">size_t</span> <span class="identifier">size</span> <span class="special">=</span> <span class="number">2</span><span class="special">;</span>
    <span class="keyword">double</span><span class="special">*</span> <span class="identifier">nums</span> <span class="special">=</span> <span class="keyword">new</span> <span class="keyword">double</span><span class="special">[</span><span class="identifier">size</span><span class="special">];</span>
    
    <span class="identifier">BOOST_LOCAL_EXIT</span><span class="special">(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)((&amp;</span><span class="identifier">size</span><span class="special">))</span> <span class="special">(</span><span class="identifier">bind</span><span class="special">)((</span><span class="identifier">nums</span><span class="special">))</span> <span class="special">)</span> <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">size</span> <span class="special">&amp;&amp;</span> <span class="identifier">nums</span><span class="special">)</span> <span class="keyword">delete</span><span class="special">[]</span> <span class="identifier">nums</span><span class="special">;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">clog</span> <span class="special">&lt;&lt;</span> <span class="string">"Freed array: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">nums</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

        <span class="keyword">return</span><span class="special">;</span> <span class="comment">// Return this local exit (and not the enclosing scope).
</span>        <span class="identifier">assert</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span> <span class="comment">// OK: Never executed.
</span>    <span class="special">}</span> <span class="identifier">BOOST_LOCAL_EXIT_END</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        Local exits are very similar to the functionality already provided by <a href="http://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
        with the addition that they also support constant binding and the binding
        of the object <code class="computeroutput"><span class="keyword">this</span></code>. <sup>[<a name="id872989" href="#ftn.id872989" class="footnote">13</a>]</sup>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_local.Tutorial.templates"></a><a class="link" href="Tutorial.html#boost_local.Tutorial.templates" title="Templates">Templates</a>
</h3></div></div></div>
<p>
        When local functions, local blocks, and local exits are programmed within
        templates, they need to be declared using the following special macros ending
        with the <code class="computeroutput"><span class="identifier">TPL</span></code> postfix (see
        the <a href="../reference.html" target="_top">Reference</a> section): <sup>[<a name="id873317" href="#ftn.id873317" class="footnote">14</a>]</sup>
      </p>
<pre class="programlisting"><code class="computeroutput">BOOST_LOCAL_FUNCTION_TPL</code><span class="special">(</span> <span class="emphasis"><em>parenthesized-signature</em></span> <span class="special">)</span>
<code class="computeroutput">BOOST_LOCAL_BLOCK_TPL</code><span class="special">(</span> <span class="emphasis"><em>parenthesized-binding</em></span> <span class="special">)</span>
<code class="computeroutput">BOOST_LOCAL_EXIT_TPL</code><span class="special">(</span> <span class="emphasis"><em>parenthesized-binding</em></span> <span class="special">)</span>
</pre>
<p>
        These macros have the exact same API as their equivalents without the <code class="computeroutput"><span class="identifier">TPL</span></code> postfix that we have seen so far. The
        local function, local block, and local exit ending macros (with the <code class="computeroutput"><span class="identifier">END</span></code> postfix) can be used unchanged within
        templates.
      </p>
<p>
        For example, let's rewrite an example similar to the one from the <a class="link" href="../index.html#boost_local.Introduction" title="Introduction">Introduction</a>
        section but wrapped within a template:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">local</span><span class="special">/</span><span class="identifier">function</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">local</span><span class="special">/</span><span class="identifier">block</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">local</span><span class="special">/</span><span class="identifier">exit</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">algorithm</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">total</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">z</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">T</span> <span class="identifier">sum</span> <span class="special">=</span> <span class="identifier">T</span><span class="special">();</span>
    <span class="keyword">int</span> <span class="identifier">factor</span> <span class="special">=</span> <span class="number">10</span><span class="special">;</span>

    <span class="identifier">BOOST_LOCAL_FUNCTION_TPL</span><span class="special">(</span> <span class="comment">// Use `..._TPL()` macros in templates.
</span>    <span class="special">(</span><span class="keyword">void</span><span class="special">)</span> <span class="special">(</span><span class="identifier">add</span><span class="special">)(</span> <span class="special">(</span><span class="identifier">T</span><span class="special">)(</span><span class="identifier">num</span><span class="special">)</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)((</span><span class="identifier">factor</span><span class="special">))</span> <span class="special">(</span><span class="identifier">bind</span><span class="special">)((&amp;</span><span class="identifier">sum</span><span class="special">))</span> <span class="special">)</span>
    <span class="special">)</span> <span class="special">{</span>
        <span class="identifier">sum</span> <span class="special">+=</span> <span class="identifier">factor</span> <span class="special">*</span> <span class="identifier">num</span><span class="special">;</span>
    <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_END</span><span class="special">(</span><span class="identifier">add</span><span class="special">)</span>
    <span class="identifier">add</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>

    <span class="identifier">size_t</span> <span class="identifier">size</span> <span class="special">=</span> <span class="number">2</span><span class="special">;</span>
    <span class="identifier">T</span><span class="special">*</span> <span class="identifier">nums</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">T</span><span class="special">[</span><span class="identifier">size</span><span class="special">];</span>
    <span class="identifier">BOOST_LOCAL_EXIT_TPL</span><span class="special">(</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)((&amp;</span><span class="identifier">size</span><span class="special">))</span> <span class="special">(</span><span class="identifier">bind</span><span class="special">)((</span><span class="identifier">nums</span><span class="special">))</span> <span class="special">)</span> <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">size</span> <span class="special">&amp;&amp;</span> <span class="identifier">nums</span><span class="special">)</span> <span class="keyword">delete</span><span class="special">[]</span> <span class="identifier">nums</span><span class="special">;</span>
    <span class="special">}</span> <span class="identifier">BOOST_LOCAL_EXIT_END</span>

    <span class="identifier">nums</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">y</span><span class="special">;</span> <span class="identifier">nums</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">z</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span><span class="identifier">nums</span><span class="special">,</span> <span class="identifier">nums</span> <span class="special">+</span> <span class="identifier">size</span><span class="special">,</span> <span class="identifier">add</span><span class="special">);</span>

    <span class="identifier">BOOST_LOCAL_BLOCK_TPL</span><span class="special">(</span>
            <span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">)((&amp;</span><span class="identifier">sum</span><span class="special">)(&amp;</span><span class="identifier">factor</span><span class="special">)(&amp;</span><span class="identifier">x</span><span class="special">)(&amp;</span><span class="identifier">y</span><span class="special">)(&amp;</span><span class="identifier">z</span><span class="special">))</span> <span class="special">)</span> <span class="special">{</span>
        <span class="identifier">assert</span><span class="special">(</span><span class="identifier">sum</span> <span class="special">==</span> <span class="identifier">factor</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">x</span> <span class="special">+</span> <span class="identifier">y</span> <span class="special">+</span> <span class="identifier">z</span><span class="special">));</span>
    <span class="special">}</span> <span class="identifier">BOOST_LOCAL_BLOCK_END</span>

    <span class="keyword">return</span> <span class="identifier">sum</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">total</span><span class="special">(</span><span class="number">100.0</span><span class="special">,</span> <span class="number">90.5</span><span class="special">,</span> <span class="number">7.0</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a id="ftn.id865394" href="#id865394" class="para">2</a>] </sup>
            The parenthesized syntax owes its name to the indeed large number of
            parenthesis <code class="computeroutput"><span class="special">()</span></code> that are
            required to wrap its elements. Programmers might notice some similarities
            between the parenthesized syntax and the syntax of the <a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)" target="_top">LISP</a>
            programming language. However, these similarities are not intentional
            in that they were not a design choice but rather a consequence of the
            fact that both <a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)" target="_top">LISP</a>
            sequences and <a href="http://www.boost.org/doc/libs/release/libs/preprocessor/doc/index.html" target="_top">Boost.Preprocessor</a>
            sequences are formed by wrapping tokens within round parenthesis <code class="computeroutput"><span class="special">()</span></code>.
          </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id865521" href="#id865521" class="para">3</a>] </sup>
            <span class="bold"><strong>Rationale.</strong></span> This constraint comes form
            the fact that the C++ preprocessor can only concatenate <code class="literal">##</code>
            alphanumeric symbols.
          </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id865557" href="#id865557" class="para">4</a>] </sup>
            <span class="bold"><strong>Rationale.</strong></span> This constraint comes from
            the fact that the ISO C++ standard preprocessor forbids empty macro parameters
            (this is different for C99 and other more recent preprocessors).
          </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id866504" href="#id866504" class="para">5</a>] </sup>
            While there are fundamental limitations to the amount of parenthesized
            syntax error checking that can be done using the preprocessor (e.g.,
            there is no way to gracefully detect and report a missing parenthesis
            "<code class="computeroutput"><span class="special">)</span></code>"), the current
            implementation of the parsing macros does not perform all the error checking
            that could be done. Improving the parenthesized syntax error checking
            is a work in progress. Programmers are encouraged to report cryptic error
            messages they experience because of parenthesized syntax errors so to
            help this development effort.
          </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id867024" href="#id867024" class="para">6</a>] </sup>
              <span class="bold"><strong>Rationale.</strong></span> If the local function body
              were instead passed as a macro parameter, it would be expanded on a
              single line of code (because macros always expand as a single line
              of code). Therefore, eventual compiler error line numbers would all
              have the same value and would no longer be useful to pinpoint the error.
            </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id867054" href="#id867054" class="para">7</a>] </sup>
              <span class="bold"><strong>Rationale.</strong></span> The local function name
              must be passed to the ending macro <code class="computeroutput">BOOST_LOCAL_FUNCTION_END</code>
              so this macro can declare a local variable with the local function
              name to hold the local functor object. At the same time, the local
              function name must also be passed to the declaration macro <code class="computeroutput">BOOST_LOCAL_FUNCTION</code>
              to allow the local function to recursively call itself. The local function
              declaration and ending macros are kept as two separate macros so that
              the local function body does not have to be passed as a macro parameter
              (otherwise, the compiler error line numbers will all appear on the
              same line and they will no longer be useful to pinpoint the errors).
            </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id867618" href="#id867618" class="para">8</a>] </sup>
          <span class="bold"><strong>Rationale.</strong></span> By binding a variable in scope,
          the local function declaration is specifying that such a variable should
          be accessible within the local function body regardless of its type. Semantically,
          this binding should be seen as an "extension" of the scope of
          the bound variable from the enclosing scope to the scope of the local function
          body. Contrary to the semantics of a function parameter passing, in-scope
          variable binding does not depend on the variable type but just on the variable
          name: "The variable in scope named <span class="emphasis"><em>x</em></span> should be
          accessible within the local function named <span class="emphasis"><em>l</em></span>".
          This is especially useful for maintenance so if a bound variable type is
          changed, the local function declaration does not have to change.
        </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id868545" href="#id868545" class="para">9</a>] </sup>
          An historical note: Constant binding of variables in scope was the main
          use case that originally motivated the authors in developing this library.
          The authors needed to locally create a chuck of code to assert some correctness
          conditions while these assertions were not supposed to modify any of the
          variables they were using (see the <a href="http://sourceforge.net/projects/contractpp" target="_top">Contract++</a>
          library). This was achieved by binding by constant reference the variables
          needed by the assertions and then by programming the local function body
          to check the assertions (or more conveniently by using <code class="computeroutput">BOOST_LOCAL_BLOCK</code>). This way
          if any of the assertions mistakenly changes a bound variable (for example
          confusing the operator <code class="computeroutput"><span class="special">==</span></code>
          with <code class="computeroutput"><span class="special">=</span></code>), the compiler correctly
          generates an error because the bound variable is of <code class="computeroutput"><span class="keyword">const</span></code>
          type within the local function body.
        </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id870165" href="#id870165" class="para">10</a>] </sup>
            <span class="bold"><strong>Rationale.</strong></span> This limitation comes from
            the fact that <code class="computeroutput"><span class="keyword">this</span></code> is a
            reserved C++ keyword so it cannot be used as the name of the internal
            parameter passing the bound object to the local function body. It would
            be possible to use <code class="computeroutput"><span class="keyword">this</span></code>
            (instead of <code class="computeroutput"><span class="identifier">this_</span></code>) within
            the local function body either at the expenses of copying the bound object
            (which would introduce run-time overhead and also the stringent requirement
            that the bound object must have a deep copy constructor) or by relying
            on an <a href="http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/d3a86f27277f713b" target="_top">undefined
            behaviour of <code class="computeroutput"><span class="keyword">static_cast</span></code></a>
            (which might not work on all platforms at the cost of portability).
          </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id870268" href="#id870268" class="para">11</a>] </sup>
            <span class="bold"><strong>Rationale.</strong></span> This is because the body
            function is implemented as static function of the local functor class.
          </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id871709" href="#id871709" class="para">12</a>] </sup>
            <span class="bold"><strong>Rationale.</strong></span> Programmers might expect
            <code class="computeroutput"><span class="keyword">return</span><span class="special">;</span></code>
            to exit the enclosing function instead of the local block (or local exit),
            especially if the enclosing function has a <code class="computeroutput"><span class="keyword">void</span></code>
            result type. However, using <code class="computeroutput"><span class="keyword">return</span><span class="special">;</span></code> to exit local blocks (and local exits)
            seemed to follow a more natural syntax and also it is the same syntax
            already provided by <a href="http://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
            (in fact, <code class="computeroutput"><span class="keyword">return</span><span class="special">;</span></code>
            is used by <a href="http://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
            to exit the local scope and not to exit the enclosing scope). However,
            if programmers were to find this use of <code class="computeroutput"><span class="keyword">return</span><span class="special">;</span></code> confusing, this library API could be
            changed to forbid the use of <code class="computeroutput"><span class="keyword">return</span></code>
            from within local blocks (and local exits) generating a compile-time
            error, and to use a different instruction (e.g., <code class="computeroutput"><span class="keyword">break</span><span class="special">;</span></code> or a special macro instruction like
            <code class="computeroutput"><span class="identifier">BOOST_LOCAL_RETURN</span><span class="special">;</span></code>)
            to exit local blocks (and local exits).
          </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id872989" href="#id872989" class="para">13</a>] </sup>
          <span class="bold"><strong>Rationale.</strong></span> This library could be merged
          together with <a href="http://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
          into a new library named Boost.Scope (from the meaning of the word "<a href="http://en.wikipedia.org/wiki/Scope_(programming)" target="_top">scope</a>"
          in computer programming). This would be justified by the fact that <code class="computeroutput">BOOST_LOCAL_EXIT</code> simply extends
          the functionality already provided by <code class="computeroutput"><span class="identifier">BOOST_SCOPE_EXIT</span></code>.
          The headers will be <code class="computeroutput"><span class="string">"boost/scope/function.hpp"</span></code>,
          <code class="computeroutput"><span class="string">"boost/scope/block.hpp"</span></code>,
          and <code class="computeroutput"><span class="string">"boost/scope/exit.hpp"</span></code>.
          For backward compatibility with <a href="http://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>,
          the header <code class="computeroutput"><span class="string">"boost/scope_exit.hpp"</span></code>
          could also be kept and it would be equivalent to including <code class="computeroutput"><span class="string">"boost/scope/exit.hpp"</span></code>. In addition
          and again for backward compatibility, the <code class="computeroutput"><span class="identifier">BOOST_SCOPE_EXIT</span></code>
          macro could be extended to accept either the original <a href="http://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
          sequence of <code class="computeroutput"><span class="special">(</span><span class="identifier">var1</span><span class="special">)...(</span><span class="identifier">varN</span><span class="special">)</span></code> without the <code class="computeroutput"><span class="identifier">bind</span></code>
          "keyword" (which would be equivalent to plain binding) or the
          parenthesized binding sequence with the <code class="computeroutput"><span class="special">(</span><span class="identifier">bind</span><span class="special">)(...)</span></code>
          and <code class="computeroutput"><span class="special">(</span><span class="keyword">const</span>
          <span class="identifier">bind</span><span class="special">)(...)</span></code>
          "keywords" plus the binding of the object <code class="computeroutput"><span class="keyword">this</span></code>.
          Local blocks would be named "scope blocks" and they would be
          provided by the <code class="computeroutput"><span class="identifier">BOOST_SCOPE_BLOCK</span><span class="special">...</span></code> macros. However, local functions would
          have to be named "scope functions" and they would be provided
          by the <code class="computeroutput"><span class="identifier">BOOST_SCOPE_FUNCTION</span><span class="special">...</span></code> macros. This might not be ideal because
          local functions are not known under the name of "scope functions"
          (they are indeed known by the name of "local functions" or "<a href="http://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html" target="_top">nested functions</a>").
        </p></div>
<div class="footnote"><p><sup>[<a id="ftn.id873317" href="#id873317" class="para">14</a>] </sup>
          <span class="bold"><strong>Rationale.</strong></span> Within templates, this library
          needs to use <code class="computeroutput"><span class="keyword">typename</span></code> to explicitly
          indicate that some expressions evaluate to a type. Because C++ does not
          allow this use of <code class="computeroutput"><span class="keyword">typename</span></code>
          outside templates, the special <code class="computeroutput"><span class="identifier">TPL</span></code>
          macros are used to indicate that the enclosing scope is a template so this
          library can safety use <code class="computeroutput"><span class="keyword">typename</span></code>
          to resolve expression type ambiguities.
        </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2009 -2011 Lorenzo Caminiti<p>
        Use, modification, and distribution is subject to the Boost Software License,
        Version 1.0 (see accompanying file LICENSE_1_0.txt or a copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>).
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="Starting.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="Advanced.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
