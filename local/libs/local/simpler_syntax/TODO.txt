

* Rework a no-macro version of the factorial example.
    >>  Ask boost about inline -- is it useful?
    >>  Tell boost that split-macros can support recursion at the cost of
        allowing `this` within the function body (so no error if used instead
        of `this_`).


* Rename function_ref to function (because it now has a default constructor so it's not a reference anymore).


* Double check all local function syntax elements (from Grammar) -- auto, register, etc.

* Provide bound parameter types within the body (via private typdefs in the functor class) as `BOUND_PARAM_NAME>_type` -- these can be used for concept checking, etc. Actually, provide access to the bind types via a macro BOOST_LOCAL_TYPEOF() so to hide the type name and to strip eventual const& (Vicente's idea).

* Rename is_xxx.hpp to xxx.hpp for all PP_KEYWORD and add REMOVE and ADD macros:
> #include <boost/preprocessor.hpp>
> #include <boost/preprocessor/detail/is_unary.hpp>
>
> #define IS_AUTO_auto (1) /* must expand to unary */
> #define IS_AUTO(tokens) BOOST_PP_IS_UNARY(BOOST_PP_CAT(IS_AUTO_, tokens))
>
> #define REMOVE_AUTO_STRIP_auto /* must expand to nothing */
> #define REMOVE_AUTO_(tokens) BOOST_PP_CAT(REMOVE_AUTO_STRIP_, tokens)
> #define REMOVE_AUTO(tokens) \
>     BOOST_PP_IIF(IS_AUTO(tokens), \
>         REMOVE_AUTO_ \
>     , \
>         tokens BOOST_PP_TUPLE_EAT(1) \
>     )(tokens)
>
> #define ADD_AUTO(tokens) \
>     BOOST_PP_EXPR_IIF(BOOST_PP_NOT(IS_AUTO(tokens)), auto) tokens
>
> IS_AUTO(auto int x) // 1
> IS_AUTO(int x) // 0
>
> REMOVE_AUTO(auto int x) // int x
> REMOVE_AUTO(int x) // int x
>
> ADD_AUTO(auto int x) // auto int x
> ADD_AUTO(int x) // auto int x
The names should actually be AUTO_IN_FRONT, AUTO_ADD_FRONT, AUTO_REMOVE_FRONT, AUTO_IN_BACK, AUTO_ADD_BACK, AUTO_REMOVE_BACK (the general stuff could go into keyword/utility/in.hpp, add.hpp, remove.hpp).



* Send comments on variadic_macro_data:

* Optimize macro expansion code for C++0x, C++03, etc. From John Bytheway:
> Yes, in C++0x local structs can be passed as template parameters.
> Obviously, in C++0x there are lambdas too, so you might think your
> library is useless, but I'd expect most compilers to support passing
> local structs as template parameters before they support lambdas, so
> there is some advantage in having this intermediate implementation.
> Also, your macros would allow writing code that worked in C++0x and
> C++03, with the virtual function business in only those compilers/modes
> where it is necessary.

* See if the two local functors `functor_factorial` and `factorial` can be declared `const`.

* Make sure that when no bound params, none of the binding overhead code is generated by the macro expansion.

* Add comparison with Look at Alex-Steven's syntax to docs:
    http://thread.gmane.org/gmane.comp.lib.boost.devel/168612/focus=168694
    >> This syntax uses same typeof trick to deduce result type.
    >> This syntax uses a strange macro-into-macro for bind. I don't.


