<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:(null)1="http://www.w3.org/TR/REC-html40"><head><!--
    Copyright 2009-2010 Intel Corporation
    license banner
-->
<title>Boost Polygon Library: Polygon Set Concept</title>
    <meta http-equiv="content-type" content="text/html;charset=ISO-8859-1">
    <!-- <link type="text/css" rel="stylesheet" href="adobe_source.css"> -->
<table style="margin: 0pt; padding: 0pt; width: 100%;" border="0" cellpadding="0" cellspacing="0"><tbody><tr>
<td style="background-color: rgb(238, 238, 238);" nowrap="1" valign="top">
    <div style="padding: 5px;" align="center">
        <img border="0" src="images/boost.png" width="277" height="86"><a title="www.boost.org home page" href="http://www.boost.org/" tabindex="2" style="border: medium none ;">
            </a>
    </div>
    <div style="margin: 5px;">
        <h3 class="navbar">Contents</h3>
        <ul>
            <li><a href="index.htm">Polygon Library Main Page</a></li>
            <li><a href="gtl_design_overview.htm">Polygon 
			Library Design Overview</a></li>
            <li><a href="gtl_isotropy.htm">Isotropy</a></li>
            <li><a href="gtl_coordinate_concept.htm">Coordinate Concept</a></li>
            <li><a href="gtl_interval_concept.htm">Interval Concept</a></li>
			<li><a href="gtl_point_concept.htm">Point Concept</a></li>
			<li><a href="gtl_point_3d_concept.htm">Point 3D Concept</a></li>
			<li><a href="gtl_rectangle_concept.htm">Rectangle Concept</a></li>
			<li><a href="gtl_polygon_90_concept.htm">Polygon 90 Concept</a></li>
			<li><a href="gtl_polygon_90_with_holes_concept.htm">Polygon 90 With Holes Concept</a></li>
			<li><a href="gtl_polygon_45_concept.htm">Polygon 45 Concept</a></li>
			<li><a href="gtl_polygon_45_with_holes_concept.htm">Polygon 45 With Holes Concept</a></li>
			<li><a href="gtl_polygon_concept.htm">Polygon Concept</a></li>
			<li><a href="gtl_polygon_with_holes_concept.htm">Polygon With Holes Concept</a></li>
			<li><a href="gtl_polygon_90_set_concept.htm">Polygon 90 Set Concept</a></li>
			<li><a href="gtl_polygon_45_set_concept.htm">Polygon 45 Set Concept</a></li>
			<li><a href="gtl_connectivity_extraction_90.htm">Connectivity Extraction 90</a></li>
			<li><a href="gtl_connectivity_extraction_45.htm">Connectivity Extraction 45</a></li>
			<li><a href="gtl_property_merge_90.htm">Property Merge 90</a></li>
			<li><a href="gtl_property_merge.htm">Property Merge</a></li>
        </ul>
        <h3 class="navbar">Other Resources</h3>
        <ul>
            <li><a href="GTL_boostcon2009.pdf">GTL Boostcon 2009 Paper</a></li>
             <li><a href="GTL_boostcon_draft03.htm">GTL Boostcon 2009 
				Presentation</a></li>
        </ul>
    </div>
        <h3 class="navbar">Polygon Sponsor</h3>
    <div style="padding: 5px;" align="center">
        <img border="0" src="images/intlogo.gif" width="127" height="51"><a title="www.adobe.com home page" href="http://www.adobe.com/" tabindex="2" style="border: medium none ;">
            </a>
    </div>    
</td>
<td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%">

<!-- End Header -->

<br>
<p>
</p><h1>Polygon Set Concept</h1>

<p> 
<p>The polygon set concept type identifier is <font face="Courier New">
polygon_set_concept</font></p>
<p> 
<font face="Times New Roman">The semantic of a polygon_set is a zero or more 
geometry regions.&nbsp; A Polygon Set Concept may be defined with floating point 
coordinates, but a snap rounding distance of one integer unit will still be 
applied, furthermore, geometry outside the domain where one integer unit is 
sufficient to provide robustness may lead to undefined behavior in algorithms.&nbsp; 
It is recommended to use integer coordinates for robust operations.&nbsp; In the 
case that data represented contains only Manhattan geometry a runtime check will 
default to the Manhattan algorithm.&nbsp; The results of which are identical to 
what the general algorithm would do, but obtained more efficiently.&nbsp; In the 
case that the data represented contains only Manhattan and 45-degree geometry a 
runtime check will default to the faster 45-degree algorithm.&nbsp; The results 
of which may differ slight from what the general algorithm would do because 
non-integer intersections will be handled differently.</font><p>Mapping type traits for a user defined 
polygon set object is an advanced topic and covered by example code.&nbsp; 
Users are recommended to use std::vector and std::list of user defined polygons 
or library provided polygon_set_data&lt;coordinate_type&gt; objects.&nbsp; Lists 
and vectors of models of polygon_concept or polygon_with_holes_concept are automatically models of polygon_set_concept.</p>
<h2>Operators</h2>
<table border="1" width="100%" id="table5">
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		polygon_set_view <b>operator</b>|(const T1&amp; l, const T2&amp; r)</font></td>
		<td>Boolean OR operation (polygon set union).&nbsp; Accepts two objects 
		that model polygon_set or one of its refinements.&nbsp; Returns an 
		operator template that performs the operation on demand when chained or 
		or nested in a library function call such as assign().</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		polygon_set_view <b>operator</b>+(const T1&amp; l, const T2&amp; r)</font></td>
		<td>Same as operator|.&nbsp; The plus sign is also used for OR 
		operations in Boolean logic expressions.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		polygon_set_view <b>operator</b>&amp;(const T1&amp; l, const T2&amp; r)</font></td>
		<td>Boolean AND operation (polygon set intersection).&nbsp; Accepts two 
		objects that model polygon_set or one of its refinements.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		polygon_set_view <b>operator</b>*(const T1&amp; l, const T2&amp; r)</font></td>
		<td>Same as operator&amp;.&nbsp; The multiplication symbol is also used for 
		AND operations in Boolean logic expressions.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		polygon_set_view <b>operator</b>^(const T1&amp; l, const T2&amp; r)</font></td>
		<td>Boolean XOR operation (polygon set disjoint-union).&nbsp; Accepts 
		two objects that model polygon_set or one of its refinements.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		polygon_set_view <b>operator</b>-(const T1&amp; l, const T2&amp; r)</font></td>
		<td>Boolean SUBTRACT operation (polygon set difference).&nbsp; Accepts 
		two objects that model polygon_set or one of its refinements.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		T1&amp; <b>operator</b>|=(const T1&amp; l, const T2&amp; r)</font></td>
		<td>Same as operator|, but with self assignment, left operand must model 
		polygon_set and not one of it's refinements.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		T1&amp; <b>operator</b>+=(T1&amp; l, const T2&amp; r)</font></td>
		<td>Same as operator+, but with self assignment, left operand must model 
		polygon_set and not one of it's refinements.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		T1&amp; <b>operator</b>&amp;=(const T1&amp; l, const T2&amp; r)</font></td>
		<td>Same as operator&amp;, but with self assignment, left operand must model 
		polygon_set and not one of it's refinements.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		T1&amp; <b>operator</b>*=(T1&amp; l, const T2&amp; r)</font></td>
		<td>Same as operator*, but with self assignment, left operand must model 
		polygon_set and not one of it's refinements.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		T1&amp; <b>operator</b>^=(const T1&amp; l, const T2&amp; r)</font></td>
		<td>Same as operator^, but with self assignment, left operand must model 
		polygon_set and not one of it's refinements.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		T1&amp; <b>operator</b>-=(T1&amp; l, const T2&amp; r)</font></td>
		<td>Same as operator-, but with self assignment, left operand must model 
		polygon_set and not one of it's refinements.</td>
	</tr>
	</table>
<h2>Functions</h2>
<table border="1" width="100%" id="table6">
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		T1&amp; <b>assign</b>(T1&amp; lvalue, const T2&amp; rvalue)</font></td>
		<td>Eliminates overlaps in geometry and copies from an object that 
		models polygon_set or any of its refinements into an object that 
		models polygon_set</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T1, typename 
		T2&gt;<br>
		bool <b>equivalence</b>(const T1&amp; lvalue, const T2&amp; rvalue) </font></td>
		<td>Returns true if an object that models polygon_set or one of its 
		refinements covers the exact same geometric regions as another object 
		that models polygon_set or one of its refinements.&nbsp; For example: 
		two of polygon objects.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename 
		polygon_set_type&gt;<br>
		void <b>clear</b>(polygon_set_type&amp; polygon_set)</font></td>
		<td>Makes the object empty of geometry.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename 
		polygon_set_type&gt;<br>
		bool <b>empty</b>(const polygon_set_type&amp; polygon_set)</font></td>
		<td>Checks whether the object is empty of geometry.&nbsp; Polygons that 
		are completely covered by holes will result in empty returning true.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T, typename 
		rectangle_type&gt;<br>
		bool <b>extents</b>(rectangle_type&amp; extents_rectangle, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const 
		T&amp; polygon_set)</font></td>
		<td>Computes bounding box of an object that models polygon_set and 
		stores it in an object that models rectangle.&nbsp; If the polygon set 
		is empty returns false.&nbsp; If there are holes outside of shells they 
		do not contribute to the extents of the polygon set.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T&gt;<br>
		area_type <b>area</b>(const T&amp; polygon_set)</font></td>
		<td>Computes the area covered by geometry in an object that models 
		polygon_set</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T&gt;<br>
T&amp; <b>scale_up</b>(T&amp; polygon_set, unsigned_area_type factor)</font></td>
		<td>Scales geometry up by unsigned factor..</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T&gt;<br>
T&amp; <b>scale_down</b>(T&amp; polygon_set, unsigned_area_type factor)</font></td>
		<td>Scales geometry down by unsigned factor.&nbsp; </td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T, typename transformation_type&gt;<br>
T&amp; <b>transform</b>(T&amp; polygon_set,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const 
transformation_type&amp; transformation)</font></td>
		<td>Applies transformation.transform() on all vertices.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename T&gt;<br>
T&amp; <b>keep</b>(T&amp; polygon_set, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_area_type min_area,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_area_type max_area,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_area_type min_width,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_area_type max_width,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_area_type min_height,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned_area_type max_height)</font></td>
		<td>Retains only regions that satisfy the min/max criteria in the 
		argument list.&nbsp; Note: useful for visualization to cull too small 
		polygons.</td>
	</tr>
	</table>
	<h1>Polygon Set Data Object</h1>

<p> 
<p>The polygon set data type encapsulates the internal data format that 
serves as the input to the sweep-line algorithm that implements polygon-clipping 
Boolean operations.&nbsp; It also internally keeps track of whether that data 
has been sorted or scanned and maintains the invariant that when its flags 
indicate that the data is sorted or scanned the data has not been changed to 
violate that assumption.&nbsp; Using the Polygon Set Data type directly can 
be more efficient than using lists and vectors of polygons in the functions 
above because of the invariants it can enforce which provide the opportunity to 
maintain the data is sorted form rather than going all the way out to polygons 
then resorting those vertices for a subsequent operation.</p>
<p>The declaration of Polygon Set Data is the following:</p>
<p><font face="Courier New">template &lt;typename T&gt;<br>
class polygon_set_data;</font></p>
<p>The class is parameterized on the coordinate data type.&nbsp; Algorithms that 
benefit from knowledge of the invariants enforced by the class are implemented 
as member functions to provide them access to information about those 
invariants.&nbsp; </p>
<h2>Member Functions</h2>
<table border="1" width="100%" id="table7">
	<tr>
		<td width="586"><font face="Courier New"><b>polygon_set_data</b>()</font></td>
		<td>Default constructor. </td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename iT&gt;<br>
	<b>polygon_set_data</b>(iT input_begin, iT 
	input_end)</font></td>
		<td>Construct with scanning orientation from an iterator range of 
		insertable objects.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">
	<b>polygon_set_data</b>(const polygon_set_data&amp; that)</font></td>
		<td>Copy construct.</td>
	</tr>
	<tr>
		<td width="586">
<font face="Courier New">template &lt;typename l, typename r, typename op&gt;<br>
<b>polygon_set_data</b>(const polygon_set_view&lt;l,r,op&gt;&amp; 
t)</font></td>
		<td>Copy construct from a Boolean operator template.</td>
	</tr>
	<tr>
		<td width="586">
<font face="Courier New">polygon_set_data&amp; <br><b>operator=</b>(const polygon_set_data&amp; that)</font></td>
		<td>Assignment from another polygon set, may change scanning 
		orientation.</td>
	</tr>
	<tr>
		<td width="586">
<font face="Courier New">template &lt;typename l, typename r, typename op&gt;<br>
polygon_set_data&amp; <br><b>operator=</b>(const polygon_set_view&lt;l, r, 
op&gt;&amp; that)</font></td>
		<td>Assignment from a Boolean operator template.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">template &lt;typename geometry_object&gt;<br>
polygon_set_data&amp; <b>operator=</b>(const geometry_object&amp; geo)</font></td>
		<td>Assignment from an insertable object.</td>
	</tr>
	<tr>
		<td width="586">
<font face="Courier New">
template &lt;typename iT&gt;<br>
void <b>insert</b>(iT input_begin, iT input_end)</font></td>
		<td>Insert objects of an iterator range.</td>
	</tr>
	<tr>
		<td width="586">
<font face="Courier New">
void <b>insert</b>(const polygon_set_data&amp; polygon_set)</font></td>
		<td>Insert a polygon set.</td>
	</tr>
	<tr>
		<td width="586">
<font face="Courier New">
template &lt;typename geometry_type&gt;<br>
void <b>insert</b>(const geometry_type&amp; geometry_object, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool is_hole 
= false)</font></td>
		<td>Insert a geometry object, if is_hole is true then the inserted 
		region is subtractive rather than additive.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">
template &lt;typename output_container&gt;<br>
void <b>get</b>(output_container&amp; output) const</font></td>
		<td>Expects a standard container of polygons objects.&nbsp; Will scan 
		and eliminate overlaps.&nbsp; Converts polygon set geometry to objects 
		of the polygon type and appends them to the container.</td>
	</tr>
	<tr>
		<td width="586">
<font face="Courier New">
bool <b>operator==</b>(const polygon_set_data&amp; p) const</font></td>
		<td>Once scanned the data representation of geometry within a polygon 
		set is in a mathematically canonical form.&nbsp; Comparison between two 
		sets is therefore a linear time operation once they are in the scanned 
		state. Will scan and eliminate overlaps in both polygon sets.&nbsp; </td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">
bool <b>operator!=</b>(const polygon_set_data&amp; p) const</font></td>
		<td>Inverse logic of equivalence operator.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">void <b>clear</b>()</font></td>
		<td>Make the polygon set empty.&nbsp; Note: does not de-allocate memory.&nbsp; 
		Use shrink to fit idiom and assign default constructed polygon set to 
		de-allocate.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">bool <b>empty</b>() const </font>
		</td>
		<td>Check whether the polygon set contains no geometry.&nbsp; Will scan 
		and eliminate overlaps because subtractive regions might make the 
		polygon set empty.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">void <b>clean</b>() const</font></td>
		<td>Scan and eliminate overlaps.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">
template &lt;typename input_iterator_type&gt;<br>
void <b>set</b>(input_iterator_type input_begin, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; input_iterator_type input_end) </font>
		</td>
		<td>Overwrite geometry in polygon set with insertable objects in the 
		iterator range. </td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">
template &lt;typename rectangle_type&gt;<br>
bool <b>extents</b>(rectangle_type&amp; extents_rectangle) const</font></td>
		<td>Given an object that models rectangle, scans and eliminates overlaps 
		in the polygon set because subtractive regions may alter its extents 
		then computes the bounding box and assigns it to extents_rectangle.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">
template &lt;typename transformation_type&gt;<br>
polygon_set_data&amp; <br><b>transform</b>(const transformation_type&amp; transformation) </font>
		</td>
		<td>Applies transformation.transform() on vertices stored within the 
		polygon set.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">
polygon_set_data&amp; <b>scale_up</b>(unsigned_area_type factor)</font></td>
		<td>Scales vertices stored within the polygon set up by factor.</td>
	</tr>
	<tr>
		<td width="586">
<font face="Courier New">polygon_set_data&amp; <b>scale_down</b>(unsigned_area_type 
factor)</font>&nbsp;</td>
		<td>Scales vertices stored within the polygon set down by factor.</td>
	</tr>
	<tr>
		<td width="586"><font face="Courier New">
template &lt;typename scaling_type&gt;<br>
polygon_set_data&amp;<br> <b>scale</b>(const scaling_type&amp; 
		f)</font></td>
		<td>Scales vertices stored within the polygon set by applying f.scale().</td>
	</tr>
	</table>
	<tr>
<td style="background-color: rgb(238, 238, 238);" nowrap="1" valign="top">
    &nbsp;</td>
<td style="padding-left: 10px; padding-right: 10px; padding-bottom: 10px;" valign="top" width="100%">

&nbsp;</html>