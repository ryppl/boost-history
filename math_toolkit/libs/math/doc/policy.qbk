[section:policy Policies]

[section:pol_overview Policy Overview]

Policies are a powerful fine-grain mechanism that allow you to customise the
behaviour of this library according to your needs.

Unless you find that the default policy behaviour
when encountering 'bad' argument values does not meet your needs,
you should not need to worry about policies.

Policies are a compile-time mechanism that allow you to change 
error-handling or calculation precision either
program wide, or at the call site.

Although the policy mechanism itself is rather complicated,
in practice it is easy to use, and very flexible.

Using policies you can control:

* [link math_toolkit.policy.pol_ref.error_handling_policies How results from 'bad' arguments are handled],
   including those that cannot be fully evaluated.
* How [link math_toolkit.policy.pol_ref.internal_promotion accuracy is controlled by internal promotion] to use more precise types.
* What working [link math_toolkit.policy.pol_ref.precision_pol precision] should be used to calculate results.
* What do to when a [link math_toolkit.policy.pol_ref.assert_undefined mathematically undefined function]
  is used. Compile or not?
* Whether [link math_toolkit.policy.pol_ref.discrete_quant_ref discrete functions],
  like the binomial, should return real or only integral values, and how they are rounded.
  
You can control policies:

* Using [link math_toolkit.policy.pol_ref.policy_defaults macros] to change any default policy.
* At your chosen [link math_toolkit.policy.pol_ref.namespace_pol namespace scope] for distributions and/or functions.

[endsect][/section:pol_overview Policy Overview]

[section:pol_tutorial Policy Tutorial]

[heading So Just What is a Policy Anyway?]

A policy is a compile-time mechanism for customising the behaviour of a 
special function, or a statistical distribution.  With Policies you can
control:

* What action to take when an error occurs.
* What happens when you call a function that is mathematically undefined
(for example if you ask for the mean of a Cauchy distribution).
* What happens when you ask for a quantile of a discrete distribution.
* Whether the library is allowed to internally promote `float` to `double`
and `double` to `long double` in order to improve precision.
* What precision to use when calculating the result.

Some of these policies could arguably be runtime variables, but then we couldn't
use compile-time dispatch internally to select the best evaluation method
for the given policies.

For this reason a Policy is a /type/: in fact it's an instance of the 
class template `boost::math::policies::policy<>`.  This class is just a 
compile-time-container of user-defined policies (sometimes called a typelist):

   using namespace boost::math::policies;
   //
   // Define a policy that sets ::errno on overflow, and does
   // not promote double to long double internally:
   //
   typedef policy<domain_error<errno_on_error>, promote_double<false> > mypolicy;

[heading Policies Have Sensible Defaults]

Most of the time you can just ignore the policy framework, the defaults for 
the various policies are as follows, if these work OK for you then you can
stop reading now!

[variablelist
[[Domain Error][Throws a `std::domain_error` exception.]]
[[Pole Error][Occurs when a function is evaluated at a pole: throws a `std::domain_error` exception.]]
[[Overflow Error][Throws a `std::overflow_error` exception.]]
[[Underflow][Ignores the underflow, and returns zero.]]
[[Denormalised Result][Ignores the fact that the result is denormalised, and returns it]]
[[Internal Evaluation Error][Throws a `boost::math::evaluation_error` exception.]]
[[Promotion of float to double][Does occur by default - gives full float precision results.]]
[[Promotion of double to long double][Does occur by default if long double offers
   more precision than double.]]
[[Precision of Approximation Used][By default uses an approximation that 
   will result in the lowest level of error for the type of the result.]]
[[Behaviour of Discrete Quantiles][Returns an integer result that is rounded
   down for lower quantiles and rounded up for upper quantiles - see TODO LINK HERE!!]]
]

What's more, if you define your own policy type, then it automatically
inherits the defaults for any policies not explicitly set, so given:

   using namespace boost::math::policies;
   //
   // Define a policy that sets ::errno on overflow, and does
   // not promote double to long double internally:
   //
   typedef policy<domain_error<errno_on_error>, promote_double<false> > mypolicy;

then `mypolicy` defines a policy where only the overflow error handling and
`double`-promotion policies differ from the defaults.

[heading So How are Policies Used Anyway?]

The details follow later, but basically policies can be set by either:

* Defining some macros that change the default behaviour: this is the 
   recomended method for setting installation-wide policies.
* By instantiating a distribution object with an explicit policy:
   this is mainly reserved for ad hoc policy changes.
* By passing a policy to a special function as an optional final argument:
   this is mainly reserved for ad hoc policy changes.
* By using some helper macros to define a set of functions or distributions
in the current namespace that use a specific policy: this is the
recomended method for setting policies on a project- or translation-unit-wide
basis.

The following sections introduce these methods in more detail.

[heading Changing the Policy Defaults]

The default policies used by the library are changed by the usual
configuration macro method.

For example passing `-DBOOST_MATH_DOMAIN_ERROR_POLICY=errno_on_error` to
your compiler will cause domain errors to set `::errno` and return a NaN
rather than the usual default behaviour of throwing a `std::domain_error`
exception.  There is however a very important caveat to this:

[important
[*['Default policies changed by setting configuration macros must be changed
uniformly in every translation unit in the program.]] 

Failure to follow this rule may result in violations of the "One
Definition Rule (ODR)" and result in unpredictable program behaviour.]

That means there are only two safe ways to use these macros:

* Edit them in [@../../../../boost/math/tools/user.hpp boost/math/tools/user.hpp],
so that the defaults are set on an installation-wide basis.  Unfortunately this may not be convenient if
you are using a pre-installed Boost distribution (on Linux for example).
* Set the defines in your project's makefile or build environment, so that they
are set uniformly across all translation units.

What you should not do is:

* Set the defines in the source file using `#define` as doing so
almost certainly will break your program, unless you're absolutely
certain that the program is restricted to a single translation unit.

And, yes, you will find examples in our test programs where we break this
rule: but only because we know there will always be a single
translation unit only: don't say that you weren't warned!

[heading Setting Policies for Distributions on an Ad Hoc Basis]

All of the statistical distributions in this library are class templates
that accept two template parameters, both with sensible defaults, for
example:

   namespace boost{ namespace math{
   
   template <class RealType = double, class Policy = policies::policy<> >
   class fisher_f_distribution;
   
   typedef fisher_f_distribution<> fisher_f;
   
   }}
   
So if you use the shorthand-typedef for the distribution, then you get
`double` precision arithmetic and all the default policies.

However, say for example we wanted to evaluate the quantile
of the binomial distribution at float precision, without internal
promotion to double, and with the result rounded to the /nearest/
integer, then here's how it can be done:

[import ../example/policy_eg_3.cpp]

[policy_eg_3]

Which outputs:

[pre quantile is: 40]

[heading Changing the Policy on an Ad Hoc Basis for the Special Functions]

All of the special functions in this library come in two overloaded forms,
one with a final "policy" parameter, and one without.  For example:

   namespace boost{ namespace math{
   
   template <class RealType, class Policy>
   RealType tgamma(RealType, const Policy&);
   
   template <class RealType>
   RealType tgamma(RealType);
   
   }} // namespaces
   
Normally, the second version is just a forwarding wrapper to the first
like this:

   template <class RealType>
   inline RealType tgamma(RealType x)
   {
      return tgamma(x, policies::policy<>());
   }

So calling a special function with a specific policy
is just a matter of defining the policy type to use
and passing it as the final parameter.  For example,
suppose we want tgamma to behave in a C-compatible
fashion and set errno when an error occurs, and never
throw an exception:

[import ../example/policy_eg_1.cpp]

[policy_eg_1]

that outputs:

[pre 
Result of tgamma(30000) is: 1.#INF
errno = 34
Result of tgamma(-10) is: 1.#QNAN
errno = 33
]

Alternatively, for ad hoc use, we can use the `make_policy`
helper function to create a policy for us: this usage is more
verbose, so is probably only preferred when a policy is going
to be used once only:

[import ../example/policy_eg_2.cpp]

[policy_eg_2]

[heading Setting Policies at Namespace or Translation Unit Scope]

Sometimes what you want to do is just change a set of policies within 
the current scope: the one thing you should not do in this situation
is use the configuration macros, as this can lead to "One Definition
Rule" violations.  Instead this library provides a pair of macros
especially for this purpose.

Let's consider the special functions first: we can declare a set of
forwarding functions that all use a specific policy using the
macro BOOST_MATH_DECLARE_SPECIAL_FUNCTIONS(['Policy]).  This
macro should be used either inside a unique namespace set aside for the 
purpose, or an unnamed namespace if you just want the functions
visible in global scope for the current file only.  

[import ../example/policy_eg_4.cpp]

[policy_eg_4]

The same mechanism works well at file scope as well, by using an unnamed 
namespace, we can ensure that these declarations don't conflict with any
alternate policies present in other translation units:

[import ../example/policy_eg_5.cpp]

[policy_eg_5]

Handling the statistical distributions is very similar except that now
the macro BOOST_MATH_DECLARE_DISTRIBUTIONS accepts two parameters: the
floating point type to use, and the policy type to apply.  For example:

   BOOST_MATH_DECLARE_DISTRIBUTIONS(double, mypolicy)
   
Results a set of typedefs being defined like this:

   typedef boost::math::normal_distribution<double, mypolicy> normal;
   
The name of each typedef is the same as the name of the distribution 
class template, but without the "_distribution" suffix.

[import ../example/policy_eg_6.cpp]

[policy_eg_6]

As before, the same mechanism works well at file scope as well: by using an unnamed 
namespace, we can ensure that these declarations don't conflict with any
alternate policies present in other translation units:

[import ../example/policy_eg_7.cpp]

[policy_eg_7]

[endsect][/section:pol_Tutorial Policy Tutorial]

[section:pol_ref Policy Reference]

[section:error_handling_policies Error Handling Policies]

There are two orthogonal aspects to error handling:

* What to do (if anything) with the error.
* What kind of error is being raised.

[h4 Available Actions When an Error is Raised]

What to do with the error is encapsulated by an enumerated type:

   namespace boost { namespace math { namespace policies {
   
   enum error_policy_type
   {
      throw_on_error = 0, // throw an exception.
      errno_on_error = 1, // set ::errno & return 0, NaN, infinity or best guess.
      ignore_error = 2, // return 0, NaN, infinity or best guess.
      user_error = 3  // call a user-defined error handler.
   };

   }}} // namespaces
   
The various enumerated values have the following meanings:

[h5 throw_on_error]

Will throw one of the following exceptions, depending upon the
 type of the error:
    [table
       [[Error Type][Exception]]
       [[Domain Error][std::domain_error]]
       [[Pole Error][std::domain_error]]
       [[Overflow Error][std::overflow_error]]
       [[Underflow Error][std::underflow_error]]
       [[Denorm Error][std::underflow_error]]
       [[Evaluation Error][boost::math::evaluation_error]]
    ]

[h5 errno_on_error]

Will set global ::errno to one of the following values depending 
upon the error type, and then return the same value as if the error
had been ignored:
 [table
    [[Error Type][errno value]]
    [[Domain Error][EDOM]]
    [[Pole Error][EDOM]]
    [[Overflow Error][ERANGE]]
    [[Underflow Error][ERANGE]]
    [[Denorm Error][ERANGE]]
    [[Evaluation Error][EDOM]]
 ]

[h5 ignore_error]

Will return a one of the values below depending on the error type (::errno is NOT changed)::
 [table
    [[Error Type][errno value]]
    [[Domain Error][std::numeric_limits<T>::quiet_NaN()]]
    [[Pole Error][std::numeric_limits<T>::quiet_NaN()]]
    [[Overflow Error][std::numeric_limits<T>::infinity()]]
    [[Underflow Error][0]]
    [[Denorm Error][The denormalised value.]]
    [[Evaluation Error][The best guess as to the result: which
          may be significantly in error.]]
 ]

[h5 user_error]

Will call a user defined error handler: these are forward declared
in boost/math/policies/error_handling.hpp, but the actual definitions
must be provided by the user:

   template <class T>
   T user_domain_error(const char* function, const char* message, const T& val);
   
   template <class T>
   T user_pole_error(const char* function, const char* message, const T& val);
   
   template <class T>
   T user_overflow_error(const char* function, const char* message, const T& val);
   
   template <class T>
   T user_underflow_error(const char* function, const char* message, const T& val);
   
   template <class T>
   T user_denorm_error(const char* function, const char* message, const T& val);
   
   template <class T>
   T user_evaluation_error(const char* function, const char* message, const T& val);

Note that the strings ['function] and ['message] contain "%1%" format specifiers
designed to be used in conjunction with Boost.Format.  
If these strings are to be presented to the program's end-user then 
the "%1%" format specifier
should be replaced with the name of type T in the ['function] string, and the
specifier in the ['message] string should be replaced with the value of ['val].

[h4 Kinds of Error Raised]                  

There are five kinds of error reported by this library, 
which are summarised in the following table:

[table
[[Error Type]
   [Policy Class]
      [Description]]
[[Domain Error]
   [boost::math::policies::domain_error<['action]>]
      [Raised when more or more arguments are outside the 
      defined range of the function.

      Defaults to `boost::math::policies::domain_error<throw_on_error>`

      When the action is set to ['throw_on_error] 
      then throws `std::domain_error`]]
[[Pole Error]
   [boost::math::policies::pole_error<['action]>]
      [Raised when more or more arguments would cause the function
      to be evaluated at a pole.

      Defaults to `boost::math::policies::pole_error<throw_on_error>`

      When the action is ['throw_on_error] then
      throw a `std::domain_error`]]
[[Overflow Error]
   [boost::math::policies::overflow_error<['action]>]
      [Raised when the result of the function is outside
      the representable range of the floating point type used.

      Defaults to `boost::math::policies::overflow_error<throw_on_error>`.

      When the action is ['throw_on_error] then throws a `std::overflow_error`.]]
[[Underflow Error]
   [boost::math::policies::underflow_error<['action]>]
      [Raised when the result of the function is too small
      to be represented in the floating point type used.

      Defaults to `boost::math::policies::underflow_error<ignore_error>`

      When the specified action is ['throw_on_error] then
      throws a `std::underflow_error`]]
[[Denorm Error]
   [boost::math::policies::denorm_error<['action]>]
      [Raised when the result of the function is a
      denormalised value.

      Defaults to `boost::math::policies::denorm_error<ignore_error>`

      When the action is ['throw_on_error] then throws a `std::underflow_error`]]
[[Evaluation Error]
   [boost::math::policies::evaluation_error<['action]>]
      [Raised when the result of the function is well defined and
      finite, but we were unable to compute it.  Typically
      this occurs when an iterative method fails to converge.
      Of course ideally this error should never be raised: feel free
      to report it as a bug if it is!

      Defaults to `boost::math::policies::evaluation_error<throw_on_error>`

      When the action is ['throw_on_error] then throws `boost::math::evaluation_error`]]
]

[h4 Examples]

Suppose we want a call to `tgamma` to behave in a C-compatible way and set global
`::errno` rather than throw an exception, we can achieve this at the call site
using:

   #include <boost/math/special_functions/gamma.hpp>
   
   using namespace boost::math::policies;
   using namespace boost::math;
   
   // Define a policy:
   typedef policy<
         domain_error<errno_on_error>, 
         pole_error<errno_on_error>,
         overflow_error<errno_on_error>,
         evaluation_error<errno_on_error> 
         > my_policy;
         
   // call the function:
   double t = tgamma(some_value, my_policy());
   
   // Alternatively we could use make_policy and define everything at the call site:
   t = tgamma(some_value, make_policy(
            domain_error<errno_on_error>(), 
            pole_error<errno_on_error>(),
            overflow_error<errno_on_error>(),
            evaluation_error<errno_on_error>() 
         ));
   
Suppose we want a statistical distribution to return infinities,
rather than throw exceptions, then we can use:

   #include <boost/math/distributions/normal.hpp>
   
   using namespace boost::math::policies;
   using namespace boost::math;
   
   // Define a policy:
   typedef policy<
         overflow_error<ignore_error>
         > my_policy;
         
   // Define the distribution:
   typedef normal_distribution<double, my_policy> my_norm;
   
   // Get a quantile:
   double q = quantile(my_norm(), 0.05);

[endsect][/section:error_handling_policies Error Handling Policies]

[section:internal_promotion Internal Promotion Policies]

Normally when evaluating a function at say `float` precision, maximal
accuracy is assured by conducting the calculation at `double` precision
internally, and then rounding the result.  There are two policies that
effect whether internal promotion takes place or not:

[table
[[Policy][Meaning]]
[[`boost::math::policies::promote_float<B>`]
   [Indicates whether `float` arguments should be promoted to `double`
   precision internally: defaults to `boost::math::policies::promote_float<true>`]]
[[`boost::math::policies::promote_double<B>`]
   [Indicates whether `double` arguments should be promoted to `long double`
   precision internally: defaults to `boost::math::policies::promote_double<true>`]]
]

[h4 Examples]

Suppose we want `tgamma` to be evaluated without internal promotion to
`long double`, then we could use:

   #include <boost/math/special_functions/gamma.hpp>
   
   using namespace boost::math::policies;
   using namespace boost::math;
   
   // Define a policy:
   typedef policy<
         promote_double<false> 
         > my_policy;
         
   // Call the function:
   double t = tgamma(some_value, my_policy());
   
   // Alternatively we could use make_policy and define everything at the call site:
   t = tgamma(some_value, make_policy(promote_double<false>()));
   
Alternatively, suppose we want a distribution to perform calculations
without promoting `float` to `double`, then we could use:

   #include <boost/math/distributions/normal.hpp>
   
   using namespace boost::math::policies;
   using namespace boost::math;
   
   // Define a policy:
   typedef policy<
         promote_float<false>
         > my_policy;
         
   // Define the distribution:
   typedef normal_distribution<float, my_policy> my_norm;
   
   // Get a quantile:
   float q = quantile(my_norm(), 0.05f);
   
[endsect][/section:internal_promotion Internal Promotion Policies]

[section:assert_undefined Mathematically Undefined Function Policies]

There are some functions that are generic
(they are present for all the statistical distributions supported)
but which may be mathematically undefined for certain distributions, but defined for others.

For example, the Cauchy distribution does not have a mean, so what should

   mean(cauchy<>());
   
return, and should such an expression even compile at all?

The default behaviour is for all such functions to not compile at all
 - in fact they will raise a 
[@http://www.boost.org/libs/static_assert/index.html static assertion]
 - but by changing the policy
we can have them return the result of a domain error instead
(which may well throw an exception, depending on the error handling policy). 

This behaviour is controlled by the `assert_undefined<>` policy:

   namespace boost{ namespace math{ namespace policies {

   template <bool b>
   class assert_undefined;

   }}} //namespaces

For example:

   #include <boost/math/distributions/cauchy.hpp>
   
   using namespace boost::math::policies;
   using namespace boost::math;
   
   // This will not compile, cauchy has no mean!
   double m1 = mean(cauchy()); 
   
   // This will compile, but raises a domain error!
   double m2 = mean(cauchy_distribution<double, policy<assert_undefined<false> > >());
 
[endsect][/section:assert_undefined Mathematically Undefined Function Policies]

[section:discrete_quant_ref Discrete Quantile Policies]

If a statistical distribution is ['discrete] then the random variable
can only have integer values - this leaves us with a problem when calculating
quantiles - we can either ignore the discreteness of the distribution and return
a real value, or we can round to an integer.  As it happens, computing integer
values can be substantially faster than calculating a real value, so there are
definite advantages to returning an integer, but we do then need to decide
how best to round the result.  The `discrete_quantile` policy defines how
discrete quantiles work, and how integer results are rounded:

   enum discrete_quantile_policy_type
   {
      real,
      integer_outside,
      integer_inside,
      integer_below,
      integer_above,
      integer_nearest
   };
   
   template <discrete_quantile_policy_type>
   struct discrete_quantile;
   
The values that `discrete_quantile` can take have the following meanings:

[h5 real]

Ignores the discreteness of the distribution, and returns a real-valued 
result.  For example:

   #include <boost/math/distributions/negative_binomial.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policies;
   
   typedef negative_binomial_distribution<
         double, 
         policy<discrete_quantile<integer_inside> > 
      > dist_type;
      
   double x, y;
   
   // Lower quantile:
   x = quantile(dist_type(20, 0.3), 0.05);
   // Upper quantile:
   y = quantile(complement(dist_type(20, 0.3), 0.05));
   
Results in `x = 27.3898` and `y = 68.1584`.

[h5 integer_outside]

This is the default policy: an integer value is returned so that:

* Lower quantiles (where the probability is less than 0.5) are rounded
down.
* Upper quantiles (where the probability is greater than 0.5) are rounded up.

This is normally the safest rounding policy, since it ensures that both
one and two sided intervals are guaranteed to have ['at least] 
the requested coverage.  For example:

   #include <boost/math/distributions/negative_binomial.hpp>
   
   using namespace boost::math;
   
   double x, y;
   
   // Lower quantile rounded down:
   x = quantile(negative_binomial(20), 0.05);
   // Upper quantile rounded up:
   y = quantile(complement(negative_binomial(20), 0.05));
   
Results in `x = 27` (rounded down from 27.3898) and `y = 69` (rounded up from 68.1584).

The variables x and y are now defined so that:

   cdf(negative_binomial(20), x) <= 0.05
   cdf(negative_binomial(20), y) >= 0.95
   
In other words we guarantee ['at least 90% coverage in the cenrtal region overall], 
and also ['no more than 5% coverage in each tail].

[h5 integer_inside]

This is the opposite of ['integer_outside]: an integer value is returned so that:

* Lower quantiles (where the probability is less than 0.5) are rounded
['up].
* Upper quantiles (where the probability is greater than 0.5) are rounded ['down].

For example:

   #include <boost/math/distributions/negative_binomial.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policies;
   
   typedef negative_binomial_distribution<
         double, 
         policy<discrete_quantile<integer_inside> > 
      > dist_type;
      
   double x, y;
   
   // Lower quantile rounded up:
   x = quantile(dist_type(20), 0.05);
   // Upper quantile rounded down:
   y = quantile(complement(dist_type(20), 0.05));
   
Results in `x = 28` (rounded up from 27.3898) and `y = 68` (rounded down from 68.1584).

The variables x and y are now defined so that:

   cdf(negative_binomial(20), x) >= 0.05
   cdf(negative_binomial(20), y) <= 0.95
   
In other words we guarantee ['at no more than 90% coverage in the cenrtal region overall], 
and also ['at least 5% coverage in each tail].

[h5 integer_below]

Always rounds down to an integer value, no matter whether it's an upper 
or a lower quantile.

[h5 integer_above]

Always rounds up to an integer value, no matter whether it's an upper 
or a lower quantile.

[h5 integer_nearest]

Always rounds to the nearest integer value, no matter whether it's an upper 
or a lower quantile.  This will produce the requested coverage
['in the average case], but for any specific example may results in
either significantly more or less coverage than the requested amount.
For example:

For example:

   #include <boost/math/distributions/negative_binomial.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policies;
   
   typedef negative_binomial_distribution<
         double, 
         policy<discrete_quantile<integer_nearest> > 
      > dist_type;
      
   double x, y;
   
   // Lower quantile rounded up:
   x = quantile(dist_type(20), 0.05);
   // Upper quantile rounded down:
   y = quantile(complement(dist_type(20), 0.05));

Results in `x = 27` (rounded from 27.3898) and `y = 68` (rounded from 68.1584).

[endsect][/section:discrete_quant_ref Discrete Quantile Policies]

[section:precision_pol Precision Policies]

There are two equivalent policies that effect the ['working precision]
used to calculate results, these policies both default to 0 - meaning
calculate to the maximum precision available in the type being used
 - but can be set to other values to cause lower levels of precision 
to be used.

   namespace boost{ namespace math{ namespace policies{
   
   template <int N>
   digits10;
   
   template <int N>
   digits2;
   
   }}} // namespaces
   
As you would expect, ['digits10] specifies the number of decimal digits
to use, and ['digits2] the number of binary digits.  Internally, whichever
is used, the precision is always converted to ['binary digits].

These policies are specified at compile-time, because many of the special
functions use compile-time-dispatch to select which approximation to use
based on the precision requested and the numeric type being used.

For example we could calculate tgamma to approximately 5 decimal digits using:

   #include <boost/math/special_functions/gamma.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policies;
   
   typedef policy<digits10<5> > pol;
   
   double t = tgamma(12, pol());
   
Or again using ['make_policy]:

   #include <boost/math/special_functions/gamma.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policies;
   
   double t = tgamma(12, policy<digits10<5> >());

And for a quantile of a distribution to approximately 25-bit precision:

   #include <boost/math/distributions/normal.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policies;
   
   double q = quantile(
         normal_distribution<double, policy<digits2<25> >(), 
         0.05);

[endsect][/section:precision_pol Precision Policies]

[section:policy_defaults Changing the Policy Defaults]

You can use the various macros below to change any (or all) of the policies.

You can make a local change by placing a macro definition *before*
a function or distribution #include.

[caution If you place it after the #include it will have no effect,
(and it will affect only any other following #includes).
This is probably not what you intend!]

[caution There is a danger of One-Definition-Rule violations if you 
add ad-hock macros to more than one source files: these must be set the same in *every 
translation unit*.]

If you want to alter the defaults for any or all of 
the policies for *all* functions and distributions, installation-wide,
then you can do so by defining various macros in
boost/math/tools/user.hpp.

[h5 BOOST_MATH_DOMAIN_ERROR_POLICY]

Defines what happens when a domain error occurs, if not defined then
defaults to `throw_on_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_POLE_ERROR_POLICY]

Defines what happens when a pole error occurs, if not defined then
defaults to `throw_on_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_OVERFLOW_ERROR_POLICY]

Defines what happens when an overflow error occurs, if not defined then
defaults to `throw_on_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_EVALUATION_ERROR_POLICY]

Defines what happens when an internal evaluation error occurs, if not defined then
defaults to `throw_on_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_UNDERFLOW_ERROR_POLICY]

Defines what happens when an overflow error occurs, if not defined then
defaults to `ignore_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_DENORM_ERROR_POLICY]

Defines what happens when a denormalisation error occurs, if not defined then
defaults to `ignore_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_DIGITS10_POLICY]

Defines how many decimal digits to use in internal computations: 
defaults to `0` - meaning use all available digits - but can be set
to some other decimal value.  Since setting this is likely to have
a substantial impact on accuracy, it's not generally recomended
that you change this from the default.

[h5 BOOST_MATH_PROMOTE_FLOAT_POLICY]

Determines whether `float` types get promoted to `double`
internally to ensure maximum precision in the result, defaults
to `true`, but can be set to `false` to turn promotion of
`float`'s off.

[h5 BOOST_MATH_PROMOTE_DOUBLE_POLICY]

Determines whether `double` types get promoted to `long double`
internally to ensure maximum precision in the result, defaults
to `true`, but can be set to `false` to turn promotion of
`double`'s off.

[h5 BOOST_MATH_DISCRETE_QUANTILE_POLICY]

Determines how disrete quantiles return their results: either
as an integer, or as a real value, can be set to one of the
enumerated values: `real`, `integer_outside`, `integer_inside`,
`integer_below`, `integer_above`, `integer_nearest`.  Defaults to
`integer_outside`.

[h5 BOOST_MATH_ASSERT_UNDEFINED_POLICY]

Determines whether functions that are mathematically undefined
for a specific distribution compile or raise a static (i.e. compile-time)
assertion.  Defaults to `true`: meaning that any mathematically
undefined function will not compile.  When set to `false` then the function
will compile but return the result of a domain error: this can be useful
for some generic code, that needs to work with all distributions and determine
at runtime whether or not a particular property is well defined.

[h5 Example]

Suppose we want overflow errors to set errno and return an infinity,
discrete quantiles to return a real-valued result (rather than round to
integer), and for mathematically undefined functions to compile, but return
a domain error. Then we could add the following to boost/math/tools/user.hpp:

   #define BOOST_MATH_OVERFLOW_ERROR_POLICY errno_on_error
   #define BOOST_MATH_DISCRETE_QUANTILE_POLICY real
   #define BOOST_MATH_ASSERT_UNDEFINED_POLICY false
   
or we could place these definitions *before*

   #include <boost/math/distributions/normal.hpp>
     using boost::math::normal_distribution;

in a source .cpp file.
[/ TODO could use a normal example here?]

[endsect][/section:policy_defaults Changing the Policy Defaults]

[section:namespace_pol Setting Polices at Namespace Scope]

Sometimes what you really want to do is bring all the special functions,
or all the distributions into a specific namespace-scope, along with
a specific policy to use with them.  There are two macros defined to
assist with that:

   BOOST_MATH_DECLARE_SPECIAL_FUNCTIONS(Policy)

and:

   BOOST_MATH_DECLARE_DISTRIBUTIONS(Type, Policy)
   
You can use either of these macros after including any special function
or distribution header.  For example:

   #include <boost/math/special_functions/gamma.hpp>
   
   namespace myspace{
   
   using namespace boost::math::policies;
   
   // Define a policy that does not throw on overflow:
   typedef policy<overflow_error<errno_on_error> > my_policy;

   // Define the special functions in this scope to use the policy:   
   BOOST_MATH_DECLARE_SPECIAL_FUNCTIONS(my_policy)
   
   }
   
   //
   // Now we can use myspace::tgamma etc.
   // They will automatically use "my_policy":
   //
   double t = myspace::tgamma(30.0); // will not throw on overflow

In this example, using BOOST_MATH_DECLARE_SPECIAL_FUNCTIONS results in
a set of thin inline forwarding functions being defined:

   template <class T>
   inline T tgamma(T a){ return ::boost::math::tgamma(a, mypolicy()); }
   
   template <class T>
   inline T lgamma(T a) ( return ::boost::math::lgamma(a, mypolicy()); }
   
and so on.  Note that a forwarding function is defined for all the special
functions, however, unless you include the specific header for the special
function you use (or boost/math/special_functions.hpp), you will get 
linker errors from undefined functions.

We can do the same thing with the distributions, but this time we need to
specify the floating-point type to use:

   #include <boost/math/distributions/cauchy.hpp>
   
   namespace myspace{
   
   using namespace boost::math::policies;
   
   // Define a policy to use, in this case we want all the distribution
   // accessor functions to compile, even if they are mathematically
   // undefined:
   typedef policy<assert_undefined<false> > my_policy;
   
   BOOST_MATH_DECLARE_DISTRIBUTIONS(double, my_policy)
   
   }
   
   // Now we can use myspace::cauchy etc, which will use policy
   // myspace::mypolicy:
   //
   // This compiles but raises a domain error at runtime:
   //
   double d = mean(myspace::cauchy()); 
   
In this example the result of BOOST_MATH_DECLARE_DISTRIBUTIONS is to
declare a typedef for each distribution like this:

   typedef boost::math::cauchy_distribution<double, my_policy> cauchy;
   tyepdef boost::math::gamma_distribution<double, my_policy> gamma;
   
and so on.  The name given to each typedef is the name of the distribution
with the "_distribution" suffix removed.

[endsect][/section Changing the Policy Defaults]

[section:pol_ref_ref Policy Class Reference]

There's very little to say here, the `policy` class is just a rag-bag
compile-time container for a collection of policies:

```#include <boost/math/policies/policy.hpp>```


   namespace boost{
   namespace math{
   namespace policies
   
   template <class A1 = default_policy, 
             class A2 = default_policy, 
             class A3 = default_policy,
             class A4 = default_policy,
             class A5 = default_policy,
             class A6 = default_policy,
             class A7 = default_policy,
             class A8 = default_policy,
             class A9 = default_policy,
             class A10 = default_policy,
             class A11 = default_policy>
   struct policy
   {
   public:
      typedef ``['computed-from-template-arguments]`` domain_error_type;
      typedef ``['computed-from-template-arguments]`` pole_error_type;
      typedef ``['computed-from-template-arguments]`` overflow_error_type;
      typedef ``['computed-from-template-arguments]`` underflow_error_type;
      typedef ``['computed-from-template-arguments]`` denorm_error_type;
      typedef ``['computed-from-template-arguments]`` evaluation_error_type;
      typedef ``['computed-from-template-arguments]`` precision_type;
      typedef ``['computed-from-template-arguments]`` promote_float_type;
      typedef ``['computed-from-template-arguments]`` promote_double_type;
      typedef ``['computed-from-template-arguments]`` discrete_quantile_type;
      typedef ``['computed-from-template-arguments]`` assert_undefined_type;
   };

   template <...argument list...>
   typename normalise<policy<>, A1>::type make_policy(...argument list..);

   template <class Policy, 
             class A1 = default_policy, 
             class A2 = default_policy, 
             class A3 = default_policy,
             class A4 = default_policy,
             class A5 = default_policy,
             class A6 = default_policy,
             class A7 = default_policy,
             class A8 = default_policy,
             class A9 = default_policy,
             class A10 = default_policy,
             class A11 = default_policy>
   struct normalise
   {
      typedef ``computed-from-template-arguments`` type;
   };

The member typedefs of class `policy` are intended for internal use
but are documented briefly here for the sake of completeness.

   policy<...>::domain_error_type
   
Specifies how domain errors are handled, will be an instance of
`boost::math::policies::domain_error<>` with the template argument to
`domain_error` one of the `error_policy_type` enumerated values.

   policy<...>::pole_error_type
   
Specifies how pole-errors are handled, will be an instance of
`boost::math::policies::pole_error<>` with the template argument to
`pole_error` one of the `error_policy_type` enumerated values.

   policy<...>::overflow_error_type
   
Specifies how overflow errors are handled, will be an instance of
`boost::math::policies::overflow_error<>` with the template argument to
`overflow_error` one of the `error_policy_type` enumerated values.

   policy<...>::underflow_error_type
   
Specifies how underflow errors are handled, will be an instance of
`boost::math::policies::underflow_error<>` with the template argument to
`underflow_error` one of the `error_policy_type` enumerated values.

   policy<...>::denorm_error_type
   
Specifies how denorm errors are handled, will be an instance of
`boost::math::policies::denorm_error<>` with the template argument to
`denorm_error` one of the `error_policy_type` enumerated values.

   policy<...>::evaluation_error_type
   
Specifies how evaluation errors are handled, will be an instance of
`boost::math::policies::evaluation_error<>` with the template argument to
`evaluation_error` one of the `error_policy_type` enumerated values.

   policy<...>::precision_type
   
Specifies the internal precision to use in binary digits (uses zero
to represent whatever the default precision is).  Will be an instance
of `boost::math::policies::digits2<N>` which in turn inherits from 
`boost::mpl::int_<N>`.

   policy<...>::promote_float_type
   
Specifies whether or not to promote `float` arguments to `double` precision
internally.  Will be an instance of `boost::math::policies::promote_float<B>`
which in turn inherits from `boost::mpl::bool_<B>`.

   policy<...>::promote_double_type
   
Specifies whether or not to promote `double` arguments to `long double` precision
internally.  Will be an instance of `boost::math::policies::promote_float<B>`
which in turn inherits from `boost::mpl::bool_<B>`.

   policy<...>::discrete_quantile_type
   
Specifies how discrete quantiles are evaluated, will be an instance
of `boost::math::policies::discrete_quantile<>` instantiated with one of
the `discrete_quantile_policy_type` enumerated type.

   policy<...>::assert_undefined_type
   
Specifies whether mathematically-undefined properties are
asserted as compile-time errors, or treated as runtime errors
instead.  Will be an instance of `boost::math::policies::assert_undefined<B>`
which in turn inherits from `boost::math::mpl::bool_<B>`.


   template <...argument list...>
   typename normalise<policy<>, A1>::type make_policy(...argument list..);

`make_policy` is a helper function that converts a list of policies into
a normalised `policy` class.

   template <class Policy, 
             class A1 = default_policy, 
             class A2 = default_policy, 
             class A3 = default_policy,
             class A4 = default_policy,
             class A5 = default_policy,
             class A6 = default_policy,
             class A7 = default_policy,
             class A8 = default_policy,
             class A9 = default_policy,
             class A10 = default_policy,
             class A11 = default_policy>
   struct normalise
   {
      typedef ``computed-from-template-arguments`` type;
   };
   
The `normalise` class template converts one instantiation of the
`policy` class into a normalised form.  This is used internally
to reduce code bloat: so that instantiating a special function
on `policy<A,B>` or `policy<B,A>` actually both generate the same
code internally.

[endsect][/section:pol_ref_ref Policy Class Reference]

[endsect][/section:pol_ref Policy Reference]
[endsect][/section:policy Policies]

[/ math.qbk
  Copyright 2007 John Maddock and Paul A. Bristow.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]


