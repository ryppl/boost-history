
[section:policy Policies]

Policies are a powerful mechanism that allow you to customise the
behaviour of this library according to your needs.  Policies are a
compile-time mechanism that allow you to change the behaviour of 
things such as error-handling or calculation precision either
program wide, or at the call site.

[section:pol_overview Policy Overview and Tutorial]

[endsect]

[section:pol_ref Policy Reference]

[section:pol_ref_ref The Policy Class]

There's very little to say here, the `policy` class is just a rag-bag
compile-time container for a collection of policies:

```#include <boost/math/policy/policy.hpp>```


   namespace boost{
   namespace math{
   namespace policy{
   
   template <class A1 = default_policy, 
             class A2 = default_policy, 
             class A3 = default_policy,
             class A4 = default_policy,
             class A5 = default_policy,
             class A6 = default_policy,
             class A7 = default_policy,
             class A8 = default_policy,
             class A9 = default_policy,
             class A10 = default_policy,
             class A11 = default_policy>
   struct policy
   {
   public:
      typedef ``['computed-from-template-arguments]`` domain_error_type;
      typedef ``['computed-from-template-arguments]`` pole_error_type;
      typedef ``['computed-from-template-arguments]`` overflow_error_type;
      typedef ``['computed-from-template-arguments]`` underflow_error_type;
      typedef ``['computed-from-template-arguments]`` denorm_error_type;
      typedef ``['computed-from-template-arguments]`` evaluation_error_type;
      typedef ``['computed-from-template-arguments]`` precision_type;
      typedef ``['computed-from-template-arguments]`` promote_float_type;
      typedef ``['computed-from-template-arguments]`` promote_double_type;
      typedef ``['computed-from-template-arguments]`` discrete_quantile_type;
      typedef ``['computed-from-template-arguments]`` assert_undefined_type;
   };

   template <...argument list...>
   typename normalise<policy<>, A1>::type make_policy(...argument list..);

   template <class Policy, 
             class A1 = default_policy, 
             class A2 = default_policy, 
             class A3 = default_policy,
             class A4 = default_policy,
             class A5 = default_policy,
             class A6 = default_policy,
             class A7 = default_policy,
             class A8 = default_policy,
             class A9 = default_policy,
             class A10 = default_policy,
             class A11 = default_policy>
   struct normalise
   {
      typedef ``computed-from-template-arguments`` type;
   };

The member typedefs of class `policy` are intended for internal use
but are documented briefly here for the sake of completeness.

   policy<...>::domain_error_type
   
Specifies how domain errors are handled, will be an instance of
`boost::math::policy::domain_error<>` with the template argument to
`domain_error` one of the `error_policy_type` enumerated values.

   policy<...>::pole_error_type
   
Specifies how pole-errors are handled, will be an instance of
`boost::math::policy::pole_error<>` with the template argument to
`pole_error` one of the `error_policy_type` enumerated values.

   policy<...>::overflow_error_type
   
Specifies how overflow errors are handled, will be an instance of
`boost::math::policy::overflow_error<>` with the template argument to
`overflow_error` one of the `error_policy_type` enumerated values.

   policy<...>::underflow_error_type
   
Specifies how underflow errors are handled, will be an instance of
`boost::math::policy::underflow_error<>` with the template argument to
`underflow_error` one of the `error_policy_type` enumerated values.

   policy<...>::denorm_error_type
   
Specifies how denorm errors are handled, will be an instance of
`boost::math::policy::denorm_error<>` with the template argument to
`denorm_error` one of the `error_policy_type` enumerated values.

   policy<...>::evaluation_error_type
   
Specifies how evaluation errors are handled, will be an instance of
`boost::math::policy::evaluation_error<>` with the template argument to
`evaluation_error` one of the `error_policy_type` enumerated values.

   policy<...>::precision_type
   
Specifies the internal precision to use in binary digits (uses zero
to represent whatever the default precision is).  Will be an instance
of `boost::math::policy::digits2<N>` which in turn inherits from 
`boost::mpl::int_<N>`.

   policy<...>::promote_float_type
   
Specifies whether or not to promote `float` arguments to `double` precision
internally.  Will be an instance of `boost::math::policy::promote_float<B>`
which in turn inherits from `boost::mpl::bool_<B>`.

   policy<...>::promote_double_type
   
Specifies whether or not to promote `double` arguments to `long double` precision
internally.  Will be an instance of `boost::math::policy::promote_float<B>`
which in turn inherits from `boost::mpl::bool_<B>`.

   policy<...>::discrete_quantile_type
   
Specifies how discrete quantiles are evaluated, will be an instance
of `boost::math::policy::discrete_quantile<>` instantiated with one of
the `discrete_quantile_policy_type` enumerated type.

   policy<...>::assert_undefined_type
   
Specifies whether mathematically-undefined properties are
asserted as compile-time errors, or treated as runtime errors
instead.  Will be an instance of `boost::math::policy::assert_undefined<B>`
which in turn inherits from `boost::math::mpl::bool_<B>`.


   template <...argument list...>
   typename normalise<policy<>, A1>::type make_policy(...argument list..);

`make_policy` is a helper function that converts a list of policies into
a normalised `policy` class.

   template <class Policy, 
             class A1 = default_policy, 
             class A2 = default_policy, 
             class A3 = default_policy,
             class A4 = default_policy,
             class A5 = default_policy,
             class A6 = default_policy,
             class A7 = default_policy,
             class A8 = default_policy,
             class A9 = default_policy,
             class A10 = default_policy,
             class A11 = default_policy>
   struct normalise
   {
      typedef ``computed-from-template-arguments`` type;
   };
   
The `normalise` class template converts one instantiation of the
`policy` class into a normalised form.  This is used internally
to reduce code bloat: so that instantiating a special function
on `policy<A,B>` or `policy<B,A>` actually both generate the same
code internally.

[endsect]

[section Error Handling Policies]

There are two orthogonal aspects to error handling:

# What to do (if anything) with the error.
# What kind of error is being raised.

[h4 Available Actions When an Error is Raised]

What to do with the error is encapsulated by an enumerated type:

   namespace boost{ namespace math{ namespace policy{
   
   enum error_policy_type
   {
      throw_on_error = 0,
      errno_on_error = 1,
      ignore_error = 2,
      user_error = 3
   };

   }}} // namespaces
   
The various enumerated values have the following meanings:

[h5 throw_on_error]

Will throw one of the following exceptions, depending upon the
 type of the error:
    [table
       [[Error Type][Exception]]
       [[Domain Error][std::domain_error]]
       [[Pole Error][std::domain_error]]
       [[Overflow Error][std::overflow_error]]
       [[Underflow Error][std::underflow_error]]
       [[Denorm Error][std::underflow_error]]
       [[Evaluation Error][boost::math::evaluation_error]]
    ]

[h5 errno_on_error]

Will set ::errno to one of the following values depending 
upon the error type, and then return the same value as if the error
had been ignored:
 [table
    [[Error Type][errno value]]
    [[Domain Error][EDOM]]
    [[Pole Error][EDOM]]
    [[Overflow Error][ERANGE]]
    [[Underflow Error][ERANGE]]
    [[Denorm Error][ERANGE]]
    [[Evaluation Error][EDOM]]
 ]

[h5 ignore_error]

Will return a one of the values below depending on the error type:
 [table
    [[Error Type][errno value]]
    [[Domain Error][std::numeric_limits<T>::quiet_NaN()]]
    [[Pole Error][std::numeric_limits<T>::quiet_NaN()]]
    [[Overflow Error][std::numeric_limits<T>::infinity()]]
    [[Underflow Error][0]]
    [[Denorm Error][The denormalised value.]]
    [[Evaluation Error][The best guess as to the result: which
          may be significantly in error.]]
 ]

[h5 user_error]

Will call a user defined error handler, these are forward declared
in boost/math/policy/error_handling.hpp, but the actual definitions
must be provided by the user:

   template <class T>
   T user_domain_error(const char* function, const char* message, const T& val);
   
   template <class T>
   T user_pole_error(const char* function, const char* message, const T& val);
   
   template <class T>
   T user_overflow_error(const char* function, const char* message, const T& val);
   
   template <class T>
   T user_underflow_error(const char* function, const char* message, const T& val);
   
   template <class T>
   T user_denorm_error(const char* function, const char* message, const T& val);
   
   template <class T>
   T user_evaluation_error(const char* function, const char* message, const T& val);

Note that the strings ['function] and ['message] contain "%1%" format specifiers
designed to be used in conjunction with Boost.Format.  
If these strings are to be presented to the program's end-user then 
the "%1%" format specifier
should be replaced with the name of type T in the ['function] string, and the
specifier in the ['message] string should be replaced with the value of ['val].

[h4 Kinds of Error Raised]                  

There are five kinds of error reported by this library, 
which are summarised in the following table:

[table
[[Error Type]
   [Policy Class]
      [Description]]
[[Domain Error]
   [boost::math::policy::domain_error<['action]>]
      [Raised when more or more arguments are outside the 
      defined range of the function.

      Defaults to `boost::math::policy::domain_error<throw_on_error>`

      When the action is set to ['throw_on_error] 
      then throws `std::domain_error`]]
[[Pole Error]
   [boost::math::policy::pole_error<['action]>]
      [Raised when more or more arguments would cause the function
      to be evaluated at a pole.

      Defaults to `boost::math::policy::pole_error<throw_on_error>`

      When the action is ['throw_on_error] then
      throw a `std::domain_error`]]
[[Overflow Error]
   [boost::math::policy::overflow_error<['action]>]
      [Raised when the result of the function is outside
      the representable range of the floating point type used.

      Defaults to `boost::math::policy::overflow_error<throw_on_error>`.

      When the action is ['throw_on_error] then throws a `std::overflow_error`.]]
[[Underflow Error]
   [boost::math::policy::underflow_error<['action]>]
      [Raised when the result of the function is too small
      to be represented in the floating point type used.

      Defaults to `boost::math::policy::underflow_error<ignore_error>`

      When the specified action is ['throw_on_error] then
      throws a `std::underflow_error`]]
[[Denorm Error]
   [boost::math::policy::denorm_error<['action]>]
      [Raised when the result of the function is a
      denormalised value.

      Defaults to `boost::math::policy::denorm_error<ignore_error>`

      When the action is ['throw_on_error] then throws a `std::underflow_error`]]
[[Evaluation Error]
   [boost::math::policy::evaluation_error<['action]>]
      [Raised when the result of the function is well defined and
      finite, but we were unable to compute it.  Typically
      this occurs when an iterative method fails to converge.
      Of course ideally this error should never be raised: feel free
      to report it as a bug if it is!

      Defaults to `boost::math::policy::evaluation_error<throw_on_error>`

      When the action is ['throw_on_error] then throws `boost::math::evaluation_error`]]
]

[h4 Examples]

Suppose we want a call to `tgamma` to behave in a C-compatible way and set
`errno` rather than throw an exception, we can achieve this at the call site
using:

   #include <boost/math/special_functions/gamma.hpp>
   
   using namespace boost::math::policy;
   using namespace boost::math;
   
   // Define a policy:
   typedef policy<
         domain_error<errno_on_error>, 
         pole_error<errno_on_error>,
         overflow_error<errno_on_error>,
         evaluation_error<errno_on_error> 
         > my_policy;
         
   // call the function:
   double t = tgamma(some_value, my_policy());
   
   // Alternatively we could use make_policy and define everything at the call site:
   t = tgamma(some_value, make_policy(
            domain_error<errno_on_error>(), 
            pole_error<errno_on_error>(),
            overflow_error<errno_on_error>(),
            evaluation_error<errno_on_error>() 
         ));
   
Suppose we want a statistical distribution to return infinities
rather than throw exceptions, then we can use:

   #include <boost/math/distributions/normal.hpp>
   
   using namespace boost::math::policy;
   using namespace boost::math;
   
   // Define a policy:
   typedef policy<
         overflow_error<ignore_error>
         > my_policy;
         
   // define the distribution:
   typedef normal_distribution<double, my_policy> my_norm;
   
   // get a quantile:
   double q = quantile(my_norm(), 0.05);

[endsect]

[section:internal_promotion Internal Promotion Policies]

Normally when evaluating a function at say `float` precision, maximal
accuracy is assured by conducting the calculation at `double` precision
internally, and then rounding the result.  There are two policies that
effect whether internal promotion takes place or not:

[table
[[Policy][Meaning]]
[[`boost::math::policy::promote_float<B>`]
   [Indicates whether `float` arguments should be promoted to `double`
   precision internally: defaults to `boost::math::policy::promote_float<true>`]]
[[`boost::math::policy::promote_double<B>`]
   [Indicates whether `double` arguments should be promoted to `long double`
   precision internally: defaults to `boost::math::policy::promote_double<true>`]]
]

[h4 Examples]

Suppose we want `tgamma` to be evaluated without internal promotion to
`long double`, then we could use:

   #include <boost/math/special_functions/gamma.hpp>
   
   using namespace boost::math::policy;
   using namespace boost::math;
   
   // Define a policy:
   typedef policy<
         promote_double<false> 
         > my_policy;
         
   // call the function:
   double t = tgamma(some_value, my_policy());
   
   // Alternatively we could use make_policy and define everything at the call site:
   t = tgamma(some_value, make_policy(promote_double<false>()));
   
Alternatively, suppose we want a distribution to perform calculations
without promoting `float` to `double`, then we could use:

   #include <boost/math/distributions/normal.hpp>
   
   using namespace boost::math::policy;
   using namespace boost::math;
   
   // Define a policy:
   typedef policy<
         promote_float<false>
         > my_policy;
         
   // define the distribution:
   typedef normal_distribution<float, my_policy> my_norm;
   
   // get a quantile:
   float q = quantile(my_norm(), 0.05f);
   
[endsect]

[section:assert_undefined Mathematically Undefined Function Policies]

There are some functions that are generic - which is to say they are
present for all the statistical distributions supported - but which
may be mathematically undefined for certain distributions, but not others.

For example the Cauchy distribution does not have a mean, so what should

   mean(cauchy<>());
   
return, and should such an expression even compile at all?

The default behaviour is for all such functions to not compile at all
 - in fact they will raise a 
[@http://www.boost.org/libs/static_assert/index.html static assertion]
 - but by changing the policy
we can have them return the result of a domain error instead (which may well
throw an exception). 

This behaviour is controlled by the `assert_undefined<>` policy:

   namespace boost{ namespace math{ namespace policy{

   template <bool b>
   class assert_undefined;

   }}} //namespaces

For example:

   #include <boost/math/distributions/cauchy.hpp>
   
   using namespace boost::math::policy;
   using namespace boost::math;
   
   // This will not compile, cauchy has no mean!
   double m1 = mean(cauchy()); 
   
   // This will compile, but raises a domain error!
   double m2 = mean(cauchy_distribution<double, policy<assert_undefined<false> > >());
 
[endsect]

[section:discrete_quant_ref Discrete Quantile Policies]

If a statistical distribution is ['discrete] then the random variable
can only have integer values - this leaves us with a problem when calculating
quantiles - we can either ignore the discreteness of the distribution and return
a real value, or we can round to an integer.  As it happens computing integer
values can be substantially faster than calculating a real value, so there are
definite advantages to returning an integer, but we do then need to decide
how best to round the result.  The `discrete_quantile` policy defines how
discrete quantiles work, and how integer results are rounded:

   enum discrete_quantile_policy_type
   {
      real,
      integer_outside,
      integer_inside,
      integer_below,
      integer_above,
      integer_nearest
   };
   
   template <discrete_quantile_policy_type>
   struct discrete_quantile;
   
The values that `discrete_quantile` can take have the following meanings:

[h5 real]

Ignores the discreteness of the distribution, and returns a real-valued 
result.  For example:

   #include <boost/math/distributions/negative_binomial.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policy;
   
   typedef negative_binomial_distribution<
         double, 
         policy<discrete_quantile<integer_inside> > 
      > dist_type;
      
   double x, y;
   
   // Lower quantile:
   x = quantile(dist_type(20, 0.3), 0.05);
   // Upper quantile:
   y = quantile(complement(dist_type(20, 0.3), 0.05));
   
Results in `x = 27.3898` and `y = 68.1584`.

[h5 integer_outside]

This is the default policy: an integer value is returned so that:

* Lower quantiles (where the probability is less than 0.5) are rounded
down.
* Upper quantiles (where the probability is greater than 0.5) are rounded up.

This is normally the safest rounding policy, since it ensures that both
one and two sided intervals are guaranteed to have ['at least] 
the requested coverage.  For example:

   #include <boost/math/distributions/negative_binomial.hpp>
   
   using namespace boost::math;
   
   double x, y;
   
   // Lower quantile rounded down:
   x = quantile(negative_binomial(20), 0.05);
   // Upper quantile rounded up:
   y = quantile(complement(negative_binomial(20), 0.05));
   
Results in `x = 27` (rounded down from 27.3898) and `y = 69` (rounded up from 68.1584).

The variables x and y are now defined so that:

   cdf(negative_binomial(20), x) <= 0.05
   cdf(negative_binomial(20), y) >= 0.95
   
In other words we guarantee ['at least 90% coverage in the cenrtal region overall], 
and also ['no more than 5% coverage in each tail].

[h5 integer_inside]

This is the opposite of ['integer_outside]: an integer value is returned so that:

* Lower quantiles (where the probability is less than 0.5) are rounded
['up].
* Upper quantiles (where the probability is greater than 0.5) are rounded ['down].

For example:

   #include <boost/math/distributions/negative_binomial.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policy;
   
   typedef negative_binomial_distribution<
         double, 
         policy<discrete_quantile<integer_inside> > 
      > dist_type;
      
   double x, y;
   
   // Lower quantile rounded up:
   x = quantile(dist_type(20), 0.05);
   // Upper quantile rounded down:
   y = quantile(complement(dist_type(20), 0.05));
   
Results in `x = 28` (rounded up from 27.3898) and `y = 68` (rounded down from 68.1584).

The variables x and y are now defined so that:

   cdf(negative_binomial(20), x) >= 0.05
   cdf(negative_binomial(20), y) <= 0.95
   
In other words we guarantee ['at no more than 90% coverage in the cenrtal region overall], 
and also ['at least 5% coverage in each tail].

[h5 integer_below]

Always rounds down to an integer value, no matter whether it's an upper 
or a lower quantile.

[h5 integer_above]

Always rounds up to an integer value, no matter whether it's an upper 
or a lower quantile.

[h5 integer_nearest]

Always rounds to the nearest integer value, no matter whether it's an upper 
or a lower quantile.  This will produce the requested coverage
['in the average case], but for any specific example may results in
either significantly more or less coverage than the requested amount.
For example:

For example:

   #include <boost/math/distributions/negative_binomial.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policy;
   
   typedef negative_binomial_distribution<
         double, 
         policy<discrete_quantile<integer_nearest> > 
      > dist_type;
      
   double x, y;
   
   // Lower quantile rounded up:
   x = quantile(dist_type(20), 0.05);
   // Upper quantile rounded down:
   y = quantile(complement(dist_type(20), 0.05));

Results in `x = 27` (rounded from 27.3898) and `y = 68` (rounded from 68.1584).

[endsect]

[section:precision_pol Precision Policies]

There are two equivalent policies that effect the ['working precision]
used to calculate results, these policies both default to 0 - meaning
calculate to the maximum precision available in the type being used
 - but can be set to other values to cause lower levels of precision 
to be used.

   namespace boost{ namespace math{ namespace policy{
   
   template <int N>
   digits10;
   
   template <int N>
   digits2;
   
   }}} // namespaces
   
As you would expect, ['digits10] specifies the number of decimal digits
to use, and ['digits2] the number of binary digits.  Internally, whichever
is used, the precision is always converted to ['binary digits].

These policies are specified at compile-time, because many of the special
functions use compile-time-dispatch to select which approximation to use
based on the precision requested and the numeric type being used.

For example we could calculate tgamma to approximately 5 decimal digits using:

   #include <boost/math/special_functions/gamma.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policy;
   
   typedef policy<digits10<5> > pol;
   
   double t = tgamma(12, pol());
   
Or again using ['make_policy]:

   #include <boost/math/special_functions/gamma.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policy;
   
   double t = tgamma(12, policy<digits10<5> >());

And for a quantile of a distribution to approximately 25-bit precision:

   #include <boost/math/distributions/normal.hpp>
   
   using namespace boost::math;
   using namespace boost::math::policy;
   
   double q = quantile(
         normal_distribution<double, policy<digits2<25> >(), 
         0.05);

[endsect]

[section Changing the Policy Defaults]

If you want to alter the defaults for any of 
the policies then you can do so by defining various macros in
boost/math/tools/user.hpp:

[h5 BOOST_MATH_DOMAIN_ERROR_POLICY]

Defines what happens when a domain error occurs, if not defined then
defaults to `throw_on_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_POLE_ERROR_POLICY]

Defines what happens when a pole error occurs, if not defined then
defaults to `throw_on_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_OVERFLOW_ERROR_POLICY]

Defines what happens when an overflow error occurs, if not defined then
defaults to `throw_on_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.


[h5 BOOST_MATH_EVALUATION_ERROR_POLICY]

Defines what happens when an internal evaluation error occurs, if not defined then
defaults to `throw_on_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_UNDERFLOW_ERROR_POLICY]

Defines what happens when an overflow error occurs, if not defined then
defaults to `ignore_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_DENORM_ERROR_POLICY]

Defines what happens when a denormalisation error occurs, if not defined then
defaults to `ignore_error`, but can be set to any of the enumerated
actions for error handing: `throw_on_error`, `errno_on_error`, 
`ignore_error` or `user_error`.

[h5 BOOST_MATH_DIGITS10_POLICY]

Defines how many decimal digits to use in internal computations: 
defaults to `0` - meaning use all available digits - but can be set
to some other decimal value.  Since setting this is likely to have
a substantial impact on accuracy, it's not generally recomended
that you change this from the default.

[h5 BOOST_MATH_PROMOTE_FLOAT_POLICY]

Determines whether `float` types get promoted to `double`
internally to ensure maximum precision in the result, defaults
to `true`, but can be set to `false` to turn promotion of
`float`'s off.

[h5 BOOST_MATH_PROMOTE_DOUBLE_POLICY]

Determines whether `double` types get promoted to `long double`
internally to ensure maximum precision in the result, defaults
to `true`, but can be set to `false` to turn promotion of
`double`'s off.

[h5 BOOST_MATH_DISCRETE_QUANTILE_POLICY]

Determines how disrete quantiles return their results: either
as an integer, or as a real value, can be set to one of the
enumerated values: `real`, `integer_outside`, `integer_inside`,
`integer_below`, `integer_above`, `integer_nearest`.  Defaults to
`integer_outside`.

[h5 BOOST_MATH_ASSERT_UNDEFINED_POLICY]

Determines whether functions that are mathematically undefined
for a specific distribution compile or raise a static (i.e. compile-time)
assertion.  Defaults to `true`: meaning that any mathematically
undefined function will not compile.  When set to `false` then the function
will compile but return the result of a domain error: this can be useful
for some generic code, that needs to work with all distributions and determine
at runtime whether or not a particular property is well defined.

[h5 Example]

Suppose we want overflow errors to set errno and return an infinity,
discrete quantiles to return a real-valued result (rather than round to
integer), and for mathematically undefined functions to compile, but return
a domain error. Then we could add the following to boost/math/tools/user.hpp:

   #define BOOST_MATH_OVERFLOW_ERROR_POLICY errno_on_error
   #define BOOST_MATH_DISCRETE_QUANTILE_POLICY real
   #define BOOST_MATH_ASSERT_UNDEFINED_POLICY false

[endsect]

[section:namespace_pol Setting Polices at Namespace Scope]

Sometimes what you really want to do is bring all the special functions,
or all the distributions into a specific namespace-scope, along with
a specific policy to use with them.  There are two macros defined to
assist with that:

   BOOST_MATH_DECLARE_SPECIAL_FUNCTIONS(Policy)

and:

   BOOST_MATH_DECLARE_DISTRIBUTIONS(Type, Policy)
   
You can use either of these macros after including any special function
or distribution header.  For example:

   #include <boost/math/special_functions/gamma.hpp>
   
   namespace myspace{
   
   using namespace boost::math::policy;
   
   // Define a policy that does not throw on overflow:
   typedef policy<overflow_error<errno_on_error> > my_policy;

   // Define the special functions in this scope to use the policy:   
   BOOST_MATH_DECLARE_SPECIAL_FUNCTIONS(my_policy)
   
   }
   
   //
   // Now we can use myspace::tgamma etc.
   // They will automatically use "my_policy":
   //
   double t = myspace::tgamma(30.0); // will not throw on overflow

In this example, using BOOST_MATH_DECLARE_SPECIAL_FUNCTIONS results in
a set of thin inline forwarding functions being defined:

   template <class T>
   inline T tgamma(T a){ return ::boost::math::tgamma(a, mypolicy()); }
   
   template <class T>
   inline T lgamma(T a) ( return ::boost::math::lgamma(a, mypolicy()); }
   
and so on.  Note that a forwarding function is defined for all the special
functions, however, unless you include the specific header for the special
function you use (or boost/math/special_functions.hpp), you will get 
linker errors from undefined functions.

We can do the same thing with the distributions, but this time we need to
specify the floating point type to use:

   #include <boost/math/distributions/cauchy.hpp>
   
   namespace myspace{
   
   using namespace boost::math::policy;
   
   // Define a policy to use, in this case we want all the distribution
   // accessor functions to compile, even if they are mathematically
   // undefined:
   typedef policy<assert_undefined<false> > my_policy;
   
   BOOST_MATH_DECLARE_DISTRIBUTIONS(double, my_policy)
   
   }
   
   //
   // Now we can use myspace::cauchy etc, which will use policy
   // myspace::mypolicy:
   //
   // This compiles but raises a domain error at runtime:
   //
   double d = mean(myspace::cauchy()); 
   
In this example the result of BOOST_MATH_DECLARE_DISTRIBUTIONS is to
declare a typedef for each distribution like this:

   typedef boost::math::cauchy_distribution<double, my_policy> cauchy;
   tyepdef boost::math::gamma_distribution<double, my_policy> gamma;
   
and so on.  The name given to each typedef is the name of the distribution
with the "_distribution" suffix removed.

[endsect]

[endsect]

[endsect]
