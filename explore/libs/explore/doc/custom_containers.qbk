[/
 / Copyright (c) 2008-2009 Jared McIntyre
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:custom_containers Custom Containers]

You can use explore with your custom containers, or third party containers. However, explore needs a little help in understanding these classes.

[heading Standard Container]

The following is a very simple class that contains a 1, 2, and 3 along with the begin and end functions to access the iterators for the container.

   class user_vector
   {
   public:
      user_vector()
      {
          m_vec.push_back(1);
          m_vec.push_back(2);
          m_vec.push_back(3);
      }

      std::vector<int>::iterator begin()
      {
          return m_vec.begin();
      }
      
      std::vector<int>::iterator end()
      {
          return m_vec.end();
      }
      
   private:
      std::vector<int> m_vec;
   };

To allow the user_vector to stream properly, you must create an operator<< overload that for the user_vector class that wrapps a call to the explore::stream_container helper function. The stream_container helper iterates through a range outputting the proper delimeters along with the values in the range. So, the operator<< passes into stream_container the result of the begin and end functions, and allows stream_container to process the contents for it.

   template<typename Elem, typename Tr>
   std::basic_ostream<Elem, Tr>& operator<<(std::basic_ostream<Elem, Tr>& ostr, const user_vector& u)
   {
      return explore::stream_container(ostr, u.begin(), u.end());
   }

With our new overloaded operator<<, the following code

   user_vector v;
   std::cout << v;

prints

   [1, 2, 3]
   
[heading Associative Container]
   
If the container had been an associative container of pairs, then the operator<< code would have looked like this:

   template<typename Elem, typename Tr>
   std::basic_ostream<Elem, Tr>& operator<<(std::basic_ostream<Elem, Tr>& ostr, const user_vector& u)
   {
      return explore::stream_container(ostr, u.begin(), u.end(), explore::stream_associative_value());
   }
   
The critical difference is the addition of the third parameter `explore::stream_associative_value()`.
[endsect]
