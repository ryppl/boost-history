[/
 / Copyright (c) 2008 Howard Hinnant
 / Copyright (c) 2006, 2008 Beman Dawes
 / Copyright (c) 2009-20010 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[article Boost.TypeTraits.Ext
    [quickbook 1.5]
    [authors [Hinnant, Howard]]
    [authors [Dawes, Beman]]
    [authors [Botet Escriba, Vicente J.]]
    [copyright 2008 Howard Hinnant]
    [copyright 2006, 2008 Beman Dawes]
    [copyright 2009-2010 Vicente J. Botet Escriba]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/==================]
[def __Boost_Chrono__ [*Boost.Chrono]]
[def __Boost_TypeTraitsExt__ [*Boost.TypeTraits.Ext]]

[/===============================================]

[template common_type_link[link_text] [link boost_typetraits_ext.reference.common_type_hpp.common_type [link_text]]]
[def __common_type__ [common_type_link `common_type`]]

[template common_type_macros[link_text] [link boost_typetraits_ext.reference.common_type_hpp.conf [link_text]]]

[template common_type_pp[link_text] [link boost_typetraits_ext.reference.common_type_hpp.pp [link_text]]]

[def __common_type__BOOST_COMMON_TYPE_USES_STATIC_ASSERT [common_type_macros `BOOST_COMMON_TYPE_USES_STATIC_ASSERT`]]
[def __common_type__BOOST_COMMON_TYPE_USES_MPL_ASSERT [common_type_macros `BOOST_COMMON_TYPE_USES_MPL_ASSERT`]]
[def __common_type__BOOST_COMMON_TYPE_USES_ARRAY_ASSERT [common_type_macros `BOOST_COMMON_TYPE_USES_ARRAY_ASSERT`]]
[def __common_type__BOOST_COMMON_TYPE_ARITY [common_type_pp `BOOST_COMMON_TYPE_ARITY`]]
[def __common_type__BOOST_COMMON_TYPE_DONT_USE_TYPEOF [common_type_pp `BOOST_COMMON_TYPE_DONT_USE_TYPEOF`]]

[template add_rvalue_reference_link[link_text] [link boost_typetraits_ext.reference.add_rvalue_reference_hpp.add_rvalue_reference [link_text]]]
[def __add_rvalue_reference__ [add_rvalue_reference_link `add_rvalue_reference`]]

[template declval_link[link_text] [link boost_typetraits_ext.reference.declval_hpp.declval [link_text]]]
[def __declval__ [declval_link `declval`]]

[warning TypeTraits.Ext is not part of the Boost libraries.]

[/===============]
[section Overview]
[/===============]


[/====================================]
[heading How to Use This Documentation]
[/====================================]

This documentation makes use of the following naming and formatting conventions.

* Code is in `fixed width font` and is syntax-highlighted.
* Replaceable text that you will need to supply is in [~italics].
* Free functions are rendered in the code font followed by (), as in free_function().
* If a name refers to a class template, it is specified like this:   `class_template<>`; that is, it is in code font and its name is followed by `<>`   to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in code font and its name is followed by `()` to   indicate that it is a function-like macro. Object-like macros appear without the   trailing `()`.
* Names that refer to /concepts/ in the generic programming sense are  specified in CamelCase.

[note In addition, notes such as this one specify non-essential information that provides additional background or rationale.]

Finally, you can mentally add the following to any code fragments in this document:

    // Include all of TypeTraits.Ext files
    #include <boost/type_traits.hpp>
    using namespace boost;

[/=================]
[section Motivation]
[/=================]

[heading Time]


See [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] which is very informative and provides motivation for key design decisions for __common_type__.

[endsect]

[/==================]
[section Description]
[/==================]

The __Boost_TypeTraitsExt__ library provides:

* __common_type__ is a traits class used to deduce a type common to a several types, useful as the return type of functions operating on multiple input types such as in mixed-mode arithmetic.
* __add_rvalue_reference__ add a rvalue reference when appropiated.
* __declval__ utility to simplify the definition of expressions which occur as unevaluated operands.


[endsect]
[endsect]


[/==============================]
[section:users_guide Users'Guide]
[/==============================]

[/======================================]
[section:getting_started Getting Started]
[/======================================]

[/======================================]
[section:install Installing Boost.TypeTraits.Ext]
[/======================================]

[/=================================]
[heading Getting Boost.TypeTraits.Ext ]
[/=================================]

You can get the last stable release of __Boost_TypeTraitsExt__ by downloading [^chrono.zip] from the
[@http://www.boost-consulting.com/vault/index.php?directory=System Boost Vault]

You can also access the latest (unstable?) state from the [@https://svn.boost.org/svn/boost/sandbox/chrono Boost Sandbox]. Just go to [@http://svn.boost.org/trac/boost/wiki/BoostSubversion here] and follow the instructions there for anonymous SVN access.

[/==========================================]
[heading Where to install Boost.TypeTraits.Ext? ]
[/==========================================]

The simple way is to decompress (or checkout from SVN) the file in your BOOST_ROOT directory.

Othesewise, if you decompress in a different directory, you will need to comment some lines, and uncomment and change others in the build/Jamfile and test/Jamfile. Sorry for this, but I have not reached yet to write a Jamfile that is able to work in both environements and use the BOOST_ROOT variable. Any help is welcome.

[/=================================]
[heading Building Boost.TypeTraits.Ext ]
[/=================================]

__Boost_TypeTraitsExt__ is a header only library. You don't need to compile it before use.

[/===================]
[heading Requirements]
[/===================]

__Boost_TypeTraitsExt__ depends on some Boost libraries. For these specific parts you must use either Boost version 1.39.0 or the version in SVN trunk (even if older versions should works also).

In particular, __Boost_TypeTraitsExt__ depends on:

[variablelist
[
    [[@http://www.boost.org/libs/config [*Boost.Config]]] [for configuration purposes, ...]
]
[
    [[@http://www.boost.org/libs/integer [*Boost.Integer]]] [for cstdint conformance, ...]
]
[
    [[@http://www.boost.org/libs/mpl [*Boost.MPL]]] [for MPL Assert and bool, logical ...]
]
[
    [[@http://www.boost.org/libs/type_traits [*Boost.TypeTraits]]] [for is_base, is_convertible ...]
]
[
    [[@http://www.boost.org/libs/utility [*Boost.Utility/EnableIf]]] [for enable_if, ...]
]
]


[/=========================================================]
[heading Building an executable that uses Boost.TypeTraits.Ext ]
[/=========================================================]

You don't need to link with any library.

[/=========================]
[heading Exceptions safety ]
[/=========================]

All functions in the library are exception-neutral and provide strong guarantee of exception safety as long as the underlying parameters provide it.

[/=====================]
[heading Thread safety ]
[/=====================]

All functions in the library are thread-unsafe except when noted explicitly.

[/========================]
[heading Tested compilers ]
[/========================]

The implementation will eventually work with most C++03 conforming compilers.
Current version has been tested on:

Windows with

* MSVC 10.0
* MSVC 9.0 Express
* MSVC 8.0

[/* Intel 11.0]

Scientific Linux with

* GCC 4.1.2

Cygwin with

* GCC 3.4.4
* GCC 4.3.2

MinGW with

* GCC 4.4.0

Initial version was tested on:

MacOS with GCC 4.2.4

Ubuntu Linux with GCC 4.2.4

[note Please let us know how this works on other platforms/compilers.]

[note Please send any questions, comments and bug reports to boost <at> lists <dot> boost <dot> org.]

[endsect]
[/
[/====================]
[section Hello World! ]
[/====================]


    #include <boost/common_type.hpp>

[endsect]
]
[endsect]


[section Tutorial]

[section Common Type]

__common_type__ has been a recurring theme in many places for many years. We've previously known it as promote and examples of it are spread throughout boost. It has been reinvented independently several times, because it is so useful.

Andrei Alexandrescu recently pointed us at a D library: std.traits - D Programming Language - Digital Mars, which became the motivation for this particular name, and the variadic nature of [@http://www.digitalmars.com/d/2.0/phobos/std_traits.html#CommonType this trait].

[section So What is `common_type` and How can I use it?]

In a nutshell, __common_type__ is a trait that takes 1 or more types, and returns a type which all of the types will convert to. The default definition demands this conversion be implicit. However the trait can be specialized for user-defined types which want to limit their inter-type conversions to explicit, and yet still want to interoperate with the __common_type__ facility.

[*Example:]

    template <class T, class U>
    typename __common_type__<complex<T>, complex<U> >::type
    operator+(complex<T>, complex<U>);

In the above example, "mixed-mode" complex arithmetic is allowed. The return type is described by __common_type__. For example the resulting type of adding a `complex<int>` and `complex<double>` might be a `complex<double>`. Another choice for the author might be:

    template <class T, class U>
    complex<typename __common_type__<T, U>::type>
    operator+(complex<T>, complex<U>);

Here is how someone might produce a variadic comparison function:

    template <class ...T>
    typename __common_type__<T...>::type
    min(T... t);

This is a very useful and broadly applicable utility. The duration<> and time_point<> facilities use it to make multi-precision arithmetic seamless and exact.

[endsect]

[section How to get the common type of inter-type with explicit conversions?]

The default definition of __common_type__ demands the conversion be implicit. However the trait can be specialized for user-defined types which want to limit their inter-type conversions to explicit, and yet still want to interoperate with the __common_type__ facility.


[endsect]

[endsect]




[endsect]

[endsect]
[/===============]
[section Examples]
[/===============]

[section Common type]

[/==================]
[section min utility]

Returns the earliest time_point.

    template <class Clock, class Duration1, class Duration2>
    typename boost::__common_type__<__time_point__<Clock, Duration1>,
                         time_point<Clock, Duration2> >::type
    min(time_point<Clock, Duration1> t1, __time_point__<Clock, Duration2> t2)
    {
        return t2 < t1 ? t2 : t1;
    }

Being able to *easily* write this function is a major feature!

    BOOST_AUTO(t1, system_clock::now() + seconds(3));
    BOOST_AUTO(t2, system_clock::now() + nanoseconds(3));
    BOOST_AUTO(t3, (min)(t1, t2));

['See the source file [@../../example/min_time_point.cpp example/min_time_point.cpp]]


[endsect]

[endsect]


[endsect]

[/=================]
[section:reference Reference ]
[/=================]

[/===================================================================]
[section:add_rvalue_reference_hpp Header `<boost/type_traits/add_rvalue_reference.hpp>`]
[/===================================================================]

    namespace boost {
        template <typename T>
        struct add_rvalue_reference;
    }

[section:add_rvalue_reference Class Template `add_rvalue_reference<>`]

The following template transform one type to another, based upon a well-defined rule, see below. The class has a single member called type  that is the result of applying the transformation to the template argument T. 

        template <typename T>
        struct add_rvalue_reference {
            typedef <see below> type;
        }

*type:* If T names an object or function type then the member typedef type shall name T&&; otherwise, type shall name T. 

*Note:* This rule reflects the semantics of reference collapsing. For example, when a type T names a type T1&, the type add_rvalue_reference<T>::type is not an rvalue
 reference. 

*C++ Standard Reference:* 20.7.6.2

[endsect]
[endsect]

[/===================================================================]
[section:common_type_hpp Header `<boost/type_traits/common_type.hpp>`]
[/===================================================================]

    // configuration macros
    #define __common_type__BOOST_COMMON_TYPE_USES_STATIC_ASSERT
    #define __common_type__BOOST_COMMON_TYPE_USES_MPL_ASSERT
    #define __common_type__BOOST_COMMON_TYPE_USES_ARRAY_ASSERT
    #define __common_type__BOOST_COMMON_TYPE_DONT_USE_TYPEOF

    // preprocessor info
    #define __common_type__BOOST_COMMON_TYPE_ARITY

    namespace boost {
      template <class ...T>  struct __common_type__;
    }

[section:conf Configuration macros]

When BOOST_NO_STATIC_ASSERT is defined, the user can select the way static assertions are reported. Define

* BOOST_COMMON_TYPE_USES_STATIC_ASSERT: define it if you want to use Boost.StaticAssert
* BOOST_COMMON_TYPE_USES_MPL_ASSERT: define it if you want to use Boost.MPL static asertions
* BOOST_COMMON_TYPE_USES_ARRAY_ASSERT: define it if you want to use internal static asertions
* nothing if you don't want static asertions

When BOOST_COMMON_TYPE_USES_MPL_ASSERT is not defined the following symbols are defined as

    #define BOOST_COMMON_TYPE_MUST_BE_A_COMPLETE_TYPE \
        "must be complete type"

Depending on the static assertion used system you will have an hint of the failing assertion either through the symbol or through the texte.

When BOOST_NO_DECLTYPE is not defined common_type is implemented using decltype. Otherwise when BOOST_COMMON_TYPE_DONT_USE_TYPEOF is not defined it uses Boost.TypeOf.


[endsect]

[section:pp Preprocessor info]

When BOOST_NO_VARIADIC_TEMPLATES is defined BOOST_COMMON_TYPE_ARITY gives the maximum number of template parameters for __common_type__.

[endsect]

[section:common_type Class Template `common_type<>`]

__common_type__ is a traits class used to deduce a type common to a several types, useful as the return type of functions operating on multiple input types such as in mixed-mode arithmetic..

The nested typedef __common_type__::type` could be defined as follows:

    template <class ...T>
    struct common_type;
    
    template <class T, class U, class ...V>
    struct common_type<T,U,...V> {
        typedef typename __common_type__<typename __common_type__<T, U>::type, V...>::type type;
    };

    template <class T>
    struct common_type<T> {
        typedef T type;
    };

    template <class T, class U>
    struct common_type<T, U> {
        typedef decltype(__declval__<bool>() ? __declval__<T>() : __declval__<U>()) type;
    };

All parameter types must be complete. This trait is permitted to be specialized by a user if at least one template parameter is a user-defined type. [*Note:] Such specializations are required when only explicit conversions are desired among the __common_type__ arguments.


[endsect]

[endsect]


[/===================================================================]
[section:declval_hpp Header `<boost/type_traits/declval.hpp>`]
[/===================================================================]

    namespace boost {

        template <typename T>
        typename add_rvalue_reference<T>::type declval(); //noexcept; // as unevaluated operand

    }  // namespace boost


[section:declval Function Template `declval<>`]

The library provides the function template declval to simplify the definition of expressions which occur as unevaluated operands.

        template <typename T>
        typename add_rvalue_reference<T>::type declval();

*Remarks:* If this function is used, the program is ill-formed.
*Remarks:* The template parameter T of declval may be an incomplete type.

*Example:*

    template <class To, class From>
    decltype(static_cast<To>(declval<From>())) convert(From&&);

Declares a function template convert which only participats in overloading if the type From can be explicitly converted to type To. For another example see class template __common_type__.


[endsect]
[endsect]

[endsect]



[/=================]
[section Appendices]
[/=================]
[/==================================]
[section:history Appendix A: History]
[/==================================]

[section [*Version 0.1, September 10, 2010] ]

[*Features:]

* Extraction of __common_type__ from Boost.Chrono.

[endsect]

[endsect]

[/======================================]
[section:rationale Appendix B: Rationale]

See [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] which is very informative and provides motivation for key design decisions. 

[endsect]

[/======================================================]
[section:implementation Appendix C: Implementation Notes]


[endsect]

[/======================================================]
[section:faq Appendix D: FAQ]

[heading How important is the order of the __common_type__<> template arguments?]

The order of the template parameters is important. First __common_type__<> is not able to find out common type if it is not present and second
__common_type__<A,B,C>::type is equivalent to __common_type__<__common_type__<A,B>::type, C>::type.


    struct A {};
    struct B {};
    struct C {
        C() {}
        C(A const&) {}
        C(B const&) {}
        C& operator=(C const&) {
            return *this;
        }
    };

    #if 0
    typedef boost::__common_type__<A, B, C>::type ABC; // DO not compile
    #else
    typedef boost::__common_type__<C, B, A>::type ABC;
    #endif


Thus, as __common_type__<A,B>::type is undefined,  __common_type__<A,B,C>::type is also undefined.

[heading Can you explain the pros/cons of __common_type__ against Boost.Typeof?]

Even if in a first look they sound to be close, __common_type__ and typeof have
different purposes. You use typeof to get the type of an expression, while
you use __common_type__ to set explicitly the type returned of a template
function. Both are complementary. For example with the preceding declaration
and the needed Typeof registrations, you can do


Suppose I have a mixed type vector2 class with a magnitude_squared function defined as:

template <typename X, typename Y>
BOOST_TYPEOF_TPL(X() * X() + Y() * Y()) magnitude_squared(const
vector2<X, Y> &v) {
   return v.x * v.x + v.y * v.y;
}


__common_type__ is closer in nature to promote_args<class ...T> in boost/math/tools/promotion.hpp than it is to Boost.Typeof, though it is not exactly the same as promote_args either.  __common_type__<T1, T2>::type simply represents the result of some operation on T1 and T2, and defaults to the type obtained by putting T1 and T2 into a conditional statement.

It is meant to be customizable (via specialization) if this default is not appropriate.


[endsect]

[/====================================================]
[section:acknowledgements Appendix E: Acknowledgements]

The library's code was derived from Howard Hinnant's time2_demo prototype. Many thanks to Howard for making his code available under the Boost license. The original code was modified by Beman Dawes to conform to Boost conventions.

time2_demo contained this comment:

Much thanks to Andrei Alexandrescu, Walter Brown, Peter Dimov, Jeff Garland, Terry Golubiewski, Daniel Krugler, Anthony Williams.

Thansk to Jeffrey Lee Hellrung, Jr. for sharing his implementation of __common_type__ without using Boost.TypeOf.

[endsect]

[/====================================================]
[section:tests  Appendix F: Tests]

In order to test you need to do.

    bjam libs/type_traits_ext/test

You can also run a specific suite of test by doing

    cd libs/type_traits_ext/test
    bjam common_type


[section `common_type`]
[table
    [[Name]             [kind]          [Description]          [Result] [Ticket]]
    [[common_type_test]    [run] [...]                  [Pass]   [#]]
]
[endsect]

[endsect]
[/=====================================]
[section:tickets  Appendix G: Tickets]

[table
    [[Ticket]             [Description]          [Resolution] [State]]
    [/[#]    [XXXX] [XXXX]                  [Closed]]
]

[endsect]


[/=====================================]
[section:todo  Appendix H: Future plans]
[/=====================================]

[heading For later releases]

* Define a C++98 variadic template emmulation of __common_type__

[endsect]
[endsect]
