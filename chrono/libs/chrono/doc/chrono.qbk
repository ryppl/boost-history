[/
 / Copyright (c) 2008 Howard Hinnant
 / Copyright (c) 2006, 2008 Beman Dawes
 / Copyright (c) 2009-20010 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[article Boost.Chrono
    [quickbook 1.5]
    [authors [Hinnant, Howard]]
    [authors [Dawes, Beman]]
    [authors [Botet Escriba, Vicente J.]]
    [copyright 2008 Howard Hinnant]
    [copyright 2006, 2008 Beman Dawes]
    [copyright 2009-2010 Vicente J. Botet Escriba]
    [purpose Time utilities]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/==================]
[def __Boost_Chrono__ [*Boost.Chrono]]

[/===============================================]

[template common_type_link[link_text] [link boost_chrono.reference.cpp0x.common_type_hpp.common_type [link_text]]]
[def __common_type__ [common_type_link `common_type`]]

[template common_type_macros[link_text] [link boost_chrono.reference.cpp0x.common_type_hpp.conf [link_text]]]

[template common_type_pp[link_text] [link boost_chrono.reference.cpp0x.common_type_hpp.pp [link_text]]]

[def __common_type__BOOST_COMMON_TYPE_USES_STATIC_ASSERT [common_type_macros `BOOST_COMMON_TYPE_USES_STATIC_ASSERT`]]
[def __common_type__BOOST_COMMON_TYPE_USES_MPL_ASSERT [common_type_macros `BOOST_COMMON_TYPE_USES_MPL_ASSERT`]]
[def __common_type__BOOST_COMMON_TYPE_USES_ARRAY_ASSERT [common_type_macros `BOOST_COMMON_TYPE_USES_ARRAY_ASSERT`]]
[def __common_type__BOOST_COMMON_TYPE_ARITY [common_type_pp `BOOST_COMMON_TYPE_ARITY`]]
[def __common_type__BOOST_COMMON_TYPE_DONT_USE_TYPEOF [common_type_pp `BOOST_COMMON_TYPE_DONT_USE_TYPEOF`]]


[/===============================================]
[def __ratio__ [link boost_chrono.reference.cpp0x.ratio_hpp.ratio `ratio`]]


[template ratio_conf[link_text] [link boost_chrono.reference.cpp0x.ratio_hpp.conf [link_text]]]

[template ratio_pp[link_text] [link boost_chrono.reference.cpp0x.ratio_hpp.pp [link_text]]]

[def __BOOST_RATIO_USES_STATIC_ASSERT [ratio_conf `BOOST_RATIO_USES_STATIC_ASSERT`]]
[def __BOOST_RATIO_USES_MPL_ASSERT [ratio_conf `BOOST_RATIO_USES_MPL_ASSERT`]]
[def __BOOST_RATIO_USES_ARRAY_ASSERT [ratio_conf `BOOST_RATIO_USES_ARRAY_ASSERT`]]

[template ratio_arithmetic[link_text] [link boost_chrono.reference.cpp0x.ratio_hpp.ratio_arithmetic [link_text]]]
[def __ratio_add [ratio_arithmetic `ratio_add`]]
[def __ratio_subtract [ratio_arithmetic `ratio_subtract`]]
[def __ratio_multiply [ratio_arithmetic `ratio_multiply`]]
[def __ratio_divide [ratio_arithmetic `ratio_divide`]]


[template ratio_comparison[link_text] [link boost_chrono.reference.cpp0x.ratio_hpp.ratio_comparison [link_text]]]
[def __ratio_equal [ratio_comparison `ratio_equal`]]
[def __ratio_not_equal [ratio_comparison `ratio_not_equal`]]
[def __ratio_less [ratio_comparison `ratio_less`]]
[def __ratio_less_equal [ratio_comparison `ratio_less_equal`]]
[def __ratio_greater [ratio_comparison `ratio_greater`]]
[def __ratio_greater_equal [ratio_comparison `ratio_greater_equal`]]


[template ratio_si_typedefs[link_text] [link boost_chrono.reference.cpp0x.ratio_hpp.ratio_si_typedefs [link_text]]]
[def __atto [ratio_si_typedefs `atto`]]
[def __femto [ratio_si_typedefs `femto`]]
[def __pico [ratio_si_typedefs `pico`]]
[def __nano [ratio_si_typedefs `nano`]]
[def __micro [ratio_si_typedefs `micro`]]
[def __milli [ratio_si_typedefs `milli`]]
[def __centi [ratio_si_typedefs `centi`]]
[def __deci [ratio_si_typedefs `deci`]]
[def __deca [ratio_si_typedefs `deca`]]
[def __hecto [ratio_si_typedefs `hecto`]]
[def __kilo [ratio_si_typedefs `kilo`]]
[def __mega [ratio_si_typedefs `mega`]]
[def __giga [ratio_si_typedefs `giga`]]
[def __tera [ratio_si_typedefs `tera`]]
[def __peta [ratio_si_typedefs `peta`]]
[def __exa [ratio_si_typedefs `exa`]]


[/==================]


[template chrono_conf[link_text] [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.conf [link_text]]]


[def __BOOST_CHRONO_USES_STATIC_ASSERT [chrono_conf `BOOST_CHRONO_USES_STATIC_ASSERT`]]
[def __BOOST_CHRONO_USES_MPL_ASSERT [chrono_conf `BOOST_CHRONO_USES_MPL_ASSERT`]]
[def __BOOST_CHRONO_USES_ARRAY_ASSERT [chrono_conf `BOOST_CHRONO_USES_ARRAY_ASSERT`]]

[def __BOOST_CHRONO_HAS_CLOCK_MONOTONIC [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.BOOST_CHRONO_HAS_CLOCK_MONOTONIC `BOOST_CHRONO_HAS_CLOCK_MONOTONIC`]]



[template clock_concept_link[link_text] [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.clock [link_text]]]
[def __clock_concept__ [clock_concept_link `Clock` concept]]
[def __clock_concept_type__ [clock_concept_link `Clock`]]
[def __clock_req__ [clock_concept_link `Clock` requirements]]
[def __Clock__ [clock_concept_link `Clock`]]
[def __Clock_s__ [clock_concept_link `Clock`'s]]


[template duration_link[link_text] [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.duration [link_text]]]
[def __duration__ [duration_link `duration`]]
[def __duration_s__ [duration_link `duration`'s]]

[/==================]
[template time_point_link[link_text] [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.time_point [link_text]]]
[def __time_point__ [time_point_link `time_point`]]
[def __time_point_s__ [time_point_link `time_point`'s]]

[/==================]
[template system_clock_link[link_text] [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.system_clock [link_text]]]
[def __system_clock__ [system_clock_link `system_clock`]]

[/==================]
[template monotonic_clock_link[link_text] [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.monotonic_clock [link_text]]]
[def __monotonic_clock__ [monotonic_clock_link `monotonic_clock`]]

[/==================]
[template high_resolution_clock_link[link_text] [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.high_resolution_clock [link_text]]]
[def __high_resolution_clock__ [high_resolution_clock_link `high_resolution_clock`]]

[def __duration_cast__ [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.duration_cast `duration_cast`]]

[def __time_point_cast__ [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.time_point_cast `time_point_cast`]]


[template duration_typedefs[link_text] [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.duration_typedefs [link_text]]]
[def __nanoseconds__ [duration_typedefs `nanoseconds`]]
[def __microseconds__ [duration_typedefs `microseconds`]]
[def __milliseconds__ [duration_typedefs `milliseconds`]]
[def __seconds__ [duration_typedefs `seconds`]]
[def __minutes__ [duration_typedefs `minutes`]]
[def __hours__ [duration_typedefs `hours`]]
[def __days__ [duration_typedefs `days`]]

[def __common_type_spe__ [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.common_type_spe `common_type`]]

[/==================]
[def __treat_as_floating_point__ [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.traits.treat_as_floating_point `treat_as_floating_point`]]
[def __duration_values__ [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.traits.duration_values `duration_values`]]
[def __zero__ [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.traits.duration_values.zero `zero`]]
[def __max__ [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.traits.duration_values.max `max`]]
[def __min__ [link boost_chrono.reference.cpp0x.chrono_chrono_hpp.traits.duration_values.min `min`]]


[/==================]
[template SuspendibleClock_concept_link[link_text] [link boost_chrono.reference.other_clocks.suspendible_clock_req [link_text]]]
[def __SuspendibleClock_concept__ [SuspendibleClock_concept_link `SuspendibleClock` concept]]
[def __SuspendibleClock_concept_type__ [SuspendibleClock_concept_link `SuspendibleClock`]]
[def __SuspendibleClock_req__ [SuspendibleClock_concept_link `SuspendibleClock` requirements]]
[def __SuspendibleClock__ [SuspendibleClock_concept_link `SuspendibleClock`]]

[/==================]
[template stopwatch_concept_link[link_text] [link boost_chrono.reference.stopwatches.stopwatch_req [link_text]]]
[def __stopwatch_concept__ [stopwatch_concept_link `Stopwatch` concept]]
[def __stopwatch_concept_type__ [stopwatch_concept_link `Stopwatch`]]
[def __stopwatch_req__ [stopwatch_concept_link `Stopwatch` requirements]]
[def __Stopwatch__ [stopwatch_concept_link `Stopwatch`]]


[def __stopwatch__ [link boost_chrono.reference.stopwatches.stopwatch_hpp.stopwatch `stopwatch`]]

[def __stopwatch_accumulator__ [link boost_chrono.reference.stopwatches.stopwatch_accumulator_hpp.stopwatch_accumulator `stopwatch_accumulator`]]


[def __stopwatch_reporter__ [link boost_chrono.reference.reporters.stopwatch_reporter_hpp.stopwatch_reporter `stopwatch_reporter`]]

[def __stopclock_accumulator__ [link boost_chrono.reference.reporters.stopclock_accumulator_hpp.stopclock_accumulator `stopclock_accumulator`]]

[/==================]
[template formatter_concept_link[link_text] [link boost_chrono.reference.reporters.formatter_req [link_text]]]
[def __formatter_concept__ [formatter_concept_link `Formatter` concept]]
[def __formatter_concept_type__ [formatter_concept_link `Formatter`]]
[def __formatter_req__ [formatter_concept_link `Formatter` requirements]]
[def __Formatter__ [formatter_concept_link `Formatter`]]

[def __stopclock__ [link boost_chrono.reference.reporters.stopclock_hpp.stopclock `stopclock`]]
[def __stopclock_clock__ [link boost_chrono.reference.reporters.stopclock_hpp.stopclock `stopclock<Clock>`]]

[def __scoped_stopclock__ [link boost_chrono.reference.reporters.scoped_stopclock_hpp.scoped_stopclock `scoped_stopclock`]]

[def __process_real_cpu_clock__ [link boost_chrono.reference.other_clocks.process_cpu_clocks_hpp.process_real_cpu_clock `process_real_cpu_clock`]]

[def __process_system_cpu_clock__ [link boost_chrono.reference.other_clocks.process_cpu_clocks_hpp.process_system_cpu_clock `process_system_cpu_clock`]]

[def __process_user_cpu_clock__ [link boost_chrono.reference.other_clocks.process_cpu_clocks_hpp.process_user_cpu_clock `process_user_cpu_clock`]]

[def __thread_clock__ [link boost_chrono.reference.other_clocks.thread_clock_hpp.thread_clock `thread_clock`]]
[def __suspendible_clock__ [link boost_chrono.reference.other_clocks.suspendible_clock_hpp.suspendible_clock `suspendible_clock`]]

[def __stopwatch_accumulator_formatter__ [link boost_chrono.reference.formatters.stopwatch_accumulator_formatter_hpp.basic_stopwatch_accumulator_formatter `stopwatch_accumulator_formatter`]]

[def __stopwatch_accumulator_time_formatter__ [link boost_chrono.reference.formatters.stopwatch_accumulator_time_formatter_hpp.basic_stopwatch_accumulator_time_formatter `stopwatch_accumulator_time_formatter`]]

[def __basic_stopwatch_formatter__ [link boost_chrono.reference.formatters.stopwatch_formatter_hpp.basic_stopwatch_formatter `stopwatch_accumulator_formatter`]]

[def __basic_stopwatch_accumulator_formatter__ [link boost_chrono.reference.formatters.stopwatch_accumulator_formatter_hpp.basic_stopwatch_accumulator_formatter `stopwatch_accumulator_formatter`]]

[def __basic_24_hours_formatter__ [link boost_chrono.reference.formatters.t24_hours_formatter_hpp.basic_24_hours_formatter `basic_24_hours_formatter`]]



[warning Chrono is not part of the Boost libraries.]

[/===============]
[section Overview]
[/===============]

[:["What is time, then? If nobody asks me, I know; if I have to explain it to someone who has asked me, I do not know.]]
[:[*['-- Augustine ]]]


[/====================================]
[heading How to Use This Documentation]
[/====================================]

This documentation makes use of the following naming and formatting conventions.

* Code is in `fixed width font` and is syntax-highlighted.
* Replaceable text that you will need to supply is in [~italics].
* Free functions are rendered in the code font followed by (), as in free_function().
* If a name refers to a class template, it is specified like this:   `class_template<>`; that is, it is in code font and its name is followed by `<>`   to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in code font and its name is followed by `()` to   indicate that it is a function-like macro. Object-like macros appear without the   trailing `()`.
* Names that refer to /concepts/ in the generic programming sense are  specified in CamelCase.

[note In addition, notes such as this one specify non-essential information that provides additional background or rationale.]

Finally, you can mentally add the following to any code fragments in this document:

    // Include all of Chrono files
    #include <boost/stopwatches.hpp>

[/
    #include <boost/type_traits/common_type.hpp>
    #include <boost/ratio.hpp>
    #include <boost/chrono.hpp>
]

[/=================]
[section Motivation]
[/=================]

[heading Time]

We all deal with time every day of our lives. We've intuitively known it since birth. Thus we are all very familiar with it and believe it to be a simple matter. The modeling of time in computer programs should be similarly simple. The unfortunate truth is that this perceived simplicity is only skin deep. Fortunately however, we do not need a terribly complicated solution to meet the bulk of our needs. However, overly simplistic solutions can be dangerous and inefficient, and won't adapt as the computer industry evolves.

__Boost_Chrono__ aims to implement the new time facilities in C++0x, as proposed in [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]].  That document provides background and motivation for key design decisions and is the source of a good deal of information in this documentation.

[/
__Boost_Chrono__ proposes a solution that is precision neutral, with a very simple end user interface which supports multiple clocks, multiple precisions (both coarser and finer than we will ever need), separate types for points in time and time durations, efficiency, and compile time enforced safety.
]

[/
In addition to the clocks provided by the standard proposal, __Boost_Chrono__ provides specific process clocks and a thread clock.
]

[/
See [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] which is very informative and provides motivation for key design decisions for __common_type__, __ratio__ and `chrono`. This documentation contains a lot of extracts from this document.
]

[heading Wall clock versus system and user time]

To make the timing facilities of Boost.Chrono more generally useful, the library provides a number of clocks that are thin wrappers around the operating system's process time API, thereby allowing the extraction of read (wall clock) time, user CPU time, and system CPU time.  (On POSIX-like systems, this relies on times().  On Windows, it relies on GetProcessTimes().)

[/
It is also helpful if such timing information is broken down into real (wall clock) time, CPU time spent by the user, and CPU time spent by the operating system servicing user requests.
]

[/
3 concrete process clocks:

# __process_real_CPU_clock__,
# __process_user_CPU_clock__,
# __process_system_CPU_clock__

providing a 
]

[/__Boost_Chrono__ provides 
thin wrappers around the operating system's process timer API. For POSIX-like systems, that's the times() function, while for Windows, it's the GetProcessTimes() function.
]

[/These clocks capture the specific time unitarily. __Boost_Chrono__ provides also a clock __process_cpu_clock__ that captures the three times at once.
]

[/
    using namespace boost::chrono;
    int main()
    {
        stopwatch_reporter<stopwatch<process_cpu_clock> > _;
      // ...
    }

Will produce the following output

    real 0.034s, cpu 0.031s (93.0%), user 0.031s, system 0.000s

As this is one of the expression more commonly use, the library provides a stopclock shortcut so the preceding can be writen as

    using namespace boost::chrono;
    int main()
    {
        __stopclock__<> _;
      // ...
    }
]

[heading Reporting elapsed time]

Knowing how long a program, a function or a specific code block takes to execute is useful in both test and production environments.
__Boost_Chrono__ introduces the __Stopwatch__ concept which is a mechanism to measure the elapsed time.
A Stopwatch allows to start, stop, suspend and resume measuring the elapsed time.
__stopwatch__`<>` is the basic model of __Stopwatch__.

It is often necessary to report elapsed time on a user display or in a log file.  __stopwatch_reporter__<> provides a runtime reporting mechanism for this purpose which can be invoked in just one line of code.

[heading How reliable are these measures?]

There are a number of things that can lead to unreliable measurement (see [link boost_chrono.appendices.rationale here] for more details), but they mostly amount to reporting overhead.  Boost.Chrono provides two ways to improve reliability of time measurements.  A __stopwatch_accumulator__ only reports statistics once all measurements have been acquired, which removes reporting overhead from the measurements.  The other approach is to use a __SuspendibleClock__ such that the reporting overhead can be ignored by suspending elapsed time tracking during reporting operations

[endsect]

[/==================]
[section Description]
[/==================]

The __Boost_Chrono__ library provides:

* A means to represent time durations: managed by the generic __duration__ class . Examples of time durations include __days__, __minutes__, __seconds__  and __nanoseconds__, which can be represented with a fixed number of clock ticks per unit. All of these units of time duration are united with a generic interface by the __duration__ facility.
* A type for representing points in time: __time_point__. A __time_point__ represents an epoch plus or minus a __duration__. The library leaves epochs unspecified. A __time_point__ is associated with a /clock/.
* Several clocks, some of which may not be available on a particular platform: __system_clock__, __monotonic_clock__ and __high_resolution_clock__. A clock is a pairing of a __time_point__ and __duration__, and a function which returns a __time_point__ representing ['now].

Additionally, a minimal amount of general purpose infrastructure is provided which will support both the interface and implementation of the /clocks/, __time_point_s__ and __duration_s__ proposed herein. It is expected that these general purpose facilities will also find utility in far ranging user applications as well.

* __common_type__ is a traits class used to deduce a type common to a several types, useful as the return type of functions operating on multiple input types such as in mixed-mode arithmetic.
[/* __ratio__ is a facility which is useful in specifying compile time rational constants. Compile time rational arithmetic is supported with protection against overflow and divide by zero. Such a facility is very handy when needing to efficiently represent 1/3 of a nanosecond, or specifying an inch in terms of meters (for example 254/10000 meters - which __ratio__ will reduce to 127/5000 meters).
]
* A class template, __ratio__, for specifying compile time rational constants such as 1/3 of a nanosecond or the number of inches per meter.  __ratio__ represents a compile time ratio of compile time constants with support for compile time arithmetic with overflow and division by zero protection

Knowing how long a program takes to execute is useful in both test and production environments. On top of the standard facilities __Boost_Chrono__ includes:

* Stopwatches: A facility to measure elapsed time with the ability to start, stop, suspend, or resume measurement.
    * __Stopwatch__ concept
    * Scoped helper classes allowing to pairwise start/stop operations, suspend/resume and resume/suspend a __Stopwatch__.
    * __stopwatch__, model of __Stopwatch__ capturing elapsed __Clock__ times.
    * __stopwatch_accumulator__, model of __Stopwatch__ capturing cummulated elapsed Clock times.

* a Stopclocks higher layer: provide a complete stopclock reporting package that can be invoked in a single line of code.
    * __stopwatch_reporter__, convenient reporting to an output stream (including wide char streams) of the elapsed time of models of __Stopwatch__ results.
    * __stopclock_clock__ shortcut of `__stopwatch_reporter__<__stopwatch__<Clock>>`

To make the timing facilities more generally useful, __Boost_Chrono__ provides a number of clocks that are thin wrappers around the operating system's time APIs, thereby allowing the extraction of read (wall clock) time, user CPU time, system CPU time,

* __process_real_cpu_clock__, captures real (wall clock) CPU times.
* __process_user_cpu_clock__, captures user-CPU times.
* __process_system_cpu_clock__, captures system-CPU times.
* A tuple-like class `process_cpu_clock`, that captures real, user-CPU, and system-CPU times together.
* Thread clocks, when supported by a platform.


[/It is also helpful if such timing information is broken down into real (wall clock) time, CPU time spent by the user, and CPU time spent by the operating system servicing user requests. process clocks provide a thin wrapper around the operating system's process timer API. For POSIX-like systems, that's the times() function, while for Windows, it's the GetProcessTimes() function.
]


[/

* Suspendible clock
    * __SuspendibleClock__ concept
    * scope_suspend which do suspend/resume if the __Clock__ is a model of __SuspendibleClock__ concept, and nothing otherwise.
    * template class __suspendible_clock__
]

Lastly, __Boost_Chrono__ includes [@http://www.boost.org/libs/typeof typeof] registration for __duration__ and __time_point__ to permit using emulated auto with C++03 compilers.


[heading Caveat emptor]

The underlying clocks provided by operating systems are subject to many seemingly arbitrary policies and implementation irregularities. That's a polite way of saying they tend to be flakey, and each operating system or even each clock has its own cruel and unusual forms of flakiness. Don't bet the farm on their accuracy, unless you have become deeply familiar with exactly what the specific operating system is guaranteeing, which is often very little.

[endsect]

[endsect]


[/==============================]
[section:users_guide Users'Guide]
[/==============================]

[/======================================]
[section:getting_started Getting Started]
[/======================================]

[/======================================]
[section:install Installing Chrono]
[/======================================]

[/=================================]
[heading Getting __Boost_Chrono__ ]
[/=================================]

You can get the last stable release of __Boost_Chrono__ by downloading [^chrono.zip] from the
[@http://www.boost-consulting.com/vault/index.php?directory=System Boost Vault]

You can also access the latest (unstable?) state from the [@https://svn.boost.org/svn/boost/sandbox/chrono Boost Sandbox]. Just go to [@http://svn.boost.org/trac/boost/wiki/BoostSubversion here] and follow the instructions there for anonymous SVN access.

[/==========================================]
[heading Where to install __Boost_Chrono__? ]
[/==========================================]

The simple way is to decompress (or checkout from SVN) the file in your BOOST_ROOT directory.

Othesewise, if you decompress in a different directory, you will need to comment some lines, and uncomment and change others in the build/Jamfile and test/Jamfile. Sorry for this, but I have not reached yet to write a Jamfile that is able to work in both environements and use the BOOST_ROOT variable. Any help is welcome.

[/=================================]
[heading Building __Boost_Chrono__ ]
[/=================================]

__Boost_Chrono__ is not a header only library. You need to compile it before use.

    bjam libs/chrono/build

[/===================]
[heading Requirements]
[/===================]

[*Boost.Chrono] depends on some Boost libraries. For these specific parts you must use either Boost version 1.39.0 or the version in SVN trunk (even if older versions should works also).

In particular, __Boost_Chrono__ depends on:

[variablelist
[
    [[@http://www.boost.org/libs/config [*Boost.Config]]] [for configuration purposes, ...]
]
[
    [[@http://www.boost.org/libs/exception [*Boost.Exception]]] [for throw_exception, ...]
]
[
    [[@http://www.boost.org/libs/integer [*Boost.Integer]]] [for cstdint conformance, ...]
]
[
    [[@http://www.boost.org/libs/system [*Boost.System]]] [for error_code, ...]
]
[
    [[@http://www.boost.org/libs/type_traits [*Boost.TypeTraits]]] [for is_base, ...]
]
[
    [[@http://www.boost.org/libs/utility [*Boost.UtiliTy/EnableIf]]] [for enable_if, ...]
]
]

__Boost_Chrono__ depends optionaly on:

[variablelist
[
    [[@http://www.boost.org/libs/accumulator [*Boost.Accumulator]]] [for accumulator_set, and statistics features when stopwatch_accumulator.hpp is included]
]
[
    [[@http://www.boost.org/libs/thread [*Boost.Thread]]] [for thread_specific_ptr when suspendible_clock.hpp is included]
]
[
    [[@http://www.boost.org/libs/typeof [*Boost.Typeof]]] [for duration and time_point registration when typeof/boost/chrono/chrono.hpp is include or when BOOST_COMMON_TYPE_DONT_USE_TYPEOF is not defined]
]
]


[/=========================================================]
[heading Building an executable that uses __Boost_Chrono__ ]
[/=========================================================]

In addition to link with the Boost Chrono library you need also to link with the Boost System library.

[/=========================]
[heading Exceptions safety ]
[/=========================]

All functions in the library are exception-neutral and provide strong guarantee of exception safety as long as the underlying parameters provide it.

[/=====================]
[heading Thread safety ]
[/=====================]

All functions in the library are thread-unsafe except when noted explicitly.

[/========================]
[heading Tested compilers ]
[/========================]

The implementation will eventually work with most C++03 conforming compilers.
Current version has been tested on:

Windows with

* MSVC 10.0
* MSVC 9.0 Express
* MSVC 8.0

[/* Intel 11.0]

Scientific Linux with

* GCC 4.1.2

Cygwin with

* GCC 3.4.4
* GCC 4.3.2

MinGW with

* GCC 4.4.0

Initial version was tested on:

MacOS with GCC 4.2.4

Ubuntu Linux with GCC 4.2.4

[note Please let us know how this works on other platforms/compilers.]

[note Please send any questions, comments and bug reports to boost <at> lists <dot> boost <dot> org.]

[endsect]
[/====================]
[section Hello World! ]
[/====================]

If all you want to do is to time a program's execution:

    #include <boost/chrono/stopclock.hpp>

    ...

    // add this in the scope you want to time,
    // at the point you want the timer to start.
    boost::chrono::__stopclock__<> rt;

Here is a complete program (stopclock_example.cpp):

    #include <boost/chrono/stopclock.hpp>
    #include <cmath>

    int main()
    {
      boost::chrono::__stopclock__<> t;

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L ); // burn some time

      return 0;
    }

Debug build output was:

    real 0.832s, cpu 0.813s (97.7%), user 0.813s, system 0.000s

In other words, the program took 0.832 real-time (i.e. wall clock) seconds to execute, while the operating system (Windows in this case) charged 0.813 seconds of CPU time to the user and 0 seconds to the system. The total CPU time reported was 0.813 seconds, and that represented utilization of 97.7% of the real-time seconds.

[endsect]

[endsect]


[section Tutorial]

[/note If you have not read yet the [@boost_chrono/overview/motivation.html motivation section], please read it now.]

[section Common Type]

__common_type__ has been a recurring theme in many places for many years. We've previously known it as promote and examples of it are spread throughout boost. It has been reinvented independently several times, because it is so useful.

Andrei Alexandrescu recently pointed us at a D library: std.traits - D Programming Language - Digital Mars, which became the motivation for this particular name, and the variadic nature of [@http://www.digitalmars.com/d/2.0/phobos/std_traits.html#CommonType this trait].

[section So What is `common_type` and How can I use it?]

In a nutshell, __common_type__ is a trait that takes 1 or more types, and returns a type which all of the types will convert to. The default definition demands this conversion be implicit. However the trait can be specialized for user-defined types which want to limit their inter-type conversions to explicit, and yet still want to interoperate with the __common_type__ facility.

[*Example:]

    template <class T, class U>
    typename __common_type__<complex<T>, complex<U> >::type
    operator+(complex<T>, complex<U>);

In the above example, "mixed-mode" complex arithmetic is allowed. The return type is described by __common_type__. For example the resulting type of adding a `complex<int>` and `complex<double>` might be a `complex<double>`. Another choice for the author might be:

    template <class T, class U>
    complex<typename __common_type__<T, U>::type>
    operator+(complex<T>, complex<U>);

Here is how someone might produce a variadic comparison function:

    template <class ...T>
    typename __common_type__<T...>::type
    min(T... t);

This is a very useful and broadly applicable utility. The __duration__ and __time_point__ facilities use it to make multi-precision arithmetic seamless and exact.

[endsect]

[section How to get the common type of inter-type with explicit conversions?]

The default definition of __common_type__ demands the conversion be implicit. However the trait can be specialized for user-defined types which want to limit their inter-type conversions to explicit, and yet still want to interoperate with the __common_type__ facility.


[endsect]

[endsect]


[section Ratio]

__ratio__ is a general purpose utility inspired by Walter Brown allowing one to easily and safely compute rational values at compile time. The __ratio__ class catches all errors (such as divide by zero and overflow) at compile time. It is used in the __duration__ and __time_point__ classes to efficiently create units of time. It can also be used in other "quantity" libraries (both std-defined and user-defined), or anywhere there is a rational constant which is known at compile time. The use of this utility can greatly reduce the chances of run time overflow because the __ratio__ (and any ratios resulting from __ratio__ arithmetic) are always reduced to lowest terms.

__ratio__ is a template taking two intmax_ts, with the second defaulted to 1. In addition to copy constructors and assignement, it only has two public members, both of which are static const intmax_t. One is the numerator of the __ratio__ and the other is the denominator. The __ratio__ is always normalized such that it is expressed in lowest terms, and the denominator is always positive. When the numerator is 0, the denominator is always 1.

[*Example:]

    typedef __ratio__<5, 3>   five_thirds;       
    // five_thirds::num == 5, five_thirds::den == 3
    
    typedef __ratio__<25, 15> also_five_thirds;  
    // also_five_thirds::num == 5, also_five_thirds::den == 3
    
    typedef ratio_divide<five_thirds, also_five_thirds>::type one;  
    // one::num == 1, one::den == 1

This facility also includes convenience typedefs for the SI prefixes __atto through __exa corresponding to their internationally recognized definitions (in terms of __ratio__). This is a tremendous syntactic convenience. It will prevent errors in specifying constants as one no longer has to double count the number of zeros when trying to write million or billion.

[*Example:]

    typedef ratio_multiply<__ratio__<5>, giga>::type _5giga;  
    // _5giga::num == 5000000000, _5giga::den == 1
    
    typedef ratio_multiply<__ratio__<5>, nano>::type _5nano;  
    // _5nano::num == 1, _5nano::den == 200000000

[endsect]

[section Duration]

The __duration__ is the heart of this library. The interface that the user will see in everyday use is nearly identical to that of Boost.DateTime time __duration_s__ authored by Jeff Garland, both in syntax and in behavior. This has been a very popular boost library for 7 years. There is an enormous positive history with this interface.

The library consists of six units of time __duration__:

* __hours__
* __minutes__
* __seconds__
* __milliseconds__
* __microseconds__
* __nanoseconds__

These units were chosen as a subset of the boost library because they are the most common units used when sleeping, waiting on a condition variable, or waiting to obtain the lock on a mutex. Each of these units is nothing but a thin wrapper around a signed integral count. That is, when you construct __minutes__`(3)`, all that happens is a `3` is stored inside of minutes. When you construct __microseconds__`(3)`, all that happens is a `3` is stored inside of __microseconds__.

The only context in which these different types differ is when being converted to one another. At this time, unit-specific compile-time conversion constants are used to convert the source unit to the target unit. Only conversions from coarser units to finer units are allowed (in boost). This restriction ensures that all conversions are always exact. That is, __microseconds__ can always represent any value __minutes__ has.

In Boost.DateTime, these units are united via inheritance. __Boost_Chrono__ instead unites these units through the class template __duration__. That is, in __Boost_Chrono__ all six of the above units are nothing but typedefs to different instantiations of __duration__. This change from Boost.DateTime has a far reaching positive impact, while not changing the syntax of the everyday use at all.

The most immediate positive impact is that the library can immediately generate any unit, any precision it needs. This is sometimes necessary when doing comparisons or arithmetic between __duration_s__ of differing precision, assuming one wants the comparison and arithmetic to be exactly correct.

A secondary benefit is that by publishing the class template __duration__ interface, user code can very easily create __duration_s__ with any precision they desire. The __ratio__ utility is used to specify the precision, so as long as the precision can be expressed by a rational constant with respect to seconds, this framework can exactly represent it (one third of a second is no problem, and neither is one third of a __femto second). All of this utility and flexibility comes at no cost just by making use of the no-run-time-overhead __ratio__ facility.

In Boost.DateTime, __hours does not have the same representation as __nanoseconds__. The former is usually represented with a `long` whereas a `long long` is required for the latter. The reason for this is simply range. You don't need many hours to cover an extremely large range of time. But this isn't true of nanoseconds. Being able to reduce the sizeof overhead for some units when possible, can be a significant performance advantage.

__Boost_Chrono__ continues, and generalizes that philosophy. Not only can one specify the precision of a __duration__, one can also specify its representation. This can be any integral type, or even a floating point type. Or it can be a user-defined type which emulates an arithmetic type. The six predefined units all use signed integral types as their representation. And they all have a minimum range of +/- 292 years. __nanoseconds__ needs 64 bits to cover that range. __hours needs only 23 bits to cover that range.


[section  So What Exactly is a `duration` and How Do I Use One?]

A __duration__ has a representation and a tick period (precision).

    template <class Rep, class Period = __ratio__<1> > class duration;

The representation is simply any arithmetic type, or an emulation of such a type. The representation stores a count of ticks. This count is the only data member stored in a __duration__. If the representation is floating point, it can store fractions of a tick to the precision of the representation. The tick period is represented by a __ratio__ and is encoded into the __duration__'s type, instead of stored. The tick period only has an impact on the behavior of the __duration__ when a conversion between different __duration__'s is attempted. The tick period is completely ignored when simply doing arithmetic among like __duration_s__.

[*Example:]

    typedef __duration__<long, __ratio__<60> > minutes;
    minutes m1(3);                 // m1 stores 3
    minutes m2(2);                 // m2 stores 2
    minutes m3 = m1 + m2;          // m3 stores 5

    typedef __duration__<long long, micro> microseconds;
    microseconds us1(3);           // us1 stores 3
    microseconds us2(2);           // us2 stores 2
    microseconds us3 = us1 + us2;  // us3 stores 5

    microseconds us4 = m3 + us3;   // us4 stores 300000005

In the final line of code above, there is an implicit conversion from minutes to microseconds, resulting in a relatively large number of microseconds.

If you need to access the tick count within a __duration__, there is a member `count()` which simply returns the stored tick count.

    long long tc = us4.count();    // tc is 300000005

These __duration_s__ have very simple, very predictable, and very observable behavior. After all, this is really nothing but the time tested interface of Jeff's boost time __duration__ library (unified with templates instead of inheritance).

[endsect]

[section What happens if I assign `m3 + us3` to `minutes` instead of `microseconds`?]

    minutes m4 = m3 + us3;

It won't compile. The rationale is that implicit truncation error should not be allowed to happen. If this were to compile, then `m4` would hold `5`, the same value as `m3`. The value associated with `us3` has been effectively ignored. This is similar to the problem of assigning a double to an `int`: the fractional part gets silently discarded.

[heading But what if the truncation behavior is what I want to do?]

There is a __duration_cast__ facility to explicitly ask for this behavior:

    minutes m4 = __duration_cast__<minutes>(m3 + us3);  // m4.count() == 5

In general, one can perform __duration__ arithmetic at will. If __duration_cast__ isn't used, and it compiles, the arithmetic is exact. Any place one wants to override this exact arithmetic behavior, __duration_cast__ can be used to explicitly specify that desire. The __duration_cast__ has the same efficiency as the implicit conversion, and will even be exact as often as it can.

[endsect]

[section  I'm trafficking in floating point `duration`s. I don't want to deal with writing `duration_cast` all over the place. I'm content with the precision of my floating point representation]

Not a problem. When the destination of a conversion has floating point representation, all conversions are allowed to happen implicitly.

    typedef __duration__<double, __ratio__<60> > dminutes;
    dminutes dm4 = m3 + us3;  // dm4.count() == 5.000000083333333

[endsect]

[section How expensive is all of this?]

If you were writing these conversions by hand, you could not make it more efficient. The use of __ratio__ ensures that all conversion constants are simplified as much as possible at compile time. This usually results in the numerator or denominator of the conversion factor simplifying to `1`, and being subsequently ignored in converting the run time values of the tick counts.

[endsect]

[section  How complicated is it to build a function taking a `duration` parameter?]

There are several options open to the user:

* If the author of the function wants to accept any __duration__, and is willing to work in floating point __duration_s__, he can simply use any floating point __duration__ as the parameter:

          void f(duration<double> d)  // accept floating point seconds
          {
              // d.count() == 3.e-6 when passed microseconds(3)
          }

          f(microseconds(3));

* If the author of the function wants to traffic only in integral __duration_s__, and is content with handling nothing finer than say nanoseconds (just as an example), he can simply specify nanoseconds as the parameter:

          void f(nanoseconds d)
          {
              // d.count() == 3000 when passed microseconds(3)
          }

          f(microseconds(3));

In this design, if the client wants to pass in a floating point __duration__, or a __duration__ of finer precision than nanoseconds, then the client is responsible for choosing his own rounding mode in the conversion to nanoseconds.

          __duration__<double> s(1./3);  // 1/3 of a second
          f(duration_cast<nanoseconds>(s));  // round towards zero in conversion to nanoseconds

In the example above, the client of f has chosen "round towards zero" as the desired rounding mode to nanoseconds. If the client has a __duration__ that won't exactly convert to nanoseconds, and fails to choose how the conversion will take place, the compiler will refuse the call:

          f(s);  // does not compile

* If the author of the function wants to accept any __duration__, but wants to work with integral representations and wants to control the rounding mode internally, then he can template the function:

          template <class Rep, class Period>
          void f(__duration__<Rep, Period> d)
          {
              // convert d to nanoseconds, rounding up if it is not an exact conversion
              nanoseconds ns = duration_cast<nanoseconds>(d);
              if (ns < d)
                  ++ns;
              // ns.count() == 333333334 when passed 1/3 of a floating point second
          }

          f(__duration__<double>(1./3));

*  If the author in the example does not want to accept floating point based __duration_s__, he can enforce that behavior like so:

          template <class Period>
          void f(__duration__<long long, Period> d)
          {
              // convert d to nanoseconds, rounding up if it is not an exact conversion
              nanoseconds ns = duration_cast<nanoseconds>(d);
              if (ns < d)
                  ++ns;
              // ns.count() == 333333334 when passed 333333333333 picoseconds
          }

          f(__duration__<long long, pico>(333333333333));  // About 1/3 of a second worth of picoseconds

Clients with floating point __duration_s__ who want to use f will now have to convert to an integral __duration__ themselves before passing the result to f.

In summary, the author of f has quite a bit of flexibility and control in the interface he wants to provide his clients with, and easy options for manipulating that __duration__ internal to his function.

[endsect]
[endsect]

[section Clocks]

While __duration_s__ only have precision and representation to concern themselves, clocks and __time_point_s__ are intimately related and refer to one another. Because clocks are simpler to explain, we will do so first without fully explaining __time_point_s__. Once clocks are introduced, it will be easier to then fill in what a __time_point__ is.

A clock is a concept which bundles 3 things:

# A concrete __duration__ type.
# A concrete __time_point__ type.
# A function called now() which returns the concrete __time_point__.

__Boost_Chrono__ provides the standard concrete clocks:

# system_clock
# monotonic_clock
# high_precision_clock

A given platform may not be able to supply all three of these clocks. The user is also able to easily create more clocks.

Given a clock named Clock, it will have:

    class Clock {
    public:
        typedef an arithmetic-like type            rep;
        typedef an instantiation of ratio          period;
        typedef boost::chrono::__duration__<rep, period> __duration__;
        typedef boost::chrono::__time_point__<Clock>     time_point;
        static const bool is_monotonic =           true or false;

        static time_point now();
    };

One can get the current time from Clock with:

    Clock::time_point t1 = Clock::now();

And one can get the time __duration__ between two __time_point_s__ associated with Clock with:

    Clock::duration d = t1 - Clock::now();

And one can specify a past or future __time_point__ with:

    Clock::time_point t2 = Clock::now() + d;

Note how even if a particular clock becomes obsolete, the next clock in line will have the same API. There is no new learning curve to come up. The only source code changes will be simply changing the type of the clock. The same __duration__ and __time_point__ framework continues to work as new clocks are introduced. And multiple clocks are safely and easily handled within the same program.

[endsect]


[section Time Point]

A __time_point__ represents a point in time, as opposed to a __duration__ of time. Another way of saying the same thing, is that a __time_point__ represents an epoch plus or minus a __duration__. Examples of __time_point_s__ include:

* 3 minutes after the computer booted.
* 03:14:07 UTC on Tuesday, January 19, 2038
* 20 milliseconds after I started that timer.

In each of the examples above, a different epoch is implied. Sometimes an epoch has meaning for several millennia. Other times the meaning of an epoch is lost after a while (such as the start of a timer, or when the computer booted). However, if two __time_point_s__ are known to share the same epoch, they can be subtracted, yielding a valid __duration__, even if the definition of the epoch no longer has meaning.

In __Boost_Chrono__, an epoch is a purely abstract and unspecified concept. There is no type representing an epoch. It is simply an idea that relates (or doesn't) __time_point_s__ to a clock, and in the case that they share a clock, __time_point_s__ to one another. __time_point_s__ associated with different clocks are generally not interoperable unless the relationship between the epochs associated with each clock is known.

[section  So What Exactly is a `time_point` and How Do I Use One?]

A __time_point__ has a clock and a __duration__.

    template <class Clock, class Duration = typename Clock::duration> class time_point;

The __time_point__'s clock is not stored. It is simply embedded into the __time_point__'s type and serves two purposes:

# Because __time_point_s__ originating from different clocks have different types, the compiler can be instructed to fail if incompatible __time_point_s__ are used in inappropriate ways.
# Given a __time_point__, one often needs to compare that __time_point__ to "now". This is very simple as long as the __time_point__ knows what clock it is defined with respect to.

A __time_point__'s __duration__ is stored as the only data member of the __time_point__. Thus __time_point_s__ and their corresponding __duration__ have exactly the same layout. But they have very different meanings. For example, it is one thing to say I want to sleep for 3 minutes. It is a completely different thing to say I want to sleep until 3 minutes past the time I started that timer (unless you just happened to start that timer now). Both meanings (and options for sleeping) have great practical value in common use cases for sleeping, waiting on a condition variable, and waiting for a mutex's lock. These same concepts and tools are found (for example) in Ada.

A timer example:

    void f()
    {
        monotonic_clock::time_point start = monotonic_clock::now();
        g();
        h();
        __duration__<double> sec = monotonic_clock::now() - start;
        cout << "f() took " << sec.count() << " seconds\n";
    }

Note that if one is using the __duration__ between two clock __time_point_s__ in a way where the precision of the __duration__ matters, it is good practice to convert the clock's native __duration__ to a known __duration__. This insulates the code from future changes which may be made to the clock's native precision in the future. For example monotonic_clock could easily be based on the clock speed of the cpu. When you upgrade to a faster machine, you do not want your code that assumed a certain tick period of this clock to start experiencing run time failures because your timing code has silently changed meaning.

A delay loop example:

    // delay for at least 500 nanoseconds:
    auto go = monotonic_clock::now() + nanoseconds(500);
    while (monotonic_clock::now() < go)
        ;

The above code will delay as close as possible to half a microsecond, no matter what the precision of monotonic_clock is. The more precise __monotonic_clock__ becomes, the more accurate will be the delay to 500 nanoseconds.


[endsect]

[section  How to get the actual CPU milliseconds (or other units?) used by the current thread between end and start?]

You can use __duration_cast__`<>` to convert the __thread_clock__`::duration` into whatever units you desire.  This facility will round down (truncate) if an exact conversion is not possible.  Ex:

    typedef boost::chrono::__milliseconds__ ms;
    ms d = boost::chrono::__duration_cast__<ms>(end - start);

    // d now holds the number of milliseconds from start to end.

    std::cout << ms.count() << "ms\n";

As `boost::chrono::__thread_clock__::duration` is __nanoseconds__, we can convert to __nanoseconds__, or some integral-based duration which __nanoseconds__ will always exactly convert to, then __duration_cast__`<>` is unnecessary:

    typedef boost::chrono::__nanoseconds__ ns;
    ns d = end - start;
    std::cout << ns.count() << "ns\n";

If you need seconds with a floating point representation you can also eliminate the __duration_cast_`<>`:

    typedef boost::chrono::__duration__<double> sec;  // seconds, stored with a double
    sec d = end - start;
    std::cout << sec.count() << "s\n";

If you're not sure if you need __duration_cast__`<>` or not, feel free to try it without.  If the conversion is exact, or if the destination has a floating point representation, it will compile.  Else it will not compile.

If you would like to programmatically inspect `__thread_clock__::duration`, you can get the representation type with `__thread_clock__::rep`, and the tick period with `__thread_clock__::period` (which should be a type __ratio__ which has nested values `__ratio__::num` and `__ratio__::den`).  The tick period of __thread_clock__ is `__thread_clock__::period::num / __thread_clock__::period::den` seconds: 1/1000000000 in this case (`1` billionth of a second), stored in a `long long`.

If you need to use __duration_cast__`<>`, but want to round up, instead of down when the conversion is inexact, here is a handy little helper function to do so.  Writing it is actually a good starter project for understanding chrono:

    template <class ToDuration, Rep, Period>
    ToDuration
    round_up(boost::chrono::__duration__<Rep, Period> d)
    {
        // first round down
        ToDuration result = boost::chrono::__duration_cast__<ToDuration>(d);
        if (result < d)  // comparisons are *always* exact
           ++result;     // increment by one tick period
        return result;
    }

    typedef boost::chrono::__milliseconds__ ms;
    ms d = round_up<ms>(end - start);
    // d now holds the number of milliseconds from start to end, rounded up.
    std::cout << ms.count() << "ms\n";

[endsect]

[/
[section How to define a thread clock]

On posix systems for which the macro _POSIX_THREAD_CPUTIME is defined we can get the time associated to a specific thread.

    class thread_clock {
    public:
        typedef nanoseconds                          duration;
        typedef duration::rep                        rep;
        typedef duration::period                     period;
        typedef chrono::__time_point__<thread_clock>    time_point;
        static const bool is_monotonic =             BOOST_CHRONO_THREAD_CLOCK_IS_MONOTONIC;

        static time_point now( ) {
            // get the current thread
            pthread_t pth=pthread_self(void);
            // get the clock_id associated to the current thread
            clockid_t clock_id;
            pthread_getcpuclockid(pth, clock_id);
            // get the timespec associated to the thread clock
            struct timespec ts;
            if ( ::clock_gettime( clock_id, &ts ) )
            {
                boost::throw_exception(
                system::system_error( errno, system::system_category, "chrono::thread_clock" ));
            }

            // transform to nanoseconds
            return time_point(duration(
                static_cast<thread_clock::rep>( ts.tv_sec ) * 1000000000 + ts.tv_nsec));

        }
        static time_point now( system::error_code & ec ) {
            // get the current thread
            pthread_t pth=pthread_self(void);
            // get the clock_id associated to the current thread
            clockid_t clock_id;
            pthread_getcpuclockid(pth, clock_id);
            // get the timespec associated to the thread clock
            struct timespec ts;
            if ( ::clock_gettime( clock_id, &ts ) )
            {
              ec.assign( errno, system::system_category );
              return time_point();
            }
            ec.clear();
            // transform to nanoseconds
            return time_point(duration(
                static_cast<thread_clock::rep>( ts.tv_sec ) * 1000000000 + ts.tv_nsec));
        }
    };

[endsect]
]


[endsect]


[section Stopwatches and Stopclocks]

Knowing how long a program, a function or a specific block takes to execute is useful in both test and production environments.
__Boost_Chrono__ introduces the __Stopwatch__ concept which captures the mechanism to measure the elapsed time.
A __Stopwatch__ allows to `start`, `stop`, `suspend` and `resume` measuring the elapsed time.
__stopwatch__`<>` is the basic model of __Stopwatch__ allowing to make a single measure.

At the user level, the main use case of measuring the elapsed time is to report these measures on the display.
__stopwatch_reporter__`<>` provides a run time reporting package that can be invoked in a single line of code to report the usage of a __Clock__.
For example

    using namespace boost::chrono;
    int f1(long j) {
        __stopwatch_reporter__<__stopwatch__<> > _;

        for ( long i = 0; i < j; ++i )
            std::sqrt( 123.456L );  // burn some time

        return 0;
    }
    int main()  {
        f1(100000);
        f1(200000);
        f1(300000);
        return 0;
    }

Will produce the following output

    0.006s
    0.011s
    0.017s


[section  Stopwatches accumulation and statistics]

The preceding stopwatch manage only with a measure. It is also interesting to have an statisitical view of these times, for example the sum, min, max and mean. __stopwatch_accumulator__`<>` associates an accumulator with a __stopwatch__, so we are able to retrieve any statistical feature Boost.Accumulator provides.

For example

    using namespace boost::chrono;
    int f1(long j) {
        static __stopwatch_reporter__<__stopwatch_accumulator__<> > sw;
        __stopwatch_reporter__<__stopwatch_accumulator__<> >::scoped_run _(sw);

        for ( long i = 0; i < j; ++i )
            std::sqrt( 123.456L );  // burn some time

        return 0;
    }
    int main()  {
        f1(100000);
        f1(200000);
        f1(300000);
        return 0;
    }

Will produce the following output

    3 times, sum=0.034s, min=0.006s, max=0.017s, mean=0.011s


[endsect]

[/
[section How reliable are these measures?]

[note this section need to be reworked, the ideas are there, but ...]

There are three context on which you can get unreliable measures:

* precision of your clock. If the precision of your clock is 10ms you can not be able to measure the time spent by blocks of code that takes the same order of magnitude. The library provides a hig_resolution_clock that gives you the higher resolution available on your platform. Respect to the precision, nothing to do except to take the clock with the highest resolution and measures blocks of code that will spent time having more than one order of magnitude the precision of the clock.

``
#include <boost/chrono/chrono.hpp>
    ...
    __stopclock__<__high_resolution_clock__> _;
``

* When your application is multithreaded, and you use a process clock, the time you get is the delay during which your block has been executed, in concurrency with the other threads of execution. If what you want is the time spent by this specific thread another clock is needed. The library provide a __thread_clock__ that returns the time spent by the thread on platforms providing this kind of data. It can be used as follows

``
#include <boost/chrono/thread_clock.hpp>
...
#if defined(__BOOST_CHRONO_HAS_THREAD_CLOCK)
    __stopclock__<__thread_clock__> _;
#else
    __stopclock__<__process_real_cpu_clock__> _;
#endif
``

* Nested stopclocks (usually nested function calls where each function contains a __stopclock__). When the nesting is deep enough, the cumulative overhead of all the stopclock functionality make the data unreliable except for the inner-most trace points. The question is, how much time is related to the application code we want to measure and how much to the fact we are meassuring and logging in inner blocks?

Some measures let us think that most of the time spent by the __stopclock__ mechanism is associated to the logging part. There are two things we can do to make the difference :

* Avoid expensive operations as logging while doing the measures. Note that reporting in itself is not too expensive as far as we don't need to flush the buffer. This can be achieved either using a __stopclock_accumulator__, 'i.e. don't report until all the measures have been compiled and then report some statistics or using an asynchronous stream.

* Introduce some cheap mechanism that allows us to make the difference between the application time and the intrinsic __stopclock__ time. When the precision of the clock is enough, we can suspend the counting of the Clock while we are spending time reporting the measures, and resume it once the work is done. The library provide a Clock wrapper __suspendible_clock__ that make the resulting clock suspendible. The __stopwatch_reporter__ is able to detect if the __Clock__ is Suspendible and then `suspend`/`resume` the __Clock__ while doing the report.

    __stopclock__<__suspendible_clock__<Clock> > _;


See the performances section for more deep details.

[endsect]
]

[section How can I prefix each report with `BOOST_CURRENT_FUNCTION` function signature?]

You will need to give a specific format to your __stopclock__. You just need to concatenate your specific pattern to the default_format of the formatter.

For example, for a __stopclock_accumulator__ the default formatter is __stopwatch_accumulator_formatter__, you will need to do something like:

    static __stopclock_accumulator__<> acc(
        std::string(BOOST_CURRENT_FUNCTION) + ":  "
            + __stopwatch_accumulator_formatter__::default_format()
    );
    __stopclock_accumulator__<>::scoped_run _(acc);


Some of you will say that this is too long to type just to get the a report. You can of course define your own macro as

    #define REPORT_FUNCTION_ACCUMULATED_LIFETIME\
        static boost::chrono::__stopclock_accumulator__<> \
                BOOST_JOIN(_accumulator_, __LINE__)_
            ( std::string(BOOST_CURRENT_FUNCTION) + ":  " + \
                boost::chrono::__stopwatch_accumulator_formatter__::default_format() \
        ); \
        boost::chrono::__stopclock_accumulator__<>::scoped_run \
                BOOST_JOIN(_accumulator_run_, __LINE__) \
            (BOOST_JOIN(_accumulator_, __LINE__))


With this macro you will just have to write

    void foo()
    {
        REPORT_FUNCTION_ACCUMULATED_LIFETIME() ;
        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
        // ...
    }

[endsect]

[section How can I prefix each report with `__FILE__[__LINE__]` pattern?]

When you want to prefix with the `__FILE__[__LINE__]` pattern you can follow the same technique as described below:

    #define REPORT_LINE_ACCUMULATED_LIFETIME \
        static __stopclock_accumulator__<>
                BOOST_JOIN(_accumulator_, __LINE__) \
                ( std::string(__FILE__) + "[" + BOOST_STRINGIZE(__LINE__) + "] "
                    + __stopwatch_accumulator_formatter__::default_format() \
        ); \
        __stopclock_accumulator__<>::scoped_run \
                BOOST_JOIN(_accumulator_run_, __LINE__)
                (BOOST_JOIN(_accumulator_, __LINE__))

Now you can mix fcntion and line reports as follows

    void foo()
    {
        REPORT_FUNCTION_ACCUMULATED_LIFETIME;
        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
        {
            REPORT_LINE_ACCUMULATED_LIFETIME;
            boost::this_thread::sleep(boost::posix_time::milliseconds(200));
        }

    }

[endsect]

[section Can I use an stopclock accumulator which is not static?]

The typical example of stopclock_accumulator is to get statistical measures of the time a function takes for each one of its calls. You can also use __stopclock_accumulator__ to get statistical measures of the time a given loop takes for each one of its laps.

        __stopclock_accumulator__<> acc(
            std::string(__FILE__) + "[" + BOOST_STRINGIZE(__LINE__) + "] "
                + __stopwatch_accumulator_formatter__::default_format()
        );
        for (int i=0; i<N; i++) {
            __stopclock_accumulator__<>::scoped_run _(acc);
            // ...
        }


[endsect]

[section How can I suspend a stopwatch?]

    #include <boost/chrono/stopwatch.hpp>
    #include <cmath>
    #include <boost/thread.hpp>


    using namespace boost::chrono;
    double res;
    void f1(long j)
    {
        __stopwatch_reporter__<__stopwatch__<> >:: _(BOOST_CHRONO_STOPWATCH_FUNCTION_FORMAT);
        for (long i =0; i< j; i+=1)
            res+=std::sqrt( res+123.456L+i );  // burn some time
        __stopwatch_reporter__<__stopwatch__<> >::scoped_suspend s(_);
        boost::this_thread::sleep(boost::posix_time::milliseconds(200));
    }

[endsect]

[section How to get specific statistics from stopwatches accumulator?]

There are two use cases that coul need to change the statistics associated to a stopwatches accumulator:

# We want to reduce the default reporting and we preffer to adapt the statistics to the reporting
# We want to report other statistics of the samples

For the first case we just need to change the accumulator_set and the format we want to get. Imagin we want to get only the count, sam and mean statistics, no need to calculate the min neither the max.

    using namespace boost::accumulators;

    typedef __stopwatch_reporter__<__stopwatch_accumulator__<__process_real_cpu_clock__,
                accumulator_set<__process_real_cpu_clock__::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean
                    >
                >
      > my_stopwatch_accumulator_reporter;

    int f1(long j)
    {
      static my_stopwatch_accumulator_reporter acc("%c times, sum=%ss, mean=%as\n");
      my_stopwatch_accumulator_reporter::scoped_run _(acc);

      for ( long i = 0; i < j; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }

But what would hapend if we haven't forced the format:

      static my_stopwatch_accumulator_reporter acc;
      my_stopwatch_accumulator_reporter::scoped_run _(acc);

Unfortunately there is no error at compile time. Fortunately, the run-time execution is not undefined and will return 0 for the missing statistics.


[endsect]

[endsect]


[section Formatters]
[section How can I make a specific formatter when the default do not satisfy my expectations]

Imagine then that we want to report the `tag::variance(lazy)`. We will need to include the specific accumulator file

    ...
    #include <boost/accumulators/statistics/variance.hpp>
    ...
    typedef __stopwatch_reporter__<__stopwatch_accumulator__<__process_real_cpu_clock__,
                accumulator_set<__process_real_cpu_clock__::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean,
                            tag::variance(lazy)
                    >
                >
    > my_stopwatch_accumulator_reporter;

But what happens if we add new statistics to the accumulator_set that are not taken in account by the default formatter? These statistics will simply be ignored. So we will need to define our own accumulator formatter.

    typedef __stopwatch_reporter__<__stopwatch_accumulator__<__process_real_cpu_clock__,
                accumulator_set<__process_real_cpu_clock__::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean,
                            tag::variance(lazy)
                    >
                >,
                my_stopwatch_accumulator_formatter
    > my_stopwatch_accumulator_reporter;

Next follow the definition of a formatter taking care of count, sum, mean and variance

    class my_stopwatch_accumulator_formatter {
    public:
        typedef std::string string_type;
        typedef char char_type;
        typedef std::ostream ostream_type;

        static ostream_type &  default_os() {return std::cout;}
        static const char_type* default_format() {
            return "%c times, sum=%ss, mean=%as, variance=%vs\n";
        }
        static int default_places() { return 3; }

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char_type* format,
                                int places, ostream_type & os, system::error_code & ec)
        {
            typedef typename Stopwatch::duration duration_t;
            typename Stopwatch::accumulator accumulator& acc = stopwatch_.accumulated();

            boost::io::ios_flags_saver ifs( os );
            os.setf( std::ios_base::fixed, std::ios_base::floatfield );
            boost::io::ios_precision_saver ips( os );
            os.precision( places );

            for ( ; *format; ++format ) {
                if ( *format != '%' || !*(format+1) || !std::strchr("acsv", *(format+1)) ) {
                    os << *format;
                } else {
                    ++format;
                    switch ( *format ) {
                    case 's':
                        os << boost::chrono::duration<double>(
                                duration_t(accumulators::sum(acc))).count();
                        break;
                    case 'a':
                        os << (accumulators::count(acc)>0)
                                ? boost::chrono::__duration__<double>(duration_t(
                                    duration_t::rep(accumulators::mean(acc)))).count()
                                : 0;
                        break;
                    case 'c':
                        os << accumulators::count(acc);
                        break;
                    case 'v':
                        os << (accumulators::count(acc)>0)
                                ? boost::chrono::__duration__<double>(duration_t(
                                    duration_t::rep(accumulators::variance(acc)))).count()
                                : 0;
                        break;
                    default:
                        assert(0 && "my_stopwatch_accumulator_formatter internal logic error");
                    }
                }
            }
        }
    };



[endsect]

[endsect]


[endsect]
[/===============]
[section Examples]
[/===============]

[section Common type]

[/==================]
[section min utility]

Returns the earliest time_point.

    template <class Clock, class Duration1, class Duration2>
    typename boost::__common_type__<__time_point__<Clock, Duration1>,
                         __time_point__<Clock, Duration2> >::type
    min(__time_point__<Clock, Duration1> t1, __time_point__<Clock, Duration2> t2)
    {
        return t2 < t1 ? t2 : t1;
    }

Being able to *easily* write this function is a major feature!

    BOOST_AUTO(t1, system_clock::now() + seconds(3));
    BOOST_AUTO(t2, system_clock::now() + nanoseconds(3));
    BOOST_AUTO(t3, (min)(t1, t2));

['See the source file [@../../example/min_time_point.cpp example/min_time_point.cpp]]


[endsect]

[endsect]

[section Ratio]

[/===============]
[section SI-units]
[/===============]

Type-safe "physics" code interoperating with boost::chrono::__duration__ types and taking advantage of the boost::__ratio__ infrastructure and design philosophy.

length - mimics boost::chrono::__duration__ except restricts representation to double.
Uses boost::__ratio__ facilities for length units conversions.

    template <class Ratio>
    class length {
    private:
        double len_;
    public:
        typedef Ratio ratio;
        length() : len_(1) {}
        length(const double& len) : len_(len) {}

        template <class R>
        length(const length<R>& d)
                : len_(d.count() * boost::ratio_divide<Ratio, R>::type::den /
                                   boost::ratio_divide<Ratio, R>::type::num) {}

        double count() const {return len_;}

        length& operator+=(const length& d) {len_ += d.count(); return *this;}
        length& operator-=(const length& d) {len_ -= d.count(); return *this;}

        length operator+() const {return *this;}
        length operator-() const {return length(-len_);}

        length& operator*=(double rhs) {len_ *= rhs; return *this;}
        length& operator/=(double rhs) {len_ /= rhs; return *this;}
    };


Sparse sampling of length units

    typedef length<boost::__ratio__<1> >          meter;        // set meter as "unity"
    typedef length<boost::__centi>              centimeter;   // 1/100 meter
    typedef length<boost::__kilo>               kilometer;    // 1000  meters
    typedef length<boost::__ratio__<254, 10000> > inch;         // 254/10000 meters

length takes __ratio__ instead of two integral types so that definitions can be made like so:

    typedef length<boost::ratio_multiply<boost::__ratio__<12>, inch::__ratio__>::type>   foot;  // 12 inchs
    typedef length<boost::ratio_multiply<boost::__ratio__<5280>, foot::__ratio__>::type> mile;  // 5280 feet

Need a floating point definition of seconds

    typedef boost::chrono::__duration__<double> seconds;                         // unity

Demo of (scientific) support for sub-nanosecond resolutions

    typedef boost::chrono::__duration__<double,  boost::__pico> picosecond;  // 10^-12 seconds
    typedef boost::chrono::__duration__<double, boost::__femto> femtosecond; // 10^-15 seconds
    typedef boost::chrono::__duration__<double,  boost::__atto> attosecond;  // 10^-18 seconds

A very brief proof-of-concept for SIUnits-like library. Hard-wired to floating point seconds and meters, but accepts other units.

    template <class R1, class R2>
    class quantity
    {
        double q_;
    public:
        typedef R1 time_dim;
        typedef R2 distance_dim;
        quantity() : q_(1) {}

        double get() const {return q_;}
        void set(double q) {q_ = q;}
    };

    template <>
    class quantity<boost::__ratio__<1>, boost::__ratio__<0> >
    {
        double q_;
    public:
        quantity() : q_(1) {}
        quantity(seconds d) : q_(d.count()) {}  // note:  only User1::seconds needed here

        double get() const {return q_;}
        void set(double q) {q_ = q;}
    };

    template <>
    class quantity<boost::__ratio__<0>, boost::__ratio__<1> >
    {
        double q_;
    public:
        quantity() : q_(1) {}
        quantity(meter d) : q_(d.count()) {}  // note:  only User1::meter needed here

        double get() const {return q_;}
        void set(double q) {q_ = q;}
    };

    template <>
    class quantity<boost::__ratio__<0>, boost::__ratio__<0> >
    {
        double q_;
    public:
        quantity() : q_(1) {}
        quantity(double d) : q_(d) {}

        double get() const {return q_;}
        void set(double q) {q_ = q;}
    };

Example of SI-Units

    typedef quantity<boost::__ratio__<0>, boost::__ratio__<0> >  Scalar;
    typedef quantity<boost::__ratio__<1>, boost::__ratio__<0> >  Time;         // second
    typedef quantity<boost::__ratio__<0>, boost::__ratio__<1> >  Distance;     // meter
    typedef quantity<boost::__ratio__<-1>, boost::__ratio__<1> > Speed;        // meter/second
    typedef quantity<boost::__ratio__<-2>, boost::__ratio__<1> > Acceleration; // meter/second^2

Quantity arithmetics

    template <class R1, class R2, class R3, class R4>
    quantity<typename boost::ratio_subtract<R1, R3>::type, 
             typename boost::ratio_subtract<R2, R4>::type>
    operator/(const quantity<R1, R2>& x, const quantity<R3, R4>& y)
    {
        typedef quantity<typename boost::ratio_subtract<R1, R3>::type,
                        typename boost::ratio_subtract<R2, R4>::type> R;
        R r;
        r.set(x.get() / y.get());
        return r;
    }

    template <class R1, class R2, class R3, class R4>
    quantity<typename boost::ratio_add<R1, R3>::type, 
             typename boost::ratio_add<R2, R4>::type>
    operator*(const quantity<R1, R2>& x, const quantity<R3, R4>& y)
    {
        typedef quantity<typename boost::ratio_add<R1, R3>::type,
                        typename boost::ratio_add<R2, R4>::type> R;
        R r;
        r.set(x.get() * y.get());
        return r;
    }

    template <class R1, class R2>
    quantity<R1, R2>
    operator+(const quantity<R1, R2>& x, const quantity<R1, R2>& y)
    {
        typedef quantity<R1, R2> R;
        R r;
        r.set(x.get() + y.get());
        return r;
    }

    template <class R1, class R2>
    quantity<R1, R2>
    operator-(const quantity<R1, R2>& x, const quantity<R1, R2>& y)
    {
        typedef quantity<R1, R2> R;
        R r;
        r.set(x.get() - y.get());
        return r;
    }

Example type-safe physics function

    Distance
    compute_distance(Speed v0, Time t, Acceleration a)
    {
        return v0 * t + Scalar(.5) * a * t * t;  // if a units mistake is made here it won't compile
    }


Exercise example type-safe physics function and show interoperation
of custom time durations (User1::seconds) and standard time durations (boost::hours).
Though input can be arbitrary (but type-safe) units, output is always in SI-units
(a limitation of the simplified Units lib demoed here).

    int main()
    {
        typedef boost::__ratio__<8, BOOST_INTMAX_C(0x7FFFFFFFD)> R1;
        typedef boost::__ratio__<3, BOOST_INTMAX_C(0x7FFFFFFFD)> R2;
        typedef User1::quantity<boost::ratio_subtract<boost::__ratio__<0>, boost::__ratio__<1> >::type,
                                 boost::ratio_subtract<boost::__ratio__<1>, boost::__ratio__<0> >::type > RR;
        typedef boost::ratio_subtract<R1, R2>::type RS;
        std::cout << RS::num << '/' << RS::den << '\n';


        std::cout << "*************\n";
        std::cout << "* testUser1 *\n";
        std::cout << "*************\n";
        User1::Distance d( User1::mile(110) );
        User1::Time t( boost::chrono::__hours(2) );

        RR r=d / t;
        //r.set(d.get() / t.get());

        User1::Speed rc= r;

        User1::Speed s = d / t;
        std::cout << "Speed = " << s.get() << " meters/sec\n";
        User1::Acceleration a = User1::Distance( User1::foot(32.2) ) / User1::Time() / User1::Time();
        std::cout << "Acceleration = " << a.get() << " meters/sec^2\n";
        User1::Distance df = compute_distance(s, User1::Time( User1::seconds(0.5) ), a);
        std::cout << "Distance = " << df.get() << " meters\n";
        std::cout << "There are " 
            << User1::mile::ratio::den << '/' << User1::mile::ratio::num << " miles/meter";
        User1::meter mt = 1;
        User1::mile mi = mt;
        std::cout << " which is approximately " << mi.count() << '\n';
        std::cout << "There are " 
            << User1::mile::ratio::num << '/' << User1::mile::ratio::den << " meters/mile";
        mi = 1;
        mt = mi;
        std::cout << " which is approximately " << mt.count() << '\n';
        User1::attosecond as(1);
        User1::seconds sec = as;
        std::cout << "1 attosecond is " << sec.count() << " seconds\n";
        std::cout << "sec = as;  // compiles\n";
        sec = User1::seconds(1);
        as = sec;
        std::cout << "1 second is " << as.count() << " attoseconds\n";
        std::cout << "as = sec;  // compiles\n";
        std::cout << "\n";
      return 0;
    }

['See the source file [@../../test/ratio_test.cpp test/ratio_test.cpp]]

[endsect]
[endsect]

[section Duration]

[/===============]
[section How you override the duration's default constructor]

Next follows how you override the duration's default constructor to do anything you want (in this case zero). All we need to do is to change the representation

    namespace I_dont_like_the_default_duration_behavior {

    template <class R>
    class zero_default
    {
    public:
        typedef R rep;

    private:
        rep rep_;
    public:
        zero_default(rep i = 0) : rep_(i) {}
        operator rep() const {return rep_;}

        zero_default& operator+=(zero_default x) {rep_ += x.rep_; return *this;}
        zero_default& operator-=(zero_default x) {rep_ -= x.rep_; return *this;}
        zero_default& operator*=(zero_default x) {rep_ *= x.rep_; return *this;}
        zero_default& operator/=(zero_default x) {rep_ /= x.rep_; return *this;}

        zero_default  operator+ () const {return *this;}
        zero_default  operator- () const {return zero_default(-rep_);}
        zero_default& operator++()       {++rep_; return *this;}
        zero_default  operator++(int)    {return zero_default(rep_++);}
        zero_default& operator--()       {--rep_; return *this;}
        zero_default  operator--(int)    {return zero_default(rep_--);}

        friend zero_default operator+(zero_default x, zero_default y) {return x += y;}
        friend zero_default operator-(zero_default x, zero_default y) {return x -= y;}
        friend zero_default operator*(zero_default x, zero_default y) {return x *= y;}
        friend zero_default operator/(zero_default x, zero_default y) {return x /= y;}

        friend bool operator==(zero_default x, zero_default y) {return x.rep_ == y.rep_;}
        friend bool operator!=(zero_default x, zero_default y) {return !(x == y);}
        friend bool operator< (zero_default x, zero_default y) {return x.rep_ < y.rep_;}
        friend bool operator<=(zero_default x, zero_default y) {return !(y < x);}
        friend bool operator> (zero_default x, zero_default y) {return y < x;}
        friend bool operator>=(zero_default x, zero_default y) {return !(x < y);}
    };

    typedef boost::chrono::__duration__<zero_default<long long>, boost::nano        > nanoseconds;
    typedef boost::chrono::__duration__<zero_default<long long>, boost::micro       > microseconds;
    typedef boost::chrono::__duration__<zero_default<long long>, boost::milli       > milliseconds;
    typedef boost::chrono::__duration__<zero_default<long long>                      > seconds;
    typedef boost::chrono::__duration__<zero_default<long long>, boost::__ratio__<60>   > minutes;
    typedef boost::chrono::__duration__<zero_default<long long>, boost::__ratio__<3600> > hours;
    }

Usage

    using namespace I_dont_like_the_default_duration_behavior;

    milliseconds ms;
    std::cout << ms.count() << '\n';

['See the source file [@../../example/i_dont_like_the_default_duration_behavior.cpp example/i_dont_like_the_default_duration_behavior.cpp]]

[endsect]

[/=========================]
[section runtime_resolution]

Handle duration with resolution not known until run time

    class duration
    {
    public:
        typedef long long rep;
    private:
        rep rep_;

        static const double ticks_per_nanosecond;

    public:
        typedef boost::chrono::duration<double, boost::nano> tonanosec;

        duration() {} // = default;
        explicit duration(const rep& r) : rep_(r) {}

        // conversions
        explicit duration(const tonanosec& d)
                : rep_(static_cast<rep>(d.count() * ticks_per_nanosecond)) {}

        // explicit
           operator tonanosec() const {return tonanosec(rep_/ticks_per_nanosecond);}

        // observer

        rep count() const {return rep_;}

        // arithmetic

        duration& operator+=(const duration& d) {rep_ += d.rep_; return *this;}
        duration& operator-=(const duration& d) {rep_ += d.rep_; return *this;}
        duration& operator*=(rep rhs)           {rep_ *= rhs; return *this;}
        duration& operator/=(rep rhs)           {rep_ /= rhs; return *this;}

        duration  operator+() const {return *this;}
        duration  operator-() const {return duration(-rep_);}
        duration& operator++()      {++rep_; return *this;}
        duration  operator++(int)   {return duration(rep_++);}
        duration& operator--()      {--rep_; return *this;}
        duration  operator--(int)   {return duration(rep_--);}

        friend duration operator+(duration x, duration y) {return x += y;}
        friend duration operator-(duration x, duration y) {return x -= y;}
        friend duration operator*(duration x, rep y)      {return x *= y;}
        friend duration operator*(rep x, duration y)      {return y *= x;}
        friend duration operator/(duration x, rep y)      {return x /= y;}

        friend bool operator==(duration x, duration y) {return x.rep_ == y.rep_;}
        friend bool operator!=(duration x, duration y) {return !(x == y);}
        friend bool operator< (duration x, duration y) {return x.rep_ < y.rep_;}
        friend bool operator<=(duration x, duration y) {return !(y < x);}
        friend bool operator> (duration x, duration y) {return y < x;}
        friend bool operator>=(duration x, duration y) {return !(x < y);}
    };

['See the source file [@../../example/runtime_resolution.cpp here]]

[endsect]

[/================]
[section Saturating]

A "saturating" signed integral type  is developed.  This type has +/- infinity and a nan (like IEEE floating point) but otherwise obeys signed integral arithmetic. This class is subsequently used as the rep in boost::chrono::__duration__ to demonstrate a duration class that does not silently ignore overflow.

['See the source file [@../../example/saturating.cpp example/saturating.cpp]]


[endsect]

[endsect]
[section Clocks]

[/==================]
[section Cycle count]

Users can easily create their own clocks, with both points in time and time durations which have a representation and precision of their own choosing. For example if there is a hardware counter which simply increments a count with each cycle of the cpu, one can very easily build clocks, time points and durations on top of that, using only a few tens of lines of code. Such systems can be used to call the time-sensitive threading API's such as sleep, wait on a condition variable, or wait for a mutex lock. The API proposed herein is not sensitive as to whether this is a 300MHz clock (with a 3 1/3 nanosecond tick period) or a 3GHz clock (with a tick period of  1/3 of a nanosecond). And the resulting code will be just as efficient as if the user wrote a special purpose clock cycle counter.


    #include <boost/chrono/chrono.hpp>
    #include <boost/type_traits.hpp>

    #include <iostream>

    using namespace boost::chrono;


    template <long long speed>
    struct cycle_count
    {
        typedef typename boost::__ratio_multiply__<boost::__ratio__<speed>, boost::__mega>::type 
            frequency;  // Mhz
        typedef typename boost::__ratio_divide__<boost::__ratio__<1>, frequency>::type period;
        typedef long long rep;
        typedef boost::chrono::__duration__<rep, period> duration;
        typedef boost::chrono::__time_point__<cycle_count> time_point;

        static time_point now()
        {
            static long long tick = 0;
            // return exact cycle count
            return time_point(duration(++tick));  // fake access to clock cycle count
        }
    };

    template <long long speed>
    struct approx_cycle_count
    {
        static const long long frequency = speed * 1000000;  // MHz
        typedef nanoseconds duration;
        typedef duration::rep rep;
        typedef duration::period period;
        static const long long nanosec_per_sec = period::den;
        typedef boost::chrono::__time_point__<approx_cycle_count> time_point;

        static time_point now()
        {
            static long long tick = 0;
            // return cycle count as an approximate number of nanoseconds
            // compute as if nanoseconds is only duration in the std::lib
            return time_point(duration(++tick * nanosec_per_sec / frequency));
        }
    };

['See the source file [@../../example/cycle_count.cpp here]]

[endsect]

[/==================]
[section xtime_clock]

This example demonstrates the use of a timeval-like struct to be used as the representation
type for both duraiton and time_point.

    class xtime {
    private:
        long tv_sec;
        long tv_usec;

        void fixup() {
            if (tv_usec < 0) {
                tv_usec += 1000000;
                --tv_sec;
            }
        }

    public:
        explicit xtime(long sec, long usec) {
            tv_sec = sec;
            tv_usec = usec;
            if (tv_usec < 0 || tv_usec >= 1000000) {
                tv_sec += tv_usec / 1000000;
                tv_usec %= 1000000;
                fixup();
            }
        }

        explicit xtime(long long usec) {
            tv_usec = static_cast<long>(usec % 1000000);
            tv_sec  = static_cast<long>(usec / 1000000);
            fixup();
        }

        // explicit
        operator long long() const {return static_cast<long long>(tv_sec) * 1000000 + tv_usec;}

        xtime& operator += (xtime rhs) {
            tv_sec += rhs.tv_sec;
            tv_usec += rhs.tv_usec;
            if (tv_usec >= 1000000) {
                tv_usec -= 1000000;
                ++tv_sec;
            }
            return *this;
        }

        xtime& operator -= (xtime rhs) {
            tv_sec -= rhs.tv_sec;
            tv_usec -= rhs.tv_usec;
            fixup();
            return *this;
        }

        xtime& operator %= (xtime rhs) {
            long long t = tv_sec * 1000000 + tv_usec;
            long long r = rhs.tv_sec * 1000000 + rhs.tv_usec;
            t %= r;
            tv_sec = static_cast<long>(t / 1000000);
            tv_usec = static_cast<long>(t % 1000000);
            fixup();
            return *this;
        }

        friend xtime operator+(xtime x, xtime y) {return x += y;}
        friend xtime operator-(xtime x, xtime y) {return x -= y;}
        friend xtime operator%(xtime x, xtime y) {return x %= y;}

        friend bool operator==(xtime x, xtime y)
            { return (x.tv_sec == y.tv_sec && x.tv_usec == y.tv_usec); }

        friend bool operator<(xtime x, xtime y) {
            if (x.tv_sec == y.tv_sec)
                return (x.tv_usec < y.tv_usec);
            return (x.tv_sec < y.tv_sec);
        }

        friend bool operator!=(xtime x, xtime y) { return !(x == y); }
        friend bool operator> (xtime x, xtime y) { return y < x; }
        friend bool operator<=(xtime x, xtime y) { return !(y < x); }
        friend bool operator>=(xtime x, xtime y) { return !(x < y); }

        friend std::ostream& operator<<(std::ostream& os, xtime x)
            {return os << '{' << x.tv_sec << ',' << x.tv_usec << '}';}
    };

Clock based on timeval-like struct.

    class xtime_clock
    {
    public:
        typedef xtime                                  rep;
        typedef boost::micro                           period;
        typedef boost::chrono::__duration__<rep, period>   duration;
        typedef boost::chrono::__time_point__<xtime_clock> time_point;

        static time_point now()
        {
        #if defined(BOOST_CHRONO_WINDOWS_API)
            time_point t(duration(xtime(0)));
            gettimeofday((timeval*)&t, 0);
            return t;

        #elif defined(BOOST_CHRONO_MAC_API)

            time_point t(duration(xtime(0)));
            gettimeofday((timeval*)&t, 0);
            return t;

        #elif defined(BOOST_CHRONO_POSIX_API)
            //time_point t(0,0);

            timespec ts;
            ::clock_gettime( CLOCK_REALTIME, &ts );

            xtime xt( ts.tv_sec, ts.tv_nsec/1000);
            return time_point(duration(xt));

        #endif  // POSIX
        }
    };

Usage of xtime_clock

        using namespace boost::chrono;
        std::cout << "sizeof xtime_clock::time_point = " << sizeof(xtime_clock::time_point) << '\n';
        std::cout << "sizeof xtime_clock::duration = " << sizeof(xtime_clock::duration) << '\n';
        std::cout << "sizeof xtime_clock::rep = " << sizeof(xtime_clock::rep) << '\n';
        xtime_clock::duration delay(milliseconds(5));
        xtime_clock::time_point start = xtime_clock::now();
        while (xtime_clock::now() - start <= delay) {}
        xtime_clock::time_point stop = xtime_clock::now();
        xtime_clock::duration elapsed = stop - start;
        std::cout << "paused " << nanoseconds(elapsed).count() << " nanoseconds\n";


['See the source file [@../../example/timeval_demo.cpp example/timeval_demo.cpp]]

[endsect]
[endsect]

[section Conversions]

[/==================]
[section xtime conversions]

Example round_up utility:  converts d to To, rounding up for inexact conversions
Being able to *easily* write this function is a major feature!

    #include <boost/chrono/chrono.hpp>
    #include <boost/type_traits.hpp>

    #include <iostream>

    using namespace boost::chrono;

    template <class To, class Rep, class Period>
    To
    round_up(duration<Rep, Period> d)
    {
        To result = duration_cast<To>(d);
        if (result < d)
            ++result;
        return result;
    }

Demonstrate interaction with xtime-like facility:


    struct xtime
    {
        long sec;
        unsigned long usec;
    };

    template <class Rep, class Period>
    xtime
    to_xtime_truncate(__duration__<Rep, Period> d)
    {
        xtime xt;
        xt.sec = static_cast<long>(__duration_cast__<__seconds__>(d).count());
        xt.usec = static_cast<long>(__duration_cast__<__microseconds__>(d - __seconds__(xt.sec)).count());
        return xt;
    }

    template <class Rep, class Period>
    xtime
    to_xtime_round_up(__duration__<Rep, Period> d)
    {
        xtime xt;
        xt.sec = static_cast<long>(__duration_cast__<__seconds__>(d).count());
        xt.usec = static_cast<unsigned long>(round_up<__microseconds__>(d - __seconds__(xt.sec)).count());
        return xt;
    }

    microseconds
    from_xtime(xtime xt)
    {
        return __seconds__(xt.sec) + __microseconds__(xt.usec);
    }

    void print(xtime xt)
    {
        std::cout << '{' << xt.sec << ',' << xt.usec << "}\n";
    }

Usage

        xtime xt = to_xtime_truncate(seconds(3) + __milliseconds__(251));
        print(xt);
        milliseconds ms = __duration_cast__<__milliseconds__>(from_xtime(xt));
        std::cout << ms.count() << " milliseconds\n";
        xt = to_xtime_round_up(ms);
        print(xt);
        xt = to_xtime_truncate(seconds(3) + __nanoseconds__(999));
        print(xt);
        xt = to_xtime_round_up(seconds(3) + __nanoseconds__(999));
        print(xt);


['See the source file [@../../example/xtime.cpp here]]

[endsect]
[endsect]



[/
[/======================================================]
[section Howard Hinnant's original demonstration program]

['See the source file [@../../example/time2_demo.cpp example/time2_demo.cpp]]

[endsect]
]

[section Reporting]

[/===============================================================]
[section A tiny program that times how long until a key is struck]

    #include <boost/chrono/chrono.hpp>
    #include <iostream>
    #include <iomanip>

    using namespace boost::chrono;

    template< class Clock >
    class timer
    {
      typename Clock::time_point start;
    public:

      timer() : start( Clock::now() ) {}

      typename Clock::duration elapsed() const
      {
        return Clock::now() - start;
      }

      double seconds() const
      {
        return elapsed().count() * ((double)Clock::period::num/Clock::period::den);
      }
    };

    int main()
    {
      timer<__system_clock__> t1;
      timer<__monotonic_clock__> t2;
      timer<__high_resolution_clock__> t3;

      std::cout << "Strike any key: ";
      std::cin.get();

      std::cout << std::fixed << std::setprecision(9);
      std::cout << "system_clock-----------: "
                << t1.seconds() << " seconds\n";
      std::cout << "monotonic_clock--------: "
                << t2.seconds() << " seconds\n";
      std::cout << "high_resolution_clock--: "
                << t3.seconds() << " seconds\n";

      __system_clock__::time_point d4 = __system_clock__::now();
      __system_clock__::time_point d5 = __system_clock__::now();

      std::cout << "\nsystem_clock latency-----------: " << (d5 - d4).count() << std::endl;

      __monotonic_clock__::time_point d6 = __monotonic_clock__::now();
      __monotonic_clock__::time_point d7 = __monotonic_clock__::now();

      std::cout << "monotonic_clock latency--------: " << (d7 - d6).count() << std::endl;

      __high_resolution_clock__::time_point d8 = __high_resolution_clock__::now();
      __high_resolution_clock__::time_point d9 = __high_resolution_clock__::now();

      std::cout << "high_resolution_clock latency--: " << (d9 - d8).count() << std::endl;

      std::time_t now = __system_clock__::to_time_t(__system_clock__::now());

      std::cout << "\nsystem_clock::now() reports UTC is "
        << std::asctime(std::gmtime(&now)) << "\n";

      return 0;
    }

The output of this program run looks like this:

['See the source file [@../../example/await_keystroke.cpp example/await_keystroke.cpp]]

[endsect]

[/============================]
[section stopclock_example.cpp]

Here is the stopclock_example.cpp program supplied with the Boost Chrono library:

[/stopclock_example_cpp]

When the `stopclock<> t` object is created, it starts timing. When it is destroyed at the end of the program, its destructor stops the time counting and displays timing information on cout.

    #include <boost/chrono/stopclock.hpp>
    #include <cmath>

    int main()
    {
      boost::chrono::__stopclock__<> t;

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }

The output of this program run looks like this:

   wall 0.42 s, user 0.41 s + system 0.00 s = total cpu 0.41 s, (96.3%)

In other words, this program ran in 0.42 seconds as would be measured by a clock on the wall, the operating system charged it for 0.41 seconds of user CPU time and 0 seconds of system CPU time, the total of these two was 0.41, and that represented 96.3 percent of the wall clock time.

['See the source file [@../../example/stopclock_example.cpp example/stopclock_example.cpp]]

[endsect]


[/=============================]
[section stopclock_example2.cpp]

The stopclock_example2.cpp program is the same, except that it supplies additional constructor arguments from the command line:

    #include <boost/chrono/stopclock.hpp>
    #include <cmath>

    int main( int argc, char * argv[] )
    {
      const char * format = argc > 1 ? argv[1] : "%t cpu seconds\n";
      int          places = argc > 2 ? std::atoi( argv[2] ) : 2;

      boost::chrono::__stopclock__<> t( format, places );

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L ); // burn some time

      return 0;
    }

Here is the output for this program for several sets of command line arguments:

    stopclock_example2
    0.42 cpu seconds

    stopclock_example2 "%w wall clock seconds\n"
    0.41 wall clock seconds

    stopclock_example2 "%w wall clock seconds\n" 6
    0.421875 wall clock seconds

    stopclock_example2 "%t total CPU seconds\n" 3
    0.422 total CPU seconds

['See the source file [@../../example/stopclock_example2.cpp example/stopclock_example2.cpp]]

[endsect]

[/===============================================================]
[section time command]

    #include <boost/chrono/stopclock.hpp>
    #include <cstdlib>
    #include <string>
    #include <iostream>

    int main( int argc, char * argv[] )
    {
      if ( argc == 1 )
      {
        std::cout << "invoke: timex [-v] command [args...]\n"
          "  command will be executed and timings displayed\n"
          "  -v option causes command and args to be displayed\n";
        return 1;
      }

      std::string s;

      bool verbose = false;
      if ( argc > 1 && *argv[1] == '-' && *(argv[1]+1) == 'v' )
      {
        verbose = true;
        ++argv;
        --argc;
      }

      for ( int i = 1; i < argc; ++i )
      {
        if ( i > 1 ) s += ' ';
        s += argv[i];
      }

      if ( verbose )
        { std::cout << "command: \"" << s.c_str() << "\"\n"; }

      boost::chrono::__stopclock__<> t;

      return std::system( s.c_str() );
    }

['See the source file [@../../example/timex.cpp example/timex.cpp]]

[endsect]
[endsect]

[/=======================================================]
[section Simulated thread interface demonstration program]

The C++0x standard library's multi-threading library requires the ability to deal with the representation of time in a manner consistent with modern C++ practices. Next follows a simaulation of this interface. 

Free sleep functions

    namespace boost { namespace this_thread {

    template <class Rep, class Period>
    void sleep_for(const chrono::__duration__<Rep, Period>& d) {
        chrono::__microseconds__ t = chrono::__duration_cast__<chrono::__microseconds__>(d);
        if (t < d)
            ++t;
        if (t > chrono::__microseconds__(0))
            std::cout << "sleep_for " << t.count() << " microseconds\n";
    }

    template <class Clock, class Duration>
    void sleep_until(const chrono::__time_point__<Clock, Duration>& t) {
        using namespace chrono;
        typedef __time_point__<Clock, Duration> Time;
        typedef __system_clock__::time_point SysTime;
        if (t > Clock::now()) {
            typedef typename __common_type__<typename Time::duration,
                                         typename SysTime::duration>::type D;
            /* auto */ D d = t - Clock::now();
            microseconds us = __duration_cast__<__microseconds__>(d);
            if (us < d)
                ++us;
            SysTime st = __system_clock__::now() + us;
            std::cout << "sleep_until    ";
            detail::print_time(st);
            std::cout << " which is " << (st - __system_clock__::now()).count() << " microseconds away\n";
        }
    }

    }}


timed_mutex modified fuctions

    namespace boost {
    struct timed_mutex {
        // ...

        template <class Rep, class Period>
        bool try_lock_for(const chrono::__duration__<Rep, Period>& d) {
            chrono::__microseconds__ t = chrono::__duration_cast__<chrono::__microseconds__>(d);
            if (t <= chrono::__microseconds__(0))
                return try_lock();
            std::cout << "try_lock_for " << t.count() << " microseconds\n";
            return true;
        }

        template <class Clock, class Duration>
        bool try_lock_until(const chrono::__time_point__<Clock, Duration>& t)
        {
            using namespace chrono;
            typedef __time_point__<Clock, Duration> Time;
            typedef __system_clock__::time_point SysTime;
            if (t <= Clock::now())
                return try_lock();
            typedef typename __common_type__<typename Time::duration,
              typename Clock::duration>::type D;
            /* auto */ D d = t - Clock::now();
            microseconds us = __duration_cast__<__microseconds__>(d);
            SysTime st = __system_clock__::now() + us;
            std::cout << "try_lock_until ";
            detail::print_time(st);
            std::cout << " which is " << (st - __system_clock__::now()).count()
              << " microseconds away\n";
            return true;
        }
    };
    }

condition_variable modified fuctions

    namespace boost {
    struct condition_variable
    {
        // ...

        template <class Rep, class Period>
        bool wait_for(mutex&, const chrono::__duration__<Rep, Period>& d) {
            chrono::microseconds t = chrono::__duration_cast__<chrono::microseconds>(d);
            std::cout << "wait_for " << t.count() << " microseconds\n";
            return true;
        }

        template <class Clock, class Duration>
        bool wait_until(mutex&, const chrono::__time_point__<Clock, Duration>& t) {
            using namespace boost::chrono;
            typedef __time_point__<Clock, Duration> Time;
            typedef __system_clock__::time_point SysTime;
            if (t <= Clock::now())
                return false;
            typedef typename __common_type__<typename Time::duration,
              typename Clock::duration>::type D;
            /* auto */ D d = t - Clock::now();
            microseconds us = __duration_cast__<__microseconds__>(d);
            SysTime st = __system_clock__::now() + us;
             std::cout << "wait_until     ";
            detail::print_time(st);
            std::cout << " which is " << (st - __system_clock__::now()).count()
              << " microseconds away\n";
            return true;
        }
    };
    }

Usage

    boost::mutex m;
    boost::timed_mutex mut;
    boost::condition_variable cv;

    using namespace boost;
    using namespace boost::chrono;

    this_thread::sleep_for(__seconds__(3));
    this_thread::sleep_for(__nanoseconds__(300));
    system_clock::time_point time_limit = __system_clock__::now() + __seconds_(4) + __milliseconds__(500);
    this_thread::sleep_until(time_limit);

    mut.try_lock_for(__milliseconds__(30));
    mut.try_lock_until(time_limit);

    cv.wait_for(m, __minutes__(1));    // real code would put this in a loop
    cv.wait_until(m, time_limit);  // real code would put this in a loop

    // For those who prefer floating point
    this_thread::sleep_for(__duration__<double>(0.25));
    this_thread::sleep_until(__system_clock__::now() + __duration__<double>(1.5));


['See the source file [@../../example/simulated_thread_interface_demo.cpp example/simulated_thread_interface_demo.cpp]]


[endsect]

[endsect]

[/================================]
[section:ext_references External Resources]
[/================================]

[variablelist

[
    [[@http://www.open-std.org/jtc1/sc22/wg21 [*C++ Standards Committee's current Working Paper]]]
    [The most authoritative reference material for the library is the C++ Standards Committee's current Working Paper (WP).  20.9 Time utilities "time", 20.4 Compile-time rational arithmetic "ratio", 20.6.7 Other transformations "meta.trans.other"]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]]]
    [From Howard E. Hinnant, Walter E. Brown, Jeff Garland  and Marc Paterno. Is very informative and provides motivation for key design decisions]
]


[
    [[@http://home.roadrunner.com/~hinnant/issue_review/lwg-defects.html#934 [*LGW 934. duration is missing operator%]]]
    [From Terry Golubiewski. Is very informative and provides motivation for key design decisions]
]

[
    [[@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]]]
    [From Vicente Juan Botet Escriba.]
]

[
    [[@http://www.digitalmars.com/d/2.0/phobos/std_traits.html#CommonType D programming language -  CommonType trait]]
    [From Andrei Alexandrescu.]
]


]

[endsect]

[endsect]

[/=================]
[section:reference Reference ]
[/=================]

[section:cpp0x Included on the C++0x recommendation]

[/===================================================================]
[section:common_type_hpp Header `<boost/type_traits/common_type.hpp>`]
[/===================================================================]

    // configuration macros
    #define __common_type__BOOST_COMMON_TYPE_USES_STATIC_ASSERT
    #define __common_type__BOOST_COMMON_TYPE_USES_MPL_ASSERT
    #define __common_type__BOOST_COMMON_TYPE_USES_ARRAY_ASSERT
    #define __common_type__BOOST_COMMON_TYPE_DONT_USE_TYPEOF

    // preprocessor info
    #define __common_type__BOOST_COMMON_TYPE_ARITY

    namespace boost {
      template <class ...T>  struct __common_type__;
    }

[section:conf Configuration macros]

When BOOST_NO_STATIC_ASSERT is defined, the user can select the way static assertions are reported. Define

* BOOST_COMMON_TYPE_USES_STATIC_ASSERT: define it if you want to use Boost.StaticAssert
* BOOST_COMMON_TYPE_USES_MPL_ASSERT: define it if you want to use Boost.MPL static asertions
* BOOST_COMMON_TYPE_USES_ARRAY_ASSERT: define it if you want to use internal static asertions
* nothing if you don't want static asertions

When BOOST_COMMON_TYPE_USES_MPL_ASSERT is not defined the following symbols are defined as

    #define BOOST_COMMON_TYPE_MUST_BE_A_COMPLETE_TYPE \
        "must be complete type"

Depending on the static assertion used system you will have an hint of the failing assertion either through the symbol or through the texte.

When BOOST_NO_DECLTYPE is not defined common_type is implemented using decltype. Otherwise when BOOST_COMMON_TYPE_DONT_USE_TYPEOF is not defined it uses Boost.TypeOf.


[endsect]

[section:pp Preprocessor info]

When BOOST_NO_VARIADIC_TEMPLATES is defined BOOST_COMMON_TYPE_ARITY gives the maximum number of template parameters for __common_type__.

[endsect]

[section:common_type Class Template `common_type<>`]

__common_type__ is a traits class used to deduce a type common to a several types, useful as the return type of functions operating on multiple input types such as in mixed-mode arithmetic..

The nested typedef __common_type__::type` could be defined as follows:

    template <class T, class U = void, class V = void>
    struct common_type {
        typedef typename __common_type__<typename __common_type__<T, U>::type, V>::type type;
    };

    template <class T>
    struct common_type<T, void, void> {
        typedef T type;
    };

    template <class T, class U>
    struct common_type<T, U, void> {
    private:
        static T m_t();
        static U m_u();
        static bool m_f();  // workaround gcc bug; not required by std
    public:
        typedef BOOST_TYPEOF_TPL(m_f() ? m_t() : m_u()) type;
    };

All parameter types must be complete. This trait is permitted to be specialized by a user if at least one template parameter is a user-defined type.

[*Note:] Such specializations are required when only explicit conversions are desired among the __common_type__ arguments.


[endsect]

[endsect]


[/===========================================]
[section:ratio_hpp Header `<boost/ratio.hpp>`]
[/===========================================]

__ratio__ is a facility which is useful in specifying compile time rational constants. Compile time rational arithmetic is supported with protection against overflow and divide by zero. Such a facility is very handy when needing to efficiently represent  1/3 of a nanosecond, or specifying an inch in terms of meters (for example 254/10000 meters - which __ratio__ will reduce to 127/5000 meters).

    // configuration macros
    #define __BOOST_RATIO_USES_STATIC_ASSERT
    #define __BOOST_RATIO_USES_MPL_ASSERT
    #define __BOOST_RATIO_USES_ARRAY_ASSERT

    namespace boost  {

        template <boost::intmax_t N, boost::intmax_t D = 1> class __ratio__;

        // ratio arithmetic
        template <class R1, class R2> struct __ratio_add;
        template <class R1, class R2> struct __ratio_subtract;
        template <class R1, class R2> struct __ratio_multiply;
        template <class R1, class R2> struct __ratio_divide;

        // ratio comparison
        template <class R1, class R2> struct __ratio_equal;
        template <class R1, class R2> struct __ratio_not_equal;
        template <class R1, class R2> struct __ratio_less;
        template <class R1, class R2> struct __ratio_less_equal;
        template <class R1, class R2> struct __ratio_greater;
        template <class R1, class R2> struct __ratio_greater_equal;

        // convenience SI typedefs
        typedef ratio<1LL, 1000000000000000000LL> __atto;
        typedef ratio<1LL,    1000000000000000LL> __femto;
        typedef ratio<1LL,       1000000000000LL> __pico;
        typedef ratio<1LL,          1000000000LL> __nano;
        typedef ratio<1LL,             1000000LL> __micro;
        typedef ratio<1LL,                1000LL> __milli;
        typedef ratio<1LL,                 100LL> __centi;
        typedef ratio<1LL,                  10LL> __deci;
        typedef ratio<                 10LL, 1LL> __deca;
        typedef ratio<                100LL, 1LL> __hecto;
        typedef ratio<               1000LL, 1LL> __kilo;
        typedef ratio<            1000000LL, 1LL> __mega;
        typedef ratio<         1000000000LL, 1LL> __giga;
        typedef ratio<      1000000000000LL, 1LL> __tera;
        typedef ratio<   1000000000000000LL, 1LL> __peta;
        typedef ratio<1000000000000000000LL, 1LL> __exa;
    }


[section:conf Configuration macros]

When BOOST_NO_STATIC_ASSERT is defined, the user can select the way static assertions are reported. Define

* BOOST_RATIO_USES_STATIC_ASSERT: define it if you want to use Boost.StaticAssert
* BOOST_RATIO_USES_MPL_ASSERT: define it if you want to use Boost.MPL static asertions
* BOOST_RATIO_USES_ARRAY_ASSERT: define it if you want to use internal static asertions
* nothing if you don't want static asertions

When BOOST_RATIO_USES_MPL_ASSERT is not defined the following symbols are defined as

    #define BOOST_RATIO_OVERFLOW_IN_ADD "overflow in ratio add"
    #define BOOST_RATIO_OVERFLOW_IN_SUB "overflow in ratio sub"
    #define BOOST_RATIO_OVERFLOW_IN_MUL "overflow in ratio mul"
    #define BOOST_RATIO_OVERFLOW_IN_DIV "overflow in ratio div"
    #define BOOST_RATIO_RATIO_NUMERATOR_IS_OUT_OF_RANGE "ratio numerator is out of range"
    #define BOOST_RATIO_RATIO_DIVIDE_BY_0 "ratio divide by 0"
    #define BOOST_RATIO_RATIO_DENOMINATOR_IS_OUT_OF_RANGE "ratio denominator is out of range"

Depending on the static assertion used system you will have an hint of the failing assertion either through the symbol or through the texte.

[endsect]

[section:ratio Class Template `ratio<>`]

        template <boost::intmax_t N, boost::intmax_t D>
        class ratio {
        public:
            static const boost::intmax_t num;
            static const boost::intmax_t den;
            typedef ratio<num, den> type;

            ratio() = default;

            template <intmax_t _N2, intmax_t _D2>
            ratio(const ratio<_N2, _D2>&);

            template <intmax_t _N2, intmax_t _D2>
            ratio& operator=(const ratio<_N2, _D2>&) {return *this;}
        };

A diagnostic will be emitted if __ratio__ is instantiated with `D == 0`, or if the absolute value of `N` or `D` can not be represented. [*Note:] These rules ensure that infinite ratios are avoided and that for any negative input, there exists a representable value of its absolute value which is positive. In a two's complement representation, this excludes the most negative value.

Let `gcd` denote the greatest common divisor of `N`'s absolute value and of `D`'s absolute value.

* `num` has the value `sign(N)*sign(D)*abs(N)/gcd`.

* `den` has the value `abs(D)/gcd`.

The nested typedef `type` denotes the normalized form of this __ratio__ type. It should be used when the template parameters doesn't give a normalized form.

Two __ratio__ classes `__ratio__<N1,D1>` and `__ratio__<N2,D2>` have the same normalized form if `__ratio__<N1,D1>::type` is the same type as `__ratio__<N2,D2>::type`

[section:ca Construction and assignment]

    template <intmax_t N2, intmax_t D2>
      ratio(const __ratio__<N2, D2>& r);

[*Effects:] Constructs a __ratio__ object.

[*Remarks:] This constructor will not participate in overload resolution unless `r` has the same normalized form as `*this`.

    template <intmax_t N2, intmax_t D2>
      __ratio__& operator=(const __ratio__<N2, D2>& r);

[*Effects:] Assigns a __ratio__ object.

[*Returns:] *this.

[*Remarks:] This operator will not participate in overload resolution unless `r` has the same normalized form as `*this`.

[endsect]


[endsect]


[section:ratio_arithmetic `ratio` arithmetic]

For each of the class templates in this clause, each template parameter refers to a `ratio`. If the implementation is unable to form the indicated __ratio__ due to overflow, a diagnostic will be issued.

        template <class R1, class R2> struct ratio_add {
           typedef [/see below] type;
        };

The nested typedef `type` is a synonym for `__ratio__<R1::num * R2::den + R2::num * R1::den, R1::den * R2::den>::type`.

        template <class R1, class R2> struct ratio_subtract {
           typedef  [/see below]  type;
        };

The nested typedef `type` is a synonym for `__ratio__<R1::num * R2::den - R2::num * R1::den, R1::den * R2::den>::type`.

        template <class R1, class R2> struct ratio_multiply {
           typedef  [/see below]  type;
        };

The nested typedef `type` is a synonym for `__ratio__<R1::num * R2::num, R1::den * R2::den>::type`.

        template <class R1, class R2> struct ratio_divide {
           typedef  [/see below]  type;
        };

The nested typedef `type` is a synonym for `__ratio__<R1::num * R2::den, R2::num * R1::den>::type`.

[endsect]

[section:ratio_comparison `ratio` comparison]

        template <class R1, class R2>  struct ratio_equal
            : public boost::integral_constant<bool, [/see below] > {};

If R1::num == R2::num && R1::den == R2::den, ratio_equal derives from true_type, else derives from false_type.

        template <class R1, class R2>
        struct ratio_less
            : public boost::integral_constant<bool, [/see below] > {};

If R1::num * R2::den < R2::num * R1::den, ratio_less derives from true_type, else derives from false_type.

    template <class R1, class R2>  struct ratio_not_equal
        : public boost::integral_constant<bool, !ratio_equal<R1, R2>::value> {};

    template <class R1, class R2> struct ratio_less_equal
        : public boost::integral_constant<bool, !ratio_less<R2, R1>::value> {};

    template <class R1, class R2> struct ratio_greater
        : public boost::integral_constant<bool, ratio_less<R2, R1>::value> {};

    template <class R1, class R2> struct ratio_greater_equal
        : public boost::integral_constant<bool, !ratio_less<R1, R2>::value> {};


[endsect]

[section:ratio_si_typedefs SI typedefs]

        // convenience SI typedefs
        typedef __ratio__<1LL, 1000000000000000000LL> atto;
        typedef __ratio__<1LL,    1000000000000000LL> femto;
        typedef __ratio__<1LL,       1000000000000LL> pico;
        typedef __ratio__<1LL,          1000000000LL> nano;
        typedef __ratio__<1LL,             1000000LL> micro;
        typedef __ratio__<1LL,                1000LL> milli;
        typedef __ratio__<1LL,                 100LL> centi;
        typedef __ratio__<1LL,                  10LL> deci;
        typedef __ratio__<                 10LL, 1LL> deca;
        typedef __ratio__<                100LL, 1LL> hecto;
        typedef __ratio__<               1000LL, 1LL> kilo;
        typedef __ratio__<            1000000LL, 1LL> mega;
        typedef __ratio__<         1000000000LL, 1LL> giga;
        typedef __ratio__<      1000000000000LL, 1LL> tera;
        typedef __ratio__<   1000000000000000LL, 1LL> peta;
        typedef __ratio__<1000000000000000000LL, 1LL> exa;


Four of the typedefs in the recomendation which can be conditionally supported are not supported: yocto, zepto, zetta and yotta.

    typedef __ratio__<1, 1000000000000000000000000> yocto;  // conditionally supported
    typedef __ratio__<1,    1000000000000000000000> zepto;  // conditionally supported
    typedef __ratio__<   1000000000000000000000, 1> zetta;  // conditionally supported
    typedef __ratio__<1000000000000000000000000, 1> yotta;  // conditionally supported

[endsect]

[endsect]

[/=============================================]
[section:chrono_hpp Header `<boost/chrono.hpp>`]
[/=============================================]

This file is a redirection to `boost/chrono/chrono.hpp` including in addition registration for __duration__ and __time_point__ class templates to Boost.Typeof.


    #include <boost/chrono/chrono.hpp>
    #include <boost/chrono/typeof/boost/chrono/chrono.hpp>

[endsect]

[/=============================================]
[section:chrono_chrono_hpp Header `<boost/chrono/chrono.hpp>`]
[/=============================================]

    // configuration macros
    #define __BOOST_CHRONO_USES_STATIC_ASSERT
    #define __BOOST_CHRONO_USES_MPL_ASSERT
    #define __BOOST_CHRONO_USES_ARRAY_ASSERT
    
    // preprocessor info
    #define __BOOST_CHRONO_HAS_CLOCK_MONOTONIC

    namespace boost {
      namespace chrono {

        template <class Rep, class Period = __ratio__<1> >  class __duration__;
        template <class Clock, class Duration = typename Clock::duration> class __time_point__;

      }
      template <class Rep1, class Period1, class Rep2, class Period2>
      struct __common_type_spe__<__duration__<Rep1, Period1>,
                         __duration__<Rep2, Period2> >;

      template <class Clock, class Duration1, class Duration2>
      struct __common_type_spe__<__time_point__<Clock, Duration1>,
                         __time_point__<Clock, Duration2> >;

      namespace chrono {

        // customization traits
        template <class Rep> struct __treat_as_floating_point__;
        template <class Rep> struct __duration_values__;

        // duration arithmetic
        template <class Rep1, class Period1, class Rep2, class Period2>
        typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
        operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
        operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period, class Rep2>
        duration<typename common_type<Rep1, Rep2>::type, Period>
        operator*(const duration<Rep1, Period>& d, const Rep2& s);

        template <class Rep1, class Period, class Rep2>
        duration<typename common_type<Rep1, Rep2>::type, Period>
        operator*(const Rep1& s, const duration<Rep2, Period>& d);

        template <class Rep1, class Period, class Rep2>
        duration<typename common_type<Rep1, Rep2>::type, Period>
        operator/(const duration<Rep1, Period>& d, const Rep2& s);

        template <class Rep1, class Period1, class Rep2, class Period2>
        typename common_type<Rep1, Rep2>::type
        operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Rep2, class Period>
        double operator/(const Rep1& s, const duration<Rep2, Period>& d);

        // duration comparisons
        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        // duration_cast

        template <class ToDuration, class Rep, class Period>
        ToDuration __duration_cast__(const __duration__<Rep, Period>& d);

        // convenience typedefs
        typedef duration<boost::int_least64_t, nano> __nanoseconds__;    // at least 64 bits needed
        typedef duration<boost::int_least64_t, micro> __microseconds__;  // at least 55 bits needed
        typedef duration<boost::int_least64_t, milli> __milliseconds__;  // at least 45 bits needed
        typedef duration<boost::int_least64_t> __seconds__;              // at least 35 bits needed
        typedef duration<boost::int_least32_t, ratio< 60> > __minutes__; // at least 29 bits needed
        typedef duration<boost::int_least32_t, ratio<3600> > __hours__;  // at least 23 bits needed

        // time_point arithmetic
        template <class Clock, class Duration1, class Rep2, class Period2>
        time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2> >::type>
        operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Clock, class Duration2>
        time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
        operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);

        template <class Clock, class Duration1, class Rep2, class Period2>
        time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2> >::type>
        operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Clock, class Duration1, class Duration2>
        typename common_type<Duration1, Duration2>::type
        operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                Duration2>& rhs);

        // time_point comparisons
        template <class Clock, class Duration1, class Duration2>
        bool operator==(const time_point<Clock, Duration1>& lhs, 
                        const time_point<Clock, Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator!=(const time_point<Clock, Duration1>& lhs, 
                        const time_point<Clock, Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator< (const time_point<Clock, Duration1>& lhs, 
                        const time_point<Clock, Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator<=(const time_point<Clock, Duration1>& lhs, 
                        const time_point<Clock, Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator> (const time_point<Clock, Duration1>& lhs, 
                        const time_point<Clock, Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator>=(const time_point<Clock, Duration1>& lhs, 
                        const time_point<Clock, Duration2>& rhs);

        // time_point_cast
        template <class ToDuration, class Clock, class Duration>
        time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);

        // Clocks
        class __system_clock__;
        class __monotonic_clock__;
        class __high_resolution_clock__;

      }
    }


[section:conf Configuration macros]


When BOOST_NO_STATIC_ASSERT is defined, the user can select the way static assertions are reported. Define

* BOOST_CHRONO_USES_STATIC_ASSERT: define it if you want to use Boost.StaticAssert
* BOOST_CHRONO_USES_MPL_ASSERT: define it if you want to use Boost.MPL static asertions
* BOOST_CHRONO_USES_ARRAY_ASSERT: define it if you want to use internal static asertions
* nothing if you don't want static asertions

When BOOST_CHRONO_USES_MPL_ASSERT is not defined the following symbols are defined as

    #define BOOST_CHRONO_A_DURATION_REPRESENTATION_CAN_NOT_BE_A_DURATION \
        "A duration representation can not be a duration"
    #define BOOST_CHRONO_SECOND_TEMPLATE_PARAMETER_OF_DURATION_MUST_BE_A_STD_RATIO \
        "Second template parameter of duration must be a std::ratio"
    #define BOOST_CHRONO_DURATION_PERIOD_MUST_BE_POSITIVE \
        "duration period must be positive"
    #define BOOST_CHRONO_SECOND_TEMPLATE_PARAMETER_OF_TIME_POINT_MUST_BE_A_BOOST_CHRONO_DURATION \
        "Second template parameter of time_point must be a boost::chrono::duration"

Depending on the static assertion used system you will have an hint of the failing assertion either through the symbol or through the texte.

[endsect]

[section:clock `Clock` Requirements]

A clock represents a bundle consisting of a native __duration__, a native __time_point__, and a function `now()` to get the current __time_point__. A clock must meet the requirements in the following Table.

In this table `C1` and `C2` denote `clock` types. `t1` and `t2` are values returned from `C1::now()` where the call returning `t1` happens before the call returning `t2` and both of these calls happen before `C1::time_point::max()`.

[table Clock Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`C1::rep`]        [An arithmetic type or class emulating an arithmetic type. ]  [The representation type of the native __duration__ and __time_point__.]]
    [[`C1::period`]        [`ratio`]  [The tick period of the clock in seconds.]]
    [[`C1::duration`]        [`chrono::duration<C1::rep, C1::period>`]  [The native __duration__ type of the `clock`.]]
    [[`C1::time_point`]        [`chrono::time_point<C1> or chrono::time_point<C2, C1::duration>`]  [The native __time_point__ type of the `clock`. Different clocks are permitted to share a __time_point__ definition if it is valid to compare their time_points by comparing their respective __duration_s__. `C1` and `C2` must refer to the same epoch.]]
    [[`C1::is_monotonic`]        [`const bool`]  [`true` if `t1 <= t2` is always `true`, else `false`. *Note*: A `clock` that can be adjusted backwards is not monotonic]]
    [[`C1::now()`]        [`C1::time_point`]  [Returns a __time_point__ representing the current point in time.]]
]


Models of Clock:

* __system_clock__
* __monotonic_clock__
* __high_resolution_clock__
* __process_real_cpu_clock__
* __process_user_cpu_clock__
* __process_system_cpu_clock__
* __thread_clock__

[endsect]

[section:traits Time-related traits]
[section:treat_as_floating_point Metafunction `treat_as_floating_point<>`]

    template <class Rep> struct treat_as_floating_point
        : boost::is_floating_point<Rep> {};

The __duration__ template uses the __treat_as_floating_point__ trait to help determine if a __duration__ with one tick period can be converted to another __duration__ with a different tick period. If `treat_as_floating_point<Rep>::value` is `true`, then `Rep` is a floating point type and implicit conversions are allowed among __duration_s__. Otherwise, the implicit convertibility depends on the tick periods of the __duration_s__. If `Rep` is a class type which emulates a floating point type, the author of `Rep` can specialize __treat_as_floating_point__ so that __duration__ will treat this `Rep` as if it were a floating point type. Otherwise `Rep` is assumed to be an integral type, or a class emulating an integral type.


[endsect]
[section:duration_values Class template `duration_values`]

    template <class Rep>
    struct duration_values
    {
    public:
        static BOOST_CHRONO_CONSTEXPR  Rep __zero__();
        static BOOST_CHRONO_CONSTEXPR  Rep __max__();
        static BOOST_CHRONO_CONSTEXPR  Rep __min__();
    };

The __duration__ template uses the __duration_values__ trait to construct special values of the __duration_s__ representation (`Rep`). This is done because the representation might be a class type with behavior which requires some other implementation to return these special values. In that case, the author of that class type should specialize __duration_values__ to return the indicated values.

[section:zero Static member Function `zero()`]

    static BOOST_CHRONO_CONSTEXPR Rep zero();

[*Returns:] `Rep(0)`. [*Note:] `Rep(0)` is specified instead of `Rep()` since `Rep()` may have some other meaning, such as an uninitialized value.

[*Remarks:] The value returned corresponds to the additive identity.

[endsect]
[section:max Static member function `max()`]

    static BOOST_CHRONO_CONSTEXPR Rep max();

[*Returns:] `numeric_limits<Rep>::max()`.

[*Remarks:] The value returned compares greater than zero().

[endsect]
[section:min Static member function `min()`]

    static BOOST_CHRONO_CONSTEXPR Rep min();

[*Returns:] `numeric_limits<Rep>::lowest()`.

[*Remarks:] The value returned compares less than or equal to `zero()`.

[endsect]

[endsect]

[endsect]

[section:common_type_spe `common_type` specializations]

    template <class Rep1, class Period1, class Rep2, class Period2>
    struct __common_type__<chrono::__duration__<Rep1, Period1>, chrono::__duration__<Rep2, Period2> >
    {
        typedef chrono::__duration__<typename __common_type__<Rep1, Rep2>::type, see below> type;
    };

The period of the __duration__ indicated by this specialization of __common_type__ is the greatest common divisor of `Period1` and `Period2`. This can be computed by forming a __ratio__ of the greatest common divisor of `Period1::num` and `Period2::num`, and the least common multiple of `Period1::den` and `Period2::den`.

[*Note:] The typedef type is the __duration__ with the largest tick period possible where both __duration__ arguments will convert to it without requiring a division operation. The representation of this type is intended to be able to hold any value resulting from this conversion, with the possible exception of round-off error when floating point __duration_s__ are involved (but not truncation error).

    template <class Clock, class Duration1, class Duration2>
    struct __common_type__<chrono::__time_point__<Clock, Duration1>, chrono::__time_point__<Clock, Duration2> >
    {
        typedef chrono::__time_point__<Clock, typename __common_type__<Duration1, Duration2>::type> type;
    };

The __common_type__ of two __time_point_s__ is a __time_point__ with the same `clock` (both have the same `clock`), and the __common_type__ of the two __duration_s__.

[endsect]


[section:duration Class template `duration<>`]

A __duration__ measures time between two points in time (__time_point__). A __duration__ has a representation which holds a count of ticks, and a tick period. The tick period is the amount of time which occurs from one tick to another in units of a second. It is expressed as a rational constant using __ratio__.

    namespace boost { namespace chrono {

        template <class Rep, class Period>
        class duration {
        public:
            typedef Rep rep;
            typedef Period period;
        private:
            rep rep_; // exposition only
        public:
            BOOST_CHRONO_CONSTEXPR duration() {} // = default;
            template <class Rep2>
            BOOST_CHRONO_CONSTEXPR explicit duration(const Rep2& r);

            template <class Rep2, class Period2>
            BOOST_CHRONO_CONSTEXPR duration(const duration<Rep2, Period2>& d);

            //~duration() = default;
            //duration(const duration&) = default;
            //duration& operator=(const duration&) = default;

            BOOST_CHRONO_CONSTEXPR rep count() const;

            BOOST_CHRONO_CONSTEXPR duration  operator+();
            BOOST_CHRONO_CONSTEXPR duration  operator-();
            duration& operator++();
            duration  operator++(int);
            duration& operator--();
            duration  operator--(int);

            duration& operator+=(const duration& d);
            duration& operator-=(const duration& d);

            duration& operator*=(const rep& rhs);
            duration& operator/=(const rep& rhs);
            duration& operator%=(const rep& rhs);
            duration& operator%=(const duration& rhs);

            static BOOST_CHRONO_CONSTEXPR duration zero();
            static BOOST_CHRONO_CONSTEXPR duration min();
            static BOOST_CHRONO_CONSTEXPR duration max();
        };

    }}

`Rep` must be an arithmetic type, or a class emulating an arithmetic type, compile diagnostic otherwise. If __duration__ is instantiated with the type of `Rep` being a __duration__, compile diagnostic is issued.

`Period` must be an instantiation of `ratio`, compile diagnostic otherwise.

`Period::num` must be positive, compile diagnostic otherwise.

Examples:

* `__duration__<long, __ratio__<60> >` holds a count of minutes using a long.

* `__duration__<long long, milli>` holds a count of milliseconds using a long long.

* `__duration__<double, __ratio__<1, 30> >` holds a count using a double with a tick period of 1/30 second (a tick frequency of 30 Hz).

The following members of __duration__ do not throw an exception unless the indicated operations on the representations throw an exception.

[section:duration_c_1 Constructor `duration(const Rep2&)`]

    template <class Rep2>
    BOOST_CHRONO_CONSTEXPR explicit duration(const Rep2& r);

[*Remarks:] `Rep2` is implicitly convertible to `rep`, and

* `treat_as_floating_point<rep>::value` is `true`, or
* `!treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value` is `true`.

If these constraints are not met, this constructor will not participate in overload resolution. [*Note:] This requirement prevents construction of an integral-based __duration__ with a floating point representation. Such a construction could easily lead to confusion about the value of the __duration__.

[*Example:]

        __duration__<int, milli> d(3.5);  // do not compile
        __duration__<int, milli> d(3);    // ok

[*Effects:] Constructs an object of type __duration__.

[*PostConditions:] `count() == static_cast<rep>(r)`.

[endsect]
[section:duration_c_2 Constructor `duration(const duration&)`]

    template <class Rep2, class Period2>
    BOOST_CHRONO_CONSTEXPR __duration__(const __duration__<Rep2, Period2>& d);

[*Remarks:] `treat_as_floating_point<rep>::value`, or `ratio_divide<Period2, period>::type::den == 1`, else this constructor will not participate in overload resolution. [*note] This requirement prevents implicit truncation error when converting between integral-based __duration_s__. Such a construction could easily lead to confusion about the value of the __duration__.

[*Example:]

        __duration__<int, milli> ms(3);
        __duration__<int, micro> us = ms;  // ok
        __duration__<int, milli> ms2 = us; // do not compile

[*Effects:] Constructs an object of type __duration__, constructing `rep_` from `duration_cast<__duration__>(d).count()`.

[endsect]
[section:count Member function `count() const`]

    BOOST_CHRONO_CONSTEXPR rep count() const;

[*Returns:] `rep_v.

[endsect]
[section:duration_operator_p Member function `operator+() const`]

    BOOST_CHRONO_CONSTEXPR __duration__ operator+() const;

[*Returns:] `*this`.

[endsect]
[section:duration_operator_m Member function `operator+() const`]

    BOOST_CHRONO_CONSTEXPR __duration__ operator-() const;

[*Returns:] `__duration__(-rep_)`.

[endsect]
[section:duration_operator_pp Member function `operator++()`]

    __duration__& operator++();

[*Effects:] `++rep_`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_pp2 Member function `operator++(int)`]

    __duration__ operator++(int);

[*Returns:] `__duration__(rep_++)v.

[endsect]
[section:duration_operator_mm Member function `operator++()`]

    __duration__& operator--();

[*Effects:] `--rep_`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_mm2 Member function `operator++(int)`]

    __duration__ operator--(int);

[*Returns:] `__duration__(rep_--)`.

[endsect]
[section:duration_operator_pa Member function `operator+=(const duration&)`]

    __duration__& operator+=(const __duration__& d);

[*Effects:] `rep_ += d.count()`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_ma Member function `operator-=(const duration&)`]

    __duration__& operator-=(const __duration__& d);

[*Effects:] `rep_ -= d.count()`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_moda Member function `operator%=(const duration&)`]

    __duration__& operator%=(const __duration__& d);

[*Effects:] `rep_ %= d.count()`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_proda Member function `operator*=(const rep&)`]

    __duration__& operator*=(const rep& rhs);

[*Effects:] `rep_ *= rhs`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_da Member function `operator/=(const rep&)`]

    __duration__& operator/=(const rep& rhs);

[*Effects:] `rep_ /= rhs`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_moda_2 Member function `operator%=(const rep&)`]

    __duration__& operator%=(const rep& rhs);

[*Effects:] `rep_ %= rhs`.

[*Returns:] `*this`.

[endsect]


[section:duration_zero Static Member function `zero()`]

    static __duration__ zero();

[*Returns:] `__duration__(__duration_values__<rep>::zero())`.

[endsect]
[section:duration_min Static Member function `min()`]

    static __duration__ min();

[*Returns:] `__duration__(__duration_values__<rep>::min()).`

[endsect]
[section:duration_max Static Member function `max()`]

    static constexpr __duration__ max();

[*Returns:] `__duration__(__duration_values__<rep>::max())`.

[endsect]

[endsect]


[section `duration` non-member arithmetic]

[section:duration_operator_p_1 Non-Member function `operator+(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    typename __common_type__<__duration__<Rep1, Period1>, __duration__<Rep2, Period2> >::type
    operator+(const __duration__<Rep1, Period1>& lhs, const __duration__<Rep2, Period2>& rhs);

[*Returns:] `CD(lhs) += rhs` where `CD` is the type of the return value.

[endsect]
[section:duration_operator_m_1 Non-Member function `operator-(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    typename __common_type__<__duration__<Rep1, Period1>, __duration__<Rep2, Period2> >::type
    operator-(const __duration__<Rep1, Period1>& lhs, const __duration__<Rep2, Period2>& rhs);

[*Returns:] `CD(lhs) -= rhs` where `CD` is the type of the return value.

    template <class Rep1, class Period, class Rep2>
    __duration__<typename __common_type__<Rep1, Rep2>::type, Period>
    operator*(const __duration__<Rep1, Period>& d, const Rep2& s);

[*Requires:] Let `CR` represent the __common_type__ of `Rep1` and `Rep2`. This function will not participate in overload resolution unless both `Rep1` and `Rep2` are implicitly convertible to `CR`.

[*Returns:] `__duration__<CR, Period>(d) *= s`.

[endsect]
[section:duration_operator_prod_1 Non-Member function `operator*(Rep1,duration)`]

    template <class Rep1, class Period, class Rep2>
    __duration__<typename __common_type__<Rep1, Rep2>::type, Period>
    operator*(const Rep1& s, const __duration__<Rep2, Period>& d);

[*Requires:] Let `CR` represent the __common_type__ of `Rep1` and `Rep2`. This function will not participate in overload resolution unless both `Rep1` and `Rep2` are implicitly convertible to `CR`.

[*Returns:] `d * s`.

[endsect]
[section:duration_operator_d_1 Non-Member function `operator/(duration,Rep2)`]

    template <class Rep1, class Period, class Rep2>
    __duration__<typename __common_type__<Rep1, Rep2>::type, Period>
    operator/(const __duration__<Rep1, Period>& d, const Rep2& s);

[*Requires:] Let `CR` represent the __common_type__ of `Rep1` and `Rep2`. This function will not participate in overload resolution unless both `Rep1` and `Rep2` are implicitly convertible to `CR`, and `Rep2` is  not an instantiation of __duration__.

[*Returns:] `__duration__<CR, Period>(d) /= s`.

[endsect]
[section:duration_operator_d_2 Non-Member function `operator/(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    typename __common_type__<Rep1, Rep2>::type
    operator/(const __duration__<Rep1, Period1>& lhs, const __duration__<Rep2, Period2>& rhs);

[*Returns:] Let `CD` represent the __common_type__ of the two __duration__ arguments. Returns `CD(lhs).count() / CD(rhs).count()`.

[endsect]

[section:duration_operator_d_3 Non-Member function `operator/(Rep1,duration)`]

    template <class Rep1, class Rep2, class Period>
    double operator/(const Rep1& s, const __duration__<Rep2, Period>& d);

[*Remarks:] Let `CR` represent the __common_type__ of `Rep1` and `Rep2`. This function will not participate in overload resolution unless both `Rep1` and `Rep2` are implicitly convertible to `CR`, and `Rep1` is  not an instantiation of __duration__.

[*Returns:] `CR(s)/__duration__<CR, Period>(d)`.

[endsect]


[section:duration_operator_mod_1 Non-Member function `operator%(duration,Rep2)`]

  template <class Rep1, class Period, class Rep2>
  __duration__<typename __common_type__<Rep1, Rep2>::type, Period>
  operator%(const __duration__<Rep1, Period>& d, const Rep2& s);

[*Remarks] This function will not participate in overload resolution unless Rep2 must be implicitly convertible to CR(Rep1, Rep2) and Rep2 must not be an instantiation of __duration__.

[*Returns:] __duration__<CR(Rep1,Rep2), Period>(d) %= s.
[endsect]

[section:duration_operator_mod_2 Non-Member function `operator%(duration,duration)`]

  template <class Rep1, class Period1, class Rep2, class Period2>
  typename __common_type__<__duration__<Rep1, Period1>, __duration__<Rep2, Period2> >::type
  operator%(const __duration__<Rep1, Period1>& lhs, 
            const __duration__<Rep2, Period2>& rhs);

[*Remarks] This function will not participate in overload resolution unless

[*Returns:] CD(lhs) %= CD(rhs)

[endsect]
[endsect]

[section `duration` Non-Member comparaisons]

[section:duration_operator_eq_1 Non-Member function `operator==(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator==(const __duration__<Rep1, Period1>& lhs, 
                    const __duration__<Rep2, Period2>& rhs);

[*Returns:] Let `CD` represent the __common_type__ of the two __duration__ arguments. Returns `CD(lhs).count() == CD(rhs).count()`

[endsect]
[section:duration_operator_neq_1 Non-Member function `operator!=(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator!=(const __duration__<Rep1, Period1>& lhs, 
                    const __duration__<Rep2, Period2>& rhs);

[*Returns:] `!(lhs == rhs)`.

[endsect]
[section:duration_operator_lt_1 Non-Member function `operator<(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator< (const __duration__<Rep1, Period1>& lhs, 
                    const __duration__<Rep2, Period2>& rhs);

[*Returns:] Let `CD` represent the __common_type__ of the two __duration__ arguments. Returns `CD(lhs).count() < CD(rhs).count()`

[endsect]
[section:duration_operator_leq_1 Non-Member function `operator<=(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator<=(const __duration__<Rep1, Period1>& lhs, 
                    const __duration__<Rep2, Period2>& rhs);

[*Returns:] `!(rhs < lhs)`.

[endsect]
[section:duration_operator_gt_1 Non-Member function `operator>(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator> (const __duration__<Rep1, Period1>& lhs, 
                    const __duration__<Rep2, Period2>& rhs);

[*Returns:] `rhs < lhs`.

[endsect]
[section:duration_operator_gteq_1 Non-Member function `operator>=(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator>=(const __duration__<Rep1, Period1>& lhs, 
                    const __duration__<Rep2, Period2>& rhs);

[*Returns:] `!(lhs < rhs)`.

[endsect]
[endsect]
[section:duration_cast Non-Member function `duration_cast(duration)`]

    template <class ToDuration, class Rep, class Period>
    ToDuration duration_cast(const __duration__<Rep, Period>& d);

[*Requires:] This function will not participate in overload resolution unless `ToDuration` is an instantiation of __duration__.

[*Returns:] Forms `CF` which is a __ratio__ resulting from `ratio_divide<Period, typename ToDuration::period>::type`. Let `CR` be the __common_type__ of `ToDuration::rep`, `Rep`, and `intmax_t`.

* If `CF::num == 1` and `CF::den == 1`, then returns `ToDuration(static_cast<typename ToDuration::rep>(d.count())) `
* else if `CF::num != 1` and `CF::den == 1`, then returns
              `ToDuration(static_cast<typename ToDuration::rep>(static_cast<CR>(d.count()) *
                                                               static_cast<CR>(CF::num)))`
* else if `CF::num == 1` and `CF::den != 1`, then returns
              `ToDuration(static_cast<typename ToDuration::rep>(static_cast<CR>(d.count()) /
                                                               static_cast<CR>(CF::den)))`
* else returns
              `ToDuration(static_cast<typename ToDuration::rep>(static_cast<CR>(d.count()) *
                                                               static_cast<CR>(CF::num)   /
                                                               static_cast<CR>(CF::den)))`

[*Remarks:] This function does not rely on any implicit conversions. All conversions must be accomplished through `static_cast`. The implementation avoids all multiplications or divisions when it is known at compile time that it can be avoided because one or more arguments are `1`. All intermediate computations are carried out in the widest possible representation and only converted to the destination representation at the final step.


[endsect]



[section:time_point Class template `time_point<>`]

A __time_point__ represents a point in time with respect to a specific clock.

    template <class Clock, class Duration>
    class time_point {
    public:
        typedef Clock                     clock;
        typedef Duration                  duration;
        typedef typename duration::rep    rep;
        typedef typename duration::period period;
    private:
        duration d_; // exposition only
    public:
        time_point();
        explicit time_point(const duration& d);

        // conversions
        template <class Duration2>
        time_point(const time_point<clock, Duration2>& t);

        // observer

        duration time_since_epoch() const;

        // arithmetic

        time_point& operator+=(const duration& d);
        time_point& operator-=(const duration& d);

        // special values

        static BOOST_CHRONO_CONSTEXPR time_point min();
        static BOOST_CHRONO_CONSTEXPR time_point max();
    };

Clock must meet the __clock_req__.

Duration must be an instantiation of __duration__, compile diagnostic otherwise.

[section:time_point_c_1 Constructor `time_point()`]

    time_point();

[*Effects:] Constructs an object of __time_point__, initializing `d_` with `duration::zero()`. This __time_point__ represents the epoch.

[endsect]
[section:time_point_c_2 Constructor `time_point(const duration&)`]

    time_point(const duration& d);

[*Effects:] Constructs an object of __time_point__, initializing `d_` with `d`. This __time_point__ represents the epoch `+ d`.

[endsect]
[section:time_point_c_3 Constructor `time_point(const duration&)`]

    template <class Duration2> time_point(const __time_point__<clock, Duration2>& t);

[*Requires:] This function will not participate in overload resolution unless `Duration2` is implicitly convertible to __duration__.

[*Effects:] Constructs an object of __time_point__, initializing `d_` with `t.time_since_epoch()`.

[endsect]

[section:time_since_epoch Member function `time_since_epoch() const`]

    duration time_since_epoch() const;

[*Returns:] `d_`.

[endsect]
[section:time_point_operator_pe Member function `operator+=`]

    time_point& operator+=(const duration& d);

[*Effects:] `d_ += d`.

[*Returns:] `*this`.

[endsect]
[section:time_point_operator_me Member function `operator-=`]

    time_point& operator-=(const duration& d);

[*Effects:] `d_ -= d`

[*Returns:] `*this`.

[endsect]
[section:time_point_min Static Member function `min`]

    static BOOST_CHRONO_CONSTEXPR time_point min();

[*Returns:] `time_point(duration::min())`.

[endsect]
[section:time_point_max Static Member function `max`]

    static BOOST_CHRONO_CONSTEXPR time_point max();

[*Returns:] `time_point(duration::max())`.

[endsect]
[endsect]


[section `time_point` non-member arithmetic]


[section:time_point_operator_p_1 Non-Member function `operator+(time_point,duration)`]

    template <class Clock, class Duration1, class Rep2, class Period2>
    __time_point__<Clock, typename __common_type__<Duration1, duration<Rep2, Period2> >::type>
    operator+(const __time_point__<Clock, Duration1>& lhs, 
              const duration<Rep2, Period2>& rhs);

[*Returns:] `CT(lhs) += rhs` where `CT` is the type of the return value.

[endsect]
[section:time_point_operator_p_2 Non-Member function `operator+(duration,time_point)`]

    template <class Rep1, class Period1, class Clock, class Duration2>
    __time_point__<Clock, typename __common_type__<duration<Rep1, Period1>, Duration2>::type>
    operator+(const duration<Rep1, Period1>& lhs, 
              const __time_point__<Clock, Duration2>& rhs);

[*Returns:] `rhs + lhs`.

[endsect]
[section:time_point_operator_m_1 Non-Member function `operator-(time_point,duration)`]

    template <class Clock, class Duration1, class Rep2, class Period2>
    __time_point__<Clock, typename __common_type__<Duration1, duration<Rep2, Period2> >::type>
    operator-(const __time_point__<Clock, Duration1>& lhs, 
              const duration<Rep2, Period2>& rhs);

[*Returns:] `lhs + (-rhs)`.

[endsect]
[section:time_point_operator_m_2 Non-Member function `operator-(duration,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    typename __common_type__<Duration1, Duration2>::type
    operator-(const __time_point__<Clock, Duration1>& lhs, 
              const __time_point__<Clock, Duration2>& rhs);

[*Returns:] `lhs.time_since_epoch() - rhs.time_since_epoch()`.

[endsect]
[endsect]

[section `time_point` non-member comparisons]
[section:time_point_operator_eq Non-Member function `operator==(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator==(const __time_point__<Clock, Duration1>& lhs, 
                    const __time_point__<Clock, Duration2>& rhs);

[*Returns:] `lhs.time_since_epoch() == rhs.time_since_epoch()`.

[endsect]
[section:time_point_operator_neq Non-Member function `operator!=(time_point,time_point)`]

template <class Clock, class Duration1, class Duration2>
   bool operator!=(const __time_point__<Clock, Duration1>& lhs, 
                   const __time_point__<Clock, Duration2>& rhs);

[*Returns:] `!(lhs == rhs)`.

[endsect]
[section:time_point_operator_lt Non-Member function `operator<(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator< (const __time_point__<Clock, Duration1>& lhs, 
                    const __time_point__<Clock, Duration2>& rhs);

[*Returns:] lhs.time_since_epoch() < rhs.time_since_epoch().

[endsect]
[section:time_point_operator_leq Non-Member function `operator<=(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator<=(const __time_point__<Clock, Duration1>& lhs, 
                    const __time_point__<Clock, Duration2>& rhs);

[*Returns:] `!(rhs < lhs)`.

[endsect]
[section:time_point_operator_gt Non-Member function `operator>(time_point,time_point)`]

template <class Clock, class Duration1, class Duration2>
   bool operator>(const __time_point__<Clock, Duration1>& lhs, 
                  const __time_point__<Clock, Duration2>& rhs);

[*Returns:] `rhs < lhs`.

[endsect]
[section:time_point_operator_geq Non-Member function `operator>=(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator>=(const __time_point__<Clock, Duration1>& lhs, 
                    const __time_point__<Clock, Duration2>& rhs);

[*Returns:] `!(lhs < rhs)`.

[endsect]
[endsect]

[section:time_point_cast Non-Member function `time_point_cast(time_point)`]

    template <class ToDuration, class Clock, class Duration>
    __time_point__<Clock, ToDuration> time_point_cast(const __time_point__<Clock, Duration>& t);

[*Requires:] This function will not participate in overload resolution unless `ToDuration` is an instantiation of __duration__.

[*Returns:] `__time_point__<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch()))`.

[endsect]

[section:duration_typedefs `duration` typedefs]

        // convenience typedefs
        typedef __duration__<boost::int_least64_t, nano> nanoseconds;    // at least 64 bits needed
        typedef __duration__<boost::int_least64_t, micro> microseconds;  // at least 55 bits needed
        typedef __duration__<boost::int_least64_t, milli> milliseconds;  // at least 45 bits needed
        typedef __duration__<boost::int_least64_t> seconds;              // at least 35 bits needed
        typedef __duration__<boost::int_least32_t, __ratio__< 60> > minutes; // at least 29 bits needed
        typedef __duration__<boost::int_least32_t, __ratio__<3600> > hours;  // at least 23 bits needed


[endsect]

[section:system_clock Class `system_clock`]

The `system_clock` class provides a means of obtaining the current wall-clock time from the system-wide real-time clock. The current time can be obtained by calling `system_clock::now()`. Instances of `system_clock::time_point`  can be converted to and from time_t  with the `system_clock::to_time_t()`  and `system_clock::to_time_point()`  functions. If system clock is not monotonic, a subsequent call to `system_clock::now()`  may return an earlier time than a previous call (e.g. if the operating system clock is manually adjusted, or synchronized with an external clock).

    class system_clock {
    public:
        typedef BOOST_SYSTEM_CLOCK_DURATION          duration;
        typedef duration::rep                        rep;
        typedef duration::period                     period;
        typedef chrono::time_point<system_clock>     time_point;
        static const bool is_monotonic =             false;

        static time_point  now();                         // throws on error
        static time_point  now(system::error_code & ec);  // never throws

        static std::time_t to_time_t(const time_point& t);
        static time_point  from_time_t(std::time_t t);
    };

`system_clock` satisfy the __clock_req__:

* `system_clock::duration::min() < system_clock::duration::zero()` is `true`.


[section:to_time_t Static member function `to_time_t(time_point)`]

time_t to_time_t(const time_point& t);

[*Returns:] A `time_t` such that the `time_t` and `t` represent the same point in time, truncated to the courser of the precisions among `time_t` and `t`.

[endsect]
[section:from_time_t Static member function `from_time_t(time_t)`]

    time_point from_time_t(time_t t);

[*Returns:] A __time_point__ such that the __time_point__ and `t` represent the same point in time, truncated to the courser of the precisions among __time_point__ and `t`.

[endsect]
[endsect]

[section:BOOST_CHRONO_HAS_CLOCK_MONOTONIC Macro `BOOST_CHRONO_HAS_CLOCK_MONOTONIC`]

Defined if the platform support monotonic clocks.

[endsect]

[section:monotonic_clock Class `monotonic_clock`]

__monotonic_clock__ satisfy the __clock_req__.

__monotonic_clock__ class provides access to the system-wide monotonic clock. The current time can be obtained by calling `monotonic_clock::now()`. There is no fixed relationship between values returned by `monotonic_clock::now()`  and wall-clock time.

    #ifdef BOOST_HAS_CLOCK_MONOTONIC
        class BOOST_CHRONO_DECL monotonic_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<monotonic_clock>  time_point;
            static const bool is_monotonic =             true;

            static time_point  now();                         // throws on error
            static time_point  now(system::error_code & ec);  // never throws
        };
    #endif



[endsect]

[section:high_resolution_clock Class `high_resolution_clock`]

`high_resolution_clock` satisfy the __clock_req__.

    #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
      typedef monotonic_clock high_resolution_clock;  // as permitted by [time.clock.hires]
    #else
      typedef system_clock high_resolution_clock;  // as permitted by [time.clock.hires]
    #endif

[endsect]

[endsect]

[/=============================================]
[section:chrono_typeof_hpp Header `<boost/chrono/typeof/boost/chrono/chrono.hpp>`]
[/=============================================]

Register __duration__`<>` and __timepoint__`<>` class templates to Boost.Typeof.

[endsect]
[endsect]

[section:other_clocks Other clocks]

[/==================================================================]
[section:process_cpu_clocks_hpp Header `<boost/chrono/process_cpu_clocks.hpp>`]
[/==================================================================]

Knowing how long a program takes to execute is useful in both test and production environments. It is also helpful if such timing information is broken down into real (wall clock) time, CPU time spent by the user, and CPU time spent by the operating system servicing user requests.

    namespace boost { namespace chrono {

        class process_real_cpu_clock;
        class process_user_cpu_clock;
        class process_system_cpu_clock;
        class process_cpu_clock;

    } }

[section:process_real_cpu_clock Class `process_real_cpu_clock`]

__process_real_cpu_clock__ satisfy the __clock_req__.

__process_real_cpu_clock__ class provides access to the real process wall-clock monotonic clock, i.e. the real CPU-time clock of the calling process. The process relative current time can be obtained by calling `process_real_cpu_clock::now()`.

        class process_real_cpu_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<process_real_cpu_clock>    time_point;
            static const bool is_monotonic =             true;

            static time_point now( system::error_code & ec = system::throws );
        };


[endsect]
[section:process_user_cpu_clock Class `process_user_cpu_clock`]

__process_user_cpu_clock__ satisfy the __clock_req__.

__process_user_cpu_clock__ class provides access to the user CPU-time monotonic clock of the calling process. The process relative user current time can be obtained by calling `process_user_cpu_clock::now()`.

        class process_user_cpu_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<process_user_cpu_clock>    time_point;
            static const bool is_monotonic =             true;

            static time_point now( system::error_code & ec = system::throws );
        };


[endsect]

[section:process_system_cpu_clock Class `process_system_cpu_clock`]

__process_system_cpu_clock__ satisfy the __clock_req__.

__process_system_cpu_clock__ class provides access to the system CPU-time monotonic clockof the calling process. The process relative system current time can be obtained by calling `process_system_cpu_clock::now()`.

        class process_system_cpu_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<process_system_cpu_clock>    time_point;
            static const bool is_monotonic =             true;

            static time_point now( system::error_code & ec = system::throws );
        };


[endsect]

[section:process_cpu_clock Class `process_cpu_clock`]

`process_cpu_clock` can be considered as a `tuple<process_real_cpu_clock, process_user_cpu_clock, process_system_cpu_clock>`.

`process_cpu_clock` provides a thin wrapper around the operating system's process time API. For POSIX-like systems, that's the times() function, while for Windows, it's the GetProcessTimes() function.

The process relative real, user and system current time can be obtained at once by calling `process_clocks::now()`.

    class BOOST_CHRONO_DECL process_cpu_clock
    {
    public:
        struct times ;

        typedef duration<times,  nano>                duration;
        typedef duration::rep                       rep;
        typedef duration::period                    period;
        typedef chrono::time_point<process_cpu_clock>  time_point;
        static const bool is_monotonic =           true;

        static time_point now( system::error_code & ec = system::throws );
    };

    template <>
    struct duration_values<process_cpu_clock::times>;


[section:times Class `times`]

This class is the representation of the process_cpu_clock::duration class. As such it needs to implements the arithmetic operators.

        struct times : arithmetic<times>, less_than_comparable<times>
        {
            process_real_cpu_clock::rep   real;    // real (i.e wall clock) time
            process_user_cpu_clock::rep   user;    // user cpu time
            process_system_cpu_clock::rep system;  // system cpu time

            times();
            times(
                process_real_cpu_clock::rep r,
                process_user_cpu_clock::rep   u,
                process_system_cpu_clock::rep s);

            bool operator==(times const& rhs);

            times operator+=(times const& rhs);
            times operator-=(times const& rhs);
            times operator*=(times const& rhs);
            times operator/=(times const& rhs);
            bool operator<(times const & rhs) const;
        };

[endsect]

[section `duration_values` specialization for `times`]

    template <>
    struct __duration_values__<process_cpu_clock::times>
    {
        static process_cpu_clock::times zero();
        static process_cpu_clock::times max();
        static process_cpu_clock::times min();
    };

The `times` specific functions `zero()`, `max()` and `min()` uses the relative functions on the representation of each component.

[endsect]

[endsect]

[endsect]

[/==================================================================]
[section:thread_clock_hpp Header `<boost/chrono/thread_clock.hpp>`]
[/==================================================================]

Knowing the time a thread takes to execute is useful in both test and production environments.

    #define BOOST_CHRONO_HAS_THREAD_CLOCK
    #define BOOST_CHRONO_THREAD_CLOCK_IS_MONOTONIC
    namespace boost { namespace chrono {

        class thread_clock;

    } }

[section:BOOST_CHRONO_HAS_THREAD_CLOCK Macro `BOOST_CHRONO_HAS_THREAD_CLOCK`]

This macro is defined if the platform supports thread clocks.

[endsect]

[section:BOOST_CHRONO_THREAD_CLOCK_IS_MONOTONIC Macro `BOOST_CHRONO_THREAD_CLOCK_IS_MONOTONIC`]

This macro is defined if the platform has a thread clockIts value is true if it is monotonic and false otherwise.

[endsect]

[section:thread_clock Class `thread_clock`]

__thread_clock__ satisfy the __clock_req__.

__thread_clock__ class provides access to the real thread wall-clock, i.e. the real CPU-time clock of the calling thread. The thread relative current time can be obtained by calling `thread_clock::now()`.

        class thread_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<thread_clock>    time_point;
            static const bool is_monotonic =             BOOST_CHRONO_THREAD_CLOCK_IS_MONOTONIC;

            static time_point now( system::error_code & ec = system::throws );
        };


[endsect]

[endsect]



[section:suspendible_clock_req `SuspendibleClock` Requirements]

A `SuspendibleClock` is a Clock that in addition supports `suspend`/`resume` operations.

A `SuspendibleClock` must meet the requirements in the following Table.

In this table `C`  denote `clock` types.

[table SuspendibleClock Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`C::suspend()`]   [`void`]  [Suspends the time counting of the clock C.]]
    [[`C::resume()`]   [`void`]  [Resumes the time counting of the clock C.]]
    [[`C::suspended()`]   [__duration__]  [Returns the delay(duration during which the clock has been suspended.]]
]

[section:SuspendibleClock_suspend Static Member Function `suspend()`]

    void suspend( system::error_code & ec = system::throws );

[*Effect:] Suspends the SuspendibleClock.

[*Throw:] Any exception the `Clock::now(ec)` function can throw. Otherwise `ec` is set with the correspoding error code set by `Clock::now(ec)`.

[endsect]
[section:SuspendibleClock_resume Static Member Function `resume()`]

    void resume( system::error_code & ec = system::throws );

[*Effect:] Resumes the `SuspendibleClock`.

[*Throw:] Any exception the `Clock::now(ec)` can throw. Otherwise `ec` is set with the correspoding error code set by `Clock::now(ec)`.

[endsect]

[section:SuspendibleClock_suspended Static Member Function `suspended()`]

    duration suspended( system::error_code & ec = system::throws );

[*Returns:] the cumalative elapsed duration during which the `SuspendibleClock` has been suspendeed.

[*Throw:] Any exception the Clock::now function can throw if `ec == system::throws`. Otherwise `ec` is set with the correspoding error code set by `Clock::now(ec)`.

[endsect]

Models of `SuspendibleClock`:

* __suspendible_clock__]


[endsect]

[/==================================================================]
[section:scoped_suspend_hpp Header `<boost/chrono/scoped_suspend.hpp>`]
[/==================================================================]

    namespace boost { namespace chrono {
        template <class Clock> struct is_suspendible;
        template <class Clock> class scoped_suspend;
    }}

[section:is_suspendible Meta Function Class `is_suspendible`]

    template <class Clock>
    struct is_suspendible : mpl:: false_ {};

[endsect]

[section:scoped_suspend Template Class `scoped_suspend`]

    template <class Clock>
    class scoped_suspend {
    public:
        scoped_suspend(system::error_code & ec = system::throws) {}
        ~scoped_suspend() {}
    private:
        scoped_suspend(); // = delete;
        scoped_suspend(const scoped_suspend&); // = delete;
        scoped_suspend& operator=(const scoped_suspend&); // = delete;
    };

[endsect]

[endsect]


[/==================================================================]
[section:suspendible_clock_hpp Header `<boost/chrono/suspendible_clock.hpp>`]
[/==================================================================]

    namespace boost { namespace chrono {

        template <class Clock>
        class suspendible_clock;

        template <class Clock>
        struct is_suspendible<suspendible_clock<Clock> > : mpl:: true_ {};

        template <class Clock>
        class scoped_suspend<suspendible_clock<Clock> >;

    }}

[section:suspendible_clock Template Class `suspendible_clock<>`]

Given a __Clock__, __suspendible_clock__ <__Clock__> is a model of __SuspendibleClock__.

    template < class Clock >
    class suspendible_clock {
    public:
        typedef typename Clock::duration                           duration;
        typedef typename Clock::rep                                       rep;
        typedef typename Clock::period                                    period;
        typedef chrono::__time_point__<suspendible_clock<Clock> >  time_point;
        static const bool is_monotonic =             true;

        static time_point now( system::error_code & ec = system::throws );

        static void suspend( system::error_code & ec = system::throws );
        static void resume( system::error_code & ec = system::throws );
        static duration suspended(system::error_code & ec = system::throws);
    };

[section `scoped_suspend` specialization for `suspendible_clock<>`]

        template <class Clock>
        class scoped_suspend<suspendible_clock<Clock> > {
        public:
            scoped_suspend(system::error_code & ec = system::throws);
            ~scoped_suspend();
        };

[endsect]

[endsect]

[endsect]

[endsect]


[/==================================================]
[section:stopwatches Stopwatches]
[/==================================================]
[/=============================================]
[section:stopwatches_hpp Header `<boost/stopwatches.hpp>`]
[/=============================================]

This file include all the stopwatches related files

    #include <boost/chrono/stopwatches.hpp>

[endsect]

[/=============================================]
[section:chrono_stopwatches_hpp Header `<boost/chrono/stopwatches.hpp>`]
[/=============================================]

This file include all the stopwatches related files

    #include <boost/chrono/scoped_stopclock.hpp>
    #include <boost/chrono/process_cpu_clocks.hpp>
    #include <boost/chrono/stopclock.hpp>
    #include <boost/chrono/stopclock_accumulator.hpp>
    #include <boost/chrono/stopwatch.hpp>
    #include <boost/chrono/stopwatch_accumulator.hpp>
    #include <boost/chrono/stopwatch_accumulator_formatter.hpp>
    #include <boost/chrono/stopwatch_accumulator_time_formatter.hpp>
    #include <boost/chrono/stopwatch_formatter.hpp>
    #include <boost/chrono/stopwatch_reporter.hpp>
    #include <boost/chrono/stopwatch_scoped.hpp>
    #include <boost/chrono/time_formatter.hpp>
    #include <boost/chrono/t24_hours.hpp>
    #include <boost/chrono/t24_hours_formatter.hpp>

[endsect]

[section:stopwatch_req `Stopwatch` Requirements]

A Stopwatch measure the amount of time elapsed from a start point in time to the stop point time or the accumulation of them. Stopwatches can in addition be restarted, suspended and resumed.

A Stopwatch must meet the requirements in the following table. In this table `S`, `S1` and `S2` denote stopwatches types. `s` is an instance of `S`.

[table Stopwatch Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`S::clock`]        [A model of __Clock__.]  [The clock associated to this Stopwatch.]]
    [[`S::duration`]        [`S::clock::duration`]  [The __duration__ type of the `clock`.]]
    [[`S::time_point`]        [`S::clock::time_point`]  [The __time_point__ type of the `clock`.]]
    [[`S::scoped_run`]        [`stopwatch_runner<stopwatch<Clock> >`]  [RAI which `start`/`stop` the `stopwatch`.]]
    [[`S::scoped_suspend`]        [`stopwatch_suspender<stopwatch<Clock> >`]  [RAI which `suspend`/`resume` the `stopwatch`.]]
    [[`S::scoped_resume`]        [`stopwatch_resumer<stopwatch<Clock> >`]  [RAI which `resume`/`suspend` the `stopwatch`.]]
    [[`s.start()`]        [`S::time_point`]  [starts a Stopwatch.]]
    [[`s.restart()`]        [`std::pair<S::duration,S::time_point>`]  [restarts a Stopwatch.]]
    [[`s.stop()`]        [`S::duration`]  [stops a Stopwatch.]]
    [[`s.resume()`]        [`S::time_point`]  [resume a Stopwatch.]]
    [[`s.suspend()`]        [`S::duration`]  [suspends a Stopwatch.]]
    [[`s.elapsed()`]        [`S::duration`]  [the elapsed time while the Stopwatch was running.]]
]


[section:stopwatch_start Member Function `start()`]

    time_point start( system::error_code & ec = system::throws );

[*Effect:] Starts running the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]
[section:stopwatch_stop Member Function `stop()`]

    duration stop( system::error_code & ec = system::throws );

[*Effect:] Stops running the stopwatch.

[*Returns:] The cummulated elapsed time.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]
[section:stopwatch_suspend Member Function `suspend()`]

    duration suspend( system::error_code & ec = system::throws );

[*Effect:] Suspends the stopwatch.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]
[section:stopwatch_resume Member Function `resume()`]

    time_point resume( system::error_code & ec = system::throws );

[*Effect:] Resumes the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]

[section:stopwatch_restart Member Function `restart()`]

    time_point restart( system::error_code & ec = system::throws );

[*Effect:] `stop`/`start` the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]

Models of `Stopwatch`:

* __stopwatch__
* __stopwatch_accumulator__

[endsect]


[/==================================================]
[section:lightweight_stopwatch_hpp Header `<boost/chrono/lightweight_stopwatch.hpp>`]
[/==================================================]


    namespace boost { namespace chrono  {
        struct dont_start_t;
        static const dont_start_t dont_start;

        template <class Clock=high_resolution_clock,
                typename Features=void,
                typename Weight=void
        > class __lightweight_stopwatch__;

        typedef <see above> system_lightweight_stopwatch;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_lightweight_stopwatch;
        #endif
        typedef <see above> high_resolution_lightweight_stopwatch;
    }}

[section:dont_start_t Class `dont_start_t`]

Structure used to don't start a `lightweight_stopwatch` at construction time.

        struct dont_start_t;
        static const dont_start_t dont_start;

[endsect]

[section:lightweight_stopwatch Template Class `lightweight_stopwatch<>`]

`lightweight_stopwatch<>` is a model of a __lightweight_stopwatch_concept__.

Knowing how long a part of a program takes to execute is useful in both test and production environments.
A __lightweight_stopwatch__ object measures elapsed time. It is recommended to use it with clocks that measure wall clock rather than CPU time since the intended use is performance measurement on systems where total elapsed time is more important than just process or CPU time.

The maximum measurable elapsed time depends on the Clock parameter. The accuracy of timings depends on the
accuracy of timing information provided the Clock, and this coudl varies a great deal from one clock to another.

        template <class Clock, typename Features, typename Weight> 
        class lightweight_stopwatch {
        public:
            typedef Clock                       clock;
            typedef typename Clock::duration    duration;
            typedef typename Clock::time_point  time_point;
            typedef <see below>                 storage;

            explicit lightweight_stopwatch( storage& st, system::error_code & ec = system::throws );
            lightweight_stopwatch( storage& st, const dont_start_t& t );

            ~lightweight_stopwatch();

            time_point start( system::error_code & ec = system::throws );
            duration stop( system::error_code & ec = system::throws );
            std::pair<duration,time_point> restart( system::error_code & ec = system::throws );

            duration suspend( system::error_code & ec = system::throws );
            time_point resume( system::error_code & ec = system::throws );

            duration elapsed( system::error_code & ec = system::throws );

            time_point now( system::error_code & ec = system::throws );

            void reset( system::error_code & ec = system::throws );

            storage& get_storage( );

            duration lifetime( system::error_code & ec = system::throws );

            typedef lightweight_stopwatch_runner<lightweight_stopwatch<Clock> > scoped_run;
            typedef lightweight_stopwatch_suspender<lightweight_stopwatch<Clock> > scoped_suspend;
            typedef lightweight_stopwatch_resumer<lightweight_stopwatch<Clock> > scoped_resume;
            typedef lightweight_stopwatch_reporter<lightweight_stopwatch<Clock> > reporter;

        };


`storage` is either `Clock::duration` if Features and Weight are void and `accumulators::accumulator_set<typename Clock::duration::rep, Features, Weight>` otherwise.
    
[section:c1 Constructor `lightweight_stopwatch( storage&, system::error_code &)`]

            explicit lightweight_stopwatch( storage& st, system::error_code & ec = system::throws );

[*Effect:] constructs and starts the lightweight_stopwatch.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]

[section:c2 Constructor `lightweight_stopwatch( storage&, dont_start_t &)`]

            explicit lightweight_stopwatch( storage& st, const dont_start_t& t );

[*Effect:] constructs the lightweight_stopwatch without starting it.

[*Throw:] Nothing.

[endsect]


[section:lightweight_stopwatch_elapsed Member Function `elapsed()`]

            duration elapsed(system::error_code & ec = system::throws) const;

[*Returns:] the cumulated elapsed time.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]


[section:stopwatch_accumulator_accumulated Member Function `accumulated()`]

            storage& get_storage();

[*Returns:] the assocaited storage reference.

[*Throw:] Nothing.

[endsect]


[section:stopwatch_accumulator_reset Member Function `reset()`]

    void reset( );

[*Effect:] Stop the lightweight_stopwatch and reinit the storage.

[*Throw:] Nothing.

[endsect]

[endsect]

[endsect]


[/==================================================]
[section:stopwatch_hpp Header `<boost/chrono/stopwatch.hpp>`]
[/==================================================]


    namespace boost { namespace chrono  {
        template <class Clock=high_resolution_clock> class __stopwatch__;

        template <class Clock>
        struct stopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef stopwatch_formatter type;
        };

        template <class Clock>
        struct wstopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef wstopwatch_formatter type;
        };

        typedef <see above> system_stopwatch;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_stopwatch;
        #endif
        typedef <see above> high_resolution_stopwatch;
    }}


[section:stopwatch Template Class `stopwatch<>`]

`stopwatch<>` is a model of a __stopwatch_concept__.

Knowing how long a part of a program takes to execute is useful in both test and production environments.
A __stopwatch__ object measures elapsed time. It is recommended to use it with clocks that measure wall clock rather than CPU time since the intended use is performance measurement on systems where total elapsed time is more important than just process or CPU time.

The maximum measurable elapsed time depends on the Clock parameter. The accuracy of timings depends on the
accuracy of timing information provided the Clock, and this coudl varies a great deal from one clock to another.

    template <class Clock>
    class stopwatch : private base_from_member<typename Clock::duration>, public lightweight_stopwatch<Clock>
    {
    public:
        explicit stopwatch( system::error_code & ec = system::throws  );
        explicit stopwatch( const dont_start_t& t );
        
    };

[section:c1 Constructor `stopwatch( system::error_code &)`]

            explicit stopwatch( system::error_code & ec = system::throws );

[*Effect:] constructs and starts the stopwatch.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]

[section:c2 Constructor `stopwatch( dont_start_t &)`]

            explicit stopwatch( const dont_start_t& t );

[*Effect:] constructs the stopwatch without starting it.

[*Throw:] Nothing.

[endsect]

[endsect]

[section:spec `stopwatch_reporter_default_formatter` Specialization]

The `stopwatch_reporter_default_formatter` of a `stopwatch<Clock>` is a `stopwatch_formatter`.

        template <class Clock>
        struct stopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef stopwatch_formatter type;
        };

The `wstopwatch_reporter_default_formatter` of a `stopwatch<Clock>` is a `wstopwatch_formatter`.

        template <class Clock>
        struct wstopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef wstopwatch_formatter type;
        };

[endsect]

[section:stopwatch_typedefs `stopwatch` useful typedefs]

The library provides stopwatch short cuts for all the models of __Clock__, replacing clock by stopwatch.

        typedef boost::chrono::stopwatch< boost::chrono::system_clock > 
            system_stopwatch;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::stopwatch< boost::chrono::monotonic_clock > 
            monotonic_stopwatch;
        #endif
        typedef boost::chrono::stopwatch< boost::chrono::high_resolution_clock > 
            high_resolution_stopwatch;

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_accumulator_hpp Header `<boost/chrono/stopwatch_accumulator.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <class Clock, 
                    typename Features=accumulators::features<
                        accumulators::tag::count,
                        accumulators::tag::sum,
                        accumulators::tag::min,
                        accumulators::tag::max,
                        accumulators::tag::mean >,
                    typename Weight=void
        > class __stopwatch_accumulator__;

        template <class Clock, class Accumulator>
        struct stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef stopwatch_accumulator_formatter type;
        };

        template <class Clock, class Accumulator>
        struct wstopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef wstopwatch_accumulator_formatter type;
        };

        typedef <see below> system_stopwatch_accumulator;
    #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see below> monotonic_stopwatch_accumulator;
    #endif
        typedef <see below> high_resolution_stopwatch_accumulator;

    }}


[section:stopwatch_accumulator Template Class `stopwatch_accumulator<>`]

A `stopwatch_accumulator<>` is a model of a __stopwatch_concept__ that allows to accumulate the time in several times instead of at once as it is the case of the class __stopwatch__`<>`.

    template <class Clock, typename Features, typename Weight>
    class stopwatch_accumulator
        : private base_from_member<typename accumulators::accumulator_set<typename Clock::duration::rep, Features, Weight> >,
          public lightweight_stopwatch<Clock,Features,Weight> 
    {
    public:
        stopwatch_accumulator( );
    };

[section:stopwatch_accumulator_c Constructor `stopwatch_accumulator()`]

    stopwatch_accumulator();

[*Effect:] Initialize the elapsed duration and the times counter to 0.

[endsect]

[endsect]

[section:spec `stopwatch_reporter_default_formatter` Specialization]

The `stopwatch_reporter_default_formatter` of a `stopwatch_accumulator<Clock>` is a `stopwatch_accumulator_formatter`.

        template <class Clock, class Accumulator>
        struct stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef stopwatch_accumulator_formatter type;
        };

The `wstopwatch_reporter_default_formatter` of a `stopwatch_accumulator<Clock>` is a `wstopwatch_accumulator_formatter`.

        template <class Clock, class Accumulator>
        struct wstopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef wstopwatch_accumulator_formatter type;
        };

[endsect]


[section:stopwatch_accumulator_typedefs `stopwatch_accumulator` useful typedefs]

The library provides stopwatch_accumulator shortcuts for all the models of __Clock__, replacing clock by stopwatch_accumulator.

    typedef boost::chrono::stopwatch_accumulator< boost::chrono::system_clock > 
        system_stopwatch_accumulator;
    #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
    typedef boost::chrono::stopwatch_accumulator< boost::chrono::monotonic_clock > 
        monotonic_stopwatch_accumulator;
    #endif
    typedef boost::chrono::stopwatch_accumulator< boost::chrono::high_resolution_clock > 
        high_resolution_stopwatch_accumulator;

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_scoped_hpp Header `<boost/chrono/stopwatch_scoped.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <class Stopwatch> class stopwatch_runner;
        template <class Stopwatch> class stopwatch_suspender;
        template <class Stopwatch> class stopwatch_resumer;
    }}

Boost.Chrono provides some helper classes ensuring pairwised operations (start/stop, suspend/resume, resule/suspend).

[section:stopwatch_runner Template Class `stopwatch_runner<>`]

This helper class ensures that the start/stop are pairwised. Start the associated accumulator at construction time, and stop it at destruction time.

    template <class Stopwatch> class stopwatch_runner {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_runner(stopwatch & a, system::error_code & ec = system::throws);
        ~stopwatch_runner();
        stopwatch_runner() = delete;
        stopwatch_runner(const stopwatch_runner&) = delete;
        stopwatch_runner& operator=(const stopwatch_runner&) = delete;
    };

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...
    }

[endsect]
[section:stopwatch_suspender Template Class `stopwatch_suspender<>`]

This helper class ensures that the suspend/resume are pairwised. Suspend the associated accumulator at construction time, and resume it at destruction time.

    template <class Stopwatch> class stopwatch_suspender {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_suspender(stopwatch & a, system::error_code & ec = system::throws);
        ~stopwatch_suspender();
        stopwatch_suspender() = delete;
        stopwatch_suspender(const stopwatch_suspender&) = delete;
        stopwatch_suspender& operator=(const stopwatch_suspender&) = delete;
    }

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...

         // call to some function we don't want to measure
         {
            stopwatch_suspender<stopwatch_accumulator<> > _(t);
            external_function();
         }
    }

[endsect]

[section:stopwatch_resumer Template Class `stopwatch_resumer<>`]

This helper class ensures that the resume/suspend are pairwised. Resume the associated accumulator at construction time, and suspecd it at destruction time.

    template <class Stopwatch> class stopwatch_resumer {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_resumer(stopwatch & a, system::error_code & ec = system::throws);
        ~stopwatch_resumer();
        stopwatch_resumer() = delete;
        stopwatch_resumer(const stopwatch_resumer&) = delete;
        stopwatch_resumer& operator=(const stopwatch_resumer&) = delete;
    }

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...

         // call to some function we don't want to measure
         {
            stopwatch_suspender<stopwatch_accumulator<> > _(t);

            {
                stopwatch_resumer<stopwatch_accumulator<> > _(t);

            }
         }
    }

[endsect]

[endsect]

[endsect]
[section:reporters Stopwatch Reporters]
[section:formatter_req `Formatter` Requirements]

A Formatter outputs on a given ostream a formatted string combining informations from a Stopwatch and the format and the double precision.

A Formatter must meet the requirements in the following Table.

In this table `F`  denote a Formatter type, `S` is a Stopwatch and `s` is an instance of `S`, `f` is `const char *` , `p` is and int, and `os` is a `std::ostream`, ec is a system::error_code

[table Formatter Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`F::default_os()`]        [std::otream&]  [The output stream.]]
    [[`F::default_places()`]        [`std::size_t`]  [The precision when displaying a double.]]
    [[`F::default_format()`]        [`const char*`]  [The default format.]]
    [[`F::show_time(s,f,p,os,ec)`]        [`S::time_point`]  [outputs on `os` a formatted string combining informations from the Stopwatch `s`, the format `f` and the double precision `p`.]]
]


Models of `Formatter`:

* __basic_stopwatch_formatter__
* __basic_stopwatch_accumulator_formatter__
* __basic_24_hours_formatter__

[endsect]

[section `Formatter` related traits]

        template <class Stopwatch>
        struct stopwatch_reporter_default_formatter {
            typedef <see below> type;
        };

The nested typedef `type` defines the default formatter used by the __stopwatch_reporter__ class when the `Formatter` parameter is not explicit.

[endsect]

[/==================================================]
[section:stopwatch_reporter_hpp Header `<boost/chrono/stopwatch_reporter.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <class Stopwatch, class Formatter>
        class basic_stopwatch_reporter;

        template <class Stopwatch>
        struct stopwatch_reporter_default_formatter;

        template <class Stopwatch, 
                  class Formatter=typename stopwatch_reporter_default_formatter<Stopwatch>::type>
        class __stopwatch_reporter__;
        
        template <class Stopwatch>
        struct wstopwatch_reporter_default_formatter;

        template <class Stopwatch, 
                  class Formatter=typename wstopwatch_reporter_default_formatter<Stopwatch>::type>
        class wstopwatch_reporter;
    }}

[section:basic_stopwatch_reporter Template Class `basic_stopwatch_reporter<>`]

class `basic_stopwatch_reporter` provides everything a `Stopwatch` provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class basic_stopwatch_reporter : public Stopwatch {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit basic_stopwatch_reporter( system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( const std::string & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( int places,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = system::throws );

        ~basic_stopwatch_reporter();

        void report( system::error_code & ec = system::throws );
        bool reported() const;


        typedef stopwatch_runner<basic_stopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<basic_stopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<basic_stopwatch_reporter<Stopwatch> > scoped_resume;
    };

[endsect]

[section:stopwatch_reporter Template Class `stopwatch_reporter<>`]

class __stopwatch_reporter__ provides a everything a `Stopwatch` provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class stopwatch_reporter : public basic_stopwatch_reporter<Stopwatch,Formatter> {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit stopwatch_reporter( system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( const std::string & format,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( int places,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = system::throws );

        ~stopwatch_reporter();

        void report( system::error_code & ec = system::throws );
        bool reported() const;


        typedef stopwatch_runner<stopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<stopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<stopwatch_reporter<Stopwatch> > scoped_resume;
    };

Usage

    void f1()
    {
        typedef stopwatch_reporter<stopwatch_accumulator<> > accumulator;
        static accumulator t;
        accumulator::scoped_run _(t);
        // ...

        // call to some function we don't want to measure
        {
            accumulator::scoped_suspend _(t);
            external_function();
        }
    }

[endsect]

[section:wstopwatch_reporter Template Class `wstopwatch_reporter<>`]

class `wstopwatch_reporter` provides a everything a `Stopwatch` provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class wstopwatch_reporter : public basic_wstopwatch_reporter<Stopwatch,Formatter> {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit wstopwatch_reporter( system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( const std::string & format,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( int places,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = system::throws );

        ~wstopwatch_reporter();

        void report( system::error_code & ec = system::throws );
        bool reported() const;


        typedef stopwatch_runner<wstopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<wstopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<wstopwatch_reporter<Stopwatch> > scoped_resume;
    };

Usage

    void f1()
    {
        typedef wstopwatch_reporter<stopwatch_accumulator<> > accumulator;
        static accumulator t;
        accumulator::scoped_run _(t);
        // ...

        // call to some function we don't want to measure
        {
            accumulator::scoped_suspend _(t);
            external_function();
        }
    }

[endsect]

[endsect]

[/==================================================]
[section:stopclock_hpp Header `<boost/chrono/stopclock.hpp>`]
[/==================================================]

    namespace boost { namespace chrono {
        template < class Clock, class Formatter > class basic_stopclock;
        template < class Clock, class Formatter > class __stopclock__;
        template < class Clock, class Formatter > class wstopclock;

        typedef <see above> system_stopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_stopclock;
        #endif
        typedef <see above> high_resolution_stopclock;
        typedef <see above> process_real_cpu_stopclock;
        typedef <see above> process_user_cpu_stopclock;
        typedef <see above> process_system_cpu_stopclock;

        typedef <see above> system_wstopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_wstopclock;
        #endif
        typedef <see above> high_resolution_wstopclock;
        typedef <see above> process_real_cpu_wstopclock;
        typedef <see above> process_user_cpu_wstopclock;
        typedef <see above> process_system_cpu_wstopclock;
    }}

[section:basic_stopclock Template Class `basic_stopclock<>`]

`basic_stopclock<Clock,Formatter>` template class is a shortcut of `basic_stopwatch_reporter<stopwatch<Clock,Formatter>>`

    template< class Clock, class Formatter>
    class basic_stopclock : public basic_stopwatch_reporter<stopwatch<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit basic_stopclock( system::error_code & ec = system::throws );
        explicit basic_stopclock( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock( int places,
                    system::error_code & ec = system::throws );

        basic_stopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        basic_stopclock( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        basic_stopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[section:stopclock Template Class `stopclock<>`]

A stopclock is a stopwatch with the ability to report elapsed time on an output stream.
`stopclock<Clock>` template class is a shortcut of `basic_stopclock<Clock, typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type>` with a specific default formatter.

    template
        < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class stopclock : public basic_stopclock<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit stopclock( system::error_code & ec = system::throws );
        explicit stopclock( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit stopclock( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit stopclock( int places,
                    system::error_code & ec = system::throws );

        stopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        stopclock( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        stopclock( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        stopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:stopclock_typedefs `stopclock` useful typedefs]

The library provides stopclock shortcuts for all the models of __Clock__, replacing clock by stopclock.

        typedef boost::chrono::stopclock< boost::chrono::system_clock > 
            system_stopwatch_stopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::stopclock< boost::chrono::monotonic_clock > 
            monotonic_stopwatch_stopclock;
        #endif
        typedef boost::chrono::stopclock< boost::chrono::high_resolution_clock > 
            high_resolution_stopclock;
        typedef boost::chrono::stopclock< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_stopclock;
        typedef boost::chrono::stopclock< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_stopclock;
        typedef boost::chrono::stopclock< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_stopclock;

[endsect]

[section:wstopclock Template Class `wstopclock<>`]

`wstopclock<Clock>` template class is a shortcut of `basic_wstopclock<Clock, typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type>` with a specific default formatter.

    template
        < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class wstopclock : public basic_wstopclock<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit wstopclock( system::error_code & ec = system::throws );
        explicit wstopclock( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit wstopclock( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit wstopclock( int places,
                    system::error_code & ec = system::throws );

        wstopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        wstopclock( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        wstopclock( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        wstopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:wstopclock_typedefs `wstopclock` useful typedefs]

The library provides wstopclock shortcuts for all the models of __Clock__, replacing clock by wstopclock.

        typedef boost::chrono::wstopclock< boost::chrono::system_clock > 
            system_wstopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::wstopclock< boost::chrono::monotonic_clock > 
            monotonic_wstopclock;
        #endif
        typedef boost::chrono::wstopclock< boost::chrono::high_resolution_clock > 
            high_resolution_wstopclock;
        typedef boost::chrono::wstopclock< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_wstopclock;
        typedef boost::chrono::wstopclock< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_wstopclock;
        typedef boost::chrono::wstopclock< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_wstopclock;

[endsect]


[endsect]

[/==================================================]
[section:stopclock_accumulator_hpp Header `<boost/chrono/stopclock_accumulator.hpp>`]
[/==================================================]

    namespace boost { namespace chrono {
        template < class Clock, class Formatter >
        class basic_stopclock_accumulator;
        template < class Clock, class Formatter >
        class __stopclock_accumulator__;
        template < class Clock, class Formatter >
        class wstopclock_accumulator;

        typedef <see above> system_stopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_stopclock_accumulator;
        #endif
        typedef <see above> high_resolution_stopclock_accumulator;
        typedef <see above> process_real_cpu_stopclock_accumulator;
        typedef <see above> process_user_cpu_stopclock_accumulator;
        typedef <see above> process_system_cpu_stopclock_accumulator;

        typedef <see above> system_wstopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_wstopclock_accumulator;
        #endif
        typedef <see above> high_resolution_wstopclock_accumulator;
        typedef <see above> process_real_cpu_wstopclock_accumulator;
        typedef <see above> process_user_cpu_wstopclock_accumulator;
        typedef <see above> process_system_cpu_wstopclock_accumulator;
    }}

[section:basic_stopclock_accumulator Template Class `basic_stopclock_accumulator<>`]

`basic_stopclock_accumulator<Clock>` template class is a shortcut of `basic_stopwatch_reporter<stopwatch_accumulator<Clock>, typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type>`

    template
        < class Clock=high_resolution_clock
        , class Formatter=
            typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class basic_stopclock_accumulator
        : public basic_stopwatch_reporter<stopwatch_accumulator<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit basic_stopclock_accumulator( system::error_code & ec = system::throws );
        explicit basic_stopclock_accumulator( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock_accumulator( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock_accumulator( int places,
                    system::error_code & ec = system::throws );

        basic_stopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        basic_stopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[section:stopclock_accumulator Template Class `stopclock_accumulator<>`]

`stopclock_accumulator<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>` with a specific formatter.

    template
        < class Clock=high_resolution_clock
        , class Formatter=
            typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class stopclock_accumulator
        : public basic_stopclock_accumulator<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit stopclock_accumulator( system::error_code & ec = system::throws );
        explicit stopclock_accumulator( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit stopclock_accumulator( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit stopclock_accumulator( int places,
                    system::error_code & ec = system::throws );

        stopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        stopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:stopclock_accumulator_typedefs `stopclock_accumulator` useful typedefs]

The library provides stopclock_accumulator shortcuts for all the models of __Clock__, replacing clock by stopclock_accumulator.


        typedef boost::chrono::stopclock_accumulator< boost::chrono::system_clock > 
            system_stopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::stopclock_accumulator< boost::chrono::monotonic_clock > 
            monotonic_stopclock_accumulator;
        #endif
        typedef boost::chrono::stopclock_accumulator< boost::chrono::high_resolution_clock > 
            high_resolution_stopclock_accumulator;
        typedef boost::chrono::stopclock_accumulator< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_stopclock_accumulator;
        typedef boost::chrono::stopclock_accumulator< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_stopclock_accumulator;
        typedef boost::chrono::stopclock_accumulator< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_stopclock_accumulator;

[endsect]
[section:wstopclock_accumulator Template Class `wstopclock_accumulator<>`]

`wstopclock_accumulator<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>` with a specific formatter.

    template
        < class Clock=high_resolution_clock
        , class Formatter=
            typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class wstopclock_accumulator
        : public basic_wstopclock_accumulator<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit wstopclock_accumulator( system::error_code & ec = system::throws );
        explicit wstopclock_accumulator( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit wstopclock_accumulator( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit wstopclock_accumulator( int places,
                    system::error_code & ec = system::throws );

        wstopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        wstopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:wstopclock_accumulator_typedefs `wstopclock_accumulator` useful typedefs]

The library provides wstopclock_accumulator shortcuts for all the models of __Clock__, replacing clock by wstopclock_accumulator.

        typedef boost::chrono::wstopclock_accumulator< boost::chrono::system_clock > 
            system_wstopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::wstopclock_accumulator< boost::chrono::monotonic_clock > 
            monotonic_wstopclock_accumulator;
        #endif
        typedef boost::chrono::wstopclock_accumulator< boost::chrono::high_resolution_clock > 
            high_resolution_wstopclock_accumulator;
        typedef boost::chrono::wstopclock_accumulator< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_wstopclock_accumulator;
        typedef boost::chrono::wstopclock_accumulator< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_wstopclock_accumulator;
        typedef boost::chrono::wstopclock_accumulator< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_wstopclock_accumulator;

[endsect]
[endsect]

[/==================================================]
[section:scoped_stopclock_hpp Header `<boost/chrono/scoped_stopclock.hpp>`]
[/==================================================]

    namespace boost { namespace chrono {
        template < class Clock, class Formatter > class scoped_stopclock;
    }}

[section:scoped_stopclock Template Class `scoped_stopclock<>`]

`scoped_stopclock<>`is like a `stopclock<>` but that in addition will output a scoped trace. At construction time it will output

    {{{ <string>

and at destruction time

    }}} <string> <output of stopwatch_reporter>

A typical ussage of this class is

    int f1(long j)
    {
      scoped_stopclock<> _(BOOST_CURRENT_FUNCTION);

      for ( long i = 0; i < j; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }


[heading Synopsis]

    template < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class scoped_stopclock
        : public stopwatch_reporter<stopwatch<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit scoped_stopclock( const std::string& func,
                    system::error_code & ec = system::throws );
        scoped_stopclock( const std::string& func, ostream_type & os,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, const string_type & format,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, int places,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os,
                    const string_type & format,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, const string_type & format,
                    int places, system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os, int places,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, int places,
                    const string_type & format, system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os,
                    const string_type & format, int places,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os, int places,
                    const string_type & format, system::error_code & ec = system::throws );

        ~scoped_stopclock();

        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[endsect]
[endsect]
[section:formatters Stopwatch Formatters]

[/==================================================]
[section:stopwatch_formatter_hpp Header `<boost/chrono/stopwatch_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_stopwatch_formatter;

        typedef basic_stopwatch_formatter<char> stopwatch_formatter;
        typedef basic_stopwatch_formatter<wchar_t> wstopwatch_formatter;
    }}

[section:basic_stopwatch_formatter Template Class `basic_stopwatch_formatter<>`]

`stopwatch_formatter` is a model of __Formatter__.

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    >
    class basic_stopwatch_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template < class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, 
                               std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%ts\\n", where

* `%d` : the result of elapsed() when the reporting is done.

The time is given using the suffix "s" following the System International d'Unites Std.

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_accumulator_formatter_hpp Header `<boost/chrono/stopwatch_accumulator_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        > basic_stopwatch_accumulator_formatter;
        typedef basic_stopwatch_accumulator_formatter<char> stopwatch_accumulator_formatter;
        typedef basic_stopwatch_accumulator_formatter<wchar_t> wstopwatch_accumulator_formatter;
    }}

[section:basic_stopwatch_accumulator_formatter Template Class `basic_stopwatch_accumulator_formatter<>`]

`basic_stopwatch_accumulator_formatter` is a model of __Formatter__

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    class basic_stopwatch_accumulator_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, 
                               std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%c times, sum=%ss, min=%ms, max=%Ms, mean=%as, frequency=%fHz, lifetime=%ls, percentage=%p\%\\n", where

* `%c` : the counter of the number of times the pair srat/stop has been called.
* `%s` : the sum of the samples of elapsed time between the call to start/stop.
* `%m` : the min of the samples of elapsed time between the call to start/stop.
* `%M` : the max of the samples of elapsed time between the call to start/stop.
* `%a` : the mean of the samples of elapsed time between the call to start/stop.
* `%f` : the frequency of calls to start.
* `%l` : the lifetime of the stopwatch_accumulator.
* `%p` : the percentage of time spent by this stopwatch respect to its lifetime.

The time is given using the suffix "s", the frequency is given using the suffix "Hz", both following the System International d'Unites Std.

[endsect]

[section:typedefs `basic_stopwatch_accumulator_formatter` useful typedefs]

The library provides basic_stopwatch_accumulator_formatter shortcuts for char and wchar_t.

        typedef basic_stopwatch_accumulator_formatter<char> 
            stopwatch_accumulator_formatter;
        typedef basic_stopwatch_accumulator_formatter<wchar_t> 
            wstopwatch_accumulator_formatter;


[endsect]
[endsect]
[/==================================================================]
[section:time_formatter_hpp Header `<boost/chrono/time_formatter.hpp>`]
[/==================================================================]

    namespace boost { namespace chrono {

        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_time_formatter;

        typedef basic_time_formatter<char> time_formatter;
        typedef basic_time_formatter<wchar_t> wtime_formatter;

        template <>
        struct stopwatch_reporter_default_formatter<stopwatch<process_cpu_clock> > {
            typedef time_formatter type;
        };

    } }

[section:basic_time_formatter Template Class `basic_time_formatter<>`]

`basic_time_formatter` is a model of __Formatter__.

    template <typename CharT, typename Traits, class Alloc>
    class basic_time_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_
            , const char * format, int places, std::ostream & os
            , system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "nreal %rs, cpu %cs (%p%), user %us, system %ss\\n", where

* `%r` : real process clock
* `%u` : user process clock
* `%s` : system process clock
* `%c` : user+system process clock
* `%p` : percentage (user+system)/real process clock

All the units are given using the suffix "s" following the System International d'Unites Std.

[endsect]

[section:typedefs `basic_time_formatter` useful typedefs]

The library provides basic_time_formatter shortcuts for char and wchar_t.

        typedef basic_time_formatter<char> time_formatter;
        typedef basic_time_formatter<wchar_t> wtime_formatter;

[endsect]

[section:spec `stopwatch_reporter_default_formatter` Specialization]

        template <>
        struct stopwatch_reporter_default_formatter<stopwatch<process_cpu_clock> > {
            typedef time_formatter type;
        };

[endsect]


[endsect]

[/==================================================]
[section:stopwatch_accumulator_time_formatter_hpp Header `<boost/chrono/stopwatch_accumulator_time_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        > basic_stopwatch_accumulator_time_formatter;
        typedef basic_stopwatch_accumulator_time_formatter<char> stopwatch_accumulator_time_formatter;
        typedef basic_stopwatch_accumulator_time_formatter<wchar_t> wstopwatch_accumulator_time_formatter;
    }}

[section:basic_stopwatch_accumulator_time_formatter Template Class `basic_stopwatch_accumulator_time_formatter<>`]

`basic_stopwatch_accumulator_time_formatter` is a model of __Formatter__

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    class basic_stopwatch_accumulator_time_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, 
                               std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%c times, sum=%s, min=%m, max=%M, mean=%a, frequency=%fHz, lifetime=%ls, percentage=%p\%\\n|real %rs, cpu %cs (%p%), user %us, system %ss", where

The part before the '|' corresponds to the accumulator format and the part after corresponds to the times format, which will be used for the sum, max, min and mean statistics.

* `%c` : the counter of the number of times the pair srat/stop has been called.
* `%s` : the sum of the samples of elapsed time between the call to start/stop.
* `%m` : the min of the samples of elapsed time between the call to start/stop.
* `%M` : the max of the samples of elapsed time between the call to start/stop.
* `%a` : the mean of the samples of elapsed time between the call to start/stop.
* `%f` : the frequency of calls to start.
* `%l` : the lifetime of the stopwatch_accumulator.
* `%p` : the percentage of time spent by this stopwatch respect to its lifetime.

* `%r` : real process clock
* `%u` : user process clock
* `%s` : system process clock
* `%c` : user+system process clock
* `%p` : percentage (user+system)/real process clock

The time is given using the suffix "s", the frequency is given using the suffix "Hz", both following the System International d'Unites Std.


[endsect]

[section:typedefs `basic_stopwatch_accumulator_time_formatter` useful typedefs]

The library provides basic_stopwatch_accumulator_time_formatter shortcuts for char and wchar_t.

        typedef basic_stopwatch_accumulator_time_formatter<char> 
            stopwatch_accumulator_time_formatter;
        typedef basic_stopwatch_accumulator_time_formatter<wchar_t> 
            wstopwatch_accumulator_time_formatter;


[endsect]
[endsect]

[/==================================================]
[section:t24_hours_hpp Header `<boost/chrono/t24_hours.hpp>`]
[/==================================================]

    namespace boost { namespace chrono {
        class t24_hours;
    }}

[section:t24_hours Class `t24_hours`]

`t24_hours` helper class decompose a duration in days, hours, minutes, seconds and nanoseconds. It can be used through its static functions or creating an instance and using its fields.

    class t24_hours {
    public:
        typedef boost::chrono::duration<boost::int_least32_t, __ratio__<24*3600> > days;
        typedef boost::chrono::hours hours;
        typedef boost::chrono::minutes minutes;
        typedef boost::chrono::seconds seconds;
        typedef boost::chrono::nanoseconds nanoseconds;
        
        template <class Rep, class Period>
        static days get_days(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static hours get_hours(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static minutes get_minutes(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static seconds get_seconds(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static nanoseconds get_nanoseconds(const boost::chrono::duration<Rep, Period>& d);

        days days_;
        hours hours_;
        minutes minutes_;
        seconds seconds_;
        nanoseconds nanoseconds_;

        template <class Rep, class Period>
            explicit t24_hours(const boost::chrono::duration<Rep, Period>& d);
    };

[endsect]
[endsect]

[/==================================================================]
[section:t24_hours_formatter_hpp Header `<boost/chrono/t24_hours_formatter.hpp>`]
[/==================================================================]


    namespace boost { namespace chrono {

        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_24_hours_formatter;

        typedef basic_24_hours_formatter<char> t24_hours_formatter;
        typedef basic_24_hours_formatter<wchar_t> wt24_hours_formatter;

    } }

[section:basic_24_hours_formatter Template Class `basic_24_hours_formatter<>`]

`basic_24_hours_formatter` is a model of __Formatter__.

    template <typename CharT, typename Traits, class Alloc>
    class basic_24_hours_formatter {
    public:
        static std::ostream &  default_os();
        static const char * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_
            , const char * format, int places, std::ostream & os
            , system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%d days(s) %h:%m:%s.%n\\n", where

* `%d` : days
* `%h` : hours
* `%m` : minutes
* `%s` : seconds
* `%n` : nanoseconds

[endsect]

[section:typedefs `basic_24_hours_formatter` useful typedefs]

The library provides basic_24_hours_formatter shortcuts for char and wchar_t.

        typedef basic_24_hours_formatter<char> t24_hours_formatter;
        typedef basic_24_hours_formatter<wchar_t> wt24_hours_formatter;

[endsect]

[endsect]

[endsect]
[section:deprecated Deprecated Headers]
[/==================================================]
[section:timer_hpp Deprecated Header `<boost/chrono/timer.hpp>`]
[/==================================================]

This header has been deprecated, use instead <boost/chrono/stopwatch.hpp>.

    namespace boost { namespace chrono  {
        template <class Clock=high_resolution_clock> class timer;
        typedef <see above> system_timer;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_timer;
        #endif
        typedef <see above> high_resolution_timer;
    }}

[/
        typedef <see above> process_real_cpu_timer;
        typedef <see above> process_user_cpu_timer;
        typedef <see above> process_system_cpu_timer;
]
[section:timer Template Class `timer<>`]

Knowing how long a part of a program takes to execute is useful in both test and production environments.
A `timer` object measures elapsed time. It is recommended to use it with clocks that measure wall clock rather than CPU time since the intended use is performance measurement on systems where total elapsed time is more important than just process or CPU time.

The maximum measurable elapsed time depends on the Clock parameter. The accuracy of timings depends on the
accuracy of timing information provided the Clock, and this coudl varies a great deal from one clock to another.

        template <class Clock> class timer {
        public:
            typedef Clock                       clock;
            typedef typename Clock::duration    duration;
            typedef typename Clock::time_point  time_point;

            explicit timer( system::error_code & ec = system::throws );

            ~timer();

            void start( system::error_code & ec = system::throws );
            duration elapsed( system::error_code & ec = system::throws );

        };

[endsect]

[section:timer_typedefs `timer` useful typedefs]

        typedef boost::chrono::timer< boost::chrono::system_clock > 
            system_timer;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::timer< boost::chrono::monotonic_clock > 
            monotonic_timer;
        #endif
        typedef boost::chrono::timer< boost::chrono::high_resolution_clock > 
            high_resolution_timer;

[/
        typedef boost::chrono::timer< boost::chrono::process_real_cpu_clock > process_real_cpu_timer;
        typedef boost::chrono::timer< boost::chrono::process_user_cpu_clock > process_user_cpu_timer;
        typedef boost::chrono::timer< boost::chrono::process_system_cpu_clock > process_system_cpu_timer;
]
[endsect]
[endsect]


[/==================================================================]
[section:process_times_hpp Deprecated Header `<boost/chrono/process_times.hpp>`]
[/==================================================================]

This header has been deprecated. Use instead `<boost/chrono/process_cpu_clocks.hpp>`, `<boost/chrono/stopwatch.hpp>`, `<boost/chrono/stopwatch_reporter.hpp>` and `<boost/chrono/stopclock.hpp>` files.

    namespace boost { namespace chrono {

        class process_clock;
        typedef <see below> process_times;
        class process_timer;
        class run_timer;

    } }

[section:process_clock Class `process_clock`]

`process_clock` doesn't satisfy the Clock Requirements as the function now do not follows the Clock prototype.

`process_clock` provides a thin wrapper around the operating system's process time API. For POSIX-like systems, that's the times() function, while for Windows, it's the GetProcessTimes() function.

The process relative real, user and system current time can be obtained at once by calling `process_clock::now()`.


        class process_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::__time_point__<process_clock>    time_point;
            static const bool is_monotonic =             true;

            struct process_times;
            static void now( process_times & times,
                             system::error_code & ec = system::throws );
        };

[section:process_times Class `process_times`]

        struct process_times {
            process_clock::duration real;    // real (i.e wall clock) time
            process_clock::duration user;    // user cpu time
            process_clock::duration system;  // system cpu time
        };

[endsect]

[endsect]
[section:process_times Typedef `process_times`]

    typedef process_clock::process_times process_times;

This is a synonym of process_clock::process_times included for backward compatibility.

[endsect]

[section:process_timer Class `process_timer`]

Knowing how long a program takes to execute is useful in both test and production environments. It is also helpful if such timing information is broken down into real (wall clock) time, CPU time spent by the user, and CPU time spent by the operating system servicing user requests.

`process_timer<>` is the `timer<>` equivalent associated to the pseudo-clock `process_clock`. It behaves like `timer<>` but it uses the specific `process_clock:now()` function.

        class process_timer {
        public:
            typedef process_clock                          clock;
            typedef process_clock::duration                duration;
            typedef process_clock::time_point              time_point;

            explicit process_timer( system::error_code & ec = system::throws );

            ~process_timer();
            void  start( system::error_code & ec = system::throws );
            void  elapsed( process_times & times, system::error_code & ec = system::throws );
        };

[endsect]
[section:run_timer Class `run_timer`]

class `run_timer` provides a complete run time reporting package that can be invoked in a single line of code. The reporting is controled by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

The default places is given by default_places and is 3.

The default format is "nreal %rs, cpu %cs (%p%), user %us, system %ss\\n", where

* `%r` : real process clock
* `%u` : user process clock
* `%s` : system process clock
* `%c` : user+system process clock
* `%p` : percentage (user+system)/real process clock

All the units are given using the suffix "s" following the System International d'Unites Std.

        class run_timer : public process_timer {
        public:
            explicit run_timer( system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os,
                        system::error_code & ec = system::throws );

            explicit run_timer( const std::string & format,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, const std::string & format,
                        system::error_code & ec = system::throws );

            explicit run_timer( const std::string & format, int places,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, const std::string & format, int places,
                        system::error_code & ec = system::throws );

            explicit run_timer( int places,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, int places,
                        system::error_code & ec = system::throws );

            explicit run_timer( int places, const std::string & format,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, int places, const std::string & format,
                        system::error_code & ec = system::throws );

            ~run_timer();

            void start( system::error_code & ec = system::throws );

            void report( system::error_code & ec = system::throws );

            void test_report( duration real_, duration user_, duration system_ );
            bool reported() const;
            static int default_places();
        };


[endsect]

[endsect]

[endsect]

[endsect]


[/=================]
[section Appendices]
[/=================]
[/==================================]
[section:history Appendix A: History]
[/==================================]

[section [*Version 0.4.6, August 28, 2010] ]

[*New Features:]

* Implementation of __common_type__ without using Boost.TypeOf.
* Added __stopwatch_accumulator_time_formatter__ class.

[*Old Features:]

* Type reporter removed from Stopwatches as well as the get_reporter metafunction.

[*Bug Fixes]

* __process_cpu_clock__ is now a valid model of Clock that can be used with __stopclocks_accumulator__.
* eliminate or suppress a lot of warnings appearing with with warnings=all -Wextra
* improve the error code handling

[endsect]

[section [*Version 0.4.5, July 6, 2010] ['Documentation update]]

[*Documentation]

* Overview rewriting
* Added missing __thread_clock__ reference.
* How to implement a __thread_clock__ tutorial removed.
* References section renamed to External Resources.
* Added links to source examples.
* Added links between Models and Concepts.
* Added macros descriptions.
* Cleanup.

[*Bug Fixes]

* Valgrind fixes: "Conditional jump or move depends on uninitialised value(s)"
* Take care of Boost.System break on version 1.44
* gcc.4.4 "warning: suggest parentheses around '&&' within '||' " removal.

[endsect]

[section [*Version 0.4.4, February 22, 2010] [' Warning fixes]]

[*Bug Fixes]

* `scoped_suspend` warning removal
* `error_code` management completed

[endsect]

[section [*Version 0.4.3, June 18, 2010] ['Missing file fixe]]

[*Bug Fixes]

* boost/thread/detail/cv_status.hpp file was not commited.

[endsect]

[section [*Version 0.4.2, June 18, 2010] ['Packaging fixe]]

* Boost.Conversion library, used by Boost.Thread porting to Boost.Chrono was not packaged.

[endsect]

[section [*Version 0.4.1, June 17, 2010] ['Added thread clock implementation on Windows]]

[*New Features:]

* Added __thread_clock__ implementation on Windows.
* Added *Boost.Thread* using *Boost.Chrono*.

[endsect]

[section [*Version 0.4, February 28, 2010] ['New thread clock and Suspendible clock ]]

[*New Features:]

* __SuspendibleClock__ concept + template class _suspendible_clock__.
* Added `scope_suspend` which do `suspend`/`resume` if the __Clock__ is a model of __SuspendibleClock__ concept, and nothing otherwise.
* __thread_clock__ support on platforms providing it natively.
* Added support for wide character for __stopwatch_reporter__, `stopclock`, and `stopclock_accumulator`.
* `digital_time` renamed `t24_hours`.

[*Perf]

Added performances measures.

[*Bug Fixes]

* Bug on timeval_demo.

    time_point t(duration(xtime(0)));  // this was taken as a function declaration
    gettimeofday((timeval*)&t, 0);
    return t;
by

    timeval tv;
    gettimeofday(&tv, 0);
    xtime xt( tv.tv_sec, tv.tv_usec);
    return time_point(duration(xt));

* Bug on run_timer_test (add a global variable to avoid optimization that removes completely the code to be  measured

[endsect]

[section [*Version 0.3.2, January 25, 2010] ['New frequency, lifetime and percentage stopwatch_accumulator features]]
[*Features:]

* Added overloading for `operator/(Integer/Duration)`
* Added frequency, lifetime and percentage to the default `stopwatch_accumulator_formatter`.

[*Bug Fixes]
* Specific formatters didn't work completly.
* Replace `duration(0)` by `duration::zero()` on template classes.
* `suspend` doesn't works: `partial_` not initialized neither taken in account by the elapsed function.

[endsect]

[section [*Version 0.3.1, January 20, 2010] ['New support for wide characters]]
[*Features:]

* Support for wide characters on formatters and stopclocks
* added `chrono.hpp` and `stopwatches.hpp` at the boost level


[endsect]

[section [*Version 0.3.0, January 17, 2010] ['New stopwatch/stopclock feature + Bug fixes]]
[*Features:]

* Added independent process cpu clocks for real, user, system process CPU time
* Added global process cpu clock for real, user, system process CPU time
* Added `digital_time` (looking for a better name)
* Added new __Stopwatch__ concept measuring elapsed time between different points in time associated to the operations `start`, `stop`, `suspend` and `resume`.
* Added __stopwatch__ is a model __Stopwatch__ measuring the elapsed time between the `start` and the `stop` operations.
* Added __stopwatch_accumulator__ is a model __Stopwatch__ allowing to accumulate several time samples and gives the average, ...
* Added scoped helper classes allowing to pairwise `start`/`stop` operations, `suspend`/`resume` and `resume`/`suspend` a __Stopwatch__.
* Added new stopwatch __Formatter__ concept
    * Added stopwatch formatter "%ds\\n"
    * Added stopwatch accumulator formatter "%c times, sum=%ss, min=%ms, max=%Ms, mean=%as\\n"
    * Added time formatter "real %rs, cpu %cs (%p%), user %us, system %ss\\n"
    * Added digital_time formatter "%d days(s) %h:%m:%s.%n\\n"
* __stopwatch_reporter__ is a convenient generic class reporting elapsed time for the Stopwatch concept.
* Added `stopclock<Clock>` shortcut `stopwatch_reporter<stopwatch<Clock>>`
* Added __scoped_stopclock__ which trace at the constuctor and destructor.
* Added `typeof` registration for classes __duration__ and __time_point__

* The old classes `process_times`, `process_clock`, `process_timer`, `timer` and `run_timer` are deprecated as the preceding additions are more generic. However for backward compatibility they preserved until inclusion of the library in Boost. Next follows the equivalences:
    * `timer<>` ~ `stopwatch<>`
    * `process_timer` ~ `stopwatch<process_cpu_clock>`
    * `run_timer` ~ `stopclock<>`

[*Bug Fixes]

* Try to correct warning "C4251: 'boost::chrono::run_timer::m_format' : class 'std::basic_string<_Elem,_Traits,_Ax>' needs to have dll-interface to be used by clients of class 'boost::chrono::run_timer'", by don't including inlines functions using the std::string `m_format`.

[endsect]

[section [*Version 0.2.1, December 13, 2009] ['Bug fixes]]

[*Bug Fixes]

* Replace `INTMAX_C` by `BOOST_INTMAX_C` until `boost/cstdint.hpp` ensures `INTMAX_C` is always defined.
* Define __BOOST_CHRONO_HAS_CLOCK_MONOTONIC__ when `BOOST_CHRONO_WINDOWS_API`
* Commenting invalid operator declarations
* Take care of Boost `min`/`max` recommendations
* Complete qualification when defining nested typedef duration on clocks to avoid the following compile error:

    ./boost/chrono/chrono.hpp:945: error: declaration of 'typedef class boost::chrono::duration<long long int, boost::__ratio__<1ll, 10000000ll> > boost::chrono::system_clock::duration'
    ./boost/chrono/chrono.hpp:458: error: changes meaning of 'duration' from 'class boost::chrono::duration<long long int, boost::__ratio__<1ll, 10000000ll> >'

* cleanup of simulated...
* warning removal on `posix/process_clock.cpp`.
* disable VC++ foolishness.
* Update Jamfiles to manage with dll.
* removal of conversion warning in test_duration.
* manage with MSVC reporting a warning instead of an error when there is an integral constant overflow.
* Use `STATIC_ASSERT` specific macro to solve the compile failing issue.
* Qualify with `boost::detail` `boost::chrono::detail` to avoid ambiguities with MSVC.


[*Documentation:]

More updated documentation.

[endsect]

[section [*Version 0.2.0, December 8, 2009] ['+ Features + Bug fixes + Updated documentation]]

[*Features:]

* Added __ratio__ construction and assignment from an equivalent __ratio__ ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]])
* Added nested __ratio__ typedef type ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]])
* Added __BOOST_CHRONO_HAS_CLOCK_MONOTONIC__ macro to state if __monotonic_clock__ is provided on this platform.
* Added __duration__ `operator%` ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-defects.html#934 [*LGW 934. duration is missing operator%]])
* Added BOOST_CHRONO_CONSTEXPR when constexpr should be used.
* Complete __duration__ `operator*` and `operator/`.


[*Implementation:]

* Use `INTMAC_C` to name `intmax_t` constants instead of `LL`.
* Separate `chrono.cpp` on # files `win/chrono.cpp`, `mac/chrono.cpp` and `posix/chrono.cpp` to make easier the maintenance on different platforms.
* Separate `process_clock.cpp` on # files `win/process_clock.cpp`, `mac/process_clock.cpp` and `posix/process_clock.cpp` to make easier the maintenace on different platforms.
* Added the `error_code` prototype for `monotonic_clock::now` for `mac/chrono.cpp`.
* Fully implement `mac/chrono.cpp` with error handling.
* Take care on POSIX systems when `CLOCK_MONOTONIC` is not defined.

[*Documentation:]

* The documentation is written now using quick-book using as base [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] .

[*Bug Fixes]

* `operator/` was ambiguous: Disambiguate duration `operator/`.
* `CLOCK_MONOTONIC` is not defined with cygwin/gcc 3.4: Disable code when __BOOST_CHRONO_HAS_CLOCK_MONOTONIC__ is not defined.
* result of metafunctions `ratio_multiply` and `ratio_divide` were not normalized ratios: Use of the nested __ratio__ typedef type on __ratio__ arithmetic operations.
* Copy constructor from similar __duration__ masked the defaulted operations: Added duration defaulted implementations


[endsect]
[section [*Version 0.1.0, April 29, 2009] ['Beman's boostified version Chrono]]

[*Features:]

*  The C++0x Standard Library's __common_type__.
*  The C++0x Standard Library's compile-time rational arithmetic.
*  The C++0x Standard Library's time utilities, including:
    * Class template __duration__
    * Class template __time_point__
    * Clocks:
        * `system_clock`
        * __monotonic_clock__
        * `high_resolution_clock`

* Class template timer, with typedefs:
    * `system_timer`
    * `monotonic_timer`
    * `high_resolution_timer`

* Process clocks and timers:
    * `process_clock`, capturing real, user-CPU, and system-CPU times.
    * `process_timer`, capturing elapsed real, user-CPU, and system-CPU times.
    * `run_timer`, convenient reporting of process_timer results.

[endsect]
[endsect]

[/======================================]
[section:rationale Appendix B: Rationale]

See [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] which is very informative and provides motivation for key design decisions. The following sections are an extract from this document.

[heading Is it possible for the user to pass a __duration__ to a function with the units being ambiguous?]

No. No matter which option the author of `f` chooses above, the following client code will not compile:

    f(3);  // Will not compile, 3 is not implicitly convertible to any __duration__

[heading Why duration needs operator%]

This operator is convenient for computing where in a time frame a given duration lies. A motivating example is converting a duration into a "broken-down" time duration such as hours::minutes::seconds:

    class ClockTime
    {
        typedef boost::chrono::hours hours;
        typedef boost::chrono::minutes minutes;
        typedef boost::chrono::seconds seconds;
    public:
        hours hours_;
        minutes minutes_;
        seconds seconds_;

        template <class Rep, class Period>
          explicit ClockTime(const boost::chrono::duration<Rep, Period>& d)
            : hours_  (boost::chrono::duration_cast<hours>  (d)),
              minutes_(boost::chrono::duration_cast<minutes>(d % hours(1))),
              seconds_(boost::chrono::duration_cast<seconds>(d % minutes(1)))
              {}
    };

[heading Why ratio needs CopyConstruction and Assignment from ratios having the same normalized form]

Current [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf [*N3000]] doesn't allows to copy-construct or assign ratio instances of ratio classes having the same normalized form.

This simple example

    __ratio__<1,3> r1;
    __ratio__<3,9> r2;
    r1 = r2; // (1)

fails to compile in (1). Other example

    __ratio__<1,3> r1;
    ratio_substract<__ratio__<2,3>,__ratio__<1,3> > r2=r1;  // (2)

The type of ratio_substract<__ratio__<2,3>,__ratio__<1,3> > could be __ratio__<3,9> so the compilation could fail in (2). It could also be __ratio__<1,3> and the compilation succeeds.

[heading Why ratio needs the nested normalizer typedef type]

In [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf [*N3000]] 20.4.2 and similar clauses

['3 The nested typedef type shall be a synonym for __ratio__<T1, T2> where T1 has the value R1::num * R2::den - R2::num * R1::den and T2 has the value R1::den * R2::den.]

The meaning of synonym let think that the result should be a normalized ratio equivalent to __ratio__<T1, T2>, but there is not an explicit definition of what synonym means in this context.

If the CopyConstruction and Assignment ([[@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#12811281 [*LWG 1281]]) is not added we need a typedef for accessing the normalized ratio, and change 20.4.2 to return only this normalized result. In this case the user will need to

    __ratio__<1,3>::type r1;
    __ratio__<3,9>::type r2;
    r1 = r2; // compiles as both types are the same.


[heading How reliable are these measures?]

[/note this section need to be reworked, the ideas are there, but ...]


There are three cases which can lead to get unreliable measures:

* It is not possible to measure events that transpire at rates of the same order of magnitude as the clock's precision with any reliability.  For example, a 10ms clock cannot be used reliably to measure elapsed times of tens of milliseconds.  The library provides a [high_resolution_clock] that gives you the highest resolution time available on your platform.  That will give the best precision, but can only be used for reliable measurement of events that elapse about an order of magnitude slower than that clock's precision.


``
#include <boost/chrono/chrono.hpp>
    ...
    __stopclock__<__high_resolution_clock__> _;
``

* Using a process clock in a multithreaded application will give elapsed time for the process as a whole, including threads other than the calling thread.  To get time elapsed for a specific thread, use the supplied __thread_clock__ which returns time elapsed for the calling thread only, if supported by the platform.

* When stopclocks are nested, usually from stopclocks appearing in each of several nested function calls, the overhead of the stopclock processing begins to be significant relative to run time of the code being measured.  The innermost measurements remain accurate, but those in the outermost layers can measure too much overhead to be trustworthy.

* Nested stopclocks (usually nested function calls where each function contains a stopclock). When the nesting is deep enough, the cumulative overhead of all the stopclock functionality make the data unreliable except for the inner-most trace points. The question is, how much time is related to the application code we want to measure and how much to the fact we are meassuring and logging in inner blocks?


Most of the stopclock overhead is likely due to logging. There are two things we can do to make the difference :

* Don't flush log information while measuring elapsed time.  A __stopwatch_accumulator__ can make that possible, because it don't report until all the measures have been compiled and then report some statistics.  Alternatively, an asynchronous stream would permit normal logging but by a thread other than the one being measured.

* Add a mechanism to track the difference between the application time and stopclock time.  If a __Clock__ models __SuspendibleClock__ and its precision is sufficiently fine, this mechanism could suspend the __Clock_s__ counting while reporting measurements and resume it thereafter.

[/
    stopclock<suspendible_clock<Clock> > _;


See the performances section for more deep details.
]

[endsect]

[/======================================================]
[section:implementation Appendix C: Implementation Notes]



[endsect]

[/======================================================]
[section:faq Appendix D: FAQ]

[heading How important is the order of the __common_type__<> template arguments?]

The order of the template parameters is important. First __common_type__<> is not able to find out common type if it is not present and second
__common_type__<A,B,C>::type is equivalent to __common_type__<__common_type__<A,B>::type, C>::type.


    struct A {};
    struct B {};
    struct C {
        C() {}
        C(A const&) {}
        C(B const&) {}
        C& operator=(C const&) {
            return *this;
        }
    };

    #if 0
    typedef boost::__common_type__<A, B, C>::type ABC; // DO not compile
    #else
    typedef boost::__common_type__<C, B, A>::type ABC;
    #endif


Thus, as __common_type__<A,B>::type is undefined,  __common_type__<A,B,C>::type is also undefined.

[heading Why does stopwatch_reporter only display millisecond place precision when the underlying Clock has nanosecond precision?]

To avoid giving the impression of precision where none exists. See Caveat emptor. You can always specify additional decimal places if you want to live dangerously.

[heading Why does stopwatch_reporter sometimes report more cpu seconds than real seconds?]

Ask your operating system supplier. The results have been inspected with a debugger, and both for Windows and Linux, that's what the OS appears to be reporting at times.

[heading  Can I obtain statistics of the time elapsed between calls to a function?]

The library do not provides this feature.

[heading What happens if I press Ctrl+C and program terminates? What log would Boost.chrono output?]

[heading Can you explain the pros/cons of __common_type__ against Boost.Typeof?]

Even if in a first look they sound to be close, __common_type__ and typeof have
different purposes. You use typeof to get the type of an expression, while
you use __common_type__ to set explicitly the type returned of a template
function. Both are complementary. For example with the preceding declaration
and the needed Typeof registrations, you can do


Suppose I have a mixed type vector2 class with a magnitude_squared function defined as:

template <typename X, typename Y>
BOOST_TYPEOF_TPL(X() * X() + Y() * Y()) magnitude_squared(const
vector2<X, Y> &v) {
   return v.x * v.x + v.y * v.y;
}


__common_type__ is closer in nature to promote_args<class ...T> in boost/math/tools/promotion.hpp than it is to Boost.Typeof, though it is not exactly the same as promote_args either.  __common_type__<T1, T2>::type simply represents the result of some operation on T1 and T2, and defaults to the type obtained by putting T1 and T2 into a conditional statement.

It is meant to be customizable (via specialization) if this default is not appropriate.


[endsect]

[/====================================================]
[section:acknowledgements Appendix E: Acknowledgements]

The library's code was derived from Howard Hinnant's time2_demo prototype. Many thanks to Howard for making his code available under the Boost license. The original code was modified by Beman Dawes to conform to Boost conventions.

time2_demo contained this comment:

Much thanks to Andrei Alexandrescu, Walter Brown, Peter Dimov, Jeff Garland, Terry Golubiewski, Daniel Krugler, Anthony Williams.

Beman Dawes added the `timer<>`, `process_clock`, `process_timer`, `run_timer` classes which are now deprecated and replaced by the __stopwatch__, `process_cpu_clock` and `stopclock` classes.

Thanks to Adrew Chinoff for its multiple suggestion on __stopwatch_accumulator__, and helping me to polish the documentation.

Thanks to Tom Tan for reporting some compiler issues with MSVC V10 beta and MinGW-gcc-4.4.0 and for the many suggestion he did concerning the new __stopwatch__, `process_cpu_clock`and `stopclock` classes and a deep help with wide characters implementation.

Thanks to Ronald Bock for reporting Valgind issues and for the many suggestion he did concerning the documentation.

Thansk to Jeffrey Lee Hellrung, Jr. for sharing his implementation of __common_type__ without using Boost.TypeOf.

[endsect]

[/====================================================]
[section:tests  Appendix F: Tests]

In order to test you need to do.

    bjam libs/chrono/test

You can also run a specific suite of test by doing

    cd libs/chrono/test
    bjam __common_type__


[section `common_type`]
[table
    [[Name]             [kind]          [Description]          [Result] [Ticket]]
    [[common_type_test]    [run] [...]                  [Pass]   [#]]
]
[endsect]

[section `ratio`]
[table
    [[Name]             [kind]          [Description]          [Result] [Ticket]]
    [[ratio_fail_test1]    [compile-fails] [...]                  [Pass]   [#]]
    [[ratio_test]       [run]           [...]                  [Pass]   [#]]
]
[endsect]

[section chrono]
[table
    [[Name]             [kind]          [Description]          [Result] [Ticket]]
    [[chrono_unit_test]      [run]           [...]                  [Pass]   [#]]
    [[explore_limits]      [run]           [...]                  [Pass]   [#]]
    [[test_duration]      [run]           [...]                  [Pass]   [#]]
    [[test_clock]      [run]           [...]                  [Pass]   [#]]
    [[miscellaneous]      [run]           [...]                  [Pass]   [#]]
    [[test_special_values]      [run]           [...]                  [Pass]   [#]]
    [[manipulate_clock_object]      [run]           [...]                  [Pass]   [#]]
    [[chrono_accuracy_test]      [run]           [...]                  [Pass]   [#]]

    [[cycle_count]      [run]           [...]                  [Pass]   [#]]
    [[runtime_resolution]      [run]           [...]                  [Pass]   [#]]
    [[xtime]      [run]           [...]                  [Pass]   [#]]
    [[saturating]      [run]           [...]                  [Pass]   [#]]
    [[min_time_point]      [run]           [...]                  [Pass]   [#]]
    [[i_dont_like_the_default_duration_behavior]      [run]           [...]                  [Pass]   [#]]
    [[simulated_thread_interface_demo]      [run]           [...]                  [Pass]   [#]]
    [[timeval_demo]      [run]           [...]                  [Pass]   [#]]
]
[endsect]


[section Other Clocks]
[table
    [[Name]                         [kind]          [Description]           [Result] [Ticket]]
    [[test_suspendible_clock]               [run]           [test basic uses of suspendible_clock.]                   [Pass]   [#]]
    [[test_thread_clock]               [run]           [test basic uses of thread_clock.]                   [Pass]   [#]]
]
[endsect]

[section stopwatch]
[table
    [[Name]                         [kind]          [Description]           [Result] [Ticket]]
    [[test_min_max]               [compile]           [test compilation succeeds in the presence of macros min and max.]                   [Pass]   [#]]
    [[stopwatch_example]               [run]           [...]                   [Pass]   [#]]
    [[scoped_stopwatch_example]               [run]           [...]                   [Pass]   [#]]
    [[stopwatch_accumulator_example] [run]   [...]                   [Pass]   [#]]
    [[specific_stopwatch_accumulator_example] [run]   [...]                   [Pass]   [#]]
    [[stopclock_example]      [run]          [...]                   [Pass]   [#]]
    [[stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[nested_stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[loop_stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[t24_hours_example]      [run]          [...]                   [Pass]   [#]]
    [[scoped_stopclock_example]      [run]          [...]                   [Pass]   [#]]
    [[timex]      [link]          [...]                   [Pass]   [#]]
    [[stopclock_constructor_overload_test]      [run]          [...]                   [Pass]   [#]]
    [[wstopclock_constructor_overload_test]      [run]          [...]                   [Pass]   [#]]

]
[endsect]

[endsect]
[/=====================================]
[section:tickets  Appendix G: Tickets]

[table
    [[Ticket]             [Description]          [Resolution] [State]]
    [[0]    [ Issues raised by Michael Marcin:  In the past I've seen QueryPerformanceCounter give incorrect results,
    especially with SpeedStep processors on laptops. This was many years ago and
    might have been fixed by service packs and drivers.

    Typically you check the results of QPC against GetTickCount to see if the
    results are reasonable.
    http://support.microsoft.com/kb/274323

    I've also heard of problems with QueryPerformanceCounter in multi-processor
    systems.

    I know some people SetThreadAffinityMask to 1 for the current thread call
    their QueryPerformance* functions then restore SetThreadAffinityMask. This
    seems horrible to me because it forces your program to jump to another
    physical processor if it isn't already on cpu0 but they claim it worked well
    in practice because they called the timing functions infrequently.

    In the past I have chosen to use timeGetTime with timeBeginPeriod(1) for
    high resolution timers to avoid these issues.
    ] [???] [*Open*]]
    [[1]    [operator/ was ambiguous] [Disambiguate duration operator/]                  [Closed]]
    [[2]    [CLOCK_MONOTONIC is not defined with cygwin/gcc 3.4] [Disable code when BOOST_CHRONO_HAS_CLOCK_MONOTONIC is not defined.]                  [Closed]]
    [[3]    [result of metafunctions ratio_multiply and ratio_divide were not normalized ratios] [Use of the nested ratio typedef type on ratio arithmetic operations.]                  [Closed]]
    [[4]    [Copy constructor from similar duration masked the defaulted operations] [Added duration defaulted implementations]                  [Closed]]
    [[5]    [INTMAX_C is not always defined] [Replace INTMAX_C by BOOST_INTMAX_C until boost/cstdint.hpp ensures INTMAX_C is always defined.]                  [Closed]]
    [[6]    [undefined BOOST_CHRONO_HAS_CLOCK_MONOTONIC when BOOST_CHRONO_WINDOWS_API] [Define BOOST_CHRONO_HAS_CLOCK_MONOTONIC when BOOST_CHRONO_WINDOWS_API]                  [Closed]]
    [[7]    [min/max macros intrussion] [Take care of Boost min/max recommendations]                  [Closed]]
    [[8]    [declaration of 'typedef class boost::chrono::duration<..> changes meaning of 'duration'] [complete qualification when defining nested typedef duration on clocks to avoid the following compile error:]                  [Closed]]
    [[9]    [VC++ warnings] [disable VC++ foolishness]                  [Closed]]
]    
[table
    [[Ticket]             [Description]          [Resolution] [State]]
    
    [[10]    [conversion warning in test_duration] [removal of conversion warning in test_duration]                  [Closed]]
    [[11]    [MSVC reports a warning instead of an error when there is an integral constant overflow] [manage with MSVC reporting a warning instead of an error when there is an integral constant overflow]                  [Closed]]
    [[12]    [ambiguities with MSVC when using detail:: namespace] [Qualify with boost::detail boost::chrono::detail ]                  [Closed]]
    [[13]    [warning C4251: 'boost::chrono::run_timer::m_format' : class 'std::basic_string<_Elem,_Traits,_Ax>' needs to have dll-interface to be used by clients of class 'boost::chrono::run_timer'] [don't include inlines functions using the std::string m_format]                  [Closed]]
    [[14]    [Bad use of duration(0) on template classes] [remplace by duration::zero()]                  [Closed]]
    [[15]    [suspend doesn't works: partial_ not initialized] [initialize with duration::zero()]                  [Closed]]
    [[16]    [suspend doesn't works: elapsed doesn't take care of partial_] [take care of partial]                  [Closed]]
    [[17]    [suspend doesn't works: bad use of system::error_code & ec] [replace by system::error_code ec]                  [Closed]]
    [[18]    [warnings on mingw-gcc.4.4:

..\..\../boost/chrono/chrono.hpp: In copy constructor 'boost::chrono::time_point<boost::chrono::process_cpu_clock,
boost::chrono::duration<boost::chrono::process_cpu_clock::times, boost::ratio<1ll, 1000000000ll> > 
>::time_point(const boost::chrono::time_point<boost::chrono::process_cpu_clock,
boost::chrono::duration<boost::chrono::process_cpu_clock::times, boost::ratio<1ll, 1000000000ll> > >&)':
..\..\../boost/chrono/chrono.hpp:816: warning: suggest parentheses around '&&' within '||'
..\..\../boost/chrono/chrono.hpp:816: warning: suggest parentheses around '&&' within '||'

] [???]                  [Closed]]
    [[19]    [Use of Specific formatters doesn't works] []                  [Closed]]

    [[20]    [boost/chrono/scoped_suspend.hpp(31) : warning C4520: 'boost::chrono::scoped_suspend<Clock>' : multiple default constructors specified
] [Remove the default constructor deletion ]                  [Closed]]
    [[21]    [suspendible_clock_test doesn't works in my mingw environement] [(issue with tss)]                  [*Open*]]
    [[22]    [error_code not initialized] [Use ec.clear() before throwing a exception.]                  [Closed]]
    [[23]    [boost/thread/detail/cv_status.hpp file was not commited] [commit file]                  [Closed]]
    [[24]    [Boost.Conversion was not packaged] [Package it]                  [Closed]]
    [[25]    [Valgrind issue: Conditional jump or move depends on uninitialised value(s)] [Replace the test]                  [Closed]]
    [/[#]    [XXXX] [XXXX]                  [Closed]]
]





[endsect]

[/=====================================]
[section:perf  Appendix H: Performances]
[/=====================================]


We have run some program changing how the reporting is done.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

The programs are either single-threaded or multi-threaded.

Two kind of inner functions are used: recursive or non recursive. In order to test the influence of nesting reports, the non recursive functions use up to 10 nesting levels, depending on its parameter.

the function at level n is defined as follows

    void fn(long v) {
        // reporting or not
        stopclock<> _;
        // burn some time
        for ( long i = 0; i < v; ++i )
            res+=std::sqrt( res+123.456L+i );  // burn some time
        if (v==0) return;

        if (v%(n-1)==0) fn-1(v-1);
        if (v%(n-2)==0) fn-2(v-1);
        ...
        f1(v-1);
    }

This gives a variable number in nesting reporting depending on the parameter, with a variable lifetime.

[heading Single-Threaded Recursive function]

We have run the same program and changed how the reporting is done.

The programm creates two thread of execution. the thread entry point calls a function which makes some calculation depending on its parameter and call recursivelly itself decreasing the parameter.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

[heading Multi-Threaded Recursive function]

We have run the same program and changed how the reporting is done.

The programm creates two thread of execution. the thread entry point calls a function which makes some calculation depending on its parameter and call recursivelly itself decreasing the parameter.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

[endsect]

[/=====================================]
[section:todo  Appendix I: Future plans]
[/=====================================]
[heading Tasks to do before review]

* Complete documentation
* Fully implement error handling, with test cases.
* Fix open isues.

[heading For later releases]

* Use of C++0x feature constexpr, when available.
* Define a C++98 variadic template emmulation of __common_type__

[endsect]
[endsect]
