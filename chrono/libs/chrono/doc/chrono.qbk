[/
 / Copyright (c) 2008 Howard Hinnant
 / Copyright (c) 2006, 2008 Beman Dawes
 / Copyright (c) 2009-20010 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[article Boost.Chrono
    [quickbook 1.3]
    [authors [Hinnant, Howard]]
    [authors [Dawes, Beman]]
    [authors [Botet Escriba, Vicente J.]]
    [copyright 2008 Howard Hinnant]
    [copyright 2006, 2008 Beman Dawes]
    [copyright 2009-2010 Vicente J. Botet Escriba]
    [purpose Time utilities]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[def __Boost_Chrono__ [*Boost.Chrono]]

[/
[section Preface]

[:[".]]
[:[*['-- ]]]

[endsect]
/]

[warning Chrono is not part of the Boost libraries.]

[/===============]
[section Overview]
[/===============]

[/==================]
[heading Description]
[/==================]

The Boost Chrono library provides:

*  The C++0x Standard Library's `common_type`.
*  The C++0x Standard Library's compile-time rational arithmetic.
*  The C++0x Standard Library's time utilities, including:
    * Class template `duration`
    * Class template `time_point`
    * Clocks:
        * `system_clock`
        * `monotonic_clock`
        * `high_resolution_clock`
    * typeof registration for classes `duration` and `time_point`

* Process clocks:
    * `process_real_CPU_clocks`, capturing real-CPU times.
    * `process_user_CPU_clocks`, capturing user-CPU times.
    * `process_system_CPU_clocks`, capturing system-CPU times.
    * `process_cpu_clock`, tuple-like class capturing at once real, user-CPU, and system-CPU times.

* Thread clock

* Suspendible Clock
    * Suspendible Clock concept
    * template class suspendible_clock<>
    * Added scope_suspend which do suspend/resume if the Clock is a model of Suspendible Clock concept, and nothing otherwise.

* Stopwatches:
    * `stopwatch`, capturing elapsed Clock times.
    * `stopwatch_accumulator`, capturing cummulated elapsed Clock times.
    * scoped helper classes allowing to pairwise start/stop operations, suspend/resume and resume/suspend a Stopwatch.

* Stopclocks or Stopwatch reporters:
    * `stopwatch_reporter`, convenient reporting of models of Stopwatch results.
    * `stopclock<Clock>` shortcut of `stopwatch_reporter<stopwatch<Clock>>`
    * Allows wide characters


[/====================================]
[heading How to Use This Documentation]
[/====================================]

This documentation makes use of the following naming and formatting conventions.

* Code is in `fixed width font` and is syntax-highlighted.
* Replaceable text that you will need to supply is in [~italics].
* If a name refers to a free function, it is specified like this:
  `free_function()`; that is, it is in code font and its name is followed by `()`   to indicate that it is a free function.
* If a name refers to a class template, it is specified like this:   `class_template<>`; that is, it is in code font and its name is followed by `<>`   to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in code font and its name is followed by `()` to   indicate that it is a function-like macro. Object-like macros appear without the   trailing `()`.
* Names that refer to /concepts/ in the generic programming sense are  specified in CamelCase.

[note In addition, notes such as this one specify non-essential information that provides additional background or rationale.]

Finally, you can mentally add the following to any code fragments in this document:

    // Include all of Chrono files
    #include <boost/type_traits/common_type.hpp>
    #include <boost/ratio.hpp>
    #include <boost/chrono.hpp>
    #include <boost/stopwatches.hpp>

[/=================]
[section Motivation]
[/=================]

See [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] which is very informative and provides motivation for key design decisions for `common_type`, `ratio` and `chrono`. The following sections are an extract from this document.

[section Common type]

`common_type` has been a recurring theme in many places for many years. We've previously known it as promote and examples of it are spread throughout boost. It has been reinvented independently several times, because it is so useful.

Andrei Alexandrescu recently pointed us at a D library: std.traits - D Programming Language - Digital Mars, which became the motivation for this particular name, and the variadic nature of this trait.

In a nutshell, `common_type` is a trait that takes 1 or more types, and returns a type which all of the types will convert to. The default definition demands this conversion be implicit. However the trait can be specialized for user-defined types which want to limit their inter-type conversions to explicit, and yet still want to interoperate with the `common_type` facility.

[*Example:]

    template <class T, class U>
    typename common_type<complex<T>, complex<U> >::type
    operator+(complex<T>, complex<U>);

In the above example, "mixed-mode" complex arithmetic is allowed. The return type is described by `common_type`. For example the resulting type of adding a `complex<int>` and `complex<double>` might be a `complex<double>`. Another choice for the author might be:

    template <class T, class U>
    complex<typename common_type<T, U>::type>
    operator+(complex<T>, complex<U>);

Here is how someone might produce a variadic comparison function:

    template <class ...T>
    typename common_type<T...>::type
    min(T... t);

This is a very useful and broadly applicable utility. The `duration` and `time_point` facilities use it to make multi-precision arithmetic seamless and exact.


[endsect]

[section Ratio]

`ratio` is a general purpose utility inspired by Walter Brown allowing one to easily and safely compute rational values at compile time. The `ratio` class catches all errors (such as divide by zero and overflow) at compile time. It is used in the `duration` and `time_point` classes to efficiently create units of time. It can also be used in other "quantity" libraries (both std-defined and user-defined), or anywhere there is a rational constant which is known at compile time. The use of this utility can greatly reduce the chances of run time overflow because the `ratio` (and any ratios resulting from `ratio` arithmetic) are always reduced to lowest terms.

`ratio` is a template taking two intmax_ts, with the second defaulted to 1. In addition to cop^y constructors and assignement, it only has two public members, both of which are static const intmax_t. One is the numerator of the `ratio` and the other is the denominator. The `ratio` is always normalized such that it is expressed in lowest terms, and the denominator is always positive. When the numerator is 0, the denominator is always 1.

[*Example:]

    typedef ratio<5, 3>   five_thirds;       // five_thirds::num == 5, five_thirds::den == 3
    typedef ratio<25, 15> also_five_thirds;  // also_five_thirds::num == 5, also_five_thirds::den == 3
    typedef ratio_divide<five_thirds, also_five_thirds>::type one;  // one::num == 1, one::den == 1

This facility also includes convenience typedefs for the SI prefixes `atto` through `exa` corresponding to their internationally recognized definitions (in terms of `ratio`). This is a tremendous syntactic convenience. It will prevent errors in specifying constants as one no longer has to double count the number of zeros when trying to write million or billion.

[*Example:]

    typedef ratio_multiply<ratio<5>, giga>::type _5giga;  // _5giga::num == 5000000000, _5giga::den == 1
    typedef ratio_multiply<ratio<5>, nano>::type _5nano;  // _5nano::num == 1, _5nano::den == 200000000

[endsect]


[section Duration]

The `duration` is the heart of this library. The interface that the user will see in everyday use is nearly identical to that of Boost.DateTime time `duration`s authored by Jeff Garland, both in syntax and in behavior. This has been a very popular boost library for 7 years. There is an enormous positive history with this interface.

The library consists of six units of time `duration`:

* `hours`
* `minutes`
* `seconds`
* `milliseconds`
* `microseconds`
* `nanoseconds`

These units were chosen as a subset of the boost library because they are the most common units used when sleeping, waiting on a condition variable, or waiting to obtain the lock on a mutex. Each of these units is nothing but a thin wrapper around a signed integral count. That is, when you construct `minutes(3)`, all that happens is a `3` is stored inside of minutes. When you construct `microseconds(3)`, all that happens is a `3` is stored inside of microseconds.

The only context in which these different types differ is when being converted to one another. At this time, unit-specific compile-time conversion constants are used to convert the source unit to the target unit. Only conversions from coarser units to finer units are allowed (in boost). This restriction ensures that all conversions are always exact. That is, `microseconds` can always represent any value `minutes` has.

In Boost.DateTime, these units are united via inheritance. __Boost_Chrono__ instead unites these units through the class template `duration`. That is, in __Boost_Chrono__ all six of the above units are nothing but typedefs to different instantiations of `duration`. This change from Boost.DateTime has a far reaching positive impact, while not changing the syntax of the everyday use at all.

The most immediate positive impact is that the library can immediately generate any unit, any precision it needs. This is sometimes necessary when doing comparisons or arithmetic between `duration`s of differing precision, assuming one wants the comparison and arithmetic to be exactly correct.

A secondary benefit is that by publishing the class template `duration` interface, user code can very easily create `duration`s with any precision they desire. The `ratio` utility is used to specify the precision, so as long as the precision can be expressed by a rational constant with respect to seconds, this framework can exactly represent it (one third of a second is no problem, and neither is one third of a `femto` second). All of this utility and flexibility comes at no cost just by making use of the no-run-time-overhead `ratio` facility.

In Boost.DateTime, `hours` does not have the same representation as `nanoseconds`. The former is usually represented with a `long` whereas a `long long` is required for the latter. The reason for this is simply range. You don't need many hours to cover an extremely large range of time. But this isn't true of nanoseconds. Being able to reduce the sizeof overhead for some units when possible, can be a significant performance advantage.

__Boost_Chrono__ continues, and generalizes that philosophy. Not only can one specify the precision of a `duration`, one can also specify its representation. This can be any integral type, or even a floating point type. Or it can be a user-defined type which emulates an arithmetic type. The six predefined units all use signed integral types as their representation. And they all have a minimum range of +/- 292 years. `nanoseconds` needs 64 bits to cover that range. `hours` needs only 23 bits to cover that range.

[heading So What Exactly is a `duration` and How Do I Use One?]

A `duration` has a representation and a tick period (precision).

    template <class Rep, class Period = ratio<1> > class duration;

The representation is simply any arithmetic type, or an emulation of such a type. The representation stores a count of ticks. This count is the only data member stored in a `duration`. If the representation is floating point, it can store fractions of a tick to the precision of the representation. The tick period is represented by a `ratio` and is encoded into the `duration`'s type, instead of stored. The tick period only has an impact on the behavior of the `duration` when a conversion between different `duration`'s is attempted. The tick period is completely ignored when simply doing arithmetic among like `duration`s.

[*Example:]

    typedef duration<long, ratio<60> > minutes;
    minutes m1(3);                 // m1 stores 3
    minutes m2(2);                 // m2 stores 2
    minutes m3 = m1 + m2;          // m3 stores 5

    typedef duration<long long, micro> microseconds;
    microseconds us1(3);           // us1 stores 3
    microseconds us2(2);           // us2 stores 2
    microseconds us3 = us1 + us2;  // us3 stores 5

    microseconds us4 = m3 + us3;   // us4 stores 300000005

In the final line of code above, there is an implicit conversion from minutes to microseconds, resulting in a relatively large number of microseconds.

If you need to access the tick count within a `duration`, there is a member `count()` which simply returns the stored tick count.

    long long tc = us4.count();    // tc is 300000005

These `duration`s have very simple, very predictable, and very observable behavior. After all, this is really nothing but the time tested interface of Jeff's boost time `duration` library (unified with templates instead of inheritance).

[heading What happens if I assign `m3 + us3` to `minutes` instead of `microseconds`?]

    minutes m4 = m3 + us3;

It won't compile. The rationale is that implicit truncation error should not be allowed to happen. If this were to compile, then `m4` would hold `5`, the same value as `m3`. The value associated with `us3` has been effectively ignored. This is similar to the problem of assigning a double to an `int`: the fractional part gets silently discarded.

[heading But what if the truncation behavior is what I want to do?]

There is a `duration_cast` facility to explicitly ask for this behavior:

    minutes m4 = duration_cast<minutes>(m3 + us3);  // m4.count() == 5

In general, one can perform `duration` arithmetic at will. If `duration_cast` isn't used, and it compiles, the arithmetic is exact. Any place one wants to override this exact arithmetic behavior, duration_cast can be used to explicitly specify that desire. The `duration_cast` has the same efficiency as the implicit conversion, and will even be exact as often as it can.

[heading I'm trafficking in floating point `duration`s. I don't want to deal with writing `duration_cast` all over the place. I'm content with the precision of my floating point representation]

Not a problem. When the destination of a conversion has floating point representation, all conversions are allowed to happen implicitly.

    typedef duration<double, ratio<60> > dminutes;
    dminutes dm4 = m3 + us3;  // dm4.count() == 5.000000083333333

[heading How expensive is all of this?]

If you were writing these conversions by hand, you could not make it more efficient. The use of `ratio` ensures that all conversion constants are simplified as much as possible at compile time. This usually results in the numerator or denominator of the conversion factor simplifying to `1`, and being subsequently ignored in converting the run time values of the tick counts.

[heading How complicated is it to build a function taking a `duration` parameter?]

There are several options open to the user:

* If the author of the function wants to accept any `duration`, and is willing to work in floating point `duration`s, he can simply use any floating point `duration` as the parameter:

          void f(duration<double> d)  // accept floating point seconds
          {
              // d.count() == 3.e-6 when passed microseconds(3)
          }

          f(microseconds(3));

* If the author of the function wants to traffic only in integral `duration`s, and is content with handling nothing finer than say nanoseconds (just as an example), he can simply specify nanoseconds as the parameter:

          void f(nanoseconds d)
          {
              // d.count() == 3000 when passed microseconds(3)
          }

          f(microseconds(3));

In this design, if the client wants to pass in a floating point `duration`, or a `duration` of finer precision than nanoseconds, then the client is responsible for choosing his own rounding mode in the conversion to nanoseconds.

          duration<double> s(1./3);  // 1/3 of a second
          f(duration_cast<nanoseconds>(s));  // round towards zero in conversion to nanoseconds

In the example above, the client of f has chosen "round towards zero" as the desired rounding mode to nanoseconds. If the client has a `duration` that won't exactly convert to nanoseconds, and fails to choose how the conversion will take place, the compiler will refuse the call:

          f(s);  // does not compile

* If the author of the function wants to accept any `duration`, but wants to work with integral representations and wants to control the rounding mode internally, then he can template the function:

          template <class Rep, class Period>
          void f(duration<Rep, Period> d)
          {
              // convert d to nanoseconds, rounding up if it is not an exact conversion
              nanoseconds ns = duration_cast<nanoseconds>(d);
              if (ns < d)
                  ++ns;
              // ns.count() == 333333334 when passed 1/3 of a floating point second
          }

          f(duration<double>(1./3));

*  If the author in the example does not want to accept floating point based `duration`s, he can enforce that behavior like so:

          template <class Period>
          void f(duration<long long, Period> d)
          {
              // convert d to nanoseconds, rounding up if it is not an exact conversion
              nanoseconds ns = duration_cast<nanoseconds>(d);
              if (ns < d)
                  ++ns;
              // ns.count() == 333333334 when passed 333333333333 picoseconds
          }

          f(duration<long long, pico>(333333333333));  // About 1/3 of a second worth of picoseconds

Clients with floating point `duration`s who want to use f will now have to convert to an integral `duration` themselves before passing the result to f.

In summary, the author of f has quite a bit of flexibility and control in the interface he wants to provide his clients with, and easy options for manipulating that `duration` internal to his function.

[endsect]

[section Clocks]

While `duration`s only have precision and representation to concern themselves, clocks and `time_point`s are intimately related and refer to one another. Because clocks are simpler to explain, we will do so first without fully explaining `time_point`s. Once clocks are introduced, it will be easier to then fill in what a `time_point` is.

A clock is a concept which bundles 3 things:

# A concrete `duration` type.
# A concrete `time_point` type.
# A function called now() which returns the concrete `time_point`.

__Boost_Chrono__ provides 3 concrete clocks:

# system_clock
# monotonic_clock
# high_precision_clock

A given platform may not be able to supply all three of these clocks. The user is also able to easily create more clocks.

Given a clock named Clock, it will have:

    class Clock {
    public:
        typedef an arithmetic-like type            rep;
        typedef an instantiation of ratio          period;
        typedef boost::chrono::duration<rep, period> duration;
        typedef boost::chrono::time_point<Clock>     time_point;
        static const bool is_monotonic =           true or false;

        static time_point now();
    };

One can get the current time from Clock with:

    Clock::time_point t1 = Clock::now();

And one can get the time `duration` between two `time_point`s associated with Clock with:

    Clock::duration d = t1 - Clock::now();

And one can specify a past or future `time_point` with:

    Clock::time_point t2 = Clock::now() + d;

Note how even if a particular clock becomes obsolete, the next clock in line will have the same API. There is no new learning curve to come up. The only source code changes will be simply changing the type of the clock. The same `duration` and `time_point` framework continues to work as new clocks are introduced. And multiple clocks are safely and easily handled within the same program.

[endsect]

[section Time Point]

A `time_point` represents a point in time, as opposed to a `duration` of time. Another way of saying the same thing, is that a `time_point` represents an epoch plus or minus a `duration`. Examples of `time_point`s include:

* 3 minutes after the computer booted.
* 03:14:07 UTC on Tuesday, January 19, 2038
* 20 milliseconds after I started that timer.

In each of the examples above, a different epoch is implied. Sometimes an epoch has meaning for several millennia. Other times the meaning of an epoch is lost after a while (such as the start of a timer, or when the computer booted). However, if two `time_point`s are known to share the same epoch, they can be subtracted, yielding a valid `duration`, even if the definition of the epoch no longer has meaning.

In __Boost_Chrono__, an epoch is a purely abstract and unspecified concept. There is no type representing an epoch. It is simply an idea that relates (or doesn't) `time_point`s to a clock, and in the case that they share a clock, `time_point`s to one another. `time_point`s associated with different clocks are generally not interoperable unless the relationship between the epochs associated with each clock is known.

[heading So What Exactly is a `time_point` and How Do I Use One?]

A `time_point` has a clock and a `duration`.

    template <class Clock, class Duration = typename Clock::duration> class time_point;

The `time_point`'s clock is not stored. It is simply embedded into the `time_point`'s type and serves two purposes:

# Because `time_point`s originating from different clocks have different types, the compiler can be instructed to fail if incompatible `time_point`s are used in inappropriate ways.
# Given a `time_point`, one often needs to compare that `time_point` to "now". This is very simple as long as the `time_point` knows what clock it is defined with respect to.

A `time_point`'s `duration` is stored as the only data member of the `time_point`. Thus `time_point`s and their corresponding `duration` have exactly the same layout. But they have very different meanings. For example, it is one thing to say I want to sleep for 3 minutes. It is a completely different thing to say I want to sleep until 3 minutes past the time I started that timer (unless you just happened to start that timer now). Both meanings (and options for sleeping) have great practical value in common use cases for sleeping, waiting on a condition variable, and waiting for a mutex's lock. These same concepts and tools are found (for example) in Ada.

A timer example:

    void f()
    {
        monotonic_clock::time_point start = monotonic_clock::now();
        g();
        h();
        duration<double> sec = monotonic_clock::now() - start;
        cout << "f() took " << sec.count() << " seconds\n";
    }

Note that if one is using the `duration` between two clock `time_point`s in a way where the precision of the `duration` matters, it is good practice to convert the clock's native `duration` to a known `duration`. This insulates the code from future changes which may be made to the clock's native precision in the future. For example monotonic_clock could easily be based on the clock speed of the cpu. When you upgrade to a faster machine, you do not want your code that assumed a certain tick period of this clock to start experiencing run time failures because your timing code has silently changed meaning.

A delay loop example:

    // delay for at least 500 nanoseconds:
    auto go = monotonic_clock::now() + nanoseconds(500);
    while (monotonic_clock::now() < go)
        ;

The above code will delay as close as possible to half a microsecond, no matter what the precision of monotonic_clock is. The more precise `monotonic_clock` becomes, the more accurate will be the delay to 500 nanoseconds.

[endsect]


[section Stopwatches]

Knowing how long a program, a function or a specific block takes to execute is useful in both test and production environments.
__Boost_Chrono__ introduces the Stopwatch concept which captures the mechanism to measure the elapsed time.
A Stopwatch allows to start, stop, suspend and resume the measure of the eleapsed time.
`stopwatch<>` is the basic model of Stopwatch allowing to make a single measure.

At the user level, the main use case of measuring the elapsed time is to report these measures on the display.
`stopwatch_reporter<>` provides a run time reporting package that can be invoked in a single line of code to report the usage of a Clock.
For example

    using namespace boost::chrono;
    int f1(long j) {
        stopwatch_reporter<stopwatch<> > _;

        for ( long i = 0; i < j; ++i )
            std::sqrt( 123.456L );  // burn some time

        return 0;
    }
    int main()  {
        f1(100000);
        f1(200000);
        f1(300000);
        return 0;
    }

Will produce the following output

    0.006s
    0.011s
    0.017s

[heading Stopwatches accumulation and statistics]

The preceding stopwatch manage only with a measure. It is also interesting to have an statisitical view of these times, for example the sum, min, max and mean. `stopwatch_accumulator<>` associates an accumulator with a stopwatch, so we are able to retrieve any statistical feature Boost.Accumulator provides.

For example

    using namespace boost::chrono;
    int f1(long j) {
        static stopwatch_reporter<stopwatch_accumulator<> > sw;
        stopwatch_reporter<stopwatch_accumulator<> >::scoped_run _(sw);

        for ( long i = 0; i < j; ++i )
            std::sqrt( 123.456L );  // burn some time

        return 0;
    }
    int main()  {
        f1(100000);
        f1(200000);
        f1(300000);
        return 0;
    }

Will produce the following output

    3 times, sum=0.034s, min=0.006s, max=0.017s, mean=0.011s


[heading Wall clock versus system and user time]

It is also helpful if such timing information is broken down into real (wall clock) time, CPU time spent by the user, and CPU time spent by the operating system servicing user requests.

__Boost_Chrono__ provides 3 concrete process clocks:

# `process_real_CPU_clock`,
# `process_user_CPU_clock`,
# `process_system_CPU_clock`

providing a thin wrappers around the operating system's process timer API. For POSIX-like systems, that's the times() function, while for Windows, it's the GetProcessTimes() function.

These clocks capture the specific time unitarily. __Boost_Chrono__ provides also a clock `process_cpu_clock` that captures the three times at once.

    using namespace boost::chrono;
    int main()
    {
        stopwatch_reporter<stopwatch<process_cpu_clock> > _;
      // ...
    }

Will produce the following output

    real 0.034s, cpu 0.031s (93.0%), user 0.031s, system 0.000s

As this is one of the expression more commonly use, the library provides a stopclock shortcut so the preceding can be writen as

    using namespace boost::chrono;
    int main()
    {
        stopclock<> _;
      // ...
    }


[heading How reliable are these measures?]

[info this section need to be reworked, the ideas are there, but ...]

There are three context on which you can get unreliable measures:

# the precission of your clock. If the precission of your clock is 10ms you can not be able to measure the time spent by blocks of code that takes the same order of magnitude. The library provides a hig_resolution_clock that gives you the higher resolution available on your platform. Respect to the precission, nothing to do except to take the clock with the highest resolution and measures blocks of code that will spent time having more than one order of magnitude the precission of the clock.

    #include <boost/chrono/thread_clock.hpp>
    ...
        stopclock<high_resolution_clock> _;


# When your application is multithreaded, and you use a process clock, the time you get is the delay during which your block has been executed, in concurrency with the other threads of execution. If what you want is the time spent by this specific thread another clock is needed. The library provide a thread_clock that returns the time spent by the thread on platforms providing this kind of data. It can be used as follows

    #include <boost/chrono/thread_clock.hpp>
    ...
    #if defined(BOOST_CHRONO_HAS_THREAD_CLOCK)
        stopclock<thread_clock> _;
    #else
        stopclock<process_real_cpu_clock> _;
    #endif

# Nested stopclocks (usually nested function calls where each function contains a stopclock). When the nesting is deep enough, the cumulative overhead of all the stopclock functionality make the data unreliable except for the inner-most trace points. The question is, how much time is related to the application code we want to measure and how much to the fact we are meassuring and logging in inner blocks?

Some measures let us think that most of the time spent by the stopclock mechanism is associated to the logging part. There are two things we can do to make the difference :

* Avoid expensive operations as logging while doing the measures. Note that reporting in itself is not too expensive as far as we don't need to flush the buffer. This can be achieved either using a stopclock accumulator, 'i.e. don't report until all the measures have been compiled and then report some statistics or using an asynchronous stream.

* Introduce some cheap mechanism that allows us to make the difference between the application time and the intrinsec stopclock time. When the precission of the clock is enough, we can suspend the counting of the Clock while we are spending time reporting the measures, and resume it once the work is done. The library provide a Clock wrapper suspendible_clock that make the resulting clock suspendible. The stopwatch_reporter is able to detect if the CLock is Suspendible and then suspend/resume the clock while doing the report.

    stopclock<suspendible_clock<Clock> > _;


See the performances section for more deep details.

[endsect]
[endsect]

[section Caveat emptor]

The underlying clocks provided by operating systems are subject to many seemingly arbitrary policies and implementation irregularities. That's a polite way of saying they tend to be flakey, and each operating system or even each clock has its own cruel and unusual forms of flakiness. Don't bet the farm on their accuracy, unless you have become deeply familiar with exactly what the specific operating system is guaranteeing, which is often very little.

[endsect]
[endsect]


[/==============================]
[section:users_guide Users'Guide]
[/==============================]

[/======================================]
[section:getting_started Getting Started]
[/======================================]

[/======================================]
[section:install Installing Chrono]
[/======================================]

[/=================================]
[heading Getting __Boost_Chrono__ ]
[/=================================]

You can get the last stable release of __Boost_Chrono__ by downloading [^chrono.zip] from the
[@http://www.boost-consulting.com/vault/index.php?directory=System Boost Vault]

You can also access the latest (unstable?) state from the [@https://svn.boost.org/svn/boost/sandbox/chrono Boost Sandbox].

[/==========================================]
[heading Where to install __Boost_Chrono__? ]
[/==========================================]

The simple way is to decompress (or checkout from SVN) the file in your BOOST_ROOT directory.

Othesewise, if you decompress in a different directory, you will need to comment some lines, and uncomment and change others in the build/Jamfile and test/Jamfile. Sorry for this, but I have not reached yet to write a Jamfile that is able to work in both environements and use the BOOST_ROOT variable. Any help is welcome.

[/=================================]
[heading Building __Boost_Chrono__ ]
[/=================================]

__Boost_Chrono__ is not a header only library. You need to compile it before use.

    bjam libs/chrono/build

[/===================]
[heading Requirements]
[/===================]

[*Boost.Bitfield] depends on some Boost libraries. For these specific parts you must use either Boost version 1.39.0 or the version in SVN trunk (even if older version should works also).

In particular, __Boost_Chrono__ depends on:

[variablelist
[
    [[@http://www.boost.org/libs/accumulator [*Boost.Accumulator]]] [for accumulator_set, and statistics features]
]
[
    [[@http://www.boost.org/libs/config [*Boost.Config]]] [for configuration purposes, ...]
]
[
    [[@http://www.boost.org/libs/exception [*Boost.Exception]]] [for throw_exception, ...]
]
[
    [[@http://www.boost.org/libs/integer [*Boost.Integer]]] [for cstdint conformance, ...]
]
[
    [[@http://www.boost.org/libs/system [*Boost.System]]] [for error_code, ...]
]
[
    [[@http://www.boost.org/libs/type_traits [*Boost.TypeTraits]]] [for is_base, ...]
]
[
    [[@http://www.boost.org/libs/typeof [*Boost.Typeof]]] [for typeof, ...]
]
[
    [[@http://www.boost.org/libs/utility [*Boost.UtiliTy/EnableIf]]] [for enable_if, ...]
]
]


[/=========================================================]
[heading Building an executable that uses __Boost_Chrono__ ]
[/=========================================================]

In addition to link with the Boost Chrono library you need also to link with the Boost System library.

[/=========================]
[heading Exceptions safety ]
[/=========================]

All functions in the library are exception-neutral and provide strong guarantee of exception safety as long as the underlying parameters provide it.

[/=====================]
[heading Thread safety ]
[/=====================]

All functions in the library are thread-unsafe except when noted explicitly.

[/========================]
[heading Tested compilers ]
[/========================]

The implementation will eventually work with most C++03 conforming compilers.
Current version has been tested on:

Windows with

* MSVC 10.0
* MSVC 9.0 Express
* MSVC 8.0

[/* Intel 11.0]

Scientific Linux with

* GCC 4.1.2

Cygwin with

* GCC 3.4.4
* GCC 4.3.2

MinGW with

* GCC 4.4.0

Initial version was tested on:

MacOS with GCC 4.2.4

Ubuntu Linux with GCC 4.2.4

[note Please let us know how this works on other platforms/compilers.]

[note Please send any questions, comments and bug reports to boost <at> lists <dot> boost <dot> org.]

[endsect]
[/====================]
[section Hello World! ]
[/====================]

If all you want to do is to time a program's execution:

    #include <boost/chrono/stopclock.hpp>

    ...

    // add this in the scope you want to time,
    // at the point you want the timer to start.
    boost::chrono::stopclock<> rt;

Here is a complete program (stopclock_example.cpp):

    #include <boost/chrono/stopclock.hpp>
    #include <cmath>

    int main()
    {
      boost::chrono::stopclock<> t;

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L ); // burn some time

      return 0;
    }

Debug build output was:

    real 0.832s, cpu 0.813s (97.7%), user 0.813s, system 0.000s

In other words, the program took 0.832 real-time (i.e. wall clock) seconds to execute, while the operating system (Windows in this case) charged 0.813 seconds of CPU time to the user and 0 seconds to the system. The total CPU time reported was 0.813 seconds, and that represented utilization of 97.7% of the real-time seconds.

[endsect]

[endsect]

[section Tutorial]

[section How to define a thread clock]

On posix systems for which the macro _POSIX_THREAD_CPUTIME is defined we can get the time associated to a specific thread.

    class thread_clock {
    public:
        typedef nanoseconds                          duration;
        typedef duration::rep                        rep;
        typedef duration::period                     period;
        typedef chrono::time_point<process_real_cpu_clock>    time_point;
        static const bool is_monotonic =             true;

        static time_point now( ) {
            // get the current thread
            pthread_t pth=pthread_self(void);
            // get the clock_id associated to the current thread
            clockid_t clock_id;
            pthread_getcpuclockid(pth, clock_id);
            // get the timespec associated to the thread clock
            struct timespec ts;
            if ( ::clock_gettime( clock_id, &ts ) )
            {
                boost::throw_exception(
                system::system_error( errno, system::system_category, "chrono::thread_clock" ));
            }

            // transform to nanoseconds
            return time_point(duration(
                static_cast<thread_clock::rep>( ts.tv_sec ) * 1000000000 + ts.tv_nsec));

        }
        static time_point now( system::error_code & ec ) {
            // get the current thread
            pthread_t pth=pthread_self(void);
            // get the clock_id associated to the current thread
            clockid_t clock_id;
            pthread_getcpuclockid(pth, clock_id);
            // get the timespec associated to the thread clock
            struct timespec ts;
            if ( ::clock_gettime( clock_id, &ts ) )
            {
              ec.assign( errno, system::system_category );
              return time_point();
            }
            ec.clear();
            // transform to nanoseconds
            return time_point(duration(
                static_cast<thread_clock::rep>( ts.tv_sec ) * 1000000000 + ts.tv_nsec));

        }
    };
[endsect]

[section How can I prefix each report with `BOOST_CURRENT_FUNCTION` function signature?]

You will need to give a specific format to you stopclock. You just need to concatenate the your specific patter to the default_format of the formatter.

For example, for a stopclock_accumulator the default formatter is stopwatch_accumulator_formatter, this you will need to do something like:

    static stopclock_accumulator<> acc(
        std::string(BOOST_CURRENT_FUNCTION) + ":  " + stopwatch_accumulator_formatter::default_format()
    );
    stopclock_accumulator<>::scoped_run _(acc);


Some of you will say that this is too long to type just to get the a report. You can of course define your own macro as

    #define REPORT_FUNCTION_ACCUMULATED_LIFETIME\
        static boost::chrono::stopclock_accumulator<> BOOST_JOIN(_boost_chrono_stopclock_accumulator_, __LINE__)( \
            std::string(BOOST_CURRENT_FUNCTION) + ":  " + boost::chrono::stopwatch_accumulator_formatter::default_format() \
        ); \
        boost::chrono::stopclock_accumulator<>::scoped_run BOOST_JOIN(_boost_chrono_stopclock_accumulator_run_, __LINE__)(BOOST_JOIN(_boost_chrono_stopclock_accumulator_, __LINE__))


With this macro you will just have

    void foo()
    {
        REPORT_FUNCTION_ACCUMULATED_LIFETIME() ;
        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
        // ...
    }

[endsect]

[section How can I prefix each report with `__FILE__[__LINE__]` pattern?]

When you want to prefix with the `__FILE__[__LINE__]` pattern you can follow the same technique as described below:

    #define REPORT_LINE_ACCUMULATED_LIFETIME \
        static stopclock_accumulator<> BOOST_JOIN(_boost_chrono_stopclock_accumulator_, __LINE__)( \
            std::string(__FILE__) + "[" + BOOST_STRINGIZE(__LINE__) + "] " + stopwatch_accumulator_formatter::default_format() \
        ); \
        stopclock_accumulator<>::scoped_run BOOST_JOIN(_boost_chrono_stopclock_accumulator_run_, __LINE__) (BOOST_JOIN(_boost_chrono_stopclock_accumulator_, __LINE__))

Now you can mix fcntion and line reports as follows

    void foo()
    {
        REPORT_FUNCTION_ACCUMULATED_LIFETIME;
        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
        {
            REPORT_LINE_ACCUMULATED_LIFETIME;
            boost::this_thread::sleep(boost::posix_time::milliseconds(200));
        }

    }

[endsect]

[section Can I use an stopclock accumulator which is not static?]

The typical example of stopclock_accumulator is to get statistical measures of the time a function takes for each one of its calls. You an also use stopclock_accumulator to get statistical measures of the time a given loop takes for each one of its laps.

        stopclock_accumulator<> acc(
            std::string(__FILE__) + "[" + BOOST_STRINGIZE(__LINE__) + "] " + stopwatch_accumulator_formatter::default_format()
        );
        for (int i=0; i<N; i++) {
            stopclock_accumulator<>::scoped_run _(acc);
            // ...
        }


[endsect]

[section How can I suspend a stopwatch?]

    #include <boost/chrono/stopwatch.hpp>
    #include <cmath>
    #include <boost/thread.hpp>


    using namespace boost::chrono;
    double res;
    void f1(long j)
    {
        stopwatch<>::reporter _(BOOST_CHRONO_STOPWATCH_FUNCTION_FORMAT);
        for (long i =0; i< j; i+=1)
            res+=std::sqrt( res+123.456L+i );  // burn some time
        stopwatch<>::reporter::scoped_suspend s(_);
        boost::this_thread::sleep(boost::posix_time::milliseconds(200));
    }

[endsect]

[section How to get specific statistics from stopwatches accumulator?]

There are two use cases that coul need to change the statistics associated to a stopwatches accumulator:

# We want to reduce the default reporting and we preffer to adapt the statistics to the reporting
# We want to report other statistics of the samples

For the first case we just need to change the accumulator_set and the format we want to get. Imagin we want to get only the count, sam and mean statistics, no need to calculate the min neither the max.

    using namespace boost::accumulators;

    typedef stopwatch_accumulator<process_real_cpu_clock,
                accumulator_set<process_real_cpu_clock::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean
                    >
                >
      >::reporter my_stopwatch_accumulator_reporter;

    int f1(long j)
    {
      static my_stopwatch_accumulator_reporter acc("%c times, sum=%ss, mean=%as\n");
      my_stopwatch_accumulator_reporter::scoped_run _(acc);

      for ( long i = 0; i < j; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }

But wat would hapend if we haven't forced the format:

      static my_stopwatch_accumulator_reporter acc;
      my_stopwatch_accumulator_reporter::scoped_run _(acc);

Unfortunately there is no error at compile time. Fortunately, the run-time execution is not undefined and will return 0 for the missing statistics.


[endsect]

[section How can I make a specific formatter when the default do not satisfy my expectations]

Imagine then that we want to report the tag::variance(lazy). We will need to include the specific accumulator file

    ...
    #include <boost/accumulators/statistics/variance.hpp>
    ...
    typedef stopwatch_accumulator<process_real_cpu_clock,
                accumulator_set<process_real_cpu_clock::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean,
                            tag::variance(lazy)
                    >
                >
    >::reporter my_stopwatch_accumulator_reporter;

But what happens if we add new statistics to the accumulator_set that are not taken in account by the default formatter? These statistics will simply be ignored. So we will need to define own own accumulator formatter.

    typedef stopwatch_accumulator<process_real_cpu_clock,
                accumulator_set<process_real_cpu_clock::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean,
                            tag::variance(lazy)
                    >
                >,
                my_stopwatch_accumulator_formatter
    >::reporter my_stopwatch_accumulator_reporter;

Next follow the definition of a formatter taking care of count, sum, mean and variance

    class my_stopwatch_accumulator_formatter {
    public:
        typedef std::string string_type;
        typedef char char_type;
        typedef std::ostream ostream_type;

        static ostream_type &  default_os() {return std::cout;}
        static const char_type* default_format() {return "%c times, sum=%ss, mean=%as, variance=%vs\n";}
        static int default_places() { return 3; }

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char_type* format,
                                int places, ostream_type & os, system::error_code & ec)
        {
            typedef typename Stopwatch::duration duration_t;
            typename Stopwatch::accumulator accumulator& acc = stopwatch_.accumulated();

            boost::io::ios_flags_saver ifs( os );
            os.setf( std::ios_base::fixed, std::ios_base::floatfield );
            boost::io::ios_precision_saver ips( os );
            os.precision( places );

            for ( ; *format; ++format ) {
                if ( *format != '%' || !*(format+1) || !std::strchr("acsv", *(format+1)) ) {
                    os << *format;
                } else {
                    ++format;
                    switch ( *format ) {
                    case 's':
                        os << boost::chrono::duration<double>(duration_t(accumulators::sum(acc))).count();
                        break;
                    case 'a':
                        os << (accumulators::count(acc)>0)
                                ? boost::chrono::duration<double>(duration_t(duration_t::rep(accumulators::mean(acc)))).count()
                                : 0;
                        break;
                    case 'c':
                        os << accumulators::count(acc);
                        break;
                    case 'v':
                        os << (accumulators::count(acc)>0)
                                ? boost::chrono::duration<double>(duration_t(duration_t::rep(accumulators::variance(acc)))).count()
                                : 0;
                        break;
                    default:
                        assert(0 && "my_stopwatch_accumulator_formatter internal logic error");
                    }
                }
            }
        }
    };



[endsect]

[endsect]

[/================================]
[section:ext_references References]
[/================================]

[variablelist

[
    [[@http://www.open-std.org/jtc1/sc22/wg21 [*C++ Standards Committee's current Working Paper]]]
    [The most authoritative reference material for the library is the C++ Standards Committee's current Working Paper (WP).  20.9 Time utilities "time", 20.4 Compile-time rational arithmetic "ratio", 20.6.7 Other transformations "meta.trans.other"]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]]]
    [From Howard E. Hinnant, Walter E. Brown, Jeff Garland  and Marc Paterno. Is very informative and provides motivation for key design decisions]
]


[
    [[@http://home.roadrunner.com/~hinnant/issue_review/lwg-defects.html#934 [*LGW 934. duration is missing operator%]]]
    [From Terry Golubiewski. Is very informative and provides motivation for key design decisions]
]

[
    [[@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]]]
    [From Vicente Juan Botet Escriba.]
]

]

[endsect]

[endsect]

[/=================]
[section:reference Reference ]
[/=================]

[section:cpp0x Included on the C++0x recommendation]

[/===================================================================]
[section:common_type_hpp Header `<boost/type_traits/common_type.hpp>`]
[/===================================================================]

    namespace boost {
      template <class ...T>  struct common_type;
    }

[section:common_type Class Template `common_type`]

`common_type` is a facility which is useful in specifying the type of the result of functions and operators which take a variety of types (e.g. "mixed mode" complex arithmetic).

The nested typedef `common_type::type` could be defined as follows:

    template <class T, class U = void, class V = void>
    struct common_type {
        typedef typename common_type<typename common_type<T, U>::type, V>::type type;
    };

    template <class T>
    struct common_type<T, void, void> {
        typedef T type;
    };

    template <class T, class U>
    struct common_type<T, U, void> {
    private:
        static T m_t();
        static U m_u();
        static bool m_f();  // workaround gcc bug; not required by std
    public:
        typedef BOOST_TYPEOF_TPL(m_f() ? m_t() : m_u()) type;
    };

All parameter types must be complete. This trait is permitted to be specialized by a user if at least one template parameter is a user-defined type.

[*Note:] Such specializations are required when only explicit conversions are desired among the `common_type` arguments.


[endsect]

[endsect]


[/===========================================]
[section:ratio_hpp Header `<boost/ratio.hpp>`]
[/===========================================]

`ratio` is a facility which is useful in specifying compile time rational constants. Compile time rational arithmetic is supported with protection against overflow and divide by zero. Such a facility is very handy when needing to efficiently represent  1/3 of a nanosecond, or specifying an inch in terms of meters (for example 254/10000 meters - which `ratio` will reduce to 127/5000 meters).

    namespace boost  {

        template <boost::intmax_t N, boost::intmax_t D = 1> class ratio;

        // ratio arithmetic
        template <class R1, class R2> struct ratio_add;
        template <class R1, class R2> struct ratio_subtract;
        template <class R1, class R2> struct ratio_multiply;
        template <class R1, class R2> struct ratio_divide;

        // ratio comparison
        template <class R1, class R2> struct ratio_equal;
        template <class R1, class R2> struct ratio_not_equal;
        template <class R1, class R2> struct ratio_less;
        template <class R1, class R2> struct ratio_less_equal;
        template <class R1, class R2> struct ratio_greater;
        template <class R1, class R2> struct ratio_greater_equal;

        // convenience SI typedefs
        typedef ratio<1LL, 1000000000000000000LL> atto;
        typedef ratio<1LL,    1000000000000000LL> femto;
        typedef ratio<1LL,       1000000000000LL> pico;
        typedef ratio<1LL,          1000000000LL> nano;
        typedef ratio<1LL,             1000000LL> micro;
        typedef ratio<1LL,                1000LL> milli;
        typedef ratio<1LL,                 100LL> centi;
        typedef ratio<1LL,                  10LL> deci;
        typedef ratio<                 10LL, 1LL> deca;
        typedef ratio<                100LL, 1LL> hecto;
        typedef ratio<               1000LL, 1LL> kilo;
        typedef ratio<            1000000LL, 1LL> mega;
        typedef ratio<         1000000000LL, 1LL> giga;
        typedef ratio<      1000000000000LL, 1LL> tera;
        typedef ratio<   1000000000000000LL, 1LL> peta;
        typedef ratio<1000000000000000000LL, 1LL> exa;
    }


[section:ratio Class Template `ratio<>`]

        template <boost::intmax_t N, boost::intmax_t D>
        class ratio {
        public:
            static const boost::intmax_t num;
            static const boost::intmax_t den;
            typedef ratio<num, den> type;

            ratio() {}

            template <intmax_t _N2, intmax_t _D2>
            ratio(const ratio<_N2, _D2>&,
                typename enable_if_c
                    <
                        ratio<_N2, _D2>::num == num &&
                        ratio<_N2, _D2>::den == den
                    >::type* = 0) {}

            template <intmax_t _N2, intmax_t _D2>
                typename enable_if_c
                <
                    ratio<_N2, _D2>::num == num &&
                    ratio<_N2, _D2>::den == den,
                    ratio&
                >::type
            operator=(const ratio<_N2, _D2>&) {return *this;}
        };

A diagnostic will be emitted if `ratio` is instantiated with `D == 0`, or if the absolute value of `N` or `D` can not be represented. [*Note:] These rules ensure that infinite ratios are avoided and that for any negative input, there exists a representable value of its absolute value which is positive. In a two's complement representation, this excludes the most negative value.

Let `gcd` denote the greatest common divisor of `N`'s absolute value and of `D`'s absolute value.

* `num` has the value `sign(N)*sign(D)*abs(N)/gcd`.

* `den` has the value `abs(D)/gcd`.

The nested typedef `type` denotes the normalized form of this ratio type. It should be used when the template parameters doesn't give a normalized form.

Two `ratio` classes `ratio<N1,D1>` and `ratio<N2,D2>` have the same normalized form if `ratio<N1,D1>::type` is the same type as `ratio<N2,D2>::type`

[section Construction and assignment]

    template <intmax_t N2, intmax_t D2>
      ratio(const ratio<N2, D2>& r);

[*Effects:] Constructs a `ratio` object.

[*Remarks:] This constructor will not participate in overload resolution unless `r` has the same normalized form as `*this`.

    template <intmax_t N2, intmax_t D2>
      ratio& operator=(const ratio<N2, D2>& r);

[*Effects:] Assigns a `ratio` object.

[*Returns:] *this.

[*Remarks:] This operator will not participate in overload resolution unless `r` has the same normalized form as `*this`.

[endsect]


[endsect]


[section:ratio_arithmetic `ratio` arithmetic]

For each of the class templates in this clause, each template parameter refers to a `ratio`. If the implementation is unable to form the indicated `ratio` due to overflow, a diagnostic will be issued.

        template <class R1, class R2> struct ratio_add {
           typedef [/see below] type;
        };

The nested typedef `type` is a synonym for `ratio<R1::num * R2::den + R2::num * R1::den, R1::den * R2::den>::type`.

        template <class R1, class R2> struct ratio_subtract {
           typedef  [/see below]  type;
        };

The nested typedef `type` is a synonym for `ratio<R1::num * R2::den - R2::num * R1::den, R1::den * R2::den>::type`.

        template <class R1, class R2> struct ratio_multiply {
           typedef  [/see below]  type;
        };

The nested typedef `type` is a synonym for `ratio<R1::num * R2::num, R1::den * R2::den>::type`.

        template <class R1, class R2> struct ratio_divide {
           typedef  [/see below]  type;
        };

The nested typedef `type` is a synonym for `ratio<R1::num * R2::den, R2::num * R1::den>::type`.

[endsect]

[section:ratio_comparison `ratio` comparison]

        template <class R1, class R2>  struct ratio_equal
            : public boost::integral_constant<bool, [/see below] > {};

If R1::num == R2::num && R1::den == R2::den, ratio_equal derives from true_type, else derives from false_type.

        template <class R1, class R2>
        struct ratio_less
            : public boost::integral_constant<bool, [/see below] > {};

If R1::num * R2::den < R2::num * R1::den, ratio_less derives from true_type, else derives from false_type.

    template <class R1, class R2>  struct ratio_not_equal
        : public boost::integral_constant<bool, !ratio_equal<R1, R2>::value> {};

    template <class R1, class R2> struct ratio_less_equal
        : public boost::integral_constant<bool, !ratio_less<R2, R1>::value> {};

    template <class R1, class R2> struct ratio_greater
        : public boost::integral_constant<bool, ratio_less<R2, R1>::value> {};

    template <class R1, class R2> struct ratio_greater_equal
        : public boost::integral_constant<bool, !ratio_less<R1, R2>::value> {};


[endsect]

[section:ration_SI_typedefs SI typedefs]

        // convenience SI typedefs
        typedef ratio<1LL, 1000000000000000000LL> atto;
        typedef ratio<1LL,    1000000000000000LL> femto;
        typedef ratio<1LL,       1000000000000LL> pico;
        typedef ratio<1LL,          1000000000LL> nano;
        typedef ratio<1LL,             1000000LL> micro;
        typedef ratio<1LL,                1000LL> milli;
        typedef ratio<1LL,                 100LL> centi;
        typedef ratio<1LL,                  10LL> deci;
        typedef ratio<                 10LL, 1LL> deca;
        typedef ratio<                100LL, 1LL> hecto;
        typedef ratio<               1000LL, 1LL> kilo;
        typedef ratio<            1000000LL, 1LL> mega;
        typedef ratio<         1000000000LL, 1LL> giga;
        typedef ratio<      1000000000000LL, 1LL> tera;
        typedef ratio<   1000000000000000LL, 1LL> peta;
        typedef ratio<1000000000000000000LL, 1LL> exa;


Four of the typedefs in the recomendation which can be conditionally supported are not supported: yocto, zepto, zetta and yotta.

    typedef ratio<1, 1000000000000000000000000> yocto;  // conditionally supported
    typedef ratio<1,    1000000000000000000000> zepto;  // conditionally supported
    typedef ratio<   1000000000000000000000, 1> zetta;  // conditionally supported
    typedef ratio<1000000000000000000000000, 1> yotta;  // conditionally supported

[endsect]

[endsect]

[/=============================================]
[section:chrono_hpp Header `<boost/chrono.hpp>`]
[/=============================================]

This file is a redirection to `boost/chrono/chrono.hpp` including in addition registration for `duration<>` and `timepoint<>` class templates to Boost.Typeof.


    #include <boost/chrono/chrono.hpp>
    #include <boost/chrono/typeof/boost/chrono/chrono.hpp>

[endsect]

[/=============================================]
[section:chrono_chrono_hpp Header `<boost/chrono/chrono.hpp>`]
[/=============================================]

    namespace boost {
      namespace chrono {

        template <class Rep, class Period = ratio<1> >  class duration;
        template <class Clock, class Duration = typename Clock::duration> class time_point;

      }
      template <class Rep1, class Period1, class Rep2, class Period2>
      struct common_type<chrono::duration<Rep1, Period1>,
                         chrono::duration<Rep2, Period2> >;

      template <class Clock, class Duration1, class Duration2>
      struct common_type<chrono::time_point<Clock, Duration1>,
                         chrono::time_point<Clock, Duration2> >;

      namespace chrono {

        // customization traits
        template <class Rep> struct treat_as_floating_point;
        template <class Rep> struct duration_values;

        // duration arithmetic
        template <class Rep1, class Period1, class Rep2, class Period2>
        typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
        operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
        operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period, class Rep2>
        duration<typename common_type<Rep1, Rep2>::type, Period>
        operator*(const duration<Rep1, Period>& d, const Rep2& s);

        template <class Rep1, class Period, class Rep2>
        duration<typename common_type<Rep1, Rep2>::type, Period>
        operator*(const Rep1& s, const duration<Rep2, Period>& d);

        template <class Rep1, class Period, class Rep2>
        duration<typename common_type<Rep1, Rep2>::type, Period>
        operator/(const duration<Rep1, Period>& d, const Rep2& s);

        template <class Rep1, class Period1, class Rep2, class Period2>
        typename common_type<Rep1, Rep2>::type
        operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Rep2, class Period>
        double operator/(const Rep1& s, const duration<Rep2, Period>& d);

        // duration comparisons
        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        // duration_cast

        template <class ToDuration, class Rep, class Period>
        ToDuration duration_cast(const duration<Rep, Period>& d);

        // convenience typedefs
        typedef duration<boost::int_least64_t, nano> nanoseconds;    // at least 64 bits needed
        typedef duration<boost::int_least64_t, micro> microseconds;  // at least 55 bits needed
        typedef duration<boost::int_least64_t, milli> milliseconds;  // at least 45 bits needed
        typedef duration<boost::int_least64_t> seconds;              // at least 35 bits needed
        typedef duration<boost::int_least32_t, ratio< 60> > minutes; // at least 29 bits needed
        typedef duration<boost::int_least32_t, ratio<3600> > hours;  // at least 23 bits needed

        // time_point arithmetic
        template <class Clock, class Duration1, class Rep2, class Period2>
        time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2> >::type>
        operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Clock, class Duration2>
        time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
        operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);

        template <class Clock, class Duration1, class Rep2, class Period2>
        time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2> >::type>
        operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Clock, class Duration1, class Duration2>
        typename common_type<Duration1, Duration2>::type
        operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                Duration2>& rhs);

        // time_point comparisons
        template <class Clock, class Duration1, class Duration2>
        bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);

        // time_point_cast
        template <class ToDuration, class Clock, class Duration>
        time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);

        // Clocks
        class system_clock;
        class monotonic_clock;
        class high_resolution_clock;

      }
    }

[section `Clock` Requirements]

A clock represents a bundle consisting of a native `duration`, a native `time_point`, and a function `now()` to get the current `time_point`. A clock must meet the requirements in the following Table.

In this table `C1` and `C2` denote `clock` types. `t1` and `t2` are values returned from `C1::now()` where the call returning `t1` happens before the call returning `t2` and both of these calls happen before `C1::time_point::max()`.

[table Clock Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`C1::rep`]        [An arithmetic type or class emulating an arithmetic type. ]  [The representation type of the native `duration` and `time_point`.]]
    [[`C1::period`]        [`ratio`]  [The tick period of the clock in seconds.]]
    [[`C1::duration`]        [`chrono::duration<C1::rep, C1::period>`]  [The native `duration` type of the `clock`.]]
    [[`C1::time_point`]        [`chrono::time_point<C1> or chrono::time_point<C2, C1::duration>`]  [The native `time_point` type of the `clock`. Different clocks are permitted to share a `time_point` definition if it is valid to compare their time_points by comparing their respective `duration`s. `C1` and `C2` must refer to the same epoch.]]
    [[`C1::is_monotonic`]        [`const bool`]  [`true` if `t1 <= t2` is always `true`, else `false`. [*Note: A `clock` that can be adjusted backwards is not monotonic]]]
    [[`C1::now()`]        [`C1::time_point`]  [Returns a `time_point` representing the current point in time.]]
]

[endsect]

[section Time-related traits]
[section:treat_as_floating_point Metafunction `treat_as_floating_point<>`]

    template <class Rep> struct treat_as_floating_point
        : boost::is_floating_point<Rep> {};

The `duration` template uses the `treat_as_floating_point` trait to help determine if a `duration` with one tick period can be converted to another `duration` with a different tick period. If `treat_as_floating_point<Rep>::value` is `true`, then `Rep` is a floating point type and implicit conversions are allowed among `duration`s. Otherwise, the implicit convertibility depends on the tick periods of the `duration`s. If `Rep` is a class type which emulates a floating point type, the author of `Rep` can specialize `treat_as_floating_point` so that `duration` will treat this `Rep` as if it were a floating point type. Otherwise `Rep` is assumed to be an integral type, or a class emulating an integral type.


[endsect]
[section:duration_values Class template `duration_values`]

    template <class Rep>
    struct duration_values
    {
    public:
        static BOOST_CHRONO_CONSTEXPR  Rep zero();
        static BOOST_CHRONO_CONSTEXPR  Rep max();
        static BOOST_CHRONO_CONSTEXPR  Rep min();
    };

The `duration` template uses the `duration_values` trait to construct special values of the `duration`s representation (`Rep`). This is done because the representation might be a class type with behavior which requires some other implementation to return these special values. In that case, the author of that class type should specialize `duration_values` to return the indicated values.

[section:zero Static member Function `zero()`]

    static BOOST_CHRONO_CONSTEXPR Rep zero();

[*Returns:] `Rep(0)`. [*Note:] `Rep(0)` is specified instead of `Rep()` since `Rep()` may have some other meaning, such as an uninitialized value.

[*Remarks:] The value returned corresponds to the additive identity.

[endsect]
[section:max Static member function `max()`]

    static BOOST_CHRONO_CONSTEXPR Rep max();

[*Returns:] `numeric_limits<Rep>::max()`.

[*Remarks:] The value returned compares greater than zero().

[endsect]
[section:min Static member function `min()`]

    static BOOST_CHRONO_CONSTEXPR Rep min();

[*Returns:] `numeric_limits<Rep>::lowest()`.

[*Remarks:] The value returned compares less than or equal to `zero()`.

[endsect]

[endsect]

[section `common_type` specializations]

    template <class Rep1, class Period1, class Rep2, class Period2>
    struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2> >
    {
        typedef chrono::duration<typename common_type<Rep1, Rep2>::type, see below> type;
    };

The period of the `duration` indicated by this specialization of `common_type` is the greatest common divisor of `Period1` and `Period2`. This can be computed by forming a `ratio` of the greatest common divisor of `Period1::num` and `Period2::num`, and the least common multiple of `Period1::den` and `Period2::den`.

[*Note:] The typedef type is the `duration` with the largest tick period possible where both `duration` arguments will convert to it without requiring a division operation. The representation of this type is intended to be able to hold any value resulting from this conversion, with the possible exception of round-off error when floating point `duration`s are involved (but not truncation error).

    template <class Clock, class Duration1, class Duration2>
    struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2> >
    {
        typedef chrono::time_point<Clock, typename common_type<Duration1, Duration2>::type> type;
    };

The `common_type` of two `time_point`s is a `time_point` with the same `clock` (both have the same `clock`), and the `common_type` of the two `duration`s.

[endsect]


[endsect]

[section Class template `duration`]

A `duration` measures time between two points in time (`time_point`). A `duration` has a representation which holds a count of ticks, and a tick period. The tick period is the amount of time which occurs from one tick to another in units of a second. It is expressed as a rational constant using `ratio`.

    namespace boost { namespace chrono {

        template <class Rep, class Period>
        class duration {
        public:
            typedef Rep rep;
            typedef Period period;
        private:
            rep rep_; // exposition only
        public:
            BOOST_CHRONO_CONSTEXPR duration() {} // = default;
            template <class Rep2>
            BOOST_CHRONO_CONSTEXPR explicit duration(const Rep2& r,
                  typename boost::enable_if_c
                  <
                  boost::is_convertible<Rep2, rep>::value
                     && (treat_as_floating_point<rep>::value
                     || (!treat_as_floating_point<rep>::value
                       && !treat_as_floating_point<Rep2>::value))
                  >::type* = 0);

            template <class Rep2, class Period2>
            BOOST_CHRONO_CONSTEXPR duration(const duration<Rep2, Period2>& d,
                  typename boost::enable_if_c
                  <
                      treat_as_floating_point<rep>::value
                      || (ratio_divide<Period2, period>::type::den == 1
                        && !treat_as_floating_point<Rep2>::value)
                  >::type* = 0);

            //~duration() = default;
            //duration(const duration&) = default;
            //duration& operator=(const duration&) = default;

            BOOST_CHRONO_CONSTEXPR rep count() const;

            BOOST_CHRONO_CONSTEXPR duration  operator+();
            BOOST_CHRONO_CONSTEXPR duration  operator-();
            duration& operator++();
            duration  operator++(int);
            duration& operator--();
            duration  operator--(int);

            duration& operator+=(const duration& d);
            duration& operator-=(const duration& d);

            duration& operator*=(const rep& rhs);
            duration& operator/=(const rep& rhs);
            duration& operator%=(const rep& rhs);
            duration& operator%=(const duration& rhs);

            static BOOST_CHRONO_CONSTEXPR duration zero();
            static BOOST_CHRONO_CONSTEXPR duration min();
            static BOOST_CHRONO_CONSTEXPR duration max();
        };

    }}

Rep must be an arithmetic type, or a class emulating an arithmetic type, compile diagnostic otherwise. If `duration` is instantiated with the type of `Rep` being a `duration`, compile diagnostic is issued.

Period must be an instantiation of `ratio`, compile diagnostic otherwise.

Period::num must be positive, compile diagnostic otherwise.

Examples:

    duration<long, ratio<60> > holds a count of minutes using a long.

    duration<long long, milli> holds a count of milliseconds using a long long.

    duration<double, ratio<1, 30> > holds a count using a double with a tick period of 1/30 second (a tick frequency of 30 Hz).

The following members of `duration` do not throw an exception unless the indicated operations on the representations throw an exception.

[section:duration_c_1 Constructor `duration(const Rep2&)`]

    template <class Rep2>
    BOOST_CHRONO_CONSTEXPR explicit duration(const Rep2& r);

[*Remarks:] `Rep2` is implicitly convertible to `rep`, and

* `treat_as_floating_point<rep>::value` is `true`, or
* `!treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value` is `true`.

If these constraints are not met, this constructor shall not participate in overload resolution. [*Note:] This requirement prevents construction of an integral-based `duration` with a floating point representation. Such a construction could easily lead to confusion about the value of the `duration`.

[*Example:]

        duration<int, milli> d(3.5);  // do not compile
        duration<int, milli> d(3);    // ok

[*Effects:] Constructs an object of type `duration`.

[*PostConditions:] `count() == static_cast<rep>(r)`.

[endsect]
[section:duration_c_2 Constructor `duration(const duration&)`]

    template <class Rep2, class Period2>
    BOOST_CHRONO_CONSTEXPR duration(const duration<Rep2, Period2>& d);

[*Remarks:] `treat_as_floating_point<rep>::value`, or `ratio_divide<Period2, period>::type::den == 1`, else this constructor shall not participate in overload resolution. [*note] This requirement prevents implicit truncation error when converting between integral-based `duration`s. Such a construction could easily lead to confusion about the value of the `duration`.

[*Example:]

        duration<int, milli> ms(3);
        duration<int, micro> us = ms;  // ok
        duration<int, milli> ms2 = us; // do not compile

[*Effects:] Constructs an object of type `duration`, constructing `rep_` from `duration_cast<duration>(d).count()`.

[endsect]
[section:count Member function `count() const`]

    BOOST_CHRONO_CONSTEXPR rep count() const;

[*Returns:] `rep_v.

[endsect]
[section:duration_operator_p Member function `operator+() const`]

    BOOST_CHRONO_CONSTEXPR duration operator+() const;

[*Returns:] `*this`.

[endsect]
[section:duration_operator_m Member function `operator+() const`]

    BOOST_CHRONO_CONSTEXPR duration operator-() const;

[*Returns:] `duration(-rep_)`.

[endsect]
[section:duration_operator_pp Member function `operator++()`]

    duration& operator++();

[*Effects:] `++rep_`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_pp2 Member function `operator++(int)`]

    duration operator++(int);

[*Returns:] `duration(rep_++)v.

[endsect]
[section:duration_operator_mm Member function `operator++()`]

    duration& operator--();

[*Effects:] `--rep_`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_mm2 Member function `operator++(int)`]

    duration operator--(int);

[*Returns:] `duration(rep_--)`.

[endsect]
[section:duration_operator_pa Member function `operator+=(const duration&)`]

    duration& operator+=(const duration& d);

[*Effects:] `rep_ += d.count()`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_ma Member function `operator-=(const duration&)`]

    duration& operator-=(const duration& d);

[*Effects:] `rep_ -= d.count()`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_moda Member function `operator%=(const duration&)`]

    duration& operator%=(const duration& d);

[*Effects:] `rep_ %= d.count()`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_proda Member function `operator*=(const rep&)`]

    duration& operator*=(const rep& rhs);

[*Effects:] `rep_ *= rhs`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_da Member function `operator/=(const rep&)`]

    duration& operator/=(const rep& rhs);

[*Effects:] `rep_ /= rhs`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_moda_2 Member function `operator%=(const rep&)`]

    duration& operator%=(const rep& rhs);

[*Effects:] `rep_ %= rhs`.

[*Returns:] `*this`.

[endsect]


[section:duration_zero Static Member function `zero()`]

    static duration zero();

[*Returns:] `duration(duration_values<rep>::zero())`.

[endsect]
[section:duration_min Static Member function `min()`]

    static duration min();

[*Returns:] `duration(duration_values<rep>::min()).`

[endsect]
[section:duration_max Static Member function `max()`]

    static constexpr duration max();

[*Returns:] `duration(duration_values<rep>::max())`.

[endsect]

[endsect]


[section duration non-member arithmetic]

[section:duration_operator_p_1 Non-Member function `operator+(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
    operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `CD(lhs) += rhs` where `CD` is the type of the return value.

[endsect]
[section:duration_operator_m_1 Non-Member function `operator-(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
    operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `CD(lhs) -= rhs` where `CD` is the type of the return value.

    template <class Rep1, class Period, class Rep2>
    duration<typename common_type<Rep1, Rep2>::type, Period>
    operator*(const duration<Rep1, Period>& d, const Rep2& s);

[*Requires:] Let `CR` represent the `common_type` of `Rep1` and `Rep2`. This function will not participate in overload resolution unless both `Rep1` and `Rep2` are implicitly convertible to `CR`.

[*Returns:] `duration<CR, Period>(d) *= s`.

[endsect]
[section:duration_operator_prod_1 Non-Member function `operator*(Rep1,duration)`]

    template <class Rep1, class Period, class Rep2>
    duration<typename common_type<Rep1, Rep2>::type, Period>
    operator*(const Rep1& s, const duration<Rep2, Period>& d);

[*Requires:] Let `CR` represent the `common_type` of `Rep1` and `Rep2`. This function will not participate in overload resolution unless both `Rep1` and `Rep2` are implicitly convertible to `CR`.

[*Returns:] `d * s`.

[endsect]
[section:duration_operator_d_1 Non-Member function `operator/(duration,Rep2)`]

    template <class Rep1, class Period, class Rep2>
    duration<typename common_type<Rep1, Rep2>::type, Period>
    operator/(const duration<Rep1, Period>& d, const Rep2& s);

[*Requires:] Let `CR` represent the `common_type` of `Rep1` and `Rep2`. This function will not participate in overload resolution unless both `Rep1` and `Rep2` are implicitly convertible to `CR`, and `Rep2` is  not an instantiation of `duration`.

[*Returns:] `duration<CR, Period>(d) /= s`.

[endsect]
[section:duration_operator_d_2 Non-Member function `operator/(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    typename common_type<Rep1, Rep2>::type
    operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] Let `CD` represent the `common_type` of the two `duration` arguments. Returns `CD(lhs).count() / CD(rhs).count()`.

[endsect]

[section:duration_operator_d_3 Non-Member function `operator/(Rep1,duration)`]

    template <class Rep1, class Rep2, class Period>
    double operator/(const Rep1& s, const duration<Rep2, Period>& d);

[*Remarks:] Let `CR` represent the `common_type` of `Rep1` and `Rep2`. This function will not participate in overload resolution unless both `Rep1` and `Rep2` are implicitly convertible to `CR`, and `Rep1` is  not an instantiation of `duration`.

[*Returns:] `CR(s)/duration<CR, Period>(d)`.

[endsect]


[section:duration_operator_mod_1 Non-Member function `operator%(duration,Rep2)`]

  template <class Rep1, class Period, class Rep2>
  duration<typename common_type<Rep1, Rep2>::type, Period>
  operator%(const duration<Rep1, Period>& d, const Rep2& s);

[*Remarks] This function will not participate in overload resolution unless Rep2 shall be implicitly convertible to CR(Rep1, Rep2) and Rep2 shall not be an instantiation of duration.

[*Returns:] duration<CR(Rep1,Rep2), Period>(d) %= s.
[endsect]

[section:duration_operator_mod_2 Non-Member function `operator%(duration,duration)`]

  template <class Rep1, class Period1, class Rep2, class Period2>
  typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
  operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Remarks] This function will not participate in overload resolution unless

[*Returns:] CD(lhs) %= CD(rhs)

[endsect]
[endsect]

[section duration comparaisons]

[section:duration_operator_eq_1 Non-Member function `operator==(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] Let `CD` represent the `common_type` of the two `duration` arguments. Returns `CD(lhs).count() == CD(rhs).count()`

[endsect]
[section:duration_operator_neq_1 Non-Member function `operator!=(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `!(lhs == rhs)`.

[endsect]
[section:duration_operator_lt_1 Non-Member function `operator<(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] Let `CD` represent the `common_type` of the two `duration` arguments. Returns `CD(lhs).count() < CD(rhs).count()`

[endsect]
[section:duration_operator_leq_1 Non-Member function `operator<=(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `!(rhs < lhs)`.

[endsect]
[section:duration_operator_gt_1 Non-Member function `operator>(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `rhs < lhs`.

[endsect]
[section:duration_operator_gteq_1 Non-Member function `operator>=(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `!(lhs < rhs)`.

[endsect]
[endsect]
[section:duration_cast Non-Member function `duration_cast(duration)`]

    template <class ToDuration, class Rep, class Period>
    ToDuration duration_cast(const duration<Rep, Period>& d);

[*Requires:] This function will not participate in overload resolution unless `ToDuration` is an instantiation of `duration`.

[*Returns:] Forms `CF` which is a `ratio` resulting from `ratio_divide<Period, typename ToDuration::period>::type`. Let `CR` be the `common_type` of `ToDuration::rep`, `Rep`, and `intmax_t`.

* If `CF::num == 1` and `CF::den == 1`, then returns `ToDuration(static_cast<typename ToDuration::rep>(d.count())) `
* else if `CF::num != 1` and `CF::den == 1`, then returns
              `ToDuration(static_cast<typename ToDuration::rep>(static_cast<CR>(d.count()) *
                                                               static_cast<CR>(CF::num)))`
* else if `CF::num == 1` and `CF::den != 1`, then returns
              `ToDuration(static_cast<typename ToDuration::rep>(static_cast<CR>(d.count()) /
                                                               static_cast<CR>(CF::den)))`
* else returns
              `ToDuration(static_cast<typename ToDuration::rep>(static_cast<CR>(d.count()) *
                                                               static_cast<CR>(CF::num)   /
                                                               static_cast<CR>(CF::den)))`

[*Remarks:] This function does not rely on any implicit conversions. All conversions must be accomplished through `static_cast`. The implementation avoids all multiplications or divisions when it is known at compile time that it can be avoided because one or more arguments are `1`. All intermediate computations are carried out in the widest possible representation and only converted to the destination representation at the final step.


[endsect]



[section Class template `time_point`]

A `time_point` represents a point in time with respect to a specific clock.

    template <class Clock, class Duration>
    class time_point {
    public:
        typedef Clock                     clock;
        typedef Duration                  duration;
        typedef typename duration::rep    rep;
        typedef typename duration::period period;
    private:
        duration d_; // exposition only
    public:
        time_point();
        explicit time_point(const duration& d);

        // conversions
        template <class Duration2>
        time_point(const time_point<clock, Duration2>& t,
          typename boost::enable_if
          <
              boost::is_convertible<Duration2, duration>
          >::type* = 0);

        // observer

        duration time_since_epoch() const;

        // arithmetic

        time_point& operator+=(const duration& d);
        time_point& operator-=(const duration& d);

        // special values

        static BOOST_CHRONO_CONSTEXPR time_point min();
        static BOOST_CHRONO_CONSTEXPR time_point max();
    };

Clock must meet the Clock Requirements.

Duration must be an instantiation of `duration`, compile diagnostic otherwise.

[section:time_point_c_1 Constructor `time_point()`]

    time_point();

[*Effects:] Constructs an object of `time_point`, initializing `d_` with `duration::zero()`. This `time_point` represents the epoch.

[endsect]
[section:time_point_c_2 Constructor `time_point(const duration&)`]

    time_point(const duration& d);

[*Effects:] Constructs an object of `time_point`, initializing `d_` with `d`. This `time_point` represents the epoch `+ d`.

[endsect]
[section:time_point_c_3 Constructor `time_point(const duration&)`]

    template <class Duration2> time_point(const time_point<clock, Duration2>& t);

[*Requires:] This function will not participate in overload resolution unless `Duration2` is implicitly convertible to `duration`.

[*Effects:] Constructs an object of `time_point`, initializing `d_` with `t.time_since_epoch()`.

[endsect]

[section:time_since_epoch Member function `time_since_epoch() const`]

    duration time_since_epoch() const;

[*Returns:] `d_`.

[endsect]
[section:time_point_operator_pe Member function `operator+=`]

    time_point& operator+=(const duration& d);

[*Effects:] `d_ += d`.

[*Returns:] `*this`.

[endsect]
[section:time_point_operator_me Member function `operator-=`]

    time_point& operator-=(const duration& d);

[*Effects:] `d_ -= d`

[*Returns:] `*this`.

[endsect]
[section:time_point_min Static Member function `min`]

    static BOOST_CHRONO_CONSTEXPR time_point min();

[*Returns:] `time_point(duration::min())`.

[endsect]
[section:time_point_max Static Member function `max`]

    static BOOST_CHRONO_CONSTEXPR time_point max();

[*Returns:] `time_point(duration::max())`.

[endsect]
[endsect]


[section time_point non-member arithmetic]


[section:time_point_operator_p_1 Non-Member function `operator+(time_point,duration)`]

    template <class Clock, class Duration1, class Rep2, class Period2>
    time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2> >::type>
    operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `CT(lhs) += rhs` where `CT` is the type of the return value.

[endsect]
[section:time_point_operator_p_2 Non-Member function `operator+(duration,time_point)`]

    template <class Rep1, class Period1, class Clock, class Duration2>
    time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
    operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `rhs + lhs`.

[endsect]
[section:time_point_operator_m_1 Non-Member function `operator-(time_point,duration)`]

    template <class Clock, class Duration1, class Rep2, class Period2>
    time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2> >::type>
    operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `lhs + (-rhs)`.

[endsect]
[section:time_point_operator_m_2 Non-Member function `operator-(duration,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    typename common_type<Duration1, Duration2>::type
    operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `lhs.time_since_epoch() - rhs.time_since_epoch()`.

[endsect]
[endsect]

[section time_point comparisons]
[section:time_point_operator_eq Non-Member function `operator==(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `lhs.time_since_epoch() == rhs.time_since_epoch()`.

[endsect]
[section:time_point_operator_neq Non-Member function `operator!=(time_point,time_point)`]

template <class Clock, class Duration1, class Duration2>
   bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `!(lhs == rhs)`.

[endsect]
[section:time_point_operator_lt Non-Member function `operator<(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] lhs.time_since_epoch() < rhs.time_since_epoch().

[endsect]
[section:time_point_operator_leq Non-Member function `operator<=(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `!(rhs < lhs)`.

[endsect]
[section:time_point_operator_gt Non-Member function `operator>(time_point,time_point)`]

template <class Clock, class Duration1, class Duration2>
   bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `rhs < lhs`.

[endsect]
[section:time_point_operator_geq Non-Member function `operator>=(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `!(lhs < rhs)`.

[endsect]
[section:time_point_cast Non-Member function `time_point_cast(time_point)`]

    template <class ToDuration, class Clock, class Duration>
    time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);

[*Requires:] This function will not participate in overload resolution unless `ToDuration` is an instantiation of `duration`.

[*Returns:] `time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch()))`.

[endsect]
[endsect]


[section Class `system_clock`]

The `system_clock` class provides a means of obtaining the current wall-clock time from the system-wide real-time clock. The current time can be obtained by calling `system_clock::now()`. Instances of `system_clock::time_point`  can be converted to and from time_t  with the `system_clock::to_time_t()`  and `system_clock::to_time_point()`  functions. If system clock is not monotonic, a subsequent call to `system_clock::now()`  may return an earlier time than a previous call (e.g. if the operating system clock is manually adjusted, or synchronized with an external clock).

    class system_clock {
    public:
        typedef BOOST_SYSTEM_CLOCK_DURATION          duration;
        typedef duration::rep                        rep;
        typedef duration::period                     period;
        typedef chrono::time_point<system_clock>     time_point;
        static const bool is_monotonic =             false;

        static time_point  now();                         // throws on error
        static time_point  now(system::error_code & ec);  // never throws

        static std::time_t to_time_t(const time_point& t);
        static time_point  from_time_t(std::time_t t);
    };

`system_clock` satisfy the Clock Requirements. In addition:

* `system_clock::duration::min() < system_clock::duration::zero()` is `true`.


[section:to_time_t Static member function `to_time_t(time_point)`]

time_t to_time_t(const time_point& t);

[*Returns:] A `time_t` such that the `time_t` and `t` represent the same point in time, truncated to the courser of the precisions among `time_t` and `t`.

[endsect]
[section:from_time_t Static member function `from_time_t(time_t)`]

    time_point from_time_t(time_t t);

[*Returns:] A `time_point` such that the `time_point` and `t` represent the same point in time, truncated to the courser of the precisions among `time_point` and `t`.

[endsect]
[endsect]

[section Class `monotonic_clock`]

`monotonic_clock` satisfy the Clock Requirements.

`monotonic_clock` class provides access to the system-wide monotonic clock. The current time can be obtained by calling `monotonic_clock::now()`. There is no fixed relationship between values returned by `monotonic_clock::now()`  and wall-clock time.

    #ifdef BOOST_HAS_CLOCK_MONOTONIC
        class BOOST_CHRONO_DECL monotonic_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<monotonic_clock>  time_point;
            static const bool is_monotonic =             true;

            static time_point  now();                         // throws on error
            static time_point  now(system::error_code & ec);  // never throws
        };
    #endif

[endsect]

[section Class `high_resolution_clock`]

`high_resolution_clock` satisfy the Clock Requirements.

    #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
      typedef monotonic_clock high_resolution_clock;  // as permitted by [time.clock.hires]
    #else
      typedef system_clock high_resolution_clock;  // as permitted by [time.clock.hires]
    #endif

[endsect]

[endsect]

[/=============================================]
[section:chrono_typeof_hpp Header `<boost/chrono/typeof/boost/chrono/chorno.hpp>`]
[/=============================================]

Register `duration<>` and `timepoint<>` class templates to Boost.Typeof.

[endsect]
[endsect]

[section Other clocks]

[/==================================================================]
[section:process_cpu_clocks_hpp Header `<boost/chrono/process_cpu_clocks.hpp>`]
[/==================================================================]

Knowing how long a program takes to execute is useful in both test and production environments. It is also helpful if such timing information is broken down into real (wall clock) time, CPU time spent by the user, and CPU time spent by the operating system servicing user requests.

    namespace boost { namespace chrono {

        class process_real_cpu_clock;
        class process_user_cpu_clock;
        class process_system_cpu_clock;
        class process_cpu_clock;

    } }

[section Class `process_real_cpu_clock`]

`process_real_cpu_clock` satisfy the Clock Requirements.

`process_real_cpu_clock` class provides access to the real process wall-clock monotonic clock, i.e. the real CPU-time clock of the calling process. The process relative current time can be obtained by calling `process_real_cpu_clock::now()`.

        class process_real_cpu_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<process_real_cpu_clock>    time_point;
            static const bool is_monotonic =             true;

            static time_point now( system::error_code & ec = system::throws );
        };


[endsect]
[section Class `process_user_cpu_clock`]

`process_user_cpu_clock` satisfy the Clock Requirements.

`process_user_cpu_clock` class provides access to the user CPU-time monotonic clock of the calling process. The process relative user current time can be obtained by calling `process_user_cpu_clock::now()`.

        class process_user_cpu_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<process_user_cpu_clock>    time_point;
            static const bool is_monotonic =             true;

            static time_point now( system::error_code & ec = system::throws );
        };


[endsect]

[section Class `process_system_cpu_clock`]

`process_system_cpu_clock` satisfy the Clock Requirements.

`process_system_cpu_clock` class provides access to the system CPU-time monotonic clockof the calling process. The process relative system current time can be obtained by calling `process_system_cpu_clock::now()`.

        class process_system_cpu_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<process_system_cpu_clock>    time_point;
            static const bool is_monotonic =             true;

            static time_point now( system::error_code & ec = system::throws );
        };


[endsect]

[section Class `process_cpu_clock`]

`process_cpu_clock` can be considered as a `tuple<process_real_cpu_clock, process_user_cpu_clock, process_system_cpu_clock>`.

`process_cpu_clock` provides a thin wrapper around the operating system's process timer API. For POSIX-like systems, that's the times() function, while for Windows, it's the GetProcessTimes() function.

The process relative real, user and system current time can be obtained at once by calling `process_clocks::now()`.


    class BOOST_CHRONO_DECL process_cpu_clock
    {
    public:
        struct times ;

        typedef duration<times,  nano>                duration;
        typedef duration::rep                       rep;
        typedef duration::period                    period;
        typedef chrono::time_point<process_cpu_clock>  time_point;
        static const bool is_monotonic =           true;

        static time_point now( system::error_code & ec = system::throws );
    };

    template <>
    struct duration_values<process_cpu_clock::times>;


[section Class `times`]

This class is the representation of the process_cpu_clock::duration class. As such it needs to implements the arithmetic operators.

        struct times : arithmetic<times>, less_than_comparable<times>
        {
            process_real_cpu_clock::rep   real;    // real (i.e wall clock) time
            process_user_cpu_clock::rep   user;    // user cpu time
            process_system_cpu_clock::rep system;  // system cpu time

            times();
            times(
                process_real_cpu_clock::rep r,
                process_user_cpu_clock::rep   u,
                process_system_cpu_clock::rep s);

            bool operator==(times const& rhs);

            times operator+=(times const& rhs);
            times operator-=(times const& rhs);
            times operator*=(times const& rhs);
            times operator/=(times const& rhs);
            bool operator<(times const & rhs) const;
        };

[endsect]

[section `duration_values` specialization for `times`]

    template <>
    struct duration_values<process_cpu_clock::times>
    {
        static process_cpu_clock::times zero();
        static process_cpu_clock::times max();
        static process_cpu_clock::times min();
    };

The `times` specific functions `zero()`, `max()` and `min()` uses the relative functions on the representation of each component.

[endsect]

[endsect]

[endsect]

[/
[section:suspendible_clock_req `SuspendibleClock` requirements]

A `SuspendibleClock` is a Clock that in addition support for `suspend`/`resume` operations.

A `SuspendibleClock` must meet the requirements in the following Table.

In this table `C`  denote `clock` types.

[table SuspendibleClock Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`C::suspend()`]   [`void`]  [Suspends the time counting of the clock C.]]
    [[`C::resume()`]   [`void`]  [Resumes the time counting of the clock C.]]
    [[`C::suspended()`]   [`duration`]  [Returns the delay(duration during which the clock has been suspended.]]
]

[section:SuspendibleClock_suspend Static Member Function `suspend()`]

    void suspend( system::error_code & ec = system::throws );

[*Effect:] Suspends the SuspendibleClock.

[*Throw:] Any exception the `Clock::now(ec)` function can throw. Otherwise `ec` is set with the correspoding error code set by `Clock::now(ec)`.

[endsect]
[section:SuspendibleClock_resume Static Member Function `resume()`]

    void resume( system::error_code & ec = system::throws );

[*Effect:] Resumes the `SuspendibleClock`.

[*Throw:] Any exception the `Clock::now(ec)` can throw. Otherwise `ec` is set with the correspoding error code set by `Clock::now(ec)`.

[endsect]

[section:SuspendibleClock_suspended Static Member Function `suspended()`]

    duration suspended( system::error_code & ec = system::throws );

[*Returns:] the cumalative elapsed duration during which the `SuspendibleClock` has been suspendeed.

[*Throw:] Any exception the Clock::now function can throw if `ec == system::throws`. Otherwise `ec` is set with the correspoding error code set by `Clock::now(ec)`.

[endsect]

[endsect]

[/==================================================================]
[section:scoped_suspend_hpp Header `<boost/chrono/scoped_suspend.hpp>`]
[/==================================================================]

    namespace boost { namespace chrono {
        template <class Clock> struct is_suspendible;
        template <class Clock> class scoped_suspend;
    }}

[section Meta Function Class `is_suspendible`]

    template <class Clock>
    struct is_suspendible : mpl:: false_ {};

[endsect]

[section Template Class `scoped_suspend`]

    template <class Clock>
    class scoped_suspend {
    public:
        scoped_suspend(system::error_code & ec = system::throws) {}
        ~scoped_suspend() {}
    private:
        scoped_suspend(); // = delete;
        scoped_suspend(const scoped_suspend&); // = delete;
        scoped_suspend& operator=(const scoped_suspend&); // = delete;
    };

[endsect]

[endsect]


[/==================================================================]
[section:suspendible_clock_hpp Header `<boost/chrono/suspendible_clock.hpp>`]
[/==================================================================]

    namespace boost { namespace chrono {

        template <class Clock>
        class suspendible_clock;

        template <class Clock>
        struct is_suspendible<suspendible_clock<Clock> > : mpl:: true_ {};

        template <class Clock>
        class scoped_suspend<suspendible_clock<Clock> >;

    }}

[section Template Class `suspendible_clock<>`]

Given a `Clock`, `suspendible_clock<Clock>` is a model of SuspendibleClock.

    template < class Clock >
    class suspendible_clock {
    public:
        typedef typename Clock::duration                           duration;
        typedef typename Clock::rep                                       rep;
        typedef typename Clock::period                                    period;
        typedef chrono::time_point<suspendible_clock<Clock> >  time_point;
        static const bool is_monotonic =             true;

        static time_point now( system::error_code & ec = system::throws );

        static void suspend( system::error_code & ec = system::throws );
        static void resume( system::error_code & ec = system::throws );
        static duration suspended(system::error_code & ec = system::throws);
    };

[section `scoped_suspend` specialization for `suspendible_clock<>`]

        template <class Clock>
        class scoped_suspend<suspendible_clock<Clock> > {
        public:
            scoped_suspend(system::error_code & ec = system::throws);
            ~scoped_suspend();
        };

[endsect]

[endsect]

[endsect]
]
[endsect]


[/==================================================]
[section Stopwatches]
[/==================================================]
[/=============================================]
[section:stopwatches_hpp Header `<boost/stopwatches.hpp>`]
[/=============================================]

This file include all the stopwatches related files

    #include <boost/chrono/stopwatches.hpp>

[endsect]

[/=============================================]
[section:chrono_stopwatches_hpp Header `<boost/chrono/stopwatches.hpp>`]
[/=============================================]

This file include all the stopwatches related files

    #include <boost/chrono/scoped_stopclock.hpp>
    #include <boost/chrono/process_cpu_clocks.hpp>
    #include <boost/chrono/stopclock.hpp>
    #include <boost/chrono/stopclock_accumulator.hpp>
    #include <boost/chrono/stopwatch.hpp>
    #include <boost/chrono/stopwatch_accumulator.hpp>
    #include <boost/chrono/stopwatch_accumulator_formatter.hpp>
    #include <boost/chrono/stopwatch_formatter.hpp>
    #include <boost/chrono/stopwatch_reporter.hpp>
    #include <boost/chrono/stopwatch_scoped.hpp>
    #include <boost/chrono/time_formatter.hpp>
    #include <boost/chrono/t24_hours.hpp>
    #include <boost/chrono/t24_hours_formatter.hpp>

[endsect]

[section `Stopwatch` Requirements]

A Stopwatch measure the amount of time elapsed from a particular time when activated to when it is deactivated, or the accumulation of them.

A Stopwatch must meet the requirements in the following Table.

In this table `S`, `S1` and `S2` denote stopwatches types. `s` is an instance of `S`.

[table Stopwatch Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`S::clock`]        [A model of the Clock concept.]  [The clock associated to this Stopwatch.]]
    [[`S::duration`]        [`S::clock::duration`]  [The `duration` type of the `clock`.]]
    [[`S::time_point`]        [`S::clock::time_point`]  [The `time_point` type of the `clock`.]]
    [[`s.start()`]        [`S::time_point`]  [starts a Stopwatch.]]
    [[`s.restart()`]        [`std::pair<S::duration,S::time_point>`]  [restarts a Stopwatch.]]
    [[`s.stop()`]        [`S::duration`]  [stops a Stopwatch.]]
    [[`s.resume()`]        [`S::time_point`]  [starts a Stopwatch.]]
    [[`s.suspend()`]        [`S::duration`]  [stops a Stopwatch.]]
    [[`s.elapsed()`]        [`S::duration`]  [the elapsed time while the Stopwatch was running.]]
]


[section:stopwatch_start Member Function `start()`]

    time_point start( system::error_code & ec = system::throws );

[*Effect:] Starts running the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]
[section:stopwatch_stop Member Function `stop()`]

    duration stop( system::error_code & ec = system::throws );

[*Effect:] Stops running the stopwatch.

[*Returns:] The cummulated elapsed time.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]
[section:stopwatch_suspend Member Function `suspend()`]

    duration suspend( system::error_code & ec = system::throws );

[*Effect:] Suspends the stopwatch.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]
[section:stopwatch_resume Member Function `resume()`]

    time_point resume( system::error_code & ec = system::throws );

[*Effect:] Resumes the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]

[section:stopwatch_restart Member Function `restart()`]

    time_point restart( system::error_code & ec = system::throws );

[*Effect:] Stop/Start the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]

[endsect]
[/==================================================]
[section:stopwatch_hpp Header `<boost/chrono/stopwatch.hpp>`]
[/==================================================]


    namespace boost { namespace chrono  {
        struct dont_start_t;
        static const dont_start_t dont_start;

        template <class Clock=high_resolution_clock> class stopwatch;

        template <class Clock>
        struct stopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef stopwatch_formatter type;
        };

        template <class Clock>
        struct wstopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef wstopwatch_formatter type;
        };

        typedef <see above> system_stopwatch;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_stopwatch;
        #endif
        typedef <see above> high_resolution_stopwatch;
        typedef <see above> process_real_cpu_stopwatch;
        typedef <see above> process_user_cpu_stopwatch;
        typedef <see above> process_system_cpu_stopwatch;
    }}

[section Template Class `stopwatch<>`]

`stopwatch<>` is a model of a `Stopwatch`.

Knowing how long a part of a program takes to execute is useful in both test and production environments.
A `stopwatch` object measures elapsed time. It is recommended to use it with clocks that measure wall clock rather than CPU time since the intended use is performance measurement on systems where total elapsed time is more important than just process or CPU time.

The maximum measurable elapsed time depends on the Clock parameter. The accuracy of timings depends on the
accuracy of timing information provided the Clock, and this coudl varies a great deal from one clock to another.

        template <class Clock> class stopwatch {
        public:
            typedef Clock                       clock;
            typedef typename Clock::duration    duration;
            typedef typename Clock::time_point  time_point;

            explicit stopwatch( system::error_code & ec = system::throws );
            explicit stopwatch( const dont_start_t& t );

            ~timer();

            time_point start( system::error_code & ec = system::throws );
            duration stop( system::error_code & ec = system::throws );
            std::pair<duration,time_point> restart( system::error_code & ec = system::throws );

            duration suspend( system::error_code & ec = system::throws );
            time_point resume( system::error_code & ec = system::throws );

            duration elapsed( system::error_code & ec = system::throws );

            typedef stopwatch_runner<stopwatch<Clock> > scoped_run;
            typedef stopwatch_suspender<stopwatch<Clock> > scoped_suspend;
            typedef stopwatch_resumer<stopwatch<Clock> > scoped_resume;
            typedef stopwatch_reporter<stopwatch<Clock> > reporter;

        };

[section:stopwatch_elapsed Member Function `elapsed()`]

            duration elapsed(system::error_code & ec = system::throws) const;

[*Returns:] the elapsed time from the last call to start.

[*Throw:] Nothing.

[*Note:] the system::error_code & parameter is here to conform to the Stopwatch concept.

[endsect]

[endsect]

[section `stopwatch` useful typedefs]

        typedef boost::chrono::stopwatch< boost::chrono::system_clock > system_stopwatch;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::stopwatch< boost::chrono::monotonic_clock > monotonic_stopwatch;
        #endif
        typedef boost::chrono::stopwatch< boost::chrono::high_resolution_clock > high_resolution_stopwatch;

        typedef boost::chrono::stopwatch< boost::chrono::process_real_cpu_clock > process_real_cpu_stopwatch;
        typedef boost::chrono::stopwatch< boost::chrono::process_user_cpu_clock > process_user_cpu_stopwatch;
        typedef boost::chrono::stopwatch< boost::chrono::process_system_cpu_clock > process_system_cpu_stopwatch;

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_accumulator_hpp Header `<boost/chrono/stopwatch_accumulator.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <class Clock, class Accumulator> class stopwatch_accumulator;

        template <class Clock, class Accumulator>
        struct stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef stopwatch_accumulator_formatter type;
        };

        template <class Clock, class Accumulator>
        struct wstopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef wstopwatch_accumulator_formatter type;
        };

        typedef <see below> system_stopwatch_accumulator;
    #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see below> monotonic_stopwatch_accumulator;
    #endif
        typedef <see below> high_resolution_stopwatch_accumulator;

        typedef <see below> process_real_cpu_stopwatch_accumulator;
        typedef <see below> process_user_cpu_stopwatch_accumulator;
        typedef <see below> process_system_cpu_stopwatch_accumulator;

    }}


[section Template Class `stopwatch_accumulator<>`]

A `stopwatch_accumulator<>` is a model of a Stopwatch that allows to accumulate the time in several times instead of at once as it is the case of the class `stopwatch<>`.

        template <class Clock> class stopwatch_accumulator {
        public:
            typedef Clock                       clock;
            typedef typename Clock::duration    duration;
            typedef typename Clock::time_point  time_point;
            typedef Accumulator accumulator;

            stopwatch_accumulator();

            time_point start( system::error_code & ec = system::throws );
            duration stop( system::error_code & ec = system::throws );
            std::pair<duration,time_point> restart( system::error_code & ec = system::throws );

            duration suspend( system::error_code & ec = system::throws );
            time_point resume( system::error_code & ec = system::throws );

            duration elapsed(system::error_code & ec = system::throws);

            accumulator& accumulated( );
            void reset();

            typedef stopwatch_runner<stopwatch_accumulator<Clock> > scoped_run;
            typedef stopwatch_suspender<stopwatch_accumulator<Clock> > scoped_suspend;
            typedef stopwatch_resumer<stopwatch_accumulator<Clock> > scoped_resume;
            typedef stopwatch_reporter<stopwatch_accumulator<Clock> > reporter;
        };

[section:stopwatch_accumulator_c Constructor `stopwatch_accumulator()`]

    stopwatch_accumulator();

[*Effect:] Initialize the elapsed duration and the times counter to 0.

[endsect]
[section:stopwatch_accumulator_start Member Function `start()`]

    time_point start( system::error_code & ec = system::throws );

[*Effect:] Starts running the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]
[section:stopwatch_accumulator_stop Member Function `stop()`]

    duration stop( system::error_code & ec = system::throws );

[*Effect:] Stops running the stopwatch. Accumulates the elapsed time since the last start-like operation + the partial accumulated by resume/suspend operation.

[*Returns:] The cummulated elapsed time.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]
[section:stopwatch_accumulator_suspend Member Function `suspend()`]

    duration suspend( system::error_code & ec = system::throws );

[*Effect:] Suspends the stopwatch. Accumulates the elapsed time since the last start-like operation on a partial duration.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]
[section:stopwatch_accumulator_resume Member Function `resume()`]

    time_point resume( system::error_code & ec = system::throws );

[*Effect:] Resumes the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]

[section:stopwatch_accumulator_restart Member Function `restart()`]

    time_point restart( system::error_code & ec = system::throws );

[*Effect:] Stop/Start the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]
[section:stopwatch_accumulator_reset Member Function `reset()`]

    void reset( );

[*Effect:] Stop the stopwatch and reset the accumulator.

[*Throw:] Nothing.

[endsect]
[section:stopwatch_accumulator_elapsed Member Function `elapsed()`]

            duration elapsed(system::error_code & ec = system::throws) const;

[*Returns:] the cumulated elapsed time.

[*Throw:] Nothing.

[endsect]

[section:stopwatch_accumulator_accumulated Member Function `accumulated()`]

            accumulator& accumulated();

[*Returns:] the assocaited accumulator.

[*Throw:] Nothing.

[endsect]

[endsect]

[section `stopwatch_accumulator` useful typedefs]

    typedef boost::chrono::stopwatch_accumulator< boost::chrono::system_clock > system_stopwatch_accumulator;
#ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
    typedef boost::chrono::stopwatch_accumulator< boost::chrono::monotonic_clock > monotonic_stopwatch_accumulator;
#endif
    typedef boost::chrono::stopwatch_accumulator< boost::chrono::high_resolution_clock > high_resolution_stopwatch_accumulator;

    typedef boost::chrono::stopwatch_accumulator< boost::chrono::process_real_cpu_clock > process_real_cpu_stopwatch_accumulator;
    typedef boost::chrono::stopwatch_accumulator< boost::chrono::process_user_cpu_clock > process_user_cpu_stopwatch_accumulator;
    typedef boost::chrono::stopwatch_accumulator< boost::chrono::process_system_cpu_clock > process_system_cpu_stopwatch_accumulator;

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_scoped_hpp Header `<boost/chrono/stopwatch_scoped.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <class Clock> class stopwatch_runner;
        template <class Clock> class stopwatch_suspender;
        template <class Clock> class stopwatch_resumer;
    }}

Boost.Chrono provides some helper classes ensuring pairwised operations (start/stop, suspend/resume, resule/suspend).

[section Template Class `stopwatch_runner<>`]

This helper class ensures that the start/stop are pairwised. Start the associated accumulator at construction time, and stop it at destruction time.

    template <class Stopwatch> class stopwatch_runner {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_runner(stopwatch & a, system::error_code & ec = system::throws);
        ~stopwatch_runner();
        stopwatch_runner() = delete;
        stopwatch_runner(const stopwatch_runner&) = delete;
        stopwatch_runner& operator=(const stopwatch_runner&) = delete;
    };

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...
    }

[endsect]
[section Template Class `stopwatch_suspender<>`]

This helper class ensures that the suspend/resume are pairwised. Suspend the associated accumulator at construction time, and resume it at destruction time.

    template <class Stopwatch> class stopwatch_suspender {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_suspender(stopwatch & a, system::error_code & ec = system::throws);
        ~stopwatch_suspender();
        stopwatch_suspender() = delete;
        stopwatch_suspender(const stopwatch_suspender&) = delete;
        stopwatch_suspender& operator=(const stopwatch_suspender&) = delete;
    }

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...

         // call to some function we don't want to measure
         {
            stopwatch_suspender<stopwatch_accumulator<> > _(t);
            external_function();
         }
    }

[endsect]

[section Template Class `stopwatch_resumer<>`]

This helper class ensures that the resume/suspend are pairwised. Resume the associated accumulator at construction time, and suspecd it at destruction time.

    template <class Stopwatch> class stopwatch_resumer {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_resumer(stopwatch & a, system::error_code & ec = system::throws);
        ~stopwatch_resumer();
        stopwatch_resumer() = delete;
        stopwatch_resumer(const stopwatch_resumer&) = delete;
        stopwatch_resumer& operator=(const stopwatch_resumer&) = delete;
    }

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...

         // call to some function we don't want to measure
         {
            stopwatch_suspender<stopwatch_accumulator<> > _(t);

            {
                stopwatch_resumer<stopwatch_accumulator<> > _(t);

            }
         }
    }

[endsect]

[endsect]

[endsect]
[section Stopwatch Reporters]
[section `Formatter` Requirements]

A Formatter outputs on a given ostream a formatted string combining informations from a Stopwatch and the format and the double precission.

A Stopwatch must meet the requirements in the following Table.

In this table `F`  denote Fromaters types, `S` is a Stopwatch and `s` is an instance of `S`, `f` is `const char *` , `p` is and int, and `os` is a `std::ostream`, ec is a system::error_code

[table Stopwatch Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`F::default_os()`]        [std::otream&]  [The output stream.]]
    [[`F::default_places()`]        [`std::size_t`]  [The precission when displaying a double.]]
    [[`F::default_format()`]        [`const char*`]  [The default format.]]
    [[`F::show_time(s,f,p,os,ec)`]        [`S::time_point`]  [outputs on `os` a formatted string combining informations from the Stopwatch `s`, the format `f` and the double precission `p`.]]
]

[endsect]

[section `Formatter` related traits]

        template <class Stopwatch>
        struct stopwatch_reporter_default_formatter {
            typedef <see below> type;
        };

The nested typedef `type` defines the default formatter used by the `stopwatch_reporter` class when the `Formatter` parameter is not explicit.

[endsect]

[/==================================================]
[section:stopwatch_reporter_hpp Header `<boost/chrono/stopwatch_reporter.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <class Stopwatch>
        struct basic_stopwatch_reporter_default_formatter;
        template <class Stopwatch>
        struct stopwatch_reporter_default_formatter;
        template <class Stopwatch>
        struct wstopwatch_reporter_default_formatter;

        template <class Stopwatch, class Formatter=typename stopwatch_reporter_default_formatter<Stopwatch>::type>
        class stopwatch_reporter;
    }}

[section Template Class `basic_stopwatch_reporter<>`]

class `basic_stopwatch_reporter` provides a everything a Timer provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precission): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class basic_stopwatch_reporter : public Stopwatch {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit basic_stopwatch_reporter( system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( const std::string & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( int places,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = system::throws );

        ~basic_stopwatch_reporter();

        void report( system::error_code & ec = system::throws );
        bool reported() const;


        typedef stopwatch_runner<basic_stopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<basic_stopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<basic_stopwatch_reporter<Stopwatch> > scoped_resume;
    };

[endsect]

[section Template Class `stopwatch_reporter<>`]

class `stopwatch_reporter` provides a everything a Timer provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precission): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class stopwatch_reporter : public basic_stopwatch_reporter<Stopwatch,Formatter> {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit stopwatch_reporter( system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( const std::string & format,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( int places,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = system::throws );

        ~stopwatch_reporter();

        void report( system::error_code & ec = system::throws );
        bool reported() const;


        typedef stopwatch_runner<stopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<stopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<stopwatch_reporter<Stopwatch> > scoped_resume;
    };

Usage

    void f1()
    {
        typedef stopwatch_reporter<stopwatch_accumulator<> > accumulator;
        static accumulator t;
        accumulator::scoped_run _(t);
        // ...

        // call to some function we don't want to measure
        {
            accumulator::scoped_suspend _(t);
            external_function();
        }
    }

[endsect]

[section Template Class `wstopwatch_reporter<>`]

class `wstopwatch_reporter` provides a everything a Timer provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precission): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class wstopwatch_reporter : public basic_wstopwatch_reporter<Stopwatch,Formatter> {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit wstopwatch_reporter( system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( const std::string & format,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( int places,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = system::throws );

        ~wstopwatch_reporter();

        void report( system::error_code & ec = system::throws );
        bool reported() const;


        typedef stopwatch_runner<wstopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<wstopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<wstopwatch_reporter<Stopwatch> > scoped_resume;
    };

Usage

    void f1()
    {
        typedef wstopwatch_reporter<stopwatch_accumulator<> > accumulator;
        static accumulator t;
        accumulator::scoped_run _(t);
        // ...

        // call to some function we don't want to measure
        {
            accumulator::scoped_suspend _(t);
            external_function();
        }
    }

[endsect]

[endsect]

[/==================================================]
[section:stopclock_hpp Header `<boost/chrono/stopclock.hpp>`]
[/==================================================]

    namespace boost { namespace chrono {
        template < class Clock, class Formatter > class basic_stopclock;
        template < class Clock, class Formatter > class stopclock;
        template < class Clock, class Formatter > class wstopclock;

        typedef <see above> system_stopclock;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_stopclock;
        #endif
        typedef <see above> high_resolution_stopclock;
        typedef <see above> process_real_cpu_stopclock;
        typedef <see above> process_user_cpu_stopclock;
        typedef <see above> process_system_cpu_stopclock;

        typedef <see above> system_wstopclock;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_wstopclock;
        #endif
        typedef <see above> high_resolution_wstopclock;
        typedef <see above> process_real_cpu_wstopclock;
        typedef <see above> process_user_cpu_wstopclock;
        typedef <see above> process_system_cpu_wstopclock;
    }}

[section Template Class `basic_stopclock<>`]

`basic_stopclock<Clock>` template class is a shortcut of `basic_stopwatch_reporter<stopwatch<Clock>>`

    template< class Clock, class Formatter>
    class basic_stopclock : public basic_stopwatch_reporter<stopwatch<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit basic_stopclock( system::error_code & ec = system::throws );
        explicit basic_stopclock( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock( int places,
                    system::error_code & ec = system::throws );

        basic_stopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        basic_stopclock( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        basic_stopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[section Template Class `stopclock<>`]

`stopclock<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>` with a specific default formatter.

    template
        < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class stopclock : public basic_stopclock<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit stopclock( system::error_code & ec = system::throws );
        explicit stopclock( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit stopclock( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit stopclock( int places,
                    system::error_code & ec = system::throws );

        stopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        stopclock( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        stopclock( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        stopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section `stopclock` useful typedefs]

        typedef boost::chrono::stopclock< boost::chrono::system_clock > system_stopwatch_reporter;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::stopclock< boost::chrono::monotonic_clock > monotonic_stopwatch_reporter;
        #endif
        typedef boost::chrono::stopclock< boost::chrono::high_resolution_clock > high_resolution_stopclock;
        typedef boost::chrono::stopclock< boost::chrono::process_real_cpu_clock > process_real_cpu_stopclock;
        typedef boost::chrono::stopclock< boost::chrono::process_user_cpu_clock > process_user_cpu_stopclock;
        typedef boost::chrono::stopclock< boost::chrono::process_system_cpu_clock > process_system_cpu_stopclock;

[endsect]

[section Template Class `wstopclock<>`]

`wstopclock<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>` with a specific default formatter.

    template
        < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class wstopclock : public basic_wstopclock<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit wstopclock( system::error_code & ec = system::throws );
        explicit wstopclock( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit wstopclock( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit wstopclock( int places,
                    system::error_code & ec = system::throws );

        wstopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        wstopclock( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        wstopclock( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        wstopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section `wstopclock` useful typedefs]

        typedef boost::chrono::wstopclock< boost::chrono::system_clock > system_stopwatch_reporter;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::wstopclock< boost::chrono::monotonic_clock > monotonic_stopwatch_reporter;
        #endif
        typedef boost::chrono::wstopclock< boost::chrono::high_resolution_clock > high_resolution_wstopclock;
        typedef boost::chrono::wstopclock< boost::chrono::process_real_cpu_clock > process_real_cpu_wstopclock;
        typedef boost::chrono::wstopclock< boost::chrono::process_user_cpu_clock > process_user_cpu_wstopclock;
        typedef boost::chrono::wstopclock< boost::chrono::process_system_cpu_clock > process_system_cpu_wstopclock;

[endsect]


[endsect]

[/==================================================]
[section:stopclock_accumulator_hpp Header `<boost/chrono/stopclock_accumulator.hpp>`]
[/==================================================]

    namespace boost { namespace chrono {
        template < class Clock, class Formatter >
        class basic_stopclock_accumulator;
        template < class Clock, class Formatter >
        class stopclock_accumulator;
        template < class Clock, class Formatter >
        class wstopclock_accumulator;

        typedef <see above> system_stopclock_accumulator;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_stopclock_accumulator;
        #endif
        typedef <see above> high_resolution_stopclock_accumulator;
        typedef <see above> process_real_cpu_stopclock_accumulator;
        typedef <see above> process_user_cpu_stopclock_accumulator;
        typedef <see above> process_system_cpu_stopclock_accumulator;

        typedef <see above> system_wstopclock_accumulator;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_wstopclock_accumulator;
        #endif
        typedef <see above> high_resolution_wstopclock_accumulator;
        typedef <see above> process_real_cpu_wstopclock_accumulator;
        typedef <see above> process_user_cpu_wstopclock_accumulator;
        typedef <see above> process_system_cpu_wstopclock_accumulator;
    }}

[section Template Class `basic_stopclock_accumulator<>`]

`basic_stopclock_accumulator<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>`

    template
        < class Clock=high_resolution_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class basic_stopclock_accumulator
        : public basic_stopwatch_reporter<stopwatch_accumulator<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit basic_stopclock_accumulator( system::error_code & ec = system::throws );
        explicit basic_stopclock_accumulator( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock_accumulator( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock_accumulator( int places,
                    system::error_code & ec = system::throws );

        basic_stopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        basic_stopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[section Template Class `stopclock_accumulator<>`]

`stopclock_accumulator<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>` with a specific formatter.

    template
        < class Clock=high_resolution_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class stopclock_accumulator
        : public basic_stopclock_accumulator<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit stopclock_accumulator( system::error_code & ec = system::throws );
        explicit stopclock_accumulator( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit stopclock_accumulator( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit stopclock_accumulator( int places,
                    system::error_code & ec = system::throws );

        stopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        stopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section `stopclock_accumulator` useful typedefs]

        typedef boost::chrono::stopclock_accumulator< boost::chrono::system_clock > system_stopwatch_reporter;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::stopclock_accumulator< boost::chrono::monotonic_clock > monotonic_stopwatch_reporter;
        #endif
        typedef boost::chrono::stopclock_accumulator< boost::chrono::high_resolution_clock > high_resolution_stopclock_accumulator;
        typedef boost::chrono::stopclock_accumulator< boost::chrono::process_real_cpu_clock > process_real_cpu_stopclock_accumulator;
        typedef boost::chrono::stopclock_accumulator< boost::chrono::process_user_cpu_clock > process_user_cpu_stopclock_accumulator;
        typedef boost::chrono::stopclock_accumulator< boost::chrono::process_system_cpu_clock > process_system_cpu_stopclock_accumulator;

[endsect]
[section Template Class `wstopclock_accumulator<>`]

`wstopclock_accumulator<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>` with a specific formatter.

    template
        < class Clock=high_resolution_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class wstopclock_accumulator
        : public basic_wstopclock_accumulator<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit wstopclock_accumulator( system::error_code & ec = system::throws );
        explicit wstopclock_accumulator( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit wstopclock_accumulator( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit wstopclock_accumulator( int places,
                    system::error_code & ec = system::throws );

        wstopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        wstopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section `wstopclock_accumulator` useful typedefs]

        typedef boost::chrono::wstopclock_accumulator< boost::chrono::system_clock > system_stopwatch_reporter;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::wstopclock_accumulator< boost::chrono::monotonic_clock > monotonic_stopwatch_reporter;
        #endif
        typedef boost::chrono::wstopclock_accumulator< boost::chrono::high_resolution_clock > high_resolution_wstopclock_accumulator;
        typedef boost::chrono::wstopclock_accumulator< boost::chrono::process_real_cpu_clock > process_real_cpu_wstopclock_accumulator;
        typedef boost::chrono::wstopclock_accumulator< boost::chrono::process_user_cpu_clock > process_user_cpu_wstopclock_accumulator;
        typedef boost::chrono::wstopclock_accumulator< boost::chrono::process_system_cpu_clock > process_system_cpu_wstopclock_accumulator;

[endsect]
[endsect]

[/==================================================]
[section:scoped_stopclock_hpp Header `<boost/chrono/scoped_stopclock.hpp>`]
[/==================================================]

    namespace boost { namespace chrono {
        template < class Clock, class Formatter > class scoped_stopclock;
    }}

[section Template Class `scoped_stopclock<>`]

`scoped_stopclock<>`is like a `stopclock<>` but that in addition will output a scoped trace. At construction time it will output

    {{{ <string>

and at destruction time

    }}} <string> <output of stopwatch_reporter>

A typical ussage of this class is

    int f1(long j)
    {
      scoped_stopclock<> _(BOOST_CURRENT_FUNCTION);

      for ( long i = 0; i < j; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }

    template < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class scoped_stopclock
        : public stopwatch_reporter<stopwatch<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit scoped_stopclock( const std::string& func,
                    system::error_code & ec = system::throws );
        scoped_stopclock( const std::string& func, ostream_type & os,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, const string_type & format,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, int places,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os,
                    const string_type & format,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, const string_type & format,
                    int places, system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os, int places,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, int places,
                    const string_type & format, system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os,
                    const string_type & format, int places,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os, int places,
                    const string_type & format, system::error_code & ec = system::throws );

        ~scoped_stopclock();

        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[endsect]
[endsect]
[section Stopwatch Formatters]

[/==================================================]
[section:stopwatch_formatter_hpp Header `<boost/chrono/stopwatch_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_stopwatch_formatter;

        typedef basic_stopwatch_formatter<char> stopwatch_formatter;
        typedef basic_stopwatch_formatter<wchar_t> wstopwatch_formatter;
    }}

[section Template Class `basic_stopwatch_formatter<>`]

`stopwatch_formatter` is a model of `Formatter`.

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    >
    class basic_stopwatch_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template < class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%ts\\n", where

* `%d` : the result of elapsed() when the reporting is done.

The time is given using the suffix "s" following the System International d'Unites Std.

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_accumulator_formatter_hpp Header `<boost/chrono/stopwatch_accumulator_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace chrono  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        > basic_stopwatch_accumulator_formatter;
        typedef basic_stopwatch_formatter<char> stopwatch_formatter;
        typedef basic_stopwatch_formatter<wchar_t> wstopwatch_formatter;
    }}

[section Template Class `basic_stopwatch_accumulator_formatter<>`]

`stopwatch_accumulator_formatter` is a model of `Formatter`

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    class basic_stopwatch_accumulator_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%c times, sum=%ss, min=%ms, max=%Ms, mean=%as, frequency=%fHz, lifetime=%ls, percentage=%p\%\\n", where

* `%c` : the counter of the number of times the pair srat/stop has been called.
* `%s` : the sum of the samples of elapsed time between the call to start/stop.
* `%m` : the min of the samples of elapsed time between the call to start/stop.
* `%M` : the max of the samples of elapsed time between the call to start/stop.
* `%a` : the mean of the samples of elapsed time between the call to start/stop.
* `%f` : the frequency of calls to start.
* `%l` : the lifetime of the stopwatch_accumulator.
* `%p` : the percentage of time spent by this stopwatch respect to its lifetime.

The time is given using the suffix "s", the frequency is given using the suffix "Hz", both following the System International d'Unites Std.

[endsect]

[endsect]

[/==================================================================]
[section:time_formatter_hpp Header `<boost/chrono/time_formatter.hpp>`]
[/==================================================================]


    namespace boost { namespace chrono {

        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_time_formatter;

        typedef basic_time_formatter<char> time_formatter;
        typedef basic_time_formatter<wchar_t> wtime_formatter;

        template <>
        struct stopwatch_reporter_default_formatter<stopwatch<process_cpu_clock> > {
            typedef time_formatter type;
        };

    } }

[section Template Class `basic_time_formatter<>`]

    template <typename CharT, typename Traits, class Alloc>
    class basic_time_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_
            , const char * format, int places, std::ostream & os
            , system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "nreal %rs, cpu %cs (%p%), user %us, system %ss\\n", where

* `%r` : real process clock
* `%u` : user process clock
* `%s` : system process clock
* `%c` : user+system process clock
* `%p` : percentage (user+system)/real process clock

All the units are given using the suffix "s" following the System International d'Unites Std.

[endsect]

[endsect]

[/==================================================]
[section:t24_hours_hpp Header `<boost/chrono/t24_hours.hpp>`]
[/==================================================]

    namespace boost { namespace chrono {
        class t24_hours;
    }}

[section Class `t24_hours`]

    class t24_hours {
    public:
        typedef boost::chrono::duration<boost::int_least32_t, ratio<24*3600> > days;
        typedef boost::chrono::hours hours;
        typedef boost::chrono::minutes minutes;
        typedef boost::chrono::seconds seconds;
        typedef boost::chrono::nanoseconds nanoseconds;

        days days_;
        hours hours_;
        minutes minutes_;
        seconds seconds_;
        nanoseconds nanoseconds_;

        template <class Rep, class Period>
            explicit t24_hours(const boost::chrono::duration<Rep, Period>& d);
    };

[endsect]
[endsect]

[/==================================================================]
[section:t24_hours_formatter_hpp Header `<boost/chrono/t24_hours_formatter.hpp>`]
[/==================================================================]


    namespace boost { namespace chrono {

        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_24_hours_formatter;

        typedef basic_24_hours_formatter<char> t24_hours_formatter;
        typedef basic_24_hours_formatter<wchar_t> wt24_hours_formatter;

    } }

[section Template Class `basic_24_hours_formatter<>`]

    template <typename CharT, typename Traits, class Alloc>
    class basic_24_hours_formatter {
    public:
        static std::ostream &  default_os();
        static const char * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_
            , const char * format, int places, std::ostream & os
            , system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%d days(s) %h:%m:%s.%n\\n", where

* `%d` : days
* `%h` : hours
* `%m` : minutes
* `%s` : seconds
* `%n` : nanoseconds

[endsect]

[endsect]

[endsect]
[section Deprecated Headers]
[/==================================================]
[section:timer_hpp Deprecated Header `<boost/chrono/timer.hpp>`]
[/==================================================]

This header has been deprecated, use instead <boost/chrono/stopwatch.hpp>.

    namespace boost { namespace chrono  {
        template <class Clock=high_resolution_clock> class timer;
        typedef <see above> system_timer;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_timer;
        #endif
        typedef <see above> high_resolution_timer;
    }}

[/
        typedef <see above> process_real_cpu_timer;
        typedef <see above> process_user_cpu_timer;
        typedef <see above> process_system_cpu_timer;
]
[section Template Class `timer<>`]

Knowing how long a part of a program takes to execute is useful in both test and production environments.
A `timer` object measures elapsed time. It is recommended to use it with clocks that measure wall clock rather than CPU time since the intended use is performance measurement on systems where total elapsed time is more important than just process or CPU time.

The maximum measurable elapsed time depends on the Clock parameter. The accuracy of timings depends on the
accuracy of timing information provided the Clock, and this coudl varies a great deal from one clock to another.

        template <class Clock> class timer {
        public:
            typedef Clock                       clock;
            typedef typename Clock::duration    duration;
            typedef typename Clock::time_point  time_point;

            explicit timer( system::error_code & ec = system::throws );

            ~timer();

            void start( system::error_code & ec = system::throws );
            duration elapsed( system::error_code & ec = system::throws );

        };

[endsect]

[section `timer` useful typedefs]

        typedef boost::chrono::timer< boost::chrono::system_clock > system_timer;
        #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::timer< boost::chrono::monotonic_clock > monotonic_timer;
        #endif
        typedef boost::chrono::timer< boost::chrono::high_resolution_clock > high_resolution_timer;

[/
        typedef boost::chrono::timer< boost::chrono::process_real_cpu_clock > process_real_cpu_timer;
        typedef boost::chrono::timer< boost::chrono::process_user_cpu_clock > process_user_cpu_timer;
        typedef boost::chrono::timer< boost::chrono::process_system_cpu_clock > process_system_cpu_timer;
]
[endsect]
[endsect]


[/==================================================================]
[section:process_times_hpp Deprecated Header `<boost/chrono/process_times.hpp>`]
[/==================================================================]

This header has been deprecated. Use instead `<boost/chrono/process_cpu_clocks.hpp>`, `<boost/chrono/stopwatch.hpp>`, `<boost/chrono/stopwatch_reporter.hpp>` and `<boost/chrono/stopclock.hpp>` files.

    namespace boost { namespace chrono {

        class process_clock;
        typedef <see below> process_times;
        class process_timer;
        class run_timer;

    } }

[section Class `process_clock`]

`process_clock` doesn't satisfy the Clock Requirements as the function now do not follows the Clock prototype.

`process_clock` provides a thin wrapper around the operating system's process timer API. For POSIX-like systems, that's the times() function, while for Windows, it's the GetProcessTimes() function.

The process relative real, user and system current time can be obtained at once by calling `process_clock::now()`.


        class process_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<process_clock>    time_point;
            static const bool is_monotonic =             true;

            struct process_times;
            static void now( process_times & times,
                             system::error_code & ec = system::throws );
        };

[section Class `process_times`]

        struct process_times {
            process_clock::duration real;    // real (i.e wall clock) time
            process_clock::duration user;    // user cpu time
            process_clock::duration system;  // system cpu time
        };

[endsect]

[endsect]
[section Typedef `process_times`]

    typedef process_clock::process_times process_times;

This is a synonym of process_clock::process_times included for backward compatibility.

[endsect]

[section Class `process_timer`]

Knowing how long a program takes to execute is useful in both test and production environments. It is also helpful if such timing information is broken down into real (wall clock) time, CPU time spent by the user, and CPU time spent by the operating system servicing user requests.

`process_timer<>` is the `timer<>` equivalent associated to the pseudo-clock `process_clock`. It behaves like `timer<>` but it uses the specific `process_clock:now()` function.

        class process_timer {
        public:
            typedef process_clock                          clock;
            typedef process_clock::duration                duration;
            typedef process_clock::time_point              time_point;

            explicit process_timer( system::error_code & ec = system::throws );

            ~process_timer();
            void  start( system::error_code & ec = system::throws );
            void  elapsed( process_times & times, system::error_code & ec = system::throws );
        };

[endsect]
[section Class `run_timer`]

class `run_timer` provides a complete run time reporting package that can be invoked in a single line of code. The reporting is controled by two parameters:

* format : The output format
* places(precission): the number of decimal placess used.

The default places is given by default_places and is 3.

The default format is "nreal %rs, cpu %cs (%p%), user %us, system %ss\\n", where

* `%r` : real process clock
* `%u` : user process clock
* `%s` : system process clock
* `%c` : user+system process clock
* `%p` : percentage (user+system)/real process clock

All the units are given using the suffix "s" following the System International d'Unites Std.

        class run_timer : public process_timer {
        public:
            explicit run_timer( system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os,
                        system::error_code & ec = system::throws );

            explicit run_timer( const std::string & format,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, const std::string & format,
                        system::error_code & ec = system::throws );

            explicit run_timer( const std::string & format, int places,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, const std::string & format, int places,
                        system::error_code & ec = system::throws );

            explicit run_timer( int places,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, int places,
                        system::error_code & ec = system::throws );

            explicit run_timer( int places, const std::string & format,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, int places, const std::string & format,
                        system::error_code & ec = system::throws );

            ~run_timer();

            void start( system::error_code & ec = system::throws );

            void report( system::error_code & ec = system::throws );

            void test_report( duration real_, duration user_, duration system_ );
            bool reported() const;
            static int default_places();
        };


[endsect]

[endsect]

[endsect]

[endsect]


[/===============]
[section Examples]
[/===============]

[/===============]
[section SI-units]
[/===============]

Type-safe "physics" code interoperating with boost::chrono::duration types and taking advantage of the boost::ratio infrastructure and design philosophy.

length - mimics boost::chrono::duration except restricts representation to double.
Uses boost::ratio facilities for length units conversions.

    template <class Ratio>
    class length {
    private:
        double len_;
    public:
        typedef Ratio ratio;
        length() : len_(1) {}
        length(const double& len) : len_(len) {}

        template <class R>
        length(const length<R>& d)
                : len_(d.count() * boost::ratio_divide<Ratio, R>::type::den /
                                   boost::ratio_divide<Ratio, R>::type::num) {}

        double count() const {return len_;}

        length& operator+=(const length& d) {len_ += d.count(); return *this;}
        length& operator-=(const length& d) {len_ -= d.count(); return *this;}

        length operator+() const {return *this;}
        length operator-() const {return length(-len_);}

        length& operator*=(double rhs) {len_ *= rhs; return *this;}
        length& operator/=(double rhs) {len_ /= rhs; return *this;}
    };


Sparse sampling of length units

    typedef length<boost::ratio<1> >          meter;        // set meter as "unity"
    typedef length<boost::centi>              centimeter;   // 1/100 meter
    typedef length<boost::kilo>               kilometer;    // 1000  meters
    typedef length<boost::ratio<254, 10000> > inch;         // 254/10000 meters

length takes ratio instead of two integral types so that definitions can be made like so:

    typedef length<boost::ratio_multiply<boost::ratio<12>, inch::ratio>::type>   foot;  // 12 inchs
    typedef length<boost::ratio_multiply<boost::ratio<5280>, foot::ratio>::type> mile;  // 5280 feet

Need a floating point definition of seconds

    typedef boost::chrono::duration<double> seconds;                         // unity

Demo of (scientific) support for sub-nanosecond resolutions

    typedef boost::chrono::duration<double,  boost::pico> picosecond;  // 10^-12 seconds
    typedef boost::chrono::duration<double, boost::femto> femtosecond; // 10^-15 seconds
    typedef boost::chrono::duration<double,  boost::atto> attosecond;  // 10^-18 seconds

A very brief proof-of-concept for SIUnits-like library. Hard-wired to floating point seconds and meters, but accepts other units.

    template <class R1, class R2>
    class quantity
    {
        double q_;
    public:
        typedef R1 time_dim;
        typedef R2 distance_dim;
        quantity() : q_(1) {}

        double get() const {return q_;}
        void set(double q) {q_ = q;}
    };

    template <>
    class quantity<boost::ratio<1>, boost::ratio<0> >
    {
        double q_;
    public:
        quantity() : q_(1) {}
        quantity(seconds d) : q_(d.count()) {}  // note:  only User1::seconds needed here

        double get() const {return q_;}
        void set(double q) {q_ = q;}
    };

    template <>
    class quantity<boost::ratio<0>, boost::ratio<1> >
    {
        double q_;
    public:
        quantity() : q_(1) {}
        quantity(meter d) : q_(d.count()) {}  // note:  only User1::meter needed here

        double get() const {return q_;}
        void set(double q) {q_ = q;}
    };

    template <>
    class quantity<boost::ratio<0>, boost::ratio<0> >
    {
        double q_;
    public:
        quantity() : q_(1) {}
        quantity(double d) : q_(d) {}

        double get() const {return q_;}
        void set(double q) {q_ = q;}
    };

Example of SI-Units

    typedef quantity<boost::ratio<0>, boost::ratio<0> >  Scalar;
    typedef quantity<boost::ratio<1>, boost::ratio<0> >  Time;         // second
    typedef quantity<boost::ratio<0>, boost::ratio<1> >  Distance;     // meter
    typedef quantity<boost::ratio<-1>, boost::ratio<1> > Speed;        // meter/second
    typedef quantity<boost::ratio<-2>, boost::ratio<1> > Acceleration; // meter/second^2

Quantity arithmetics

    template <class R1, class R2, class R3, class R4>
    quantity<typename boost::ratio_subtract<R1, R3>::type, typename boost::ratio_subtract<R2, R4>::type>
    operator/(const quantity<R1, R2>& x, const quantity<R3, R4>& y)
    {
        typedef quantity<typename boost::ratio_subtract<R1, R3>::type,
                        typename boost::ratio_subtract<R2, R4>::type> R;
        R r;
        r.set(x.get() / y.get());
        return r;
    }

    template <class R1, class R2, class R3, class R4>
    quantity<typename boost::ratio_add<R1, R3>::type, typename boost::ratio_add<R2, R4>::type>
    operator*(const quantity<R1, R2>& x, const quantity<R3, R4>& y)
    {
        typedef quantity<typename boost::ratio_add<R1, R3>::type,
                        typename boost::ratio_add<R2, R4>::type> R;
        R r;
        r.set(x.get() * y.get());
        return r;
    }

    template <class R1, class R2>
    quantity<R1, R2>
    operator+(const quantity<R1, R2>& x, const quantity<R1, R2>& y)
    {
        typedef quantity<R1, R2> R;
        R r;
        r.set(x.get() + y.get());
        return r;
    }

    template <class R1, class R2>
    quantity<R1, R2>
    operator-(const quantity<R1, R2>& x, const quantity<R1, R2>& y)
    {
        typedef quantity<R1, R2> R;
        R r;
        r.set(x.get() - y.get());
        return r;
    }

Example type-safe physics function

    Distance
    compute_distance(Speed v0, Time t, Acceleration a)
    {
        return v0 * t + Scalar(.5) * a * t * t;  // if a units mistake is made here it won't compile
    }


Exercise example type-safe physics function and show interoperation
of custom time durations (User1::seconds) and standard time durations (boost::hours).
Though input can be arbitrary (but type-safe) units, output is always in SI-units
(a limitation of the simplified Units lib demoed here).

    int main()
    {
        typedef boost::ratio<8, BOOST_INTMAX_C(0x7FFFFFFFD)> R1;
        typedef boost::ratio<3, BOOST_INTMAX_C(0x7FFFFFFFD)> R2;
        typedef User1::quantity<boost::ratio_subtract<boost::ratio<0>, boost::ratio<1> >::type,
                                 boost::ratio_subtract<boost::ratio<1>, boost::ratio<0> >::type > RR;
        typedef boost::ratio_subtract<R1, R2>::type RS;
        std::cout << RS::num << '/' << RS::den << '\n';


        std::cout << "*************\n";
        std::cout << "* testUser1 *\n";
        std::cout << "*************\n";
        User1::Distance d( User1::mile(110) );
        User1::Time t( boost::chrono::hours(2) );

        RR r=d / t;
        //r.set(d.get() / t.get());

        User1::Speed rc= r;

        User1::Speed s = d / t;
        std::cout << "Speed = " << s.get() << " meters/sec\n";
        User1::Acceleration a = User1::Distance( User1::foot(32.2) ) / User1::Time() / User1::Time();
        std::cout << "Acceleration = " << a.get() << " meters/sec^2\n";
        User1::Distance df = compute_distance(s, User1::Time( User1::seconds(0.5) ), a);
        std::cout << "Distance = " << df.get() << " meters\n";
        std::cout << "There are " << User1::mile::ratio::den << '/' << User1::mile::ratio::num << " miles/meter";
        User1::meter mt = 1;
        User1::mile mi = mt;
        std::cout << " which is approximately " << mi.count() << '\n';
        std::cout << "There are " << User1::mile::ratio::num << '/' << User1::mile::ratio::den << " meters/mile";
        mi = 1;
        mt = mi;
        std::cout << " which is approximately " << mt.count() << '\n';
        User1::attosecond as(1);
        User1::seconds sec = as;
        std::cout << "1 attosecond is " << sec.count() << " seconds\n";
        std::cout << "sec = as;  // compiles\n";
        sec = User1::seconds(1);
        as = sec;
        std::cout << "1 second is " << as.count() << " attoseconds\n";
        std::cout << "as = sec;  // compiles\n";
        std::cout << "\n";
      return 0;
    }

[/ratio_test_cpp]

[endsect]

[/===============]
[section How you override the duration's default constructor]

Next follows how you override the duration's default constructor to do anything you want (in this case zero). All we need to do is to change the representation

    namespace I_dont_like_the_default_duration_behavior {

    template <class R>
    class zero_default
    {
    public:
        typedef R rep;

    private:
        rep rep_;
    public:
        zero_default(rep i = 0) : rep_(i) {}
        operator rep() const {return rep_;}

        zero_default& operator+=(zero_default x) {rep_ += x.rep_; return *this;}
        zero_default& operator-=(zero_default x) {rep_ -= x.rep_; return *this;}
        zero_default& operator*=(zero_default x) {rep_ *= x.rep_; return *this;}
        zero_default& operator/=(zero_default x) {rep_ /= x.rep_; return *this;}

        zero_default  operator+ () const {return *this;}
        zero_default  operator- () const {return zero_default(-rep_);}
        zero_default& operator++()       {++rep_; return *this;}
        zero_default  operator++(int)    {return zero_default(rep_++);}
        zero_default& operator--()       {--rep_; return *this;}
        zero_default  operator--(int)    {return zero_default(rep_--);}

        friend zero_default operator+(zero_default x, zero_default y) {return x += y;}
        friend zero_default operator-(zero_default x, zero_default y) {return x -= y;}
        friend zero_default operator*(zero_default x, zero_default y) {return x *= y;}
        friend zero_default operator/(zero_default x, zero_default y) {return x /= y;}

        friend bool operator==(zero_default x, zero_default y) {return x.rep_ == y.rep_;}
        friend bool operator!=(zero_default x, zero_default y) {return !(x == y);}
        friend bool operator< (zero_default x, zero_default y) {return x.rep_ < y.rep_;}
        friend bool operator<=(zero_default x, zero_default y) {return !(y < x);}
        friend bool operator> (zero_default x, zero_default y) {return y < x;}
        friend bool operator>=(zero_default x, zero_default y) {return !(x < y);}
    };

    typedef boost::chrono::duration<zero_default<long long>, boost::nano        > nanoseconds;
    typedef boost::chrono::duration<zero_default<long long>, boost::micro       > microseconds;
    typedef boost::chrono::duration<zero_default<long long>, boost::milli       > milliseconds;
    typedef boost::chrono::duration<zero_default<long long>                      > seconds;
    typedef boost::chrono::duration<zero_default<long long>, boost::ratio<60>   > minutes;
    typedef boost::chrono::duration<zero_default<long long>, boost::ratio<3600> > hours;
    }

Usage

    using namespace I_dont_like_the_default_duration_behavior;

    milliseconds ms;
    std::cout << ms.count() << '\n';

['See the file i_dont_like_the_default_duration_behavior.cpp]

[endsect]

[/==================]
[section min utility]

Returns the earliest time_point.

    template <class Clock, class Duration1, class Duration2>
    typename boost::common_type<time_point<Clock, Duration1>,
                         time_point<Clock, Duration2> >::type
    min(time_point<Clock, Duration1> t1, time_point<Clock, Duration2> t2)
    {
        return t2 < t1 ? t2 : t1;
    }

Being able to *easily* write this function is a major feature!

    typedef time_point<system_clock,
      boost::common_type<system_clock::duration, seconds>::type> T1;
    typedef time_point<system_clock,
      boost::common_type<system_clock::duration, nanoseconds>::type> T2;
    typedef boost::common_type<T1, T2>::type T3;
    /*auto*/ T1 t1 = system_clock::now() + seconds(3);
    /*auto*/ T2 t2 = system_clock::now() + nanoseconds(3);
    /*auto*/ T3 t3 = min(t1, t2);


[endsect]

[/==================]
[section Cycle count]

    #include <boost/chrono/chrono.hpp>
    #include <boost/type_traits.hpp>

    #include <iostream>

    using namespace boost::chrono;


    template <long long speed>
    struct cycle_count
    {
        typedef typename boost::ratio_multiply<boost::ratio<speed>, boost::mega>::type frequency;  // Mhz
        typedef typename boost::ratio_divide<boost::ratio<1>, frequency>::type period;
        typedef long long rep;
        typedef boost::chrono::duration<rep, period> duration;
        typedef boost::chrono::time_point<cycle_count> time_point;

        static time_point now()
        {
            static long long tick = 0;
            // return exact cycle count
            return time_point(duration(++tick));  // fake access to clock cycle count
        }
    };

    template <long long speed>
    struct approx_cycle_count
    {
        static const long long frequency = speed * 1000000;  // MHz
        typedef nanoseconds duration;
        typedef duration::rep rep;
        typedef duration::period period;
        static const long long nanosec_per_sec = period::den;
        typedef boost::chrono::time_point<approx_cycle_count> time_point;

        static time_point now()
        {
            static long long tick = 0;
            // return cycle count as an approximate number of nanoseconds
            // compute as if nanoseconds is only duration in the std::lib
            return time_point(duration(++tick * nanosec_per_sec / frequency));
        }
    };


['See the file libs/chrono/example/cycle_count.cpp]

[endsect]

[/==================]
[section xtime conversions]

Example round_up utility:  converts d to To, rounding up for inexact conversions
Being able to *easily* write this function is a major feature!

    #include <boost/chrono/chrono.hpp>
    #include <boost/type_traits.hpp>

    #include <iostream>

    using namespace boost::chrono;

    template <class To, class Rep, class Period>
    To
    round_up(duration<Rep, Period> d)
    {
        To result = duration_cast<To>(d);
        if (result < d)
            ++result;
        return result;
    }

Demonstrate interaction with xtime-like facility:


    struct xtime
    {
        long sec;
        unsigned long usec;
    };

    template <class Rep, class Period>
    xtime
    to_xtime_truncate(duration<Rep, Period> d)
    {
        xtime xt;
        xt.sec = static_cast<long>(duration_cast<seconds>(d).count());
        xt.usec = static_cast<long>(duration_cast<microseconds>(d - seconds(xt.sec)).count());
        return xt;
    }

    template <class Rep, class Period>
    xtime
    to_xtime_round_up(duration<Rep, Period> d)
    {
        xtime xt;
        xt.sec = static_cast<long>(duration_cast<seconds>(d).count());
        xt.usec = static_cast<unsigned long>(round_up<microseconds>(d - seconds(xt.sec)).count());
        return xt;
    }

    microseconds
    from_xtime(xtime xt)
    {
        return seconds(xt.sec) + microseconds(xt.usec);
    }

    void print(xtime xt)
    {
        std::cout << '{' << xt.sec << ',' << xt.usec << "}\n";
    }

Usage

        xtime xt = to_xtime_truncate(seconds(3) + milliseconds(251));
        print(xt);
        milliseconds ms = duration_cast<milliseconds>(from_xtime(xt));
        std::cout << ms.count() << " milliseconds\n";
        xt = to_xtime_round_up(ms);
        print(xt);
        xt = to_xtime_truncate(seconds(3) + nanoseconds(999));
        print(xt);
        xt = to_xtime_round_up(seconds(3) + nanoseconds(999));
        print(xt);


[/xtime_cpp]

[endsect]

[/==================]
[section xtime_clock]

This example demonstrates the use of a timeval-like struct to be used as the representation
type for both duraiton and time_point.

    class xtime {
    private:
        long tv_sec;
        long tv_usec;

        void fixup() {
            if (tv_usec < 0) {
                tv_usec += 1000000;
                --tv_sec;
            }
        }

    public:
        explicit xtime(long sec, long usec) {
            tv_sec = sec;
            tv_usec = usec;
            if (tv_usec < 0 || tv_usec >= 1000000) {
                tv_sec += tv_usec / 1000000;
                tv_usec %= 1000000;
                fixup();
            }
        }

        explicit xtime(long long usec) {
            tv_usec = static_cast<long>(usec % 1000000);
            tv_sec  = static_cast<long>(usec / 1000000);
            fixup();
        }

        // explicit
        operator long long() const {return static_cast<long long>(tv_sec) * 1000000 + tv_usec;}

        xtime& operator += (xtime rhs) {
            tv_sec += rhs.tv_sec;
            tv_usec += rhs.tv_usec;
            if (tv_usec >= 1000000) {
                tv_usec -= 1000000;
                ++tv_sec;
            }
            return *this;
        }

        xtime& operator -= (xtime rhs) {
            tv_sec -= rhs.tv_sec;
            tv_usec -= rhs.tv_usec;
            fixup();
            return *this;
        }

        xtime& operator %= (xtime rhs) {
            long long t = tv_sec * 1000000 + tv_usec;
            long long r = rhs.tv_sec * 1000000 + rhs.tv_usec;
            t %= r;
            tv_sec = static_cast<long>(t / 1000000);
            tv_usec = static_cast<long>(t % 1000000);
            fixup();
            return *this;
        }

        friend xtime operator+(xtime x, xtime y) {return x += y;}
        friend xtime operator-(xtime x, xtime y) {return x -= y;}
        friend xtime operator%(xtime x, xtime y) {return x %= y;}

        friend bool operator==(xtime x, xtime y)
            { return (x.tv_sec == y.tv_sec && x.tv_usec == y.tv_usec); }

        friend bool operator<(xtime x, xtime y) {
            if (x.tv_sec == y.tv_sec)
                return (x.tv_usec < y.tv_usec);
            return (x.tv_sec < y.tv_sec);
        }

        friend bool operator!=(xtime x, xtime y) { return !(x == y); }
        friend bool operator> (xtime x, xtime y) { return y < x; }
        friend bool operator<=(xtime x, xtime y) { return !(y < x); }
        friend bool operator>=(xtime x, xtime y) { return !(x < y); }

        friend std::ostream& operator<<(std::ostream& os, xtime x)
            {return os << '{' << x.tv_sec << ',' << x.tv_usec << '}';}
    };

Clock based on timeval-like struct.

    class xtime_clock
    {
    public:
        typedef xtime                                  rep;
        typedef boost::micro                           period;
        typedef boost::chrono::duration<rep, period>   duration;
        typedef boost::chrono::time_point<xtime_clock> time_point;

        static time_point now()
        {
        #if defined(BOOST_CHRONO_WINDOWS_API)
            time_point t(duration(xtime(0)));
            gettimeofday((timeval*)&t, 0);
            return t;

        #elif defined(BOOST_CHRONO_MAC_API)

            time_point t(duration(xtime(0)));
            gettimeofday((timeval*)&t, 0);
            return t;

        #elif defined(BOOST_CHRONO_POSIX_API)
            //time_point t(0,0);

            timespec ts;
            ::clock_gettime( CLOCK_REALTIME, &ts );

            xtime xt( ts.tv_sec, ts.tv_nsec/1000);
            return time_point(duration(xt));

        #endif  // POSIX
        }
    };

Usage of xtime_clock

        using namespace boost::chrono;
        std::cout << "sizeof xtime_clock::time_point = " << sizeof(xtime_clock::time_point) << '\n';
        std::cout << "sizeof xtime_clock::duration = " << sizeof(xtime_clock::duration) << '\n';
        std::cout << "sizeof xtime_clock::rep = " << sizeof(xtime_clock::rep) << '\n';
        xtime_clock::duration delay(milliseconds(5));
        xtime_clock::time_point start = xtime_clock::now();
        while (xtime_clock::now() - start <= delay) {}
        xtime_clock::time_point stop = xtime_clock::now();
        xtime_clock::duration elapsed = stop - start;
        std::cout << "paused " << nanoseconds(elapsed).count() << " nanoseconds\n";

[endsect]

[/=========================]
[section runtime_resolution]

Handle duration with resolution not known until run time

    class duration
    {
    public:
        typedef long long rep;
    private:
        rep rep_;

        static const double ticks_per_nanosecond;

    public:
        typedef boost::chrono::duration<double, boost::nano> tonanosec;

        duration() {} // = default;
        explicit duration(const rep& r) : rep_(r) {}

        // conversions
        explicit duration(const tonanosec& d)
                : rep_(static_cast<rep>(d.count() * ticks_per_nanosecond)) {}

        // explicit
           operator tonanosec() const {return tonanosec(rep_/ticks_per_nanosecond);}

        // observer

        rep count() const {return rep_;}

        // arithmetic

        duration& operator+=(const duration& d) {rep_ += d.rep_; return *this;}
        duration& operator-=(const duration& d) {rep_ += d.rep_; return *this;}
        duration& operator*=(rep rhs)           {rep_ *= rhs; return *this;}
        duration& operator/=(rep rhs)           {rep_ /= rhs; return *this;}

        duration  operator+() const {return *this;}
        duration  operator-() const {return duration(-rep_);}
        duration& operator++()      {++rep_; return *this;}
        duration  operator++(int)   {return duration(rep_++);}
        duration& operator--()      {--rep_; return *this;}
        duration  operator--(int)   {return duration(rep_--);}

        friend duration operator+(duration x, duration y) {return x += y;}
        friend duration operator-(duration x, duration y) {return x -= y;}
        friend duration operator*(duration x, rep y)      {return x *= y;}
        friend duration operator*(rep x, duration y)      {return y *= x;}
        friend duration operator/(duration x, rep y)      {return x /= y;}

        friend bool operator==(duration x, duration y) {return x.rep_ == y.rep_;}
        friend bool operator!=(duration x, duration y) {return !(x == y);}
        friend bool operator< (duration x, duration y) {return x.rep_ < y.rep_;}
        friend bool operator<=(duration x, duration y) {return !(y < x);}
        friend bool operator> (duration x, duration y) {return y < x;}
        friend bool operator>=(duration x, duration y) {return !(x < y);}
    };


['See the file libs/chrono/example/runtime_resolution.cpp]

[endsect]

[/=======================================================]
[section Simulated thread interface demonstration program]

[/simulated_thread_interface_demo_cpp]

Free sleep functions

    namespace boost { namespace this_thread {

    template <class Rep, class Period>
    void sleep_for(const boost::chrono::duration<Rep, Period>& d) {
        boost::chrono::microseconds t = boost::chrono::duration_cast<boost::chrono::microseconds>(d);
        if (t < d)
            ++t;
        if (t > boost::chrono::microseconds(0))
            std::cout << "sleep_for " << t.count() << " microseconds\n";
    }

    template <class Clock, class Duration>
    void sleep_until(const boost::chrono::time_point<Clock, Duration>& t) {
        using namespace boost::chrono;
        typedef time_point<Clock, Duration> Time;
        typedef system_clock::time_point SysTime;
        if (t > Clock::now()) {
            typedef typename boost::common_type<typename Time::duration,
                                         typename SysTime::duration>::type D;
            /* auto */ D d = t - Clock::now();
            microseconds us = duration_cast<microseconds>(d);
            if (us < d)
                ++us;
            SysTime st = system_clock::now() + us;
            std::cout << "sleep_until    ";
            detail::print_time(st);
            std::cout << " which is " << (st - system_clock::now()).count() << " microseconds away\n";
        }
    }

    }}


timed_mutex modified fuctions

    namespace boost {
    struct timed_mutex {
        // ...

        template <class Rep, class Period>
        bool try_lock_for(const boost::chrono::duration<Rep, Period>& d) {
            boost::chrono::microseconds t = boost::chrono::duration_cast<boost::chrono::microseconds>(d);
            if (t <= boost::chrono::microseconds(0))
                return try_lock();
            std::cout << "try_lock_for " << t.count() << " microseconds\n";
            return true;
        }

        template <class Clock, class Duration>
        bool try_lock_until(const boost::chrono::time_point<Clock, Duration>& t)
        {
            using namespace boost::chrono;
            typedef time_point<Clock, Duration> Time;
            typedef system_clock::time_point SysTime;
            if (t <= Clock::now())
                return try_lock();
            typedef typename boost::common_type<typename Time::duration,
              typename Clock::duration>::type D;
            /* auto */ D d = t - Clock::now();
            microseconds us = duration_cast<microseconds>(d);
            SysTime st = system_clock::now() + us;
            std::cout << "try_lock_until ";
            detail::print_time(st);
            std::cout << " which is " << (st - system_clock::now()).count()
              << " microseconds away\n";
            return true;
        }
    };
    }

condition_variable modified fuctions

    namespace boost {
    struct condition_variable
    {
        // ...

        template <class Rep, class Period>
        bool wait_for(mutex&, const boost::chrono::duration<Rep, Period>& d) {
            boost::chrono::microseconds t = boost::chrono::duration_cast<boost::chrono::microseconds>(d);
            std::cout << "wait_for " << t.count() << " microseconds\n";
            return true;
        }

        template <class Clock, class Duration>
        bool wait_until(mutex&, const boost::chrono::time_point<Clock, Duration>& t) {
            using namespace boost::chrono;
            typedef time_point<Clock, Duration> Time;
            typedef system_clock::time_point SysTime;
            if (t <= Clock::now())
                return false;
            typedef typename boost::common_type<typename Time::duration,
              typename Clock::duration>::type D;
            /* auto */ D d = t - Clock::now();
            microseconds us = duration_cast<microseconds>(d);
            SysTime st = system_clock::now() + us;
             std::cout << "wait_until     ";
            detail::print_time(st);
            std::cout << " which is " << (st - system_clock::now()).count()
              << " microseconds away\n";
            return true;
        }
    };
    }

Usage

    boost::mutex m;
    boost::timed_mutex mut;
    boost::condition_variable cv;

    using namespace boost;
    using namespace boost::chrono;

    this_thread::sleep_for(seconds(3));
    this_thread::sleep_for(nanoseconds(300));
    system_clock::time_point time_limit = system_clock::now() + seconds(4) + milliseconds(500);
    this_thread::sleep_until(time_limit);

    mut.try_lock_for(milliseconds(30));
    mut.try_lock_until(time_limit);

    cv.wait_for(m, minutes(1));    // real code would put this in a loop
    cv.wait_until(m, time_limit);  // real code would put this in a loop

    // For those who prefer floating point
    this_thread::sleep_for(duration<double>(0.25));
    this_thread::sleep_until(system_clock::now() + duration<double>(1.5));


[/See the file libs/chrono/example/simulated_thread_interface_demo.cpp]

[endsect]

[/================]
[section Saturating]

A "saturating" signed integral type  is developed.  This type has +/- infinity and a nan (like IEEE floating point) but otherwise obeys signed integral arithmetic. This class is subsequently used as the rep in boost::chrono::duration to demonstrate a duration class that does not silently ignore overflow.

['See the file libs/chrono/example/satutating.cpp]

[endsect]

[/======================================================]
[section Howard Hinnant's original demonstration program]

['See the file libs/chrono/example/time2_demo.cpp]

[endsect]

[/===============================================================]
[section A tiny program that times how long until a key is struck]

[/await_keystroke_cpp]

    #include <boost/chrono/chrono.hpp>
    #include <iostream>
    #include <iomanip>

    using namespace boost::chrono;

    template< class Clock >
    class timer
    {
      typename Clock::time_point start;
    public:

      timer() : start( Clock::now() ) {}

      typename Clock::duration elapsed() const
      {
        return Clock::now() - start;
      }

      double seconds() const
      {
        return elapsed().count() * ((double)Clock::period::num/Clock::period::den);
      }
    };

    int main()
    {
      timer<system_clock> t1;
      timer<monotonic_clock> t2;
      timer<high_resolution_clock> t3;

      std::cout << "Strike any key: ";
      std::cin.get();

      std::cout << std::fixed << std::setprecision(9);
      std::cout << "system_clock-----------: "
                << t1.seconds() << " seconds\n";
      std::cout << "monotonic_clock--------: "
                << t2.seconds() << " seconds\n";
      std::cout << "high_resolution_clock--: "
                << t3.seconds() << " seconds\n";

      system_clock::time_point d4 = system_clock::now();
      system_clock::time_point d5 = system_clock::now();

      std::cout << "\nsystem_clock latency-----------: " << (d5 - d4).count() << std::endl;

      monotonic_clock::time_point d6 = monotonic_clock::now();
      monotonic_clock::time_point d7 = monotonic_clock::now();

      std::cout << "monotonic_clock latency--------: " << (d7 - d6).count() << std::endl;

      high_resolution_clock::time_point d8 = high_resolution_clock::now();
      high_resolution_clock::time_point d9 = high_resolution_clock::now();

      std::cout << "high_resolution_clock latency--: " << (d9 - d8).count() << std::endl;

      std::time_t now = system_clock::to_time_t(system_clock::now());

      std::cout << "\nsystem_clock::now() reports UTC is "
        << std::asctime(std::gmtime(&now)) << "\n";

      return 0;
    }

[endsect]

[/============================]
[section stopclock_example.cpp]

Here is the stopclock_example.cpp program supplied with the Boost Chrono library:

[/stopclock_example_cpp]

When the stopclock<> t object is created, it starts timing. When it is destroyed at the end of the program, its destructor stops the timer and displays timing information on cout.

    #include <boost/chrono/stopclock.hpp>
    #include <cmath>

    int main()
    {
      boost::chrono::stopclock<> t;

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }

The output of this program run on a circa 2006 processor looks was this:

   wall 0.42 s, user 0.41 s + system 0.00 s = total cpu 0.41 s, (96.3%)

In other words, this program ran in 0.42 seconds as would be measured by a clock on the wall, the operating system charged it for 0.41 seconds of user CPU time and 0 seconds of system CPU time, the total of these two was 0.41, and that represented 96.3 percent of the wall clock time.

[endsect]


[/=============================]
[section stopclock_example2.cpp]

The stopclock_example2.cpp program is the same, except that it supplies additional constructor arguments from the command line:

    #include <boost/chrono/stopclock.hpp>
    #include <cmath>

    int main( int argc, char * argv[] )
    {
      const char * format = argc > 1 ? argv[1] : "%t cpu seconds\n";
      int          places = argc > 2 ? std::atoi( argv[2] ) : 2;

      boost::chrono::stopclock<> t( format, places );

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L ); // burn some time

      return 0;
    }

Here is the output for this program for several sets of command line arguments:

    stopclock_example2
    0.42 cpu seconds

    stopclock_example2 "%w wall clock seconds\n"
    0.41 wall clock seconds

    stopclock_example2 "%w wall clock seconds\n" 6
    0.421875 wall clock seconds

    stopclock_example2 "%t total CPU seconds\n" 3
    0.422 total CPU seconds

[endsect]

[/===============================================================]
[section time command]

    #include <boost/chrono/stopclock.hpp>
    #include <cstdlib>
    #include <string>
    #include <iostream>

    int main( int argc, char * argv[] )
    {
      if ( argc == 1 )
      {
        std::cout << "invoke: timex [-v] command [args...]\n"
          "  command will be executed and timings displayed\n"
          "  -v option causes command and args to be displayed\n";
        return 1;
      }

      std::string s;

      bool verbose = false;
      if ( argc > 1 && *argv[1] == '-' && *(argv[1]+1) == 'v' )
      {
        verbose = true;
        ++argv;
        --argc;
      }

      for ( int i = 1; i < argc; ++i )
      {
        if ( i > 1 ) s += ' ';
        s += argv[i];
      }

      if ( verbose )
        { std::cout << "command: \"" << s.c_str() << "\"\n"; }

      boost::chrono::stopclock<> t;

      return std::system( s.c_str() );
    }

[endsect]

[endsect]
[/=================]
[section Appendices]
[/=================]
[/==================================]
[section:history Appendix A: History]
[/==================================]


[section [*Version 0.4, Febrary 31, 2010] ['New thread clock and Suspendible clock ]]

[*New Features:]

* Suspendible Clock concept + template class suspendible_clock<>
* Added scope_suspend which do suspend/resume if the Clock is a model of Suspendible Clock concept, and nothing otherwise.
* thread_clock support on platforms providing it natively.
* Added support for wide character for stopwatch_reporter, stopclock, and stopclock_accumulator.
* digital_time renamed t24_hours

[*Perf]

Added performances measures.

[*Bug Fixes]

* Bug on timeval_demo.

    time_point t(duration(xtime(0)));  // this was taken as a function declaration
    gettimeofday((timeval*)&t, 0);
    return t;
by

    timeval tv;
    gettimeofday(&tv, 0);
    xtime xt( tv.tv_sec, tv.tv_usec);
    return time_point(duration(xt));

* Bug on run_timer_test (add a global variable to avoid optimization that removes completely the code to be  measured

[endsect]

[section [*Version 0.3.2, January 25, 2010] ['New frequency, lifetime and percentage stopwatch_accumulator features]]
[*Features:]

* Added overloading for operator/(Integer/Duration)
* Added frequency, lifetime and percentage to the default stopwatch_accumulator_formatter

[*Bug Fixes]
* Specific formatters didn't work completly
* Replace duration(0) by duration::zero() on template classes.
* suspend doesn't works: partial_ not initialized neither taken in account by the elapsed function.

[endsect]

[section [*Version 0.3.1, January 20, 2010] ['New support for wide characters]]
[*Features:]

* Support for wide characters on formatters and stopclocks
* added chrono.hpp and stopwatches.hpp at the boost level


[endsect]

[section [*Version 0.3.0, January 17, 2010] ['New stopwatch/stopclock feature + Bug fixes]]
[*Features:]

* Added independent process cpu clocks for real, user, system process CPU time
* Added global process cpu clock for real, user, system process CPU time
* Added digital_time (looking for a better name)
* Added new *Stopwatch* concept measuring elapsed time between different points in time associated to the operations start, stop, suspend and resume.
* Added stopwatch is a model Stopwatch measuring the elapsed time between the start and the stop operations.
* Added stopwatch_accumulator is a model Stopwatch allowing to accumulate several time samples and give the average, ...
* Added scoped helper classes allowing to pairwise start/stop operations, suspend/resume and resume/suspend a Stopwatch.
* Added new stopwatch *Formatter* concept
    * Added stopwatch formatter "%ds\\n"
    * Added stopwatch accumulator formatter "%c times, sum=%ss, min=%ms, max=%Ms, mean=%as\\n"
    * Added time formatter "real %rs, cpu %cs (%p%), user %us, system %ss\\n"
    * Added digital_time formatter "%d days(s) %h:%m:%s.%n\\n"
* stopwatch_reporter is a convenient generic class reporting elapsed time for the Stopwatch concept.
* Added stopclock<Clock> shortcut stopwatch_reporter<stopwatch<Clcok>>
* Added scoped_stopclock which
* Added typeof registration for classes `duration` and `time_point`

* The old classes process_times, process_clock, process_timer, timer and run_timer are deprecated as the preceding additions are more generic. However for backward compatibility they preserved until inclusion of the library in Boost. Next follows the equivalences:
    * timer<> ~ stopwatch<>
    * process_timer ~ stopwatch<process_cpu_clock>
    * run_timer ~ stopclock<>

[*Bug Fixes]

* Try to correct warning C4251: 'boost::chrono::run_timer::m_format' : class 'std::basic_string<_Elem,_Traits,_Ax>' needs to have dll-interface to be used by clients of class 'boost::chrono::run_timer', by don't including inlines functions using the std::string m_format.

[endsect]

[section [*Version 0.2.1, December 13, 2009] ['Bug fixes]]

[*Bug Fixes]

* Replace INTMAX_C by BOOST_INTMAX_C until boost/cstdint;hpp ensures INTMAX_C is always defined.
* Define BOOST_CHRONO_HAS_CLOCK_MONOTONIC when BOOST_CHRONO_WINDOWS_API
* Commenting invalid operator declarations
* Take care of Boost min/max recommendations
* complete qualification when defining nested typedef duration on clocks to avoid the following compile error:

    ./boost/chrono/chrono.hpp:945: error: declaration of 'typedef class boost::chrono::duration<long long int, boost::ratio<1ll, 10000000ll> > boost::chrono::system_clock::duration'
    ./boost/chrono/chrono.hpp:458: error: changes meaning of 'duration' from 'class boost::chrono::duration<long long int, boost::ratio<1ll, 10000000ll> >'

* cleanup of simulated...
* warning removal on posix/process_clock.cpp
* disable VC++ foolishness
* Update Jamfiles to manage with dll
* removal of conversion warning in test_duration
* manage with MSVC reporting a warning instead of an error when there is an integral constant overflow
* Use STATIC_ASSERT specific macro to solve the compile failing issue
* Qualify with boost::detail boost::chrono::detail to avoid ambiguities with MSVC


[*Documentation:]

More updated documentation.

[endsect]

[section [*Version 0.2.0, December 8, 2009] ['+ Features + Bug fixes + Updated documentation]]

[*Features:]

* Added ratio construction and assignment from an equivalent ratio ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]])
* Added nested ratio typedef type ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]])
* Added BOOST_CHRONO_HAS_CLOCK_MONOTONIC macro to state if monotonic_clock is provided on this platform.
* Added duration operator% ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-defects.html#934 [*LGW 934. duration is missing operator%]])
* Added BOOST_CHRONO_CONSTEXPR when constexpr should be used
* Complete duration operator* and operator/


[*Implementation:]

* Use INTMAC_C to name intmax_t constants instead of LL.
* Separate chrono.cpp on # files win/chrono.cpp, mac/chrono.cpp and posix/chrono.cpp to make easier the maintenance on different platforms.
* Separate process_clock.cpp on # files win/process_clock.cpp, mac/process_clock.cpp and posix/process_clock.cpp to make easir the maintenace on different platforms.
* Added the error_code prototype for monotonic_clock::now for mac/chrono.cpp
* Fully implement mac/chrono.cpp with error handling.
* Take care on POSIX systems when CLOCK_MONOTONIC is not defined.

[*Documentation:]

* The documentation is written now using quick-book using as base [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] .

[*Bug Fixes]

* operator/ was ambiguous: Disambiguate duration operator/
* CLOCK_MONOTONIC is not defined with cygwin/gcc 3.4: Disable code when BOOST_CHRONO_HAS_CLOCK_MONOTONIC is not defined.
* result of metafunctions ratio_multiply and ratio_divide were not normalized ratios: Use of the nested ratio typedef type on ratio arithmetic operations.
* Copy constructor from similar duration masked the defaulted operations: Added duration defaulted implementations


[endsect]
[section [*Version 0.1.0, April 29, 2009] ['Beman's boostified version Chrono]]

[*Features:]

*  The C++0x Standard Library's `common_type`.
*  The C++0x Standard Library's compile-time rational arithmetic.
*  The C++0x Standard Library's time utilities, including:
    * Class template `duration`
    * Class template `time_point`
    * Clocks:
        * `system_clock`
        * `monotonic_clock`
        * `high_resolution_clock`

* Class template timer, with typedefs:
    * `system_timer`
    * `monotonic_timer`
    * `high_resolution_timer`

* Process clocks and timers:
    * `process_clock`, capturing real, user-CPU, and system-CPU times.
    * `process_timer`, capturing elapsed real, user-CPU, and system-CPU times.
    * `run_timer`, convenient reporting of process_timer results.

[endsect]
[endsect]

[/======================================]
[section:rationale Appendix B: Rationale]

See [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] which is very informative and provides motivation for key design decisions. The following sections are an extract from this document.

[heading Is it possible for the user to pass a `duration` to a function with the units being ambiguous?]

No. No matter which option the author of `f` chooses above, the following client code will not compile:

    f(3);  // Will not compile, 3 is not implicitly convertible to any `duration`

[heading Why duration needs operator%]

This operator is convenient for computing where in a time frame a given duration lies. A motivating example is converting a duration into a "broken-down" time duration such as hours::minutes::seconds:

    class ClockTime
    {
        typedef boost::chrono::hours hours;
        typedef boost::chrono::minutes minutes;
        typedef boost::chrono::seconds seconds;
    public:
        hours hours_;
        minutes minutes_;
        seconds seconds_;

        template <class Rep, class Period>
          explicit ClockTime(const boost::chrono::duration<Rep, Period>& d)
            : hours_  (boost::chrono::duration_cast<hours>  (d)),
              minutes_(boost::chrono::duration_cast<minutes>(d % hours(1))),
              seconds_(boost::chrono::duration_cast<seconds>(d % minutes(1)))
              {}
    };

[heading Why ratio needs CopyConstruction and Assignment from ratios having the same normalized form]

Current [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf [*N3000]] doesn't allows to copy-construct or assign ratio instances of ratio classes having the same normalized form.

This simple example

    ratio<1,3> r1;
    ratio<3,9> r2;
    r1 = r2; // (1)

fails to compile in (1). Other example

    ratio<1,3> r1;
    ratio_substract<ratio<2,3>,ratio<1,3> > r2=r1;  // (2)

The type of ratio_substract<ratio<2,3>,ratio<1,3> > could be ratio<3,9> so the compilation could fail in (2). It could also be ratio<1,3> and the compilation succeeds.

[heading Why ratio needs the nested normalizer typedef type]

In [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf [*N3000]] 20.4.2 and similar clauses

['3 The nested typedef type shall be a synonym for ratio<T1, T2> where T1 has the value R1::num * R2::den - R2::num * R1::den and T2 has the value R1::den * R2::den.]

The meaning of synonym let think that the result should be a normalized ratio equivalent to ratio<T1, T2>, but there is not an explicit definition of what synonym means in this context.

If the CopyConstruction and Assignment ([[@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#12811281 [*LWG 1281]]) is not added we need a typedef for accessing the normalized ratio, and change 20.4.2 to return only this normalized result. In this case the user will need to

    ratio<1,3>::type r1;
    ratio<3,9>::type r2;
    r1 = r2; // compiles as both types are the same.


[endsect]

[/======================================================]
[section:implementation Appendix C: Implementation Notes]



[endsect]

[/======================================================]
[section:faq Appendix D: FAQ]

[heading How important is the order of the common_type<> template arguments?]

The order of the template parameters is important. First common_type<> is not able to find out common type if it is not present and second
common_type<A,B,C>::type is equivalent to common_type<common_type<A,B>::type, C>::type.


    struct A {};
    struct B {};
    struct C {
        C() {}
        C(A const&) {}
        C(B const&) {}
        C& operator=(C const&) {
            return *this;
        }
    };

    #if 0
    typedef boost::common_type<A, B, C>::type ABC; // DO not compile
    #else
    typedef boost::common_type<C, B, A>::type ABC;
    #endif


Thus, as common_type<A,B>::type is undefined,  common_type<A,B,C>::type is also undefined.

[heading Why does stopwatch_reporter only display millisecond place precision when the underlying timer has nanosecond precision?]

To avoid giving the impression of precision where none exists. See Caveat emptor. You can always specify additional decimal places if you want to live dangerously.

[heading Why does stopwatch_reporter sometimes report more cpu seconds than real seconds?]

Ask your operating system supplier. The results have been inspected with a debugger, and both for Windows and Linux, that's what the OS appears to be reporting at times.

[heading  Can I obtain statistics of the time elapsed between calls to a function?]

The library do not provides this feature.

[endsect]

[/====================================================]
[section:acknowledgements Appendix E: Acknowledgements]

The library's code was derived from Howard Hinnant's time2_demo prototype. Many thanks to Howard for making his code available under the Boost license. The original code was modified by Beman Dawes to conform to Boost conventions.

time2_demo contained this comment:

Much thanks to Andrei Alexandrescu, Walter Brown, Peter Dimov, Jeff Garland, Terry Golubiewski, Daniel Krugler, Anthony Williams.

Beman Dawes added the timer<>, process_clock, process_timer, run_timer classes which are now deprecated and replaced by the stopwatch, process_cpu_clock and stopclock classes.

Thanks to Tom Tan to report some compiler issues with MSVC V10 beta and MinGW-gcc-4.4.0 and for the many suggestion he did concerning the new stopwatch, process_cpu_clock, stopclock and function stopclock classes and a deep help with wide characters implementation.

[endsect]

[/====================================================]
[section:tests  Appendix F: Tests]

In order to test you need to do.

    bjam libs/chrono/test

You can also run a specific suite of test by doing

    cd libs/chrono/test
    bjam common_type


[section `common_type`]
[table
    [[Name]             [kind]          [Description]          [Result] [Ticket]]
    [[common_type_test]    [run] [...]                  [Pass]   [#]]
]
[endsect]

[section `ratio`]
[table
    [[Name]             [kind]          [Description]          [Result] [Ticket]]
    [[ratio_fail_test1]    [compile-fails] [...]                  [Pass]   [#]]
    [[ratio_test]       [run]           [...]                  [Pass]   [#]]
]
[endsect]

[section chrono]
[table
    [[Name]             [kind]          [Description]          [Result] [Ticket]]
    [[chrono_unit_test]      [run]           [...]                  [Pass]   [#]]
    [[explore_limits]      [run]           [...]                  [Pass]   [#]]
    [[test_duration]      [run]           [...]                  [Pass]   [#]]
    [[test_system_clock]      [run]           [...]                  [Pass]   [#]]
    [[miscellaneous]      [run]           [...]                  [Pass]   [#]]
    [[test_special_values]      [run]           [...]                  [Pass]   [#]]
    [[manipulate_clock_object]      [run]           [...]                  [Pass]   [#]]
    [[chrono_accuracy_test]      [run]           [...]                  [Pass]   [#]]

    [[cycle_count]      [run]           [...]                  [Pass]   [#]]
    [[runtime_resolution]      [run]           [...]                  [Pass]   [#]]
    [[xtime]      [run]           [...]                  [Pass]   [#]]
    [[saturating]      [run]           [...]                  [Pass]   [#]]
    [[min_time_point]      [run]           [...]                  [Pass]   [#]]
    [[i_dont_like_the_default_duration_behavior]      [run]           [...]                  [Pass]   [#]]
    [[simulated_thread_interface_demo]      [run]           [...]                  [Pass]   [#]]
    [[timeval_demo]      [run]           [...]                  [Pass]   [#]]
]
[endsect]


[section Other Clocks]
[table
    [[Name]                         [kind]          [Description]           [Result] [Ticket]]
    [[test_suspendible_clock]               [run]           [test basic uses of suspendible_clock.]                   [Pass]   [#]]
]
[endsect]

[section stopwatch]
[table
    [[Name]                         [kind]          [Description]           [Result] [Ticket]]
    [[test_min_max]               [compile]           [test compilation succeeds in the presence of macros min and max.]                   [Pass]   [#]]
    [[stopwatch_example]               [run]           [...]                   [Pass]   [#]]
    [[stopwatch_example]               [run]           [...]                   [Pass]   [#]]
    [[scoped_stopwatch_example]               [run]           [...]                   [Pass]   [#]]
    [[stopwatch_accumulator_example] [run]   [...]                   [Pass]   [#]]
    [[specific_stopwatch_accumulator_example] [run]   [...]                   [Pass]   [#]]
    [[stopclock_example]      [run]          [...]                   [Pass]   [#]]
    [[stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[nested_stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[t24_hours_example]      [run]          [...]                   [Pass]   [#]]
    [[scoped_stopclock_example]      [run]          [...]                   [Pass]   [#]]
    [[test_minmax]      [compile]          [...]                   [Pass]   [#]]
    [[stopclock_constructor_overload_test]      [run]          [...]                   [Pass]   [#]]
    [[wstopclock_constructor_overload_test]      [run]          [...]                   [Pass]   [#]]

]
[endsect]

[endsect]
[/=====================================]
[section:tickets  Appendix G: Tickets]

[table
    [[Ticket]             [Description]          [Resolution] [State]]
    [[0]    [ Issues raised by Michael Marcin:  In the past I've seen QueryPerformanceCounter give incorrect results,
    especially with SpeedStep processors on laptops. This was many years ago and
    might have been fixed by service packs and drivers.

    Typically you check the results of QPC against GetTickCount to see if the
    results are reasonable.
    http://support.microsoft.com/kb/274323

    I've also heard of problems with QueryPerformanceCounter in multi-processor
    systems.

    I know some people SetThreadAffinityMask to 1 for the current thread call
    their QueryPerformance* functions then restore SetThreadAffinityMask. This
    seems horrible to me because it forces your program to jump to another
    physical processor if it isn't already on cpu0 but they claim it worked well
    in practice because they called the timing functions infrequently.

    In the past I have chosen to use timeGetTime with timeBeginPeriod(1) for
    high resolution timers to avoid these issues.
    ] [XXXX] [Open]]
    [[1]    [operator/ was ambiguous] [Disambiguate duration operator/]                  [Close]]
    [[2]    [CLOCK_MONOTONIC is not defined with cygwin/gcc 3.4] [Disable code when BOOST_CHRONO_HAS_CLOCK_MONOTONIC is not defined.]                  [Close]]
    [[3]    [result of metafunctions ratio_multiply and ratio_divide were not normalized ratios] [Use of the nested ratio typedef type on ratio arithmetic operations.]                  [Close]]
    [[4]    [Copy constructor from similar duration masked the defaulted operations] [Added duration defaulted implementations]                  [Close]]
    [[5]    [INTMAX_C is not always defined] [Replace INTMAX_C by BOOST_INTMAX_C until boost/cstdint.hpp ensures INTMAX_C is always defined.]                  [Close]]
    [[6]    [undefined BOOST_CHRONO_HAS_CLOCK_MONOTONIC when BOOST_CHRONO_WINDOWS_API] [Define BOOST_CHRONO_HAS_CLOCK_MONOTONIC when BOOST_CHRONO_WINDOWS_API]                  [Close]]
    [[7]    [min/max macros intrussion] [Take care of Boost min/max recommendations]                  [Close]]
    [[8]    [declaration of 'typedef class boost::chrono::duration<..> changes meaning of 'duration'] [complete qualification when defining nested typedef duration on clocks to avoid the following compile error:]                  [Close]]
    [[9]    [VC++ warnings] [disable VC++ foolishness]                  [Close]]
    [[10]    [conversion warning in test_duration] [removal of conversion warning in test_duration]                  [Close]]
    [[11]    [MSVC reports a warning instead of an error when there is an integral constant overflow] [manage with MSVC reporting a warning instead of an error when there is an integral constant overflow]                  [Close]]
    [[12]    [ambiguities with MSVC when using detail:: namespace] [Qualify with boost::detail boost::chrono::detail ]                  [Close]]
    [[13]    [warning C4251: 'boost::chrono::run_timer::m_format' : class 'std::basic_string<_Elem,_Traits,_Ax>' needs to have dll-interface to be used by clients of class 'boost::chrono::run_timer'] [don't include inlines functions using the std::string m_format]                  [Close]]
    [[14]    [Bad use of duration(0) on template classes] [remplace by duration::zero()]                  [Close]]
    [[15]    [suspend doesn't works: partial_ not initialized] [initialize with duration::zero()]                  [Close]]
    [[16]    [suspend doesn't works: elapsed doesn't take care of partial_] [take care of partial]                  [Close]]
    [[17]    [suspend doesn't works: bad use of system::error_code & ec] [replace by system::error_code ec]                  [Close]]
    [[18]    [warnings on mingw-gcc.4.4:[br]..\..\../boost/chrono/chrono.hpp: In copy constructor 'boost::chrono::time_point<boost::chrono::process_cpu_clock, boost::chrono::duration<boost::chrono::process_cpu_clock::times, boost::ratio<1ll, 1000000000ll> > >::time_point(const boost::chrono::time_point<boost::chrono::process_cpu_clock, boost::chrono::duration<boost::chrono::process_cpu_clock::times, boost::ratio<1ll, 1000000000ll> > >&)':
..\..\../boost/chrono/chrono.hpp:816: warning: suggest parentheses around '&&' within '||'
..\..\../boost/chrono/chrono.hpp:816: warning: suggest parentheses around '&&' within '||'] [???]                  [Open]]
    [[19]    [Use of Specific formatters doesn't works] [XXXX]                  [Close]]

    [[20]    [boost/chrono/scoped_suspend.hpp(31) : warning C4520: 'boost::chrono::scoped_suspend<Clock>' : multiple default constructors specified
] [XXXX]                  [Open]]
    [[[19]    [suspendible_clock_test doesn't works in my mingw environement (issue with tss)] [XXXX]                  [Open]]
    [[#]    [XXXX] [XXXX]                  [Close]]
]




[endsect]

[/=====================================]
[section:perf  Appendix H: Performances]
[/=====================================]


We have run some program changing how the reporting is done.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

The programs are either single-threaded or multi-threaded.

Two kind of inner functions are used: recursive or non recursive. In order to test the influence of nesting reports, the non recursive functions use up to 10 nesting levels, depending on its parameter.

the function at level n is defined as follows

    void fn(long v) {
        // reporting or not
        stopclock<> _;
        // burn some time
        for ( long i = 0; i < v; ++i )
            res+=std::sqrt( res+123.456L+i );  // burn some time
        if (v==0) return;

        if (v%(n-1)==0) fn-1(v-1);
        if (v%(n-2)==0) fn-2(v-1);
        ...
        f1(v-1);
    }

This gives a variable number in nesting reporting depending on the parameter, with a variable lifetime.

[heading Single-Threaded Recursive function]

We have run the same program and changed how the reporting is done.

The programm creates two thread of execution. the thread entry point calls a function which makes some calculation depending on its parameter and call recursivelly itself decreasing the parameter.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

[heading Multi-Threaded Recursive function]

We have run the same program and changed how the reporting is done.

The programm creates two thread of execution. the thread entry point calls a function which makes some calculation depending on its parameter and call recursivelly itself decreasing the parameter.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

[endsect]

[/=====================================]
[section:todo  Appendix I: Future plans]
[/=====================================]
[heading Tasks to do before review]

* Complete documentation
* Fully implement error handling, with test cases.
* Fix open isues.

[heading For later releases]

* Use of C++0x feature constexpr, when available.
* Define a C++98 variadic template emmulation of common_type

[endsect]
[endsect]
