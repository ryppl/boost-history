[/
 / Copyright (c) 2008 Howard Hinnant
 / Copyright (c) 2006, 2008 Beman Dawes
 / Copyright (c) 2009 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[article Boost.Chrono
    [quickbook 1.3]
    [authors [Hinnant, Howard]]
    [authors [Dawes, Beman]]
    [authors [Botet Escriba, Vicente J.]]
    [copyright 2008 Howard Hinnant]
    [copyright 2006, 2008 Beman Dawes]
    [copyright 2009 Vicente J. Botet Escriba]
    [purpose Time utilities]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/
[section Preface]

[:[".]]
[:[*['-- ]]]

[endsect]
/]

[warning Chrono is not part of the Boost libraries.]

[/===============]
[section Overview]
[/===============]

[/==================]
[heading Description]
[/==================]

The Boost Chrono library provides:

*  The C++0x Standard Library's `common_type`.
*  The C++0x Standard Library's compile-time rational arithmetic.
*  The C++0x Standard Library's time utilities, including:
    * Class template `duration`
    * Class template `time_point`
    * Clocks:
        * `system_clock`
        * `monotonic_clock`
        * `high_resolution_clock`

* Class template timer, with typedefs:
    * `system_timer`
    * `monotonic_timer`
    * `high_resolution_timer`

* Process clocks and timers:
    * `process_clock`, capturing real, user-CPU, and system-CPU times.
    * `process_timer`, capturing elapsed real, user-CPU, and system-CPU times.
    * `run_timer`, convenient reporting of process_timer results.

[/====================================]
[heading How to Use This Documentation]
[/====================================]

This documentation makes use of the following naming and formatting conventions.

* Code is in `fixed width font` and is syntax-highlighted.
* Replaceable text that you will need to supply is in [~italics].
* If a name refers to a free function, it is specified like this:
  `free_function()`; that is, it is in code font and its name is followed by `()`   to indicate that it is a free function.
* If a name refers to a class template, it is specified like this:   `class_template<>`; that is, it is in code font and its name is followed by `<>`   to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in code font and its name is followed by `()` to   indicate that it is a function-like macro. Object-like macros appear without the   trailing `()`.
* Names that refer to /concepts/ in the generic programming sense are  specified in CamelCase.

[note In addition, notes such as this one specify non-essential information that provides additional background or rationale.]

Finally, you can mentally add the following to any code fragments in this document:

    // Include all of Chono files
    #include <boost/chono.hpp>
    #include <boost/ratio.hpp>
    #include <boost/type_traits/common_type.hpp>
    #include <boost/chono/timer.hpp>
    #include <boost/chono/process_times.hpp>

[/=================]
[section Motivation]
[/=================]

See [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] which is very informative and provides motivation for key design decisions for `common_type`, `ratio` and `chrono`. The following sections are an extract from this document.

[section Common type]

`common_type` has been a recurring theme in many places for many years. We've previously known it as promote and examples of it are spread throughout boost. It has been reinvented independently several times, because it is so useful.

Andrei Alexandrescu recently pointed us at a D library: std.traits - D Programming Language - Digital Mars, which became the motivation for this particular name, and the variadic nature of this trait.

In a nutshell, `common_type` is a trait that takes 1 or more types, and returns a type which all of the types will convert to. The default definition demands this conversion be implicit. However the trait can be specialized for user-defined types which want to limit their inter-type conversions to explicit, and yet still want to interoperate with the `common_type` facility.

[*Example:]

    template <class T, class U>
    typename common_type<complex<T>, complex<U> >::type
    operator+(complex<T>, complex<U>);

In the above example, "mixed-mode" complex arithmetic is allowed. The return type is described by `common_type`. For example the resulting type of adding a `complex<int>` and `complex<double>` might be a `complex<double>`. Another choice for the author might be:

    template <class T, class U>
    complex<typename common_type<T, U>::type>
    operator+(complex<T>, complex<U>);

Here is how someone might produce a variadic comparison function:

    template <class ...T>
    typename common_type<T...>::type
    min(T... t);

This is a very useful and broadly applicable utility. The `duration` and `time_point` facilities use it to make multi-precision arithmetic seamless and exact.


[endsect]

[section Ratio]

`ratio` is a general purpose utility inspired by Walter Brown allowing one to easily and safely compute rational values at compile time. The `ratio` class catches all errors (such as divide by zero and overflow) at compile time. It is used in the `duration` and `time_point` classes to efficiently create units of time. It can also be used in other "quantity" libraries (both std-defined and user-defined), or anywhere there is a rational constant which is known at compile time. The use of this utility can greatly reduce the chances of run time overflow because the `ratio` (and any ratios resulting from `ratio` arithmetic) are always reduced to lowest terms.

`ratio` is a template taking two intmax_ts, with the second defaulted to 1. It only has two public members, both of which are static const intmax_t. One is the numerator of the `ratio` and the other is the denominator. The `ratio` is always normalized such that it is expressed in lowest terms, and the denominator is always positive. When the numerator is 0, the denominator is always 1.

[*Example:]

    typedef ratio<5, 3>   five_thirds;       // five_thirds::num == 5, five_thirds::den == 3
    typedef ratio<25, 15> also_five_thirds;  // also_five_thirds::num == 5, also_five_thirds::den == 3
    typedef ratio_divide<five_thirds, also_five_thirds>::type one;  // one::num == 1, one::den == 1

This facility also includes convenience typedefs for the SI prefixes atto through exa corresponding to their internationally recognized definitions (in terms of `ratio`). This is a tremendous syntactic convenience. It will prevent errors in specifying constants as one no longer has to double count the number of zeros when trying to write million or billion.

[*Example:]

    typedef ratio_multiply<ratio<5>, giga>::type _5giga;  // _5giga::num == 5000000000, _5giga::den == 1
    typedef ratio_multiply<ratio<5>, nano>::type _5nano;  // _5nano::num == 1, _5nano::den == 200000000

[endsect]


[section Duration]

The `duration` is the heart of this library. The interface that the user will see in everyday use is nearly identical to that of Boost.DateTime time `duration`s authored by Jeff Garland, both in syntax and in behavior. This has been a very popular boost library for 7 years. There is an enormous positive history with this interface.

The library consists of six units of time `duration`:

* hours
* minutes
* seconds
* milliseconds
* microseconds
* nanoseconds

These units were chosen as a subset of the boost library because they are the most common units used when sleeping, waiting on a condition variable, or waiting to obtain the lock on a mutex. Each of these units is nothing but a thin wrapper around a signed integral count. That is, when you construct `minutes(3)`, all that happens is a 3 is stored inside of minutes. When you construct `microseconds(3)`, all that happens is a 3 is stored inside of microseconds.

The only context in which these different types differ is when being converted to one another. At this time, unit-specific compile-time conversion constants are used to convert the source unit to the target unit. Only conversions from coarser units to finer units are allowed (in boost). This restriction ensures that all conversions are always exact. That is, microseconds can always represent any value minutes has.

In Boost.DateTime, these units are united via inheritance. __Boost_Chrono__ instead unites these units through the class template `duration`. That is, in __Boost_Chrono__ all six of the above units are nothing but typedefs to different instantiations of `duration`. This change from Boost.DateTime has a far reaching positive impact, while not changing the syntax of the everyday use at all.

The most immediate positive impact is that the library can immediately generate any unit, any precision it needs. This is sometimes necessary when doing comparisons or arithmetic between `duration`s of differing precision, assuming one wants the comparison and arithmetic to be exactly correct.

A secondary benefit is that by publishing the class template `duration` interface, user code can very easily create `duration`s with any precision they desire. The `ratio` utility is used to specify the precision, so as long as the precision can be expressed by a rational constant with respect to seconds, this framework can exactly represent it (one third of a second is no problem, and neither is one third of a femto second). All of this utility and flexibility comes at no cost just by making use of the no-run-time-overhead `ratio` facility.

In Boost.DateTime, hours does not have the same representation as nanoseconds. The former is usually represented with a long whereas a long long is required for the latter. The reason for this is simply range. You don't need many hours to cover an extremely large range of time. But this isn't true of nanoseconds. Being able to reduce the sizeof overhead for some units when possible, can be a significant performance advantage.

__Boost_Chrono__ continues, and generalizes that philosophy. Not only can one specify the precision of a `duration`, one can also specify its representation. This can be any integral type, or even a floating point type. Or it can be a user-defined type which emulates an arithmetic type. The six predefined units all use signed integral types as their representation. And they all have a minimum range of +/- 292 years. nanoseconds needs 64 bits to cover that range. hours needs only 23 bits to cover that range.

[heading So What Exactly is a `duration` and How Do I Use One?]

A `duration` has a representation and a tick period (precision).

    template <class Rep, class Period = ratio<1> > class duration;

The representation is simply any arithmetic type, or an emulation of such a type. The representation stores a count of ticks. This count is the only data member stored in a `duration`. If the representation is floating point, it can store fractions of a tick to the precision of the representation. The tick period is represented by a `ratio` and is encoded into the `duration`'s type, instead of stored. The tick period only has an impact on the behavior of the `duration` when a conversion between different `duration`'s is attempted. The tick period is completely ignored when simply doing arithmetic among like `duration`s.

[*Example:]

    typedef duration<long, ratio<60> > minutes;
    minutes m1(3);                 // m1 stores 3
    minutes m2(2);                 // m2 stores 2
    minutes m3 = m1 + m2;          // m3 stores 5

    typedef duration<long long, micro> microseconds;
    microseconds us1(3);           // us1 stores 3
    microseconds us2(2);           // us2 stores 2
    microseconds us3 = us1 + us2;  // us3 stores 5

    microseconds us4 = m3 + us3;   // us4 stores 300000005

In the final line of code above, there is an implicit conversion from minutes to microseconds, resulting in a relatively large number of microseconds.

If you need to access the tick count within a `duration`, there is a member `count()` which simply returns the stored tick count.

    long long tc = us4.count();    // tc is 300000005

These `duration`s have very simple, very predictable, and very observable behavior. After all, this is really nothing but the time tested interface of Jeff's boost time `duration` library (unified with templates instead of inheritance).

[heading What happens if I assign `m3 + us3` to minutes instead of microseconds?]

    minutes m4 = m3 + us3;

It won't compile. The rationale is that implicit truncation error should not be allowed to happen. If this were to compile, then `m4` would hold `5`, the same value as `m3`. The value associated with `us3` has been effectively ignored. This is similar to the problem of assigning a double to an `int`: the fractional part gets silently discarded.

[heading But what if the truncation behavior is what I want to do?]

There is a `duration_cast` facility to explicitly ask for this behavior:

    minutes m4 = duration_cast<minutes>(m3 + us3);  // m4.count() == 5

In general, one can perform `duration` arithmetic at will. If `duration_cast` isn't used, and it compiles, the arithmetic is exact. Any place one wants to override this exact arithmetic behavior, duration_cast can be used to explicitly specify that desire. The `duration_cast` has the same efficiency as the implicit conversion, and will even be exact as often as it can.

[heading I'm trafficking in floating point `duration`s. I don't want to deal with writing `duration_cast` all over the place. I'm content with the precision of my floating point representation]

Not a problem. When the destination of a conversion has floating point representation, all conversions are allowed to happen implicitly.

    typedef duration<double, ratio<60> > dminutes;
    dminutes dm4 = m3 + us3;  // dm4.count() == 5.000000083333333

[heading How expensive is all of this?]

If you were writing these conversions by hand, you could not make it more efficient. The use of `ratio` ensures that all conversion constants are simplified as much as possible at compile time. This usually results in the numerator or denominator of the conversion factor simplifying to `1`, and being subsequently ignored in converting the run time values of the tick counts.

[heading How complicated is it to build a function taking a `duration` parameter?]

There are several options open to the user:

* If the author of the function wants to accept any `duration`, and is willing to work in floating point `duration`s, he can simply use any floating point `duration` as the parameter:

          void f(duration<double> d)  // accept floating point seconds
          {
              // d.count() == 3.e-6 when passed microseconds(3)
          }

          f(microseconds(3));

* If the author of the function wants to traffic only in integral `duration`s, and is content with handling nothing finer than say nanoseconds (just as an example), he can simply specify nanoseconds as the parameter:

          void f(nanoseconds d)
          {
              // d.count() == 3000 when passed microseconds(3)
          }

          f(microseconds(3));

In this design, if the client wants to pass in a floating point `duration`, or a `duration` of finer precision than nanoseconds, then the client is responsible for choosing his own rounding mode in the conversion to nanoseconds.

          duration<double> s(1./3);  // 1/3 of a second
          f(duration_cast<nanoseconds>(s));  // round towards zero in conversion to nanoseconds

In the example above, the client of f has chosen "round towards zero" as the desired rounding mode to nanoseconds. If the client has a `duration` that won't exactly convert to nanoseconds, and fails to choose how the conversion will take place, the compiler will refuse the call:

          f(s);  // does not compile

* If the author of the function wants to accept any `duration`, but wants to work with integral representations and wants to control the rounding mode internally, then he can template the function:

          template <class Rep, class Period>
          void f(duration<Rep, Period> d)
          {
              // convert d to nanoseconds, rounding up if it is not an exact conversion
              nanoseconds ns = duration_cast<nanoseconds>(d);
              if (ns < d)
                  ++ns;
              // ns.count() == 333333334 when passed 1/3 of a floating point second
          }

          f(duration<double>(1./3));

*  If the author in the example does not want to accept floating point based `duration`s, he can enforce that behavior like so:

          template <class Period>
          void f(duration<long long, Period> d)
          {
              // convert d to nanoseconds, rounding up if it is not an exact conversion
              nanoseconds ns = duration_cast<nanoseconds>(d);
              if (ns < d)
                  ++ns;
              // ns.count() == 333333334 when passed 333333333333 picoseconds
          }

          f(duration<long long, pico>(333333333333));  // About 1/3 of a second worth of picoseconds

Clients with floating point `duration`s who want to use f will now have to convert to an integral `duration` themselves before passing the result to f.

In summary, the author of f has quite a bit of flexibility and control in the interface he wants to provide his clients with, and easy options for manipulating that `duration` internal to his function.

[endsect]

[section Clocks]

While `duration`s only have precision and representation to concern themselves, clocks and `time_point`s are intimately related and refer to one another. Because clocks are simpler to explain, we will do so first without fully explaining `time_point`s. Once clocks are introduced, it will be easier to then fill in what a `time_point` is.

A clock is a concept which bundles 3 things:

# A concrete `duration` type.
# A concrete `time_point` type.
# A function called now() which returns the concrete `time_point`.

__Boost_Chrono__ proposes 3 concrete clocks:

# system_clock
# monotonic_clock
# high_precision_clock

A given platform may not be able to supply all three of these clocks. The user is also able to easily create more clocks.

Given a clock named Clock, it will have:

    class Clock {
    public:
        typedef an arithmetic-like type            rep;
        typedef an instantiation of ratio          period;
        typedef std::chrono::duration<rep, period> duration;
        typedef std::chrono::time_point<Clock>     time_point;
        static const bool is_monotonic =           true or false;

        static time_point now();
    };

One can get the current time from Clock with:

    Clock::time_point t1 = Clock::now();

And one can get the time `duration` between two `time_point`s associated with Clock with:

    Clock::duration d = t1 - Clock::now();

And one can specify a past or future `time_point` with:

    Clock::time_point t2 = Clock::now() + d;

Note how even if a particular clock becomes obsolete, the next clock in line will have the same API. There is no new learning curve to come up. The only source code changes will be simply changing the type of the clock. The same `duration` and `time_point` framework continues to work as new clocks are introduced. And multiple clocks are safely and easily handled within the same program.

[endsect]

[section Time Point]

A `time_point` represents a point in time, as opposed to a `duration` of time. Another way of saying the same thing, is that a `time_point` represents an epoch plus or minus a `duration`. Examples of `time_point`s include:

* 3 minutes after the computer booted.
* 03:14:07 UTC on Tuesday, January 19, 2038
* 20 milliseconds after I started that timer.

In each of the examples above, a different epoch is implied. Sometimes an epoch has meaning for several millennia. Other times the meaning of an epoch is lost after a while (such as the start of a timer, or when the computer booted). However, if two `time_point`s are known to share the same epoch, they can be subtracted, yielding a valid `duration`, even if the definition of the epoch no longer has meaning.

In __Boost_Chrono__, an epoch is a purely abstract and unspecified concept. There is no type representing an epoch. It is simply an idea that relates (or doesn't) `time_point`s to a clock, and in the case that they share a clock, `time_point`s to one another. `time_point`s associated with different clocks are generally not interoperable unless the relationship between the epochs associated with each clock is known.

[heading So What Exactly is a `time_point` and How Do I Use One?]

A `time_point` has a clock and a `duration`.

    template <class Clock, class Duration = typename Clock::duration> class time_point;

The `time_point`'s clock is not stored. It is simply embedded into the `time_point`'s type and serves two purposes:

# Because `time_point`s originating from different clocks have different types, the compiler can be instructed to fail if incompatible `time_point`s are used in inappropriate ways.
# Given a `time_point`, one often needs to compare that `time_point` to "now". This is very simple as long as the `time_point` knows what clock it is defined with respect to.

A `time_point`'s `duration` is stored as the only data member of the `time_point`. Thus `time_point`s and their corresponding `duration` have exactly the same layout. But they have very different meanings. For example, it is one thing to say I want to sleep for 3 minutes. It is a completely different thing to say I want to sleep until 3 minutes past the time I started that timer (unless you just happened to start that timer now). Both meanings (and options for sleeping) have great practical value in common use cases for sleeping, waiting on a condition variable, and waiting for a mutex's lock. These same concepts and tools are found (for example) in Ada.

A timer example:

    void f()
    {
        monotonic_clock::time_point start = monotonic_clock::now();
        g();
        h();
        duration<double> sec = monotonic_clock::now() - start;
        cout << "f() took " << sec.count() << " seconds\n";
    }

Note that if one is using the `duration` between two clock `time_point`s in a way where the precision of the `duration` matters, it is good practice to convert the clock's native `duration` to a known `duration`. This insulates the code from future changes which may be made to the clock's native precision in the future. For example monotonic_clock could easily be based on the clock speed of the cpu. When you upgrade to a faster machine, you do not want your code that assumed a certain tick period of this clock to start experiencing run time failures because your timing code has silently changed meaning.

A delay loop example:

    // delay for at least 500 nanoseconds:
    auto go = monotonic_clock::now() + nanoseconds(500);
    while (monotonic_clock::now() < go)
        ;

The above code will delay as close as possible to half a microsecond, no matter what the precision of monotonic_clock is. The more precise `monotonic_clock` becomes, the more accurate will be the delay to 500 nanoseconds.

[endsect]


[section Timers]

Knowing how long a program takes to execute is useful in both test and production environments. It is also helpful if such timing information is broken down into real (wall clock) time, CPU time spent by the user, and CPU time spent by the operating system servicing user requests.

The Boost Chrono Library's process times components provide that information:

* At the highest level, class `run_timer` provides a complete run time reporting package that can be invoked in a single line of code.
* At a middle level, class `process_timer` provides a process timer useful when the automatic reporting of `run_timer` isn't desired.
* At the lowest level, `process_clock` provides a thin wrapper around the operating system's process timer API. For POSIX-like systems, that's the times() function, while for Windows, it's the GetProcessTimes() function.

[endsect]


[endsect]

[section Caveat emptor]

The underlying clocks provided by operating systems are subject to many seemingly arbitrary policies and implementation irregularities. That's a polite way of saying they tend to be flakey, and each operating system or even each clock has its own cruel and unusual forms of flakiness. Don't bet the farm on their accuracy, unless you have become deeply familiar with exactly what the specific operating system is guaranteeing, which is often very little.

[endsect]
[endsect]


[/==============================]
[section:users_guide Users'Guide]
[/==============================]

[/======================================]
[section:getting_started Getting Started]
[/======================================]

[/======================================]
[section:install Installing Chrono]
[/======================================]

[/=================================]
[heading Getting __Boost_Chrono__]
[/=================================]

You can get the last stable release of __Boost_Chrono__ by downloading [^chrono.zip] from the
[@http://www.boost-consulting.com/vault/index.php?directory=System Boost Vault]

You can also access the latest (unstable?) state from the [@https://svn.boost.org/svn/boost/sandbox/chrono Boost Sandbox].

[/=================================]
[heading Building __Boost_Chrono__]
[/=================================]

__Boost_Chrono__ is not a header only library. You need to compile it before use.

    bjam libs/chrono/build


[/=========================]
[heading Requirements]
[/=========================]

[*Boost.Bitfield] depends on some Boost libraries. For these specific parts you must use either Boost version 1.39.0 or the version in SVN trunk (even if older version should works also).

In particular, __Boost_Chrono__ depends on:

[variablelist
[
    [[@http://www.boost.org/libs/config [*Boost.Config]]] [for configuration purposes, ...]
]
[
    [[@http://www.boost.org/libs/exception [*Boost.Exception]]] [for throw_exception, ...]
]
[
    [[@http://www.boost.org/libs/system [*Boost.System]]] [for error_code, ...]
]
[
    [[@http://www.boost.org/libs/type_traits [*Boost.TypeTraits]]] [for ..., ...]
]
[
    [[@http://www.boost.org/libs/typeof [*Boost.Typeof]]] [for typeof, ...]
]
[
    [[@http://www.boost.org/libs/utility [*Boost.UtiliTy/EnableIf]]] [for enable_if, ...]
]
]

[/========================]
[heading Exceptions safety]
[/========================]

All functions in the library are exception-neutral and provide strong guarantee of exception safety as long as the underlying parameters provide it.

[/====================]
[heading Thread safety]
[/====================]

All functions in the library are thread-unsafe except when noted explicitly.

[/=======================]
[heading Tested compilers]
[/=======================]

The implementation will eventually work with most C++03 conforming compilers. Initial tests have been run on

Windows with

* VC++ 9.0 SP1
* Intel 11.0

On Ubuntu Linux with

* GCC 4.2.4

On SL Linux with

* GCC 3.4.6
* GCC 4.1.2

On Cygwin with

* GCC 3.4.4
[/*  GCC 4.3.2]


[note Please send any questions, comments and bug reports to boost <at> lists <dot> boost <dot> org.]

[endsect]
[/=============================]
[section Hello World! ]
[/=============================]

If all you want to do is to time a program's execution:

    #include <boost/chrono/process_times.hpp>

    ...

    // add this in the scope you want to time,
    // at the point you want the timer to start.
    boost::chrono::run_timer rt;

Here is a complete program (run_timer_example.cpp):

    #include <boost/chrono/process_times.hpp>
    #include <cmath>

    int main()
    {
      boost::chrono::run_timer t;

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L ); // burn some time

      return 0;
    }

Debug build output was:

    real 0.832s, cpu 0.813s (97.7%), user 0.813s, system 0.000s

In other words, the program took 0.832 real-time (i.e. wall clock) seconds to execute, while the operating system (Windows in this case) charged 0.813 seconds of CPU time to the user and 0 seconds to the system. The total CPU time reported was 0.813 seconds, and that represented utilization of 97.7% of the real-time seconds.

[endsect]

[endsect]

[section Tutorial]

[endsect]

[section:ext_references References]

[variablelist

[
    [[@http://www.open-std.org/jtc1/sc22/wg21 [*C++ Standards Committee's current Working Paper]]]
    [The most authoritative reference material for the library is the C++ Standards Committee's current Working Paper (WP).  20.9 Time utilities "time", 20.4 Compile-time rational arithmetic "ratio", 20.6.7 Other transformations "meta.trans.other"]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]]]
    [From Howard E. Hinnant, Walter E. Brown, Jeff Garland  and Marc Paterno. Is very informative and provides motivation for key design decisions]
]


[
    [[@http://home.roadrunner.com/~hinnant/issue_review/lwg-defects.html#934 [*LGW 934. duration is missing operator%]]]
    [From Terry Golubiewski. Is very informative and provides motivation for key design decisions]
]

[
    [[@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]]]
    [From Vicente Juan Botet Escriba.]
]

]

[endsect]

[endsect]

[section Reference]


[/==========================================================================================]
[section:common_type_hpp Header `<boost/type_traits/common_type.hpp>`]
[/==========================================================================================]

    namespace boost {
      template <class ...T>  struct common_type;
    }

[section:common_type Class Template `common_type`]

`common_type` is a facility which is useful in specifying the type of the result of functions and operators which take a variety of types (e.g. "mixed mode" complex arithmetic).

The nested typedef `common_type::type` shall be defined as follows:

    template <class T, class U = void, class V = void>
    struct common_type {
        typedef typename common_type<typename common_type<T, U>::type, V>::type type;
    };

    template <class T>
    struct common_type<T, void, void> {
        typedef T type;
    };

    template <class T, class U>
    struct common_type<T, U, void> {
    private:
        static T m_t();
        static U m_u();
        static bool m_f();  // workaround gcc bug; not required by std
    public:
        typedef BOOST_TYPEOF_TPL(m_f() ? m_t() : m_u()) type;
    };

All types in the parameter pack T shall be complete. This trait is permitted to be specialized by a user if at least one template parameter is a user-defined type.

[*Note:] Such specializations are required when only explicit conversions are desired among the `common_type` arguments.


[endsect]

[endsect]


[/==========================================================================================]
[section:ratio_hpp Header `<boost/ratio.hpp>`]
[/==========================================================================================]

`ratio` is a facility which is useful in specifying compile time rational constants. Compile time rational arithmetic is supported with protection against overflow and divide by zero. Such a facility is very handy when needing to efficiently represent  1/3 of a nanosecond, or specifying an inch in terms of meters (for example 254/10000 meters - which `ratio` will reduce to 127/5000 meters).

    namespace boost  {

        template <boost::intmax_t N, boost::intmax_t D = 1> class ratio;

        // ratio arithmetic
        template <class R1, class R2> struct ratio_add;
        template <class R1, class R2> struct ratio_subtract;
        template <class R1, class R2> struct ratio_multiply;
        template <class R1, class R2> struct ratio_divide;

        // ratio comparison
        template <class R1, class R2> struct ratio_equal;
        template <class R1, class R2> struct ratio_not_equal;
        template <class R1, class R2> struct ratio_less;
        template <class R1, class R2> struct ratio_less_equal;
        template <class R1, class R2> struct ratio_greater;
        template <class R1, class R2> struct ratio_greater_equal;

        // convenience SI typedefs
        typedef ratio<1LL, 1000000000000000000LL> atto;
        typedef ratio<1LL,    1000000000000000LL> femto;
        typedef ratio<1LL,       1000000000000LL> pico;
        typedef ratio<1LL,          1000000000LL> nano;
        typedef ratio<1LL,             1000000LL> micro;
        typedef ratio<1LL,                1000LL> milli;
        typedef ratio<1LL,                 100LL> centi;
        typedef ratio<1LL,                  10LL> deci;
        typedef ratio<                 10LL, 1LL> deca;
        typedef ratio<                100LL, 1LL> hecto;
        typedef ratio<               1000LL, 1LL> kilo;
        typedef ratio<            1000000LL, 1LL> mega;
        typedef ratio<         1000000000LL, 1LL> giga;
        typedef ratio<      1000000000000LL, 1LL> tera;
        typedef ratio<   1000000000000000LL, 1LL> peta;
        typedef ratio<1000000000000000000LL, 1LL> exa;
    }


[section:ratio Class Template `ratio<>`]

        template <boost::intmax_t N, boost::intmax_t D>
        class ratio {
        public:
            static const boost::intmax_t num;
            static const boost::intmax_t den;
            typedef ratio<num, den> type;

            ratio() {}

            template <intmax_t _N2, intmax_t _D2>
            ratio(const ratio<_N2, _D2>&,
                typename enable_if_c
                    <
                        ratio<_N2, _D2>::num == num &&
                        ratio<_N2, _D2>::den == den
                    >::type* = 0) {}

            template <intmax_t _N2, intmax_t _D2>
                typename enable_if_c
                <
                    ratio<_N2, _D2>::num == num &&
                    ratio<_N2, _D2>::den == den,
                    ratio&
                >::type
            operator=(const ratio<_N2, _D2>&) {return *this;}
        };

A diagnostic shall be emitted if `ratio` is instantiated with `D == 0`, or if the absolute value of `N` or `D` can not be represented. [*Note:] These rules ensure that infinite ratios are avoided and that for any negative input, there exists a representable value of its absolute value which is positive. In a two's complement representation, this excludes the most negative value.

Let `gcd` denote the greatest common divisor of `N`'s absolute value and of `D`'s absolute value.

* `num` shall have the value `sign(N)*sign(D)*abs(N)/gcd`.

* `den` shall have the value `abs(D)/gcd`.

The nested typedef `type` denotes the normalized form of this ratio type. It should be used when the template parameters don't give a normalized form.

Two `ratio` classes `ratio<N1,D1>` and `ratio<N2,D2>` have the same normalized form if `ratio<N1,D1>::type` is the same type as `ratio<N2,D2>::type`

[section Construction and assignment]

    template <intmax_t N2, intmax_t D2>
      ratio(const ratio<N2, D2>& r);

[*Effects:] Constructs a `ratio` object.

[*Remarks:] This constructor shall not participate in overload resolution unless `r` has the same normalized form as `*this`.

    template <intmax_t N2, intmax_t D2>
      ratio& operator=(const ratio<N2, D2>& r);

[*Effects:] Assigns a `ratio` object.

[*Returns:] *this.

[*Remarks:] This operator shall not participate in overload resolution unless `r` has the same normalized form as `*this`.

[endsect]


[endsect]


[section:ratio_arithmetic `ratio` arithmetic]

For each of the class templates in this clause, each template parameter shall refer to a `ratio`. If the implementation is unable to form the indicated `ratio` due to overflow, a diagnostic shall be issued.

        template <class R1, class R2> struct ratio_add {
           typedef [/see below] type;
        };

The nested typedef `type` shall be a synonym for `ratio<R1::num * R2::den + R2::num * R1::den, R1::den * R2::den>::type`.

        template <class R1, class R2> struct ratio_subtract {
           typedef  [/see below]  type;
        };

The nested typedef `type` shall be a synonym for `ratio<R1::num * R2::den - R2::num * R1::den, R1::den * R2::den>::type`.

        template <class R1, class R2> struct ratio_multiply {
           typedef  [/see below]  type;
        };

The nested typedef `type` shall be a synonym for `ratio<R1::num * R2::num, R1::den * R2::den>::type`.

        template <class R1, class R2> struct ratio_divide {
           typedef  [/see below]  type;
        };

The nested typedef `type` shall be a synonym for `ratio<R1::num * R2::den, R2::num * R1::den>::type`.

[endsect]

[section:ratio_comparison `ratio` comparison]

        template <class R1, class R2>  struct ratio_equal
            : public boost::integral_constant<bool, [/see below] > {};

If R1::num == R2::num && R1::den == R2::den, ratio_equal derives from true_type, else derives from false_type.

        template <class R1, class R2>
        struct ratio_less
            : public boost::integral_constant<bool, [/see below] > {};

If R1::num * R2::den < R2::num * R1::den, ratio_less derives from true_type, else derives from false_type. Implementations are permitted to use more complex algorithms to compute the above relationship to avoid overflow. If the implementation is not able to avoid overflow, a diagnostic shall be emitted.


    template <class R1, class R2>  struct ratio_not_equal
        : public boost::integral_constant<bool, !ratio_equal<R1, R2>::value> {};

    template <class R1, class R2> struct ratio_less_equal
        : public boost::integral_constant<bool, !ratio_less<R2, R1>::value> {};

    template <class R1, class R2> struct ratio_greater
        : public boost::integral_constant<bool, ratio_less<R2, R1>::value> {};

    template <class R1, class R2> struct ratio_greater_equal
        : public boost::integral_constant<bool, !ratio_less<R1, R2>::value> {};


[endsect]

[section:ration_SI_typedefs SI typedefs]

        // convenience SI typedefs
        typedef ratio<1LL, 1000000000000000000LL> atto;
        typedef ratio<1LL,    1000000000000000LL> femto;
        typedef ratio<1LL,       1000000000000LL> pico;
        typedef ratio<1LL,          1000000000LL> nano;
        typedef ratio<1LL,             1000000LL> micro;
        typedef ratio<1LL,                1000LL> milli;
        typedef ratio<1LL,                 100LL> centi;
        typedef ratio<1LL,                  10LL> deci;
        typedef ratio<                 10LL, 1LL> deca;
        typedef ratio<                100LL, 1LL> hecto;
        typedef ratio<               1000LL, 1LL> kilo;
        typedef ratio<            1000000LL, 1LL> mega;
        typedef ratio<         1000000000LL, 1LL> giga;
        typedef ratio<      1000000000000LL, 1LL> tera;
        typedef ratio<   1000000000000000LL, 1LL> peta;
        typedef ratio<1000000000000000000LL, 1LL> exa;


Four of the typedefs in the recomendation which can be conditionally supported are not supported: yocto, zepto, zetta and yotta.

    typedef ratio<1, 1000000000000000000000000> yocto;  // conditionally supported
    typedef ratio<1,    1000000000000000000000> zepto;  // conditionally supported
    typedef ratio<   1000000000000000000000, 1> zetta;  // conditionally supported
    typedef ratio<1000000000000000000000000, 1> yotta;  // conditionally supported

[endsect]

[endsect]


[/==========================================================================================]
[section:chrono_hpp Header `<boost/chrono.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace chrono {

        template <class Rep, class Period = ratio<1> >  class duration;
        template <class Clock, class Duration = typename Clock::duration> class time_point;

    }
        template <class Rep1, class Period1, class Rep2, class Period2>
        struct common_type<chrono::duration<Rep1, Period1>,
                         chrono::duration<Rep2, Period2> >;

        template <class Clock, class Duration1, class Duration2>
        struct common_type<chrono::time_point<Clock, Duration1>,
                         chrono::time_point<Clock, Duration2> >;

    namespace chrono {

        // customization traits
        template <class Rep> struct treat_as_floating_point;
        template <class Rep> struct duration_values;

        // duration arithmetic
        template <class Rep1, class Period1, class Rep2, class Period2>
        typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
        operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
        operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period, class Rep2>
        duration<typename common_type<Rep1, Rep2>::type, Period>
        operator*(const duration<Rep1, Period>& d, const Rep2& s);

        template <class Rep1, class Period, class Rep2>
        duration<typename common_type<Rep1, Rep2>::type, Period>
        operator*(const Rep1& s, const duration<Rep2, Period>& d);

        template <class Rep1, class Period, class Rep2>
        duration<typename common_type<Rep1, Rep2>::type, Period>
        operator/(const duration<Rep1, Period>& d, const Rep2& s);

        template <class Rep1, class Period1, class Rep2, class Period2>
        typename common_type<Rep1, Rep2>::type
        operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        // duration comparisons
        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
        template <class Rep1, class Period1, class Rep2, class Period2>
        bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

        // duration_cast

        template <class ToDuration, class Rep, class Period>
        ToDuration duration_cast(const duration<Rep, Period>& d);

        // convenience typedefs
        typedef duration<boost::int_least64_t, nano> nanoseconds;    // at least 64 bits needed
        typedef duration<boost::int_least64_t, micro> microseconds;  // at least 55 bits needed
        typedef duration<boost::int_least64_t, milli> milliseconds;  // at least 45 bits needed
        typedef duration<boost::int_least64_t> seconds;              // at least 35 bits needed
        typedef duration<boost::int_least32_t, ratio< 60> > minutes; // at least 29 bits needed
        typedef duration<boost::int_least32_t, ratio<3600> > hours;  // at least 23 bits needed

        // time_point arithmetic
        template <class Clock, class Duration1, class Rep2, class Period2>
        time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2> >::type>
        operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Rep1, class Period1, class Clock, class Duration2>
        time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
        operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);

        template <class Clock, class Duration1, class Rep2, class Period2>
        time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2> >::type>
        operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

        template <class Clock, class Duration1, class Duration2>
        typename common_type<Duration1, Duration2>::type
        operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                Duration2>& rhs);

        // time_point comparisons
        template <class Clock, class Duration1, class Duration2>
        bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);
        template <class Clock, class Duration1, class Duration2>
        bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock,
                      Duration2>& rhs);

        // time_point_cast
        template <class ToDuration, class Clock, class Duration>
        time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);

        // Clocks
        class system_clock;
        class monotonic_clock;
        class high_resolution_clock;

    }
    }

[section `Clock` Requirements]

A clock represents a bundle consisting of a native `duration`, a native `time_point`, and a function `now()` to get the current `time_point`. A clock shall meet the requirements in the following Table.

In this table `C1` and `C2` denote `clock` types. `t1` and `t2` are values returned from `C1::now()` where the call returning `t1` happens before the call returning `t2` and both of these calls happen before `C1::time_point::max()`.

[table Clock Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`C1::rep`]        [An arithmetic type or class emulating an arithmetic type. ]  [The representation type of the native `duration` and `time_point`.]]
    [[`C1::period`]        [`ratio`]  [The tick period of the clock in seconds.]]
    [[`C1::duration`]        [`chrono::duration<C1::rep, C1::period>`]  [The native `duration` type of the `clock`.]]
    [[`C1::time_point`]        [`chrono::time_point<C1> or chrono::time_point<C2, C1::duration>`]  [The native `time_point` type of the `clock`. Different clocks are permitted to share a `time_point` definition if it is valid to compare their time_points by comparing their respective `duration`s. `C1` and `C2` shall refer to the same epoch.]]
    [[`C1::is_monotonic`]        [`const bool`]  [`true` if `t1 <= t2` is always `true`, else `false`. [*Note: A `clock` that can be adjusted backwards is not monotonic]]]
    [[`C1::now()`]        [`C1::time_point`]  [Returns a `time_point` representing the current point in time.]]
]

[endsect]

[section Time-related traits]
[section:treat_as_floating_point Metafunction `treat_as_floating_point<>`]

    template <class Rep> struct treat_as_floating_point
        : boost::is_floating_point<Rep> {};

The `duration` template uses the `treat_as_floating_point` trait to help determine if a `duration` with one tick period can be converted to another `duration` with a different tick period. If `treat_as_floating_point<Rep>::value` is `true`, then `Rep` is a floating point type and implicit conversions are allowed among `duration`s. Otherwise, the implicit convertibility depends on the tick periods of the `duration`s. If `Rep` is a class type which emulates a floating point type, the author of `Rep` can specialize `treat_as_floating_point` so that `duration` will treat this `Rep` as if it were a floating point type. Otherwise `Rep` is assumed to be an integral type, or a class emulating an integral type.


[endsect]
[section:duration_values Class template `duration_values`]

    template <class Rep>
    struct duration_values
    {
    public:
        static BOOST_CONSTEXPR  Rep zero();
        static BOOST_CONSTEXPR  Rep max();
        static BOOST_CONSTEXPR  Rep min();
    };

The `duration` template uses the `duration_values` trait to construct special values of the `duration`s representation (`Rep`). This is done because the representation might be a class type with behavior which requires some other implementation to return these special values. In that case, the author of that class type should specialize `duration_values` to return the indicated values.

[section:zero Static member function`zero()`]

    static BOOST_CONSTEXPR Rep zero();

[*Returns:] `Rep(0)`. [*Note:] `Rep(0)` is specified instead of `Rep()` since `Rep()` may have some other meaning, such as an uninitialized value.

[*Remarks:] The value returned shall correspond to the additive identity.

[endsect]
[section:max Static member function `max()`]

    static BOOST_CONSTEXPR Rep max();

[*Returns:] `numeric_limits<Rep>::max()`.

[*Remarks:] The value returned shall compare greater than zero().

[endsect]
[section:min Static member function `min()`]

    static BOOST_CONSTEXPR Rep min();

[*Returns:] `numeric_limits<Rep>::lowest()`.

[*Remarks:] The value returned shall compare less than or equal to `zero()`.

[endsect]

[endsect]

[section `common_type` specializations]

    template <class Rep1, class Period1, class Rep2, class Period2>
    struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2> >
    {
        typedef chrono::duration<typename common_type<Rep1, Rep2>::type, see below> type;
    };

The period of the `duration` indicated by this specialization of `common_type` shall be the greatest common divisor of `Period1` and `Period2`. This can be computed by forming a `ratio` of the greatest common divisor of `Period1::num` and `Period2::num`, and the least common multiple of `Period1::den` and `Period2::den`.

[*Note:] The typedef type is the `duration` with the largest tick period possible where both `duration` arguments will convert to it without requiring a division operation. The representation of this type is intended to be able to hold any value resulting from this conversion, with the possible exception of round-off error when floating point `duration`s are involved (but not truncation error).

    template <class Clock, class Duration1, class Duration2>
    struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2> >
    {
        typedef chrono::time_point<Clock, typename common_type<Duration1, Duration2>::type> type;
    };

The `common_type` of two `time_point`s is a `time_point` with the same `clock` (both shall have the same `clock`), and the `common_type` of the two `duration`s.

[endsect]


[endsect]

[section Class template `duration`]

A `duration` measures time between two points in time (`time_point`). A `duration` has a representation which holds a count of ticks, and a tick period. The tick period is the amount of time which occurs from one tick to another in units of a second. It is expressed as a rational constant using `ratio`.

    namespace boost { namespace chrono {

        template <class Rep, class Period>
        class duration {
        public:
            typedef Rep rep;
            typedef Period period;
        private:
            rep rep_; // exposition only
        public:
            BOOST_CONSTEXPR duration() {} // = default;
            template <class Rep2>
            BOOST_CONSTEXPR explicit duration(const Rep2& r,
                  typename boost::enable_if_c
                  <
                  boost::is_convertible<Rep2, rep>::value
                     && (treat_as_floating_point<rep>::value
                     || (!treat_as_floating_point<rep>::value
                       && !treat_as_floating_point<Rep2>::value))
                  >::type* = 0);

            template <class Rep2, class Period2>
            BOOST_CONSTEXPR duration(const duration<Rep2, Period2>& d,
                  typename boost::enable_if_c
                  <
                      treat_as_floating_point<rep>::value
                      || (ratio_divide<Period2, period>::type::den == 1
                        && !treat_as_floating_point<Rep2>::value)
                  >::type* = 0);

            //~duration() = default;
            //duration(const duration&) = default;
            //duration& operator=(const duration&) = default;

            BOOST_CONSTEXPR rep count() const;

            BOOST_CONSTEXPR duration  operator+();
            BOOST_CONSTEXPR duration  operator-();
            duration& operator++();
            duration  operator++(int);
            duration& operator--();
            duration  operator--(int);

            duration& operator+=(const duration& d);
            duration& operator-=(const duration& d);

            duration& operator*=(const rep& rhs);
            duration& operator/=(const rep& rhs);
            duration& operator%=(const rep& rhs);
            duration& operator%=(const duration& rhs);

            static BOOST_CONSTEXPR duration zero();
            static BOOST_CONSTEXPR duration min();
            static BOOST_CONSTEXPR duration max();
        };

    }}

Rep shall be an arithmetic type, or a class emulating an arithmetic type. If `duration` is instantiated with the type of `Rep` being a `duration`, a diagnostic is required.

Period shall be an instantiation of `ratio`, diagnostic required.

Period::num shall be positive, diagnostic required.

Examples:

    duration<long, ratio<60> > holds a count of minutes using a long.

    duration<long long, milli> holds a count of milliseconds using a long long.

    duration<double, ratio<1, 30> > holds a count using a double with a tick period of 1/30 second (a tick frequency of 30 Hz).

The following members of `duration` do not throw an exception unless the indicated operations on the representations throw an exception.

[section:duration_c_1 Constructor `duration(const Rep2&)`]

    template <class Rep2>
    BOOST_CONSTEXPR explicit duration(const Rep2& r);

[*Requires:] `Rep2` is implicitly convertible to `rep`, and

* `treat_as_floating_point<rep>::value` is `true`, or
* `!treat_as_floating_point<rep>::value && !treat_as_floating_point<Rep2>::value` is `true`.

A diagnostic is required if this requirement is not met. [*Note:] This requirement prevents construction of an integral-based `duration` with a floating point representation. Such a construction could easily lead to confusion about the value of the `duration`.

[*Example:]

        duration<int, milli> d(3.5);  // shall not compile
        duration<int, milli> d(3);    // ok

[*Effects:] Constructs an object of type `duration`.

[*PostConditions:] `count() == static_cast<rep>(r)`.

[endsect]
[section:duration_c_2 Constructor `duration(const duration&)`]

    template <class Rep2, class Period2>
    BOOST_CONSTEXPR duration(const duration<Rep2, Period2>& d);

[*Requires:] `treat_as_floating_point<rep>::value`, or `ratio_divide<Period2, period>::type::den == 1`.

    A diagnostic is required if this requirement is not met.

[*note] This requirement prevents implicit truncation error when converting between integral-based `duration`s. Such a construction could easily lead to confusion about the value of the `duration`.

[*Example:]

        duration<int, milli> ms(3);
        duration<int, micro> us = ms;  // ok
        duration<int, milli> ms2 = us; // shall not compile

[*Effects:] Constructs an object of type `duration`, constructing `rep_` from `duration_cast<duration>(d).count()`.

[endsect]
[section:count Member function `count() const`]

    BOOST_CONSTEXPR rep count() const;

[*Returns:] `rep_v.

[endsect]
[section:duration_operator_p Member function `operator+() const`]

    BOOST_CONSTEXPR duration operator+() const;

[*Returns:] `*this`.

[endsect]
[section:duration_operator_m Member function `operator+() const`]

    BOOST_CONSTEXPR duration operator-() const;

[*Returns:] `duration(-rep_)`.

[endsect]
[section:duration_operator_pp Member function `operator++()`]

    duration& operator++();

[*Effects:] `++rep_`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_pp2 Member function `operator++(int)`]

    duration operator++(int);

[*Returns:] `duration(rep_++)v.

[endsect]
[section:duration_operator_mm Member function `operator++()`]

    duration& operator--();

[*Effects:] `--rep_`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_mm2 Member function `operator++(int)`]

    duration operator--(int);

[*Returns:] `duration(rep_--)`.

[endsect]
[section:duration_operator_pa Member function `operator+=(const duration&)`]

    duration& operator+=(const duration& d);

[*Effects:] `rep_ += d.count()`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_ma Member function `operator-=(const duration&)`]

    duration& operator-=(const duration& d);

[*Effects:] `rep_ -= d.count()`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_moda Member function `operator%=(const duration&)`]

    duration& operator%=(const duration& d);

[*Effects:] `rep_ %= d.count()`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_proda Member function `operator*=(const rep&)`]

    duration& operator*=(const rep& rhs);

[*Effects:] `rep_ *= rhs`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_da Member function `operator/=(const rep&)`]

    duration& operator/=(const rep& rhs);

[*Effects:] `rep_ /= rhs`.

[*Returns:] `*this`.

[endsect]
[section:duration_operator_moda_2 Member function `operator%=(const rep&)`]

    duration& operator%=(const rep& rhs);

[*Effects:] `rep_ %= rhs`.

[*Returns:] `*this`.

[endsect]


[section:duration_zero Static Member function `zero()`]

    static duration zero();

[*Returns:] `duration(duration_values<rep>::zero())`.

[endsect]
[section:duration_min Static Member function `min()`]

    static duration min();

[*Returns:] `duration(duration_values<rep>::min()).`

[endsect]
[section:duration_max Static Member function `max()`]

    static constexpr duration max();

[*Returns:] `duration(duration_values<rep>::max())`.

[endsect]

[endsect]


[section duration non-member arithmetic]

[section:duration_operator_p_1 Non-Member function `operator+(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
    operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `CD(lhs) += rhs` where `CD` is the type of the return value.

[endsect]
[section:duration_operator_m_1 Non-Member function `operator-(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type
    operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `CD(lhs) -= rhs` where `CD` is the type of the return value.

    template <class Rep1, class Period, class Rep2>
    duration<typename common_type<Rep1, Rep2>::type, Period>
    operator*(const duration<Rep1, Period>& d, const Rep2& s);

[*Requires:] Let `CR` represent the `common_type` of `Rep1` and `Rep2`. Both `Rep1` and `Rep2` shall be implicitly convertible to `CR`, diagnostic required.

[*Returns:] `duration<CR, Period>(d) *= s`.

[endsect]
[section:duration_operator_prod_1 Non-Member function `operator*(Rep1,duration)`]

    template <class Rep1, class Period, class Rep2>
    duration<typename common_type<Rep1, Rep2>::type, Period>
    operator*(const Rep1& s, const duration<Rep2, Period>& d);

[*Requires:] Let `CR` represent the `common_type` of `Rep1` and `Rep2`. Both `Rep1` and `Rep2` shall be implicitly convertible to `CR`, diagnostic required.

[*Returns:] `d * s`.

[endsect]
[section:duration_operator_d_1 Non-Member function `operator/(duration,Rep2)`]

    template <class Rep1, class Period, class Rep2>
    duration<typename common_type<Rep1, Rep2>::type, Period>
    operator/(const duration<Rep1, Period>& d, const Rep2& s);

[*Requires:] Let `CR` represent the `common_type` of `Rep1` and `Rep2`. Both `Rep1` and `Rep2` shall be implicitly convertible to `CR`, and `Rep2` shall not be an instantiation of `duration`, diagnostic required.

[*Returns:] `duration<CR, Period>(d) /= s`.

[endsect]
[section:duration_operator_d_2 Non-Member function `operator/(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    typename common_type<Rep1, Rep2>::type
    operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] Let `CD` represent the `common_type` of the two `duration` arguments. Returns `CD(lhs).count() / CD(rhs).count()`.

[endsect]

[endsect]

[section duration comparaisons]

[section:duration_operator_eq_1 Non-Member function `operator==(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] Let `CD` represent the `common_type` of the two `duration` arguments. Returns `CD(lhs).count() == CD(rhs).count()`

[endsect]
[section:duration_operator_neq_1 Non-Member function `operator!=(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `!(lhs == rhs)`.

[endsect]
[section:duration_operator_lt_1 Non-Member function `operator<(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] Let `CD` represent the `common_type` of the two `duration` arguments. Returns `CD(lhs).count() < CD(rhs).count()`

[endsect]
[section:duration_operator_leq_1 Non-Member function `operator<=(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `!(rhs < lhs)`.

[endsect]
[section:duration_operator_gt_1 Non-Member function `operator>(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `rhs < lhs`.

[endsect]
[section:duration_operator_gteq_1 Non-Member function `operator>=(duration,duration)`]

    template <class Rep1, class Period1, class Rep2, class Period2>
    bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `!(lhs < rhs)`.

[endsect]
[endsect]
[section:duration_cast Non-Member function `duration_cast(duration)`]

    template <class ToDuration, class Rep, class Period>
    ToDuration duration_cast(const duration<Rep, Period>& d);

[*Requires:] `ToDuration` is an instantiation of `duration`, diagnostic required.

[*Returns:] Forms `CF` which is a `ratio` resulting from `ratio_divide<Period, typename ToDuration::period>::type`. Let `CR` be the `common_type` of `ToDuration::rep`, `Rep`, and `intmax_t`.

* If `CF::num == 1` and `CF::den == 1`, then returns `ToDuration(static_cast<typename ToDuration::rep>(d.count())) `
* else if `CF::num != 1` and `CF::den == 1`, then returns
              `ToDuration(static_cast<typename ToDuration::rep>(static_cast<CR>(d.count()) *
                                                               static_cast<CR>(CF::num)))`
* else if `CF::num == 1` and `CF::den != 1`, then returns
              `ToDuration(static_cast<typename ToDuration::rep>(static_cast<CR>(d.count()) /
                                                               static_cast<CR>(CF::den)))`
* else returns
              `ToDuration(static_cast<typename ToDuration::rep>(static_cast<CR>(d.count()) *
                                                               static_cast<CR>(CF::num)   /
                                                               static_cast<CR>(CF::den)))`

[*Remarks:] This function shall not rely on any implicit conversions. All conversions shall be accomplished through `static_cast`. The implementation shall avoid all multiplications or divisions when it is known at compile time that it can be avoided because one or more arguments are `1`. All intermediate computations shall be carried out in the widest possible representation and only converted to the destination representation at the final step.


[endsect]



[section Class template `time_point`]

A `time_point` represents a point in time with respect to a specific clock.

    template <class Clock, class Duration>
    class time_point {
    public:
        typedef Clock                     clock;
        typedef Duration                  duration;
        typedef typename duration::rep    rep;
        typedef typename duration::period period;
    private:
        duration d_; // exposition only
    public:
        time_point();
        explicit time_point(const duration& d);

        // conversions
        template <class Duration2>
        time_point(const time_point<clock, Duration2>& t,
          typename boost::enable_if
          <
              boost::is_convertible<Duration2, duration>
          >::type* = 0);

        // observer

        duration time_since_epoch() const;

        // arithmetic

        time_point& operator+=(const duration& d);
        time_point& operator-=(const duration& d);

        // special values

        static BOOST_CONSTEXPR time_point min();
        static BOOST_CONSTEXPR time_point max();
    };

Clock shall meet the Clock Requirements.

Duration shall be an instantiation of `duration`, diagnostic required.

[section:time_point_c_1 Constructor `time_point()`]

    time_point();

[*Effects:] Constructs an object of `time_point`, initializing `d_` with `duration::zero()`. This `time_point` represents the epoch.

[endsect]
[section:time_point_c_2 Constructor `time_point(const duration&)`]

    time_point(const duration& d);

[*Effects:] Constructs an object of `time_point`, initializing `d_` with `d`. This `time_point` represents the epoch `+ d`.

[endsect]
[section:time_point_c_3 Constructor `time_point(const duration&)`]

    template <class Duration2> time_point(const time_point<clock, Duration2>& t);

[*Requires:] `Duration2` shall be implicitly convertible to `duration`, diagnostic required.

[*Effects:] Constructs an object of `time_point`, initializing `d_` with `t.time_since_epoch()`.

[endsect]

[section:time_since_epoch Member function `time_since_epoch() const`]

    duration time_since_epoch() const;

[*Returns:] `d_`.

[endsect]
[section:time_point_operator_pe Member function `operator+=`]

    time_point& operator+=(const duration& d);

[*Effects:] `d_ += d`.

[*Returns:] `*this`.

[endsect]
[section:time_point_operator_me Member function `operator-=`]

    time_point& operator-=(const duration& d);

[*Effects:] `d_ -= d`

[*Returns:] `*this`.

[endsect]
[section:time_point_min Static Member function `min`]

    static BOOST_CONSTEXPR time_point min();

[*Returns:] `time_point(duration::min())`.

[endsect]
[section:time_point_max Static Member function `max`]

    static BOOST_CONSTEXPR time_point max();

[*Returns:] `time_point(duration::max())`.

[endsect]
[endsect]


[section time_point non-member arithmetic]


[section:time_point_operator_p_1 Non-Member function `operator+(time_point,duration)`]

    template <class Clock, class Duration1, class Rep2, class Period2>
    time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2> >::type>
    operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `CT(lhs) += rhs` where `CT` is the type of the return value.

[endsect]
[section:time_point_operator_p_2 Non-Member function `operator+(duration,time_point)`]

    template <class Rep1, class Period1, class Clock, class Duration2>
    time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
    operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `rhs + lhs`.

[endsect]
[section:time_point_operator_m_1 Non-Member function `operator-(time_point,duration)`]

    template <class Clock, class Duration1, class Rep2, class Period2>
    time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2> >::type>
    operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);

[*Returns:] `lhs + (-rhs)`.

[endsect]
[section:time_point_operator_m_2 Non-Member function `operator-(duration,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    typename common_type<Duration1, Duration2>::type
    operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `lhs.time_since_epoch() - rhs.time_since_epoch()`.

[endsect]
[endsect]

[section time_point comparisons]
[section:time_point_operator_eq Non-Member function `operator==(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `lhs.time_since_epoch() == rhs.time_since_epoch()`.

[endsect]
[section:time_point_operator_neq Non-Member function `operator!=(time_point,time_point)`]

template <class Clock, class Duration1, class Duration2>
   bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `!(lhs == rhs)`.

[endsect]
[section:time_point_operator_lt Non-Member function `operator<(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] lhs.time_since_epoch() < rhs.time_since_epoch().

[endsect]
[section:time_point_operator_leq Non-Member function `operator<=(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `!(rhs < lhs)`.

[endsect]
[section:time_point_operator_gt Non-Member function `operator>(time_point,time_point)`]

template <class Clock, class Duration1, class Duration2>
   bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `rhs < lhs`.

[endsect]
[section:time_point_operator_geq Non-Member function `operator>=(time_point,time_point)`]

    template <class Clock, class Duration1, class Duration2>
    bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);

[*Returns:] `!(lhs < rhs)`.

[endsect]
[section:time_point_cast Non-Member function `time_point_cast(time_point)`]

    template <class ToDuration, class Clock, class Duration>
    time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);

[*Requires:] `ToDuration` is an instantiation of `duration`, diagnostic required.

[*Returns:] `time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch()))`.

[endsect]
[endsect]


[section Class `system_clock`]


    class system_clock {
    public:
        typedef BOOST_SYSTEM_CLOCK_DURATION          duration;
        typedef duration::rep                        rep;
        typedef duration::period                     period;
        typedef chrono::time_point<system_clock>     time_point;
        static const bool is_monotonic =             <unspecified>;

        static time_point  now();                         // throws on error
        static time_point  now(system::error_code & ec);  // never throws

        static std::time_t to_time_t(const time_point& t);
        static time_point  from_time_t(std::time_t t);
    };

`system_clock::duration::min() < system_clock::duration::zero()` shall be `true`.


[section:to_time_t Non-Member function `to_time_t(time_point)`]

time_t to_time_t(const time_point& t);

[*Returns:] A `time_t` such that the `time_t` and `t` represent the same point in time, truncated to the courser of the precisions among `time_t` and `t`.

[endsect]
[section:from_time_t Non-Member function `from_time_t(time_t)`]

    time_point from_time_t(time_t t);

[*Returns:] A `time_point` such that the `time_point` and `t` represent the same point in time, truncated to the courser of the precisions among `time_point` and `t`.

[endsect]
[endsect]

[section Class `monotonic_clock`]

`monotonic_clock` satisfy the Clock Requirements.

    #ifdef BOOST_HAS_CLOCK_MONOTONIC
        class BOOST_CHRONO_DECL monotonic_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<monotonic_clock>  time_point;
            static const bool is_monotonic =             true;

            static time_point  now();                         // throws on error
            static time_point  now(system::error_code & ec);  // never throws
        };
    #endif

[endsect]

[section Class `high_resolution_clock`]

`high_resolution_clock` satisfy the Clock Requirements.

    #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
      typedef monotonic_clock high_resolution_clock;  // as permitted by [time.clock.hires]
    #else
      typedef system_clock high_resolution_clock;  // as permitted by [time.clock.hires]
    #endif

[endsect]

[endsect]

[/==========================================================================================]
[section:timer_hpp Header `<boost/chrono/timer.hpp>`]
[/==========================================================================================]

    namespace boost { namespace chrono  {

        template <class Clock> class timer {
        public:
            typedef Clock                       clock;
            typedef typename Clock::duration    duration;
            typedef typename Clock::time_point  time_point;

            explicit timer( system::error_code & ec = system::throws );

            ~timer();

            void start( system::error_code & ec = system::throws );
            duration elapsed( system::error_code & ec = system::throws );

        };

        typedef boost::chrono::timer< boost::chrono::system_clock > system_timer;
    #ifdef BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::chrono::timer< boost::chrono::monotonic_clock > monotonic_timer;
    #endif
        typedef boost::chrono::timer< boost::chrono::high_resolution_clock > high_resolution_timer;

    } }


[endsect]

[/==========================================================================================]
[section:process_times_hpp Header `<boost/chrono/process_times.hpp>`]
[/==========================================================================================]

    namespace boost { namespace chrono {

        struct process_times;

        class process_clock {
        public:
            typedef nanoseconds                          duration;
            typedef duration::rep                        rep;
            typedef duration::period                     period;
            typedef chrono::time_point<process_clock>    time_point;
            static const bool is_monotonic =             true;

            static void now( process_times & times,
                             system::error_code & ec = system::throws );
        };

        struct process_times {
            process_clock::duration                       real;    // real (i.e wall clock) time
            process_clock::duration                       user;    // user cpu time
            process_clock::duration                       system;  // system cpu time
        };

        class process_timer {
        public:
            typedef process_clock                          clock;
            typedef process_clock::duration                duration;
            typedef process_clock::time_point              time_point;

            explicit process_timer( system::error_code & ec = system::throws );

            ~process_timer();
            void  start( system::error_code & ec = system::throws );
            void  elapsed( process_times & times, system::error_code & ec = system::throws );
        };

        class run_timer : public process_timer {
        public:

            explicit run_timer( system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os,
                        system::error_code & ec = system::throws );

            explicit run_timer( const std::string & format,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, const std::string & format,
                        system::error_code & ec = system::throws );

            explicit run_timer( const std::string & format, int places,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, const std::string & format, int places,
                        system::error_code & ec = system::throws );

            explicit run_timer( int places,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, int places,
                        system::error_code & ec = system::throws );

            explicit run_timer( int places, const std::string & format,
                        system::error_code & ec = system::throws );
            explicit run_timer( std::ostream & os, int places, const std::string & format,
                        system::error_code & ec = system::throws );

            ~run_timer();

            void start( system::error_code & ec = system::throws );

            void report( system::error_code & ec = system::throws );

            void test_report( duration real_, duration user_, duration system_ );
            bool reported() const;
            static int default_places();
        };

      } // namespace chrono
    } // namespace boost


[endsect]

[endsect]

[section Examples]

[section SI-units]

Type-safe "physics" code interoperating with std::chrono::duration types and taking advantage of the std::ratio infrastructure and design philosophy.

[/ratio_test_cpp]

[endsect]


[section How you override the duration's default constructor]

How you override the duration's default constructor to do anything you want (in this case zero)

[/i_dont_like_the_default_duration_behavior_cpp]

[endsect]

[section min utility]

Returns the earliest time_point.

    template <class Clock, class Duration1, class Duration2>
    typename boost::common_type<time_point<Clock, Duration1>,
                         time_point<Clock, Duration2> >::type
    min(time_point<Clock, Duration1> t1, time_point<Clock, Duration2> t2)
    {
        return t2 < t1 ? t2 : t1;
    }

Being able to *easily* write this function is a major feature!

    typedef time_point<system_clock,
      boost::common_type<system_clock::duration, seconds>::type> T1;
    typedef time_point<system_clock,
      boost::common_type<system_clock::duration, nanoseconds>::type> T2;
    typedef boost::common_type<T1, T2>::type T3;
    /*auto*/ T1 t1 = system_clock::now() + seconds(3);
    /*auto*/ T2 t2 = system_clock::now() + nanoseconds(3);
    /*auto*/ T3 t3 = min(t1, t2);


[endsect]

[section Cycle count]

How you override the duration's default constructor to do anything you want (in this case zero)

[/cycle_count_cpp]

[endsect]

[section xtime_clock]


[/xtime_clock_cpp]

[endsect]

[section runtime_resolution]


[/runtime_resolution_cpp]

[endsect]

[section Simulated thread interface demonstration program]

[/simulated_thread_interface_demo_cpp]

[endsect]



[section saturating]

A "saturating" signed integral type  is developed.  This type has +/- infinity and a nan (like IEEE floating point) but otherwise obeys signed integral arithmetic. This class is subsequently used as the rep in boost::chrono::duration to demonstrate a duration class that does not silently ignore overflow.

[/ratio_test_cpp]

[endsect]

[section Howard Hinnant's original demonstration program]

[/time2_demo_cpp]

[endsect]

[section A tiny program that times how long until a key is struck]

[/await_keystroke_cpp]

[endsect]

[section run_timer_example.cpp]

Here is the run_timer_example.cpp program supplied with the Boost Chrono library:

[/run_timer_example_cpp]

When the run_timer t object is created, it starts timing. When it is destroyed at the end of the program, its destructor stops the timer and displays timing information on cout.

The output of this program run on a circa 2006 processor looks was this:

   wall 0.42 s, user 0.41 s + system 0.00 s = total cpu 0.41 s, (96.3%)

In other words, this program ran in 0.42 seconds as would be measured by a clock on the wall, the operating system charged it for 0.41 seconds of user CPU time and 0 seconds of system CPU time, the total of these two was 0.41, and that represented 96.3 percent of the wall clock time.

[endsect]

[section run_timer_example2.cpp]

The run_timer_example2.cpp program is the same, except that it supplies additional constructor arguments from the command line:

    #include <boost/system/timer.hpp>
    #include <cmath>

    int main( int argc, char * argv[] )
    {
      const char * format = argc > 1 ? argv[1] : "%t cpu seconds\n";
      int          places = argc > 2 ? std::atoi( argv[2] ) : 2;

      boost::system::run_timer t( format, places );

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L ); // burn some time

      return 0;
    }

Here is the output for this program for several sets of command line arguments:

    run_timer_example2
    0.42 cpu seconds

    run_timer_example2 "%w wall clock seconds\n"
    0.41 wall clock seconds

    run_timer_example2 "%w wall clock seconds\n" 6
    0.421875 wall clock seconds

    run_timer_example2 "%t total CPU seconds\n" 3
    0.422 total CPU seconds

[endsect]


[endsect]
[/=================]
[section Appendices]
[/=================]
[/==================================]
[section:history Appendix A: History]
[/==================================]

[section [*Version 0.2.0, December 8, 2009] ['+ Features + Bug fixes + Updated documentation]]

[*Features:] 

* Added ratio construction and assignment from an equivalent ratio ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]])
* Added nested ratio typedef type ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]])
* Added BOOST_CHRONO_HAS_CLOCK_MONOTONIC macro to state if monotonic_clock is provided on this platform.
* Added duration operator% ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-defects.html#934 [*934. duration is missing operator%]])
* Added BOOST_CONSTEXPR when constexpr should be used
* Complete duration operator* and operator/  


[*Implementation:]

* Use INTMAC_C to name intmax_t constants instead of LL.
* Separate chrono.cpp on # files win/chrono.cpp, mac/chrono.cpp and posix/chrono.cpp to make easier the maintenance on different platforms.
* Separate process_clock.cpp on # files win/process_clock.cpp, mac/process_clock.cpp and posix/process_clock.cpp to make easir the maintenace on different platforms.
* Added the error_code prototype for monotonic_clock::now for mac/chono.cpp
* Fully implement mac/chrono.cpp with error handling.
* Take care on POSIX systems when CLOCK_MONOTONIC is not defined.

[*Documentation:]

* The documentation is written now using quick-book using as base [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] .

[*Bugs]

* operator/ was ambiguous: Disambiguate duration operator/  
* CLOCK_MONOTONIC is not defined with cygwin/gcc 3.4: Disable code when BOOST_CHRONO_HAS_CLOCK_MONOTONIC is not defined.
* result of metafunctions ratio_multiply and ratio_divide were not normalized ratios: Use of the nested ratio typedef type on ratio arithmetic operations.
* Copy constructor from similar duration masked the defaulted operations: Added duration defaulted implementations


[endsect]
[section [*Version 0.1.0, April 29, 2009] ['Beman's boostified version Chrono]]

[*Features:]

*  The C++0x Standard Library's `common_type`.
*  The C++0x Standard Library's compile-time rational arithmetic.
*  The C++0x Standard Library's time utilities, including:
    * Class template `duration`
    * Class template `time_point`
    * Clocks:
        * `system_clock`
        * `monotonic_clock`
        * `high_resolution_clock`

* Class template timer, with typedefs:
    * `system_timer`
    * `monotonic_timer`
    * `high_resolution_timer`

* Process clocks and timers:
    * `process_clock`, capturing real, user-CPU, and system-CPU times.
    * `process_timer`, capturing elapsed real, user-CPU, and system-CPU times.
    * `run_timer`, convenient reporting of process_timer results.

[endsect]
[endsect]

[section:rationale Appendix B: Rationale]

See [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] which is very informative and provides motivation for key design decisions. The following sections are an extract from this document.

[heading Is it possible for the user to pass a `duration` to a function with the units being ambiguous?]

No. No matter which option the author of `f` chooses above, the following client code will not compile:

    f(3);  // Will not compile, 3 is not implicitly convertible to any `duration`

[heading Why duration needs operator%]

This operator is convenient for computing where in a time frame a given duration lies. A motivating example is converting a duration into a "broken-down" time duration such as hours::minutes::seconds:

    class ClockTime
    {
        typedef std::chrono::hours hours;
        typedef std::chrono::minutes minutes;
        typedef std::chrono::seconds seconds;
    public:
        hours hours_;
        minutes minutes_;
        seconds seconds_;

        template <class Rep, class Period>
          explicit ClockTime(const std::chrono::duration<Rep, Period>& d)
            : hours_  (std::chrono::duration_cast<hours>  (d)),
              minutes_(std::chrono::duration_cast<minutes>(d % hours(1))),
              seconds_(std::chrono::duration_cast<seconds>(d % minutes(1)))
              {}
    };

[heading Why ratio needs CopyConstruction and Assignment from ratios having the same normalized form]

Current [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf [*N3000]] doesn't allows to copy-construct or assign ratio instances of ratio classes having the same normalized form.

This simple example

    ratio<1,3> r1;
    ratio<3,9> r2;
    r1 = r2; // (1)

fails to compile in (1). Other example

    ratio<1,3> r1;
    ratio<2,3> r2;
    r1 = r2-r1; // (2)

The type of this expression (r2-r1) could be ratio<3,9> so the compilation could fail in (2). It could also be ratio<1,3> and the compilation succeeds.

[heading Why ratio needs the nested normalizer typedef type]

In [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf [*N3000]] 20.4.2 and similar clauses

[/3 The nested typedef type shall be a synonym for ratio<T1, T2> where T1 has the value R1::num * R2::den - R2::num * R1::den and T2 has the value R1::den * R2::den.]

The meaning of synonym let think that the result shall be a normalized ratio equivalent to ratio<T1, T2>, but there is not an explicit definition of what synonym means in this context.

If the CopyConstruction and Assignment ([[@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#12811281 [*LWG 1281]]) is not added we need a typedef for accessing the normalized ratio, and change 20.4.2 to return only this normalized result. In this case the user will need to 

    ratio<1,3>::type r1;
    ratio<3,9>::type r2;
    r1 = r2; // compiles as both types are the same.


[endsect]

[section:implementation Appendix C: Implementation Notes]


[heading Why does run_timer only display millisecond place precision when the underlying timer has nanosecond precision?]

To avoid giving the impression of precision where none exists. See Caveat emptor. You can always specify additional decimal places if you want to live dangerously.

[heading Why does run_timer sometimes report more cpu seconds than real seconds?]

Ask your operating system supplier. The results have been inspected with a debugger, and both for Windows and Linux, that's what the OS appears to be reporting at times.

[endsect]

[section:acknowledgements Appendix D: Acknowledgements]

The library's code was derived from Howard Hinnant's time2_demo prototype. Many thanks to Howard for making his code available under the Boost license. The original code was modified by Beman Dawes to conform to Boost conventions.

time2_demo contained this comment:

Much thanks to Andrei Alexandrescu, Walter Brown, Peter Dimov, Jeff Garland, Terry Golubiewski, Daniel Krugler, Anthony Williams.


[endsect]
[section  Appendix E: Tests]

In order to test you need to do just

    bjam libs/chrono/test


[section `ratio`]
[table
    [[Name]             [kind]          [Description]          [Result] [Ticket]]
    [[ratio_fail_1.]    [compile-fails] [...]                  [Pass]   [#]]
    [[ratio_test]       [run]           [...]                  [Pass]   [#]]
]
[endsect]

[section chrono]
[table
    [[Name]             [kind]          [Description]          [Result] [Ticket]]
    [[chrono_unit]      [run]           [...]                  [Pass]   [#]]
]
[endsect]

[section timer]
[table
    [[Name]                         [kind]          [Description]           [Result] [Ticket]]
    [[timer.accuracy]               [run]           [...]                   [Pass]   [#]]
    [[timer.run_timer_constructor_overload] [run]   [...]                   [Pass]   [#]]
    [[timer.process_timer_test]      [run]          [...]                   [Pass]   [#]]
]
[endsect]

[endsect]
[section  Appendix F: Tickets]

[endsect]

[/=====================================]
[section:todo  Appendix F: Future plans]
[/=====================================]

[heading Tasks to do before review]

* Fully implement error handling, with test cases.
* Consider issues raised by Michael Marcin:

'''
    > In the past I've seen QueryPerformanceCounter give incorrect results,
    > especially with SpeedStep processors on laptops. This was many years ago and
    > might have been fixed by service packs and drivers.
    >
    > Typically you check the results of QPC against GetTickCount to see if the
    > results are reasonable.
    > http://support.microsoft.com/kb/274323
    >
    > I've also heard of problems with QueryPerformanceCounter in multi-processor
    > systems.
    >
    > I know some people SetThreadAffinityMask to 1 for the current thread call
    > their QueryPerformance* functions then restore SetThreadAffinityMask. This
    > seems horrible to me because it forces your program to jump to another
    > physical processor if it isn't already on cpu0 but they claim it worked well
    > in practice because they called the timing functions infrequently.
    >
    > In the past I have chosen to use timeGetTime with timeBeginPeriod(1) for
    > high resolution timers to avoid these issues.
'''

[heading For later releases]

* Use of C++0x features, such as variadic templates, rvalues, decltype and constexpr, when available.
* Define a C++98 variadic template emmulation  of common_type

[endsect]
[endsect]
