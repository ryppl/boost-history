[/
 / Copyright (c) 2009-20010 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[article Boost.Stopwatches
    [quickbook 1.5]
    [authors [Botet Escriba, Vicente J.]]
    [copyright 2009-2010 Vicente J. Botet Escriba]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/==================]
[def __Boost_Chrono__ [*Boost.Chrono]]

[def __Boost_Stopwatches__ [*Boost.Stopwatches]]


[/===============================================]

[template common_type_link[link_text] [link boost_stopwatches.reference.cpp0x.common_type_hpp.common_type [link_text]]]
[def __common_type__ `common_type`]

[/===============================================]
[def __ratio__ `ratio`]



[template ratio_arithmetic[link_text] [link boost_stopwatches.reference.cpp0x.ratio_hpp.ratio_arithmetic [link_text]]]
[def __ratio_add `ratio_add`]
[def __ratio_subtract `ratio_subtract`]
[def __ratio_multiply `ratio_multiply`]
[def __ratio_divide `ratio_divide`]


[template ratio_comparison[link_text] [link boost_stopwatches.reference.cpp0x.ratio_hpp.ratio_comparison [link_text]]]
[def __ratio_equal `ratio_equal]]
[def __ratio_not_equal `ratio_not_equal`]
[def __ratio_less `ratio_less`]]
[def __ratio_less_equal `ratio_less_equal`]
[def __ratio_greater `ratio_greater`]
[def __ratio_greater_equal `ratio_greater_equal`]


[/template ratio_si_typedefs[link_text] [link boost_stopwatches.reference.cpp0x.ratio_hpp.ratio_si_typedefs [link_text]]]
[template ratio_si_typedefs[link_text] [link_text]]
[def __atto [ratio_si_typedefs `atto`]]
[def __femto [ratio_si_typedefs `femto`]]
[def __pico [ratio_si_typedefs `pico`]]
[def __nano [ratio_si_typedefs `nano`]]
[def __micro [ratio_si_typedefs `micro`]]
[def __milli [ratio_si_typedefs `milli`]]
[def __centi [ratio_si_typedefs `centi`]]
[def __deci [ratio_si_typedefs `deci`]]
[def __deca [ratio_si_typedefs `deca`]]
[def __hecto [ratio_si_typedefs `hecto`]]
[def __kilo [ratio_si_typedefs `kilo`]]
[def __mega [ratio_si_typedefs `mega`]]
[def __giga [ratio_si_typedefs `giga`]]
[def __tera [ratio_si_typedefs `tera`]]
[def __peta [ratio_si_typedefs `peta`]]
[def __exa [ratio_si_typedefs `exa`]]


[/==================]


[/template chrono_conf[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.conf [link_text]]]
[template chrono_conf[link_text] [link_text]]


[def __BOOST_CHRONO_USES_STATIC_ASSERT [chrono_conf `BOOST_CHRONO_USES_STATIC_ASSERT`]]
[def __BOOST_CHRONO_USES_MPL_ASSERT [chrono_conf `BOOST_CHRONO_USES_MPL_ASSERT`]]
[def __BOOST_CHRONO_USES_ARRAY_ASSERT [chrono_conf `BOOST_CHRONO_USES_ARRAY_ASSERT`]]

[/def __BOOST_CHRONO_HAS_CLOCK_MONOTONIC [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.BOOST_CHRONO_HAS_CLOCK_MONOTONIC `BOOST_CHRONO_HAS_CLOCK_MONOTONIC`]]

[def __BOOST_CHRONO_HAS_CLOCK_MONOTONIC `BOOST_CHRONO_HAS_CLOCK_MONOTONIC`]


[/template clock_concept_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.clock [link_text]]]
[template clock_concept_link[link_text] [link_text]]
[def __clock_concept__ [clock_concept_link `Clock` concept]]
[def __clock_concept_type__ [clock_concept_link `Clock`]]
[def __clock_req__ [clock_concept_link `Clock` requirements]]
[def __Clock__ [clock_concept_link `Clock`]]
[def __Clock_s__ [clock_concept_link `Clock`'s]]


[/template duration_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.duration [link_text]]]
[template duration_link[link_text] [link_text]]
[def __duration__ [duration_link `duration`]]
[def __duration_s__ [duration_link `duration`'s]]

[/==================]
[/template time_point_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.time_point [link_text]]]
[template time_point_link[link_text] [link_text]]
[def __time_point__ [time_point_link `time_point`]]
[def __time_point_s__ [time_point_link `time_point`'s]]

[/==================]
[/template system_clock_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.system_clock [link_text]]]
[template system_clock_link[link_text] [link_text]]
[def __system_clock__ [system_clock_link `system_clock`]]

[/==================]
[/template monotonic_clock_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.monotonic_clock [link_text]]]
[template monotonic_clock_link[link_text] [link_text]]
[def __monotonic_clock__ [monotonic_clock_link `monotonic_clock`]]

[/==================]
[/template high_resolution_clock_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.high_resolution_clock [link_text]]]
[template high_resolution_clock_link[link_text] [link_text]]
[def __high_resolution_clock__ [high_resolution_clock_link `high_resolution_clock`]]

[/def __duration_cast__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.duration_cast `duration_cast`]]
[def __duration_cast__ `duration_cast`]

[/def __time_point_cast__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.time_point_cast `time_point_cast`]]
[def __time_point_cast__ `time_point_cast`]


[/template duration_typedefs[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.duration_typedefs [link_text]]]
[template duration_typedefs[link_text] [link_text]]
[def __nanoseconds__ [duration_typedefs `nanoseconds`]]
[def __microseconds__ [duration_typedefs `microseconds`]]
[def __milliseconds__ [duration_typedefs `milliseconds`]]
[def __seconds__ [duration_typedefs `seconds`]]
[def __minutes__ [duration_typedefs `minutes`]]
[def __hours__ [duration_typedefs `hours`]]
[def __days__ [duration_typedefs `days`]]

[/def __common_type_spe__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.common_type_spe `common_type`]]
[def __common_type_spe__ `common_type`]

[/==================]
[/def __treat_as_floating_point__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.traits.treat_as_floating_point `treat_as_floating_point`]]
[def __treat_as_floating_point__ `treat_as_floating_point`]
[/def __duration_values__ `duration_values`]
[def __duration_values__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.traits.duration_values `duration_values`]]
[/def __zero__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.traits.duration_values.zero `zero`]]
[def __zero__ `zero`]
[/def __max__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.traits.duration_values.max `max`]]
[def __max__ `max`]
[/def __min__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.traits.duration_values.min `min`]]
[def __min__ `min`]


[/==================]
[/template SuspendibleClock_concept_link[link_text] [link boost_stopwatches.reference.other_clocks.suspendible_clock_req [link_text]]]
[template SuspendibleClock_concept_link[link_text] [link_text]]
[def __SuspendibleClock_concept__ [SuspendibleClock_concept_link `SuspendibleClock` concept]]
[def __SuspendibleClock_concept_type__ [SuspendibleClock_concept_link `SuspendibleClock`]]
[def __SuspendibleClock_req__ [SuspendibleClock_concept_link `SuspendibleClock` requirements]]
[def __SuspendibleClock__ [SuspendibleClock_concept_link `SuspendibleClock`]]

[/==================]
[template stopwatch_concept_link[link_text] [link boost_stopwatches.reference.stopwatches.stopwatch_req [link_text]]]
[def __stopwatch_concept__ [stopwatch_concept_link `Stopwatch` concept]]
[def __stopwatch_concept_type__ [stopwatch_concept_link `Stopwatch`]]
[def __stopwatch_req__ [stopwatch_concept_link `Stopwatch` requirements]]
[def __Stopwatch__ [stopwatch_concept_link `Stopwatch`]]


[def __stopwatch__ [link boost_stopwatches.reference.stopwatches.stopwatch_hpp.stopwatch `stopwatch`]]

[def __stopwatch_accumulator__ [link boost_stopwatches.reference.stopwatches.stopwatch_accumulator_hpp.stopwatch_accumulator `stopwatch_accumulator`]]


[def __stopwatch_reporter__ [link boost_stopwatches.reference.reporters.stopwatch_reporter_hpp.stopwatch_reporter `stopwatch_reporter`]]

[def __stopclock_accumulator__ [link boost_stopwatches.reference.reporters.stopclock_accumulator_hpp.stopclock_accumulator `stopclock_accumulator`]]

[/==================]
[template formatter_concept_link[link_text] [link boost_stopwatches.reference.reporters.formatter_req [link_text]]]
[def __formatter_concept__ [formatter_concept_link `Formatter` concept]]
[def __formatter_concept_type__ [formatter_concept_link `Formatter`]]
[def __formatter_req__ [formatter_concept_link `Formatter` requirements]]
[def __Formatter__ [formatter_concept_link `Formatter`]]

[def __stopclock__ [link boost_stopwatches.reference.reporters.stopclock_hpp.stopclock `stopclock`]]
[def __stopclock_clock__ [link boost_stopwatches.reference.reporters.stopclock_hpp.stopclock `stopclock<Clock>`]]

[def __scoped_stopclock__ [link boost_stopwatches.reference.reporters.scoped_stopclock_hpp.scoped_stopclock `scoped_stopclock`]]

[def __process_real_cpu_clock__  `process_real_cpu_clock`]

[def __process_system_cpu_clock__ `process_system_cpu_clock`]

[def __process_user_cpu_clock__  `process_user_cpu_clock`]

[def __thread_clock__  `thread_clock`]

[def __suspendible_clock__  `suspendible_clock`]

[def __stopwatch_accumulator_formatter__ [link boost_stopwatches.reference.formatters.stopwatch_accumulator_formatter_hpp.basic_stopwatch_accumulator_formatter `stopwatch_accumulator_formatter`]]

[def __stopwatch_accumulator_time_formatter__ [link boost_stopwatches.reference.formatters.stopwatch_accumulator_time_formatter_hpp.basic_stopwatch_accumulator_time_formatter `stopwatch_accumulator_time_formatter`]]

[def __basic_stopwatch_formatter__ [link boost_stopwatches.reference.formatters.stopwatch_formatter_hpp.basic_stopwatch_formatter `stopwatch_accumulator_formatter`]]

[def __basic_stopwatch_accumulator_formatter__ [link boost_stopwatches.reference.formatters.stopwatch_accumulator_formatter_hpp.basic_stopwatch_accumulator_formatter `stopwatch_accumulator_formatter`]]

[def __basic_24_hours_formatter__ [link boost_stopwatches.reference.formatters.t24_hours_formatter_hpp.basic_24_hours_formatter `basic_24_hours_formatter`]]



[warning Stopwatches is not part of the Boost libraries.]

[/===============]
[section Overview]
[/===============]



[/====================================]
[heading How to Use This Documentation]
[/====================================]

This documentation makes use of the following naming and formatting conventions.

* Code is in `fixed width font` and is syntax-highlighted.
* Replaceable text that you will need to supply is in [~italics].
* Free functions are rendered in the code font followed by (), as in free_function().
* If a name refers to a class template, it is specified like this:   `class_template<>`; that is, it is in code font and its name is followed by `<>`   to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in code font and its name is followed by `()` to   indicate that it is a function-like macro. Object-like macros appear without the   trailing `()`.
* Names that refer to /concepts/ in the generic programming sense are  specified in CamelCase.

[note In addition, notes such as this one specify non-essential information that provides additional background or rationale.]

Finally, you can mentally add the following to any code fragments in this document:

    // Include all of Stopwatches files
    #include <boost/stopwatches.hpp>
    using namespace boost::chrono;
    using namespace boost::stopwatches;


[/=================]
[section Motivation]
[/=================]



[heading Measuring elapsed time]

Knowing how long a program, a function or a specific code block takes to execute is useful in both test and production environments.
__Boost_Stopwatches__ introduces the __Stopwatch__ concept which is a mechanism to measure the elapsed time.
A Stopwatch allows to start, stop, suspend and resume measuring the elapsed time.
__stopwatch__`<>` is the basic model of __Stopwatch__.

[heading Reporting elapsed time]

It is often necessary to report elapsed time on a user display or in a log file.  __stopwatch_reporter__<> provides a runtime reporting mechanism for this purpose which can be invoked in just one line of code.

    using namespace boost::chrono;
    using namespace boost::stopwatches;
    int main()
    {
        stopwatch_reporter<stopwatch<process_cpu_clock> > _;
      // ...
    }

Will produce the following output

    real 0.034s, cpu 0.031s (93.0%), user 0.031s, system 0.000s

As this is one of the expression more commonly use, the library provides a stopclock shortcut so the preceding can be writen as

    using namespace boost::stopwatches;
    int main()
    {
        __stopclock__<> _;
      // ...
    }


[heading How reliable are these measures?]

There are a number of things that can lead to unreliable measurement (see [link boost_stopwatches.appendices.rationale here] for more details), but they mostly amount to reporting overhead.  Boost.Chrono provides two ways to improve reliability of time measurements.  A __stopwatch_accumulator__ only reports statistics once all measurements have been acquired, which removes reporting overhead from the measurements.  The other approach is to use a __SuspendibleClock__ such that the reporting overhead can be ignored by suspending elapsed time tracking during reporting operations

[endsect]

[/==================]
[section Description]
[/==================]


On top of the standard facilities of __Boost_Chrono__, __Boost_Stopwatches__ provides:

* Stopwatches: A facility to measure elapsed time with the ability to start, stop, suspend, or resume measurement.
    * __Stopwatch__ concept
    * Scoped helper classes allowing to pairwise start/stop operations, suspend/resume and resume/suspend a __Stopwatch__.
    * __stopwatch__, model of __Stopwatch__ capturing elapsed __Clock__ times.
    * __stopwatch_accumulator__, model of __Stopwatch__ capturing cummulated elapsed Clock times.

* Stopclocks: a complete time reporting package that can be invoked in a single line of code.
    * __stopwatch_reporter__, convenient reporting to an output stream (including wide char streams) of the elapsed time of models of __Stopwatch__ results.
    * __stopclock_clock__ shortcut of `__stopwatch_reporter__<__stopwatch__<Clock>>`


[endsect]

[endsect]


[/==============================]
[section:users_guide Users'Guide]
[/==============================]

[/======================================]
[section:getting_started Getting Started]
[/======================================]

[/======================================]
[section:install Installing __Boost_Stopwatches__]
[/======================================]

[/=================================]
[heading Getting __Boost_Stopwatches__ ]
[/=================================]

You can get the last stable release of __Boost_Stopwatches__ by downloading [^chrono.zip] from the
[@http://www.boost-consulting.com/vault/index.php?directory=System Boost Vault], directories boost/stopwatches and libs/stopwatches.

You can also access the latest (unstable?) state from the [@http://svn.boost.org/svn/boost/sandbox/chrono Boost Sandbox], directories boost/stopwatches and libs/stopwatches. Just go to [@http://svn.boost.org/trac/boost/wiki/BoostSubversion here] and follow the instructions there for anonymous SVN access.

[/==========================================]
[heading Where to install __Boost_Stopwatches__? ]
[/==========================================]

The simple way is to decompress (or checkout from SVN) the file in your BOOST_ROOT directory.

Othesewise, if you decompress in a different directory, you will need to comment some lines, and uncomment and change others in the build/Jamfile and test/Jamfile. Sorry for this, but I have not reached yet to write a Jamfile that is able to work in both environements and use the BOOST_ROOT variable. Any help is welcome.

[/=================================]
[heading Building __Boost_Stopwatches__ ]
[/=================================]

__Boost_Stopwatches__ is a header only library. 

[/===================]
[heading Requirements]
[/===================]

__Boost_Stopwatches__ depends on some Boost libraries. For these specific parts you must use either Boost version 1.44.0 or the version in SVN trunk (even if older versions should works also).

In particular, __Boost_Stopwatches__ depends on:

[variablelist
[
    [[@http://www.boost.org/libs/chrono [*Boost.Chrono]]] [for duration, time_point and clocks, ...]
]
[
    [[@http://www.boost.org/libs/config [*Boost.Config]]] [for configuration purposes, ...]
]
[
    [[@http://www.boost.org/libs/exception [*Boost.Exception]]] [for throw_exception, ...]
]
[
    [[@http://www.boost.org/libs/mpl [*Boost.MPL]]] [for MPL Assert and bool, ...]
]
[
    [[@http://www.boost.org/libs/system [*Boost.System]]] [for error_code, ...]
]
[
    [[@http://www.boost.org/libs/io [*Boost.Input/Outpu]]] [for io_state, ...]
]
[
    [[@http://www.boost.org/libs/static_assert [*Boost.StaticAssert]]] [for STATIC_ASSERT, ...]
]
[
    [[@http://www.boost.org/libs/type_traits [*Boost.TypeTraits]]] [for is_same, ...]
]
[
    [[@http://www.boost.org/libs/utility [*Boost.Utility]]] [for base_from_memeber, ...]
]
]

__Boost_Stopwatches__ depends optionaly on:

[variablelist
[
    [[@http://www.boost.org/libs/accumulator [*Boost.Accumulator]]] [for accumulator_set, and statistics features when stopwatch_accumulator.hpp is included]
]
]


[/=========================================================]
[heading Building an executable that uses __Boost_Stopwatches__ ]
[/=========================================================]

In addition to link with the Boost Chrono library you need also to link with the Boost System library. If you use Suspendibles clocks you will need also with Boos Thread.

[/=========================]
[heading Exceptions safety ]
[/=========================]

All functions in the library are exception-neutral and provide strong guarantee of exception safety as long as the underlying parameters provide it.

[/=====================]
[heading Thread safety ]
[/=====================]

All functions in the library are thread-unsafe except when noted explicitly.

[/========================]
[heading Tested compilers ]
[/========================]

The implementation will eventually work with most C++03 conforming compilers.
Current version has been tested on:

Windows with

* MSVC 10.0
* MSVC 9.0 Express
* MSVC 8.0

[/* Intel 11.0]

Scientific Linux with

* GCC 4.1.2

Cygwin with

* GCC 3.4.4
* GCC 4.3.2

MinGW with

* GCC 4.4.0

Initial version was tested on:

MacOS with GCC 4.2.4

Ubuntu Linux with GCC 4.2.4

[note Please let us know how this works on other platforms/compilers.]

[note Please send any questions, comments and bug reports to boost <at> lists <dot> boost <dot> org.]

[endsect]
[/====================]
[section Hello World! ]
[/====================]

If all you want to do is to time a program's execution:

    #include <boost/stopwatches/stopclock.hpp>

    ...

    // add this in the scope you want to time,
    // at the point you want the timer to start.
    boost::stopwatches::__stopclock__<> rt;

Here is a complete program (stopclock_example.cpp):

    #include <boost/stopwatches/stopclock.hpp>
    #include <cmath>

    int main()
    {
      boost::stopwatches::__stopclock__<> t;

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L ); // burn some time

      return 0;
    }

Debug build output was:

    real 0.832s, cpu 0.813s (97.7%), user 0.813s, system 0.000s

In other words, the program took 0.832 real-time (i.e. wall clock) seconds to execute, while the operating system (Windows in this case) charged 0.813 seconds of CPU time to the user and 0 seconds to the system. The total CPU time reported was 0.813 seconds, and that represented utilization of 97.7% of the real-time seconds.

[endsect]

[endsect]


[section Tutorial]




[section Stopwatches and Stopclocks]

Knowing how long a program, a function or a specific block takes to execute is useful in both test and production environments.
__Boost_Stopwatches__ introduces the __Stopwatch__ concept which captures the mechanism to measure the elapsed time.
A __Stopwatch__ allows to `start`, `stop`, `suspend` and `resume` measuring the elapsed time.
__stopwatch__`<>` is the basic model of __Stopwatch__ allowing to make a single measure.

At the user level, the main use case of measuring the elapsed time is to report these measures on the display.
__stopwatch_reporter__`<>` provides a run time reporting package that can be invoked in a single line of code to report the usage of a __Clock__.
For example

    using namespace boost::chrono;
    using namespace boost::stopwatches;
    
    int f1(long j) {
        __stopwatch_reporter__<__stopwatch__<> > _;

        for ( long i = 0; i < j; ++i )
            std::sqrt( 123.456L );  // burn some time

        return 0;
    }
    int main()  {
        f1(100000);
        f1(200000);
        f1(300000);
        return 0;
    }

Will produce the following output

    0.006s
    0.011s
    0.017s


[section  Stopwatches accumulation and statistics]

The preceding stopwatch manage only with a measure. It is also interesting to have an statisitical view of these times, for example the sum, min, max and mean. __stopwatch_accumulator__`<>` associates an accumulator with a __stopwatch__, so we are able to retrieve any statistical feature Boost.Accumulator provides.

For example

    using namespace boost::stopwatches;
    
    int f1(long j) {
        static __stopwatch_reporter__<__stopwatch_accumulator__<> > sw;
        __stopwatch_reporter__<__stopwatch_accumulator__<> >::scoped_run _(sw);

        for ( long i = 0; i < j; ++i )
            std::sqrt( 123.456L );  // burn some time

        return 0;
    }
    int main()  {
        f1(100000);
        f1(200000);
        f1(300000);
        return 0;
    }

Will produce the following output

    3 times, sum=0.034s, min=0.006s, max=0.017s, mean=0.011s


[endsect]



[section How can I prefix each report with `BOOST_CURRENT_FUNCTION` function signature?]

You will need to give a specific format to your __stopclock__. You just need to concatenate your specific pattern to the default_format of the formatter.

For example, for a __stopclock_accumulator__ the default formatter is __stopwatch_accumulator_formatter__, you will need to do something like:

    static __stopclock_accumulator__<> acc(
        std::string(BOOST_CURRENT_FUNCTION) + ":  "
            + __stopwatch_accumulator_formatter__::default_format()
    );
    __stopclock_accumulator__<>::scoped_run _(acc);


Some of you will say that this is too long to type just to get the a report. You can of course define your own macro as

    #define REPORT_FUNCTION_ACCUMULATED_LIFETIME\
        static boost::stopwatches::__stopclock_accumulator__<> \
                BOOST_JOIN(_accumulator_, __LINE__)_
            ( std::string(BOOST_CURRENT_FUNCTION) + ":  " + \
                boost::stopwatches::__stopwatch_accumulator_formatter__::default_format() \
        ); \
        boost::stopwatches::__stopclock_accumulator__<>::scoped_run \
                BOOST_JOIN(_accumulator_run_, __LINE__) \
            (BOOST_JOIN(_accumulator_, __LINE__))


With this macro you will just have to write

    void foo()
    {
        REPORT_FUNCTION_ACCUMULATED_LIFETIME() ;
        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
        // ...
    }

[endsect]

[section How can I prefix each report with `__FILE__[__LINE__]` pattern?]

When you want to prefix with the `__FILE__[__LINE__]` pattern you can follow the same technique as described below:

    #define REPORT_LINE_ACCUMULATED_LIFETIME \
        static __stopclock_accumulator__<>
                BOOST_JOIN(_accumulator_, __LINE__) \
                ( std::string(__FILE__) + "[" + BOOST_STRINGIZE(__LINE__) + "] "
                    + __stopwatch_accumulator_formatter__::default_format() \
        ); \
        __stopclock_accumulator__<>::scoped_run \
                BOOST_JOIN(_accumulator_run_, __LINE__)
                (BOOST_JOIN(_accumulator_, __LINE__))

Now you can mix fcntion and line reports as follows

    void foo()
    {
        REPORT_FUNCTION_ACCUMULATED_LIFETIME;
        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
        {
            REPORT_LINE_ACCUMULATED_LIFETIME;
            boost::this_thread::sleep(boost::posix_time::milliseconds(200));
        }

    }

[endsect]

[section Can I use an stopclock accumulator which is not static?]

The typical example of stopclock_accumulator is to get statistical measures of the time a function takes for each one of its calls. You can also use __stopclock_accumulator__ to get statistical measures of the time a given loop takes for each one of its laps.

        __stopclock_accumulator__<> acc(
            std::string(__FILE__) + "[" + BOOST_STRINGIZE(__LINE__) + "] "
                + __stopwatch_accumulator_formatter__::default_format()
        );
        for (int i=0; i<N; i++) {
            __stopclock_accumulator__<>::scoped_run _(acc);
            // ...
        }


[endsect]

[section How can I suspend a stopwatch?]

    #include <boost/stopwatches/stopwatch.hpp>
    #include <cmath>
    #include <boost/thread.hpp>


    using namespace boost::stopwatches;
    double res;
    void f1(long j)
    {
        __stopwatch_reporter__<__stopwatch__<> >:: _(BOOST_STOPWATCHES_STOPWATCH_FUNCTION_FORMAT);
        for (long i =0; i< j; i+=1)
            res+=std::sqrt( res+123.456L+i );  // burn some time
        __stopwatch_reporter__<__stopwatch__<> >::scoped_suspend s(_);
        boost::this_thread::sleep(boost::posix_time::milliseconds(200));
    }

[endsect]

[section How to get specific statistics from stopwatches accumulator?]

There are two use cases that coul need to change the statistics associated to a stopwatches accumulator:

# We want to reduce the default reporting and we preffer to adapt the statistics to the reporting
# We want to report other statistics of the samples

For the first case we just need to change the accumulator_set and the format we want to get. Imagin we want to get only the count, sam and mean statistics, no need to calculate the min neither the max.

    using namespace boost::accumulators;

    typedef __stopwatch_reporter__<__stopwatch_accumulator__<__process_real_cpu_clock__,
                accumulator_set<__process_real_cpu_clock__::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean
                    >
                >
      > my_stopwatch_accumulator_reporter;

    int f1(long j)
    {
      static my_stopwatch_accumulator_reporter acc("%c times, sum=%ss, mean=%as\n");
      my_stopwatch_accumulator_reporter::scoped_run _(acc);

      for ( long i = 0; i < j; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }

But what would hapend if we haven't forced the format:

      static my_stopwatch_accumulator_reporter acc;
      my_stopwatch_accumulator_reporter::scoped_run _(acc);

Unfortunately there is no error at compile time. Fortunately, the run-time execution is not undefined and will return 0 for the missing statistics.


[endsect]

[endsect]


[section Formatters]
[section How can I make a specific formatter when the default do not satisfy my expectations]

Imagine then that we want to report the `tag::variance(lazy)`. We will need to include the specific accumulator file

    ...
    #include <boost/accumulators/statistics/variance.hpp>
    ...
    typedef __stopwatch_reporter__<__stopwatch_accumulator__<__process_real_cpu_clock__,
                accumulator_set<__process_real_cpu_clock__::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean,
                            tag::variance(lazy)
                    >
                >
    > my_stopwatch_accumulator_reporter;

But what happens if we add new statistics to the accumulator_set that are not taken in account by the default formatter? These statistics will simply be ignored. So we will need to define our own accumulator formatter.

    typedef __stopwatch_reporter__<__stopwatch_accumulator__<__process_real_cpu_clock__,
                accumulator_set<__process_real_cpu_clock__::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean,
                            tag::variance(lazy)
                    >
                >,
                my_stopwatch_accumulator_formatter
    > my_stopwatch_accumulator_reporter;

Next follow the definition of a formatter taking care of count, sum, mean and variance

    class my_stopwatch_accumulator_formatter {
    public:
        typedef std::string string_type;
        typedef char char_type;
        typedef std::ostream ostream_type;

        static ostream_type &  default_os() {return std::cout;}
        static const char_type* default_format() {
            return "%c times, sum=%ss, mean=%as, variance=%vs\n";
        }
        static int default_places() { return 3; }

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char_type* format,
                                int places, ostream_type & os, system::error_code & ec)
        {
            typedef typename Stopwatch::duration duration_t;
            typename Stopwatch::accumulator accumulator& acc = stopwatch_.accumulated();

            boost::io::ios_flags_saver ifs( os );
            os.setf( std::ios_base::fixed, std::ios_base::floatfield );
            boost::io::ios_precision_saver ips( os );
            os.precision( places );

            for ( ; *format; ++format ) {
                if ( *format != '%' || !*(format+1) || !std::strchr("acsv", *(format+1)) ) {
                    os << *format;
                } else {
                    ++format;
                    switch ( *format ) {
                    case 's':
                        os << boost::chrono::duration<double>(
                                duration_t(accumulators::sum(acc))).count();
                        break;
                    case 'a':
                        os << (accumulators::count(acc)>0)
                                ? boost::chrono::__duration__<double>(duration_t(
                                    duration_t::rep(accumulators::mean(acc)))).count()
                                : 0;
                        break;
                    case 'c':
                        os << accumulators::count(acc);
                        break;
                    case 'v':
                        os << (accumulators::count(acc)>0)
                                ? boost::chrono::__duration__<double>(duration_t(
                                    duration_t::rep(accumulators::variance(acc)))).count()
                                : 0;
                        break;
                    default:
                        assert(0 && "my_stopwatch_accumulator_formatter internal logic error");
                    }
                }
            }
        }
    };



[endsect]

[endsect]


[endsect]
[/===============]
[section Examples]
[/===============]



[section Reporting]



[/============================]
[section stopclock_example.cpp]

Here is the stopclock_example.cpp program supplied with the Boost Chrono library:

[/stopclock_example_cpp]

When the `stopclock<> t` object is created, it starts timing. When it is destroyed at the end of the program, its destructor stops the time counting and displays timing information on cout.

    #include <boost/stopwatches/stopclock.hpp>
    #include <cmath>

    int main()
    {
      boost::stopwatches::__stopclock__<> t;

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }

The output of this program run looks like this:

   wall 0.42 s, user 0.41 s + system 0.00 s = total cpu 0.41 s, (96.3%)

In other words, this program ran in 0.42 seconds as would be measured by a clock on the wall, the operating system charged it for 0.41 seconds of user CPU time and 0 seconds of system CPU time, the total of these two was 0.41, and that represented 96.3 percent of the wall clock time.

['See the source file [@../../example/stopclock_example.cpp example/stopclock_example.cpp]]

[endsect]


[/=============================]
[section stopclock_example2.cpp]

The stopclock_example2.cpp program is the same, except that it supplies additional constructor arguments from the command line:

    #include <boost/stopwatches/stopclock.hpp>
    #include <cmath>

    int main( int argc, char * argv[] )
    {
      const char * format = argc > 1 ? argv[1] : "%t cpu seconds\n";
      int          places = argc > 2 ? std::atoi( argv[2] ) : 2;

      boost::stopwatches::__stopclock__<> t( format, places );

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L ); // burn some time

      return 0;
    }

Here is the output for this program for several sets of command line arguments:

    stopclock_example2
    0.42 cpu seconds

    stopclock_example2 "%w wall clock seconds\n"
    0.41 wall clock seconds

    stopclock_example2 "%w wall clock seconds\n" 6
    0.421875 wall clock seconds

    stopclock_example2 "%t total CPU seconds\n" 3
    0.422 total CPU seconds

['See the source file [@../../example/stopclock_example2.cpp example/stopclock_example2.cpp]]

[endsect]

[/===============================================================]
[section time command]

    #include <boost/stopwatches/stopclock.hpp>
    #include <cstdlib>
    #include <string>
    #include <iostream>

    int main( int argc, char * argv[] )
    {
      if ( argc == 1 )
      {
        std::cout << "invoke: timex [-v] command [args...]\n"
          "  command will be executed and timings displayed\n"
          "  -v option causes command and args to be displayed\n";
        return 1;
      }

      std::string s;

      bool verbose = false;
      if ( argc > 1 && *argv[1] == '-' && *(argv[1]+1) == 'v' )
      {
        verbose = true;
        ++argv;
        --argc;
      }

      for ( int i = 1; i < argc; ++i )
      {
        if ( i > 1 ) s += ' ';
        s += argv[i];
      }

      if ( verbose )
        { std::cout << "command: \"" << s.c_str() << "\"\n"; }

      boost::stopwatches::__stopclock__<> t;

      return std::system( s.c_str() );
    }

['See the source file [@../../example/timex.cpp example/timex.cpp]]

[endsect]
[endsect]
[endsect]


[/
[/================================]
[section:ext_references External Resources]
[/================================]

[variablelist

[
    [[@http://www.open-std.org/jtc1/sc22/wg21 [*C++ Standards Committee's current Working Paper]]]
    [The most authoritative reference material for the library is the C++ Standards Committee's current Working Paper (WP).  20.9 Time utilities "time", 20.4 Compile-time rational arithmetic "ratio", 20.6.7 Other transformations "meta.trans.other"]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]]]
    [From Howard E. Hinnant, Walter E. Brown, Jeff Garland  and Marc Paterno. Is very informative and provides motivation for key design decisions]
]


[
    [[@http://home.roadrunner.com/~hinnant/issue_review/lwg-defects.html#934 [*LGW 934. duration is missing operator%]]]
    [From Terry Golubiewski. Is very informative and provides motivation for key design decisions]
]

[
    [[@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]]]
    [From Vicente Juan Botet Escriba.]
]

[
    [[@http://www.digitalmars.com/d/2.0/phobos/std_traits.html#CommonType D programming language -  CommonType trait]]
    [From Andrei Alexandrescu.]
]


]

[endsect]
]

[endsect]

[/=================]
[section:reference Reference ]
[/=================]



[/==================================================]
[section:stopwatches Stopwatches]
[/==================================================]
[/=============================================]
[section:stopwatches_hpp Header `<boost/stopwatches.hpp>`]
[/=============================================]

This file include all the stopwatches related files

    #include <boost/stopwatches/stopwatches.hpp>

[endsect]

[/=============================================]
[section:chrono_stopwatches_hpp Header `<boost/stopwatches/stopwatches.hpp>`]
[/=============================================]

This file include all the stopwatches related files

    #include <boost/stopwatches/scoped_stopclock.hpp>
    #include <boost/stopwatches/process_cpu_clocks.hpp>
    #include <boost/stopwatches/stopclock.hpp>
    #include <boost/stopwatches/stopclock_accumulator.hpp>
    #include <boost/stopwatches/stopwatch.hpp>
    #include <boost/stopwatches/stopwatch_accumulator.hpp>
    #include <boost/stopwatches/stopwatch_accumulator_formatter.hpp>
    #include <boost/stopwatches/stopwatch_accumulator_time_formatter.hpp>
    #include <boost/stopwatches/stopwatch_formatter.hpp>
    #include <boost/stopwatches/stopwatch_reporter.hpp>
    #include <boost/stopwatches/stopwatch_scoped.hpp>
    #include <boost/stopwatches/time_formatter.hpp>
    #include <boost/stopwatches/t24_hours.hpp>
    #include <boost/stopwatches/t24_hours_formatter.hpp>

[endsect]

[section:stopwatch_req `Stopwatch` Requirements]

A Stopwatch measure the amount of time elapsed from a start point in time to the stop point time or the accumulation of them. Stopwatches can in addition be restarted, suspended and resumed.

A Stopwatch must meet the requirements in the following table. In this table `S`, `S1` and `S2` denote stopwatches types. `s` is an instance of `S`.

[table Stopwatch Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`S::clock`]        [A model of __Clock__.]  [The clock associated to this Stopwatch.]]
    [[`S::duration`]        [`S::clock::duration`]  [The __duration__ type of the `clock`.]]
    [[`S::time_point`]        [`S::clock::time_point`]  [The __time_point__ type of the `clock`.]]
    [[`S::scoped_run`]        [`stopwatch_runner<stopwatch<Clock> >`]  [RAI which `start`/`stop` the `stopwatch`.]]
    [[`S::scoped_suspend`]        [`stopwatch_suspender<stopwatch<Clock> >`]  [RAI which `suspend`/`resume` the `stopwatch`.]]
    [[`S::scoped_resume`]        [`stopwatch_resumer<stopwatch<Clock> >`]  [RAI which `resume`/`suspend` the `stopwatch`.]]
    [[`s.start()`]        [`S::time_point`]  [starts a Stopwatch.]]
    [[`s.restart()`]        [`std::pair<S::duration,S::time_point>`]  [restarts a Stopwatch.]]
    [[`s.stop()`]        [`S::duration`]  [stops a Stopwatch.]]
    [[`s.resume()`]        [`S::time_point`]  [resume a Stopwatch.]]
    [[`s.suspend()`]        [`S::duration`]  [suspends a Stopwatch.]]
    [[`s.elapsed()`]        [`S::duration`]  [the elapsed time while the Stopwatch was running.]]
]


[section:stopwatch_start Member Function `start()`]

    time_point start( system::error_code & ec = system::throws );

[*Effect:] Starts running the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]
[section:stopwatch_stop Member Function `stop()`]

    duration stop( system::error_code & ec = system::throws );

[*Effect:] Stops running the stopwatch.

[*Returns:] The cummulated elapsed time.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]
[section:stopwatch_suspend Member Function `suspend()`]

    duration suspend( system::error_code & ec = system::throws );

[*Effect:] Suspends the stopwatch.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]
[section:stopwatch_resume Member Function `resume()`]

    time_point resume( system::error_code & ec = system::throws );

[*Effect:] Resumes the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]

[section:stopwatch_restart Member Function `restart()`]

    time_point restart( system::error_code & ec = system::throws );

[*Effect:] `stop`/`start` the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]

Models of `Stopwatch`:

* __stopwatch__
* __stopwatch_accumulator__

[endsect]


[/==================================================]
[section:lightweight_stopwatch_hpp Header `<boost/stopwatches/lightweight_stopwatch.hpp>`]
[/==================================================]


    namespace boost { namespace stopwatches  {
        struct dont_start_t;
        static const dont_start_t dont_start;

        template <class Clock=high_resolution_clock,
                typename Features=void,
                typename Weight=void
        > class __lightweight_stopwatch__;

        typedef <see above> system_lightweight_stopwatch;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_lightweight_stopwatch;
        #endif
        typedef <see above> high_resolution_lightweight_stopwatch;
    }}

[section:dont_start_t Class `dont_start_t`]

Structure used to don't start a `lightweight_stopwatch` at construction time.

        struct dont_start_t;
        static const dont_start_t dont_start;

[endsect]

[section:lightweight_stopwatch Template Class `lightweight_stopwatch<>`]

`lightweight_stopwatch<>` is a model of a __lightweight_stopwatch_concept__.

Knowing how long a part of a program takes to execute is useful in both test and production environments.
A __lightweight_stopwatch__ object measures elapsed time. It is recommended to use it with clocks that measure wall clock rather than CPU time since the intended use is performance measurement on systems where total elapsed time is more important than just process or CPU time.

The maximum measurable elapsed time depends on the Clock parameter. The accuracy of timings depends on the
accuracy of timing information provided the Clock, and this coudl varies a great deal from one clock to another.

        template <class Clock, typename Features, typename Weight> 
        class lightweight_stopwatch {
        public:
            typedef Clock                       clock;
            typedef typename Clock::duration    duration;
            typedef typename Clock::time_point  time_point;
            typedef <see below>                 storage;

            explicit lightweight_stopwatch( storage& st, system::error_code & ec = system::throws );
            lightweight_stopwatch( storage& st, const dont_start_t& t );

            ~lightweight_stopwatch();

            time_point start( system::error_code & ec = system::throws );
            duration stop( system::error_code & ec = system::throws );
            std::pair<duration,time_point> restart( system::error_code & ec = system::throws );

            duration suspend( system::error_code & ec = system::throws );
            time_point resume( system::error_code & ec = system::throws );

            duration elapsed( system::error_code & ec = system::throws );

            time_point now( system::error_code & ec = system::throws );

            void reset( system::error_code & ec = system::throws );

            storage& get_storage( );

            duration lifetime( system::error_code & ec = system::throws );

            typedef lightweight_stopwatch_runner<lightweight_stopwatch<Clock> > scoped_run;
            typedef lightweight_stopwatch_suspender<lightweight_stopwatch<Clock> > scoped_suspend;
            typedef lightweight_stopwatch_resumer<lightweight_stopwatch<Clock> > scoped_resume;
            typedef lightweight_stopwatch_reporter<lightweight_stopwatch<Clock> > reporter;

        };


`storage` is either `Clock::duration` if Features and Weight are void and `accumulators::accumulator_set<typename Clock::duration::rep, Features, Weight>` otherwise.
    
[section:c1 Constructor `lightweight_stopwatch( storage&, system::error_code &)`]

            explicit lightweight_stopwatch( storage& st, system::error_code & ec = system::throws );

[*Effect:] constructs and starts the lightweight_stopwatch.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]

[section:c2 Constructor `lightweight_stopwatch( storage&, dont_start_t &)`]

            explicit lightweight_stopwatch( storage& st, const dont_start_t& t );

[*Effect:] constructs the lightweight_stopwatch without starting it.

[*Throw:] Nothing.

[endsect]


[section:lightweight_stopwatch_elapsed Member Function `elapsed()`]

            duration elapsed(system::error_code & ec = system::throws) const;

[*Returns:] the cumulated elapsed time.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]


[section:stopwatch_accumulator_accumulated Member Function `accumulated()`]

            storage& get_storage();

[*Returns:] the assocaited storage reference.

[*Throw:] Nothing.

[endsect]


[section:stopwatch_accumulator_reset Member Function `reset()`]

    void reset( );

[*Effect:] Stop the lightweight_stopwatch and reinit the storage.

[*Throw:] Nothing.

[endsect]

[endsect]

[endsect]


[/==================================================]
[section:stopwatch_hpp Header `<boost/stopwatches/stopwatch.hpp>`]
[/==================================================]


    namespace boost { namespace stopwatches  {
        template <class Clock=high_resolution_clock> class __stopwatch__;

        template <class Clock>
        struct stopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef stopwatch_formatter type;
        };

        template <class Clock>
        struct wstopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef wstopwatch_formatter type;
        };

        typedef <see above> system_stopwatch;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_stopwatch;
        #endif
        typedef <see above> high_resolution_stopwatch;
    }}


[section:stopwatch Template Class `stopwatch<>`]

`stopwatch<>` is a model of a __stopwatch_concept__.

Knowing how long a part of a program takes to execute is useful in both test and production environments.
A __stopwatch__ object measures elapsed time. It is recommended to use it with clocks that measure wall clock rather than CPU time since the intended use is performance measurement on systems where total elapsed time is more important than just process or CPU time.

The maximum measurable elapsed time depends on the Clock parameter. The accuracy of timings depends on the
accuracy of timing information provided the Clock, and this coudl varies a great deal from one clock to another.

    template <class Clock>
    class stopwatch : private base_from_member<typename Clock::duration>, public lightweight_stopwatch<Clock>
    {
    public:
        explicit stopwatch( system::error_code & ec = system::throws  );
        explicit stopwatch( const dont_start_t& t );
        
    };

[section:c1 Constructor `stopwatch( system::error_code &)`]

            explicit stopwatch( system::error_code & ec = system::throws );

[*Effect:] constructs and starts the stopwatch.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `system::throws`

[endsect]

[section:c2 Constructor `stopwatch( dont_start_t &)`]

            explicit stopwatch( const dont_start_t& t );

[*Effect:] constructs the stopwatch without starting it.

[*Throw:] Nothing.

[endsect]

[endsect]

[section:spec `stopwatch_reporter_default_formatter` Specialization]

The `stopwatch_reporter_default_formatter` of a `stopwatch<Clock>` is a `stopwatch_formatter`.

        template <class Clock>
        struct stopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef stopwatch_formatter type;
        };

The `wstopwatch_reporter_default_formatter` of a `stopwatch<Clock>` is a `wstopwatch_formatter`.

        template <class Clock>
        struct wstopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef wstopwatch_formatter type;
        };

[endsect]

[section:stopwatch_typedefs `stopwatch` useful typedefs]

The library provides stopwatch short cuts for all the models of __Clock__, replacing clock by stopwatch.

        typedef boost::stopwatches::stopwatch< boost::chrono::system_clock > 
            system_stopwatch;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::stopwatches::stopwatch< boost::chrono::monotonic_clock > 
            monotonic_stopwatch;
        #endif
        typedef boost::stopwatches::stopwatch< boost::chrono::high_resolution_clock > 
            high_resolution_stopwatch;

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_accumulator_hpp Header `<boost/stopwatches/stopwatch_accumulator.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <class Clock, 
                    typename Features=accumulators::features<
                        accumulators::tag::count,
                        accumulators::tag::sum,
                        accumulators::tag::min,
                        accumulators::tag::max,
                        accumulators::tag::mean >,
                    typename Weight=void
        > class __stopwatch_accumulator__;

        template <class Clock, class Accumulator>
        struct stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef stopwatch_accumulator_formatter type;
        };

        template <class Clock, class Accumulator>
        struct wstopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef wstopwatch_accumulator_formatter type;
        };

        typedef <see below> system_stopwatch_accumulator;
    #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see below> monotonic_stopwatch_accumulator;
    #endif
        typedef <see below> high_resolution_stopwatch_accumulator;

    }}


[section:stopwatch_accumulator Template Class `stopwatch_accumulator<>`]

A `stopwatch_accumulator<>` is a model of a __stopwatch_concept__ that allows to accumulate the time in several times instead of at once as it is the case of the class __stopwatch__`<>`.

    template <class Clock, typename Features, typename Weight>
    class stopwatch_accumulator
        : private base_from_member<typename accumulators::accumulator_set<typename Clock::duration::rep, Features, Weight> >,
          public lightweight_stopwatch<Clock,Features,Weight> 
    {
    public:
        stopwatch_accumulator( );
    };

[section:stopwatch_accumulator_c Constructor `stopwatch_accumulator()`]

    stopwatch_accumulator();

[*Effect:] Initialize the elapsed duration and the times counter to 0.

[endsect]

[endsect]

[section:spec `stopwatch_reporter_default_formatter` Specialization]

The `stopwatch_reporter_default_formatter` of a `stopwatch_accumulator<Clock>` is a `stopwatch_accumulator_formatter`.

        template <class Clock, class Accumulator>
        struct stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef stopwatch_accumulator_formatter type;
        };

The `wstopwatch_reporter_default_formatter` of a `stopwatch_accumulator<Clock>` is a `wstopwatch_accumulator_formatter`.

        template <class Clock, class Accumulator>
        struct wstopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef wstopwatch_accumulator_formatter type;
        };

[endsect]


[section:stopwatch_accumulator_typedefs `stopwatch_accumulator` useful typedefs]

The library provides stopwatch_accumulator shortcuts for all the models of __Clock__, replacing clock by stopwatch_accumulator.

    typedef boost::stopwatches::stopwatch_accumulator< boost::chrono::system_clock > 
        system_stopwatch_accumulator;
    #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
    typedef boost::stopwatches::stopwatch_accumulator< boost::chrono::monotonic_clock > 
        monotonic_stopwatch_accumulator;
    #endif
    typedef boost::stopwatches::stopwatch_accumulator< boost::chrono::high_resolution_clock > 
        high_resolution_stopwatch_accumulator;

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_scoped_hpp Header `<boost/stopwatches/stopwatch_scoped.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <class Stopwatch> class stopwatch_runner;
        template <class Stopwatch> class stopwatch_suspender;
        template <class Stopwatch> class stopwatch_resumer;
    }}

Boost.Chrono provides some helper classes ensuring pairwised operations (start/stop, suspend/resume, resule/suspend).

[section:stopwatch_runner Template Class `stopwatch_runner<>`]

This helper class ensures that the start/stop are pairwised. Start the associated accumulator at construction time, and stop it at destruction time.

    template <class Stopwatch> class stopwatch_runner {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_runner(stopwatch & a, system::error_code & ec = system::throws);
        ~stopwatch_runner();
        stopwatch_runner() = delete;
        stopwatch_runner(const stopwatch_runner&) = delete;
        stopwatch_runner& operator=(const stopwatch_runner&) = delete;
    };

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...
    }

[endsect]
[section:stopwatch_suspender Template Class `stopwatch_suspender<>`]

This helper class ensures that the suspend/resume are pairwised. Suspend the associated accumulator at construction time, and resume it at destruction time.

    template <class Stopwatch> class stopwatch_suspender {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_suspender(stopwatch & a, system::error_code & ec = system::throws);
        ~stopwatch_suspender();
        stopwatch_suspender() = delete;
        stopwatch_suspender(const stopwatch_suspender&) = delete;
        stopwatch_suspender& operator=(const stopwatch_suspender&) = delete;
    }

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...

         // call to some function we don't want to measure
         {
            stopwatch_suspender<stopwatch_accumulator<> > _(t);
            external_function();
         }
    }

[endsect]

[section:stopwatch_resumer Template Class `stopwatch_resumer<>`]

This helper class ensures that the resume/suspend are pairwised. Resume the associated accumulator at construction time, and suspecd it at destruction time.

    template <class Stopwatch> class stopwatch_resumer {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_resumer(stopwatch & a, system::error_code & ec = system::throws);
        ~stopwatch_resumer();
        stopwatch_resumer() = delete;
        stopwatch_resumer(const stopwatch_resumer&) = delete;
        stopwatch_resumer& operator=(const stopwatch_resumer&) = delete;
    }

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...

         // call to some function we don't want to measure
         {
            stopwatch_suspender<stopwatch_accumulator<> > _(t);

            {
                stopwatch_resumer<stopwatch_accumulator<> > _(t);

            }
         }
    }

[endsect]

[endsect]

[endsect]
[section:reporters Stopwatch Reporters]
[section:formatter_req `Formatter` Requirements]

A Formatter outputs on a given ostream a formatted string combining informations from a Stopwatch and the format and the double precision.

A Formatter must meet the requirements in the following Table.

In this table `F`  denote a Formatter type, `S` is a Stopwatch and `s` is an instance of `S`, `f` is `const char *` , `p` is and int, and `os` is a `std::ostream`, ec is a system::error_code

[table Formatter Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`F::default_os()`]        [std::otream&]  [The output stream.]]
    [[`F::default_places()`]        [`std::size_t`]  [The precision when displaying a double.]]
    [[`F::default_format()`]        [`const char*`]  [The default format.]]
    [[`F::show_time(s,f,p,os,ec)`]        [`S::time_point`]  [outputs on `os` a formatted string combining informations from the Stopwatch `s`, the format `f` and the double precision `p`.]]
]


Models of `Formatter`:

* __basic_stopwatch_formatter__
* __basic_stopwatch_accumulator_formatter__
* __basic_24_hours_formatter__

[endsect]

[section `Formatter` related traits]

        template <class Stopwatch>
        struct stopwatch_reporter_default_formatter {
            typedef <see below> type;
        };

The nested typedef `type` defines the default formatter used by the __stopwatch_reporter__ class when the `Formatter` parameter is not explicit.

[endsect]

[/==================================================]
[section:stopwatch_reporter_hpp Header `<boost/stopwatches/stopwatch_reporter.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <class Stopwatch, class Formatter>
        class basic_stopwatch_reporter;

        template <class Stopwatch>
        struct stopwatch_reporter_default_formatter;

        template <class Stopwatch, 
                  class Formatter=typename stopwatch_reporter_default_formatter<Stopwatch>::type>
        class __stopwatch_reporter__;
        
        template <class Stopwatch>
        struct wstopwatch_reporter_default_formatter;

        template <class Stopwatch, 
                  class Formatter=typename wstopwatch_reporter_default_formatter<Stopwatch>::type>
        class wstopwatch_reporter;
    }}

[section:basic_stopwatch_reporter Template Class `basic_stopwatch_reporter<>`]

class `basic_stopwatch_reporter` provides everything a `Stopwatch` provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class basic_stopwatch_reporter : public Stopwatch {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit basic_stopwatch_reporter( system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( const std::string & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( int places,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = system::throws );

        explicit basic_stopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = system::throws );

        ~basic_stopwatch_reporter();

        void report( system::error_code & ec = system::throws );
        bool reported() const;


        typedef stopwatch_runner<basic_stopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<basic_stopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<basic_stopwatch_reporter<Stopwatch> > scoped_resume;
    };

[endsect]

[section:stopwatch_reporter Template Class `stopwatch_reporter<>`]

class __stopwatch_reporter__ provides a everything a `Stopwatch` provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class stopwatch_reporter : public basic_stopwatch_reporter<Stopwatch,Formatter> {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit stopwatch_reporter( system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( const std::string & format,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( int places,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = system::throws );

        explicit stopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = system::throws );
        explicit stopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = system::throws );

        ~stopwatch_reporter();

        void report( system::error_code & ec = system::throws );
        bool reported() const;


        typedef stopwatch_runner<stopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<stopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<stopwatch_reporter<Stopwatch> > scoped_resume;
    };

Usage

    void f1()
    {
        typedef stopwatch_reporter<stopwatch_accumulator<> > accumulator;
        static accumulator t;
        accumulator::scoped_run _(t);
        // ...

        // call to some function we don't want to measure
        {
            accumulator::scoped_suspend _(t);
            external_function();
        }
    }

[endsect]

[section:wstopwatch_reporter Template Class `wstopwatch_reporter<>`]

class `wstopwatch_reporter` provides a everything a `Stopwatch` provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class wstopwatch_reporter : public basic_wstopwatch_reporter<Stopwatch,Formatter> {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit wstopwatch_reporter( system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( const std::string & format,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( int places,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = system::throws );

        explicit wstopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = system::throws );
        explicit wstopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = system::throws );

        ~wstopwatch_reporter();

        void report( system::error_code & ec = system::throws );
        bool reported() const;


        typedef stopwatch_runner<wstopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<wstopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<wstopwatch_reporter<Stopwatch> > scoped_resume;
    };

Usage

    void f1()
    {
        typedef wstopwatch_reporter<stopwatch_accumulator<> > accumulator;
        static accumulator t;
        accumulator::scoped_run _(t);
        // ...

        // call to some function we don't want to measure
        {
            accumulator::scoped_suspend _(t);
            external_function();
        }
    }

[endsect]

[endsect]

[/==================================================]
[section:stopclock_hpp Header `<boost/stopwatches/stopclock.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches {
        template < class Clock, class Formatter > class basic_stopclock;
        template < class Clock, class Formatter > class __stopclock__;
        template < class Clock, class Formatter > class wstopclock;

        typedef <see above> system_stopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_stopclock;
        #endif
        typedef <see above> high_resolution_stopclock;
        typedef <see above> process_real_cpu_stopclock;
        typedef <see above> process_user_cpu_stopclock;
        typedef <see above> process_system_cpu_stopclock;

        typedef <see above> system_wstopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_wstopclock;
        #endif
        typedef <see above> high_resolution_wstopclock;
        typedef <see above> process_real_cpu_wstopclock;
        typedef <see above> process_user_cpu_wstopclock;
        typedef <see above> process_system_cpu_wstopclock;
    }}

[section:basic_stopclock Template Class `basic_stopclock<>`]

`basic_stopclock<Clock,Formatter>` template class is a shortcut of `basic_stopwatch_reporter<stopwatch<Clock,Formatter>>`

    template< class Clock, class Formatter>
    class basic_stopclock : public basic_stopwatch_reporter<stopwatch<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit basic_stopclock( system::error_code & ec = system::throws );
        explicit basic_stopclock( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock( int places,
                    system::error_code & ec = system::throws );

        basic_stopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        basic_stopclock( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        basic_stopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[section:stopclock Template Class `stopclock<>`]

A stopclock is a stopwatch with the ability to report elapsed time on an output stream.
`stopclock<Clock>` template class is a shortcut of `basic_stopclock<Clock, typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type>` with a specific default formatter.

    template
        < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class stopclock : public basic_stopclock<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit stopclock( system::error_code & ec = system::throws );
        explicit stopclock( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit stopclock( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit stopclock( int places,
                    system::error_code & ec = system::throws );

        stopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        stopclock( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        stopclock( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        stopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:stopclock_typedefs `stopclock` useful typedefs]

The library provides stopclock shortcuts for all the models of __Clock__, replacing clock by stopclock.

        typedef boost::stopwatches::stopclock< boost::chrono::system_clock > 
            system_stopwatch_stopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::stopwatches::stopclock< boost::chrono::monotonic_clock > 
            monotonic_stopwatch_stopclock;
        #endif
        typedef boost::stopwatches::stopclock< boost::chrono::high_resolution_clock > 
            high_resolution_stopclock;
        typedef boost::stopwatches::stopclock< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_stopclock;
        typedef boost::stopwatches::stopclock< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_stopclock;
        typedef boost::stopwatches::stopclock< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_stopclock;

[endsect]

[section:wstopclock Template Class `wstopclock<>`]

`wstopclock<Clock>` template class is a shortcut of `basic_wstopclock<Clock, typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type>` with a specific default formatter.

    template
        < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class wstopclock : public basic_wstopclock<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit wstopclock( system::error_code & ec = system::throws );
        explicit wstopclock( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit wstopclock( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit wstopclock( int places,
                    system::error_code & ec = system::throws );

        wstopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        wstopclock( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        wstopclock( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        wstopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:wstopclock_typedefs `wstopclock` useful typedefs]

The library provides wstopclock shortcuts for all the models of __Clock__, replacing clock by wstopclock.

        typedef boost::stopwatches::wstopclock< boost::chrono::system_clock > 
            system_wstopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::stopwatches::wstopclock< boost::chrono::monotonic_clock > 
            monotonic_wstopclock;
        #endif
        typedef boost::stopwatches::wstopclock< boost::chrono::high_resolution_clock > 
            high_resolution_wstopclock;
        typedef boost::stopwatches::wstopclock< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_wstopclock;
        typedef boost::stopwatches::wstopclock< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_wstopclock;
        typedef boost::stopwatches::wstopclock< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_wstopclock;

[endsect]


[endsect]

[/==================================================]
[section:stopclock_accumulator_hpp Header `<boost/stopwatches/stopclock_accumulator.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches {
        template < class Clock, class Formatter >
        class basic_stopclock_accumulator;
        template < class Clock, class Formatter >
        class __stopclock_accumulator__;
        template < class Clock, class Formatter >
        class wstopclock_accumulator;

        typedef <see above> system_stopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_stopclock_accumulator;
        #endif
        typedef <see above> high_resolution_stopclock_accumulator;
        typedef <see above> process_real_cpu_stopclock_accumulator;
        typedef <see above> process_user_cpu_stopclock_accumulator;
        typedef <see above> process_system_cpu_stopclock_accumulator;

        typedef <see above> system_wstopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef <see above> monotonic_wstopclock_accumulator;
        #endif
        typedef <see above> high_resolution_wstopclock_accumulator;
        typedef <see above> process_real_cpu_wstopclock_accumulator;
        typedef <see above> process_user_cpu_wstopclock_accumulator;
        typedef <see above> process_system_cpu_wstopclock_accumulator;
    }}

[section:basic_stopclock_accumulator Template Class `basic_stopclock_accumulator<>`]

`basic_stopclock_accumulator<Clock>` template class is a shortcut of `basic_stopwatch_reporter<stopwatch_accumulator<Clock>, typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type>`

    template
        < class Clock=high_resolution_clock
        , class Formatter=
            typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class basic_stopclock_accumulator
        : public basic_stopwatch_reporter<stopwatch_accumulator<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit basic_stopclock_accumulator( system::error_code & ec = system::throws );
        explicit basic_stopclock_accumulator( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock_accumulator( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit basic_stopclock_accumulator( int places,
                    system::error_code & ec = system::throws );

        basic_stopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        basic_stopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        basic_stopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[section:stopclock_accumulator Template Class `stopclock_accumulator<>`]

`stopclock_accumulator<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>` with a specific formatter.

    template
        < class Clock=high_resolution_clock
        , class Formatter=
            typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class stopclock_accumulator
        : public basic_stopclock_accumulator<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit stopclock_accumulator( system::error_code & ec = system::throws );
        explicit stopclock_accumulator( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit stopclock_accumulator( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit stopclock_accumulator( int places,
                    system::error_code & ec = system::throws );

        stopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        stopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        stopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:stopclock_accumulator_typedefs `stopclock_accumulator` useful typedefs]

The library provides stopclock_accumulator shortcuts for all the models of __Clock__, replacing clock by stopclock_accumulator.


        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::system_clock > 
            system_stopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::monotonic_clock > 
            monotonic_stopclock_accumulator;
        #endif
        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::high_resolution_clock > 
            high_resolution_stopclock_accumulator;
        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_stopclock_accumulator;
        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_stopclock_accumulator;
        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_stopclock_accumulator;

[endsect]
[section:wstopclock_accumulator Template Class `wstopclock_accumulator<>`]

`wstopclock_accumulator<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>` with a specific formatter.

    template
        < class Clock=high_resolution_clock
        , class Formatter=
            typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class wstopclock_accumulator
        : public basic_wstopclock_accumulator<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit wstopclock_accumulator( system::error_code & ec = system::throws );
        explicit wstopclock_accumulator( ostream_type & os,
                    system::error_code & ec = system::throws );
        explicit wstopclock_accumulator( const string_type & format,
                    system::error_code & ec = system::throws );
        explicit wstopclock_accumulator( int places,
                    system::error_code & ec = system::throws );

        wstopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = system::throws );

        wstopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = system::throws );
        wstopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = system::throws );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:wstopclock_accumulator_typedefs `wstopclock_accumulator` useful typedefs]

The library provides wstopclock_accumulator shortcuts for all the models of __Clock__, replacing clock by wstopclock_accumulator.

        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::system_clock > 
            system_wstopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_MONOTONIC
        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::monotonic_clock > 
            monotonic_wstopclock_accumulator;
        #endif
        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::high_resolution_clock > 
            high_resolution_wstopclock_accumulator;
        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_wstopclock_accumulator;
        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_wstopclock_accumulator;
        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_wstopclock_accumulator;

[endsect]
[endsect]

[/==================================================]
[section:scoped_stopclock_hpp Header `<boost/stopwatches/scoped_stopclock.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches {
        template < class Clock, class Formatter > class scoped_stopclock;
    }}

[section:scoped_stopclock Template Class `scoped_stopclock<>`]

`scoped_stopclock<>`is like a `stopclock<>` but that in addition will output a scoped trace. At construction time it will output

    {{{ <string>

and at destruction time

    }}} <string> <output of stopwatch_reporter>

A typical ussage of this class is

    int f1(long j)
    {
      scoped_stopclock<> _(BOOST_CURRENT_FUNCTION);

      for ( long i = 0; i < j; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }


[heading Synopsis]

    template < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class scoped_stopclock
        : public stopwatch_reporter<stopwatch<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit scoped_stopclock( const std::string& func,
                    system::error_code & ec = system::throws );
        scoped_stopclock( const std::string& func, ostream_type & os,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, const string_type & format,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, int places,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os,
                    const string_type & format,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, const string_type & format,
                    int places, system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os, int places,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, int places,
                    const string_type & format, system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os,
                    const string_type & format, int places,
                    system::error_code & ec = system::throws );

        scoped_stopclock( const std::string& func, ostream_type & os, int places,
                    const string_type & format, system::error_code & ec = system::throws );

        ~scoped_stopclock();

        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[endsect]
[endsect]
[section:formatters Stopwatch Formatters]

[/==================================================]
[section:stopwatch_formatter_hpp Header `<boost/stopwatches/stopwatch_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_stopwatch_formatter;

        typedef basic_stopwatch_formatter<char> stopwatch_formatter;
        typedef basic_stopwatch_formatter<wchar_t> wstopwatch_formatter;
    }}

[section:basic_stopwatch_formatter Template Class `basic_stopwatch_formatter<>`]

`stopwatch_formatter` is a model of __Formatter__.

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    >
    class basic_stopwatch_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template < class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, 
                               std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%ts\\n", where

* `%d` : the result of elapsed() when the reporting is done.

The time is given using the suffix "s" following the System International d'Unites Std.

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_accumulator_formatter_hpp Header `<boost/stopwatches/stopwatch_accumulator_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        > basic_stopwatch_accumulator_formatter;
        typedef basic_stopwatch_accumulator_formatter<char> stopwatch_accumulator_formatter;
        typedef basic_stopwatch_accumulator_formatter<wchar_t> wstopwatch_accumulator_formatter;
    }}

[section:basic_stopwatch_accumulator_formatter Template Class `basic_stopwatch_accumulator_formatter<>`]

`basic_stopwatch_accumulator_formatter` is a model of __Formatter__

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    class basic_stopwatch_accumulator_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, 
                               std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%c times, sum=%ss, min=%ms, max=%Ms, mean=%as, frequency=%fHz, lifetime=%ls, percentage=%p\%\\n", where

* `%c` : the counter of the number of times the pair srat/stop has been called.
* `%s` : the sum of the samples of elapsed time between the call to start/stop.
* `%m` : the min of the samples of elapsed time between the call to start/stop.
* `%M` : the max of the samples of elapsed time between the call to start/stop.
* `%a` : the mean of the samples of elapsed time between the call to start/stop.
* `%f` : the frequency of calls to start.
* `%l` : the lifetime of the stopwatch_accumulator.
* `%p` : the percentage of time spent by this stopwatch respect to its lifetime.

The time is given using the suffix "s", the frequency is given using the suffix "Hz", both following the System International d'Unites Std.

[endsect]

[section:typedefs `basic_stopwatch_accumulator_formatter` useful typedefs]

The library provides basic_stopwatch_accumulator_formatter shortcuts for char and wchar_t.

        typedef basic_stopwatch_accumulator_formatter<char> 
            stopwatch_accumulator_formatter;
        typedef basic_stopwatch_accumulator_formatter<wchar_t> 
            wstopwatch_accumulator_formatter;


[endsect]
[endsect]
[/==================================================================]
[section:time_formatter_hpp Header `<boost/stopwatches/time_formatter.hpp>`]
[/==================================================================]

    namespace boost { namespace stopwatches {

        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_time_formatter;

        typedef basic_time_formatter<char> time_formatter;
        typedef basic_time_formatter<wchar_t> wtime_formatter;

        template <>
        struct stopwatch_reporter_default_formatter<stopwatch<process_cpu_clock> > {
            typedef time_formatter type;
        };

    } }

[section:basic_time_formatter Template Class `basic_time_formatter<>`]

`basic_time_formatter` is a model of __Formatter__.

    template <typename CharT, typename Traits, class Alloc>
    class basic_time_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_
            , const char * format, int places, std::ostream & os
            , system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "nreal %rs, cpu %cs (%p%), user %us, system %ss\\n", where

* `%r` : real process clock
* `%u` : user process clock
* `%s` : system process clock
* `%c` : user+system process clock
* `%p` : percentage (user+system)/real process clock

All the units are given using the suffix "s" following the System International d'Unites Std.

[endsect]

[section:typedefs `basic_time_formatter` useful typedefs]

The library provides basic_time_formatter shortcuts for char and wchar_t.

        typedef basic_time_formatter<char> time_formatter;
        typedef basic_time_formatter<wchar_t> wtime_formatter;

[endsect]

[section:spec `stopwatch_reporter_default_formatter` Specialization]

        template <>
        struct stopwatch_reporter_default_formatter<stopwatch<process_cpu_clock> > {
            typedef time_formatter type;
        };

[endsect]


[endsect]

[/==================================================]
[section:stopwatch_accumulator_time_formatter_hpp Header `<boost/stopwatches/stopwatch_accumulator_time_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        > basic_stopwatch_accumulator_time_formatter;
        typedef basic_stopwatch_accumulator_time_formatter<char> stopwatch_accumulator_time_formatter;
        typedef basic_stopwatch_accumulator_time_formatter<wchar_t> wstopwatch_accumulator_time_formatter;
    }}

[section:basic_stopwatch_accumulator_time_formatter Template Class `basic_stopwatch_accumulator_time_formatter<>`]

`basic_stopwatch_accumulator_time_formatter` is a model of __Formatter__

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    class basic_stopwatch_accumulator_time_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, 
                               std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%c times, sum=%s, min=%m, max=%M, mean=%a, frequency=%fHz, lifetime=%ls, percentage=%p\%\\n|real %rs, cpu %cs (%p%), user %us, system %ss", where

The part before the '|' corresponds to the accumulator format and the part after corresponds to the times format, which will be used for the sum, max, min and mean statistics.

* `%c` : the counter of the number of times the pair srat/stop has been called.
* `%s` : the sum of the samples of elapsed time between the call to start/stop.
* `%m` : the min of the samples of elapsed time between the call to start/stop.
* `%M` : the max of the samples of elapsed time between the call to start/stop.
* `%a` : the mean of the samples of elapsed time between the call to start/stop.
* `%f` : the frequency of calls to start.
* `%l` : the lifetime of the stopwatch_accumulator.
* `%p` : the percentage of time spent by this stopwatch respect to its lifetime.

* `%r` : real process clock
* `%u` : user process clock
* `%s` : system process clock
* `%c` : user+system process clock
* `%p` : percentage (user+system)/real process clock

The time is given using the suffix "s", the frequency is given using the suffix "Hz", both following the System International d'Unites Std.


[endsect]

[section:typedefs `basic_stopwatch_accumulator_time_formatter` useful typedefs]

The library provides basic_stopwatch_accumulator_time_formatter shortcuts for char and wchar_t.

        typedef basic_stopwatch_accumulator_time_formatter<char> 
            stopwatch_accumulator_time_formatter;
        typedef basic_stopwatch_accumulator_time_formatter<wchar_t> 
            wstopwatch_accumulator_time_formatter;


[endsect]
[endsect]

[/==================================================]
[section:t24_hours_hpp Header `<boost/stopwatches/t24_hours.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches {
        class t24_hours;
    }}

[section:t24_hours Class `t24_hours`]

`t24_hours` helper class decompose a duration in days, hours, minutes, seconds and nanoseconds. It can be used through its static functions or creating an instance and using its fields.

    class t24_hours {
    public:
        typedef boost::chrono::duration<boost::int_least32_t, __ratio__<24*3600> > days;
        typedef boost::chrono::hours hours;
        typedef boost::chrono::minutes minutes;
        typedef boost::chrono::seconds seconds;
        typedef boost::chrono::nanoseconds nanoseconds;
        
        template <class Rep, class Period>
        static days get_days(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static hours get_hours(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static minutes get_minutes(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static seconds get_seconds(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static nanoseconds get_nanoseconds(const boost::chrono::duration<Rep, Period>& d);

        days days_;
        hours hours_;
        minutes minutes_;
        seconds seconds_;
        nanoseconds nanoseconds_;

        template <class Rep, class Period>
            explicit t24_hours(const boost::chrono::duration<Rep, Period>& d);
    };

[endsect]
[endsect]

[/==================================================================]
[section:t24_hours_formatter_hpp Header `<boost/stopwatches/t24_hours_formatter.hpp>`]
[/==================================================================]


    namespace boost { namespace stopwatches {

        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_24_hours_formatter;

        typedef basic_24_hours_formatter<char> t24_hours_formatter;
        typedef basic_24_hours_formatter<wchar_t> wt24_hours_formatter;

    } }

[section:basic_24_hours_formatter Template Class `basic_24_hours_formatter<>`]

`basic_24_hours_formatter` is a model of __Formatter__.

    template <typename CharT, typename Traits, class Alloc>
    class basic_24_hours_formatter {
    public:
        static std::ostream &  default_os();
        static const char * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_
            , const char * format, int places, std::ostream & os
            , system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%d days(s) %h:%m:%s.%n\\n", where

* `%d` : days
* `%h` : hours
* `%m` : minutes
* `%s` : seconds
* `%n` : nanoseconds

[endsect]

[section:typedefs `basic_24_hours_formatter` useful typedefs]

The library provides basic_24_hours_formatter shortcuts for char and wchar_t.

        typedef basic_24_hours_formatter<char> t24_hours_formatter;
        typedef basic_24_hours_formatter<wchar_t> wt24_hours_formatter;

[endsect]

[endsect]

[endsect]

[endsect]


[/=================]
[section Appendices]
[/=================]
[/==================================]
[section:history Appendix A: History]
[/==================================]

[section [*Version 0.5.0, September 10, 2010] ]

[*Features:]

* Extraction from Boost.Chrono of Boost.Stopwatches

[endsect]

[section [*Version 0.4.7, September 1, 2010] ]

[*New Features:]

* Added __lightweight_stopwatch__.

[endsect]

[section [*Version 0.4.6, August 28, 2010] ]

[*New Features:]

* Implementation of __common_type__ without using Boost.TypeOf.
* Added __stopwatch_accumulator_time_formatter__ class.

[*Old Features:]

* Type reporter removed from Stopwatches as well as the get_reporter metafunction.

[*Bug Fixes]

* __process_cpu_clock__ is now a valid model of Clock that can be used with __stopclocks_accumulator__.
* eliminate or suppress a lot of warnings appearing with with warnings=all -Wextra
* improve the error code handling

[endsect]

[section [*Version 0.4.5, July 6, 2010] ['Documentation update]]

[*Documentation]

* Overview rewriting
* Added missing __thread_clock__ reference.
* How to implement a __thread_clock__ tutorial removed.
* References section renamed to External Resources.
* Added links to source examples.
* Added links between Models and Concepts.
* Added macros descriptions.
* Cleanup.

[*Bug Fixes]

* Valgrind fixes: "Conditional jump or move depends on uninitialised value(s)"
* Take care of Boost.System break on version 1.44
* gcc.4.4 "warning: suggest parentheses around '&&' within '||' " removal.

[endsect]

[section [*Version 0.4.4, February 22, 2010] [' Warning fixes]]

[*Bug Fixes]

* `scoped_suspend` warning removal
* `error_code` management completed

[endsect]

[section [*Version 0.4.3, June 18, 2010] ['Missing file fixe]]

[*Bug Fixes]

* boost/thread/detail/cv_status.hpp file was not commited.

[endsect]

[section [*Version 0.4.2, June 18, 2010] ['Packaging fixe]]

* Boost.Conversion library, used by Boost.Thread porting to Boost.Chrono was not packaged.

[endsect]

[section [*Version 0.4.1, June 17, 2010] ['Added thread clock implementation on Windows]]

[*New Features:]

* Added __thread_clock__ implementation on Windows.
* Added *Boost.Thread* using *Boost.Chrono*.

[endsect]

[section [*Version 0.4, February 28, 2010] ['New thread clock and Suspendible clock ]]

[*New Features:]

* __SuspendibleClock__ concept + template class _suspendible_clock__.
* Added `scope_suspend` which do `suspend`/`resume` if the __Clock__ is a model of __SuspendibleClock__ concept, and nothing otherwise.
* __thread_clock__ support on platforms providing it natively.
* Added support for wide character for __stopwatch_reporter__, `stopclock`, and `stopclock_accumulator`.
* `digital_time` renamed `t24_hours`.

[*Perf]

Added performances measures.

[*Bug Fixes]

* Bug on timeval_demo.

    time_point t(duration(xtime(0)));  // this was taken as a function declaration
    gettimeofday((timeval*)&t, 0);
    return t;
by

    timeval tv;
    gettimeofday(&tv, 0);
    xtime xt( tv.tv_sec, tv.tv_usec);
    return time_point(duration(xt));

* Bug on run_timer_test (add a global variable to avoid optimization that removes completely the code to be  measured

[endsect]

[section [*Version 0.3.2, January 25, 2010] ['New frequency, lifetime and percentage stopwatch_accumulator features]]
[*Features:]

* Added overloading for `operator/(Integer/Duration)`
* Added frequency, lifetime and percentage to the default `stopwatch_accumulator_formatter`.

[*Bug Fixes]
* Specific formatters didn't work completly.
* Replace `duration(0)` by `duration::zero()` on template classes.
* `suspend` doesn't works: `partial_` not initialized neither taken in account by the elapsed function.

[endsect]

[section [*Version 0.3.1, January 20, 2010] ['New support for wide characters]]
[*Features:]

* Support for wide characters on formatters and stopclocks
* added `chrono.hpp` and `stopwatches.hpp` at the boost level


[endsect]

[section [*Version 0.3.0, January 17, 2010] ['New stopwatch/stopclock feature + Bug fixes]]
[*Features:]

* Added independent process cpu clocks for real, user, system process CPU time
* Added global process cpu clock for real, user, system process CPU time
* Added `digital_time` (looking for a better name)
* Added new __Stopwatch__ concept measuring elapsed time between different points in time associated to the operations `start`, `stop`, `suspend` and `resume`.
* Added __stopwatch__ is a model __Stopwatch__ measuring the elapsed time between the `start` and the `stop` operations.
* Added __stopwatch_accumulator__ is a model __Stopwatch__ allowing to accumulate several time samples and gives the average, ...
* Added scoped helper classes allowing to pairwise `start`/`stop` operations, `suspend`/`resume` and `resume`/`suspend` a __Stopwatch__.
* Added new stopwatch __Formatter__ concept
    * Added stopwatch formatter "%ds\\n"
    * Added stopwatch accumulator formatter "%c times, sum=%ss, min=%ms, max=%Ms, mean=%as\\n"
    * Added time formatter "real %rs, cpu %cs (%p%), user %us, system %ss\\n"
    * Added digital_time formatter "%d days(s) %h:%m:%s.%n\\n"
* __stopwatch_reporter__ is a convenient generic class reporting elapsed time for the Stopwatch concept.
* Added `stopclock<Clock>` shortcut `stopwatch_reporter<stopwatch<Clock>>`
* Added __scoped_stopclock__ which trace at the constuctor and destructor.
* Added `typeof` registration for classes __duration__ and __time_point__

* The old classes `process_times`, `process_clock`, `process_timer`, `timer` and `run_timer` are deprecated as the preceding additions are more generic. However for backward compatibility they preserved until inclusion of the library in Boost. Next follows the equivalences:
    * `timer<>` ~ `stopwatch<>`
    * `process_timer` ~ `stopwatch<process_cpu_clock>`
    * `run_timer` ~ `stopclock<>`

[*Bug Fixes]

* Try to correct warning "C4251: 'boost::chrono::run_timer::m_format' : class 'std::basic_string<_Elem,_Traits,_Ax>' needs to have dll-interface to be used by clients of class 'boost::chrono::run_timer'", by don't including inlines functions using the std::string `m_format`.

[endsect]

[section [*Version 0.2.1, December 13, 2009] ['Bug fixes]]

[*Bug Fixes]

* Replace `INTMAX_C` by `BOOST_INTMAX_C` until `boost/cstdint.hpp` ensures `INTMAX_C` is always defined.
* Define __BOOST_CHRONO_HAS_CLOCK_MONOTONIC__ when `BOOST_CHRONO_WINDOWS_API`
* Commenting invalid operator declarations
* Take care of Boost `min`/`max` recommendations
* Complete qualification when defining nested typedef duration on clocks to avoid the following compile error:

    ./boost/chrono/chrono.hpp:945: error: declaration of 'typedef class boost::chrono::duration<long long int, boost::__ratio__<1ll, 10000000ll> > boost::chrono::system_clock::duration'
    ./boost/chrono/chrono.hpp:458: error: changes meaning of 'duration' from 'class boost::chrono::duration<long long int, boost::__ratio__<1ll, 10000000ll> >'

* cleanup of simulated...
* warning removal on `posix/process_clock.cpp`.
* disable VC++ foolishness.
* Update Jamfiles to manage with dll.
* removal of conversion warning in test_duration.
* manage with MSVC reporting a warning instead of an error when there is an integral constant overflow.
* Use `STATIC_ASSERT` specific macro to solve the compile failing issue.
* Qualify with `boost::detail` `boost::chrono::detail` to avoid ambiguities with MSVC.


[*Documentation:]

More updated documentation.

[endsect]

[section [*Version 0.2.0, December 8, 2009] ['+ Features + Bug fixes + Updated documentation]]

[*Features:]

* Added __ratio__ construction and assignment from an equivalent __ratio__ ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]])
* Added nested __ratio__ typedef type ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]])
* Added __BOOST_CHRONO_HAS_CLOCK_MONOTONIC__ macro to state if __monotonic_clock__ is provided on this platform.
* Added __duration__ `operator%` ([@http://home.roadrunner.com/~hinnant/issue_review/lwg-defects.html#934 [*LGW 934. duration is missing operator%]])
* Added BOOST_CHRONO_CONSTEXPR when constexpr should be used.
* Complete __duration__ `operator*` and `operator/`.


[*Implementation:]

* Use `INTMAC_C` to name `intmax_t` constants instead of `LL`.
* Separate `chrono.cpp` on # files `win/chrono.cpp`, `mac/chrono.cpp` and `posix/chrono.cpp` to make easier the maintenance on different platforms.
* Separate `process_clock.cpp` on # files `win/process_clock.cpp`, `mac/process_clock.cpp` and `posix/process_clock.cpp` to make easier the maintenace on different platforms.
* Added the `error_code` prototype for `monotonic_clock::now` for `mac/chrono.cpp`.
* Fully implement `mac/chrono.cpp` with error handling.
* Take care on POSIX systems when `CLOCK_MONOTONIC` is not defined.

[*Documentation:]

* The documentation is written now using quick-book using as base [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]] .

[*Bug Fixes]

* `operator/` was ambiguous: Disambiguate duration `operator/`.
* `CLOCK_MONOTONIC` is not defined with cygwin/gcc 3.4: Disable code when __BOOST_CHRONO_HAS_CLOCK_MONOTONIC__ is not defined.
* result of metafunctions `ratio_multiply` and `ratio_divide` were not normalized ratios: Use of the nested __ratio__ typedef type on __ratio__ arithmetic operations.
* Copy constructor from similar __duration__ masked the defaulted operations: Added duration defaulted implementations


[endsect]
[section [*Version 0.1.0, April 29, 2009] ['Beman's boostified version Chrono]]

[*Features:]

*  The C++0x Standard Library's __common_type__.
*  The C++0x Standard Library's compile-time rational arithmetic.
*  The C++0x Standard Library's time utilities, including:
    * Class template __duration__
    * Class template __time_point__
    * Clocks:
        * `system_clock`
        * __monotonic_clock__
        * `high_resolution_clock`

* Class template timer, with typedefs:
    * `system_timer`
    * `monotonic_timer`
    * `high_resolution_timer`

* Process clocks and timers:
    * `process_clock`, capturing real, user-CPU, and system-CPU times.
    * `process_timer`, capturing elapsed real, user-CPU, and system-CPU times.
    * `run_timer`, convenient reporting of process_timer results.

[endsect]
[endsect]

[/======================================]
[section:rationale Appendix B: Rationale]

[heading How reliable are these measures?]

[/note this section need to be reworked, the ideas are there, but ...]


There are three cases which can lead to get unreliable measures:

* It is not possible to measure events that transpire at rates of the same order of magnitude as the clock's precision with any reliability.  For example, a 10ms clock cannot be used reliably to measure elapsed times of tens of milliseconds.  The library provides a [high_resolution_clock] that gives you the highest resolution time available on your platform.  That will give the best precision, but can only be used for reliable measurement of events that elapse about an order of magnitude slower than that clock's precision.


``
#include <boost/chrono/chrono.hpp>
    ...
    __stopclock__<__high_resolution_clock__> _;
``

* Using a process clock in a multithreaded application will give elapsed time for the process as a whole, including threads other than the calling thread.  To get time elapsed for a specific thread, use the supplied __thread_clock__ which returns time elapsed for the calling thread only, if supported by the platform.

* When stopclocks are nested, usually from stopclocks appearing in each of several nested function calls, the overhead of the stopclock processing begins to be significant relative to run time of the code being measured.  The innermost measurements remain accurate, but those in the outermost layers can measure too much overhead to be trustworthy.

* Nested stopclocks (usually nested function calls where each function contains a stopclock). When the nesting is deep enough, the cumulative overhead of all the stopclock functionality make the data unreliable except for the inner-most trace points. The question is, how much time is related to the application code we want to measure and how much to the fact we are meassuring and logging in inner blocks?


Most of the stopclock overhead is likely due to logging. There are two things we can do to make the difference :

* Don't flush log information while measuring elapsed time.  A __stopwatch_accumulator__ can make that possible, because it don't report until all the measures have been compiled and then report some statistics.  Alternatively, an asynchronous stream would permit normal logging but by a thread other than the one being measured.

* Add a mechanism to track the difference between the application time and stopclock time.  If a __Clock__ models __SuspendibleClock__ and its precision is sufficiently fine, this mechanism could suspend the __Clock_s__ counting while reporting measurements and resume it thereafter.

[/
    stopclock<suspendible_clock<Clock> > _;


See the performances section for more deep details.
]


[endsect]

[/======================================================]
[section:implementation Appendix C: Implementation Notes]



[endsect]

[/======================================================]
[section:faq Appendix D: FAQ]


[heading Why does stopwatch_reporter only display millisecond place precision when the underlying Clock has nanosecond precision?]

To avoid giving the impression of precision where none exists. See Caveat emptor. You can always specify additional decimal places if you want to live dangerously.

[heading Why does stopwatch_reporter sometimes report more cpu seconds than real seconds?]

Ask your operating system supplier. The results have been inspected with a debugger, and both for Windows and Linux, that's what the OS appears to be reporting at times.

[heading  Can I obtain statistics of the time elapsed between calls to a function?]

The library do not provides this feature.

[heading What happens if I press Ctrl+C and program terminates? What log would Boost.Stopwatches output?]


[endsect]

[/====================================================]
[section:acknowledgements Appendix E: Acknowledgements]

The library's started from the Beman Dawes `timer<>`, `process_clock`, `process_timer`, `run_timer` classes which are now deprecated and replaced by the __stopwatch__, `process_cpu_clock` and `stopclock` classes.

Thanks to Adrew Chinoff for its multiple suggestion on __stopwatch_accumulator__, and helping me to polish the documentation.

Thanks to Tom Tan for reporting some compiler issues with MSVC V10 beta and MinGW-gcc-4.4.0 and for the many suggestion he did concerning the __stopwatch__, __lightweight_stopwatch__, and __stopclock__ classes and a deep help with wide characters implementation.

Thanks to Ronald Bock for reporting Valgind issues and for the many suggestion he did concerning the documentation.

[endsect]

[/====================================================]
[section:tests  Appendix F: Tests]

In order to test you need to do.

    bjam libs/stopwatches/test

You can also run a specific suite of test by doing

    cd libs/stopwatches/test
    bjam stopwatch


[section stopwatch]
[table
    [[Name]                         [kind]          [Description]           [Result] [Ticket]]
    [[test_min_max]               [compile]           [test compilation succeeds in the presence of macros min and max.]                   [Pass]   [#]]
    [[stopwatch_example]               [run]           [...]                   [Pass]   [#]]
    [[scoped_stopwatch_example]               [run]           [...]                   [Pass]   [#]]
    [[stopwatch_accumulator_example] [run]   [...]                   [Pass]   [#]]
    [[specific_stopwatch_accumulator_example] [run]   [...]                   [Pass]   [#]]
    [[stopclock_example]      [run]          [...]                   [Pass]   [#]]
    [[stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[nested_stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[loop_stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[t24_hours_example]      [run]          [...]                   [Pass]   [#]]
    [[scoped_stopclock_example]      [run]          [...]                   [Pass]   [#]]
    [[timex]      [link]          [...]                   [Pass]   [#]]
    [[stopclock_constructor_overload_test]      [run]          [...]                   [Pass]   [#]]
    [[wstopclock_constructor_overload_test]      [run]          [...]                   [Pass]   [#]]

]
[endsect]

[endsect]
[/=====================================]
[section:tickets  Appendix G: Tickets]

[table
    [[Ticket]             [Description]          [Resolution] [State]]
    [[0]    [ Issues raised by Michael Marcin:  In the past I've seen QueryPerformanceCounter give incorrect results,
    especially with SpeedStep processors on laptops. This was many years ago and
    might have been fixed by service packs and drivers.

    Typically you check the results of QPC against GetTickCount to see if the
    results are reasonable.
    http://support.microsoft.com/kb/274323

    I've also heard of problems with QueryPerformanceCounter in multi-processor
    systems.

    I know some people SetThreadAffinityMask to 1 for the current thread call
    their QueryPerformance* functions then restore SetThreadAffinityMask. This
    seems horrible to me because it forces your program to jump to another
    physical processor if it isn't already on cpu0 but they claim it worked well
    in practice because they called the timing functions infrequently.

    In the past I have chosen to use timeGetTime with timeBeginPeriod(1) for
    high resolution timers to avoid these issues.
    ] [???] [*Open*]]
    [[1]    [operator/ was ambiguous] [Disambiguate duration operator/]                  [Closed]]
    [[2]    [CLOCK_MONOTONIC is not defined with cygwin/gcc 3.4] [Disable code when BOOST_CHRONO_HAS_CLOCK_MONOTONIC is not defined.]                  [Closed]]
    [[3]    [result of metafunctions ratio_multiply and ratio_divide were not normalized ratios] [Use of the nested ratio typedef type on ratio arithmetic operations.]                  [Closed]]
    [[4]    [Copy constructor from similar duration masked the defaulted operations] [Added duration defaulted implementations]                  [Closed]]
    [[5]    [INTMAX_C is not always defined] [Replace INTMAX_C by BOOST_INTMAX_C until boost/cstdint.hpp ensures INTMAX_C is always defined.]                  [Closed]]
    [[6]    [undefined BOOST_CHRONO_HAS_CLOCK_MONOTONIC when BOOST_CHRONO_WINDOWS_API] [Define BOOST_CHRONO_HAS_CLOCK_MONOTONIC when BOOST_CHRONO_WINDOWS_API]                  [Closed]]
    [[7]    [min/max macros intrussion] [Take care of Boost min/max recommendations]                  [Closed]]
    [[8]    [declaration of 'typedef class boost::chrono::duration<..> changes meaning of 'duration'] [complete qualification when defining nested typedef duration on clocks to avoid the following compile error:]                  [Closed]]
    [[9]    [VC++ warnings] [disable VC++ foolishness]                  [Closed]]
]    
[table
    [[Ticket]             [Description]          [Resolution] [State]]
    
    [[10]    [conversion warning in test_duration] [removal of conversion warning in test_duration]                  [Closed]]
    [[11]    [MSVC reports a warning instead of an error when there is an integral constant overflow] [manage with MSVC reporting a warning instead of an error when there is an integral constant overflow]                  [Closed]]
    [[12]    [ambiguities with MSVC when using detail:: namespace] [Qualify with boost::detail boost::chrono::detail ]                  [Closed]]
    [[13]    [warning C4251: 'boost::chrono::run_timer::m_format' : class 'std::basic_string<_Elem,_Traits,_Ax>' needs to have dll-interface to be used by clients of class 'boost::chrono::run_timer'] [don't include inlines functions using the std::string m_format]                  [Closed]]
    [[14]    [Bad use of duration(0) on template classes] [remplace by duration::zero()]                  [Closed]]
    [[15]    [suspend doesn't works: partial_ not initialized] [initialize with duration::zero()]                  [Closed]]
    [[16]    [suspend doesn't works: elapsed doesn't take care of partial_] [take care of partial]                  [Closed]]
    [[17]    [suspend doesn't works: bad use of system::error_code & ec] [replace by system::error_code ec]                  [Closed]]
    [[18]    [warnings on mingw-gcc.4.4:

..\..\../boost/chrono/chrono.hpp: In copy constructor 'boost::chrono::time_point<boost::chrono::process_cpu_clock,
boost::chrono::duration<boost::chrono::process_cpu_clock::times, boost::ratio<1ll, 1000000000ll> > 
>::time_point(const boost::chrono::time_point<boost::chrono::process_cpu_clock,
boost::chrono::duration<boost::chrono::process_cpu_clock::times, boost::ratio<1ll, 1000000000ll> > >&)':
..\..\../boost/chrono/chrono.hpp:816: warning: suggest parentheses around '&&' within '||'
..\..\../boost/chrono/chrono.hpp:816: warning: suggest parentheses around '&&' within '||'

] [???]                  [Closed]]
    [[19]    [Use of Specific formatters doesn't works] []                  [Closed]]

    [[20]    [boost/chrono/scoped_suspend.hpp(31) : warning C4520: 'boost::chrono::scoped_suspend<Clock>' : multiple default constructors specified
] [Remove the default constructor deletion ]                  [Closed]]
    [[21]    [suspendible_clock_test doesn't works in my mingw environement] [(issue with tss)]                  [*Open*]]
    [[22]    [error_code not initialized] [Use ec.clear() before throwing a exception.]                  [Closed]]
    [[23]    [boost/thread/detail/cv_status.hpp file was not commited] [commit file]                  [Closed]]
    [[24]    [Boost.Conversion was not packaged] [Package it]                  [Closed]]
    [[25]    [Valgrind issue: Conditional jump or move depends on uninitialised value(s)] [Replace the test]                  [Closed]]
    [/[#]    [XXXX] [XXXX]                  [Closed]]
]





[endsect]

[/=====================================]
[section:perf  Appendix H: Performances]
[/=====================================]


We have run some program changing how the reporting is done.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

The programs are either single-threaded or multi-threaded.

Two kind of inner functions are used: recursive or non recursive. In order to test the influence of nesting reports, the non recursive functions use up to 10 nesting levels, depending on its parameter.

the function at level n is defined as follows

    void fn(long v) {
        // reporting or not
        stopclock<> _;
        // burn some time
        for ( long i = 0; i < v; ++i )
            res+=std::sqrt( res+123.456L+i );  // burn some time
        if (v==0) return;

        if (v%(n-1)==0) fn-1(v-1);
        if (v%(n-2)==0) fn-2(v-1);
        ...
        f1(v-1);
    }

This gives a variable number in nesting reporting depending on the parameter, with a variable lifetime.

[heading Single-Threaded Recursive function]

We have run the same program and changed how the reporting is done.

The programm creates two thread of execution. the thread entry point calls a function which makes some calculation depending on its parameter and call recursivelly itself decreasing the parameter.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

[heading Multi-Threaded Recursive function]

We have run the same program and changed how the reporting is done.

The programm creates two thread of execution. the thread entry point calls a function which makes some calculation depending on its parameter and call recursivelly itself decreasing the parameter.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

[endsect]

[/=====================================]
[section:todo  Appendix I: Future plans]
[/=====================================]
[heading Tasks to do]

* Complete documentation
* Fully implement error handling, with test cases.
* Fix open isues.

[endsect]
[endsect]
