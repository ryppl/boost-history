[/
 / Copyright (c) 2009-20010 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[article Boost.Stopwatches
    [quickbook 1.5]
    [version 0.2.0]
    [authors [Botet Escriba, Vicente J.]]
    [copyright 2009-2011 Vicente J. Botet Escriba]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/==================]
[def __Boost_Chrono__ [*Boost.Chrono]]

[def __Boost_Stopwatches__ [*Boost.Stopwatches]]


[/===============================================]

[def __common_type__ `common_type`]

[/===============================================]
[def __ratio__ `ratio`]



[def __ratio_add `ratio_add`]
[def __ratio_subtract `ratio_subtract`]
[def __ratio_multiply `ratio_multiply`]
[def __ratio_divide `ratio_divide`]


[def __ratio_equal `ratio_equal]]
[def __ratio_not_equal `ratio_not_equal`]
[def __ratio_less `ratio_less`]]
[def __ratio_less_equal `ratio_less_equal`]
[def __ratio_greater `ratio_greater`]
[def __ratio_greater_equal `ratio_greater_equal`]


[template ratio_si_typedefs[link_text] [link_text]]
[def __atto [ratio_si_typedefs `atto`]]
[def __femto [ratio_si_typedefs `femto`]]
[def __pico [ratio_si_typedefs `pico`]]
[def __nano [ratio_si_typedefs `nano`]]
[def __micro [ratio_si_typedefs `micro`]]
[def __milli [ratio_si_typedefs `milli`]]
[def __centi [ratio_si_typedefs `centi`]]
[def __deci [ratio_si_typedefs `deci`]]
[def __deca [ratio_si_typedefs `deca`]]
[def __hecto [ratio_si_typedefs `hecto`]]
[def __kilo [ratio_si_typedefs `kilo`]]
[def __mega [ratio_si_typedefs `mega`]]
[def __giga [ratio_si_typedefs `giga`]]
[def __tera [ratio_si_typedefs `tera`]]
[def __peta [ratio_si_typedefs `peta`]]
[def __exa [ratio_si_typedefs `exa`]]


[/==================]


[template chrono_conf[link_text] [link_text]]


[def __BOOST_CHRONO_USES_STATIC_ASSERT [chrono_conf `BOOST_CHRONO_USES_STATIC_ASSERT`]]
[def __BOOST_CHRONO_USES_MPL_ASSERT [chrono_conf `BOOST_CHRONO_USES_MPL_ASSERT`]]
[def __BOOST_CHRONO_USES_ARRAY_ASSERT [chrono_conf `BOOST_CHRONO_USES_ARRAY_ASSERT`]]

[/def __BOOST_CHRONO_HAS_CLOCK_STEADY [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.BOOST_CHRONO_HAS_CLOCK_STEADY `BOOST_CHRONO_HAS_CLOCK_STEADY`]]

[def __BOOST_CHRONO_HAS_CLOCK_STEADY `BOOST_CHRONO_HAS_CLOCK_STEADY`]


[/template clock_concept_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.clock [link_text]]]
[template clock_concept_link[link_text] [link_text]]
[def __clock_concept__ [clock_concept_link `Clock` concept]]
[def __clock_concept_type__ [clock_concept_link `Clock`]]
[def __clock_req__ [clock_concept_link `Clock` requirements]]
[def __Clock__ [clock_concept_link `Clock`]]
[def __Clock_s__ [clock_concept_link `Clock`'s]]


[/template duration_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.duration [link_text]]]
[template duration_link[link_text] [link_text]]
[def __duration__ [duration_link `duration`]]
[def __duration_s__ [duration_link `duration`'s]]

[/==================]
[/template time_point_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.time_point [link_text]]]
[template time_point_link[link_text] [link_text]]
[def __time_point__ [time_point_link `time_point`]]
[def __time_point_s__ [time_point_link `time_point`'s]]

[/==================]
[/template system_clock_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.system_clock [link_text]]]
[template system_clock_link[link_text] [link_text]]
[def __system_clock__ [system_clock_link `system_clock`]]

[/==================]
[/template steady_clock_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.steady_clock [link_text]]]
[template steady_clock_link[link_text] [link_text]]
[def __steady_clock__ [steady_clock_link `steady_clock`]]

[/==================]
[/template high_resolution_clock_link[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.high_resolution_clock [link_text]]]
[template high_resolution_clock_link[link_text] [link_text]]
[def __high_resolution_clock__ [high_resolution_clock_link `high_resolution_clock`]]

[/def __duration_cast__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.duration_cast `duration_cast`]]
[def __duration_cast__ `duration_cast`]

[/def __time_point_cast__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.time_point_cast `time_point_cast`]]
[def __time_point_cast__ `time_point_cast`]


[/template duration_typedefs[link_text] [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.duration_typedefs [link_text]]]
[template duration_typedefs[link_text] [link_text]]
[def __nanoseconds__ [duration_typedefs `nanoseconds`]]
[def __microseconds__ [duration_typedefs `microseconds`]]
[def __milliseconds__ [duration_typedefs `milliseconds`]]
[def __seconds__ [duration_typedefs `seconds`]]
[def __minutes__ [duration_typedefs `minutes`]]
[def __hours__ [duration_typedefs `hours`]]
[def __days__ [duration_typedefs `days`]]

[/def __common_type_spe__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.common_type_spe `common_type`]]
[def __common_type_spe__ `common_type`]

[/==================]
[/def __treat_as_floating_point__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.traits.treat_as_floating_point `treat_as_floating_point`]]
[def __treat_as_floating_point__ `treat_as_floating_point`]
[/def __duration_values__ `duration_values`]
[def __duration_values__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.traits.duration_values `duration_values`]]
[/def __zero__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.traits.duration_values.zero `zero`]]
[def __zero__ `zero`]
[/def __max__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.traits.duration_values.max `max`]]
[def __max__ `max`]
[/def __min__ [link boost_stopwatches.reference.cpp0x.chrono_chrono_hpp.traits.duration_values.min `min`]]
[def __min__ `min`]


[/==================]
[template SuspendibleClock_concept_link[link_text] [link boost_stopwatches.reference.other_clocks.suspendible_clock_req [link_text]]]
[def __SuspendibleClock_concept__ [SuspendibleClock_concept_link `SuspendibleClock` concept]]
[def __SuspendibleClock_concept_type__ [SuspendibleClock_concept_link `SuspendibleClock`]]
[def __SuspendibleClock_req__ [SuspendibleClock_concept_link `SuspendibleClock` requirements]]
[def __SuspendibleClock__ [SuspendibleClock_concept_link `SuspendibleClock`]]

[/==================]
[template stopwatch_concept_link[link_text] [link boost_stopwatches.reference.stopwatches.stopwatch_req [link_text]]]
[def __stopwatch_concept__ [stopwatch_concept_link `Stopwatch` concept]]
[def __stopwatch_concept_type__ [stopwatch_concept_link `Stopwatch`]]
[def __stopwatch_req__ [stopwatch_concept_link `Stopwatch` requirements]]
[def __Stopwatch__ [stopwatch_concept_link `Stopwatch`]]


[def __stopwatch__ [link boost_stopwatches.reference.stopwatches.stopwatch_hpp.stopwatch `stopwatch`]]
[def __lightweight_stopwatch__ [link boost_stopwatches.reference.stopwatches.lightweight_stopwatch_hpp.lightweight_stopwatch `lightweight_stopwatch`]]

[def __stopwatch_accumulator__ [link boost_stopwatches.reference.stopwatches.stopwatch_accumulator_hpp.stopwatch_accumulator `stopwatch_accumulator`]]


[def __stopwatch_reporter__ [link boost_stopwatches.reference.reporters.stopwatch_reporter_hpp.stopwatch_reporter `stopwatch_reporter`]]

[def __stopclock_accumulator__ [link boost_stopwatches.reference.reporters.stopclock_accumulator_hpp.stopclock_accumulator `stopclock_accumulator`]]

[/==================]
[template formatter_concept_link[link_text] [link boost_stopwatches.reference.reporters.formatter_req [link_text]]]
[def __formatter_concept__ [formatter_concept_link `Formatter` concept]]
[def __formatter_concept_type__ [formatter_concept_link `Formatter`]]
[def __formatter_req__ [formatter_concept_link `Formatter` requirements]]
[def __Formatter__ [formatter_concept_link `Formatter`]]

[def __stopclock__ [link boost_stopwatches.reference.reporters.stopclock_hpp.stopclock `stopclock`]]
[def __stopclock_clock__ [link boost_stopwatches.reference.reporters.stopclock_hpp.stopclock `stopclock<Clock>`]]

[def __scoped_stopclock__ [link boost_stopwatches.reference.reporters.scoped_stopclock_hpp.scoped_stopclock `scoped_stopclock`]]

[def __process_real_cpu_clock__  `process_real_cpu_clock`]

[def __process_system_cpu_clock__ `process_system_cpu_clock`]

[def __process_user_cpu_clock__  `process_user_cpu_clock`]

[def __thread_clock__  `thread_clock`]

[def __suspendible_clock__ [link boost_stopwatches.reference.other_clocks.suspendible_clock_hpp.suspendible_clock `suspendible_clock`]]

[def __stopwatch_accumulator_formatter__ [link boost_stopwatches.reference.formatters.stopwatch_accumulator_formatter_hpp.basic_stopwatch_accumulator_formatter `stopwatch_accumulator_formatter`]]

[def __stopwatch_accumulator_time_formatter__ [link boost_stopwatches.reference.formatters.stopwatch_accumulator_time_formatter_hpp.basic_stopwatch_accumulator_time_formatter `stopwatch_accumulator_time_formatter`]]

[def __basic_stopwatch_formatter__ [link boost_stopwatches.reference.formatters.stopwatch_formatter_hpp.basic_stopwatch_formatter `stopwatch_accumulator_formatter`]]

[def __basic_stopwatch_accumulator_formatter__ [link boost_stopwatches.reference.formatters.stopwatch_accumulator_formatter_hpp.basic_stopwatch_accumulator_formatter `stopwatch_accumulator_formatter`]]

[def __basic_24_hours_formatter__ [link boost_stopwatches.reference.formatters.t24_hours_formatter_hpp.basic_24_hours_formatter `basic_24_hours_formatter`]]



[warning Stopwatches is not part of the Boost libraries.]

[/===============]
[section Overview]
[/===============]



[/====================================]
[heading How to Use This Documentation]
[/====================================]

This documentation makes use of the following naming and formatting conventions.

* Code is in `fixed width font` and is syntax-highlighted.
* Replaceable text that you will need to supply is in [~italics].
* Free functions are rendered in the code font followed by (), as in `free_function()`.
* If a name refers to a class template, it is specified like this:   `class_template<>`; that is, it is in code font and its name is followed by `<>`   to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in code font and its name is followed by `()` to   indicate that it is a function-like macro. Object-like macros appear without the   trailing `()`.
* Names that refer to /concepts/ in the generic programming sense are  specified in CamelCase.

[note In addition, notes such as this one specify non-essential information that provides additional background or rationale.]

Finally, you can mentally add the following to any code fragments in this document:

    // Include all of Stopwatches files
    #include <boost/stopwatches.hpp>
    using namespace boost::chrono;
    using namespace boost::stopwatches;


[/=================]
[section Motivation]
[/=================]



[heading Measuring elapsed time]

Knowing how long a program, a function or a specific code block takes to execute is useful in both test and production environments.
__Boost_Stopwatches__ introduces the __Stopwatch__ concept which is a mechanism to measure the elapsed time.
A Stopwatch allows to start, stop, suspend and resume measuring the elapsed time.
__stopwatch__`<>` is the basic model of __Stopwatch__.

[heading Reporting elapsed time]

It is often necessary to report elapsed time on a user display or in a log file.  __stopwatch_reporter__<> provides a runtime reporting mechanism for this purpose which can be invoked in just one line of code.

    using namespace boost::chrono;
    using namespace boost::stopwatches;
    int main()
    {
        __stopwatch_reporter__<__stopwatch__<process_cpu_clock> > _;
      // ...
    }

Will produce the following output

    real 0.034s, cpu 0.031s (93.0%), user 0.031s, system 0.000s

As this is one of the expression more commonly use, the library provides a stopclock shortcut so the preceding can be writen as

    using namespace boost::stopwatches;
    int main()
    {
        __stopclock__<> _;
      // ...
    }


[heading How reliable are these measures?]

There are a number of things that can lead to unreliable measurement (see [link boost_stopwatches.appendices.rationale here] for more details), but they mostly amount to reporting overhead.  Boost.Chrono provides two ways to improve reliability of time measurements.  A __stopwatch_accumulator__ only reports statistics once all measurements have been acquired, which removes reporting overhead from the measurements.  The other approach is to use a __SuspendibleClock__ such that the reporting overhead can be ignored by suspending elapsed time tracking during reporting operations

[endsect]

[/==================]
[section Description]
[/==================]


On top of the standard facilities of __Boost_Chrono__, __Boost_Stopwatches__ provides:

* Stopwatches: A facility to measure elapsed time with the ability to start, stop, suspend, or resume measurement.
    * __Stopwatch__ concept
    * Scoped helper classes allowing to pairwise start/stop operations, suspend/resume and resume/suspend a __Stopwatch__.
    * __stopwatch__, model of __Stopwatch__ capturing elapsed __Clock__ times.
    * __stopwatch_accumulator__, model of __Stopwatch__ capturing cummulated elapsed Clock times.

* Stopclocks: a complete time reporting package that can be invoked in a single line of code.
    * __stopwatch_reporter__, convenient reporting to an output stream (including wide char streams) of the elapsed time of models of __Stopwatch__ results.
    * __stopclock_clock__ shortcut of `__stopwatch_reporter__<__stopwatch__<Clock>>`

[/

* Suspendible clock
    * __SuspendibleClock__ concept
    * scope_suspend which do suspend/resume if the __Clock__ is a model of __SuspendibleClock__ concept, and nothing otherwise.
    * template class __suspendible_clock__
]

[endsect]

[endsect]


[/==============================]
[section:users_guide Users'Guide]
[/==============================]

[/======================================]
[section:getting_started Getting Started]
[/======================================]

[/======================================]
[section:install Installing __Boost_Stopwatches__]
[/======================================]

[/=================================]
[heading Getting __Boost_Stopwatches__ ]
[/=================================]

You can get the last stable release of __Boost_Stopwatches__ by downloading [^stopwatches.zip] from the
[@http://www.boost-consulting.com/vault/index.php?directory=System Boost Vault].

You can also access the latest (unstable?) state from the [@http://svn.boost.org/svn/boost/sandbox/chrono Boost Sandbox], directories boost/stopwatches and libs/stopwatches. Just go to [@http://svn.boost.org/trac/boost/wiki/BoostSubversion here] and follow the instructions there for anonymous SVN access.

[/==========================================]
[heading Where to install __Boost_Stopwatches__? ]
[/==========================================]

The simple way is to decompress (or checkout from SVN) the file in your BOOST_ROOT directory.

Othesewise, if you decompress in a different directory, you will need to comment some lines, and uncomment and change others in the build/Jamfile and test/Jamfile. Sorry for this, but I have not reached yet to write a Jamfile that is able to work in both environements and use the BOOST_ROOT variable. Any help is welcome.

[/=================================]
[heading Building __Boost_Stopwatches__ ]
[/=================================]

__Boost_Stopwatches__ is a header only library. 

[/===================]
[heading Requirements]
[/===================]

__Boost_Stopwatches__ depends on some Boost libraries. For these specific parts you must use either Boost version 1.44.0 or the version in SVN trunk (even if older versions should works also).

In particular, __Boost_Stopwatches__ depends on:

[variablelist
[
    [[@http://www.boost.org/libs/chrono [*Boost.Chrono]]] [for duration, time_point and clocks, ...]
]
[
    [[@http://www.boost.org/libs/config [*Boost.Config]]] [for configuration purposes, ...]
]
[
    [[@http://www.boost.org/libs/exception [*Boost.Exception]]] [for throw_exception, ...]
]
[
    [[@http://www.boost.org/libs/mpl [*Boost.MPL]]] [for MPL Assert and bool, ...]
]
[
    [[@http://www.boost.org/libs/system [*Boost.System]]] [for error_code, ...]
]
[
    [[@http://www.boost.org/libs/io [*Boost.Input/Output]]] [for io_state, ...]
]
[
    [[@http://www.boost.org/libs/static_assert [*Boost.StaticAssert]]] [for STATIC_ASSERT, ...]
]
[
    [[@http://www.boost.org/libs/type_traits [*Boost.TypeTraits]]] [for is_same, ...]
]
[
    [[@http://www.boost.org/libs/utility [*Boost.Utility]]] [for base_from_memeber, ...]
]
]

__Boost_Stopwatches__ depends optionaly on:

[variablelist
[
    [[@http://www.boost.org/libs/thread [*Boost.Thread]]] [for thread_specific_ptr when suspendible_clock.hpp is included]
]
[
    [[@http://www.boost.org/libs/accumulator [*Boost.Accumulator]]] [for accumulator_set, and statistics features when stopwatch_accumulator.hpp is included]
]
]


[/=========================================================]
[heading Building an executable that uses __Boost_Stopwatches__ ]
[/=========================================================]

In addition to linking with the Boost.Chrono library you need also to link with the Boost.System library. If you use Suspendible clocks you will need also with Boost.Thread.

[/=========================]
[heading Exceptions safety ]
[/=========================]

All functions in the library are exception-neutral and provide strong guarantee of exception safety as long as the underlying parameters provide it.

[/=====================]
[heading Thread safety ]
[/=====================]

All functions in the library are thread-unsafe except when noted explicitly.

[/========================]
[heading Tested compilers ]
[/========================]

The implementation will eventually work with most C++03 conforming compilers.
Current version has been tested on:

Windows with

* MSVC 10.0

Cygwin 1.5 with

* GCC 3.4.4

Cygwin 1.7 with

* GCC 4.3.4

MinGW with

* GCC 4.4.0
* GCC 4.5.0
* GCC 4.5.0 -std=c++0x
* GCC 4.6.0
* GCC 4.6.0 -std=c++0x

Ubuntu 10.10

* GCC 4.4.5
* GCC 4.4.5 -std=c++0x
* GCC 4.5.1
* GCC 4.5.1 -std=c++0x
* clang 2.8

[note Please let us know how this works on other platforms/compilers.]

[note Please send any questions, comments and bug reports to boost <at> lists <dot> boost <dot> org.]

[endsect]
[/====================]
[section:hello Hello World! ]
[/====================]

If all you want to do is to time a program's execution:

    #include <boost/stopwatches/stopclock.hpp>

    ...

    // add this in the scope you want to time,
    // at the point you want the timer to start.
    boost::stopwatches::__stopclock__<> rt;

Here is a complete program (stopclock_example.cpp):

    #include <boost/stopwatches/stopclock.hpp>
    #include <cmath>

    int main()
    {
      boost::stopwatches::__stopclock__<> t;

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L ); // burn some time

      return 0;
    }

Debug build output was:

    real 0.832s, cpu 0.813s (97.7%), user 0.813s, system 0.000s

In other words, the program took 0.832 real-time (i.e. wall clock) seconds to execute, while the operating system (Windows in this case) charged 0.813 seconds of CPU time to the user and 0 seconds to the system. The total CPU time reported was 0.813 seconds, and that represented utilization of 97.7% of the real-time seconds.

[endsect]

[endsect]


[section Tutorial]




[section Stopwatches and Stopclocks]

Knowing how long a program, a function or a specific block takes to execute is useful in both test and production environments.
__Boost_Stopwatches__ introduces the __Stopwatch__ concept which captures the mechanism to measure the elapsed time.
A __Stopwatch__ allows to `start`, `stop`, `suspend` and `resume` measuring the elapsed time.
__stopwatch__`<>` is the basic model of __Stopwatch__ allowing to make a single measure.

At the user level, the main use case of measuring the elapsed time is to report these measures on the display.
__stopwatch_reporter__`<>` provides a run time reporting package that can be invoked in a single line of code to report the usage of a __Clock__.
For example

    using namespace boost::chrono;
    using namespace boost::stopwatches;
    
    int f1(long j) {
        __stopwatch_reporter__<__stopwatch__<> > _;

        for ( long i = 0; i < j; ++i )
            std::sqrt( 123.456L );  // burn some time

        return 0;
    }
    int main()  {
        f1(100000);
        f1(200000);
        f1(300000);
        return 0;
    }

Will produce the following output

    0.006s
    0.011s
    0.017s

[/
[section:reliable How reliable are these measures?]

[note this section need to be reworked, the ideas are there, but ...]

There are three context on which you can get unreliable measures:

* precision of your clock. If the precision of your clock is 10ms you can not be able to measure the time spent by blocks of code that takes the same order of magnitude. The library provides a hig_resolution_clock that gives you the higher resolution available on your platform. Respect to the precision, nothing to do except to take the clock with the highest resolution and measures blocks of code that will spent time having more than one order of magnitude the precision of the clock.

``
#include <boost/chrono/chrono.hpp>
    ...
    __stopclock__<__high_resolution_clock__> _;
``

* When your application is multithreaded, and you use a process clock, the time you get is the delay during which your block has been executed, in concurrency with the other threads of execution. If what you want is the time spent by this specific thread another clock is needed. The library provide a __thread_clock__ that returns the time spent by the thread on platforms providing this kind of data. It can be used as follows

``
#include <boost/chrono/thread_clock.hpp>
...
#if defined(__BOOST_CHRONO_HAS_THREAD_CLOCK)
    __stopclock__<__thread_clock__> _;
#else
    __stopclock__<__process_real_cpu_clock__> _;
#endif
``

* Nested stopclocks (usually nested function calls where each function contains a __stopclock__). When the nesting is deep enough, the cumulative overhead of all the stopclock functionality make the data unreliable except for the inner-most trace points. The question is, how much time is related to the application code we want to measure and how much to the fact we are meassuring and logging in inner blocks?

Some measures let us think that most of the time spent by the __stopclock__ mechanism is associated to the logging part. There are two things we can do to make the difference :

* Avoid expensive operations as logging while doing the measures. Note that reporting in itself is not too expensive as far as we don't need to flush the buffer. This can be achieved either using a __stopclock_accumulator__, 'i.e. don't report until all the measures have been compiled and then report some statistics or using an asynchronous stream.

* Introduce some cheap mechanism that allows us to make the difference between the application time and the intrinsic __stopclock__ time. When the precision of the clock is enough, we can suspend the counting of the Clock while we are spending time reporting the measures, and resume it once the work is done. The library provide a Clock wrapper __suspendible_clock__ that make the resulting clock suspendible. The __stopwatch_reporter__ is able to detect if the __Clock__ is Suspendible and then `suspend`/`resume` the __Clock__ while doing the report.

    __stopclock__<__suspendible_clock__<Clock> > _;


See the performances section for more deep details.

[endsect]
]

[section:accumulators Stopwatches accumulation and statistics]

The preceding stopwatch manage only with a measure. It is also interesting to have an statisitical view of these times, for example the sum, min, max and mean. __stopwatch_accumulator__`<>` associates an accumulator with a __stopwatch__, so we are able to retrieve any statistical feature Boost.Accumulator provides.

For example

    using namespace boost::stopwatches;
    
    int f1(long j) {
        static __stopwatch_reporter__<__stopwatch_accumulator__<> > sw;
        __stopwatch_reporter__<__stopwatch_accumulator__<> >::scoped_run _(sw);

        for ( long i = 0; i < j; ++i )
            std::sqrt( 123.456L );  // burn some time

        return 0;
    }
    int main()  {
        f1(100000);
        f1(200000);
        f1(300000);
        return 0;
    }

Will produce the following output

    3 times, sum=0.034s, min=0.006s, max=0.017s, mean=0.011s


[endsect]



[section:function How can I prefix each report with `BOOST_CURRENT_FUNCTION` function signature?]

You will need to give a specific format to your __stopclock__. You just need to concatenate your specific pattern to the default_format of the formatter.

For example, for a __stopclock_accumulator__ the default formatter is __stopwatch_accumulator_formatter__, you will need to do something like:

    static __stopclock_accumulator__<> acc(
        std::string(BOOST_CURRENT_FUNCTION) + ":  "
            + __stopwatch_accumulator_formatter__::default_format()
    );
    __stopclock_accumulator__<>::scoped_run _(acc);


Some of you will say that this is too long to type just to get the a report. You can of course define your own macro as

    #define REPORT_FUNCTION_ACCUMULATED_LIFETIME\
        static boost::stopwatches::__stopclock_accumulator__<> \
                BOOST_JOIN(_accumulator_, __LINE__)_
            ( std::string(BOOST_CURRENT_FUNCTION) + ":  " + \
                boost::stopwatches::__stopwatch_accumulator_formatter__::default_format() \
        ); \
        boost::stopwatches::__stopclock_accumulator__<>::scoped_run \
                BOOST_JOIN(_accumulator_run_, __LINE__) \
            (BOOST_JOIN(_accumulator_, __LINE__))


With this macro you will just have to write

    void foo()
    {
        REPORT_FUNCTION_ACCUMULATED_LIFETIME() ;
        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
        // ...
    }

[endsect]

[section:file_line How can I prefix each report with `__FILE__[__LINE__]` pattern?]

When you want to prefix with the `__FILE__[__LINE__]` pattern you can follow the same technique as described below:

    #define REPORT_LINE_ACCUMULATED_LIFETIME \
        static __stopclock_accumulator__<>
                BOOST_JOIN(_accumulator_, __LINE__) \
                ( std::string(__FILE__) + "[" + BOOST_STRINGIZE(__LINE__) + "] "
                    + __stopwatch_accumulator_formatter__::default_format() \
        ); \
        __stopclock_accumulator__<>::scoped_run \
                BOOST_JOIN(_accumulator_run_, __LINE__)
                (BOOST_JOIN(_accumulator_, __LINE__))

Now you can mix fcntion and line reports as follows

    void foo()
    {
        REPORT_FUNCTION_ACCUMULATED_LIFETIME;
        boost::this_thread::sleep(boost::posix_time::milliseconds(100));
        {
            REPORT_LINE_ACCUMULATED_LIFETIME;
            boost::this_thread::sleep(boost::posix_time::milliseconds(200));
        }

    }

[endsect]

[section:non_static_acc Can I use an stopclock accumulator which is not static?]

The typical example of stopclock_accumulator is to get statistical measures of the time a function takes for each one of its calls. You can also use __stopclock_accumulator__ to get statistical measures of the time a given loop takes for each one of its laps.

        __stopclock_accumulator__<> acc(
            std::string(__FILE__) + "[" + BOOST_STRINGIZE(__LINE__) + "] "
                + __stopwatch_accumulator_formatter__::default_format()
        );
        for (int i=0; i<N; i++) {
            __stopclock_accumulator__<>::scoped_run _(acc);
            // ...
        }


[endsect]

[section:suspend How can I suspend a stopwatch?]

    #include <boost/stopwatches/stopwatch.hpp>
    #include <cmath>
    #include <boost/thread.hpp>


    using namespace boost::stopwatches;
    double res;
    void f1(long j)
    {
        __stopwatch_reporter__<__stopwatch__<> >:: _(BOOST_STOPWATCHES_STOPWATCH_FUNCTION_FORMAT);
        for (long i =0; i< j; i+=1)
            res+=std::sqrt( res+123.456L+i );  // burn some time
        __stopwatch_reporter__<__stopwatch__<> >::scoped_suspend s(_);
        boost::this_thread::sleep(boost::posix_time::milliseconds(200));
    }

[endsect]

[section:stats How to get specific statistics from stopwatches accumulator?]

There are two use cases that coul need to change the statistics associated to a stopwatches accumulator:

# We want to reduce the default reporting and we preffer to adapt the statistics to the reporting
# We want to report other statistics of the samples

For the first case we just need to change the accumulator_set and the format we want to get. Imagin we want to get only the count, sam and mean statistics, no need to calculate the min neither the max.

    using namespace boost::accumulators;

    typedef __stopwatch_reporter__<__stopwatch_accumulator__<__process_real_cpu_clock__,
                accumulator_set<__process_real_cpu_clock__::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean
                    >
                >
      > my_stopwatch_accumulator_reporter;

    int f1(long j)
    {
      static my_stopwatch_accumulator_reporter acc("%c times, sum=%ss, mean=%as\n");
      my_stopwatch_accumulator_reporter::scoped_run _(acc);

      for ( long i = 0; i < j; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }

But what would hapend if we haven't forced the format:

      static my_stopwatch_accumulator_reporter acc;
      my_stopwatch_accumulator_reporter::scoped_run _(acc);

Unfortunately there is no error at compile time. Fortunately, the run-time execution is not undefined and will return 0 for the missing statistics.


[endsect]

[endsect]


[section Formatters]
[section:other How can I make a specific formatter when the default do not satisfy my expectations]

Imagine then that we want to report the `tag::variance(lazy)`. We will need to include the specific accumulator file

    ...
    #include <boost/accumulators/statistics/variance.hpp>
    ...
    typedef __stopwatch_reporter__<__stopwatch_accumulator__<__process_real_cpu_clock__,
                accumulator_set<__process_real_cpu_clock__::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean,
                            tag::variance(lazy)
                    >
                >
    > my_stopwatch_accumulator_reporter;

But what happens if we add new statistics to the accumulator_set that are not taken in account by the default formatter? These statistics will simply be ignored. So we will need to define our own accumulator formatter.

    typedef __stopwatch_reporter__<__stopwatch_accumulator__<__process_real_cpu_clock__,
                accumulator_set<__process_real_cpu_clock__::rep,
                    features<
                            tag::count,
                            tag::sum,
                            tag::mean,
                            tag::variance(lazy)
                    >
                >,
                my_stopwatch_accumulator_formatter
    > my_stopwatch_accumulator_reporter;

Next follow the definition of a formatter taking care of count, sum, mean and variance

    class my_stopwatch_accumulator_formatter {
    public:
        typedef std::string string_type;
        typedef char char_type;
        typedef std::ostream ostream_type;

        static ostream_type &  default_os() {return std::cout;}
        static const char_type* default_format() {
            return "%c times, sum=%ss, mean=%as, variance=%vs\n";
        }
        static int default_places() { return 3; }

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char_type* format,
                                int places, ostream_type & os, system::error_code & ec)
        {
            typedef typename Stopwatch::duration duration_t;
            typename Stopwatch::accumulator accumulator& acc = stopwatch_.accumulated();

            boost::io::ios_flags_saver ifs( os );
            os.setf( std::ios_base::fixed, std::ios_base::floatfield );
            boost::io::ios_precision_saver ips( os );
            os.precision( places );

            for ( ; *format; ++format ) {
                if ( *format != '%' || !*(format+1) || !std::strchr("acsv", *(format+1)) ) {
                    os << *format;
                } else {
                    ++format;
                    switch ( *format ) {
                    case 's':
                        os << boost::chrono::duration<double>(
                                duration_t(accumulators::sum(acc))).count();
                        break;
                    case 'a':
                        os << (accumulators::count(acc)>0)
                                ? boost::chrono::__duration__<double>(duration_t(
                                    duration_t::rep(accumulators::mean(acc)))).count()
                                : 0;
                        break;
                    case 'c':
                        os << accumulators::count(acc);
                        break;
                    case 'v':
                        os << (accumulators::count(acc)>0)
                                ? boost::chrono::__duration__<double>(duration_t(
                                    duration_t::rep(accumulators::variance(acc)))).count()
                                : 0;
                        break;
                    default:
                        assert(0 && "my_stopwatch_accumulator_formatter internal logic error");
                    }
                }
            }
        }
    };



[endsect]

[endsect]


[endsect]
[/===============]
[section Examples]
[/===============]



[section Reporting]



[/============================]
[section stopclock_example.cpp]

Here is the stopclock_example.cpp program supplied with the Boost Chrono library:

[/stopclock_example_cpp]

When the `stopclock<> t` object is created, it starts timing. When it is destroyed at the end of the program, its destructor stops the time counting and displays timing information on cout.

    #include <boost/stopwatches/stopclock.hpp>
    #include <cmath>

    int main()
    {
      boost::stopwatches::__stopclock__<> t;

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }

The output of this program run looks like this:

   wall 0.42 s, user 0.41 s + system 0.00 s = total cpu 0.41 s, (96.3%)

In other words, this program ran in 0.42 seconds as would be measured by a clock on the wall, the operating system charged it for 0.41 seconds of user CPU time and 0 seconds of system CPU time, the total of these two was 0.41, and that represented 96.3 percent of the wall clock time.

['See the source file [@../../example/stopclock_example.cpp example/stopclock_example.cpp]]

[endsect]


[/=============================]
[section stopclock_example2.cpp]

The stopclock_example2.cpp program is the same, except that it supplies additional constructor arguments from the command line:

    #include <boost/stopwatches/stopclock.hpp>
    #include <cmath>

    int main( int argc, char * argv[] )
    {
      const char * format = argc > 1 ? argv[1] : "%t cpu seconds\n";
      int          places = argc > 2 ? std::atoi( argv[2] ) : 2;

      boost::stopwatches::__stopclock__<> t( format, places );

      for ( long i = 0; i < 10000000; ++i )
        std::sqrt( 123.456L ); // burn some time

      return 0;
    }

Here is the output for this program for several sets of command line arguments:

    stopclock_example2
    0.42 cpu seconds

    stopclock_example2 "%w wall clock seconds\n"
    0.41 wall clock seconds

    stopclock_example2 "%w wall clock seconds\n" 6
    0.421875 wall clock seconds

    stopclock_example2 "%t total CPU seconds\n" 3
    0.422 total CPU seconds

['See the source file [@../../example/stopclock_example2.cpp example/stopclock_example2.cpp]]

[endsect]

[/===============================================================]
[section time command]

    #include <boost/stopwatches/stopclock.hpp>
    #include <cstdlib>
    #include <string>
    #include <iostream>

    int main( int argc, char * argv[] )
    {
      if ( argc == 1 )
      {
        std::cout << "invoke: timex [-v] command [args...]\n"
          "  command will be executed and timings displayed\n"
          "  -v option causes command and args to be displayed\n";
        return 1;
      }

      std::string s;

      bool verbose = false;
      if ( argc > 1 && *argv[1] == '-' && *(argv[1]+1) == 'v' )
      {
        verbose = true;
        ++argv;
        --argc;
      }

      for ( int i = 1; i < argc; ++i )
      {
        if ( i > 1 ) s += ' ';
        s += argv[i];
      }

      if ( verbose )
        { std::cout << "command: \"" << s.c_str() << "\"\n"; }

      boost::stopwatches::__stopclock__<> t;

      return std::system( s.c_str() );
    }

['See the source file [@../../example/timex.cpp example/timex.cpp]]

[endsect]
[endsect]



[/
[/================================]
[section:ext_references External Resources]
[/================================]

[variablelist

[
    [[@http://www.open-std.org/jtc1/sc22/wg21 [*C++ Standards Committee's current Working Paper]]]
    [The most authoritative reference material for the library is the C++ Standards Committee's current Working Paper (WP).  20.9 Time utilities "time", 20.4 Compile-time rational arithmetic "ratio", 20.6.7 Other transformations "meta.trans.other"]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm [*N2661 - A Foundation to Sleep On]]]
    [From Howard E. Hinnant, Walter E. Brown, Jeff Garland  and Marc Paterno. Is very informative and provides motivation for key design decisions]
]


[
    [[@http://home.roadrunner.com/~hinnant/issue_review/lwg-defects.html#934 [*LGW 934. duration is missing operator%]]]
    [From Terry Golubiewski. Is very informative and provides motivation for key design decisions]
]

[
    [[@http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#1281 [*LWG 1281. CopyConstruction and Assignment between ratios having the same normalized form]]]
    [From Vicente Juan Botet Escriba.]
]

[
    [[@http://www.digitalmars.com/d/2.0/phobos/std_traits.html#CommonType D programming language -  CommonType trait]]
    [From Andrei Alexandrescu.]
]


]

[endsect]
]

[endsect]
[endsect]

[/=================]
[section:reference Reference ]
[/=================]

[/=============================================]
[section:stopwatches_hpp Header `<boost/stopwatches.hpp>`]
[/=============================================]


    #include <boost/stopwatches/stopwatches.hpp>

[endsect]

[/=============================================]
[section:stopwatches_stopwatches_hpp Header `<boost/stopwatches/stopwatches.hpp>`]
[/=============================================]

This file include all the stopwatches related files except the suspendible related files.

    #include <boost/stopwatches/scoped_stopclock.hpp>
    #include <boost/stopwatches/stopclock.hpp>
    #include <boost/stopwatches/stopclock_accumulator.hpp>
    #include <boost/stopwatches/stopwatch.hpp>
    #include <boost/stopwatches/stopwatch_accumulator.hpp>
    #include <boost/stopwatches/stopwatch_accumulator_formatter.hpp>
    #include <boost/stopwatches/stopwatch_accumulator_time_formatter.hpp>
    #include <boost/stopwatches/stopwatch_formatter.hpp>
    #include <boost/stopwatches/stopwatch_reporter.hpp>
    #include <boost/stopwatches/stopwatch_scoped.hpp>
    #include <boost/stopwatches/time_formatter.hpp>
    #include <boost/stopwatches/t24_hours.hpp>
    #include <boost/stopwatches/t24_hours_formatter.hpp>

[endsect]

[section:other_clocks Other clocks]

[section:suspendible_clock_req `SuspendibleClock` Requirements]

A `SuspendibleClock` is a Clock that in addition supports `suspend`/`resume` operations.

A `SuspendibleClock` must meet the requirements in the following Table.

In this table `C`  denote `clock` types.

[table SuspendibleClock Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`C::suspend()`]   [`void`]  [Suspends the time counting of the clock C.]]
    [[`C::resume()`]   [`void`]  [Resumes the time counting of the clock C.]]
    [[`C::suspended()`]   [__duration__]  [Returns the delay(duration during which the clock has been suspended.]]
]

[section:suspend Static Member Function `suspend()`]

    void suspend( system::error_code & ec = throws() );

[*Effect:] Suspends the SuspendibleClock.

[*Throw:] Any exception the `Clock::now(ec)` function can throw. Otherwise `ec` is set with the correspoding error code set by `Clock::now(ec)`.

[endsect]
[section:resume Static Member Function `resume()`]

    void resume( system::error_code & ec = throws() );

[*Effect:] Resumes the `SuspendibleClock`.

[*Throw:] Any exception the `Clock::now(ec)` can throw. Otherwise `ec` is set with the correspoding error code set by `Clock::now(ec)`.

[endsect]

[section:suspended Static Member Function `suspended()`]

    duration suspended( system::error_code & ec = throws() );

[*Returns:] the cumalative elapsed duration during which the `SuspendibleClock` has been suspendeed.

[*Throw:] Any exception the Clock::now function can throw if `ec == throws()`. Otherwise `ec` is set with the correspoding error code set by `Clock::now(ec)`.

[endsect]

Models of `SuspendibleClock`:

* __suspendible_clock__


[endsect]


[/==================================================================]
[section:scoped_suspend_hpp Header `<boost/stopwatches/scoped_suspend.hpp>`]
[/==================================================================]

    namespace boost { namespace stopwatches {
        template <class Clock> struct is_suspendible;
        template <class Clock> class scoped_suspend;
    }}

[section:is_suspendible Meta Function Class `is_suspendible`]

    template <class Clock>
    struct is_suspendible : mpl:: false_ {};

[endsect]

[section:scoped_suspend Template Class `scoped_suspend`]

    template <class Clock>
    class scoped_suspend {
    public:
        scoped_suspend(system::error_code & ec = throws()) {}
        ~scoped_suspend() {}
    private:
        scoped_suspend(); // = delete;
        scoped_suspend(const scoped_suspend&); // = delete;
        scoped_suspend& operator=(const scoped_suspend&); // = delete;
    };

[endsect]

[endsect]


[/==================================================================]
[section:suspendible_clock_hpp Header `<boost/stopwatches/suspendible_clock.hpp>`]
[/==================================================================]

    namespace boost { namespace stopwatches {

        template <class Clock>
        class suspendible_clock;

        template <class Clock>
        struct is_suspendible<suspendible_clock<Clock> >;

        template <class Clock>
        class scoped_suspend<suspendible_clock<Clock> >;

    }}

[section:suspendible_clock Template Class `suspendible_clock<>`]

Given a __Clock__, __suspendible_clock__ <__Clock__> is a model of __SuspendibleClock__.

    template < class Clock >
    class suspendible_clock {
    public:
        typedef typename Clock::duration                           duration;
        typedef typename Clock::rep                                rep;
        typedef typename Clock::period                             period;
        typedef chrono::__time_point__<suspendible_clock<Clock> >  time_point;
        static const bool is_steady = Clock::is_steady;

        static time_point now( system::error_code & ec = throws() );
        static void suspend( system::error_code & ec = throws() );
        static void resume( system::error_code & ec = throws() );
        static duration suspended(system::error_code & ec = throws());
    };

[section `scoped_suspend` specialization for `suspendible_clock<>`]

        template <class Clock>
        class scoped_suspend<suspendible_clock<Clock> > {
        public:
            scoped_suspend(system::error_code & ec = throws());
            ~scoped_suspend();
        };

[endsect]

[endsect]

[endsect]

[endsect]

[/==================================================]
[section:stopwatches Stopwatches]
[/==================================================]

[section:stopwatch_req `Stopwatch` Requirements]

A Stopwatch measure the amount of time elapsed from a start point in time to the stop point time or the accumulation of them. Stopwatches can in addition be restarted, suspended and resumed.

A Stopwatch must meet the requirements in the following table. In this table `S`, `S1` and `S2` denote stopwatches types. `s` is an instance of `S`.

[table Stopwatch Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`S::clock`]        [A model of __Clock__.]  [The clock associated to this Stopwatch.]]
    [[`S::duration`]        [`S::clock::duration`]  [The __duration__ type of the `clock`.]]
    [[`S::time_point`]        [`S::clock::time_point`]  [The __time_point__ type of the `clock`.]]
    [[`S::scoped_run`]        [`stopwatch_runner<stopwatch<Clock> >`]  [RAI which `start`/`stop` the `stopwatch`.]]
    [[`S::scoped_suspend`]        [`stopwatch_suspender<stopwatch<Clock> >`]  [RAI which `suspend`/`resume` the `stopwatch`.]]
    [[`S::scoped_resume`]        [`stopwatch_resumer<stopwatch<Clock> >`]  [RAI which `resume`/`suspend` the `stopwatch`.]]
    [[`s.start()`]        [`S::time_point`]  [starts a Stopwatch.]]
    [[`s.restart()`]        [`std::pair<S::duration,S::time_point>`]  [restarts a Stopwatch.]]
    [[`s.stop()`]        [`S::duration`]  [stops a Stopwatch.]]
    [[`s.resume()`]        [`S::time_point`]  [resume a Stopwatch.]]
    [[`s.suspend()`]        [`S::duration`]  [suspends a Stopwatch.]]
    [[`s.elapsed()`]        [`S::duration`]  [the elapsed time while the Stopwatch was running.]]
]


[section:start Member Function `start()`]

    time_point start( system::error_code & ec = throws() );

[*Effect:] Starts running the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `throws()`

[endsect]
[section:stop Member Function `stop()`]

    duration stop( system::error_code & ec = throws() );

[*Effect:] Stops running the stopwatch.

[*Returns:] The cummulated elapsed time.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `throws()`

[endsect]
[section:suspend Member Function `suspend()`]

    duration suspend( system::error_code & ec = throws() );

[*Effect:] Suspends the stopwatch.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `throws()`

[endsect]
[section:resume Member Function `resume()`]

    time_point resume( system::error_code & ec = throws() );

[*Effect:] Resumes the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the Clock::now function can throw.

[endsect]

[section:restart Member Function `restart()`]

    time_point restart( system::error_code & ec = throws() );

[*Effect:] `stop`/`start` the stopwatch.

[*Returns:] the starting time point.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `throws()`

[endsect]

[section:elapsed Member Function `elapsed()`]

            duration elapsed(system::error_code & ec = throws()) const;

[*Returns:] the cumulated elapsed time.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `throws()`

[endsect]


Models of `Stopwatch`:

* __stopwatch__
* __stopwatch_accumulator__

[endsect]


[/==================================================]
[section:lightweight_stopwatch_hpp Header `<boost/stopwatches/lightweight_stopwatch.hpp>`]
[/==================================================]


    namespace boost { namespace stopwatches  {
        struct dont_start_t;
        static const dont_start_t dont_start;

        template <class Clock=high_resolution_clock,
                typename Features=void,
                typename Weight=void
        > class __lightweight_stopwatch__;

        typedef <see above> system_lightweight_stopwatch;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef <see above> steady_lightweight_stopwatch;
        #endif
        typedef <see above> high_resolution_lightweight_stopwatch;
    }}

[section:dont_start_t Class `dont_start_t`]

Structure used to don't start a `lightweight_stopwatch` at construction time.

        struct dont_start_t;
        static const dont_start_t dont_start;

[endsect]

[section:lightweight_stopwatch Template Class `lightweight_stopwatch<>`]

`lightweight_stopwatch<>` is a model of a __stopwatch_concept__.

Knowing how long a part of a program takes to execute is useful in both test and production environments.
A __lightweight_stopwatch__ object measures elapsed time. It is recommended to use it with clocks that measure wall clock rather than CPU time since the intended use is performance measurement on systems where total elapsed time is more important than just process or CPU time.

The maximum measurable elapsed time depends on the Clock parameter. The accuracy of timings depends on the
accuracy of timing information provided the Clock, and this could varies a great deal from one clock to another.

        template <class Clock, typename Features, typename Weight> 
        class lightweight_stopwatch {
        public:
            typedef Clock                       clock;
            typedef typename Clock::duration    duration;
            typedef typename Clock::time_point  time_point;
            typedef <see below>                 storage;

            explicit lightweight_stopwatch( storage& st, system::error_code & ec = throws() );
            lightweight_stopwatch( storage& st, const dont_start_t& t );

            ~lightweight_stopwatch();

            time_point start( system::error_code & ec = throws() );
            duration stop( system::error_code & ec = throws() );
            std::pair<duration,time_point> restart( system::error_code & ec = throws() );
            duration suspend( system::error_code & ec = throws() );
            time_point resume( system::error_code & ec = throws() );
            duration elapsed( system::error_code & ec = throws() );
            time_point now( system::error_code & ec = throws() );
            void reset( system::error_code & ec = throws() );

            storage& get_storage( );
            duration lifetime( system::error_code & ec = throws() );

            typedef stopwatch_runner<lightweight_stopwatch<Clock> > scoped_run;
            typedef stopwatch_suspender<lightweight_stopwatch<Clock> > scoped_suspend;
            typedef stopwatch_resumer<lightweight_stopwatch<Clock> > scoped_resume;
            
        };


`storage` is either `Clock::duration` if Features and Weight are void and `accumulators::accumulator_set<typename Clock::duration::rep, Features, Weight>` otherwise.

Only the specificities of this class are documented here. See __stopwatch_concept__ for the common parts.

[section:c1 Constructor `lightweight_stopwatch( storage&, system::error_code &)`]

            explicit lightweight_stopwatch( storage& st, system::error_code & ec = throws() );

[*Effect:] constructs and starts the lightweight_stopwatch.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `throws()`

[endsect]

[section:c2 Constructor `lightweight_stopwatch( storage&, dont_start_t &)`]

            explicit lightweight_stopwatch( storage& st, const dont_start_t& t );

[*Effect:] constructs the lightweight_stopwatch without starting it.

[*Throw:] Nothing.

[endsect]




[section:get_storage Member Function `get_storage()`]

            storage& get_storage();

[*Returns:] the assocaited storage reference.

[*Throw:] Nothing.

[endsect]


[section:reset Member Function `reset()`]

    void reset( );

[*Effect:] Stop the lightweight_stopwatch and reinit the storage.

[*Throw:] Nothing.

[endsect]

[endsect]

[endsect]


[/==================================================]
[section:stopwatch_hpp Header `<boost/stopwatches/stopwatch.hpp>`]
[/==================================================]


    namespace boost { namespace stopwatches  {
        template <class Clock=high_resolution_clock> class __stopwatch__;

        template <class Clock>
        struct stopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef stopwatch_formatter type;
        };

        template <class Clock>
        struct wstopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef wstopwatch_formatter type;
        };

        typedef <see above> system_stopwatch;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef <see above> steady_stopwatch;
        #endif
        typedef <see above> high_resolution_stopwatch;
    }}


[section:stopwatch Template Class `stopwatch<>`]

`stopwatch<>` is a model of a __stopwatch_concept__.

Knowing how long a part of a program takes to execute is useful in both test and production environments.
A __stopwatch__ object measures elapsed time. It is recommended to use it with clocks that measure wall clock rather than CPU time since the intended use is performance measurement on systems where total elapsed time is more important than just process or CPU time.

The maximum measurable elapsed time depends on the Clock parameter. The accuracy of timings depends on the
accuracy of timing information provided the Clock, and this could varies a great deal from one clock to another.

    template <class Clock>
    class stopwatch : 
        private base_from_member<typename Clock::duration>, 
        public lightweight_stopwatch<Clock>
    {
    public:
        explicit stopwatch( system::error_code & ec = throws()  );
        explicit stopwatch( const dont_start_t& t );
        
    };

[section:c1 Constructor `stopwatch( system::error_code &)`]

            explicit stopwatch( system::error_code & ec = throws() );

[*Effect:] constructs and starts the stopwatch.

[*Throw:] Any exception the `Clock::now` function can throw when `ec` is `throws()`

[endsect]

[section:c2 Constructor `stopwatch( dont_start_t &)`]

            explicit stopwatch( const dont_start_t& t );

[*Effect:] constructs the stopwatch without starting it.

[*Throw:] Nothing.

[endsect]

[endsect]

[section:spec `stopwatch_reporter_default_formatter` Specialization]

The `stopwatch_reporter_default_formatter` of a `stopwatch<Clock>` is a `stopwatch_formatter`.

        template <class Clock>
        struct stopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef stopwatch_formatter type;
        };

The `wstopwatch_reporter_default_formatter` of a `stopwatch<Clock>` is a `wstopwatch_formatter`.

        template <class Clock>
        struct wstopwatch_reporter_default_formatter<stopwatch<Clock> > {
            typedef wstopwatch_formatter type;
        };

[endsect]

[section:stopwatch_typedefs `stopwatch` useful typedefs]

The library provides stopwatch short cuts for all the models of __Clock__, replacing clock by stopwatch.

        typedef boost::stopwatches::stopwatch< boost::chrono::system_clock > 
            system_stopwatch;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef boost::stopwatches::stopwatch< boost::chrono::steady_clock > 
            steady_stopwatch;
        #endif
        typedef boost::stopwatches::stopwatch< boost::chrono::high_resolution_clock > 
            high_resolution_stopwatch;

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_accumulator_hpp Header `<boost/stopwatches/stopwatch_accumulator.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <class Clock, 
                    typename Features=accumulators::features<
                        accumulators::tag::count,
                        accumulators::tag::sum,
                        accumulators::tag::min,
                        accumulators::tag::max,
                        accumulators::tag::mean >,
                    typename Weight=void
        > class __stopwatch_accumulator__;

        template <class Clock, class Accumulator>
        struct stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef stopwatch_accumulator_formatter type;
        };

        template <class Clock, class Accumulator>
        struct wstopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef wstopwatch_accumulator_formatter type;
        };

        typedef <see below> system_stopwatch_accumulator;
    #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef <see below> steady_stopwatch_accumulator;
    #endif
        typedef <see below> high_resolution_stopwatch_accumulator;

    }}


[section:stopwatch_accumulator Template Class `stopwatch_accumulator<>`]

A `stopwatch_accumulator<>` is a model of a __stopwatch_concept__ that allows to accumulate the time in several times instead of at once as it is the case of the class __stopwatch__`<>`.

    template <class Clock, typename Features, typename Weight>
    class stopwatch_accumulator
        : private base_from_member<
                      typename accumulators::accumulator_set<
                          typename Clock::duration::rep, Features, Weight
                      > 
                  >,
          public lightweight_stopwatch<Clock,Features,Weight> 
    {
    public:
        stopwatch_accumulator( );
    };

[section:c Constructor `stopwatch_accumulator()`]

    stopwatch_accumulator();

[*Effect:] Initialize the elapsed duration and the times counter to 0. The stopwatch is not started.

[endsect]

[endsect]

[section:spec `stopwatch_reporter_default_formatter` Specialization]

The `stopwatch_reporter_default_formatter` of a `stopwatch_accumulator<Clock>` is a `stopwatch_accumulator_formatter`.

        template <class Clock, class Accumulator>
        struct stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef stopwatch_accumulator_formatter type;
        };

The `wstopwatch_reporter_default_formatter` of a `stopwatch_accumulator<Clock>` is a `wstopwatch_accumulator_formatter`.

        template <class Clock, class Accumulator>
        struct wstopwatch_reporter_default_formatter<stopwatch_accumulator<Clock, Accumulator> > {
            typedef wstopwatch_accumulator_formatter type;
        };

[endsect]


[section:typedefs `stopwatch_accumulator` useful typedefs]

The library provides stopwatch_accumulator shortcuts for all the models of __Clock__, replacing clock by stopwatch_accumulator.

    typedef boost::stopwatches::stopwatch_accumulator< boost::chrono::system_clock > 
        system_stopwatch_accumulator;
    #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
    typedef boost::stopwatches::stopwatch_accumulator< boost::chrono::steady_clock > 
        steady_stopwatch_accumulator;
    #endif
    typedef boost::stopwatches::stopwatch_accumulator< boost::chrono::high_resolution_clock > 
        high_resolution_stopwatch_accumulator;

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_scoped_hpp Header `<boost/stopwatches/stopwatch_scoped.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <class Stopwatch> class stopwatch_runner;
        template <class Stopwatch> class stopwatch_suspender;
        template <class Stopwatch> class stopwatch_resumer;
    }}

Boost.Chrono provides some helper classes ensuring pairwised operations (start/stop, suspend/resume, resule/suspend).

[section:stopwatch_runner Template Class `stopwatch_runner<>`]

This helper class ensures that the start/stop are pairwised. Starts the associated __Stopwatch__ at construction time, and stops it at destruction time.

    template <class Stopwatch> class stopwatch_runner {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_runner(stopwatch & a, system::error_code & ec = throws());
        ~stopwatch_runner();
        stopwatch_runner() = delete;
        stopwatch_runner(const stopwatch_runner&) = delete;
        stopwatch_runner& operator=(const stopwatch_runner&) = delete;
    };

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...
    }

[endsect]
[section:stopwatch_suspender Template Class `stopwatch_suspender<>`]

This helper class ensures that the suspend/resume are pairwised. Suspends the associated __Stopwatch__ at construction time, and resumes it at destruction time.

    template <class Stopwatch> class stopwatch_suspender {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_suspender(stopwatch & a, system::error_code & ec = throws());
        ~stopwatch_suspender();
        stopwatch_suspender() = delete;
        stopwatch_suspender(const stopwatch_suspender&) = delete;
        stopwatch_suspender& operator=(const stopwatch_suspender&) = delete;
    }

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...

         // call to some function we don't want to measure
         {
            stopwatch_suspender<stopwatch_accumulator<> > _(t);
            external_function();
         }
    }

[endsect]

[section:stopwatch_resumer Template Class `stopwatch_resumer<>`]

This helper class ensures that the resume/suspend are pairwised. Resumes the associated __Stopwatch__ at construction time, and suspends it at destruction time.

    template <class Stopwatch> class stopwatch_resumer {
    public:
        typedef Stopwatch stopwatch;
        stopwatch_resumer(stopwatch & a, system::error_code & ec = throws());
        ~stopwatch_resumer();
        stopwatch_resumer() = delete;
        stopwatch_resumer(const stopwatch_resumer&) = delete;
        stopwatch_resumer& operator=(const stopwatch_resumer&) = delete;
    }

Usage

    void f1()
    {
         static stopwatch_accumulator<> t;
         stopwatch_runner<stopwatch_accumulator<> > _(t);
         // ...

         // call to some function we don't want to measure
         {
            stopwatch_suspender<stopwatch_accumulator<> > _(t);

            {
                stopwatch_resumer<stopwatch_accumulator<> > _(t);

            }
         }
    }

[endsect]

[endsect]

[endsect]
[section:reporters Stopwatch Reporters]
[section:formatter_req `Formatter` Requirements]

A Formatter outputs on a given ostream a formatted string combining informations from a Stopwatch and the format and the double precision.

A Formatter must meet the requirements in the following Table.

In this table `F`  denote a Formatter type, `S` is a Stopwatch and `s` is an instance of `S`, `f` is `const char *` , `p` is and int, and `os` is a `std::ostream`, ec is a system::error_code

[table Formatter Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`F::default_os()`]        [std::otream&]  [The output stream.]]
    [[`F::default_places()`]        [`std::size_t`]  [The precision when displaying a double.]]
    [[`F::default_format()`]        [`const char*`]  [The default format.]]
    [[`F::show_time(s,f,p,os,ec)`]        [`S::time_point`]  [outputs on `os` a formatted string combining informations from the Stopwatch `s`, the format `f` and the double precision `p`.]]
]


Models of `Formatter`:

* __basic_stopwatch_formatter__
* __basic_stopwatch_accumulator_formatter__
* __basic_24_hours_formatter__

[endsect]

[section `Formatter` related traits]

        template <class Stopwatch>
        struct stopwatch_reporter_default_formatter {
            typedef <see below> type;
        };

The nested typedef `type` defines the default formatter used by the __stopwatch_reporter__ class when the `Formatter` parameter is not explicit.

[endsect]

[section:reporters_req `Reporter` Requirements]

A `Reporter` provides everything a __Stopwatch__ provides and adds reporting capabilities. The reporting is controleed by two parameters:

A `Reporter` must meet the requirements in the following table in addition of the __Stopwatch__. 
The reporting is controleed by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

And is sent to an output stream.

In this table `R` denote Reporters types. `r` is an instance of `R`, ec is a system::error_code, os is an std::ostream, f is a std::string, p is an int. From the library perspective a Reporter needs to satisfy the following requirements. 

[table Reporter Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`R::stopwatch`]        [A model of __Stopwatch__.]  [The Stopwatch associated to this Reporter.]]

    [[`r.report()`]        [`void`]  [Creates a report.]]
    [[`r.report(ec)`]        [`void`]  [Creates a report.]]
    [[`r.reported()`]        [`bool`]  [The reporting has been done.]]
]

From the user point of view, the reporter provides often construction with any of the parameters controleed the reporting.

[table Open Reporter Requirements
    [[expression]        [return type]  [operational semantics]]
    [[`R r`]        [`R`]  [Creates a Reporter.]]
    [[`R r(ec)`]        [`R`]  [Creates a Reporter.]]

    [[`R r(os)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(os,ec)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(os,f)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(os,f,ec)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(os,f,p)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(os,f,p,ec)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(os,p)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(os,p,ec)`]        [`R`]  [Creates a Reporter.]]

    [[`R r(f)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(f,ec)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(f,p)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(f,p,ec)`]        [`R`]  [Creates a Reporter.]]

    [[`R r(p)`]        [`R`]  [Creates a Reporter.]]
    [[`R r(p,ec)`]        [`R`]  [Creates a Reporter.]]

]

[section:R Member Function `R()`]

    void R(
        [ std::ostream & os ]
        [, const std::string & format]
        [, int places]
        [, system::error_code & ec = throws()]
        );

[*Effect:] Creates a reporter. All the parameters are optional.

[*Throw:] Nothing.

[endsect]

[section:report Member Function `report()`]

    void report(system::error_code & ec = throws());

[*Effect:] Produce a report taking in account the ostream, format and place.

[*Throw:] Any exception the `Formatter::show_time(*this,f,p,os,ec)` function can throw when `ec` is `throws()`.

[endsect]
[section:reported Member Function `reported()`]

    bool reported();

[*Returns:] True if the reportes has ben reported already.

[*Throw:] Nothing.

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_reporter_hpp Header `<boost/stopwatches/stopwatch_reporter.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <class Stopwatch, class Formatter>
        class basic_stopwatch_reporter;

        template <class Stopwatch>
        struct stopwatch_reporter_default_formatter;

        template <class Stopwatch, 
                  class Formatter=typename stopwatch_reporter_default_formatter<Stopwatch>::type>
        class __stopwatch_reporter__;
        
        template <class Stopwatch>
        struct wstopwatch_reporter_default_formatter;

        template <class Stopwatch, 
                  class Formatter=typename wstopwatch_reporter_default_formatter<Stopwatch>::type>
        class wstopwatch_reporter;
    }}

[section:basic_stopwatch_reporter Template Class `basic_stopwatch_reporter<>`]

class `basic_stopwatch_reporter` provides everything a `Stopwatch` provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class basic_stopwatch_reporter : public Stopwatch {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit basic_stopwatch_reporter( system::error_code & ec = throws() );
        explicit basic_stopwatch_reporter( std::ostream & os,
                    system::error_code & ec = throws() );

        explicit basic_stopwatch_reporter( const std::string & format,
                    system::error_code & ec = throws() );
        explicit basic_stopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = throws() );

        explicit basic_stopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = throws() );
        explicit basic_stopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = throws() );

        explicit basic_stopwatch_reporter( int places,
                    system::error_code & ec = throws() );
        explicit basic_stopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = throws() );

        explicit basic_stopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = throws() );
        explicit basic_stopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = throws() );

        ~basic_stopwatch_reporter();

        void report( system::error_code & ec = throws() );
        bool reported() const;


        typedef stopwatch_runner<basic_stopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<basic_stopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<basic_stopwatch_reporter<Stopwatch> > scoped_resume;
    };

[endsect]

[section:stopwatch_reporter Template Class `stopwatch_reporter<>`]

class __stopwatch_reporter__ provides a everything a `Stopwatch` provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class stopwatch_reporter : public basic_stopwatch_reporter<Stopwatch,Formatter> {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit stopwatch_reporter( system::error_code & ec = throws() );
        explicit stopwatch_reporter( std::ostream & os,
                    system::error_code & ec = throws() );

        explicit stopwatch_reporter( const std::string & format,
                    system::error_code & ec = throws() );
        explicit stopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = throws() );

        explicit stopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = throws() );
        explicit stopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = throws() );

        explicit stopwatch_reporter( int places,
                    system::error_code & ec = throws() );
        explicit stopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = throws() );

        explicit stopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = throws() );
        explicit stopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = throws() );

        ~stopwatch_reporter();

        void report( system::error_code & ec = throws() );
        bool reported() const;


        typedef stopwatch_runner<stopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<stopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<stopwatch_reporter<Stopwatch> > scoped_resume;
    };

Usage

    void f1()
    {
        typedef stopwatch_reporter<stopwatch_accumulator<> > accumulator;
        static accumulator t;
        accumulator::scoped_run _(t);
        // ...

        // call to some function we don't want to measure
        {
            accumulator::scoped_suspend _(t);
            external_function();
        }
    }

[endsect]

[section:wstopwatch_reporter Template Class `wstopwatch_reporter<>`]

class `wstopwatch_reporter` provides a everything a `Stopwatch` provides and it adds reporting capabilities that can be invoked in a single line of code. The reporting is controleed by two parameters:

* format : The output format
* places(precision): the number of decimal placess used.

The default places is given by Formatter::default_places().

The default format is given by Formatter::default_format().

    template <class Stopwatch, class Formatter>
    class wstopwatch_reporter : public basic_wstopwatch_reporter<Stopwatch,Formatter> {
    public:
        typedef typename Stopwatch::clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;

        explicit wstopwatch_reporter( system::error_code & ec = throws() );
        explicit wstopwatch_reporter( std::ostream & os,
                    system::error_code & ec = throws() );

        explicit wstopwatch_reporter( const std::string & format,
                    system::error_code & ec = throws() );
        explicit wstopwatch_reporter( std::ostream & os, const std::string & format,
                    system::error_code & ec = throws() );

        explicit wstopwatch_reporter( const std::string & format, int places,
                    system::error_code & ec = throws() );
        explicit wstopwatch_reporter( std::ostream & os, const std::string & format, int places,
                    system::error_code & ec = throws() );

        explicit wstopwatch_reporter( int places,
                    system::error_code & ec = throws() );
        explicit wstopwatch_reporter( std::ostream & os, int places,
                    system::error_code & ec = throws() );

        explicit wstopwatch_reporter( int places, const std::string & format,
                    system::error_code & ec = throws() );
        explicit wstopwatch_reporter( std::ostream & os, int places, const std::string & format,
                    system::error_code & ec = throws() );

        ~wstopwatch_reporter();

        void report( system::error_code & ec = throws() );
        bool reported() const;


        typedef stopwatch_runner<wstopwatch_reporter<Stopwatch> > scoped_run;
        typedef stopwatch_suspender<wstopwatch_reporter<Stopwatch> > scoped_suspend;
        typedef stopwatch_resumer<wstopwatch_reporter<Stopwatch> > scoped_resume;
    };

Usage

    void f1()
    {
        typedef wstopwatch_reporter<stopwatch_accumulator<> > accumulator;
        static accumulator t;
        accumulator::scoped_run _(t);
        // ...

        // call to some function we don't want to measure
        {
            accumulator::scoped_suspend _(t);
            external_function();
        }
    }

[endsect]

[endsect]

[/==================================================]
[section:stopclock_hpp Header `<boost/stopwatches/stopclock.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches {
        template < class Clock, class Formatter > class basic_stopclock;
        template < class Clock, class Formatter > class __stopclock__;
        template < class Clock, class Formatter > class wstopclock;

        typedef <see above> system_stopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef <see above> steady_stopclock;
        #endif
        typedef <see above> high_resolution_stopclock;
        typedef <see above> process_real_cpu_stopclock;
        typedef <see above> process_user_cpu_stopclock;
        typedef <see above> process_system_cpu_stopclock;

        typedef <see above> system_wstopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef <see above> steady_wstopclock;
        #endif
        typedef <see above> high_resolution_wstopclock;
        typedef <see above> process_real_cpu_wstopclock;
        typedef <see above> process_user_cpu_wstopclock;
        typedef <see above> process_system_cpu_wstopclock;
    }}

[section:basic_stopclock Template Class `basic_stopclock<>`]

`basic_stopclock<Clock,Formatter>` template class is a shortcut of `basic_stopwatch_reporter<stopwatch<Clock,Formatter>>`

    template< class Clock, class Formatter>
    class basic_stopclock : public basic_stopwatch_reporter<stopwatch<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit basic_stopclock( system::error_code & ec = throws() );
        explicit basic_stopclock( ostream_type & os,
                    system::error_code & ec = throws() );
        explicit basic_stopclock( const string_type & format,
                    system::error_code & ec = throws() );
        explicit basic_stopclock( int places,
                    system::error_code & ec = throws() );

        basic_stopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = throws() );
        basic_stopclock( const string_type & format, int places,
                    system::error_code & ec = throws() );
        basic_stopclock( ostream_type & os, int places,
                    system::error_code & ec = throws() );
        basic_stopclock( int places, const string_type & format,
                    system::error_code & ec = throws() );

        basic_stopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = throws() );
        basic_stopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = throws() );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[section:stopclock Template Class `stopclock<>`]

A stopclock is a stopwatch with the ability to report elapsed time on an output stream.
`stopclock<Clock>` template class is a shortcut of `basic_stopclock<Clock, typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type>` with a specific default formatter.

    template
        < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class stopclock : public basic_stopclock<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit stopclock( system::error_code & ec = throws() );
        explicit stopclock( ostream_type & os,
                    system::error_code & ec = throws() );
        explicit stopclock( const string_type & format,
                    system::error_code & ec = throws() );
        explicit stopclock( int places,
                    system::error_code & ec = throws() );

        stopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = throws() );
        stopclock( const string_type & format, int places,
                    system::error_code & ec = throws() );
        stopclock( ostream_type & os, int places,
                    system::error_code & ec = throws() );
        stopclock( int places, const string_type & format,
                    system::error_code & ec = throws() );

        stopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = throws() );
        stopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = throws() );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:typedefs `stopclock` useful typedefs]

The library provides stopclock shortcuts for all the models of __Clock__, replacing clock by stopclock.

        typedef boost::stopwatches::stopclock< boost::chrono::system_clock > 
            system_stopwatch_stopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef boost::stopwatches::stopclock< boost::chrono::steady_clock > 
            steady_stopwatch_stopclock;
        #endif
        typedef boost::stopwatches::stopclock< boost::chrono::high_resolution_clock > 
            high_resolution_stopclock;
        typedef boost::stopwatches::stopclock< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_stopclock;
        typedef boost::stopwatches::stopclock< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_stopclock;
        typedef boost::stopwatches::stopclock< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_stopclock;

[endsect]

[section:wstopclock Template Class `wstopclock<>`]

`wstopclock<Clock>` template class is a shortcut of `basic_wstopclock<Clock, typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type>` with a specific default formatter.

    template
        < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class wstopclock : public basic_wstopclock<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit wstopclock( system::error_code & ec = throws() );
        explicit wstopclock( ostream_type & os,
                    system::error_code & ec = throws() );
        explicit wstopclock( const string_type & format,
                    system::error_code & ec = throws() );
        explicit wstopclock( int places,
                    system::error_code & ec = throws() );

        wstopclock( ostream_type & os, const string_type & format,
                    system::error_code & ec = throws() );
        wstopclock( const string_type & format, int places,
                    system::error_code & ec = throws() );
        wstopclock( ostream_type & os, int places,
                    system::error_code & ec = throws() );
        wstopclock( int places, const string_type & format,
                    system::error_code & ec = throws() );

        wstopclock( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = throws() );
        wstopclock( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = throws() );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:wtypedefs `wstopclock` useful typedefs]

The library provides wstopclock shortcuts for all the models of __Clock__, replacing clock by wstopclock.

        typedef boost::stopwatches::wstopclock< boost::chrono::system_clock > 
            system_wstopclock;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef boost::stopwatches::wstopclock< boost::chrono::steady_clock > 
            steady_wstopclock;
        #endif
        typedef boost::stopwatches::wstopclock< boost::chrono::high_resolution_clock > 
            high_resolution_wstopclock;
        typedef boost::stopwatches::wstopclock< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_wstopclock;
        typedef boost::stopwatches::wstopclock< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_wstopclock;
        typedef boost::stopwatches::wstopclock< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_wstopclock;

[endsect]


[endsect]

[/==================================================]
[section:stopclock_accumulator_hpp Header `<boost/stopwatches/stopclock_accumulator.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches {
        template < class Clock, class Formatter >
        class basic_stopclock_accumulator;
        template < class Clock, class Formatter >
        class __stopclock_accumulator__;
        template < class Clock, class Formatter >
        class wstopclock_accumulator;

        typedef <see above> system_stopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef <see above> steady_stopclock_accumulator;
        #endif
        typedef <see above> high_resolution_stopclock_accumulator;
        typedef <see above> process_real_cpu_stopclock_accumulator;
        typedef <see above> process_user_cpu_stopclock_accumulator;
        typedef <see above> process_system_cpu_stopclock_accumulator;

        typedef <see above> system_wstopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef <see above> steady_wstopclock_accumulator;
        #endif
        typedef <see above> high_resolution_wstopclock_accumulator;
        typedef <see above> process_real_cpu_wstopclock_accumulator;
        typedef <see above> process_user_cpu_wstopclock_accumulator;
        typedef <see above> process_system_cpu_wstopclock_accumulator;
    }}

[section:basic_stopclock_accumulator Template Class `basic_stopclock_accumulator<>`]

`basic_stopclock_accumulator<Clock>` template class is a shortcut of `basic_stopwatch_reporter<stopwatch_accumulator<Clock>, typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type>`

    template
        < class Clock=high_resolution_clock
        , class Formatter=
            typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class basic_stopclock_accumulator
        : public basic_stopwatch_reporter<stopwatch_accumulator<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit basic_stopclock_accumulator( system::error_code & ec = throws() );
        explicit basic_stopclock_accumulator( ostream_type & os,
                    system::error_code & ec = throws() );
        explicit basic_stopclock_accumulator( const string_type & format,
                    system::error_code & ec = throws() );
        explicit basic_stopclock_accumulator( int places,
                    system::error_code & ec = throws() );

        basic_stopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = throws() );
        basic_stopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = throws() );
        basic_stopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = throws() );
        basic_stopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = throws() );

        basic_stopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = throws() );
        basic_stopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = throws() );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[section:stopclock_accumulator Template Class `stopclock_accumulator<>`]

`stopclock_accumulator<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>` with a specific formatter.

    template
        < class Clock=high_resolution_clock
        , class Formatter=
            typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class stopclock_accumulator
        : public basic_stopclock_accumulator<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit stopclock_accumulator( system::error_code & ec = throws() );
        explicit stopclock_accumulator( ostream_type & os,
                    system::error_code & ec = throws() );
        explicit stopclock_accumulator( const string_type & format,
                    system::error_code & ec = throws() );
        explicit stopclock_accumulator( int places,
                    system::error_code & ec = throws() );

        stopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = throws() );
        stopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = throws() );
        stopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = throws() );
        stopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = throws() );

        stopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = throws() );
        stopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = throws() );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:typedefs `stopclock_accumulator` useful typedefs]

The library provides stopclock_accumulator shortcuts for all the models of __Clock__, replacing clock by stopclock_accumulator.


        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::system_clock > 
            system_stopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::steady_clock > 
            steady_stopclock_accumulator;
        #endif
        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::high_resolution_clock > 
            high_resolution_stopclock_accumulator;
        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_stopclock_accumulator;
        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_stopclock_accumulator;
        typedef boost::stopwatches::stopclock_accumulator< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_stopclock_accumulator;

[endsect]
[section:wstopclock_accumulator Template Class `wstopclock_accumulator<>`]

`wstopclock_accumulator<Clock>` template class is a shortcut of `stopwatch_reporter<stopwatch<Clock>>` with a specific formatter.

    template
        < class Clock=high_resolution_clock
        , class Formatter=
            typename stopwatch_reporter_default_formatter<stopwatch_accumulator<Clock>>::type
    > class wstopclock_accumulator
        : public basic_wstopclock_accumulator<Clock, Formatter> {
    public:
        typedef Clock clock;
        typedef stopwatch_accumulator<Clock> stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit wstopclock_accumulator( system::error_code & ec = throws() );
        explicit wstopclock_accumulator( ostream_type & os,
                    system::error_code & ec = throws() );
        explicit wstopclock_accumulator( const string_type & format,
                    system::error_code & ec = throws() );
        explicit wstopclock_accumulator( int places,
                    system::error_code & ec = throws() );

        wstopclock_accumulator( ostream_type & os, const string_type & format,
                    system::error_code & ec = throws() );
        wstopclock_accumulator( const string_type & format, int places,
                    system::error_code & ec = throws() );
        wstopclock_accumulator( ostream_type & os, int places,
                    system::error_code & ec = throws() );
        wstopclock_accumulator( int places, const string_type & format,
                    system::error_code & ec = throws() );

        wstopclock_accumulator( ostream_type & os, const string_type & format, int places,
                    system::error_code & ec = throws() );
        wstopclock_accumulator( ostream_type & os, int places, const string_type & format,
                    system::error_code & ec = throws() );


        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]
[section:wtypedefs `wstopclock_accumulator` useful typedefs]

The library provides wstopclock_accumulator shortcuts for all the models of __Clock__, replacing clock by wstopclock_accumulator.

        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::system_clock > 
            system_wstopclock_accumulator;
        #ifdef __BOOST_CHRONO_HAS_CLOCK_STEADY
        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::steady_clock > 
            steady_wstopclock_accumulator;
        #endif
        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::high_resolution_clock > 
            high_resolution_wstopclock_accumulator;
        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::process_real_cpu_clock > 
            process_real_cpu_wstopclock_accumulator;
        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::process_user_cpu_clock > 
            process_user_cpu_wstopclock_accumulator;
        typedef boost::stopwatches::wstopclock_accumulator< boost::chrono::process_system_cpu_clock > 
            process_system_cpu_wstopclock_accumulator;

[endsect]
[endsect]

[/==================================================]
[section:scoped_stopclock_hpp Header `<boost/stopwatches/scoped_stopclock.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches {
        template < class Clock, class Formatter > class scoped_stopclock;
    }}

[section:scoped_stopclock Template Class `scoped_stopclock<>`]

`scoped_stopclock<>`is like a `stopclock<>` but that in addition will output a scoped trace. At construction time it will output

    {{{ <string>

and at destruction time

    }}} <string> <output of stopwatch_reporter>

A typical ussage of this class is

    int f1(long j)
    {
      scoped_stopclock<> _(BOOST_CURRENT_FUNCTION);

      for ( long i = 0; i < j; ++i )
        std::sqrt( 123.456L );  // burn some time

      return 0;
    }


[heading Synopsis]

    template < class Clock=process_cpu_clock
        , class Formatter=typename stopwatch_reporter_default_formatter<stopwatch<Clock>>::type
    > class scoped_stopclock
        : public stopwatch_reporter<stopwatch<Clock>, Formatter> {
    public:
        typedef Clock clock;
        typedef Stopwatch stopwatch;
        typedef Formatter formatter;
        typedef typename Formatter::string_type string_type;
        typedef typename Formatter::char_type char_type;
        typedef typename Formatter::ostream_type ostream_type;

        explicit scoped_stopclock( const std::string& func,
                    system::error_code & ec = throws() );
        scoped_stopclock( const std::string& func, ostream_type & os,
                    system::error_code & ec = throws() );

        scoped_stopclock( const std::string& func, const string_type & format,
                    system::error_code & ec = throws() );

        scoped_stopclock( const std::string& func, int places,
                    system::error_code & ec = throws() );

        scoped_stopclock( const std::string& func, ostream_type & os,
                    const string_type & format,
                    system::error_code & ec = throws() );

        scoped_stopclock( const std::string& func, const string_type & format,
                    int places, system::error_code & ec = throws() );

        scoped_stopclock( const std::string& func, ostream_type & os, int places,
                    system::error_code & ec = throws() );

        scoped_stopclock( const std::string& func, int places,
                    const string_type & format, system::error_code & ec = throws() );

        scoped_stopclock( const std::string& func, ostream_type & os,
                    const string_type & format, int places,
                    system::error_code & ec = throws() );

        scoped_stopclock( const std::string& func, ostream_type & os, int places,
                    const string_type & format, system::error_code & ec = throws() );

        ~scoped_stopclock();

        typedef typename base_type::scoped_run scoped_run;
        typedef typename base_type::scoped_suspend scoped_suspend;
        typedef typename base_type::scoped_resume scoped_resume;
    };

[endsect]

[endsect]
[endsect]
[section:formatters Stopwatch Formatters]

[/==================================================]
[section:stopwatch_formatter_hpp Header `<boost/stopwatches/stopwatch_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_stopwatch_formatter;

        typedef basic_stopwatch_formatter<char> stopwatch_formatter;
        typedef basic_stopwatch_formatter<wchar_t> wstopwatch_formatter;
    }}

[section:basic_stopwatch_formatter Template Class `basic_stopwatch_formatter<>`]

`stopwatch_formatter` is a model of __Formatter__.

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    >
    class basic_stopwatch_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template < class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, 
                               std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%ts\\n", where

* `%d` : the result of elapsed() when the reporting is done.

The time is given using the suffix "s" following the System International d'Unites Std.

[endsect]
[endsect]

[/==================================================]
[section:stopwatch_accumulator_formatter_hpp Header `<boost/stopwatches/stopwatch_accumulator_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        > basic_stopwatch_accumulator_formatter;
        typedef basic_stopwatch_accumulator_formatter<char> stopwatch_accumulator_formatter;
        typedef basic_stopwatch_accumulator_formatter<wchar_t> wstopwatch_accumulator_formatter;
    }}

[section:basic_stopwatch_accumulator_formatter Template Class `basic_stopwatch_accumulator_formatter<>`]

`basic_stopwatch_accumulator_formatter` is a model of __Formatter__

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    class basic_stopwatch_accumulator_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, 
                               std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%c times, sum=%ss, min=%ms, max=%Ms, mean=%as, frequency=%fHz, lifetime=%ls, percentage=%p\%\\n", where

* `%c` : the counter of the number of times the pair srat/stop has been called.
* `%s` : the sum of the samples of elapsed time between the call to start/stop.
* `%m` : the min of the samples of elapsed time between the call to start/stop.
* `%M` : the max of the samples of elapsed time between the call to start/stop.
* `%a` : the mean of the samples of elapsed time between the call to start/stop.
* `%f` : the frequency of calls to start.
* `%l` : the lifetime of the stopwatch_accumulator.
* `%p` : the percentage of time spent by this stopwatch respect to its lifetime.

The time is given using the suffix "s", the frequency is given using the suffix "Hz", both following the System International d'Unites Std.

[endsect]

[section:typedefs `basic_stopwatch_accumulator_formatter` useful typedefs]

The library provides basic_stopwatch_accumulator_formatter shortcuts for char and wchar_t.

        typedef basic_stopwatch_accumulator_formatter<char> 
            stopwatch_accumulator_formatter;
        typedef basic_stopwatch_accumulator_formatter<wchar_t> 
            wstopwatch_accumulator_formatter;


[endsect]
[endsect]
[/==================================================================]
[section:time_formatter_hpp Header `<boost/stopwatches/time_formatter.hpp>`]
[/==================================================================]

    namespace boost { namespace stopwatches {

        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_time_formatter;

        typedef basic_time_formatter<char> time_formatter;
        typedef basic_time_formatter<wchar_t> wtime_formatter;

        template <>
        struct stopwatch_reporter_default_formatter<stopwatch<process_cpu_clock> > {
            typedef time_formatter type;
        };

    } }

[section:basic_time_formatter Template Class `basic_time_formatter<>`]

`basic_time_formatter` is a model of __Formatter__.

    template <typename CharT, typename Traits, class Alloc>
    class basic_time_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_
            , const char * format, int places, std::ostream & os
            , system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "nreal %rs, cpu %cs (%p%), user %us, system %ss\\n", where

* `%r` : real process clock
* `%u` : user process clock
* `%s` : system process clock
* `%c` : user+system process clock
* `%p` : percentage (user+system)/real process clock

All the units are given using the suffix "s" following the System International d'Unites Std.

[endsect]

[section:typedefs `basic_time_formatter` useful typedefs]

The library provides basic_time_formatter shortcuts for char and wchar_t.

        typedef basic_time_formatter<char> time_formatter;
        typedef basic_time_formatter<wchar_t> wtime_formatter;

[endsect]

[section:spec `stopwatch_reporter_default_formatter` Specialization]

        template <>
        struct stopwatch_reporter_default_formatter<stopwatch<process_cpu_clock> > {
            typedef time_formatter type;
        };

[endsect]


[endsect]

[/==================================================]
[section:stopwatch_accumulator_time_formatter_hpp Header `<boost/stopwatches/stopwatch_accumulator_time_formatter.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches  {
        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        > basic_stopwatch_accumulator_time_formatter;
        typedef basic_stopwatch_accumulator_time_formatter<char> stopwatch_accumulator_time_formatter;
        typedef basic_stopwatch_accumulator_time_formatter<wchar_t> wstopwatch_accumulator_time_formatter;
    }}

[section:basic_stopwatch_accumulator_time_formatter Template Class `basic_stopwatch_accumulator_time_formatter<>`]

`basic_stopwatch_accumulator_time_formatter` is a model of __Formatter__

    template <
        typename CharT=char,
        typename Traits=std::char_traits<CharT>,
        class Alloc=std::allocator<CharT>
    class basic_stopwatch_accumulator_time_formatter {
    public:
        typedef std::basic_string<CharT,Traits,Alloc> string_type;
        typedef CharT char_type;
        typedef std::basic_ostream<CharT,Traits> ostream_type;
        static ostream_type &  default_os();
        static const char_type * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_, const char * format, int places, 
                               std::ostream & os, system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%c times, sum=%s, min=%m, max=%M, mean=%a, frequency=%fHz, lifetime=%ls, percentage=%p\%\\n|real %rs, cpu %cs (%p%), user %us, system %ss", where

The part before the '|' corresponds to the accumulator format and the part after corresponds to the times format, which will be used for the sum, max, min and mean statistics.

* `%c` : the counter of the number of times the pair srat/stop has been called.
* `%s` : the sum of the samples of elapsed time between the call to start/stop.
* `%m` : the min of the samples of elapsed time between the call to start/stop.
* `%M` : the max of the samples of elapsed time between the call to start/stop.
* `%a` : the mean of the samples of elapsed time between the call to start/stop.
* `%f` : the frequency of calls to start.
* `%l` : the lifetime of the stopwatch_accumulator.
* `%p` : the percentage of time spent by this stopwatch respect to its lifetime.

* `%r` : real process clock
* `%u` : user process clock
* `%s` : system process clock
* `%c` : user+system process clock
* `%p` : percentage (user+system)/real process clock

The time is given using the suffix "s", the frequency is given using the suffix "Hz", both following the System International d'Unites Std.


[endsect]

[section:typedefs `basic_stopwatch_accumulator_time_formatter` useful typedefs]

The library provides basic_stopwatch_accumulator_time_formatter shortcuts for char and wchar_t.

        typedef basic_stopwatch_accumulator_time_formatter<char> 
            stopwatch_accumulator_time_formatter;
        typedef basic_stopwatch_accumulator_time_formatter<wchar_t> 
            wstopwatch_accumulator_time_formatter;


[endsect]
[endsect]

[/==================================================]
[section:t24_hours_hpp Header `<boost/stopwatches/t24_hours.hpp>`]
[/==================================================]

    namespace boost { namespace stopwatches {
        class t24_hours;
    }}

[section:t24_hours Class `t24_hours`]

`t24_hours` helper class decompose a duration in days, hours, minutes, seconds and nanoseconds. It can be used through its static functions or creating an instance and using its fields.

    class t24_hours {
    public:
        typedef boost::chrono::duration<boost::int_least32_t, __ratio__<24*3600> > days;
        typedef boost::chrono::hours hours;
        typedef boost::chrono::minutes minutes;
        typedef boost::chrono::seconds seconds;
        typedef boost::chrono::nanoseconds nanoseconds;
        
        template <class Rep, class Period>
        static days get_days(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static hours get_hours(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static minutes get_minutes(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static seconds get_seconds(const boost::chrono::duration<Rep, Period>& d);

        template <class Rep, class Period>
        static nanoseconds get_nanoseconds(const boost::chrono::duration<Rep, Period>& d);

        days days_;
        hours hours_;
        minutes minutes_;
        seconds seconds_;
        nanoseconds nanoseconds_;

        template <class Rep, class Period>
            explicit t24_hours(const boost::chrono::duration<Rep, Period>& d);
    };

[endsect]
[endsect]

[/==================================================================]
[section:t24_hours_formatter_hpp Header `<boost/stopwatches/t24_hours_formatter.hpp>`]
[/==================================================================]


    namespace boost { namespace stopwatches {

        template <
            typename CharT=char,
            typename Traits=std::char_traits<CharT>,
            class Alloc=std::allocator<CharT>
        >
        class basic_24_hours_formatter;

        typedef basic_24_hours_formatter<char> t24_hours_formatter;
        typedef basic_24_hours_formatter<wchar_t> wt24_hours_formatter;

    } }

[section:basic_24_hours_formatter Template Class `basic_24_hours_formatter<>`]

`basic_24_hours_formatter` is a model of __Formatter__.

    template <typename CharT, typename Traits, class Alloc>
    class basic_24_hours_formatter {
    public:
        static std::ostream &  default_os();
        static const char * default_format();
        static int default_places();

        template <class Stopwatch >
        static void show_time( Stopwatch & stopwatch_
            , const char * format, int places, std::ostream & os
            , system::error_code & ec);
    };

The default places is given by default_places and is 3.

The default format is "%d days(s) %h:%m:%s.%n\\n", where

* `%d` : days
* `%h` : hours
* `%m` : minutes
* `%s` : seconds
* `%n` : nanoseconds

[endsect]

[section:typedefs `basic_24_hours_formatter` useful typedefs]

The library provides basic_24_hours_formatter shortcuts for char and wchar_t.

        typedef basic_24_hours_formatter<char> t24_hours_formatter;
        typedef basic_24_hours_formatter<wchar_t> wt24_hours_formatter;

[endsect]

[endsect]

[endsect]

[endsect]

[/=================]
[section Appendices]
[/=================]
[/==================================]
[section:history Appendix A: History]
[/==================================]

[section [*Version 0.2.0, Feb 6, 2011] ]

[*Features:]

* Adaptation to new Boost.Chrono inteface.

[endsect]


[section [*Version 0.1.0, September 10, 2010] ]

[*Features:]

* Extraction from Boost.Chrono of Boost.Stopwatches

[endsect]


[endsect]

[/======================================]
[section:rationale Appendix B: Rationale]

[heading How reliable are these measures?]

[/note this section need to be reworked, the ideas are there, but ...]


There are three cases which can lead to get unreliable measures:

* It is not possible to measure events that transpire at rates of the same order of magnitude as the clock's precision with any reliability.  For example, a 10ms clock cannot be used reliably to measure elapsed times of tens of milliseconds.  The library provides a [high_resolution_clock] that gives you the highest resolution time available on your platform.  That will give the best precision, but can only be used for reliable measurement of events that elapse about an order of magnitude slower than that clock's precision.


``
#include <boost/chrono/chrono.hpp>
    ...
    __stopclock__<__high_resolution_clock__> _;
``

* Using a process clock in a multithreaded application will give elapsed time for the process as a whole, including threads other than the calling thread.  To get time elapsed for a specific thread, use the supplied __thread_clock__ which returns time elapsed for the calling thread only, if supported by the platform.

* When stopclocks are nested, usually from stopclocks appearing in each of several nested function calls, the overhead of the stopclock processing begins to be significant relative to run time of the code being measured.  The innermost measurements remain accurate, but those in the outermost layers can measure too much overhead to be trustworthy.

* Nested stopclocks (usually nested function calls where each function contains a stopclock). When the nesting is deep enough, the cumulative overhead of all the stopclock functionality make the data unreliable except for the inner-most trace points. The question is, how much time is related to the application code we want to measure and how much to the fact we are meassuring and logging in inner blocks?


Most of the stopclock overhead is likely due to logging. There are two things we can do to make the difference :

* Don't flush log information while measuring elapsed time.  A __stopwatch_accumulator__ can make that possible, because it don't report until all the measures have been compiled and then report some statistics.  Alternatively, an asynchronous stream would permit normal logging but by a thread other than the one being measured.

* Add a mechanism to track the difference between the application time and stopclock time.  If a __Clock__ models __SuspendibleClock__ and its precision is sufficiently fine, this mechanism could suspend the __Clock_s__ counting while reporting measurements and resume it thereafter.

[/
    stopclock<suspendible_clock<Clock> > _;


See the performances section for more deep details.
]


[endsect]

[/======================================================]
[section:implementation Appendix C: Implementation Notes]



[endsect]

[/======================================================]
[section:faq Appendix D: FAQ]


[heading Why does stopwatch_reporter only display millisecond place precision when the underlying Clock has nanosecond precision?]

To avoid giving the impression of precision where none exists. See Caveat emptor. You can always specify additional decimal places if you want to live dangerously.

[heading Why does stopwatch_reporter sometimes report more cpu seconds than real seconds?]

Ask your operating system supplier. The results have been inspected with a debugger, and both for Windows and Linux, that's what the OS appears to be reporting at times.

[heading  Can I obtain statistics of the time elapsed between calls to a function?]

The library does not provides this feature.

[heading What happens if I press Ctrl+C and program terminates? What log would Boost.Stopwatches output?]


[endsect]

[/====================================================]
[section:acknowledgements Appendix E: Acknowledgements]

The library's started from the Beman Dawes `timer<>`, `process_clock`, `process_timer`, `run_timer` classes which are now deprecated and replaced by the __stopwatch__, `process_cpu_clock` and `stopclock` classes.

Thanks to Adrew Chinoff for its multiple suggestion on __stopwatch_accumulator__, and helping me to polish the documentation.

Thanks to Tom Tan for reporting some compiler issues with MSVC V10 beta and MinGW-gcc-4.4.0 and for the many suggestion he did concerning the __stopwatch__, __lightweight_stopwatch__, and __stopclock__ classes and a deep help with wide characters implementation.

Thanks to Ronald Bock for reporting Valgind issues and for the many suggestion he did concerning the documentation.

[endsect]

[/====================================================]
[section:tests  Appendix F: Tests]

In order to test you need to do.

    bjam libs/stopwatches/test

You can also run a specific suite of test by doing

    cd libs/stopwatches/test
    bjam stopwatch


[section stopwatch]
[table
    [[Name]                         [kind]          [Description]           [Result] [Ticket]]
    [[test_min_max]               [compile]           [test compilation succeeds in the presence of macros min and max.]                   [Pass]   [#]]
    [[stopwatch_example]               [run]           [...]                   [Pass]   [#]]
    [[scoped_stopwatch_example]               [run]           [...]                   [Pass]   [#]]
    [[stopwatch_accumulator_example] [run]   [...]                   [Pass]   [#]]
    [[specific_stopwatch_accumulator_example] [run]   [...]                   [Pass]   [#]]
    [[stopclock_example]      [run]          [...]                   [Pass]   [#]]
    [[stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[nested_stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[loop_stopclock_accumulator_example]      [run]          [...]                   [Pass]   [#]]
    [[t24_hours_example]      [run]          [...]                   [Pass]   [#]]
    [[scoped_stopclock_example]      [run]          [...]                   [Pass]   [#]]
    [[timex]      [link]          [...]                   [Pass]   [#]]
    [[stopclock_constructor_overload_test]      [run]          [...]                   [Pass]   [#]]
    [[wstopclock_constructor_overload_test]      [run]          [...]                   [Pass]   [#]]

]
[endsect]

[endsect]
[/=====================================]
[section:tickets  Appendix G: Tickets]

[table
    [[Ticket]             [Description]          [Resolution] [State]]
    
    [[1]    [suspend doesn't works: partial_ not initialized] [initialize with duration::zero()]                  [Closed]]
    [[2]    [suspend doesn't works: elapsed doesn't take care of partial_] [take care of partial]                  [Closed]]
    [[3]    [suspend doesn't works: bad use of system::error_code & ec] [replace by system::error_code ec]                  [Closed]]
    [[4]    [Use of Specific formatters doesn't works] []                  [Closed]]

    [[5]    [boost/chrono/scoped_suspend.hpp(31) : warning C4520: 'boost::chrono::scoped_suspend<Clock>' : multiple default constructors specified
] [Remove the default constructor deletion ]                  [Closed]]
    [[6]    [suspendible_clock_test doesn't works in my mingw environement] [(issue with tss)]                  [*Open*]]
    [[7]    [error_code not initialized] [Use ec.clear() before throwing a exception.]                  [Closed]]
    [[8]    [Valgrind issue: Conditional jump or move depends on uninitialised value(s)] [Replace the test]                  [Closed]]
    [/[#]    [XXXX] [XXXX]                  [Closed]]
]





[endsect]

[/=====================================]
[section:perf  Appendix H: Performances]
[/=====================================]


We have run some program changing how the reporting is done.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

The programs are either single-threaded or multi-threaded.

Two kind of inner functions are used: recursive or non recursive. In order to test the influence of nesting reports, the non recursive functions use up to 10 nesting levels, depending on its parameter.

the function at level n is defined as follows

    void fn(long v) {
        // reporting or not
        stopclock<> _;
        // burn some time
        for ( long i = 0; i < v; ++i )
            res+=std::sqrt( res+123.456L+i );  // burn some time
        if (v==0) return;

        if (v%(n-1)==0) fn-1(v-1);
        if (v%(n-2)==0) fn-2(v-1);
        ...
        f1(v-1);
    }

This gives a variable number in nesting reporting depending on the parameter, with a variable lifetime.

[heading Single-Threaded Recursive function]

We have run the same program and changed how the reporting is done.

The programm creates two thread of execution. the thread entry point calls a function which makes some calculation depending on its parameter and call recursivelly itself decreasing the parameter.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

[heading Multi-Threaded Recursive function]

We have run the same program and changed how the reporting is done.

The programm creates two thread of execution. the thread entry point calls a function which makes some calculation depending on its parameter and call recursivelly itself decreasing the parameter.

NONE: no report is done on the inner function
HIGH: every call to the recursive function is reported using an stopclock
SUSPEND: every call to the recursive function is reported using a using an stopclock on a suspendible clock
ACCU: every call to the recursive function is tracked using a stopclock_accumulator

We have run the programm with two different clocks, high_resolution_clock and thread_clock.

[endsect]

[/=====================================]
[section:todo  Appendix I: Future plans]
[/=====================================]
[heading Tasks to do]

* Complete documentation
* Fully implement error handling, with test cases.
* Fix open isues.

[endsect]
[endsect]
