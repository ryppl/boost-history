<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Filesystem Reference
</title>
<link rel="stylesheet" type="text/css" href="../../../doc/html/minimal.css">
</head>

<body>

<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="933">
  <tr>
    <td width="277">
<a href="../../../index.htm">
<img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" width="277" height="86" border="0"></a></td>
    <td width="633" align="middle">
    <font size="7">Filesystem Library<br>
    Version 3<br>
&nbsp;</font></td>
  </tr>
</table>

<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="100%">
  <tr>
    <td><a href="../../../index.htm">Boost Home</a>
    &nbsp;&nbsp;&nbsp; <a href="index.htm">Library Home</a>
    &nbsp; &nbsp; <a href="index.htm#tutorial">Tutorial</a>
    &nbsp; &nbsp; <a href="reference.html">Reference</a>
    &nbsp;&nbsp; <a href="faq.htm">FAQ</a>
    &nbsp;&nbsp; <a href="v3.html"> V3 Introduction</a>
    </td>
  </tr>
</table>

<h1>Reference Documentation</h1>

<h2><a name="TOC">Table of Contents</a></h2>

<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
  <tr>
    <td width="33%" valign="top"><a href="#Introduction">Introduction</a><br>
    <a href="#Definitions">Definitions</a><br>
    <a href="#Header-filesystem-synopsis">
    Header &lt;filesystem&gt; synopsis</a><br>
    <a href="#Error-reporting">Error reporting</a><br>
    <a href="#class-path">Class path</a><br>
    &nbsp;&nbsp;&nbsp;
<a href="#Pathname-formats">Pathname formats</a><br>
    &nbsp;&nbsp;&nbsp;
<a href="#Pathname-grammar">Pathname grammar</a><br>
    &nbsp;&nbsp;&nbsp;
<a href="#Input-conversion">Filename conversion</a><br>
    &nbsp;&nbsp;&nbsp; <a href="#path-constructors">path constructors</a><br>
&nbsp;&nbsp;&nbsp; <a href="#path-assignments">path assignments</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-appends">path appends</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-modifiers">path modifiers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-decompositions">path observers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-iterators">path iterators</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-deprecated-functions">path deprecated functions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-non-member-functions">path non-member functions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-inserter-extractor">path inserters and extractor</a>s<span style="background-color: #FFFFFF"><br>
</span> &nbsp;<a href="#Class-filesystem_error">Class filesystem_error</a><br>
&nbsp;&nbsp;&nbsp; <a href="#filesystem_error-members">filesystem_error 
    constructors</a><br>
&nbsp;&nbsp;&nbsp; f<a href="#filesystem_error-path1">ilesystem_error path1</a><br>
&nbsp;&nbsp;&nbsp; <a href="#filesystem_error-path2">filesystem_error path2</a><br>
&nbsp;&nbsp;&nbsp; <a href="#filesystem_error-what">filesystem_error what</a><br>
<a href="#Class-directory_entry">Class directory_entry</a><br>
&nbsp;&nbsp;&nbsp;
<a href="#directory_entry-constructors">directory_entry constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#directory_entry-modifiers">directory_entry modifiers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#directory_entry-observers">directory_entry observers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#directory_entry-comparisons">directory_entry comparisons</a><br>
<a href="#Class-directory_iterator">Class  directory_iterator</a><br>
&nbsp;&nbsp;&nbsp; <a href="#directory_iterator-members">directory_iterator 
    members</a><br>
<a href="#Class-recursive_directory_iterator">Class recursive_directory_iterator</a><br>
    <a href="#file_status">Class 
    file_status</a><br>
    &nbsp;</td>
    <td width="33%" valign="top">
    <a href="#Operational-functions">
    Operational functions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#complete">complete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#copy_file">copy_file</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#create_directories">create_directories</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#create_directory">create_directory</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#create_hard_link">create_hard_link</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#create_symlink">create_symlink</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#current_path">current_path</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#exists">exists</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#equivalent">equivalent</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#file_size">file_size</a><br>
&nbsp;&nbsp;&nbsp;&nbsp i<a href="#initial_path">nitial_path</a><br>
&nbsp;&nbsp;&nbsp;&nbsp i<a href="#is_directory">s_directory</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#is_empty">is_empty</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#is_other">is_other</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#is_regular_file">is_regular_file</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#is_symlink">is_symlink</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#last_write_time">last_write_time</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#read_symlink">read_symlink</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#remove">remove</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#remove_all">remove_all</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#rename">rename</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#resize_file">resize_file</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#space">space</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#status">status</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#status_known">status_known</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#symlink_status">symlink_status</a><br>
&nbsp;&nbsp;&nbsp;&nbsp <a href="#system_complete">system_complete</a></td>
    <td width="34%" valign="top">
    <a href="#header-fstream">Additions 
    to header &lt;fstream&gt;</a><br>
<a href="#Suggestions-for-fstream">Suggestions for <code>&lt;fstream&gt;</code></a><code><br>
&nbsp; </code>
<a href="#Suggestions-for-fstream">&nbsp;implementations</a><br>
<a href="#Path-decomposition-table">Path decomposition table</a><br>
<a href="#Acknowledgements">Acknowledgements</a><br>
<a href="#References">References</a><br>
&nbsp;</td>
  </tr>
</table>

<h2><a name="Introduction">Introduction</a></h2>
<p>Some behavior is specified by reference to ISO/IEC 9945:2003, <i>
<a href="http://www.unix.org/single_unix_specification/">POSIX</a></i>. How such behavior is actually implemented is unspecified.</p>
<blockquote>
<p>[<i>Note:</i> This constitutes an &quot;as if&quot; rule for implementation of 
operating system dependent behavior. Presumably implementations will usually call native 
operating system API's. <i>--end note</i>]</p>
</blockquote>
<p>Implementations are encouraged, but not required, to support such behavior 
 
as it is defined by <i>POSIX</i>. Implementations shall document any 
behavior that differs from the <i>POSIX</i> defined behavior. Implementations that do not support exact <i>POSIX</i> behavior are 
encouraged to provide behavior as close to <i>POSIX</i> behavior as is reasonable given the 
limitations of actual operating systems and file systems. If an implementation cannot provide any 
reasonable behavior, the implementation shall report an error in an 
implementation-defined manner.</p>
<blockquote>
<p>[<i>Note:</i> Such errors might be reported by an #error directive, a <code>
static_assert</code>, a <code>filesystem_error</code> exception, a special 
return value, or some other manner. <i>--end note</i>]</p>
</blockquote>
<p>Specific operating systems such as <i>OpenMVS</i>,
<i>UNIX</i>, and <i>Windows</i> are mentioned only for purposes of illustration or to 
give guidance to implementers. No slight to other operating systems is implied 
or intended.</p>
<p>The <i>Effects</i> and <i>Postconditions</i> of functions described in this 
reference 
may not be achieved in 
the presence of <a href="#Race-condition">race conditions</a>. No diagnostic is required.</p>
<p>If the possibility of race conditions makes it unreliable for a program to 
test for a precondition before calling a function described in this clause, <i>
Requires</i> is not specified for the condition. Instead, the condition is 
specified as a <i>Throws</i> condition.</p>
<blockquote>
<p>[<i>Note:</i> As a design practice, preconditions are not specified when it 
is unreasonable for a program to detect them prior to calling the function. <i>
-- end note</i>]</p>
</blockquote>
<h3><a name="Definitions">Definitions</a></h3>
<p>The following definitions  apply throughout this reference documentation:</p>
<p><i><a name="File">File</a>: </i>An object that can be written to, or read from, or both. A file 
has certain attributes, including type. Common types of files include regular files 
and directories. Other types of files, such as symbolic links, may be supported by the 
implementation.</p>
<p><i><a name="File-system">File system</a>:</i> A collection of files and certain of their attributes.</p>
<p><i><a name="Filename">Filename</a>:</i> The name of a file. The format is as 
specified by the <i>POSIX
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_169">
Filename</a></i> base definition.</p>
<p><i><a name="Path">Path</a>:</i> A sequence of elements that identify 
a location within a filesystem. The elements are the <i>root-name</i>, <i>
root-directory</i>, and each successive <i>filename</i>. See
<a href="#Pathname-grammar">Pathname grammar</a>.</p>
<p><i><a name="Pathname">Pathname</a>: </i>A character string that represents a 
path.</p>
<p><i><a name="Link">Link</a>: </i>A directory entry object that associates a 
filename with a file. On some file systems, several directory entries can 
associate names with the same file.</p>
<p><i><a name="Hard-link">Hard link</a>:</i> A link to an existing file. Some 
file systems support multiple hard links to a file. If the last hard link to a 
file is removed, the file itself is removed.</p>
<blockquote>
<p>[<i>Note:</i> A hard link can be thought of as a shared-ownership smart 
pointer to a file.<i> -- end note</i>]<i> </i></p>
</blockquote>
<p><i><a name="Symbolic-link">Symbolic link</a>: </i>A type of file with the 
property that when the file is encountered during pathname resolution, a string 
stored by the file is used to modify the pathname resolution.</p>
<blockquote>
<p>[<i>Note:</i> A symbolic link can be thought of as a raw pointer to a file. 
If the file pointed to does not exist, the symbolic link is said to be a 
&quot;dangling&quot; symbolic link.<i> -- end note</i>]<i> </i></p>
</blockquote>
<p><i><a name="Slash">Slash</a>:</i> The character <tt>'/'</tt>, also known as 
solidus.</p>
<p><i><a name="Dot">Dot</a>:</i> The character '.', also known as period.</p>
<p><i><a name="Race-condition">Race condition</a>:</i> The condition that occurs 
when multiple threads, processes, or computers interleave access and 
modification of 
the same object within a file system.</p>
<h3><a name="Header-filesystem-synopsis">Header <code>&lt;boost/filesystem&gt;</code> synopsis</a></h3>
<pre>  namespace boost
  {
    namespace filesystem
    {
      class <a href="#Class-template-path">path</a>;

      void swap(path&amp; lhs, path&amp; rhs);

      bool operator==(const path&amp; lhs, const path&amp; rhs);
      bool operator!=(const path&amp; lhs, const path&amp; rhs);
      bool operator&lt; (const path&amp; lhs, const path&amp; rhs);
      bool operator&lt;=(const path&amp; lhs, const path&amp; rhs);
      bool operator&gt; (const path&amp; lhs, const path&amp; rhs);
      bool operator&gt;=(const path&amp; lhs, const path&amp; rhs);

      path operator/ (const path&amp; lhs, const path&amp; rhs);

      std::ostream&amp;  operator&lt;&lt;( std::ostream&amp; os, const path&amp; p );
      std::wostream&amp; operator&lt;&lt;( std::wostream&amp; os, const path&amp; p );
      std::istream&amp;  operator&gt;&gt;( std::istream&amp; is, path&amp; p );
      std::wistream&amp; operator&gt;&gt;( std::wistream&amp; is, path&amp; p )

      <span style="background-color: #FFFFFF">class <a href="#Class-filesystem_error">filesystem_error</a>;</span><span style="background-color: #FFFF00">
</span>      
      <span style="background-color: #FFFFFF">class <a href="#Class-directory_entry">directory_entry</a>;

</span>      class <a href="#Class-directory_iterator">directory_iterator</a>;

      class <a href="#Class-recursive_directory_iterator">recursive_directory_iterator</a>;

      enum <a name="file_type">file_type</a> { status_error, file_not_found, regular_file, directory_file,
                       symlink_file, block_file, character_file, fifo_file, socket_file,
                       type_unknown
                     };

      class <a href="#file_status">file_status</a>;

      <span style="background-color: #FFFFFF">struct <a name="space_info">space_info</a>  // returned by </span><a href="#space" style="text-decoration: none"><span style="background-color: #FFFFFF">space</span></a><span style="background-color: #FFFFFF"> function
      {
        uintmax_t capacity;
        uintmax_t free; 
        uintmax_t available; // free space available to a non-privileged process
      };

      BOOST_SCOPED_ENUM_START(<a name="copy_option">copy_option</a>)
      {
        fail_if_exists,
        overwrite_if_exists
      };
      BOOST_SCOPED_ENUM_END

      // <a href="#Operational-functions">operational functions</a>

</span>      path         <a href="#complete">complete</a>(const path&amp; p, const path&amp; base, system::error_code&amp; ec);
      path         <a href="#complete">complete</a>(const path&amp; p, system::error_code&amp; ec);

      void         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to);
      void         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, system::error_code&amp; ec);
      void         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, BOOST_SCOPED_ENUM(<a href="#copy_option">copy_option</a>) option);
      void         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, BOOST_SCOPED_ENUM(<a href="#copy_option">copy_option</a>) option,
                             system::error_code&amp; ec);

      bool         <a href="#create_directories">create_directories</a>(const path&amp; p);
      bool         <a href="#create_directories">create_directories</a>(const path&amp; p, system::error_code&amp; ec);

      bool         <a href="#create_directory">create_directory</a>(const path&amp; p);
      bool         <a href="#create_directory">create_directory</a>(const path&amp; p, system::error_code&amp; ec);

      void         <a href="#create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; from);
      void         <a href="#create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; from, system::error_code&amp; ec);

<span style="background-color: #FFFFFF">      void         <a href="#create_symlink">create_symlink</a>(const path&amp; to, const path&amp; from);
      void         <a href="#create_symlink">create_symlink</a>(const path&amp; to, const path&amp; from</span>, system::error_code&amp; ec<span style="background-color: #FFFFFF">);

</span>      path         <a href="#current_path">current_path</a>();
      path         <a href="#current_path">current_path</a>(system::error_code&amp; ec);
      void         <a href="#current_path">current_path</a>(const path&amp; p);
      void         <a href="#current_path">current_path</a>(const path&amp; p, system::error_code&amp; ec);

      bool         <a href="#exists-path">exists</a>(file_status s);
      bool         <a href="#exists-path">exists</a>(const path&amp; p);
      bool         <a href="#exists-path">exists</a>(const path&amp; p, system::error_code&amp; ec);

      bool         <a href="#equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2);
      bool         <a href="#equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2, system::error_code&amp; ec);

      <span style="background-color: #FFFFFF; ">uintmax_t</span>    <a href="#file_size">file_size</a>(const path&amp; p);
      <span style="background-color: #FFFFFF; ">uintmax_t</span>    <a href="#file_size">file_size</a>(const path&amp; p, system::error_code&amp; ec);

      const path&amp;  <a href="#initial_path">initial_path</a>();
      const path&amp;  <a href="#initial_path">initial_path</a>(system::error_code&amp; ec);

      bool         <a href="#is_directory">is_directory</a>(file_status s);
      bool         <a href="#is_directory2">is_directory</a>(const path&amp; p);
      bool         <a href="#is_directory2">is_directory</a>(const path&amp; p, system::error_code&amp; ec);

      bool         <a href="#is_empty">is_empty</a>(const path&amp; p);
      bool         <a href="#is_empty">is_empty</a>(const path&amp; p, system::error_code&amp; ec);

      bool         <a href="#is_other">is_other</a>(file_status s);
      bool         <a href="#is_other2">is_other</a>(const path&amp; p,);
      bool         <a href="#is_other2">is_other</a>(const path&amp; p, system::error_code&amp; ec);

      bool         <a href="#is_regular_file">is_regular_file</a>(file_status s); 
      bool         i<a href="#is_regular_file2">s_regular_file</a>(const path&amp; p);
      bool         i<a href="#is_regular_file2">s_regular_file</a>(const path&amp; p, system::error_code&amp; ec);

      bool         <a href="#is_symlink">is_symlink</a>(file_status s);
      bool         <a href="#is_symlink2">is_symlink</a>(const path&amp; p);
      bool         <a href="#is_symlink2">is_symlink</a>(const path&amp; p, system::error_code&amp; ec);

      std::time_t  <a href="#last_write_time">last_write_time</a>(const path&amp; p);
      std::time_t  <a href="#last_write_time">last_write_time</a>(const path&amp; p, system::error_code&amp; ec);
      void         <a href="#last_write_time2">last_write_time</a>(const path&amp; p, const std::time_t new_time);
      void         <a href="#last_write_time2">last_write_time</a>(const path&amp; p, const std::time_t new_time, system::error_code&amp; ec);

      path         <a href="#read_symlink">read_symlink</a>(const path&amp; p);
      path         <a href="#read_symlink">read_symlink</a>(const path&amp; p, system::error_code&amp; ec);

      bool         <a href="#remove">remove</a>(const path&amp; p);
      bool         <a href="#remove">remove</a>(const path&amp; p, system::error_code&amp; ec);

      uintmax_t    <a href="#remove_all">remove_all</a>(const path&amp; p);
      uintmax_t    <a href="#remove_all">remove_all</a>(const path&amp; p, system::error_code&amp; ec);

      void         <a href="#rename">rename</a>(const path&amp; from, const path&amp; to);
      void         <a href="#rename">rename</a>(const path&amp; from, const path&amp; to, system::error_code&amp; ec);

<span style="background-color: #FFFFFF">      <a href="#space_info">space_info</a>   <a href="#space">space</a>(const path&amp; p);
      <a href="#space_info">space_info</a>   <a href="#space">space</a>(const path&amp; p</span>, system::error_code&amp; ec<span style="background-color: #FFFFFF">);
</span><span style="background-color: #FFFF00">
</span>      <a href="#file_status">file_status</a>  <a href="#status">status</a>(const path&amp; p);
      <a href="#file_status">file_status</a>  <a href="#status">status</a>(const path&amp; p, system::error_code&amp; ec);

      bool         <a href="#status_known">status_known</a>(file_status s);

      <a href="#file_status">file_status</a>  <a href="#symlink_status">symlink_status</a>(const path&amp; p);
      <a href="#file_status">file_status</a>  <a href="#symlink_status">symlink_status</a>(const path&amp; p, system::error_code&amp; ec);

      path         <a href="#system_complete">system_complete</a>(const path&amp; p);
      path         <a href="#system_complete">system_complete</a>(const path&amp; p, system::error_code&amp; ec);

    } // namespace filesystem
  } // namespace boost</pre>
<h4><a name="Error-reporting">Error reporting</a></h4>
<p>Filesystem library functions often provide two overloads, one that 
throws an exception to report file system errors, and another that sets an
<code>error_code</code>.</p>
<blockquote>
<p>[<i>Note:</i> This supports two common use cases:</p>
<ul>
  <li>Uses where file system 
errors are truly exceptional and indicate a serious failure. Throwing an 
  exception is the most appropriate response. This is the preferred default for 
  most everyday programming.<br>
&nbsp;</li>
  <li>Uses where file system system errors are routine and do not necessarily represent 
  failure. Returning an error code is the most appropriate response. This allows 
  application specific error handling, including simply ignoring the error.</li>
</ul>
  <p><i>--end note</i>]</p>
</blockquote>
<p>Functions <b>not</b> having an argument of type
<code>system::error_code&amp;</code> 
report errors as follows, unless otherwise specified:</p>
  <ul>
  <li>When a call by the 
  implementation to an operating system or other underlying API results in an 
  error that prevents the function from meeting its specifications, an exception 
  of type
<code>filesystem_error</code> is thrown.<br>
&nbsp;</li>
  <li>Failure to allocate storage is reported by throwing an exception as described in the C++ standard, 
  17.6.4.10 [res.on.exception.handling].<br>
&nbsp;</li>
  <li>Destructors throw nothing.</li>
  </ul>
  <p>Functions having an argument of type
<code>system::error_code&amp;</code> report errors as follows, unless otherwise 
  specified:</p>
<ul>
  <li>If a call by the 
  implementation to an operating system or other underlying API results in an 
  error that prevents the function from meeting its specifications, the
<code>system::error_code&amp;</code> argument is set as 
  appropriate appropriate for the specific error. Otherwise, <code>clear()</code> 
  is called on the
<code>system::error_code&amp;</code> argument.<br>
&nbsp;</li>
  <li>Failure to allocate storage is reported by 
  throwing an exception as described in the C++ standard, 
  17.6.4.10 [res.on.exception.handling].</li>
</ul>
<h3><a name="class-path">Class <code>path</code></a></h3>
<p>An object of class <code>path</code> represents a <a href="#Path">path</a>, 
and contains a <a href="#Pathname">pathname</a> in the
<a href="#Native-pathname-format">native format</a>. Such an object is concerned only with the lexical and syntactic aspects 
of a path. The path does not have to actually exist in the operating system's file 
systems, and may contain pathnames which are not even valid for the current operating 
system. </p>
<blockquote>
  <p>[<i>Note: </i>If the library's operational functions trafficked only in C++<i> </i>or 
  C-style strings rather than <code>path</code> objects, it would provide only the illusion of portability since 
  while the syntax of function calls would be portable, the semantics of the 
  strings they operate on would not be portable. <i>-- end note</i>]</p>
</blockquote>
<pre>  namespace boost
  {
    namespace filesystem
    {
      class path
      {
      public:
        typedef <b><i><a href="#value_type">see below</a></i></b>                     value_type;  // char for POSIX, wchar_t for Windows
        typedef std::basic_string&lt;value_type&gt; string_type;
        typedef path_traits::codecvt_type     codecvt_type;

        // <a href="#path-constructors">constructors</a> and destructor
        path();
        path(const path&amp; p);

        template &lt;class <a href="#ContiguousIterator">ContiguousIterator</a>&gt;
          path(ContiguousIterator begin, ContiguousIterator end);

        template &lt;class Source&gt;
          path(Source const&amp; source);

       ~path();

        // <a href="#path-assignments">assignments</a>
        path&amp; operator=(const path&amp; p);

        template &lt;class <a href="#ContiguousIterator">ContiguousIterator</a>&gt;
          path&amp; assign(ContiguousIterator begin, ContiguousIterator end);

        template &lt;class Source&gt;
          path&amp; operator=(Source const&amp; source);

        // <a href="#path-appends">appends</a>
        path&amp; operator/=(const path&amp; p);

        template &lt;class <a href="#ContiguousIterator">ContiguousIterator</a>&gt;
          path&amp; append(ContiguousIterator begin, ContiguousIterator end);

        template &lt;class Source&gt;
          path&amp; operator/=(Source const&amp; source);

        // <a href="#path-modifiers">modifiers</a>
        void  clear();
        void  swap(path&amp; rhs);
        path&amp; remove_filename();
        path&amp; replace_extension(const path&amp; new_extension = path());
        path&amp; localize();  // POSIX: no effect. Windows: convert slashes to backslashes

        // <a href="#path-observers">observers</a>
        const string_type&amp;  native() const;           // native format, encoding
        const value_type*   c_str() const;            // native().c_str()

        const string        native_string() const;    // native format, uses codecvt() for encoding
        const wstring       native_wstring() const;   // ditto
        const u16string     native_u16string() const; // ditto
        const u32string     native_u32string() const; // ditto

        const string        string() const;           // portable format, uses codecvt() for encoding
        const wstring       wstring() const;          // ditto
        const u16string     u16string() const;        // ditto
        const u32string     u32string() const;        // ditto

        // <a href="#path-decomposition">decomposition</a>
        path  root_name() const;
        path  root_directory() const;
        path  root_path() const;
        path  relative_path() const;
        path  parent_path() const;
        path  filename() const;
        path  stem() const;
        path  extension() const;

        // <a href="#path-query">query</a>
        bool empty() const;
        bool has_root_name() const;
        bool has_root_directory() const;
        bool has_root_path() const;
        bool has_relative_path() const;
        bool has_parent_path() const;
        bool has_filename() const;
        bool has_stem() const;
        bool has_extension() const;
        bool is_complete() const;

        // <a href="#path-iterators">iterators</a>
        class iterator;
        typedef iterator const_iterator;

        iterator begin() const;
        iterator end() const;
        
        // encoding conversion
        static std::locale imbue( const std::locale&amp; loc );
        static const codecvt_type &amp; codecvt()
      };

    } // namespace filesystem
  } // namespace boost</pre>
<p><code><a name="value_type">value_type</a></code> is an implementation-defined typedef for the 
character type used by the implementation to represent pathnames.</p>
<blockquote>
<p><i>[Note:</i> For POSIX-like implementations, including<b> </b>Unix's, Linux, 
and
  <a href="http://www.cygwin.com/">Cygwin</a>, <code>path::value_type</code> 
is <code>char</code> .</p>
<p>For Windows-like implementations, including Windows and
<a href="http://www.mingw.org/">MinGW</a>, <code>path::value_type</code> is <code>
wchar_t</code>.&nbsp;<i>--end note]</i></p>
</blockquote>
<p>For member functions described as returning <code>const string</code>, <code>
const wstring</code>, <code>const u16string</code>, or <code>const u32string</code>, 
implementations are permitted to return <code>const string&amp;</code>, <code>const 
wstring&amp;</code>, <code>const u16string&amp;</code>, or <code>const u32string&amp;</code>, 
respectively.</p>
<blockquote>
<p>[<i>Note:</i> This allows implementations to avoid unnecessary copies when no 
conversion is required. 
Return-by-value is specified as
<code>const</code> to ensure programs won't break if moved to a return-by-reference 
implementation. <i>-- 
end note</i>]</p>
</blockquote>
<p><code><a name="ContiguousIterator">ContiguousIterator</a></code> is required be a standard library <code>RandomIterator</code> 
compliant iterator 
pointing to contiguous storage. The iterator's value_type is required to be <code>char</code>, <code>
  wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code>.</p>
<p><code>Source</code> is required to be one of:</p>
<ul>
  <li>A container. The value type is required to be <code>char</code>, <code>
  wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code>.</li>
  <li>An iterator for a null terminated byte-string. The value type is required 
  to be <code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, or <code>
  char32_t</code>.</li>
  <li>A C-array. The value type is required to be <code>char</code>, <code>
  wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code>.</li>
  <li>A <code>boost::filesystem::directory_entry</code>.</li>
</ul>
<h4><a name="Pathname-formats">Pathname formats</a></h4>
<p>Strings representing paths may be in two possible formats: </p>
<ul>
  <li><i><b><a name="Portable-pathname-format">Portable pathname format</a>:</b></i> As described in <a href="#Pathname-grammar">
  Pathname grammar</a> and by the <i>POSIX</i> <i><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_169">Filename</a>,
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_266">
Pathname</a> </i>and<i>
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap04.html#tag_04_11">
Pathname Resolution</a></i> definitions.<blockquote>
<p>[<i>Note:</i> <span style="background-color: #FFFFFF">The <i>POSIX</i> format 
is the basis for the portable format because it is already part of an ISO standard, is 
the basis for the ubiquitous <i>URL</i> format, and is the native pathname format 
(or a 
subset thereof) for the <i>UNIX</i>-like and <i>Windows</i>-like 
pathnames familiar to most programmers. </span></p>
<p>Use of the portable format does not alone guarantee 
portability;  filenames must also be portable.<span style="background-color: #FFFFFF"> 
See <a href="#Input-conversion">Filename conversions</a>. Each operating system 
 
follows its own rules. Use of the portable format 
does not change those rules. </span> <i>-- end note</i>]</p>
  </blockquote>
  
  </li>
  <li>
  
  <b><i><a name="Native-pathname-format">Native pathname format</a>:</i></b> As defined by the operating system.<blockquote>
    <p>[<i>Note:</i> <span style="background-color: #FFFFFF">Working with 
    user-provided paths in the native format is a common need.</span></p>
    <p><span style="background-color: #FFFFFF">Programs using hard-coding native 
    formats may not be  portable.&nbsp; --</span><i><span style="background-color: #FFFFFF"> end note</span></i><span style="background-color: #FFFFFF">]</span></p>
  </blockquote>
  </li>
</ul>
<div align="left">
  <table border="1" cellpadding="10" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td bgcolor="#D7EEFF">
    <p align="left">[<i>Note:</i></p>
    <p align="left"><b>POSIX-like<i> </i>implementations, including Cygwin:</b> 
    The portable format and the native format are the same, and the encoding 
    follows the conventions of the specific operating system</p>
    <p align="left"><b>Windows-like implementations:</b> The native format is 
    the Windows pathname format, and the encoding is UTF-16 (UCS-2 for older 
    versions). The native directory separator is a backslash, but a slash is 
    also acceptable. Since the portable format is a subset of the native format, 
    no reformatting is required and directory separators are preserved. For 
    example, on Windows:</p>
      <blockquote>
    <p align="left"><code>path p = &quot;foo\\bar/baz&quot;;<br>
    assert( p.native() == L&quot;foo\\bar/baz&quot; );<br>
    p = &quot;baz/bar/foo&quot;;<br>
    assert( p.native() == L&quot;baz/bar/foo&quot; );</code></p>
      </blockquote>
    <p align="left"> <i>--end note</i>]</p>
      </td>
    </tr>
  </table>
</div>
<p><span style="background-color: #FFFF00">All <code>path</code> string or sequence arguments that describe a 
path shall accept the portable pathname format, and shall accept the native 
format if explicitly identified by a native format escape sequence prefix of
<code>slash slash colon</code>.</span></p>
<blockquote>
    <p><span style="background-color: #FFFF00">[<i>Note:</i> <code>slash 
    slash colon</code> was chosen as the escape sequence because a leading <code>
    slash slash</code>&nbsp; is already implementation-defined by POSIX, <code>
    colon</code> is prohibited in a Windows filename, and on any system a single
    <code>slash</code> can be used when a filename beginning with a <code>colon</code> 
    is desired.&nbsp;These factors eliminate the chance of collision with a real 
    filename. --</span><i><span style="background-color: #FFFF00"> end note</span></i><span style="background-color: #FFFF00">]</span></p>
    </blockquote>
<p><span style="background-color: #FFFF00">Implementations are encouraged to 
implicitly recognize the native pathname format if it can be lexically 
identified. An implementation shall document whether or 
not the native pathname format is
implicitly recognized.</span></p>
<blockquote>
<p><span style="background-color: #FFFF00">[</span><i><span style="background-color: #FFFF00">Example:</span></i></p>
<p><i><span style="background-color: #FFFF00">-- OpenVMS:</span></i><span style="background-color: #FFFF00">
</span> <code><span style="background-color: #FFFF00">&quot;SYS1::DISK1:[JANE.TYLER.HARRY]</span></code><span style="background-color: #FFFF00">&quot; is treated 
as a native pathname with a system name, drive name,&nbsp;and three directory 
filenames, rather than a portable pathname with one filename.</span></p>
<p><i><span style="background-color: #FFFF00">-- Windows: </span> </i><code>
<span style="background-color: #FFFF00">&quot;c:\\jane\\tyler\\harry&quot;</span></code><span style="background-color: #FFFF00"> is treated as a 
native pathname with a drive letter, root-directory, and three filenames, rather 
than a portable pathname with one filename.</span></p>
<p><i><span style="background-color: #FFFF00">-- Counter-example 1:</span></i><span style="background-color: #FFFF00"> An operating system that allows slashes in 
filenames and uses dot as a directory separator. Distinguishing between portable 
and native format argument strings or sequences is not possible as there is no 
other distinguishing syntax. The implementation does not accept native format 
pathnames unless the </span> <code><span style="background-color: #FFFF00">native</span></code><span style="background-color: #FFFF00"> argument is present.</span></p>
<p><i><span style="background-color: #FFFF00">-- Counter-example 2:</span></i><span style="background-color: #FFFF00"> An operating system that allows slashes in 
filenames and uses some unusual character as a directory separator. The 
implementation does accept native format pathnames without the additional </span> <code>
<span style="background-color: #FFFF00">native</span></code><span style="background-color: #FFFF00"> argument, which only has to be used for native format arguments 
containing slashes in filenames.</span></p>
<p><i><span style="background-color: #FFFF00">-- end example</span></i><span style="background-color: #FFFF00">]</span></p>
<p><span style="background-color: #FFFF00">[</span><i><span style="background-color: #FFFF00">Note:</span></i><span style="background-color: #FFFF00"> This
</span> <i><a name="duck-rule"><span style="background-color: #FFFF00">duck-rule</span></a></i><span style="background-color: #FFFF00"> (&quot;if it looks 
like a duck, walks like a duck, and quacks like a duck, it must be a duck&quot;) 
eliminates format confusion as a source of programmer error and support 
requests. </span> <i><span style="background-color: #FFFF00">-- end note</span></i><span style="background-color: #FFFF00">]</span></p>
</blockquote>
<p><span style="background-color: #FFFF00">If both the portable and native formats are accepted, implementations shall 
document what characters or character sequences are used to distinguish between 
portable and native formats.</span></p>
<blockquote>
<p><span style="background-color: #FFFF00">[</span><i><span style="background-color: #FFFF00">Note:</span></i><span style="background-color: #FFFF00">
</span> <i><span style="background-color: #FFFF00">Windows</span></i><span style="background-color: #FFFF00"> implementations are encouraged to define colons 
and backslashes as the characters which distinguish native from portable 
formats. </span> <i><span style="background-color: #FFFF00">--end note</span></i><span style="background-color: #FFFF00">]</span></p>
</blockquote>
<h4><a name="Pathname-grammar">Pathname grammar</a></h4>
<p>The grammar for the portable pathname format is as follows:</p>
<blockquote>
<p><i>pathname:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-name<sub>opt</sub> 
root-directory<sub>opt</sub> relative-path<sub>opt</sub></i></p>
<p><i>root-name:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
implementation-defined</i></p>
<p><i>root-directory:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
directory-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
root-directory directory-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
implementation-defined</i></p>
<p><i>relative-path:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
filename<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relative-path 
directory-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relative-path 
directory-separator filename</i></p>
<p><i>filename:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dot<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dot dot</i></p>
<p><i>directory-separator:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>&quot;/&quot;</code></i></p>
<p><i>dot:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i><code>&quot;.&quot;</code></p>
</blockquote>
<p>The grammar is aligned with the <i>POSIX </i>&nbsp;<i><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_169">Filename</a>,
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap03.html#tag_03_266">
Pathname</a> </i>and<i>
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap04.html#tag_04_11">
Pathname Resolution</a></i> definitions. Any conflict between the grammar and <i>
POSIX</i> is unintentional. This technical report defers to <i>POSIX</i>.</p>
<blockquote>
<p><span style="background-color: #E0E0E0"><i>The form of the above wording was taken 
from POSIX, which uses it in several places to defer to the C standard.</i></span></p>
<p>[<i>Note: Windows</i> implementations are encouraged to define <i>slash slash 
name</i> as a permissible <i>root-name</i>. <i>POSIX</i> permits, but does not 
require, implementations to do the same. <i>Windows</i> implementations are 
encouraged to define an additional <i>root-directory</i> element <i>
root_directory name.</i> It is applicable only to the <i>slash slash name</i> 
form of <i>root-name.</i></p>
<p> <i>Windows</i> implementations are encouraged to recognize a <i>name</i> 
followed by a colon as a native format <i>root-name</i>, 
and a backslash as a format element equivalent to <i>slash</i>. <i>-- end note</i>]</p>
</blockquote>
<h4><a name="Input-conversion">Input conversion</a></h4>
<p><span style="background-color: #FFFF00">To be supplied. Explain when, how 
codecvt applied.</span></p>
<p><span style="background-color: #FFFF00">When converting filenames to the native operating system format, 
implementations are encouraged, but not required, to convert otherwise invalid 
characters or character sequences to valid characters or character sequences. 
Such conversions are implementation-defined.</span></p>
<blockquote>
<p><span style="background-color: #FFFF00">[</span><i><span style="background-color: #FFFF00">Note:</span></i><span style="background-color: #FFFF00"> Filename conversion allows much wider portability of both 
programs and filenames that would otherwise be possible.</span></p>
<p><span style="background-color: #FFFF00">Implementations are encouraged to base conversion on existing standards or 
practice. Examples include the Uniform Resource Locator escape syntax of a percent sign (</span><code><span style="background-color: #FFFF00">'%'</span></code><span style="background-color: #FFFF00">) 
followed by two hex digits representing the character value. On </span>
<i><span style="background-color: #FFFF00">OpenVMS</span></i><span style="background-color: #FFFF00">, which does not allow percent signs in filenames, a dollar sign (</span><code><span style="background-color: #FFFF00">'$'</span></code><span style="background-color: #FFFF00">) 
followed by two hex digits is the existing practice, as is converting lowercase 
letters to uppercase.</span><i><span style="background-color: #FFFF00"> -- end note.</span></i><span style="background-color: #FFFF00">]</span></p>
<p><span style="background-color: #E0E0E0"><i>The Boost implementation for 
Windows currently does not map invalid characters. Pending feedback from the LWG, 
Boost may settle on % hex hex as the preferred escape sequence. If so, should 
there be normative encouragement?</i></span></p>
</blockquote>
<h4> <code><font size="4">class </font></code> <a name="path-constructors"> <code>
<font size="4">path</font></code> constructors</a></h4>
<pre>path();</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>empty()</code>.</p>
  </blockquote>
<pre>template &lt;class <a href="#ContiguousIterator">ContiguousIterator</a>&gt;
  path(ContiguousIterator begin, ContiguousIterator end);</pre>
<pre>template &lt;class Source&gt;
  path(Source const&amp; source);</pre>
<blockquote>
  <p><i>Effects:</i> Stores the contents [<code>begin</code>,<code>end</code>) 
  or <code>source</code>, in the native format, as the contained pathname.</p>
  <p>
  <i>Remarks:</i> If the value type of&nbsp; [<code>begin</code>,<code>end</code>) 
  or <code>source</code> is not <code>value_type</code>, the contents are 
  converted by <code>codecvt()</code>.</p>
</blockquote>
<h4> <code><font size="4">class </font></code> <a name="path-assignments"> <code>
<font size="4">path</font></code> assignments</a></h4>
<pre>template &lt;class <a href="#ContiguousIterator">ContiguousIterator</a>&gt;
  path&amp; assign(ContiguousIterator begin, ContiguousIterator end);</pre>
<pre>template &lt;class Source&gt;
  path&amp; operator=(Source const&amp; source);</pre>
<blockquote>
  <p><i>Effects:</i> Stores the contents [<code>begin</code>,<code>end</code>) 
  or <code>source</code>, in the native format, as the contained pathname.</p>
  <p>
  <i>Remarks:</i> If the value type of&nbsp; [<code>begin</code>,<code>end</code>) 
  or <code>source</code> is not <code>value_type</code>, the contents are 
  converted by <code>codecvt()</code>.</p>
  <p><i>Returns: </i><code>*this</code></p>
  </blockquote>
<h4> <code><font size="4">class <a name="path-appends">path</a></font></code><a name="path-appends"> 
appends</a></h4>
  <p>The append operations use <code>operator/=</code> to denote their semantic 
  effect of appending a native directory separator when needed. The native 
  directory separator is implementation-defined.</p>
<blockquote>
    <p align="left">[<i>Note: </i>For POSIX-like implementations, including<b> </b>
    Unix's, Linux, and
  <a href="http://www.cygwin.com/">Cygwin</a>, the native directory separator is a forward slash.</p>
    <p align="left">For Windows-like implementations, including Windows and
    <a href="http://www.mingw.org/">MinGW</a>, the native directory 
    separator is a backslash.<i>--end note</i>]</p>
      </blockquote>
<pre>path&amp; operator/=(const path&amp; p);</pre>
<blockquote>
  <p><i>Effects:</i></p>
  <blockquote>
    Appends a native directory separator to the contained pathname, unless:<ul>
    <li>an added separator 
    would be redundant, or</li>
    <li>would change an incomplete path to a complete path, or</li>
    <li><code>p.empty()</code>, or</li>
    <li><code>*p.native().cbegin()</code> is a directory separator.</li>
  </ul>
    <p>Appends <code>p.native()</code> to the contained pathname.</p>
  </blockquote>
  <p><i>Returns: </i><code>*this</code></p>
</blockquote>
<pre>template &lt;class <a href="#ContiguousIterator">ContiguousIterator</a>&gt;
  path&amp; append(ContiguousIterator begin, ContiguousIterator end);</pre>
<pre>template &lt;class Source&gt;
  path&amp; operator/=(Source const &amp; source);</pre>
<blockquote>
  <p><i>Effects:</i></p>
  <blockquote>
    <p>Appends a native directory separator to the contained pathname, unless:</p>
    <ul>
    <li>an added separator 
    would be redundant, or</li>
    <li>would change an incomplete path to a complete path, or</li>
    <li><code>p.empty()</code>, or</li>
    <li><code>*p.native().cbegin()</code> is a separator.</li>
  </ul>
    <p>Appends the contents [<code>begin</code>,<code>end</code>) 
  or <code>source</code>, in the native format, to the contained pathname.</p>
  </blockquote>
  <p><i>Remarks:</i> If the value type of&nbsp; [<code>begin</code>,<code>end</code>) 
  or <code>source</code> is not <code>value_type</code>, the contents are 
  converted by <code>codecvt()</code>.</p>
  <p><i>Returns: </i><code>*this</code></p>
  </blockquote>
<h4> <code><font size="4">class </font></code> <a name="path-modifiers"> <code>
<font size="4">path</font></code> modifiers</a></h4>
<pre>void clear();</pre>
<blockquote>
<p><i>Postcondition:</i> <code>this-&gt;empty()</code> is true.</p>
</blockquote>
<pre><code><span style="background-color: #FFFFFF">void swap( path&amp; rhs );</span></code></pre>
<blockquote>
  <p><i><span style="background-color: #FFFFFF">Effects:</span></i><span style="background-color: #FFFFFF"> 
  Swaps the contents of the two paths.</span></p>
  <p><i><span style="background-color: #FFFFFF">Throws: </span></i>
  <span style="background-color: #FFFFFF">nothing.</span></p>
  <p><i><span style="background-color: #FFFFFF">Complexity: </span></i>
  <span style="background-color: #FFFFFF">constant time.</span></p>
</blockquote>
<pre>path&amp; remove_filename();</pre>
<blockquote>
  <p><i>Returns: </i>As if, <code>*this = parent_path();</code></p>
  <p>[<i>Note:</i> This function is needed to efficiently implement <code>
  directory_iterator</code>. It is exposed to allow additional uses. The actual 
  implementation may be much more efficient than <code>*this = parent_path()</code>&nbsp; <i>-- end 
  note</i>]</p>
</blockquote>
<pre>path&amp; replace_extension(const path&amp; new_extension = path());</pre>
<blockquote>
  <p><i>Postcondition: </i> <code>extension() == <i>replacement</i></code>, 
  where <code><i>replacement</i></code> is <code>new_extension</code> if <code>
  new_extension.empty() || new_extension[0] ==</code> the dot character, 
  otherwise <code><i>replacement</i></code> is the dot character followed by
  <code>new_extension</code>.</p>
  <p><i>Returns:</i> <code>*this</code></p>
</blockquote>
<pre>path&amp; localize();</pre>
<blockquote>
  <p><i>Effects:</i> The contained pathname is converted to the preferred native 
  format. [<i>Note:</i> On Windows, the effect is to replace slashes with 
  backslashes. On POSIX, there is no effect. <i>-- end note</i>]</p>
  <p><i>Returns:</i> <code>*this</code></p>
</blockquote>
<h4> <code><font size="4">class </font></code> <a name="path-observers"> <code>
<font size="4">path</font></code> observers</a></h4>
<p><span style="background-color: #FFFF00"><i>Move elsewhere.</i> </span></p>
<p><span style="background-color: #FFFF00">Some operating systems, including
</span> <i><span style="background-color: #FFFF00">POSIX</span></i><span style="background-color: #FFFF00"> and
</span> <i>
<span style="background-color: #FFFF00">Windows</span></i><span style="background-color: #FFFF00">, use the same format for paths to directories and paths to regular 
files.</span></p>
<p><span style="background-color: #FFFF00">Other operating systems, such as 
</span><span style="background-color: #FFFF00">OpenVMS</span><span style="background-color: #FFFF00">, used different formats for paths to 
directories and paths to regular files. On such systems, implementations shall 
determine the format according to whether or not the last element is a 
separator.</span></p>
<table border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td colspan="2">
    <p align="center"><b><span style="background-color: #FFFF00">OpenVMS</span></b></td>
  </tr>
  <tr>
    <td><code><span style="background-color: #FFFF00">path p</span></code></td>
    <td><code><span style="background-color: #FFFF00">p.native()</span></code></td>
  </tr>
  <tr>
    <td><code><span style="background-color: #FFFF00">p = &quot;/cats/jane&quot;</span></code></td>
    <td> <code><span style="background-color: #FFFF00">&quot;[CATS]JANE&quot;</span></code></td>
  </tr>
  <tr>
    <td><code><span style="background-color: #FFFF00">p = &quot;/cats/jane/&quot;</span></code></td>
    <td> <code><span style="background-color: #FFFF00">&quot;[CATS.JANE]&quot;</span></code></td>
  </tr>
</table>
<pre>const string_type&amp;  native() const;</pre>
<blockquote>
<p><i>Returns:</i> The contained pathname. [<i>Note:</i> The contained pathname 
is in the <a href="#Native-pathname-format">native pathname format</a>. <i>-- 
end note</i>]</p>
<p><i>Throws:</i> nothing.</p>
</blockquote>
<pre>const value_type* c_str() const;</pre>
<blockquote>
<p><i>Returns:</i> <code>native().c_str()</code>.</p>
<p><i>Throws:</i> nothing.</p>
</blockquote>
<pre><i><b>const-string</b></i> native_string() const;</pre>
<blockquote>
<p><b><i><code>const-string</code></i></b> is permitted to be <code>const 
std::string</code> or <code>const std::string&amp;</code>.</p>
<p><i>Returns:</i> The contained pathname. [<i>Note:</i> The contained pathname 
is in the <a href="#Native-pathname-format">native pathname format</a>. <i>-- 
end note</i>]</p>
<p><i>Remarks:</i> If
<code>value_type</code> is not <code>char</code>, the encoding is converted by
<code>codecvt()</code>.</p>
<p><i>[Note:</i> For POSIX-like implementations, no conversion is required; the 
implementation will simply return <code>native()</code>. <i>-- end note]</i></p>
</blockquote>
<pre><i><b>const-wstring</b></i> native_wstring() const; </pre>
<blockquote>
<p><b><i><code>const-wstring</code></i></b> is permitted to be <code>const 
std::wstring</code> or <code>const std::wstring&amp;</code>.</p>
<p><i>Returns:</i> The contained pathname. [<i>Note:</i> The contained pathname 
is in the <a href="#Native-pathname-format">native pathname format</a>. <i>-- 
end note</i>]</p>
<p><i>Remarks:</i> If
<code>value_type</code> is not <code>wchar_t</code>, the encoding is converted by
<code>codecvt()</code>.</p>
<p><i>[Note:</i> For Windows implementations, no conversion is required; the 
implementation will simply return <code>native()</code>. <i>-- end note]</i></p>
</blockquote>
<pre><b><i>const-string</i></b> string() const;</pre>
<blockquote>
<p><b><i><code>const-string</code></i></b> is permitted to be <code>const 
std::string</code> or <code>const std::string&amp;</code>.</p>
<p><i>Returns:</i> The contained pathname, in the
<a href="#Portable-pathname-format">portable pathname format</a>.</p>
<p><i>Remarks:</i> If
<code>value_type</code> is not <code>char</code>, the encoding is converted by
<code>codecvt()</code>.</p>
</blockquote>
<pre><b><i>const-wstring</i></b> wstring() const;</pre>
<blockquote>
<p><b><i><code>const-wstring</code></i></b> is permitted to be <code>const 
std::wstring</code> or <code>const std::wstring&amp;</code>.</p>
<p><i>Returns:</i> The contained pathname, in the
<a href="#Portable-pathname-format">portable pathname format</a>.</p>
<p><i>Remarks:</i> If
<code>value_type</code> is not <code>wchar_t</code>, the encoding is converted by
<code>codecvt()</code>.</p>
</blockquote>
<h4> <a name="path-decomposition"> <code><font size="4">class path</font></code> 
decomposition</a></h4>
<p><span style="background-color: #E0E0E0"><i>See the
<a href="#Path-decomposition-table">Path decomposition table</a> for examples 
for values returned by decomposition functions.</i></span></p>
<pre>path root_name() const;</pre>
<blockquote>
<p><i>Returns:</i> <i>root-name,</i> if the stored path includes <i>
root-name</i>, otherwise <code>path()</code>. </p>
</blockquote>
<pre>path root_directory() const;</pre>
<blockquote>
<p><i>Returns:</i> <i>root-directory</i>, if the stored path includes <i>
root-directory</i>, otherwise <code>path()</code>.</p>
<p>If <i>root-directory</i> is composed <i>slash name</i>, <i>slash</i> is 
excluded from the returned string.</p>
</blockquote>
<pre>path root_path() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>root_name() / root_directory()</code></p>
</blockquote>
<pre>path relative_path() const;</pre>
<blockquote>
<p><i>Returns:</i> A <code>path</code> composed from the the stored path, if any, beginning 
with the first <i>filename</i> after <i>root-path</i>. Otherwise, <code>path()</code>.</p>
</blockquote>
<pre>path filename() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>empty() ? path() : *--end()</code></p>
</blockquote>
<pre>path parent_path() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>(empty() || begin() == --end()) ? path() : <i>pp</i></code>, where
  <code><i>pp</i></code> is constructed as if by 
  starting with an empty <code>path</code> and successively applying <code>
  operator/=</code> for each element in the range <code>begin()</code>, <code>
  --end()</code>.</p>
</blockquote>
<pre>path stem(const path&amp; p) const;</pre>
<blockquote>
  <p><i>Returns:</i> if <code>p.filename()</code> contains a <i>dot</i>, returns 
  the substring of <code>p.filename()</code> starting at its beginning and 
  ending at the last <i>dot</i> (the <i>dot</i> is not included). Otherwise, 
  returns <code>
  p.filename()</code>.</p>
</blockquote>
<pre>path extension(const path&amp; p) const;</pre>
<blockquote>
  <p><i>Returns:</i> if <code>p.filename()</code> contains a <i>dot</i>, returns 
  the substring of <code>p.filename()</code> starting at the rightmost <i>dot</i> 
  and ending at the string's end. Otherwise, returns an empty string. </p>
  <p>[<i>Note:<b> </b></i>The <i>dot</i> is included in the return value so that 
  it is possible to distinguish between no extension and an empty extension.&nbsp; <i>-- end note</i>]</p>
  <p>Implementations are permitted but not required to define additional 
  behavior for file systems which append additional elements to extensions, such 
  as alternate data streams or partitioned dataset names.</p>
</blockquote>
<h4> <a name="path-query"> <code><font size="4">class path</font></code> query</a></h4>
<pre>bool empty() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>native().empty()</code>.</p>
</blockquote>
<pre>bool is_complete() const;</pre>
<blockquote>
  <p><span style="background-color: #FFFFFF"><i>Returns:</i> <code>true</code>, 
  if the elements of root_path() uniquely identify a directory, else <code>false</code>.</span></p>
</blockquote>
<pre>bool has_root_path() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!root_path().empty()</code></p>
</blockquote>
<pre>bool has_root_name() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!root_name().empty()</code></p>
</blockquote>
<pre>bool has_root_directory() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!root_directory().empty()</code></p>
</blockquote>
<pre>bool has_relative_path() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!relative_path().empty()</code></p>
</blockquote>
<pre>bool has_parent_path() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!parent_path().empty()</code></p>
</blockquote>
<pre>bool has_filename() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!filename().empty()</code></p>
</blockquote>
<pre>bool has_stem() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!</code><code>stem().empty()</code></p>
</blockquote>
<pre>bool has_extension() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!extension().empty()</code></p>
</blockquote>
<h4> <code><font size="4">class </font></code> <a name="path-iterators"> <code>
<font size="4">path</font></code> iterators</a></h4>
<p> A <code>path::iterator</code> is a constant iterator satisfying all 
the requirements of a bidirectional iterator (C++ Std, 24.1.4 Bidirectional 
iterators [lib.bidirectional.iterators]). Its <code>value_type</code> is
<code>string_type</code>.</p>
  <p>Calling any non-const member function of a <code>path</code> object 
  invalidates all iterators referring to elements of the object.</p>
<p> The forward traversal order is as follows:</p>
<ul>
  <li>The <i>root-name</i> element, if present.</li>
  <li>The <i>root-directory</i> element, if present.</li>
  <li>Each successive <i>filename</i> element, if present.</li>
  <li><i>Dot</i>, if one or more trailing non-root <i>slash</i> 
  characters are present.</li>
</ul>
  <p>The backward traversal order is the reverse of forward traversal.</p>
  <pre>iterator begin() const;</pre>
<blockquote>
  <p><i>Returns:</i> An iterator for the first present element in the traversal 
  list above. If no elements are present, the end iterator.</p>
</blockquote>
<pre>iterator end() const;</pre>
<blockquote>
  <p><i>Returns:</i> The end iterator.</p>
</blockquote>
<h4> <code><font size="4">class <a name="path-deprecated-functions">path</a></font></code><a name="path-deprecated-functions"> 
deprecated functions</a></h4>
<p> <span style="background-color: #FFFF00">index.htm</span><span style="background-color: #FFFF00"> 
also has a section (see macros) partially duplicating this material. Change to 
reference this.</span></p>
<p> Several member functions from previous versions of <code>class path</code> 
have been deprecated, either because they have been renamed or because the 
functionality is no longer desirable or has become obsolete.</p>
<p> Deprecated functions available by default; will be suppressed if <code>
BOOST_FILESYSTEM_NO_DEPRECATED</code> is defined:</p>
<blockquote>
  <pre>path&amp;  remove_leaf()           { return remove_filename(); }
path   leaf() const            { return filename(); }
path   branch_path() const     { return parent_path(); }
bool   has_leaf() const        { return !m_path.empty(); }
bool   has_branch_path() const { return !parent_path().empty(); }</pre>
</blockquote>
<p> Deprecated functions not available by default; will be supplied if <code>
BOOST_FILESYSTEM_DEPRECATED</code> is defined:</p>
<blockquote>
  <pre>const std::string  file_string() const               { return native_string(); }
const std::string  directory_string() const          { return native_string(); }
const std::string  native_file_string() const        { return native_string(); }
const std::string  native_directory_string() const   { return native_string(); }
const string_type  external_file_string() const      { return native(); }
const string_type  external_directory_string() const { return native(); }</pre>
</blockquote>
<p>Functions no longer available:</p>
<p><span style="background-color: #FFFF00">TBS</span></p>
<h4> <a name="path-non-member-functions">
<span style="background-color: #FFFFFF">path non-member functions</span></a></h4>
<pre><span style="background-color: #FFFFFF">template&lt;class String, class Traits&gt;
void swap( path&lt;String, Traits&gt; &amp; lhs, path&lt;String, Traits&gt; &amp; rhs )</span></pre>
<blockquote>
  <p><i><span style="background-color: #FFFFFF">Effects: </span></i><code>
  <span style="background-color: #FFFFFF">lhs.swap( 
  rhs )</span></code></p>
</blockquote>
  <h4><span style="background-color: #FFFFFF">path non-member operators</span></h4>
  <p><span style="background-color: #FF0000">There are seven path non-member operators (/,
  </span> <code><span style="background-color: #FF0000">==</span></code><span style="background-color: #FF0000">,
  </span> <code>
  <span style="background-color: #FF0000">!=</span></code><span style="background-color: #FF0000">,
  </span> <code><span style="background-color: #FF0000">&lt;</span></code><span style="background-color: #FF0000">,
  </span> <code><span style="background-color: #FF0000">&gt;</span></code><span style="background-color: #FF0000">,
  </span> <code><span style="background-color: #FF0000">&lt;=</span></code><span style="background-color: #FF0000">,
  </span> <code><span style="background-color: #FF0000">&gt;=</span></code><span style="background-color: #FF0000">), 
  each with five overloads. For brevity, the specifications are given in tabular 
  form. Each of the resulting thirty-five signatures is a template, with 
  template parameter list template</span><code><span style="background-color: #FF0000">&lt;class 
  String, class Traits&gt;</span></code><span style="background-color: #FF0000">. 
  The format of such arguments is described in </span> <a href="#Pathname-formats">
  <span style="background-color: #FF0000">Pathname formats</span></a><span style="background-color: #FF0000">.</span></p>
    <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" height="150">
      <tr>
        <td width="100%" height="16">
        <p align="center"><i><b><span style="background-color: #FF0000">Argument type overloads</span></b></i></td>
      </tr>
      <tr>
        <td width="100%" height="16"><code>
        <span style="background-color: #FF0000">path&lt;String, Traits&gt;&amp; a, path&lt;String, Traits&gt;&amp; 
        b</span></code></td>
      </tr>
      <tr>
        <td width="100%" height="16"><code>
        <span style="background-color: #FF0000">const 
        typename path&lt;String, Traits&gt;::string_type&amp; a, 
        path&lt;String, Traits&gt;&amp; b</span></code></td>
      </tr>
      <tr>
        <td width="100%" height="16"><code>
        <span style="background-color: #FF0000">const 
        typename path&lt;String, Traits&gt;::string_type::value_type* a, 
        path&lt;String, Traits&gt;&amp; b</span></code></td>
      </tr>
      <tr>
        <td width="100%" height="5"><code>
        <span style="background-color: #FF0000">const 
        path&lt;String, Traits&gt;&amp; a, typename path&lt;String, Traits&gt;::string_type&amp; 
        b</span></code></td>
      </tr>
      <tr>
        <td width="100%" height="16"><code>
        <span style="background-color: #FF0000">const 
        path&lt;String, Traits&gt;&amp; a, typename 
        path&lt;String, Traits&gt;::string_type::value_type* b</span></code></td>
      </tr>
    </table>
  <p><span style="background-color: #FF0000">In the </span><b><i>
  <span style="background-color: #FF0000">path non-member operators </span>
  </i></b><span style="background-color: #FF0000">table, </span><code>
  <span style="background-color: #FF0000">a</span></code><span style="background-color: #FF0000"> 
  and </span><code><span style="background-color: #FF0000">b</span></code><span style="background-color: #FF0000"> 
  are of the types given in the </span><i><b>
  <span style="background-color: #FF0000">Argument type overloads</span></b></i><span style="background-color: #FF0000"> 
  table. If </span><code><span style="background-color: #FF0000">a</span></code><span style="background-color: #FF0000"> 
  or </span><code><span style="background-color: #FF0000">b</span></code><span style="background-color: #FF0000"> 
  is of type </span><code><span style="background-color: #FF0000">const 
  path&lt;String, Traits&gt;&amp;</span></code><span style="background-color: #FF0000">, 
  then </span><i><b><span style="background-color: #FF0000">a</span></b></i><code><i><b><span style="background-color: #FF0000">'</span></b></i></code><span style="background-color: #FF0000"> 
  or </span><i><b><span style="background-color: #FF0000">b'</span></b></i><span style="background-color: #FF0000"> 
  respectively is </span><code><span style="background-color: #FF0000">a</span></code><span style="background-color: #FF0000"> 
  or </span><code><span style="background-color: #FF0000">b</span></code><span style="background-color: #FF0000"> 
  respectively. Otherwise </span><i><b><span style="background-color: #FF0000">a</span></b></i><code><i><b><span style="background-color: #FF0000">'</span></b></i></code><span style="background-color: #FF0000"> 
  or </span><i><b><span style="background-color: #FF0000">b'</span></b></i><span style="background-color: #FF0000"> 
  respectively represent named or unnamed temporary </span><code>
  <span style="background-color: #FF0000">path&lt;String, Traits&gt;</span></code><span style="background-color: #FF0000"> 
  objects constructed from </span><code><span style="background-color: #FF0000">
  a</span></code><span style="background-color: #FF0000"> or </span><code>
  <span style="background-color: #FF0000">b</span></code><span style="background-color: #FF0000"> 
  respectively.</span></p>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" height="280">
  <tr>
    <td width="100%" colspan="3" align="center" height="19"><b><i>
    <span style="background-color: #FF0000">path non-member operators</span></i></b></td>
  </tr>
  <tr>
    <td width="20%" align="center" height="19"><i><b>
    <span style="background-color: #FF0000">Expression</span></b></i></td>
    <td width="25%" align="center" height="19"><i><b>
    <span style="background-color: #FF0000">Return type</span></b></i></td>
    <td width="55%" align="center" height="19"><i><b>
    <span style="background-color: #FF0000">Semantics</span></b></i></td>
  </tr>
  <tr>
    <td width="20%" align="center" height="30" valign="top"><code>
    <span style="background-color: #FF0000">a / b</span></code></td>
    <td width="25%" align="center" height="30" valign="top"><code>
    <span style="background-color: #FF0000">path&lt;String, Traits&gt;</span></code></td>
    <td width="55%" height="30"><code><span style="background-color: #FF0000">
    path&lt;String, Traits&gt; tmp(a);<br>
    return tmp /= </span></code><i><b><span style="background-color: #FF0000">b'</span></b></i><code><span style="background-color: #FF0000">;</span></code></td>
  </tr>
  <tr>
    <td width="20%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">a &lt; b</span></code></td>
    <td width="25%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">bool</span></code></td>
    <td width="55%" height="19"><code><span style="background-color: #FF0000">
    return lexicographical_compare(</span></code><span style="background-color: #FF0000"><i><b>a</b></i></span><code><span style="background-color: #FF0000"><i><b>'</b></i>.begin</span><span style="background-color: #FF0000">(), </span></code><i><b>
    <span style="background-color: #FF0000">a</span></b></i><code><span style="background-color: #FF0000"><i><b>'</b></i>.end</span><span style="background-color: #FF0000">(), </span></code><i><b>
    <span style="background-color: #FF0000">b'</span></b></i><code><span style="background-color: #FF0000">.begin</span><span style="background-color: #FF0000">(), </span></code><i><b>
    <span style="background-color: #FF0000">b'</span></b></i><code><span style="background-color: #FF0000">.end</span><span style="background-color: #FF0000">());</span></code></td>
  </tr>
  <tr>
    <td width="20%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">a == b</span></code></td>
    <td width="25%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">bool</span></code></td>
    <td width="55%" height="19"><code><span style="background-color: #FF0000">
    return !(</span></code><i><b><span style="background-color: #FF0000">a</span></b></i><code><i><b><span style="background-color: #FF0000">'</span></b></i><span style="background-color: #FF0000"> 
    &lt; </span></code><i><b><span style="background-color: #FF0000">b'</span></b></i><code><span style="background-color: #FF0000">) 
    &amp;&amp; !(</span></code><i><b><span style="background-color: #FF0000">b'</span></b></i><code><span style="background-color: #FF0000"> 
    &lt; </span></code><i><b><span style="background-color: #FF0000">a</span></b></i><code><i><b><span style="background-color: #FF0000">'</span></b></i><span style="background-color: #FF0000">);</span></code></td>
  </tr>
  <tr>
    <td width="20%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">a != b</span></code></td>
    <td width="25%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">bool</span></code></td>
    <td width="55%" height="19"><code><span style="background-color: #FF0000">
    return !(</span></code><i><b><span style="background-color: #FF0000">a</span></b></i><code><i><b><span style="background-color: #FF0000">'</span></b></i><span style="background-color: #FF0000"> 
    == </span></code><i><b><span style="background-color: #FF0000">b'</span></b></i><code><span style="background-color: #FF0000">);</span></code></td>
  </tr>
  <tr>
    <td width="20%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">a &gt; b</span></code></td>
    <td width="25%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">bool</span></code></td>
    <td width="55%" height="19"><code><span style="background-color: #FF0000">
    return </span></code><i><b><span style="background-color: #FF0000">b'</span></b></i><code><span style="background-color: #FF0000"> 
    &lt; </span></code><i><b><span style="background-color: #FF0000">a</span></b></i><code><i><b><span style="background-color: #FF0000">'</span></b></i><span style="background-color: #FF0000">;</span></code></td>
  </tr>
  <tr>
    <td width="20%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">a &lt;= b</span></code></td>
    <td width="25%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">bool</span></code></td>
    <td width="55%" height="19"><code><span style="background-color: #FF0000">
    return !(</span></code><i><b><span style="background-color: #FF0000">b'</span></b></i><code><span style="background-color: #FF0000"> 
    &lt; </span></code><i><b><span style="background-color: #FF0000">a</span></b></i><code><i><b><span style="background-color: #FF0000">'</span></b></i><span style="background-color: #FF0000">);</span></code></td>
  </tr>
  <tr>
    <td width="20%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">a &gt;= b</span></code></td>
    <td width="25%" align="center" height="19" valign="top"><code>
    <span style="background-color: #FF0000">bool</span></code></td>
    <td width="55%" height="19"><code><span style="background-color: #FF0000">
    return !(</span></code><i><b><span style="background-color: #FF0000">a</span></b></i><code><i><b><span style="background-color: #FF0000">'</span></b></i><span style="background-color: #FF0000"> 
    &lt; </span></code><i><b><span style="background-color: #FF0000">b'</span></b></i><code><span style="background-color: #FF0000">);</span></code></td>
  </tr>
</table>
  <blockquote>
  <p><span style="background-color: #FF0000">[</span><i><span style="background-color: #FF0000">Note:</span></i><span style="background-color: #FF0000">
  </span> <a name="Path-equality"><span style="background-color: #FF0000">Path equality</span></a><span style="background-color: #FF0000"> and path 
  equivalence have different semantics.</span></p>
  <p><span style="background-color: #FF0000">Equality is determined by </span> <i>
  <span style="background-color: #FF0000">path</span></i><span style="background-color: #FF0000">'s 
  non-member </span> <code><a href="#operator-eq">
  <span style="background-color: #FF0000">operator==</span></a></code><span style="background-color: #FF0000">, which considers the two path's lexical representations 
  only. Paths &quot;abc&quot; and &quot;ABC&quot; are never equal.</span></p>
  <p><span style="background-color: #FF0000">Equivalence is determined by the
  </span> <a href="#equivalent"><span style="background-color: #FF0000">equivalent()</span></a><span style="background-color: #FF0000"> 
  non-member function, which determines if two paths </span>
  <a href="#pathname-resolution"><span style="background-color: #FF0000">resolve</span></a><span style="background-color: #FF0000"> to the same file system entity. 
  Paths &quot;abc&quot; 
  and &quot;ABC&quot; may or may not resolve to the same file, depending on the file 
  system.</span></p>
  <p><span style="background-color: #FF0000">Programmers wishing to determine if two paths are &quot;the same&quot; must decide if 
  &quot;the same&quot; means &quot;the same representation&quot; or &quot;resolve to the same actual 
  file&quot;, and choose the appropriate function accordingly. </span> <i>
  <span style="background-color: #FF0000">-- end note</span></i><span style="background-color: #FF0000">]</span></p>
</blockquote>
  <h4><a name="path-inserter-extractor"> <code>
  <span style="background-color: #FFFFFF">path</span></code><span style="background-color: #FFFFFF"> inserters 
  and extractor</span></a><span style="background-color: #FFFFFF">s</span></h4>
<pre>std::ostream&amp; operator&lt;&lt;(std::ostream &amp; os, const path&amp; p);</pre>
<blockquote>
  <p><i><span style="background-color: #FFFFFF">Effects:</span></i><span style="background-color: #FFFFFF">&nbsp;
  <code>os &lt;&lt; p.native_string();</code></span></p>
  <p><i><span style="background-color: #FFFFFF">Returns:</span></i><span style="background-color: #FFFFFF">
  </span> <code><span style="background-color: #FFFFFF">os</span></code></p>
</blockquote>
<pre>std::wostream&amp; operator&lt;&lt;(std::wostream &amp; os, const path&amp; p);</pre>
<blockquote style="font-size: 10pt">
  <p style="font-size: 10pt"><i><span style="background-color: #FFFFFF">Effects:</span></i><span style="background-color: #FFFFFF">&nbsp;
  <code>os &lt;&lt; p.native_wstring();</code></span></p>
  <p style="font-size: 10pt"><i><span style="background-color: #FFFFFF">Returns:</span></i><span style="background-color: #FFFFFF">
  </span><code><span style="background-color: #FFFFFF">os</span></code></p>
</blockquote>
<pre>std::istream&amp; operator&gt;&gt;(std::istream &amp; is, path&amp; p);</pre>
<blockquote>
  <p><span style="background-color: #FFFFFF"><i>Effects: </i>
      <code>&nbsp; std::string str;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is &gt;&gt; str;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = str;</code></span></p>
  <p><i><span style="background-color: #FFFFFF">Returns:</span></i><span style="background-color: #FFFFFF">
  </span> <code><span style="background-color: #FFFFFF">is</span></code></p>
  </blockquote>
<pre>std::wistream&amp; operator&gt;&gt;(std::wistream &amp; is, path&amp; p);</pre>
<blockquote>
  <p><span style="background-color: #FFFFFF"><i>Effects: </i>
      <code>&nbsp; std::wstring str;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is &gt;&gt; str;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = str;</code></span></p>
  <p><i><span style="background-color: #FFFFFF">Returns:</span></i><span style="background-color: #FFFFFF">
  </span> <code><span style="background-color: #FFFFFF">is</span></code></p>
  </blockquote>
<h3><a name="Class-filesystem_error">Class <code>filesystem_error</code></a></h3>
<pre>  namespace boost
  {
    namespace filesystem
    {
      class basic_filesystem_error : public <span style="background-color: #FFFFFF">system</span>_error
      {
      public:
        filesystem_error();
        filesystem_error(const filesystem_error&amp;);
        <a href="#filesystem_error-2-arg">filesystem_error</a>(const std::string&amp; <span style="background-color: #FFFFFF">what_arg</span>, system::error_code ec);
        <a href="#filesystem_error-3-arg">filesystem_error</a>(const std::string&amp; <span style="background-color: #FFFFFF">what_arg</span>, const path&amp; p1, system::error_code ec);
        <a href="#filesystem_error-4-arg">filesystem_error</a>(const std::string&amp; <span style="background-color: #FFFFFF">what_arg</span>, const path&amp; p1, const path&amp; p2, system::error_code ec);

        filesystem_error&amp; filesystem_error(const filesystem_error&amp;);
       ~filesystem_error();

        filesystem_error&amp; operator=(const filesystem_error&amp;);

        const path&amp; <a href="#filesystem_error-path1">path1</a>() const;
        const path&amp; <a href="#filesystem_error-path2">path2</a>() const;

        const char * <a href="#filesystem_error-what">what</a>() const;
      };
    } // namespace filesystem
  } // namespace boost</pre>
<p>The class template <code>basic_filesystem_error</code> defines the type of 
objects thrown as exceptions to report file system errors from functions described in this 
clause.</p>
<h4> <a name="filesystem_error-members"> <code>filesystem_error</code> members</a></h4>
<pre><a name="filesystem_error-2-arg">filesystem_error</a>(const std::string&amp; <span style="background-color: #FFFFFF">what_arg</span>, error_code ec);</pre>
<blockquote>
  <p><i>Postconditions:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%" bgcolor="#FFFFFF"><code>
      <span style="background-color: #FFFFFF">runtime_error::what</span>()</code></td>
      <td width="82%" bgcolor="#FFFFFF"><span style="background-color: #FFFFFF">
      <code><i>what_arg</i>.c_str()</code></span></td>
    </tr>
    <tr>
      <td width="18%"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path1().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path2().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
  </table>
</blockquote>
<pre><a name="filesystem_error-3-arg">filesystem_error</a>(const std::string&amp; <span style="background-color: #FFFFFF">what_arg</span>, const path_type&amp; p1, error_code ec);</pre>
<blockquote>
  <p><i>Postconditions:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>
      <span style="background-color: #FFFFFF">runtime_error::what</span>()</code></td>
      <td width="82%"><span style="background-color: #FFFFFF">
      <code><i>what_arg</i>.c_str()</code></span></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>path1()</code></td>
      <td width="82%"><span style="background-color: #FFFFFF">Reference to stored copy of
      </span> <code>p1</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>path2().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
  </table>
</blockquote>
<pre><a name="filesystem_error-4-arg">filesystem_error</a>(const std::string&amp; <span style="background-color: #FFFFFF">what_arg</span>, const path_type&amp; p1, const path_type&amp; p2, error_code ec);</pre>
<blockquote>
  <p><i>Postconditions:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>
      <span style="background-color: #FFFFFF">runtime_error::what</span>()</code></td>
      <td width="82%"><span style="background-color: #FFFFFF">
      <u>
      <code><i>w</i></code></u><code><i>hat_arg</i>.c_str()</code></span></td>
    </tr>
    <tr>
      <td width="18%"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path1()</code></td>
      <td width="82%"><span style="background-color: #FFFFFF">Reference to stored copy of
      </span> <code>p1</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path2()</code></td>
      <td width="82%"><span style="background-color: #FFFFFF">Reference to stored copy of
      </span> <code>p2</code></td>
    </tr>
  </table>
</blockquote>
<pre>const path&amp; <a name="filesystem_error-path1">path1</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> Reference to copy of <code>p1</code> stored by the 
  constructor, or, if none, an empty path.</p>
</blockquote>
<pre>const path&amp; <a name="filesystem_error-path2">path2</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> Reference to copy of <code>p2</code> stored by the 
  constructor, or, if none, an empty path.</p>
</blockquote>
<pre>const char* <a name="filesystem_error-what">what</a>() const;</pre>
<blockquote>
  <p><i>Returns: </i>A string containing <code>runtime_error::what()</code>. The exact format is unspecified. 
  Implementations are encouraged but not required to include <code>
  path1.native_string()</code>if not empty, <code>path2.native_string()</code>if 
  not empty, and <code>system_error::what()</code> strings in the returned 
  string.</p>
</blockquote>
<h3><a name="Class-directory_entry">Class <code>directory_entry</code></a></h3>
<pre>  namespace boost
  {
    namespace filesystem
    {
      class directory_entry
      {
      public:

        // <a href="#directory_entry-constructors">constructors</a> and destructor
        directory_entry();
        directory_entry(const directory_entry&amp;);
        explicit directory_entry(const path_type&amp; p, <span style="background-color: #FFFFFF">file_status</span> st=file_status(), <span style="background-color: #FFFFFF">file_status</span> symlink_st=file_status());
       ~directory_entry(); 

        // <a href="#directory_entry-modifiers">modifiers</a>
        directory_entry&amp; operator=(const directory_entry&amp;);
        void assign(const path_type&amp; p, <span style="background-color: #FFFFFF">file_status</span> st=file_status(), <span style="background-color: #FFFFFF">file_status</span> symlink_st=file_status());
        void replace_filename(const string_type&amp; s, <span style="background-color: #FFFFFF">file_status</span> st=file_status(), <span style="background-color: #FFFFFF">file_status</span> symlink_st=file_status());

        // <a href="#directory_entry-observers">observers</a>
        const path&amp;  path() const;
<span style="background-color: #FFFFFF">        file_status  status(system::error_code&amp; ec) const;
        file_status  symlink_status(system::error_code&amp; ec) const;
</span><span style="background-color: #FFFF00">
</span>      private:
        path_type            m_path;           // for exposition only
        mutable <span style="background-color: #FFFFFF">file_status</span>  m_status;         // for exposition only; stat()-like
        mutable <span style="background-color: #FFFFFF">file_status</span>  m_symlink_status; // for exposition only; lstat()-like
      };

    } // namespace filesystem
  } // namespace boost</pre>
<p>A <code>directory_entry</code> object stores a <code>path object</code>, 
a <code>file_status</code> object for non-symbolic link status, and a <code>
file_status</code> object for symbolic link status. The <code>file_status</code> 
objects act as value caches.</p>
<blockquote>
<p>[<i>Note:</i> Because <code>status()</code>on a pathname may be a very expensive operation, 
some operating systems provide status information as a byproduct of directory 
iteration. Caching such status information can result is significant time savings. Cached and 
non-cached results may differ in the presence of race conditions. <i>-- end note</i>]</p>
<p><span style="background-color: #E0E0E0"><i>Actual cold-boot timing of iteration over 
a directory with 15,047 entries was six seconds for non-cached status queries 
versus one second for cached status queries. Windows XP, 3.0 GHz processor, with 
a moderately fast hard-drive. Similar speedup expected on Linux and BSD-derived 
Unix variants that provide status during directory iteration.</i></span></p>
</blockquote>
<h4> <a name="directory_entry-constructors"> <code>directory_entry </code>constructors</a></h4>
<pre>directory_entry();</pre>
<blockquote>
  <p><i>Postconditions:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="36%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>path().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
    <tr>
      <td width="18%"><code>status()</code></td>
      <td width="82%"><code>file_status()</code></td>
    </tr>
    <tr>
      <td width="18%"><code>symlink_status()</code></td>
      <td width="82%"><code>file_status()</code></td>
    </tr>
  </table>
</blockquote>
<pre>explicit directory_entry(const path_type&amp; p, <span style="background-color: #FFFFFF">file_status</span> st=file_status(), <span style="background-color: #FFFFFF">file_status</span> symlink_st=file_status());</pre>
<blockquote>
  <p><i>Postconditions:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="36%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>path()</code></td>
      <td width="82%"><code>p</code></td>
    </tr>
    <tr>
      <td width="18%"><code>status()</code></td>
      <td width="82%"><code>st</code></td>
    </tr>
    <tr>
      <td width="18%"><code>symlink_status()</code></td>
      <td width="82%"><code>symlink_st</code></td>
    </tr>
  </table>
</blockquote>
<h4> <a name="directory_entry-modifiers"> <code>directory_entry </code>modifiers</a></h4>
<pre>void assign(const path_type&amp; p, <span style="background-color: #FFFFFF">file_status</span> st=file_status(), <span style="background-color: #FFFFFF">file_status</span> symlink_st=file_status());</pre>
<blockquote>
  <p><i>Postconditions:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="36%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>path()</code></td>
      <td width="82%"><code>p</code></td>
    </tr>
    <tr>
      <td width="18%"><code>status()</code></td>
      <td width="82%"><code>st</code></td>
    </tr>
    <tr>
      <td width="18%"><code>symlink_status()</code></td>
      <td width="82%"><code>symlink_st</code></td>
    </tr>
  </table>
</blockquote>
<pre>void replace_filename(const string_type&amp; s, <span style="background-color: #FFFFFF">file_status</span> st=file_status(), <span style="background-color: #FFFFFF">file_status</span> symlink_st=file_status());</pre>
<blockquote>
  <p><i>Postconditions:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="43%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>path()</code></td>
      <td width="82%"><code>path().branch() / s</code></td>
    </tr>
    <tr>
      <td width="18%"><code>status()</code></td>
      <td width="82%"><code>st</code></td>
    </tr>
    <tr>
      <td width="18%"><code>symlink_status()</code></td>
      <td width="82%"><code>symlink_st</code></td>
    </tr>
  </table>
</blockquote>
<h4> <a name="directory_entry-observers"> <code>directory_entry</code> observers</a></h4>
<pre>const path&amp; path() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path</code></p>
</blockquote>
<pre><span style="background-color: #FFFFFF">file_status status(system::error_code&amp; ec) const;</span></pre>
<blockquote>
<p><span style="font-style: italic; background-color: #FFFFFF">Effects:</span><span style="background-color: #FFFFFF"> 
As if,</span></p>
  <blockquote>
    <pre><span style="background-color: #FFFFFF">if ( !status_known( m_status ) )
{
  if ( status_known(m_symlink_status) &amp;&amp; !is_symlink(m_symlink_status) )
    { m_status = m_symlink_status; }
  else { m_status = status(m_path, ec); }
}
else if ( &amp;ec != &amp;boost::throws() ) ec.clear();</span></pre>
  </blockquote>
  <p><span style="background-color: #FFFFFF"><i>Returns:</i> <code>m_status</code></span></p>
</blockquote>
<pre><span style="background-color: #FFFFFF">file_status  symlink_status(system::error_code&amp; ec) const;</span></pre>
<blockquote>
<p><span style="font-style: italic; background-color: #FFFFFF">Effects:</span><span style="background-color: #FFFFFF"> 
As if,</span></p>
  <blockquote>
    <pre><span style="background-color: #FFFFFF">if ( !status_known( m_symlink_status ) )
{
  m_symlink_status = symlink_status(m_path, ec);
}
else if ( &amp;ec != &amp;boost::throws() ) ec.clear();</span></pre>
  </blockquote>
  <p><span style="background-color: #FFFFFF"><i>Returns:</i> <code>
  m_symlink_status</code></span></p>
</blockquote>
<h3><a name="Class-directory_iterator">Class <code>directory_iterator</code></a></h3>
<p>Objects of type <code>directory_iterator</code> provide standard library 
compliant iteration over the contents of a directory. Also see class <code>
<a href="#Class-recursive_directory_iterator">recursive_directory_iterator</a></code>.</p>
<pre>  namespace boost
  {
    namespace filesystem
    {
      class directory_iterator
        : public boost::iterator_facade&lt; directory_iterator,
                                         <a href="#Class-directory_entry">directory_entry</a>,
                                         boost::single_pass_traversal_tag &gt;
      {
      public:
        // <a href="#directory_iterator-members">member functions</a>

        directory_iterator();  // creates the &quot;end&quot; iterator
        directory_iterator(const directory_iterator&amp;);
        explicit directory_iterator(const path&amp; p);
        directory_iterator(const path&amp; p, system::error_code&amp; ec);
       ~directory_iterator();

        directory_iterator&amp; operator=(const directory_iterator&amp;);

        directory_iterator&amp; operator++();
        directory_iterator&amp; increment(system::error_code&amp; ec);

        // other members as required by
        //  C++ Std, 24.1.1 Input iterators [input.iterators]
      };

    } // namespace filesystem
  } // namespace boost</pre>
<p> <code>directory_iterator</code> satisfies the requirements of an 
input iterator (C++ Std, 24.2.1, Input iterators [input.iterators]).</p>
<p>A <code>directory_iterator</code> reads successive elements from the directory for 
which it was constructed, as if by calling <i>POSIX</i>
<code>
<a href="http://www.opengroup.org/onlinepubs/000095399/functions/readdir_r.html">readdir_r()</a></code>. After a <code>directory_iterator</code> is constructed, and every time 
<code>operator++</code> is called, 
it reads a directory element and stores information about it in a object of type <code>
<a href="#Class-directory_entry">directory_entry</a></code>. 
<code>operator++</code> is not equality preserving; that is, <code>i == j</code> does not imply that
<code>++i == ++j</code>. </p>
<blockquote>
<p>[<i>Note:</i> The practical consequence of not preserving equality is that directory iterators 
can only be used for single-pass algorithms. <i>--end note</i>]</p>
</blockquote>
<p>If the end of the directory elements is reached, the iterator becomes equal to 
the end iterator value. The constructor <code>directory_iterator()</code> 
with no arguments always constructs an end iterator object, which is the only 
legitimate iterator to be used for the end condition. The result of <code>
operator*</code> on an end iterator is not defined. For any other iterator value 
a <code>const directory_entry&amp;</code> is returned. The result of
<code>operator-&gt;</code> on an end iterator is not defined. For any other iterator value a <code>const directory_entry*</code> is 
returned. </p>
<p>Two end iterators are always equal. An end iterator is not equal to a non-end 
iterator.</p>
<blockquote>
<p><i><span style="background-color: #E0E0E0">The above wording is based on the 
Standard Library's istream_iterator wording. Commentary was shortened and 
moved into a note.</span></i></p>
</blockquote>
<p>The result of calling the <code>path()</code> member of the <code>
directory_entry</code> object obtained by dereferencing a <code>
directory_iterator</code> is a reference to a <code>path</code> 
object composed of the directory argument from which the iterator was 
constructed with filename of the directory entry appended as if by <code>
operator/=</code>. </p>
<p>Directory iteration shall not yield directory entries for the current (<i>dot</i>) 
and parent (<i>dot dot</i>) directories.</p>
<p>The order of directory entries obtained by dereferencing successive 
increments of a <code>directory_iterator</code> is unspecified.</p>
<blockquote>
<p>[<i>Note:</i> Programs performing directory iteration may wish to test if the 
path obtained by dereferencing a directory iterator actually exists. It could be 
a
symbolic link to a non-existent file. Programs recursively 
walking directory trees for purposes of removing and renaming entries may wish 
to avoid following symbolic links.</p>
<p>If a file  is removed from or added to a directory after the 
construction of a <code>directory_iterator</code> for the directory, it is 
unspecified whether or not subsequent incrementing of the iterator will ever 
result in an iterator whose value is the removed or added directory entry. See
<i>POSIX</i>
<code>
<a href="http://www.opengroup.org/onlinepubs/000095399/functions/readdir_r.html">readdir_r()</a></code>. <i>
--end note</i>]</p>
</blockquote>
<h4><a name="directory_iterator-members"><code>directory_iterator</code> members</a></h4>

<p><code><a name="directory_iterator-default-ctor">directory_iterator</a>();</code></p>

<blockquote>

<p><i>Effects:</i> Constructs the end iterator.</p>

<p><i>Throws:</i> Nothing.</p>

</blockquote>

<pre><code>explicit <a name="directory_iterator-ctor-path">directory_iterator</a>(</code>const path&amp; p<code>);
directory_iterator(</code>const path&amp; p, system::error_code&amp; ec<code>);</code></pre>
<blockquote>

<p><i>Effects:</i> Constructs a iterator representing the first 
entry in the directory <code>p</code> resolves to, if any; otherwise, the end iterator.</p>

<p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>

<p>[<i>Note:</i> To iterate over the current directory, use <code>
directory_iterator(&quot;.&quot;)</code> rather than <code>directory_iterator(&quot;&quot;)</code>.
<i>-- end note</i>]</p>
</blockquote>
<pre>directory_iterator&amp; <a name="directory_iterator-increment">operator++</a>();
directory_iterator&amp; increment(system::error_code&amp; ec);</pre>
<blockquote>

<p><i>Effects:</i> As specified by the C++ Standard, 24.1.1 Input iterators [input.iterators]</p>

<p><i>Returns:</i> <code>*this</code>.</p>

<p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>

</blockquote>
<h3><a name="Class-recursive_directory_iterator">Class <code>recursive_directory_iterator</code></a></h3>
<p>Objects of type <code>directory_iterator</code> provide standard library 
compliant iteration over the contents of a directory, including recursion into 
its sub-directories.</p>
<pre>  namespace boost
  {
    namespace filesystem
    {
      class recursive_directory_iterator :
        public iterator&lt;input_iterator_tag, directory_entry &gt;
      {
      public:

        // constructors and destructor
        recursive_directory_iterator();
        recursive_directory_iterator(const recursive_directory_iterator&amp;);
        explicit recursive_directory_iterator(const path&amp; p);
        recursive_directory_iterator(const path&amp; p, system::error_code&amp; ec);
       ~recursive_directory_iterator();

        // observers
        int level() const;
        bool no_push<code>_request</code>() const;

        // modifiers
        recursive_directory_iterator&amp; operator=(const recursive_directory_iterator&amp;);

        recursive_directory_iterator&amp; operator++();
        recursive_directory_iterator&amp; increment(system::error_code&amp; ec);

        void pop();
        void no_push();

        // other members as required by
        //  C++ Std, 24.1.2 Input iterators [input.iterators]

      private:
        int  m_level; <b><i>          // for exposition only</i></b>
        bool m_no_<code>push_request</code>;  <b><i>// for exposition only</i></b>
      };

    } // namespace filesystem
  } // namespace boost</pre>
<p>The behavior of a <code>recursive_directory_iterator</code> is the same 
as a <code>directory_iterator</code> unless otherwise specified.</p>
<ul>
  <li>When an iterator reaches the end of the directory currently being iterated 
  over, or when <code>pop()</code> is called, <code>m_level</code> is 
  decremented, and iteration continues with the parent directory, until the 
  directory specified in the constructor argument is reached.</li>
</ul>
<blockquote>
  <p>[<i>Note:</i> One of the uses of <code>no_push()</code> is to prevent 
  unwanted recursion into a directory symlink. This may be necessary to 
  prevent loops on some operating systems. <i>--end note</i>]</p>
</blockquote>
<pre>recursive_directory_iterator();</pre>
<blockquote>

<p><i>Effects:</i> Constructs the end iterator.</p>

<p><i>Throws:</i> Nothing.</p>

</blockquote>

<pre><code>explicit </code>recursive_<code>directory_iterator(</code>const path&amp; p<code>);
</code>recursive_<code>directory_iterator(</code>const path&amp; p, system::error_code&amp; ec<code>);</code></pre>
<blockquote>

<p><i>Effects:</i>&nbsp; Constructs a iterator representing the first 
entry in the directory <code>p</code> resolves to, if any; otherwise, the end iterator.</p>

<p><i>Postconditions: </i>Unless the end iterator was constructed,<i> </i><code>
level() == 0</code>, <code>no_push_request() == false</code>.</p>

<p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>

<p>[<i>Note:</i> To iterate over the current directory, use <code>recursive_directory_iterator(&quot;.&quot;)</code> rather than
<code>recursive_directory_iterator(&quot;&quot;)</code>.
<i>-- end note</i>]</p>
</blockquote>
<pre>int level() const;</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p><i>Returns:</i> <code>m_level</code>.</p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre>bool <code>no_push_request</code>() const;</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p><i>Returns:</i> <code>m_no_push_request</code>.</p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre><code>recursive_</code>directory_iterator&amp; <a name="directory_iterator-increment">operator++</a>();
<code>recursive_</code>directory_iterator&amp; increment(system::error_code&amp; ec);</pre>
<blockquote>

<p><i>Effects:</i> As specified by the C++ Standard, 24.1.1 Input iterators [input.iterators], 
except that if <code>(*this)-&gt;is_directory() &amp;&amp; !no_push_requested()</code> then&nbsp; <code>m_level</code> 
is incremented and <code>(*this)-&gt;path()</code> is recursively iterated into.</p>

<p><i>Postconditions:</i> <code>no_push_request() == false</code>.</p>

<p><i>Returns:</i> <code>*this</code>.</p>

<p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>

</blockquote>
<pre>void pop();</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p><i>Effects:</i> If <code>level() == 0</code>, set <code>*this</code> to <code>recursive_directory_iterator()</code>. 
  Otherwise, <code>--m_level</code>, cease iteration of the directory currently being 
  iterated over, and continue iteration over the parent directory.</p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre>void no_push();</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
<p><i>Postconditions:</i> <code>no_push_request() == true</code>.</p>
  <p><i>Throws:</i> Nothing.</p>
  <p>[<i>Note:</i> One of the uses of <code>no_push()</code> is to prevent 
  unwanted recursion into a directory symlink. This may be necessary to 
  prevent loops on some operating systems. <i>--end note</i>]</p>
</blockquote>
<h3><a name="file_status">Class file_status</a></h3>
<pre>  namespace boost
  {
    namespace filesystem
    {
      class file_status
      {
      public:
        file_status();
        file_status(const file_status&amp;);
        explicit file_status(file_type v=status_error);
       ~file_status();

        <a href="#file_type">file_type</a> type() const;
        void type(file_type v);
      };
    } // namespace filesystem
  } // namespace boost</pre>
<p>An object of type <code>file_status</code> stores information about the status of a 
file. The internal form of the stored information is unspecified.</p>
<blockquote>
  <p><i>[Note: </i>The class may be extended in the future to store 
  additional status information. <i>--end note]</i></p>
</blockquote>
<h4>Members</h4>
<pre>explicit file_status(<a href="#file_type">file_type</a> v=status_error);</pre>
<blockquote>
  <p><i>Effects:</i> Stores <code>v</code>.</p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre>file_type type() const;</pre>
<blockquote>
  <p><i>Returns: </i>The stored <a href="#file_type"> <code>file_type</code>.</a></p>
</blockquote>
<pre>void type(<a href="#file_type">file_type</a> v);</pre>
<blockquote>
  <p><i>Effects:</i> Stores <code>v</code>, replacing the previously stored 
  value.</p>
</blockquote>
<h3><a name="Operational-functions">Operational functions</a></h3>
<p>Operational functions query or modify files, including directories, in external 
storage.</p>
<p style="font-size: 10pt">Operational functions access a file by resolving an 
object of class <code>path</code> to a particular file in a file hierarchy. The 
path is resolved as if by the <i>POSIX</i>
<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap04.html#tag_04_11">
Pathname Resolution</a> mechanism.</p>
<p>[<i>Note: </i>Because hardware failures, network failures,
<a href="#Race-condition">race conditions</a>, and many 
other kinds of errors occur frequently in file system operations, users should be aware 
that any filesystem operational function, no matter how apparently innocuous, may encounter 
an error.&nbsp;See <a href="#Error-reporting">Error reporting</a>. <i>-- end note</i>]</p>
<h4><a name="Function-specifications">Operational function specifications</a></h4>
<pre>path <a name="complete">complete</a>(const path&amp; p, const path&amp; base, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects:</i> Composes a complete path from <code>p</code> and <code>base</code>, 
  using the following rules:</p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td align="center">&nbsp;</td>
      <td align="center"><b><code>p.has_root_directory()</code></b></td>
      <td align="center"><b><code>!p.has_root_directory()</code></b></td>
    </tr>
    <tr>
      <td align="center"><b><code>p.has_root_name()</code></b></td>
      <td align="center"><code>p</code></td>
      <td align="center">precondition failure</td>
    </tr>
    <tr>
      <td align="center"><b><code>!p.has_root_name()</code></b></td>
      <td align="center"><code>base.root_name()<br>
      / p</code></td>
      <td align="center"><code>base / p</code></td>
    </tr>
  </table>
  <p><i>Postconditions:</i> For the returned path, <code>rp,</code> <code>
  rp.is_complete()</code> is true.</p>
  <p><i>Returns:</i> The composed path.</p>
  <p><i><span style="background-color: #FFFF00">Throws: </span> </i> <code>
  <span style="background-color: #FFFF00">filesystem_error</span></code><span style="background-color: #FFFF00"> if
  </span> <code>
  <span style="background-color: #FFFF00">!(base.is_complete() &amp;&amp; (p.is_complete() || !p.has_root_name()))</span></code></p>
  <p>[<i><a name="complete_note">Note</a>:</i> When portable behavior is 
  required, use <i>complete()</i>. When operating system dependent behavior is 
  required, use <i>system_complete()</i>.</p>
  <p>Portable behavior is useful when dealing with paths created 
  internally within a program, particularly if the program should exhibit the 
  same behavior on all operating systems.</p>
  <p>Operating system dependent behavior is useful when dealing with 
  paths supplied by user input, reported to program users, or when such behavior 
  is expected by program users. <i>-- 
  end note</i>]</p>
</blockquote>
<pre>path complete(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
<p><i>Returns:</i> <code>path(p, initial_path(), ec)</code>.</p>
<p><i><span style="background-color: #FFFF00">Throws: </span> </i> </p>
</blockquote>
<pre>void copy_file(const path&amp; from, const path&amp; to);</pre>
<blockquote>
  <p><i>Effects: </i><code>copy_file(from, to, 
  copy_option::fail_if_exists)</code>.</p>
  
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
  
</blockquote>
<pre>void copy_file(const path&amp; from, const path&amp; to, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects: </i><code>copy_file(from, to, 
  copy_option::fail_if_exists, ec)</code>.</p>
  
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
  
</blockquote>
<pre>void <a name="copy_file">copy_file</a>(const path&amp; from, const path&amp; to, BOOST_SCOPED_ENUM(<a href="#copy_option">copy_option</a>) option);
void <a name="copy_file">copy_file</a>(const path&amp; from, const path&amp; to, BOOST_SCOPED_ENUM(<a href="#copy_option">copy_option</a>) option, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects:</i> If <code>option == copy_option::</code><span style="background-color: #FFFFFF"><code>fail_if_exists 
  &amp;&amp; exists(to)</code>, an error is reported. Otherwise, t</span>he contents and attributes of the file <code>from</code> 
  resolves to are copied to the file <code>to</code> resolves to.</p>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
</blockquote>
<pre>bool <a name="create_directories">create_directories</a>(const path&amp; p);
bool <a name="create_directories">create_directories</a>(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Requires:</i> <code>p.empty() || <br>
  forall px: px == p || is_parent(px, p): is_directory(px) || !exists( px )</code>
  </p>
  <p><i>Postconditions:</i> <code>is_directory(p)</code></p>
  <p><i>Returns:</i> The value of <code>!exists(p)</code> prior to the 
  establishment of the postcondition.</p>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
</blockquote>
<pre>bool <a name="create_directory">create_directory</a>(const path&amp; p);
bool <a name="create_directory">create_directory</a>(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects:</i> Attempts to create the directory <code>p</code> resolves to, 
  as if by<i> POSIX </i><code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/mkdir.html">mkdir()</a></code> with a second argument of S_IRWXU|S_IRWXG|S_IRWXO. </p>
  <p><i>Postcondition:</i> <code>is_directory(p)</code></p>
  <p><i>Returns:</i> <code>true</code> if a new directory was created, otherwise 
  <code>false</code>.</p>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
</blockquote>
<pre><span style="background-color: #FFFFFF">void <a name="create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; from);
void <a name="create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; from, system::error_code&amp; ec);</span></pre>
<blockquote>
  <p><i><span style="background-color: #FFFFFF">Effects:</span></i><span style="background-color: #FFFFFF"> Establishes the postcondition, as if by
  </span> <i><span style="background-color: #FFFFFF">POSIX</span></i><span style="background-color: #FFFFFF">
  </span> <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/link.html">
  <span style="background-color: #FFFFFF">link()</span></a></code><span style="background-color: #FFFFFF">.</span></p>
  <p><i><span style="background-color: #FFFFFF">Postconditions:</span></i></p>
  <ul>
    <li><span style="background-color: #FFFFFF">&nbsp;</span><code><span style="background-color: #FFFFFF">exists(to) &amp;&amp; 
    exists(from) &amp;&amp; equivalent(to, 
    from)</span></code></li>
    <li><span style="background-color: #FFFFFF">The contents of the file or directory
    <code>to</code> resolves to are unchanged.</span></li>
  </ul>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
  <p><span style="background-color: #FFFFFF">[</span><i><span style="background-color: #FFFFFF">Note:</span></i><span style="background-color: #FFFFFF"> 
  Some <b>operating systems</b> do not support hard links at all or support 
  them only for regular files. Some <b>file systems</b> do not support hard 
  links regardless of the operating system - the FAT system used on floppy 
  discs, memory cards and flash drives, for example. Some file systems limit the 
  number of links per file. Thus hard links should only be used if these 
  situations are not concerns, or if workarounds are provided. </span> <i><span style="background-color: #FFFFFF">-- end note</span></i><span style="background-color: #FFFFFF">]</span></p>
  </blockquote>
<pre><span style="background-color: #FFFFFF">void <a name="create_symlink">create_symlink</a>(const path&amp; to, const path&amp; from);
void <a name="create_symlink">create_symlink</a>(const path&amp; to, const path&amp; from, system::error_code&amp; ec);</span></pre>
<blockquote style="font-size: 10pt">
  <p style="font-size: 10pt"><i><span style="background-color: #FFFFFF">Effects:</span></i><span style="background-color: #FFFFFF"> 
  Establishes the postcondition, as if by </span><i>
  <span style="background-color: #FFFFFF">POSIX</span></i><span style="background-color: #FFFFFF">
  </span><code><span style="background-color: #FFFFFF">
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/symlink.html">
  symlink()</a></span></code><span style="background-color: #FFFFFF">.</span></p>
  <p style="font-size: 10pt"><span style="background-color: #FFFFFF"><i>
  Postconditions:</i> <code>from</code> resolves to a symbolic link file that 
  contains an unspecified representation of <code>to</code>.</span></p>
  <p style="font-size: 10pt"><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
  <p><span style="background-color: #FFFFFF">[</span><i><span style="background-color: #FFFFFF">Note:</span></i><span style="background-color: #FFFFFF"> 
  Some <b>operating systems</b> do not support symbolic links at all or support 
  them only for regular files. Windows prior to Vista, for example, did not 
  support symbolic links. 
  Some <b>file systems</b> do not 
  support 
  symbolic links regardless of the operating system - the FAT system used on floppy discs, memory cards and flash 
  drives, 
  for example. Thus symbolic links should only be used if these situations are 
  not concerns, or if workarounds are provided. </span> <i><span style="background-color: #FFFFFF">-- end note</span></i><span style="background-color: #FFFFFF">]</span></p>
  </blockquote>
<pre>path <a name="current_path">current_path</a>();
path <a name="current_path">current_path</a>(system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Returns:</i> The current working directory path, as if by <i>POSIX</i>
  <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/getcwd.html">
  getcwd()</a></code>. <code>is_complete()</code> is true for the returned path.</p>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
  <p>[<i>Note:</i> The current path as returned by many operating systems is a 
  dangerous global variable. It may be changed unexpectedly by a third-party or 
  system library functions, or by another thread. For a safer alternative, 
  see <code><a href="#initial_path">initial_path()</a></code>. The <code>
  current_path()</code> name was chosen to emphasize that the return is a 
  complete path, not just a single directory name. <i>-- end note</i>]</p>
</blockquote>
<pre>void current_path(const path&amp; p);
void current_path(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
  <p style="font-size: 10pt"><i><span style="background-color: #FFFFFF">Effects:</span></i><span style="background-color: #FFFFFF"> 
  Establishes the postcondition, as if by </span><i>
  <span style="background-color: #FFFFFF">POSIX</span></i><span style="background-color: #FFFFFF">
  </span><code><span style="background-color: #FFFFFF">
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/chdir.html">
  chdir()</a></span></code><span style="background-color: #FFFFFF">.</span></p>
<p><i>Postconditions:</i> <code>equivalent(p, current_path())</code>.</p>
<p><i>Throws:</i> As specified in
<a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
Error reporting</a>.</p>
</blockquote>
<pre><span style="background-color: #FFFFFF">bool <a name="exists-file_status">exists</a>(file_status s);</span></pre>
<blockquote>
  <p><i><span style="background-color: #FFFFFF">Returns:</span></i><span style="background-color: #FFFFFF">
  <code>status_known(s) &amp;&amp; s.type() != file_not_found</code></span></p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre>bool <a name="exists-path">exists</a>(const path&amp; p);
bool <a name="exists2">exists</a>(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Returns:</i> <code>exists(status(p))</code> or <code>exists(status(p, ec))</code>, 
  respectively.</p>
<p><i>Throws:</i> <code>filesystem_error</code>; overload with <code>error_code&amp;</code> throws 
nothing.</p>
</blockquote>
<pre><code>bool <a name="equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2);
bool <a name="equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2, system::error_code&amp; ec);</code></pre>
<blockquote style="font-size: 10pt">
  <p style="font-size: 10pt"><i>Effects:</i> Determines <code>file_status s1</code> 
  and <code>s2</code>, as if by <code>status(p1)</code> and&nbsp; <code>status(p2)</code>, 
  respectively.</p>
  <p style="font-size: 10pt"><i>Returns:</i> <code>true</code>, if <code>sf1 == 
  sf2</code> and <code>p1</code> and <code>p2</code> resolve to the same file 
  system entity, else <code>false</code>.</p>
  <blockquote>
  <p style="font-size: 10pt">Two paths are considered to resolve to the same 
  file system entity if two candidate entities reside on the same device at the 
  same location. This is determined as if by the values of the <i>POSIX</i>
  <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">
  stat</a></code> structure<code>,</code> obtained as if by <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">
  stat()</a></code> for the two paths, having equal <code>st_dev</code> values 
  and equal <code>st_ino</code> values.</p>
  <p style="font-size: 10pt">[<i>Note:</i> <i>POSIX</i> requires that <i>&quot;st_dev</i> 
  must be unique within a Local Area Network&quot;. Conservative <i>POSIX</i> 
  implementations may also wish to check for equal <code>st_size</code> and
  <code>st_mtime</code> values. <i>Windows</i> implementations may use <code>
  GetFileInformationByHandle()</code> as a surrogate for <code>stat()</code>, 
  and consider &quot;same&quot; to be equal values for <code>dwVolumeSerialNumber</code>,
  <code>nFileIndexHigh</code>, <code>nFileIndexLow</code>, <code>nFileSizeHigh</code>,
  <code>nFileSizeLow</code>, <code>ftLastWriteTime.dwLowDateTime</code>, and
  <code>ftLastWriteTime.dwHighDateTime</code>. <i>-- end note</i>]</p>
  </blockquote>
  <p style="font-size: 10pt"><i>Throws:</i> <code>filesystem_error</code><span style="background-color: #FFFFFF">
  </span>if <code>(!exists(s1) &amp;&amp; !exists(s2)) || (is_other(s1) &amp;&amp; is_other(s2))</code>, 
  otherwise as specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
</blockquote>
<pre><span style="background-color: #FFFFFF; ">uintmax_t</span> <a name="file_size">file_size</a>(const path&amp; p);<span style="background-color: #FFFFFF; ">
uintmax_t</span> <a name="file_size">file_size</a>(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
  <p><span style="background-color: #FFFF00">Remarks: </span></p>
  <p><i>Returns:</i> If <code>exists(p) &amp;&amp; is_regular_file(p)</code>, the size 
  <span style="background-color: #FFFFFF; ">in bytes</span> 
  of the file <code>p</code> resolves to, determined as if by the value of 
  the <i>POSIX</i> <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code> structure member <code>st_size</code> 
  obtained as if by <i>POSIX</i> <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>. 
  Otherwise, <code>static_cast&lt;uintmax_t&gt;(-1)</code>.</p>
  <p style="font-size: 10pt"><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
</blockquote>
<pre>const path&amp; <a name="initial_path">initial_path</a>();
const path&amp; <a name="initial_path">initial_path</a>(system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Returns:</i> <code>current_path()</code> at the time of entry to <code>
  main()</code>.</p>
  <p><i>Throws:</i> Nothing.</p>
  <p>[<i>Note:</i> These semantics turn a dangerous global variable into a safer 
  global constant. <i>--end note</i>]</p>
  <p>[<i>Note:</i> Full implementation requires runtime library support. 
  Implementations which cannot provide runtime library support are encouraged to 
  instead store the value of <code>current_path()</code> at the first call of
  <a name="initial_path"><code>initial_path</code></a><code>()</code>, and 
  return this value for all subsequent calls. Programs using
  <a name="initial_path"><code>initial_path</code></a><code>()</code> are 
  encouraged to call it immediately on entrance to <code>main()</code> so that 
  they will work correctly with such partial implementations. <i>--end note</i>]</p>
</blockquote>
<pre><span style="background-color: #FFFFFF">bool </span><code><span style="background-color: #FFFFFF"><a name="is_directory">is_directory</a></span></code><span style="background-color: #FFFFFF">(file_status s);</span></pre>
<blockquote>
  <p><i><span style="background-color: #FFFFFF">Returns:</span></i><span style="background-color: #FFFFFF"> </span>
  <code><span style="background-color: #FFFFFF">s.type() == directory_file</span></code></p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre><code>bool <a name="is_directory2">is_directory</a>(const path&amp; p);
bool <a name="is_directory2">is_directory</a>(const path&amp; p, system::error_code&amp; ec);</code></pre>
<blockquote>
  <p dir="ltr"><i>Returns:</i> <code>is_<a name="is_directory2">directory</a>(status(p))</code> or <code>is_directory(status(p, ec))</code>, 
  respectively.</p>
<p><i>Throws:</i> <code>filesystem_error</code>; overload with <code>error_code&amp;</code> throws 
nothing.</p>
</blockquote>
<pre><code><span style="background-color: #FFFF00">bool </span><span style="background-color: #FFFF00; text-decoration:underline"><a name="is_empty">is_</a></span><span style="background-color: #FFFF00"><a name="is_empty">empty</a>(const path&amp; p);
bool </span><span style="background-color: #FFFF00; text-decoration:underline"><a name="is_empty">is_</a></span><span style="background-color: #FFFF00"><a name="is_empty">empty</a>(const path&amp; p, system::error_code&amp; ec);</span></code></pre>
<blockquote>
  <p><i><span style="background-color: #FFFF00">Effects:</span></i><span style="background-color: #FFFF00"> Determines
  </span> <code><span style="background-color: #FFFF00">file_status s</span></code><span style="background-color: #FFFF00">, as if by
  </span> <code>
  <span style="background-color: #FFFF00">status(p, ec)</span></code><span style="background-color: #FFFF00">.</span></p>
  <p><i><span style="background-color: #FFFF00">Returns:</span></i><span style="background-color: #FFFF00">
  </span> <code><span style="background-color: #FFFF00">is_directory(s)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? 
  directory_iterator(p) == directory_iterator()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : file_size(p) == 0;</span></code></p>
</blockquote>
<pre>bool <code><a name="is_regular_file">is_regular_file</a></code>(file_status s);</pre>
<blockquote>
  <p><i>Returns:</i>
  <code>s.type() == regular_file</code></p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre><code>bool <a name="is_regular_file2">is_regular_file</a>(const path&amp; p);</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_regular_file(status(p))</code>.</p>
  <p><i>Throws:</i> <code>filesystem_error</code> 
  if <code>status(p)</code> would throw <code>filesystem_error.</code></p>
  </blockquote>
<pre><code>bool <a name="is_regular_file2">is_regular_file</a>(const path&amp; p, system::error_code&amp; ec);</code></pre>
<blockquote>
  <p><i>Effects:</i> Sets <code>ec</code> as if by <code>status(p, ec)</code>.
  <span style="background-color: #FFFF00">[</span><i><span style="background-color: #FFFF00">Note:</span></i><span style="background-color: #FFFF00">
  </span>
      <code><span style="background-color: #FFFF00">status_error</span></code><span style="background-color: #FFFF00">,
  </span>
      <code><span style="background-color: #FFFF00">file_not_found</span></code><span style="background-color: #FFFF00"> 
  and </span>
      <code><span style="background-color: #FFFF00">type_unknown</span></code><span style="background-color: #FFFF00"> 
  cases set </span><code><span style="background-color: #FFFF00">ec</span></code><span style="background-color: #FFFF00"> 
  to error values. To distinguish between cases, call the </span><code>
  <span style="background-color: #FFFF00">status</span></code><span style="background-color: #FFFF00"> 
  function directly. </span><i><span style="background-color: #FFFF00">-- end 
  note</span></i><span style="background-color: #FFFF00">] </span></p>
  <p><i>Returns:</i> <code>is_regular_file(status(p, ec))</code>.</p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre><span style="background-color: #FFFFFF">bool <a name="is_other">is_other</a>(file_status s);</span></pre>
<blockquote>
  <p><i><span style="background-color: #FFFFFF">Returns:</span></i><span style="background-color: #FFFFFF">
  <code>return exists(s) &amp;&amp; !is_regular_file(s) &amp;&amp; !is_directory(s) &amp;&amp; !is_symlink(s)</code></span></p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre><code>bool <a name="is_other2">is_other</a>(const path&amp; p);
bool <a name="is_other2">is_other</a>(const path&amp; p, system::error_code&amp; ec);</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_other(status(p))</code> or <code>is_other(status(p, ec))</code>, 
  respectively.</p>
  <p><i>Throws:</i> <code>filesystem_error</code>; overload with <code>error_code&amp;</code> throws 
  nothing.</p>
</blockquote>
<pre><span style="background-color: #FFFFFF">bool <a name="is_symlink">is_symlink</a>(file_status s);</span></pre>
<blockquote>
  <p><i><span style="background-color: #FFFFFF">Returns:</span></i><span style="background-color: #FFFFFF"> </span>
  <code><span style="background-color: #FFFFFF">s.type() == symlink_file</span></code></p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre><code>bool <a name="is_symlink2">is_symlink</a>(const path&amp; p);
bool <a name="is_symlink2">is_symlink</a>(const path&amp; p, system::error_code&amp; ec);</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_symlink(symlink_status(p))</code> or <code>is_symlink(symlink_status(p, ec))</code>, 
  respectively.</p>
  <p><i>Throws:</i> <code>filesystem_error</code>; overload with <code>error_code&amp;</code> throws 
  nothing.</p>
</blockquote>
<pre>std::time_t <a name="last_write_time">last_write_time</a>(const path&amp; p);
std::time_t <a name="last_write_time">last_write_time</a>(const path&amp; p<code>, system::error_code&amp; ec</code>);</pre>
<blockquote>
  <p><i>Returns:</i> The time of last data modification of <code>p</code>, determined as if by the 
  value of the <i>POSIX</i> <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code> structure member <code>st_mtime</code>&nbsp; obtained 
  as if by <i>POSIX</i> <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>.</p>
</blockquote>
<pre>void <a name="last_write_time2">last_write_time</a>(const path&amp; p, const std::time_t new_time);
void <a name="last_write_time2">last_write_time</a>(const path&amp; p, const std::time_t new_time<code>, system::error_code&amp; ec</code>);</pre>
<blockquote>
  <p><i>Effects:</i> Sets the time of last data modification of the file 
  resolved to by <code>p</code> 
  to <code>new_time</code>, as if by <i>POSIX</i> <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code> 
  followed by <i>POSIX</i>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/utime.html">
  <code>utime()</code></a>.</p>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
  <p>[<i>Note:</i> A postcondition of <code>last_write_time(p) == 
  new_time</code> is not specified since it might not hold for file systems 
  with coarse time granularity. <i>-- end note</i>]</p>
</blockquote>
<pre>path <a name="read_symlink">read_symlink</a>(const path&amp; p);
path read_symlink(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
  <p dir="ltr"><i>Returns:</i>&nbsp; If <code>p</code> resolves to a symbolic 
  link, a <code>path</code> object containing the contents of that symbolic 
  link. Otherwise an empty <code>path</code> object.</p>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>. [<i>Note:</i> It is an error if <code>p</code> does not 
  resolve to a symbolic link. <i>-- end note</i>]</p>
</blockquote>
<pre>bool <a name="remove">remove</a>(const path&amp; p);
bool <a name="remove">remove</a>(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects:</i>&nbsp; If <code>exists(symlink_status(p,ec))</code>, it is 
  removed 
  as if by<i> POSIX </i><code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/remove.html">remove()</a></code>.</p>
  <blockquote>
  <p>[<i>Note:</i> A symbolic link is itself removed, rather than the file it 
  resolves to being removed. <i>-- end note</i>]</p>
  </blockquote>
  <p><i>Postcondition:</i> <code>!exists(symlink_status(p))</code>.</p>
  <p><i>Returns:</i>&nbsp; <code>false</code> if p did not exist in the first 
  place, otherwise <code>true</code>.</p>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
</blockquote>
<pre>uintmax_t <a name="remove_all">remove_all</a>(const path&amp; p);
uintmax_t <a name="remove_all">remove_all</a>(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects:</i>&nbsp; Recursively deletes the contents of p if it exists, 
  then deletes file <code>p</code> itself, 
  as if by<i> POSIX </i><code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/remove.html">remove()</a></code>.</p>
  <blockquote>
  <p>[<i>Note:</i> A symbolic link is itself removed, rather than the file it 
  resolves to being removed. <i>-- end note</i>]</p>
  </blockquote>
  <p><i>Postcondition:</i> <code>!exists(p)</code></p>
  <p><i>Returns:</i> The number of files removed.</p>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
</blockquote>
<pre>void <a name="rename">rename</a>(const path&amp; old_p, const path&amp; new_p);
void <a name="rename">rename</a>(const path&amp; old_p, const path&amp; new_p, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects:</i> Renames <code>old_p</code> to <code>new_p</code>, as if by
  <i>POSIX</i> <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/rename.html">
  rename()</a></code>.</p>
  <blockquote>
  <p>[<i>Note:</i> If <code>old_p</code> and <code>new_p</code> resolve to the 
  same existing file, no action is taken. Otherwise, if <code>new_p</code> resolves to an 
  existing non-directory file, it is removed, while if <code>new_p</code> resolves to an 
  existing directory, it is removed if empty on POSIX but is an error on Windows. A symbolic link is itself renamed, rather than 
  the file it resolves to being renamed. <i>-- end note</i>]</p>
  </blockquote>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
</blockquote>
<pre>void <a name="resize_file">resize_file</a>(const path&amp; p, <span style="background-color: #FFFFFF; ">uintmax_t new_size</span>);
void <a name="resize_file">resize_file</a>(const path&amp; p, <span style="background-color: #FFFFFF; ">uintmax_t new_size, </span>system::error_code&amp; ec);</pre>
<blockquote>
<p><i>Postconditions:</i> <code>file_size() == new_size</code>.</p>
<p><i>Throws:</i> As specified in
<a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
Error reporting</a>.</p>
  <p style="font-size: 10pt"><i>Remarks:</i> Achieves its postconditions as if by 
  POSIX <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/truncate.html">
  truncate()</a></code>.</p>
</blockquote>
<pre><span style="background-color: #FFFFFF">space_info <a name="space">space</a>(const path&amp; p);
space_info <a name="space">space</a>(const path&amp; p</span>, system::error_code&amp; ec<span style="background-color: #FFFFFF">);</span></pre>
<blockquote>
  <p><span style="background-color: #FFFFFF"><i>Returns:</i> An object of type <code>
  <a href="#space_info">space_info</a></code>. The value of the <code>space_info</code> object is determined as if by 
  using </span> <i><span style="background-color: #FFFFFF">POSIX</span></i><span style="background-color: #FFFFFF"> <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/statvfs.html" style="text-decoration: none">
  statvfs()</a></code> to obtain a <i>POSIX</i> struct <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/statvfs.h.html" style="text-decoration: none">
  statvfs</a></code>, and then multiplying its <code>f_blocks</code>, <code>
  f_bfree</code>, and <code>f_bavail</code> members by its <code>f_frsize</code> 
  member, and assigning the results to the <code>capacity</code>, <code>free</code>, 
  and <code>available</code> members respectively. Any members for which the 
  value cannot be determined shall be set to -1.</span></p>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
</blockquote>
<pre><a href="#file_status">file_status</a> <a name="status">status</a>(const path&amp; p);</pre>
<blockquote>
  <p><i>Effects: </i>As if:</p>
  <blockquote>
    <pre>system::error_code ec;
file_status result = status(p, ec);
if (result == status_error)
  throw filesystem_error(<i>implementation-supplied-message</i>, p, ec);
return result;</pre>
  </blockquote>
  <p><i>Returns:</i> See above.</p>
  <p><i>Throws:</i> <code>filesystem_error</code>. 
[<i>Note:</i> <code>result</code> values of <code>
      file_status(file_not_found)</code>and <code>
      file_status(type_unknown)</code> are not considered failures and do not 
  cause an exception to be 
thrown.<i> -- end note</i>] </p>
  </blockquote>
<pre><a href="#file_status">file_status</a> <a name="status">status</a>(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects: </i></p>
  <blockquote>
    <p>If possible, determines the attributes 
    of the file
    <code>p</code> resolves to, as if by<i> POSIX </i> <code>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>.</p>
      <p>[<i>Note:</i> If a symbolic link is encountered during pathname 
      resolution, 
      pathname resolution continues using the contents of the symbolic link. <i>-- 
    end note</i>]</p>
      If, during attribute determination, the underlying file system API reports 
    an error, sets <code>ec</code> to indicate the specific error reported. 
    Otherwise, <code>ec.clear()</code>.<blockquote>
      <p>[<i>Note:</i> This allows users to inspect the specifics of underlying 
      API errors even when the value returned by <code>status()</code> is not <code>
      file_status(status_error)</code>.&nbsp; <i>--end note</i>]</p>
    </blockquote>
    </blockquote>
  <p><i>Returns:</i></p>
  <blockquote>
    <p>If <code>ec != error_code()</code>:</p>
    <ul>
      <li>If the specific error indicates that <code>p</code> cannot be resolved 
      because some element of the path does not exist, return <code>
      file_status(file_not_found)</code>. [<i>Note:</i> POSIX errors that 
      indicate this are ENOENT or ENOTDIR. Windows equivalents 
      include ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_INVALID_NAME, 
      ERROR_INVALID_PARAMETER, ERROR_BAD_PATHNAME, and ERROR_BAD_NETPATH. <i>-- 
      end note</i>]<br>
&nbsp;</li>
      <li>Otherwise, if the specific error indicates that <code>p</code> can be resolved 
      but the attributes cannot be determined, return <code>
      file_status(type_unknown)</code>. [<i>Note: </i>For example, Windows 
      ERROR_SHARING_VIOLATION errors. For POSIX, the case never arises. <i>-- end 
      note</i>]<br>
&nbsp;</li>
      <li>Otherwise, return <code>
      file_status(status_error)</code>.</li>
    </ul>
        <blockquote>
        <p>[<i>Note:</i> These semantics distinguish between 
        <code>p</code> being known not to exist, 
        <code>p</code> existing but not being able to determine its attributes, 
        and there being an error that prevents even knowing if 
        <code>p</code> exists. These 
        distinctions are important to some use cases.&nbsp;<i>--end note</i>]</p>
    </blockquote>
    <p>Otherwise,</p>
    <ul>
      <li>If the attributes indicate a regular file, as if by <i>POSIX</i>&nbsp;<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISREG()</a>, 
      return <code>
      file_status(regular_file)</code>. [<i>Note:</i> <code>
regular_file</code> implies appropriate <code>&lt;fstream&gt;</code> operations 
      would succeed, assuming no hardware, permission, access, or race condition 
      errors. Lack of
<code>regular_file</code> does not necessarily imply <code>&lt;fstream&gt;</code> operations would 
fail on a directory.
<i>-- end note</i>]<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a directory, as if by <i>POSIX</i>
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISDIR()</a>, 
      return <code>
      file_status(directory_file)</code>. [<i>Note:</i> <code>directory_file</code> implies <code>
directory_iterator(p)</code>would succeed.
<i>-- end note</i>]<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a block special file, as if by <i>POSIX</i>
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISBLK()</a>, 
      return <code>
      file_status(block_file)</code>.<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a character special file, as if by <i>POSIX</i>
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISCHR()</a>, 
      return <code>
      file_status(character_file)</code>.<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a fifo or pipe file, as if by <i>POSIX</i>
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISFIFO()</a>, 
      return <code>
      file_status(fifo_file)</code>.<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a socket, as if by <i>POSIX</i>
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISSOCK()</a>, 
      return <code>
      file_status(socket_file)</code>.<br>
&nbsp;</li>
      <li>Otherwise, return <code>
      file_status(type_unknown)</code>.</li>
    </ul>
    </blockquote>
<p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre><span style="background-color: #FFFFFF">bool <a name="status_known">status_known</a>(file_status s);</span></pre>
<blockquote>
  <p><i><span style="background-color: #FFFFFF">Returns:</span></i><span style="background-color: #FFFFFF">
  <code>s.type() != status_error</code></span></p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre><span style="background-color: #FFFF00">file_status</span><span style="background-color: #FFFF00"> </span><a name="symlink_status"><span style="background-color: #FFFF00">symlink_status</span></a><span style="background-color: #FFFF00">(const</span><span style="background-color: #FFFF00"> path&amp; p);
</span><span style="background-color: #FFFF00">file_status</span><span style="background-color: #FFFF00"> </span><a name="symlink_status"><span style="background-color: #FFFF00">symlink_status</span></a><span style="background-color: #FFFF00">(const</span><span style="background-color: #FFFF00"> path&amp; p, </span><span style="background-color: #FFFF00">system::error_code</span><span style="background-color: #FFFF00">&amp; </span><span style="background-color: #FFFF00">ec</span><span style="background-color: #FFFF00">);</span></pre>
<blockquote>
  <p><i>Effects:</i>&nbsp; Same as <a href="#status">status()</a>, above, 
  except that the attributes 
    of
    <code>p</code> are determined as if by<i> POSIX </i> <code>
    <a href="http://www.opengroup.org/onlinepubs/000095399/functions/lstat.html">
    lstat()</a></code>.</p>
</blockquote>
<blockquote>
      <blockquote>
      <p>[<i>Note:</i> Pathname resolution is complete if <code>p</code> names a symbolic link. <i>-- 
    end note</i>]</p>
      </blockquote>
      <p><i>Returns:</i> Same as <a href="#status">status()</a>, above,<span style="background-color: #FFFF00"> 
      except ....</span></p>
<p><i>Throws:</i> <code>filesystem_error</code>; overload with <code>error_code&amp;</code> throws 
nothing.</p>
</blockquote>
<pre>path <a name="system_complete">system_complete</a>(const path&amp; p);
path <a name="system_complete">system_complete</a>(const path&amp; p, system::error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects:</i> Composes a complete path from <code>p</code>, using the 
  same rules used by the operating system to resolve a path passed as the 
  filename argument to standard library open functions.</p>
  <p><i>Returns:</i> The composed path.</p>
  <p><i>Postconditions:</i> For the returned path, <code>rp,</code> <code>
  rp.is_complete()</code> is true.</p>
  <p><i>Throws:</i> As specified in
  <a href="file:///C:/boost/filesystem-v3-sandbox/libs/filesystem/doc/reference.html#Error-reporting">
  Error reporting</a>.</p>
  <p>[<i>Note:</i> For <i>POSIX</i>, <code>system_complete(p)</code> has the same semantics as
  <code>complete(p, current_path())</code>.</p>
  <p><a name="windows_effects">For <i>Windows</i></a>, <code>system_complete(p)</code> has the 
  same semantics as <code>complete(ph, current_path())</code> if 
  <code>p.is_complete() || !p.has_root_name()</code> or <code>p</code> and <code>base</code> have the same
  <code>root_name()</code>. 
  Otherwise it acts like <code>complete(p, kinky)</code>, where <code>kinky</code> 
  is the current directory for the <code>p.root_name()</code> drive. This will 
  be the current directory of that drive the last time it was set, and thus may 
  be <b>residue left over from a prior program</b> run by the command 
  processor! Although these semantics are often useful, they are also very 
  error-prone.</p>
  <p>See <a href="#complete_note">
  <i>complete()</i> note</a> for usage suggestions. <i>-- end note</i>]</p>
</blockquote>
<h4><a name="Convenience-functions">Convenience functions</a></h4>
<table border="1" cellpadding="5" cellspacing="1" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td>
    <h4><span style="background-color: #FFFF00">Deprecated convenience functions</span></h4>
    <p><span style="background-color: #FFFF00">The following functions have been replaced by
    </span> <code><span style="background-color: #FFFF00">path</span></code><span style="background-color: #FFFF00"> 
    member functions </span> <code><span style="background-color: #FFFF00">extension()</span></code><span style="background-color: #FFFF00">,
    </span> <code><span style="background-color: #FFFF00">stem()</span></code><span style="background-color: #FFFF00">, and
    </span> <code>
    <span style="background-color: #FFFF00">replace_extension()</span></code><span style="background-color: #FFFF00">.</span></p>
<pre><span style="background-color: #FFFF00">typename </span><span style="background-color: #FFFF00">Path::string_type</span><span style="background-color: #FFFF00"> </span><span style="background-color: #FFFF00">extension(const</span><span style="background-color: #FFFF00"> path&amp; p);</span></pre>
<blockquote>
  <p><i><span style="background-color: #FFFF00">Returns:</span></i><span style="background-color: #FFFF00"> if
  </span> <code><span style="background-color: #FFFF00">p.filename()</span></code><span style="background-color: #FFFF00"> contains a
  </span> <i><span style="background-color: #FFFF00">dot</span></i><span style="background-color: #FFFF00">, returns 
  the </span><span style="background-color: #FFFF00">substring</span><span style="background-color: #FFFF00"> of
  </span> <code><span style="background-color: #FFFF00">p.filename()</span></code><span style="background-color: #FFFF00"> starting at the rightmost
  </span> <i><span style="background-color: #FFFF00">dot</span></i><span style="background-color: #FFFF00"> 
  and ending at the string's end. Otherwise, returns an empty string. </span> </p>
  <p><span style="background-color: #FFFF00">[</span><i><span style="background-color: #FFFF00">Note:</span><b><span style="background-color: #FFFF00">
  </span> </b></i><span style="background-color: #FFFF00">The </span> <i>
  <span style="background-color: #FFFF00">dot</span></i><span style="background-color: #FFFF00"> is included in the return value so that 
  it is possible to distinguish between no extension and an empty extension.
  </span> </p>
  <p><span style="background-color: #FFFF00">Implementations are permitted but not required to define additional 
  behavior for file systems which append additional elements to extensions, such 
  as alternate data stream or partitioned dataset names. </span> <i>
  <span style="background-color: #FFFF00">-- end note</span></i><span style="background-color: #FFFF00">]</span></p>
</blockquote>
<pre><span style="background-color: #FFFF00">typename </span><span style="background-color: #FFFF00">Path::string_type</span><span style="background-color: #FFFF00"> </span><span style="background-color: #FFFF00">basename(const</span><span style="background-color: #FFFF00"> path&amp; p);</span></pre>
<blockquote>
  <p><i><span style="background-color: #FFFF00">Returns:</span></i><span style="background-color: #FFFF00"> if
  </span> <code><span style="background-color: #FFFF00">p.filename()</span></code><span style="background-color: #FFFF00"> contains a
  </span> <i><span style="background-color: #FFFF00">dot</span></i><span style="background-color: #FFFF00">, returns 
  the </span><span style="background-color: #FFFF00">substring</span><span style="background-color: #FFFF00"> of
  </span> <code><span style="background-color: #FFFF00">p.filename()</span></code><span style="background-color: #FFFF00"> starting at its beginning and 
  ending at the last </span> <i><span style="background-color: #FFFF00">dot</span></i><span style="background-color: #FFFF00"> (the
  </span> <i><span style="background-color: #FFFF00">dot</span></i><span style="background-color: #FFFF00"> is not included). Otherwise, 
  returns </span> <code>
  <span style="background-color: #FFFF00">p.filename()</span></code><span style="background-color: #FFFF00">.</span></p>
</blockquote>
<pre><span style="background-color: #FFFF00">template &lt;class Path&gt;
  Path </span><span style="background-color: #FFFF00">change_extension(const</span><span style="background-color: #FFFF00"> path&amp; p, const typename </span><span style="background-color: #FFFF00">Path::string_type</span><span style="background-color: #FFFF00"> &amp; </span><span style="background-color: #FFFF00">new_extension</span><span style="background-color: #FFFF00">);</span></pre>
<blockquote>
  <p><i><span style="background-color: #FFFF00">Postcondition:</span></i><span style="background-color: #FFFF00">
  </span> <code><span style="background-color: #FFFF00">basename(<i>return_value</i>) == basename(p) &amp;&amp; 
  extension(<i>return_value</i>) == new_extension</span></code><span style="background-color: #FFFF00">
  </span> </p>
  <p><span style="background-color: #FFFF00">[</span><i><span style="background-color: #FFFF00">Note:</span></i><span style="background-color: #FFFF00"> It follows from the semantics of
  </span> <code><span style="background-color: #FFFF00">extension()</span></code><span style="background-color: #FFFF00"> 
  that </span> <code><span style="background-color: #FFFF00">new_extension</span></code><span style="background-color: #FFFF00"> should include
  </span> <i><span style="background-color: #FFFF00">dot</span></i><span style="background-color: #FFFF00"> to achieve 
  reasonable results. </span> <i><span style="background-color: #FFFF00">-- end note</span></i><span style="background-color: #FFFF00">]</span></p>
</blockquote>
    </td>
  </tr>
</table>
<h3><a name="header-fstream">Additions</a> to header <code>&lt;fstream&gt;</code></h3>
<blockquote>
<p><span style="background-color: #E0E0E0; font-style:italic">These additions have been carefully 
specified to avoid breaking existing code in common operating environments such as
</span> <i><span style="background-color: #E0E0E0">POSIX</span></i><span style="background-color: #E0E0E0; font-style:italic">,
</span> <i>
<span style="background-color: #E0E0E0">Windows</span></i><span style="background-color: #E0E0E0; font-style:italic">, and
</span> <i><span style="background-color: #E0E0E0">OpenVMS. 
See </span><a href="#Suggestions-for-fstream">
<span style="background-color: #E0E0E0">Suggestions for <code>&lt;fstream&gt;</code> 
implementations</span></a><span style="background-color: #E0E0E0"> for 
techniques to avoid breaking existing code in other environments, particularly 
on operating systems allowing slashes in filenames.</span></i></p>
<p><span style="background-color: #FFFFFF">[<i>Note:</i> The 
&quot;do-the-right-thing&quot; rule from <a href="#Requirements-on-implementations">
Requirements on implementations</a> does apply to header <code>&lt;fstream&gt;</code>.</span></p>
<p><span style="background-color: #FFFFFF">The overloads 
below are specified as additions rather than replacements for existing 
functions. This preserves existing code (perhaps 
using a <a name="home-grown-path">home-grown path</a> class) that relies on an 
automatic conversion to <code>const char*</code>.<i> -- end note</i>]</span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>In 27.8.1.1 Class template 
basic_filebuf [lib.filebuf] synopsis preceding paragraph 1, add the function:</i></span></p>
<blockquote>
<pre><span style="background-color: #FFFFFF"></span><span style="background-color: #FFFFFF">basic_filebuf</span><span style="background-color: #FFFFFF">&lt;charT,traits&gt;* </span><span style="background-color: #FFFFFF">open(const</span><span style="background-color: #FFFFFF"> path p, </span><span style="background-color: #FFFFFF">ios_base::openmode</span><span style="background-color: #FFFFFF"> mode);</span></pre>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>In 27.8.1.3 Member functions [lib.filebuf.members], 
add the above to the signature preceding paragraph 2, and replace the 
sentence:</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF">It then opens a file, if possible, 
whose name is the NTBS s (as if by calling <code>std::fopen(s ,<i>modstr</i> 
))</code>.</span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>with:</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF">It then opens, if possible, the file 
that
<code>p</code> or <code>path(s)</code> resolves to, as if by calling <code>std::fopen()</code> with a 
second argument of <i>modstr</i>.</span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>In 27.8.1.5 Class template 
basic_ifstream [lib.ifstream] synopsis preceding paragraph 1, add the functions:</i></span></p>
<blockquote>
  <pre><span style="background-color: #FFFFFF">explicit basic_ifstream(const path&amp; p, ios_base::openmode mode = ios_base::in);
void open(const path&amp; p, ios_base::openmode mode = ios_base::in);</span></pre>
</blockquote>
<p><i><span style="background-color: #FFFFFF">In 27.8.1.6 basic_ifstream 
constructors [lib.ifstream.cons] </span></i>
<span style="background-color: #FFFFFF"><i>add the above constructor to the signature preceding 
paragraph 2, and in paragraph 2 replace</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(s, mode | 
ios_base::in)</code></span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>with</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(path(s), mode | 
ios_base::in)</code> or <code>rdbuf()-&gt;open(p, mode | ios_base::in)</code> as 
appropriate</span></p>
</blockquote>
<p><i><span style="background-color: #FFFFFF">In 27.8.1.7 Member functions [lib.ifstream.members]
</span></i><span style="background-color: #FFFFFF"><i>add the above open 
function to the signature 
preceding paragraph 3, and in paragraph 3 replace</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(s, mode | 
ios_base::in)</code></span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>with</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(path(s), mode | 
ios_base::in)</code> or <code>rdbuf()-&gt;open(p, mode | ios_base::in)</code> as 
appropriate</span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>In 27.8.1.8 Class template 
basic_ofstream [lib.ofstream] synopsis preceding paragraph 1, add the 
 
functions:</i></span></p>
<blockquote>
  <pre><span style="background-color: #FFFFFF">explicit basic_ofstream(const path&amp; p, ios_base::openmode mode = ios_base::out);
void open(const path&amp; p, ios_base::openmode mode = ios_base::out);</span></pre>
</blockquote>
<p><i><span style="background-color: #FFFFFF">In 27.8.1.9 basic_ofstream 
constructors [lib.ofstream.cons] </span></i>
<span style="background-color: #FFFFFF"><i>add the above constructor to the signature preceding 
paragraph 2, and in paragraph 2 replace</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(s, mode | 
ios_base::out)</code></span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>with</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(path(s), mode | 
ios_base::out)</code> or <code>rdbuf()-&gt;open(p, mode | ios_base::out)</code> as 
appropriate</span></p>
</blockquote>
<p><i><span style="background-color: #FFFFFF">In 27.8.1.10 Member functions [lib.ofstream.members]
</span></i><span style="background-color: #FFFFFF"><i>add the above open 
function to the signature 
preceding paragraph 3, and in paragraph 3 replace</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(s, mode | 
ios_base::out)</code></span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>with</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(path(s), mode | 
ios_base::out)</code> or <code>rdbuf()-&gt;open(p, mode | ios_base::out)</code> as 
appropriate</span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>In 27.8.1.11 Class template 
basic_fstream [lib.fstream] synopsis preceding paragraph 1, add the  functions:</i></span></p>
<blockquote>
  <pre><span style="background-color: #FFFFFF">explicit basic_fstream(const path&amp; p, ios_base::openmode mode = ios_base::in|ios_base::out);
void open(const path&amp; p, ios_base::openmode mode = ios_base::in|ios_base::out);</span></pre>
</blockquote>
<p><i><span style="background-color: #FFFFFF">In 27.8.1.12 basic_fstream 
constructors [lib.fstream.cons] </span></i>
<span style="background-color: #FFFFFF"><i>add the above constructor to the signature preceding 
paragraph 2, and in paragraph 2 replace</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(s, mode)</code></span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>with</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(path(s), mode)</code> 
or <code>rdbuf()-&gt;open(p, mode)</code> as appropriate</span></p>
</blockquote>
<p><i><span style="background-color: #FFFFFF">In 27.8.1.13 Member functions [lib.fstream.members]
</span></i><span style="background-color: #FFFFFF"><i>add the above open 
function to the signature 
preceding paragraph 3, and in paragraph 3 replace</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(s, mode)</code></span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>with</i></span></p>
<blockquote>
<p><span style="background-color: #FFFFFF"><code>rdbuf()-&gt;open(path(s), mode)</code> 
or <code>rdbuf()-&gt;open(p, mode)</code> as appropriate</span></p>
</blockquote>
<p><span style="background-color: #FFFFFF"><i>End of proposed text.</i></span></p>
<h2><a name="Path-decomposition-table">Path decomposition table</a></h2>
<p>The table is generated by a program compiled with the Boost implementation.</p>
<p>Shaded entries indicate cases where <i>POSIX</i> and <i>Windows</i> 
implementations yield different results. The top value is the
<i>POSIX</i> result and the bottom value is the <i>Windows</i> result. <br>
&nbsp;<table border="1" cellspacing="0" cellpadding="5" width="1066">
<p>
<tr><td width="112"><b>Constructor<br>argument</b></td>
<td width="160"><b>Elements found<br>by iteration</b></td>
<td width="112"><b><code>string()</code></b></td>
<td width="112"><code><b>file_<br>string()</b></td>
<td width="72"><b><code>root_<br>path()<br>.string()</code></b></td>
<td width="48"><b><code>root_<br>name()</code></b></td>
<td width="88"><b><code>root_<br>directory()</code></b></td>
<td width="96"><b><code>relative_<br>path()<br>.string()</code></b></td>
<td width="72"><b><code>parent_<br>path()<br>.string()</code></b></td>
<td width="72"><b><code>filename()</code></b></td>
</tr>
<tr>
<td width="112"><code>&quot;&quot;</code></td>
<td width="160"><code>&quot;&quot;</code></td>
<td width="112"><code>&quot;&quot;</code></td>
<td width="112"><code>&quot;&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;.&quot;</code></td>
<td width="160"><code>&quot;.&quot;</code></td>
<td width="112"><code>&quot;.&quot;</code></td>
<td width="112"><code>&quot;.&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;.&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;..&quot;</code></td>
<td width="160"><code>&quot;..&quot;</code></td>
<td width="112"><code>&quot;..&quot;</code></td>
<td width="112"><code>&quot;..&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;..&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="72"><code>&quot;..&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;foo&quot;</code></td>
<td width="160"><code>&quot;foo&quot;</code></td>
<td width="112"><code>&quot;foo&quot;</code></td>
<td width="112"><code>&quot;foo&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;foo&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="72"><code>&quot;foo&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;/&quot;</code></td>
<td width="160"><code>&quot;/&quot;</code></td>
<td width="112"><code>&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;/&quot;<br>&quot;\&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;/&quot;</code></td>
<td width="96"><code>&quot;&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;/foo&quot;</code></td>
<td width="160"><code>&quot;/&quot;,&quot;foo&quot;</code></td>
<td width="112"><code>&quot;/foo&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;/foo&quot;<br>&quot;\foo&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;/&quot;</code></td>
<td width="96"><code>&quot;foo&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="72"><code>&quot;foo&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;foo/&quot;</code></td>
<td width="160"><code>&quot;foo&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;foo/&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;foo/&quot;<br>&quot;foo\&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;foo/&quot;</code></td>
<td width="72"><code>&quot;foo&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;/foo/&quot;</code></td>
<td width="160"><code>&quot;/&quot;,&quot;foo&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;/foo/&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;/foo/&quot;<br>&quot;\foo\&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;/&quot;</code></td>
<td width="96"><code>&quot;foo/&quot;</code></td>
<td width="72"><code>&quot;/foo&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;foo/bar&quot;</code></td>
<td width="160"><code>&quot;foo&quot;,&quot;bar&quot;</code></td>
<td width="112"><code>&quot;foo/bar&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;foo/bar&quot;<br>&quot;foo\bar&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;foo/bar&quot;</code></td>
<td width="72"><code>&quot;foo&quot;</code></td>
<td width="72"><code>&quot;bar&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;/foo/bar&quot;</code></td>
<td width="160"><code>&quot;/&quot;,&quot;foo&quot;,&quot;bar&quot;</code></td>
<td width="112"><code>&quot;/foo/bar&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;/foo/bar&quot;<br>&quot;\foo\bar&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;/&quot;</code></td>
<td width="96"><code>&quot;foo/bar&quot;</code></td>
<td width="72"><code>&quot;/foo&quot;</code></td>
<td width="72"><code>&quot;bar&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;///foo///&quot;</code></td>
<td width="160"><code>&quot;/&quot;,&quot;foo&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;///foo///&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;///foo///&quot;<br>&quot;\foo\\\&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;/&quot;</code></td>
<td width="96"><code>&quot;foo///&quot;</code></td>
<td width="72"><code>&quot;///foo&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;///foo///bar&quot;</code></td>
<td width="160"><code>&quot;/&quot;,&quot;foo&quot;,&quot;bar&quot;</code></td>
<td width="112"><code>&quot;///foo///bar&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;///foo///bar&quot;<br>&quot;\foo\\\bar&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;/&quot;</code></td>
<td width="96"><code>&quot;foo///bar&quot;</code></td>
<td width="72"><code>&quot;///foo&quot;</code></td>
<td width="72"><code>&quot;bar&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;/.&quot;</code></td>
<td width="160"><code>&quot;/&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;/.&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;/.&quot;<br>&quot;\.&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;/&quot;</code></td>
<td width="96"><code>&quot;.&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;./&quot;</code></td>
<td width="160"><code>&quot;.&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;./&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;./&quot;<br>&quot;.\&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;./&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;/..&quot;</code></td>
<td width="160"><code>&quot;/&quot;,&quot;..&quot;</code></td>
<td width="112"><code>&quot;/..&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;/..&quot;<br>&quot;\..&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;/&quot;</code></td>
<td width="96"><code>&quot;..&quot;</code></td>
<td width="72"><code>&quot;/&quot;</code></td>
<td width="72"><code>&quot;..&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;../&quot;</code></td>
<td width="160"><code>&quot;..&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;../&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;../&quot;<br>&quot;..\&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;../&quot;</code></td>
<td width="72"><code>&quot;..&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;foo/.&quot;</code></td>
<td width="160"><code>&quot;foo&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;foo/.&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;foo/.&quot;<br>&quot;foo\.&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;foo/.&quot;</code></td>
<td width="72"><code>&quot;foo&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;foo/..&quot;</code></td>
<td width="160"><code>&quot;foo&quot;,&quot;..&quot;</code></td>
<td width="112"><code>&quot;foo/..&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;foo/..&quot;<br>&quot;foo\..&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;foo/..&quot;</code></td>
<td width="72"><code>&quot;foo&quot;</code></td>
<td width="72"><code>&quot;..&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;foo/./&quot;</code></td>
<td width="160"><code>&quot;foo&quot;,&quot;.&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;foo/./&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;foo/./&quot;<br>&quot;foo\.\&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;foo/./&quot;</code></td>
<td width="72"><code>&quot;foo/.&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;foo/./bar&quot;</code></td>
<td width="160"><code>&quot;foo&quot;,&quot;.&quot;,&quot;bar&quot;</code></td>
<td width="112"><code>&quot;foo/./bar&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;foo/./bar&quot;<br>&quot;foo\.\bar&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;foo/./bar&quot;</code></td>
<td width="72"><code>&quot;foo/.&quot;</code></td>
<td width="72"><code>&quot;bar&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;foo/..&quot;</code></td>
<td width="160"><code>&quot;foo&quot;,&quot;..&quot;</code></td>
<td width="112"><code>&quot;foo/..&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;foo/..&quot;<br>&quot;foo\..&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;foo/..&quot;</code></td>
<td width="72"><code>&quot;foo&quot;</code></td>
<td width="72"><code>&quot;..&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;foo/../&quot;</code></td>
<td width="160"><code>&quot;foo&quot;,&quot;..&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;foo/../&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;foo/../&quot;<br>&quot;foo\..\&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;foo/../&quot;</code></td>
<td width="72"><code>&quot;foo/..&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;foo/../bar&quot;</code></td>
<td width="160"><code>&quot;foo&quot;,&quot;..&quot;,&quot;bar&quot;</code></td>
<td width="112"><code>&quot;foo/../bar&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;foo/../bar&quot;<br>&quot;foo\..\bar&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="48"><code>&quot;&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td width="96"><code>&quot;foo/../bar&quot;</code></td>
<td width="72"><code>&quot;foo/..&quot;</code></td>
<td width="72"><code>&quot;bar&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:&quot;</code></td>
<td width="160"><code>&quot;c:&quot;</code></td>
<td width="112"><code>&quot;c:&quot;</code></td>
<td width="112"><code>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:&quot;<br>&quot;&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="72"><code>&quot;c:&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:&quot;,&quot;.&quot;<br>&quot;c:&quot;,&quot;/&quot;</code></td>
<td width="112"><code>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code><span style="background-color: #99FF66">
&quot;c:/&quot;<br>&quot;c:\&quot;</span></code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="88"><code>&quot;&quot;<br>&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:/&quot;<br>&quot;&quot;</code></td>
<td width="72"><code>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;.&quot;<br>&quot;/&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:foo&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:foo&quot;<br>&quot;c:&quot;,&quot;foo&quot;</code></td>
<td width="112"><code>&quot;c:foo&quot;</code></td>
<td width="112"><code>&quot;c:foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:foo&quot;<br>&quot;foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;c:foo&quot;<br>&quot;foo&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:/foo&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:&quot;,&quot;foo&quot;<br>&quot;c:&quot;,&quot;/&quot;,&quot;foo&quot;</code></td>
<td width="112"><code>&quot;c:/foo&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:/foo&quot;<br>&quot;c:\foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="88"><code>&quot;&quot;<br>&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:/foo&quot;<br>&quot;foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;c:&quot;<br>&quot;c:/&quot;</code></td>
<td width="72"><code>&quot;foo&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:foo/&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:foo&quot;,&quot;.&quot;<br>&quot;c:&quot;,&quot;foo&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;c:foo/&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:foo/&quot;<br>&quot;c:foo\&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:foo/&quot;<br>&quot;foo/&quot;</code></td>
<td width="72"><code>&quot;c:foo&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:/foo/&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:&quot;,&quot;foo&quot;,&quot;.&quot;<br>&quot;c:&quot;,&quot;/&quot;,&quot;foo&quot;,&quot;.&quot;</code></td>
<td width="112"><code>&quot;c:/foo/&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:/foo/&quot;<br>&quot;c:\foo\&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="88"><code>&quot;&quot;<br>&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:/foo/&quot;<br>&quot;foo/&quot;</code></td>
<td width="72"><code>&quot;c:/foo&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:/foo/bar&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:&quot;,&quot;foo&quot;,&quot;bar&quot;<br>&quot;c:&quot;,&quot;/&quot;,&quot;foo&quot;,&quot;bar&quot;</code></td>
<td width="112"><code>&quot;c:/foo/bar&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:/foo/bar&quot;<br>&quot;c:\foo\bar&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="88"><code>&quot;&quot;<br>&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:/foo/bar&quot;<br>&quot;foo/bar&quot;</code></td>
<td width="72"><code>&quot;c:/foo&quot;</code></td>
<td width="72"><code>&quot;bar&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;prn:&quot;</code></td>
<td width="160"><code>&quot;prn:&quot;</code></td>
<td width="112"><code>&quot;prn:&quot;</code></td>
<td width="112"><code>&quot;prn:&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;prn:&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;prn:&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;prn:&quot;<br>&quot;&quot;</code></td>
<td width="72"><code>&quot;&quot;</code></td>
<td width="72"><code>&quot;prn:&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:\&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:\&quot;<br>&quot;c:&quot;,&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:\&quot;<br>&quot;c:/&quot;</code></td>
<td width="112"><code>&quot;c:\&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="88"><code>&quot;&quot;<br>&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:\&quot;<br>&quot;&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;c:\&quot;<br>&quot;/&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:foo&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:foo&quot;<br>&quot;c:&quot;,&quot;foo&quot;</code></td>
<td width="112"><code>&quot;c:foo&quot;</code></td>
<td width="112"><code>&quot;c:foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:foo&quot;<br>&quot;foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;c:foo&quot;<br>&quot;foo&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:\foo&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:\foo&quot;<br>&quot;c:&quot;,&quot;/&quot;,&quot;foo&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:\foo&quot;<br>&quot;c:/foo&quot;</code></td>
<td width="112"><code>&quot;c:\foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="88"><code>&quot;&quot;<br>&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:\foo&quot;<br>&quot;foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;c:\foo&quot;<br>&quot;foo&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:foo\&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:foo\&quot;<br>&quot;c:&quot;,&quot;foo&quot;,&quot;.&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:foo\&quot;<br>&quot;c:foo/&quot;</code></td>
<td width="112"><code>&quot;c:foo\&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td width="88"><code>&quot;&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:foo\&quot;<br>&quot;foo/&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;c:foo\&quot;<br>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:\foo\&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:\foo\&quot;<br>&quot;c:&quot;,&quot;/&quot;,&quot;foo&quot;,&quot;.&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:\foo\&quot;<br>&quot;c:/foo/&quot;</code></td>
<td width="112"><code>&quot;c:\foo\&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="88"><code>&quot;&quot;<br>&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:\foo\&quot;<br>&quot;foo/&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;c:\foo\&quot;<br>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:\foo/&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:\foo&quot;,&quot;.&quot;<br>&quot;c:&quot;,&quot;/&quot;,&quot;foo&quot;,&quot;.&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:\foo/&quot;<br>&quot;c:/foo/&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:\foo/&quot;<br>&quot;c:\foo\&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="88"><code>&quot;&quot;<br>&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:\foo/&quot;<br>&quot;foo/&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;c:\foo&quot;<br>&quot;c:/foo&quot;</code></td>
<td width="72"><code>&quot;.&quot;</code></td>
</tr>
<tr>
<td width="112"><code>&quot;c:/foo\bar&quot;</code></td>
<td bgcolor="#99FF66" width="160"><code>&quot;c:&quot;,&quot;foo\bar&quot;<br>&quot;c:&quot;,&quot;/&quot;,&quot;foo&quot;,&quot;bar&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:/foo\bar&quot;<br>&quot;c:/foo/bar&quot;</code></td>
<td bgcolor="#99FF66" width="112"><code>&quot;c:/foo\bar&quot;<br>&quot;c:\foo\bar&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;&quot;<br>&quot;c:/&quot;</code></td>
<td bgcolor="#99FF66" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-bottom-style: solid; border-bottom-width: 1" width="48"><code>
&quot;&quot;<br>&quot;c:&quot;</code></td>
<td bgcolor="#99FF66" width="88"><code>&quot;&quot;<br>&quot;/&quot;</code></td>
<td bgcolor="#99FF66" width="96"><code>&quot;c:/foo\bar&quot;<br>&quot;foo/bar&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;c:&quot;<br>&quot;c:/foo&quot;</code></td>
<td bgcolor="#99FF66" width="72"><code>&quot;foo\bar&quot;<br>&quot;bar&quot;</code></td>
</tr>
</table>
<h2><a name="Suggestions-for-fstream">Suggestions for <code>&lt;fstream&gt;</code></a> 
implementations</h2>
<p><span style="background-color: #FFFFFF">The change in semantics to functions 
taking <code>const char*</code> arguments can break existing code, but only on 
operating systems where implementations don't 
<a href="#Pathname-formats">implicitly accept native format pathnames</a> or 
operating systems that allow slashes in filenames. Thus on <i>POSIX</i>, 
<i>Windows,</i> and <i>OpenVMS</i>, for example, there is no problem if the 
implementation follows encouraged behavior.</span></p>
<p><span style="background-color: #FFFFFF">For most of the Filesystem Library, 
there is no existing code, so the issue preserving existing code that uses 
slashes in filenames doesn't arise. New code simply must use path 
constructors with <code>path_format_t</code> arguments of <code>native</code>. 
To preserve existing fstream code that uses slashes in filenames, an 
implementation may wish to provide a mechanism such as a macro to control 
selection of the old behavior.</span></p>
<p><span style="background-color: #FFFFFF">Implementations are already required 
by the TR front-matter to provide a mechanism such as a macro to control 
selection of the old behavior (useful to guarantee protection of existing code) 
or new behavior (useful in new code, and code being ported from other systems) 
for headers. Because use of the rest of the Filesystem Library is independent of 
use of the <code>&lt;fstream&gt;</code> additions, affected implementations are 
encouraged to allow disabling the <code>&lt;fstream&gt;</code> additions separately 
from other TR features.</span></p>
<p><span style="background-color: #FFFFFF">An rejected alternative was to supply 
new fstream classes in namespace <code>filesystem</code>, inheriting from the current 
classes, overriding the constructors and opens taking pathname arguments, and 
providing the additional overloads. In Lillehammer LWG members indicated lack of 
support for this alternative, feeling that costs outweigh benefits.</span></p>
<h2><a name="Acknowledgements">Acknowledgements</a></h2>
<p>This Filesystem Library is dedicated to my wife, Sonda, who provided the 
support necessary to see both a trial implementation and the proposal itself 
through to completion. She gave me the strength to continue after a difficult 
year of cancer treatment in the middle of it all.</p>
<p>Many people contributed technical comments, ideas, and suggestions to the 
Boost Filesystem Library. See
<a href="http://www.boost.org/libs/filesystem/doc/index.htm#Acknowledgements">
http://www.boost.org/libs/filesystem/doc/index.htm#Acknowledgements</a>.</p>
<p>Dietmar Kuehl contributed the original Boost Filesystem Library directory_iterator design. Peter Dimov, Walter Landry, Rob Stewart, and Thomas 
Witt were particularly helpful in refining the library.</p>
<p>The create_directories, extension, basename, and replace_extension functions 
were developed by Vladimir Prus.</p>
<p>Howard Hinnant and John Maddock reviewed a draft of the version 2 proposal, and 
identified a number of mistakes or weaknesses, resulting in a more polished 
final document.</p>
<p>Peter Dimov suggested a single class path, with member templates to adapt to 
multiple string types. His idea became the basis for the version 3 path design.</p>
<h2><a name="References">References</a></h2>
<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%">
  <tr>
    <td width="16%" valign="top">[<a name="ISO_POSIX">ISO-POSIX</a>]</td>
    <td width="84%">ISO/IEC 9945:2003, IEEE&nbsp;Std&nbsp;1003.1-2001, and The Open Group 
    Base Specifications, Issue 6. Also known as The Single Unix<font face="Times New Roman"> 
    Specification, Version 3. Available from each of the organizations involved 
    in its creation. For example, read online or download from
    <a href="http://www.unix.org/single_unix_specification/">
    www.unix.org/single_unix_specification/</a>.</font> The ISO JTC1/SC22/WG15 - 
    POSIX homepage is <a href="http://www.open-std.org/jtc1/sc22/WG15/">
    www.open-std.org/jtc1/sc22/WG15/</a></td>
  </tr>
  <tr>
    <td width="16%" valign="top">[Abrahams]</td>
    <td width="84%">Dave Abrahams, Error and Exception Handling,
    <a href="http://www.boost.org/more/error_handling.html">
    www.boost.org/more/error_handling.html</a></td>
  </tr>
</table>
<hr>
<p> Copyright Beman Dawes, 2002, 2006, 2007, 2009</p>
<p>Distributed under the Boost Software License, Version 1.0. See
<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
<p>Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->02 January 2010<!--webbot bot="Timestamp" endspan i-checksum="32136" --></p>

</body>

</html>