<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Filesystem Tutorial</title>
<style type="text/css">
  body    { font-family: sans-serif; margin: 1em; }
  p, td, li, blockquote { font-size: 10pt; }
  pre     { font-size: 9pt; }
</style>
</head>

<body>

<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="742">
  <tr>
    <td width="277">
<a href="../../../index.htm">
<img src="../../../boost.png" alt="boost.png (6897 bytes)" align="middle" width="277" height="86" border="0"></a></td>
    <td width="442" align="middle">
    <font size="7">Filesystem Tutorial</font>
    </td>
  </tr>
</table>

<table border="0" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="100%">
  <tr>
    <td><a href="../../../index.htm">Boost Home</a>&nbsp;&nbsp;&nbsp;
    <a href="index.htm">Library Home</a>&nbsp; &nbsp; 
    <a href="reference.html">
    Reference</a>&nbsp;&nbsp; 
    <a href="faq.htm">FAQ</a></td>
  </tr>
</table>

<h2>Introduction</h2>

<p>This tutorial develops a little command line program to list information 
about files and directories - essentially a much simplified version of the POSIX <code>ls</code> or Windows <code>dir</code> 
commands. We'll start with the simplest possible version and progress to more 
complex functionality. Along the way we'll digress to cover topics you'll need 
to know about to use Boost.Filesystem effectively.</p>

<p>Source code for each version of the tutorial program is available, and you 
are encouraged to compile, test, and experiment with it. To conserve space, we won't 
always show boilerplate code here, but the provided source is complete and 
ready to build.</p>

<h3>Preliminaries</h3>

<p>Install the Boost distribution if you haven't already done so. See the
<a href="http://www.boost.org/more/getting_started/index.html">Boost Getting 
Started</a> docs.</p>

<p>This tutorial assumes you are going to compile and test the examples using 
the provided scripts. That's highly recommended.</p>

<blockquote>

<p><b>If you are planning to compile and test the examples but not use the 
scripts, make sure your build setup knows where to 
locate or build the Boost library binaries.</b></p>

</blockquote>
<p>Fire up your command line interpreter, and type the following commands:</p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre>$ cd <i><b>boost-root</b></i>/libs/filesystem/example/test
$ ./setup
$ ./bld
$ ./tut1
Usage: tut1 path</pre>
      </td>
      <td style="font-size: 10pt">
      <pre>&gt;cd <i><b>boost-root</b></i>\libs\filesystem\example\test
&gt;setup
&gt;bld
&gt;tut1
Usage: tut1 path</pre>
      </td>
    </tr>
  </table>

<p>If the <code>tut1</code> command outputs &quot;<code>Usage: tut1 path</code>&quot;, all 
is well. A set of tutorial programs has been copied (by <code>setup</code>) to
<i><b><code>boost-root</code></b></i><code>/libs/filesystem/example/test</code> 
and then built. You are encouraged to modify and experiment with them as the 
tutorial progresses. Just invoke the <code>bld</code> script again to rebuild.</p>

<p>If something didn't work right, here are some troubleshooting suggestions:</p>

<blockquote>

<p><b>Windows:</b></p>

  <ul>
    <li><code>'bjam' is not recognized as an internal or external command, 
    operable program or batch file</code>. The bjam program isn't being found. 
    Check your path environmental variable if it should have been found, 
    otherwise see
    <a href="http://www.boost.org/more/getting_started/windows.html">Boost 
    Getting Started</a>.</li>
    <li>Look at <code>bjam.log</code> to try to spot an indication of the 
    problem.</li>
  </ul>
</blockquote>

<h2><a href="../example/tut1.cpp">tut1.cpp</a> - Reporting the size of a file</h2>

<p>Let's get started. One of the simplest things we can do is report the size of 
a file.</p>

<table align="center" border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
  <tr>
    <td style="font-size: 10pt">
    <pre><a href="../example/tut1.cpp">tut1.cpp</a></pre>
    <blockquote style="font-size: 10pt">
      <pre>#include &lt;iostream&gt;
#include &lt;boost/filesystem.hpp&gt;
using namespace boost::filesystem;

int main(int argc, char* argv[])
{
  if (argc &lt; 2)
  {
    std::cout &lt;&lt; &quot;Usage: tut1 path\n&quot;;
    return 1;
  }
  std::cout &lt;&lt; argv[1] &lt;&lt; &quot;: &quot; &lt;&lt; file_size(argv[1]) &lt;&lt; '\n';
  return 0;
}</pre>
    </blockquote>
    </td>
  </tr>
</table>

<p>The Boost.Filesystem <code><a href="reference.html#file_size">file_size</a></code> function returns an <code>uintmax_t</code> 
containing the size of the file named by the argument. The declaration looks 
like this:</p>

<blockquote>
  <pre><span style="background-color: #FFFFFF; ">uintmax_t</span> <a name="file_size">file_size</a>(const path&amp; p);</pre>
</blockquote>
<p>For now, all you need to know is that class path has constructors that take
<code>const char *</code> and many other useful types. (If you can't wait to 
find out more, skip ahead to the <a href="#Class-path">class path</a> section of 
the tutorial.)</p>
<p>Please take a minute to try out <code>tut1</code> on your system, using a 
file that is known to exist, such as <code>tut1.cpp</code>. Here is what the 
results look like on two different operating systems:</p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre><span style="background-color: #FFFF00">$ ./tut1 tut1.cpp
tut1.cpp: 570</span></pre>
      </td>
      <td style="font-size: 10pt">
      <pre>&gt;tut1 tut1.cpp
tut1.cpp: 593
&gt;dir tut1.cpp
...
01/30/2010 10:47 AM 593 tut1.cpp
...</pre>
      </td>
    </tr>
  </table>

<p>So far, so good. The reported Linux and Windows sizes are different because 
the Linux tests used <code>&quot;\n&quot;</code> line endings, while the Windows tests 
used <code>&quot;\r\n&quot;</code> line endings.</p>
  <p>Now try again, but give a path that doesn't exist:</p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre>$ ./tut1 foo</pre>
      </td>
      <td style="font-size: 10pt">
      <pre>&gt;tut1 foo</pre>
      </td>
    </tr>
  </table>

  <p>What happens?
  There's no file named <code>foo</code> in the current directory, so an 
exception is thrown.</p>
  <p>Try this:</p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre>$ ./tut1 .</pre>
      </td>
      <td style="font-size: 10pt">
      <pre>&gt;tut1 .</pre>
      </td>
    </tr>
  </table>

  <p>The current directory exists, but <code>file_size()</code> works on regular 
  files, not directories, so again, an exception is thrown.</p>

  <p>We'll deal with those situations in <code>tut2.cpp</code>.</p>

<h2><a href="../example/tut2.cpp">tut2.cpp</a> - Using status queries to determine file existence and type</h2>

<p>Boost.filesystem includes status query functions such as <code>exists</code>,
<code>is_directory</code>, and <code>is_regular_file</code>. These all return
<code>bool</code>'s, and will return <code>true</code> if the condition 
described by their name is met. They return <code>false</code> when any element 
of the path argument can't be found.</p>

<p>tut2.cpp uses several of the status query functions to cope with non-existent 
files and with different file types. </p>

<table align="center" border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
  <tr>
    <td style="font-size: 10pt">
    <pre><a href="../example/tut2.cpp">tut2.cpp</a></pre>
    <blockquote style="font-size: 10pt">
      <pre>int main(int argc, char* argv[])
{
  <a href="reference.html#class-path">path</a> p (argv[1]);   // p reads clearer than argv[1] in the following code

  cout &lt;&lt; p &lt;&lt; &quot;: &quot;;  // utilize the <a href="reference.html#path-inserter-extractor">path narrow stream inserter</a>

  if ( <a href="reference.html#exists-path">exists</a>(p) )    // does p actually exist?
  {
    if ( <a href="reference.html#is_regular_file-path">is_regular_file</a>(p) )        // is p a regular file?   
      cout &lt;&lt; <a href="reference.html#file_size">file_size</a>(p) &lt;&lt; '\n';

    else if ( <a href="reference.html#is_directory-path">is_directory</a>(p) )      // is p a directory?
      cout &lt;&lt; &quot;is a directory\n&quot;;

    else
      cout &lt;&lt; &quot;exists, but is neither a regular file nor a directory\n&quot;;
  }
  else
    cout &lt;&lt; &quot;does not exist\n&quot;;

  return 0;
}</pre>
    </blockquote>
    </td>
  </tr>
</table>

<p>Give it a try:</p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre><span style="background-color: #FFFF00">$ ./tut2 ..</span></pre>
      </td>
      <td style="font-size: 10pt">
      <pre>&gt;tut2 tut2.cpp
tut2.cpp: 1079

&gt;tut2 foo
foo: does not exist

&gt;tut2 .
.: is a directory</pre>
      </td>
    </tr>
  </table>

<p>Although tut2 works, the output is less than 
satisfactory for a directory since we'd typically like to see the directory's contents. Move 
on to <code>tut3.cpp</code> to see how to iterate over directories.</p>

<h2><a href="../example/tut3.cpp">tut3.cpp</a> - Directory iteration</h2>

<p>Boost.Filesystem's <code><a href="reference.html#directory_iterator">
directory_iterator</a></code> class is just what we need here. It follows the 
general pattern of the standard library's <code>istream_iterator</code>. Constructed from 
a path, it iterates over the contents of the directory. A default constructed <code>directory_iterator</code> 
acts as the end iterator.</p>

<p>The value type of <code>directory_iterator</code> is <code>
<a href="reference.html#directory_entry">directory_entry</a></code>. A <code>
directory_entry</code> contains a <code>path</code> and symlink/non-symlink 
resolving <code><a href="reference.html#file_status">file_status</a></code> 
caches, and 
can be passed to <code>path</code> arguments in function calls.</p>

<table align="center" border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
  <tr>
    <td style="font-size: 10pt">
    <pre><a href="../example/tut3.cpp">tut3.cpp</a></pre>
    <blockquote>
      <pre>int main(int argc, char* argv[])
{
  <a href="reference.html#class-path">path</a> p (argv[1]);   // p reads clearer than argv[1] in the following code

  cout &lt;&lt; p &lt;&lt; &quot;: &quot;;  // utilize the <a href="reference.html#path-inserter-extractor">path narrow stream inserter</a>

  if ( <a href="reference.html#exists-path">exists</a>(p) )    // does p actually exist?
  {
    if ( <a href="reference.html#is_regular_file-path">is_regular_file</a>(p) )        // is p a regular file?   
      cout &lt;&lt; <a href="reference.html#file_size">file_size</a>(p) &lt;&lt; '\n';

    else if ( <a href="reference.html#is_directory-path">is_directory</a>(p) )      // is p a directory?
    {
      cout &lt;&lt; &quot;is a directory containing:\n&quot;;

      for ( <a href="reference.html#directory_iterator-ctor-path">directory_iterator</a> it (p);   // initialize it to the first element
            it != <a href="reference.html#directory_iterator-default-ctor">directory_iterator()</a>;  // test for the past-the-end element
            ++it )                       // increment
      {
        cout &lt;&lt; &quot; &quot; &lt;&lt; *it &lt;&lt; '\n';      // *it returns a <a href="reference.html#directory_entry">directory_entry</a>,
                                         // which is converted to a path by the
                                         // stream inserter.
                                         // it-&gt;path() would be wordier, but would
                                         // eliminate an unnecessary path temporary
      }
    }

    else
      cout &lt;&lt; &quot;exists, but is neither a regular file nor a directory\n&quot;;
  }
  else
    cout &lt;&lt; &quot;does not exist\n&quot;;

  return 0;
}</pre>
    </blockquote>
    </td>
  </tr>
</table>

<p>Give <code>tut3</code> a try, passing it a path to a directory as a command line argument. 
Here is a run on a checkout of the Boost Subversion trunk:</p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre>$ ./tut3 ~/boost/trunk
/home/beman/boost/trunk: is a directory containing:
  /home/beman/boost/trunk/tools
  /home/beman/boost/trunk/boost-build.jam
  /home/beman/boost/trunk/dist
  /home/beman/boost/trunk/doc
  /home/beman/boost/trunk/bootstrap.sh
  /home/beman/boost/trunk/index.html
  /home/beman/boost/trunk/bin.v2
  /home/beman/boost/trunk/bootstrap.bat
  /home/beman/boost/trunk/boost.css
  /home/beman/boost/trunk/INSTALL
  /home/beman/boost/trunk/rst.css
  /home/beman/boost/trunk/boost
  /home/beman/boost/trunk/people
  /home/beman/boost/trunk/wiki
  /home/beman/boost/trunk/boost.png
  /home/beman/boost/trunk/LICENSE_1_0.txt
  /home/beman/boost/trunk/more
  /home/beman/boost/trunk/Jamroot
  /home/beman/boost/trunk/.svn
  /home/beman/boost/trunk/libs
  /home/beman/boost/trunk/index.htm
  /home/beman/boost/trunk/status
  /home/beman/boost/trunk/CMakeLists.txt</pre>
      </td>
      <td style="font-size: 10pt">
      <pre>&gt;tut3 c:\boost\trunk
c:\boost\trunk: is a directory containing:
   c:\boost\trunk\.svn
   c:\boost\trunk\bin.v2
   c:\boost\trunk\boost
   c:\boost\trunk\boost-build.jam
   c:\boost\trunk\boost.css
   c:\boost\trunk\boost.png
   c:\boost\trunk\bootstrap.bat
   c:\boost\trunk\bootstrap.sh
   c:\boost\trunk\CMakeLists.txt
   c:\boost\trunk\dist
   c:\boost\trunk\doc
   c:\boost\trunk\index.htm
   c:\boost\trunk\index.html
   c:\boost\trunk\INSTALL
   c:\boost\trunk\Jamroot
   c:\boost\trunk\libs
   c:\boost\trunk\LICENSE_1_0.txt
   c:\boost\trunk\more
   c:\boost\trunk\people
   c:\boost\trunk\rst.css
   c:\boost\trunk\status
   c:\boost\trunk\tools
   c:\boost\trunk\wiki</pre>
      </td>
    </tr>
  </table>

<h2><a href="../example/tut4.cpp">tut4.cpp</a> - Using a path decomposition 
function and sorting results</h2>

<p>It might be clearer to output just the filename, without the parent path. Class 
<code>path</code> has a decomposition function to extract the filename, so 
that's easy to try. Just change</p>
<blockquote>
  <pre>cout &lt;&lt; &quot; &quot; &lt;&lt; *it &lt;&lt; '\n';</pre>
</blockquote>
<p>to</p>
<blockquote>
  <pre>cout &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;path().filename() &lt;&lt; '\n'; </pre>
</blockquote>
<p>Here is the output from <code><a href="../example/tut4.cpp">tut4.cpp</a></code>, which makes that change:</p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre>$ ./tut4 ~/boost/trunk
/home/beman/boost/trunk: is a directory containing:
  .svn
  CMakeLists.txt
  INSTALL
  Jamroot
  LICENSE_1_0.txt
  boost
  boost-build.jam
  boost.css
  boost.png
  bootstrap.bat
  bootstrap.sh
  doc
  index.htm
  index.html
  libs
  more
  people
  rst.css
  status
  tools
  wiki</pre>
      </td>
      <td style="font-size: 10pt">
      <pre>C:\v3d&gt;tut4 c:\boost\trunk
c:\boost\trunk: is a directory containing:
  .svn
  CMakeLists.txt
  INSTALL
  Jamroot
  LICENSE_1_0.txt
  boost
  boost-build.jam
  boost.css
  boost.png
  bootstrap.bat
  bootstrap.sh
  doc
  index.htm
  index.html
  libs
  more
  people
  rst.css
  status
  tools
  wiki</pre>
      </td>
    </tr>
  </table>

<h2><a href="../example/path_info.cpp">path_info.cpp</a> - Path iterators, observers, composition, decomposition and query</h2>

<p>The <code>path_info</code> program is handy for learning how class <code>path</code> 
iterators, 
observers, composition, decomposition, and query functions work on your system. 
If it hasn't already already been built on your system, please build it now. Run 
the examples below on your system, and try some different path arguments as we 
go along.</p>

<p> <code>path_info</code> produces several dozen output lines every time it's 
invoked. We will only show the output lines we are interested in at the moment.</p>

<p>First we'll look at iteration over the elements of a path, and then use 
iteration to illustrate the difference between generic and native format paths.</p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre>$ ./path_info /foo/bar/baa.txt
...
elements:
  /
  foo
  bar
  baa.txt</pre>
      </td>
      <td style="font-size: 10pt">
      <pre>&gt;path_info /foo/bar/baa.txt
...
elements:
  /
  foo
  bar
  baa.txt</pre>
      </td>
    </tr>
  </table>

<p>Thus on both POSIX and Windows based systems the path <code>&quot;/foo/bar/baa.txt&quot;</code> 
is seen as having four elements.</p>

<p>Here is the code that produced the above listing:</p>

<table align="center" border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
  <tr>
    <td style="font-size: 10pt">
    <blockquote style="font-size: 10pt">
    <pre>cout &lt;&lt; &quot;\nelements:\n&quot;;

for (path::iterator it = p.begin(); it != p.end(); ++it)
  cout &lt;&lt; &quot; &quot; &lt;&lt; *it &lt;&lt; '\n';</pre>
    </blockquote>
    </td>
  </tr>
</table>
<p><code>path::iterator::value_type</code> is <code>path::string_type</code>, 
and iteration treats <code>path</code> as a container of filenames.</p>

<p dir="ltr">Let's look at some at the output from the a slightly different 
example:</p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre>$ ./path_info /foo/bar/baa.txt

composed path:
  cout &lt;&lt; -------------: /foo/bar/baa.txt
  preferred()----------: /foo/bar/baa.txt
...
observers, native format:
  native()-------------: /foo/bar/baa.txt
  c_str()--------------: /foo/bar/baa.txt
  string()-------------: /foo/bar/baa.txt
  wstring()------------: /foo/bar/baa.txt

observers, generic format:
  generic_string()-----: /foo/bar/baa.txt
  generic_wstring()----: /foo/bar/baa.txt</pre>
      </td>
      <td style="font-size: 10pt">
      <pre>&gt;path_info /foo/bar\baa.txt

composed path:
  cout &lt;&lt; -------------: /foo/bar/baa.txt
  preferred()----------: \foo\bar\baa.txt
...
observers, native format:
  native()-------------: /foo/bar\baa.txt
  c_str()--------------: /foo/bar\baa.txt
  string()-------------: /foo/bar\baa.txt
  wstring()------------: /foo/bar\baa.txt

observers, generic format:
  generic_string()-----: /foo/bar/baa.txt
  generic_wstring()----: /foo/bar/baa.txt</pre>
      </td>
    </tr>
  </table>

<p dir="ltr"><b>Class <code>path</code> deals with two different pathname 
formats - a generic format and a native format.</b> In the case of POSIX-like 
operating systems, these formats are the same. But for users of Windows and 
other non-POSIX operating systems, the distinction is important. Even 
programmers writing for POSIX-like systems need to understand the distinction if 
they want their code to be portable to non-POSIX systems.</p>

<p dir="ltr">The <b>generic format</b> is the format used by POSIX-like 
operating systems such as the Unixes, Linux, and Mac OS X. The directory 
separator character is a slash.</p>

<p dir="ltr">The <b>native format</b> is the format as defined by the particular 
operating system. For Windows, either the slash or the backslash can be used as 
the directory separator character. If a drive specified or a backslash appears 
in a pathname on a Windows system, it is always treated as the native format.</p>

<p dir="ltr">Native format observers should be used when interacting with the 
operating system or with users; that's what they expect.</p>

<p dir="ltr">Generic format observers should be used when the results need to be 
portable and uniform regardless of the operating system.</p>

<p dir="ltr"><code>path</code> objects always hold pathnames in the native 
format, but otherwise leave them unchanged from their source. The
<a href="reference.html#preferred">preferred()</a> function will convert to the 
preferred form, if the native format has several forms. Thus on Windows, it will 
convert slashes to backslashes.</p>

<p dir="ltr">Let's move on to decomposition and query functions:</p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre>$ ./path_info /foo/bar/baa.txt
...
decomposition:
  root_name()----------:
  root_directory()-----: /
  root_path()----------: /
  relative_path()------: foo/bar/baa.txt
  parent_path()--------: /foo/bar
  filename()-----------: baa.txt
  stem()---------------: baa
  extension()----------: .txt

query:
  empty()--------------: false
  <span style="background-color: #FFFF00">is_absolute</span><span style="background-color: #FFFF00">()--------: true</span>
  has_root_name()------: false
  has_root_directory()-: true
  has_root_path()------: true
  has_relative_path()--: true
  has_parent_path()----: true
  has_filename()-------: true
  has_stem()-----------: true
  has_extension()------: true</pre>
      </td>
      <td style="font-size: 10pt">
      <pre>&gt;path_info /foo/bar/baa.txt
...
decomposition:
  root_name()----------:
  root_directory()-----: /
  root_path()----------: /
  relative_path()------: foo/bar/baa.txt
  parent_path()--------: /foo/bar
  filename()-----------: baa.txt
  stem()---------------: baa
  extension()----------: .txt

query:
  empty()--------------: false
  <span style="background-color: #FFFF00">is_absolute</span><span style="background-color: #FFFF00">()--------: false</span>
  has_root_name()------: false
  has_root_directory()-: true
  has_root_path()------: true
  has_relative_path()--: true
  has_parent_path()----: true
  has_filename()-------: true
  has_stem()-----------: true
  has_extension()------: true</pre>
      </td>
    </tr>
  </table>

<p dir="ltr">These are pretty self-evident, but do note the difference in the 
result of <code>is_absolute()</code> between Linux and Windows. Because there is 
no root name (i.e. drive specifier or network name), a lone slash (or backslash) 
is a relative path on Windows. </p>

<p dir="ltr">On to composition!</p>

<p>Class <code>path</code> uses <code>/</code> and <code>/=</code> operators to 
append elements. That's a reminder 
that these operations append the operating system's preferred directory 
separator if needed. The preferred 
directory separator is a slash on POSIX-like systems, and a backslash on 
Windows-like systems.</p>

<p><a href="../example/path_info.cpp"><code>path_info.cpp</code></a> 
composes a path by appending each of the command line elements to an initially 
empty path:</p>

<table align="center" border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
  <tr>
    <td style="font-size: 10pt">
    <blockquote>
    <pre>path p;  // compose a path from the command line arguments

for (; argc &gt; 1; --argc, ++argv)
  p /= argv[1];

cout &lt;&lt; &quot;\ncomposed path:\n&quot;;
cout &lt;&lt; &quot; cout &lt;&lt; -------------: &quot; &lt;&lt; p &lt;&lt; &quot;\n&quot;;
cout &lt;&lt; &quot; preferred()----------: &quot; &lt;&lt; p.preferred() &lt;&lt; &quot;\n&quot;;</pre>
    </blockquote>
    </td>
  </tr>
</table>

<p>Let's give this code a try: </p>

  <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
    <tr>
      <td align="center" width="50%" style="font-size: 10pt"><i><b>Ubuntu Linux </b></i></td>
      <td align="center" style="font-size: 10pt"><i><b>Microsoft Windows</b></i></td>
    </tr>
    <tr>
      <td width="50%" style="font-size: 10pt">
      <pre>$ ./path_info / foo/bar baz.txt

composed path:
  cout &lt;&lt; -------------: /foo/bar/baa.txt
  preferred()----------: /foo/bar/baa.txt</pre>
      </td>
      <td style="font-size: 10pt">
      <pre>&gt;path_info / foo/bar baa.txt

composed path:
  cout &lt;&lt; -------------: /foo/bar\baa.txt
  preferred()----------: \foo\bar\baa.txt</pre>
      </td>
    </tr>
  </table>

<h3>Directory iteration tweak - tut4.cpp</h3>

<table align="center" border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF" width="90%">
  <tr>
    <td style="font-size: 10pt">
    <pre><a href="../tutorial/tut4.cpp">tut4.cpp</a></pre>
    <blockquote>
      <pre>int main(int argc, char* argv[])
{
  path p (argv[1]);

  cout &lt;&lt; p &lt;&lt; &quot;: &quot;;
  if ( exists(p) )
  {
    if ( is_regular_file(p) )
      cout &lt;&lt; file_size(p) &lt;&lt; '\n';
    else if ( is_directory(p) )
    {
      cout &lt;&lt; &quot;is a directory containing:\n&quot;;
      for ( directory_iterator it (p); it != directory_iterator (); ++it )
      {
        <span style="background-color: #88FFA3">cout &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;</span><span style="background-color: #88FFA3">path().filename</span><span style="background-color: #88FFA3">() &lt;&lt; '\n';</span>
      }
    }
    else
      cout &lt;&lt; &quot;exists, but is neither a regular file nor a directory\n&quot;;<span style="background-color: #88FFA3">
</span>  }
  else
    cout &lt;&lt; &quot;does not exist\n&quot;;

  return 0;
}</pre>
    </blockquote>
    </td>
  </tr>
</table>

<h3>Error handling - tut5.cpp</h3>

<hr>

<h3><a name="Class-path">Class path</a></h3>

<p>Rather than trafficking in <code>const char*</code>'s, Boost.Filesystem 
operational functions traffics in objects of <a href="reference.html#Path">class path</a>, 
which are a lot more flexible. For example, class path has a converting constructor 
template:</p>

<blockquote style="font-size: 10pt">
  <pre>template &lt;class Source&gt;
  path(Source const&amp; source);</pre>
</blockquote>
<p>and this allows <code>const path&amp;</code> arguments to be called with a 
variety of object types, such as:</p>
<ul>
  <li style="font-size: 10pt">An iterator, such as a pointer, for a null terminated byte-string. 
  Value type can be <code>char</code>, <code>
  wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code>.</li>
  <li style="font-size: 10pt">A container with a value type of <code>char</code>, <code>
  wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code>.</li>
  <li style="font-size: 10pt">A C-array with a value type of <code>char</code>, <code>
  wchar_t</code>, <code>char16_t</code>, or <code>char32_t</code>.</li>
  <li style="font-size: 10pt">A <code>boost::filesystem::directory_entry</code>.</li>
</ul>
<p>In addition to handling a variety of types, class path function templates 
also handle conversion between the argument's encoding and the internal encoding 
required for communication with the operating system. Thus it's no problem to 
pass a wide character string to a Boost.Filesystem operational function even if 
the underlying operating system uses narrow characters, and visa versa. </p>
<p>Say we have a file named <code><font size="4">valentine</font></code> we'd 
like to rename <code><font size="4">&#9829;valentine</font></code>. Here's the code:</p>
<blockquote style="font-size: 10pt">
  <pre>boost::filesystem::rename(&quot;valentine&quot;, L&quot;\u2665valentine&quot;);</pre>
</blockquote>

  <p>Class <code>path</code> will take care of whatever character type or 
  encoding conversions are required by the particular operating system. It also 
  provides path syntax that is portable across operating systems, element 
  iterators, and observer, composition, decomposition, and query functions to 
  manipulate the elements of a path. <span style="background-color: #FFFF00">
  More on class </span><code><span style="background-color: #FFFF00">path</span></code><span style="background-color: #FFFF00"> 
  later in this tutorial.</span></p>

  <hr>

  <h3>Error reporting</h3>

  <p>Legacy C interfaces like the original <code>rename</code> function report 
  errors via an error code, typically obtained via <code>errno</code>. The 
  preferred C++ practice is to throw an exception to report an error, and that's 
  how the first of the two Boost.Filesystem <code>rename</code> functions 
  reports errors. A <code>filesystem_error</code> exception will be thrown on an 
  operational error. It's derived from <code>std::runtime_error</code> and has a 
  member function to obtain the <code>error_code</code> reported by the source 
  of the error. It also has member functions to obtain the path[s] that caused 
  the error.</p>

  <p>That was the entire error reporting story for the earliest versions of 
  Boost.Filesystem, and indeed throwing exceptions on errors worked very well in 
  many applications. But some user reports trickled in of code that became so 
  littered by try and catch blocks as to be unreadable and unmaintainable. In 
  some applications I/O errors aren't exceptional, and that's why most 
  Boost.Filesystem operational functions come in two flavors.</p>

  <p>Functions without a <code>system::error_code&amp;</code> 
argument throw exceptions to report operational errors. These functions should 
  be your default choice, unless you really do need to deal with errors via hand 
  coded error tests.</p>

  <p>Functions with a <code>system::error_code&amp;</code> 
argument report operational error status by setting the <code>ec</code> argument, and 
do not throw exceptions when I/O errors occur. 
  <span style="background-color: #FFFF00">More on that later in the tutorial.</span></p>

<p>&nbsp;</p>

<hr>
<p>© Copyright Beman Dawes 2009</p>
<p>Distributed under the Boost Software License, Version 1.0. See
<a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
<p>Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B %Y" startspan -->31 January 2010<!--webbot bot="Timestamp" endspan i-checksum="32137" --></p>

</body>

</html>