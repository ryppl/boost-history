O:15:"boost_libraries":3:{s:10:"categories";a:20:{s:6:"String";a:3:{s:4:"name";s:6:"String";s:5:"title";s:26:"String and text processing";s:9:"libraries";a:0:{}}s:10:"Containers";a:3:{s:4:"name";s:10:"Containers";s:5:"title";s:10:"Containers";s:9:"libraries";a:0:{}}s:9:"Iterators";a:3:{s:4:"name";s:9:"Iterators";s:5:"title";s:9:"Iterators";s:9:"libraries";a:0:{}}s:10:"Algorithms";a:3:{s:4:"name";s:10:"Algorithms";s:5:"title";s:10:"Algorithms";s:9:"libraries";a:0:{}}s:16:"Function-objects";a:3:{s:4:"name";s:16:"Function-objects";s:5:"title";s:45:"Function objects and higher-order programming";s:9:"libraries";a:0:{}}s:7:"Generic";a:3:{s:4:"name";s:7:"Generic";s:5:"title";s:19:"Generic Programming";s:9:"libraries";a:0:{}}s:15:"Metaprogramming";a:3:{s:4:"name";s:15:"Metaprogramming";s:5:"title";s:25:"Template  Metaprogramming";s:9:"libraries";a:0:{}}s:12:"Preprocessor";a:3:{s:4:"name";s:12:"Preprocessor";s:5:"title";s:28:"Preprocessor Metaprogramming";s:9:"libraries";a:0:{}}s:10:"Concurrent";a:3:{s:4:"name";s:10:"Concurrent";s:5:"title";s:22:"Concurrent Programming";s:9:"libraries";a:0:{}}s:4:"Math";a:3:{s:4:"name";s:4:"Math";s:5:"title";s:17:"Math and numerics";s:9:"libraries";a:0:{}}s:11:"Correctness";a:3:{s:4:"name";s:11:"Correctness";s:5:"title";s:23:"Correctness and testing";s:9:"libraries";a:0:{}}s:4:"Data";a:3:{s:4:"name";s:4:"Data";s:5:"title";s:15:"Data structures";s:9:"libraries";a:0:{}}s:16:"Image-processing";a:3:{s:4:"name";s:16:"Image-processing";s:5:"title";s:16:"Image processing";s:9:"libraries";a:0:{}}s:2:"IO";a:3:{s:4:"name";s:2:"IO";s:5:"title";s:12:"Input/Output";s:9:"libraries";a:0:{}}s:14:"Inter-language";a:3:{s:4:"name";s:14:"Inter-language";s:5:"title";s:22:"Inter-language support";s:9:"libraries";a:0:{}}s:6:"Memory";a:3:{s:4:"name";s:6:"Memory";s:5:"title";s:6:"Memory";s:9:"libraries";a:0:{}}s:7:"Parsing";a:3:{s:4:"name";s:7:"Parsing";s:5:"title";s:7:"Parsing";s:9:"libraries";a:0:{}}s:11:"Programming";a:3:{s:4:"name";s:11:"Programming";s:5:"title";s:22:"Programming Interfaces";s:9:"libraries";a:0:{}}s:13:"Miscellaneous";a:3:{s:4:"name";s:13:"Miscellaneous";s:5:"title";s:13:"Miscellaneous";s:9:"libraries";a:0:{}}s:11:"workarounds";a:3:{s:4:"name";s:11:"workarounds";s:5:"title";s:27:"Broken compiler workarounds";s:9:"libraries";a:0:{}}}s:2:"db";a:109:{s:12:"accumulators";a:10:{s:3:"key";s:12:"accumulators";s:13:"boost-version";s:6:"1.36.0";s:4:"name";s:12:"Accumulators";s:7:"authors";s:12:"Eric Niebler";s:11:"description";s:82:"Framework for incremental calculation, and collection of statistical accumulators.";s:13:"documentation";s:28:"libs/accumulators/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:16:"algorithm/minmax";a:10:{s:3:"key";s:16:"algorithm/minmax";s:13:"boost-version";s:6:"1.32.0";s:4:"name";s:7:"Min-Max";s:7:"authors";s:18:"Hervé Brönnimann";s:11:"description";s:90:"Standard library extensions for simultaneous
    min/max and min/max element computations.";s:13:"documentation";s:32:"libs/algorithm/minmax/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:10:"Algorithms";}}s:16:"algorithm/string";a:10:{s:3:"key";s:16:"algorithm/string";s:13:"boost-version";s:6:"1.32.0";s:4:"name";s:11:"String Algo";s:7:"authors";s:11:"Pavol Droba";s:11:"description";s:26:"String algorithms library.";s:13:"documentation";s:25:"doc/html/string_algo.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:6:"String";i:1;s:10:"Algorithms";}}s:3:"any";a:10:{s:3:"key";s:3:"any";s:13:"boost-version";s:6:"1.23.0";s:4:"name";s:3:"Any";s:7:"authors";s:13:"Kevlin Henney";s:11:"description";s:71:"Safe, generic container for single values of
    different value types.";s:13:"documentation";s:17:"doc/html/any.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Data";}}s:5:"array";a:10:{s:3:"key";s:5:"array";s:13:"boost-version";s:6:"1.17.0";s:4:"name";s:5:"Array";s:7:"authors";s:16:"Nicolai Josuttis";s:11:"description";s:64:"STL compliant container wrapper for arrays of
    constant size.";s:13:"documentation";s:19:"doc/html/array.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:10:"Containers";}}s:4:"asio";a:10:{s:3:"key";s:4:"asio";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:4:"Asio";s:7:"authors";s:14:"Chris Kohlhoff";s:11:"description";s:93:"Portable networking, including sockets, timers,
    hostname resolution and socket iostreams.";s:13:"documentation";s:24:"doc/html/boost_asio.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:19:"autolink-dependency";s:8:"category";a:2:{i:0;s:10:"Concurrent";i:1;s:2:"IO";}}s:6:"assign";a:10:{s:3:"key";s:6:"assign";s:13:"boost-version";s:6:"1.32.0";s:4:"name";s:6:"Assign";s:7:"authors";s:16:"Thorsten Ottosen";s:11:"description";s:77:"Filling containers with constant or generated data
    has never been easier.";s:13:"documentation";s:26:"libs/assign/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:2:"IO";}}s:5:"bimap";a:10:{s:3:"key";s:5:"bimap";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:5:"Bimap";s:7:"authors";s:16:"Matias Capeletto";s:11:"description";s:138:"Bidirectional maps library for C++. With Boost.Bimap you
    can create associative containers in which both types can be used
    as key.";s:13:"documentation";s:30:"libs/bimap/doc/html/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:10:"Containers";i:1;s:4:"Data";}}s:4:"bind";a:10:{s:3:"key";s:4:"bind";s:13:"boost-version";s:6:"1.25.0";s:4:"name";s:4:"Bind";s:7:"authors";s:11:"Peter Dimov";s:11:"description";s:312:"boost::bind is a generalization of the standard
    functions std::bind1st and std::bind2nd. It supports arbitrary
    function objects, functions, function pointers, and member
    function pointers, and is able to bind any argument to a
    specific value or route input arguments into arbitrary
    positions.";s:13:"documentation";s:19:"libs/bind/bind.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:11:"bind/mem_fn";a:10:{s:3:"key";s:11:"bind/mem_fn";s:13:"boost-version";s:6:"1.25.0";s:4:"name";s:15:"Member Function";s:7:"authors";s:11:"Peter Dimov";s:11:"description";s:74:"Generalized binders for function/object/pointers
    and member functions.";s:13:"documentation";s:21:"libs/bind/mem_fn.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:8:"bind/ref";a:10:{s:3:"key";s:8:"bind/ref";s:13:"boost-version";s:6:"1.25.0";s:4:"name";s:3:"Ref";s:7:"authors";s:61:"Jaako Järvi, Peter Dimov, Doug Gregor, and Dave
    Abrahams";s:11:"description";s:66:"A utility library for passing references to
    generic functions.";s:13:"documentation";s:17:"doc/html/ref.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:6:"chrono";a:10:{s:3:"key";s:6:"chrono";s:13:"boost-version";s:6:"1.47.0";s:4:"name";s:6:"Chrono";s:7:"authors";s:25:"Vicente J. Botet Escribá";s:11:"description";s:22:"Useful time utilities.";s:13:"documentation";s:22:"libs/chrono/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:15:"circular_buffer";a:10:{s:3:"key";s:15:"circular_buffer";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:15:"Circular Buffer";s:7:"authors";s:10:"Jan Gaspar";s:11:"description";s:62:"A STL compliant container also known as ring or cyclic buffer.";s:13:"documentation";s:31:"libs/circular_buffer/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:10:"Containers";}}s:13:"compatibility";a:10:{s:3:"key";s:13:"compatibility";s:13:"boost-version";s:6:"1.21.2";s:4:"name";s:13:"Compatibility";s:7:"authors";s:37:"Ralf Grosse-Kunstleve and Jens Maurer";s:11:"description";s:47:"Help for non-conforming standard
    libraries.";s:13:"documentation";s:29:"libs/compatibility/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:11:"workarounds";}}s:13:"concept_check";a:10:{s:3:"key";s:13:"concept_check";s:13:"boost-version";s:6:"1.19.0";s:4:"name";s:13:"Concept Check";s:7:"authors";s:11:"Jeremy Siek";s:11:"description";s:30:"Tools for generic programming.";s:13:"documentation";s:36:"libs/concept_check/concept_check.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:7:"Generic";i:1;s:11:"Correctness";}}s:6:"config";a:10:{s:3:"key";s:6:"config";s:13:"boost-version";s:5:"1.9.0";s:4:"name";s:6:"Config";s:7:"authors";s:0:"";s:11:"description";s:100:"Helps Boost library developers adapt to compiler
    idiosyncrasies; not intended for library users.";s:13:"documentation";s:22:"libs/config/config.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:11:"workarounds";}}s:10:"conversion";a:10:{s:3:"key";s:10:"conversion";s:13:"boost-version";s:6:"1.20.0";s:4:"name";s:10:"Conversion";s:7:"authors";s:31:"Dave Abrahams and Kevlin Henney";s:11:"description";s:30:"Polymorphic and lexical casts.";s:13:"documentation";s:26:"libs/conversion/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:6:"String";i:1;s:13:"Miscellaneous";}}s:3:"crc";a:10:{s:3:"key";s:3:"crc";s:13:"boost-version";s:6:"1.22.0";s:4:"name";s:3:"CRC";s:7:"authors";s:13:"Daryle Walker";s:11:"description";s:208:"The Boost CRC Library provides two implementations
    of CRC (cyclic redundancy code) computation objects and two
    implementations of CRC computation functions. The
    implementations are template-based.";s:13:"documentation";s:19:"libs/crc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:9:"date_time";a:10:{s:3:"key";s:9:"date_time";s:13:"boost-version";s:6:"1.29.0";s:4:"name";s:9:"Date Time";s:7:"authors";s:12:"Jeff Garland";s:11:"description";s:71:"A set of date-time libraries based on generic
    programming concepts.";s:13:"documentation";s:23:"doc/html/date_time.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:13:"disjoint_sets";a:10:{s:3:"key";s:13:"disjoint_sets";s:13:"boost-version";s:5:"1.9.0";s:4:"name";s:13:"Disjoint Sets";s:7:"authors";s:43:"Jeremy Siek, Lie-Quan Lee, Andrew Lumsdaine";s:11:"description";s:101:"Boost.DisjointSets provides disjoint sets
    operations with union by rank and path
    compression.";s:13:"documentation";s:37:"libs/disjoint_sets/disjoint_sets.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:10:"Containers";}}s:14:"dynamic_bitset";a:10:{s:3:"key";s:14:"dynamic_bitset";s:13:"boost-version";s:6:"1.29.0";s:4:"name";s:14:"Dynamic Bitset";s:7:"authors";s:29:"Jeremy Siek and Chuck Allison";s:11:"description";s:373:"The dynamic_bitset class represents a set of bits.
    It provides accesses to the value of individual bits via an
    operator[] and provides all of the bitwise operators that one
    can apply to builtin integers, such as operator& and
    operator<<. The number of bits in the set is specified at
    runtime via a parameter to the constructor of the
    dynamic_bitset.";s:13:"documentation";s:39:"libs/dynamic_bitset/dynamic_bitset.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:10:"Containers";}}s:9:"exception";a:10:{s:3:"key";s:9:"exception";s:13:"boost-version";s:6:"1.36.0";s:4:"name";s:9:"Exception";s:7:"authors";s:15:"Emil Dotchevski";s:11:"description";s:145:"The Boost Exception library supports transporting
    of arbitrary data in exception objects, and transporting of
    exceptions between threads.";s:13:"documentation";s:39:"libs/exception/doc/boost-exception.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:10:"filesystem";a:10:{s:3:"key";s:10:"filesystem";s:13:"boost-version";s:6:"1.30.0";s:4:"name";s:10:"Filesystem";s:7:"authors";s:11:"Beman Dawes";s:11:"description";s:120:"The Boost Filesystem Library provides portable
    facilities to query and manipulate paths, files, and
    directories.";s:13:"documentation";s:26:"libs/filesystem/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:9:"flyweight";a:10:{s:3:"key";s:9:"flyweight";s:13:"boost-version";s:6:"1.38.0";s:4:"name";s:9:"Flyweight";s:7:"authors";s:24:"Joaquín M López Muñoz";s:11:"description";s:74:"Design pattern to manage large quantities of highly redundant
    objects.";s:13:"documentation";s:29:"libs/flyweight/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:7:"foreach";a:10:{s:3:"key";s:7:"foreach";s:13:"boost-version";s:6:"1.34.0";s:4:"name";s:7:"Foreach";s:7:"authors";s:12:"Eric Niebler";s:11:"description";s:646:"In C++, writing a loop that iterates over a
    sequence is tedious. We can either use iterators, which
    requires a considerable amount of boiler-plate, or we can use
    the std::for_each() algorithm and move our loop body into a
    predicate, which requires no less boiler-plate and forces us to
    move our logic far from where it will be used. In contrast,
    some other languages, like Perl, provide a dedicated "foreach"
    construct that automates this process. BOOST_FOREACH is just
    such a construct for C++. It iterates over sequences for us,
    freeing us from having to deal directly with iterators or write
    predicates.";s:13:"documentation";s:21:"doc/html/foreach.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:10:"Algorithms";}}s:6:"format";a:10:{s:3:"key";s:6:"format";s:13:"boost-version";s:6:"1.29.0";s:4:"name";s:6:"Format";s:7:"authors";s:13:"Samuel Krempp";s:11:"description";s:500:"The format library provides a class for formatting
    arguments according to a format-string, as does printf, but
    with two major differences: format sends the arguments to an
    internal stream, and so is entirely type-safe and naturally
    supports all user-defined types; the ellipsis (...) can not be
    used correctly in the strongly typed context of format, and
    thus the function call with arbitrary arguments is replaced by
    successive calls to an argument feeding
    operator%.";s:13:"documentation";s:22:"libs/format/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:6:"String";i:1;s:2:"IO";}}s:8:"function";a:10:{s:3:"key";s:8:"function";s:13:"boost-version";s:6:"1.23.0";s:4:"name";s:8:"Function";s:7:"authors";s:11:"Doug Gregor";s:11:"description";s:61:"Function object wrappers for deferred calls or
    callbacks.";s:13:"documentation";s:22:"doc/html/function.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:16:"Function-objects";i:1;s:11:"Programming";}}s:14:"function_types";a:10:{s:3:"key";s:14:"function_types";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:14:"Function Types";s:7:"authors";s:16:"Tobias Schwinger";s:11:"description";s:164:"Boost.FunctionTypes provides functionality to classify,
    decompose and synthesize function, function pointer, function reference and
    pointer to member types.";s:13:"documentation";s:39:"libs/function_types/doc/html/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:7:"Generic";i:1;s:15:"Metaprogramming";}}s:10:"functional";a:10:{s:3:"key";s:10:"functional";s:13:"boost-version";s:6:"1.16.0";s:4:"name";s:10:"Functional";s:7:"authors";s:12:"Mark Rodgers";s:11:"description";s:106:"The Boost.Function library contains a family of
    class templates that are function object
    wrappers.";s:13:"documentation";s:26:"libs/functional/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:15:"functional/hash";a:10:{s:3:"key";s:15:"functional/hash";s:13:"boost-version";s:6:"1.33.0";s:4:"name";s:15:"Functional/Hash";s:7:"authors";s:12:"Daniel James";s:11:"description";s:79:"A TR1 hash function object that can be extended to
    hash user defined types.";s:13:"documentation";s:18:"doc/html/hash.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:18:"functional/factory";a:10:{s:3:"key";s:18:"functional/factory";s:13:"boost-version";s:6:"1.43.0";s:4:"name";s:18:"Functional/Factory";s:7:"authors";s:16:"Tobias Schwinger";s:11:"description";s:64:"Function object templates for dynamic and static object creation";s:13:"documentation";s:34:"libs/functional/factory/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:18:"functional/forward";a:10:{s:3:"key";s:18:"functional/forward";s:13:"boost-version";s:6:"1.43.0";s:4:"name";s:18:"Functional/Forward";s:7:"authors";s:16:"Tobias Schwinger";s:11:"description";s:72:"Adapters to allow generic function objects to accept arbitrary arguments";s:13:"documentation";s:34:"libs/functional/forward/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:6:"fusion";a:10:{s:3:"key";s:6:"fusion";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:6:"Fusion";s:7:"authors";s:48:"Joel de Guzman, Dan Marsden and Tobias Schwinger";s:11:"description";s:80:"Library for working with tuples, including various containers,
	algorithms, etc.";s:13:"documentation";s:31:"libs/fusion/doc/html/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:15:"Metaprogramming";i:1;s:4:"Data";}}s:8:"geometry";a:10:{s:3:"key";s:8:"geometry";s:13:"boost-version";s:6:"1.47.0";s:4:"name";s:8:"Geometry";s:7:"authors";s:48:"Barend Gehrels, Bruno Lalande and Mateusz Loskot";s:11:"description";s:17:"Geometry Library.";s:13:"documentation";s:24:"libs/geometry/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:10:"Algorithms";i:1;s:4:"Math";}}s:3:"gil";a:10:{s:3:"key";s:3:"gil";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:3:"GIL";s:7:"authors";s:30:"Lubomir Bourdev and Hailin Jin";s:11:"description";s:21:"Generic Image Library";s:13:"documentation";s:23:"libs/gil/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:5:{i:0;s:10:"Containers";i:1;s:9:"Iterators";i:2;s:10:"Algorithms";i:3;s:7:"Generic";i:4;s:16:"Image-processing";}}s:5:"graph";a:10:{s:3:"key";s:5:"graph";s:13:"boost-version";s:6:"1.18.0";s:4:"name";s:5:"Graph";s:7:"authors";s:107:"Jeremy Siek and a University of Notre Dame team;
    now maintained by Andrew Sutton and Jeremiah Willcock.";s:11:"description";s:127:"The BGL graph interface and graph components are
    generic, in the same sense as the the Standard Template Library
    (STL).";s:13:"documentation";s:37:"libs/graph/doc/table_of_contents.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:3:{i:0;s:10:"Containers";i:1;s:9:"Iterators";i:2;s:10:"Algorithms";}}s:3:"icl";a:10:{s:3:"key";s:3:"icl";s:13:"boost-version";s:6:"1.46.0";s:4:"name";s:3:"ICL";s:7:"authors";s:17:"Joachim Faulhaber";s:11:"description";s:91:"Interval Container Library, interval sets and maps and
    aggregation of associated values";s:13:"documentation";s:19:"libs/icl/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:10:"Containers";i:1;s:4:"Data";}}s:7:"integer";a:10:{s:3:"key";s:7:"integer";s:13:"boost-version";s:5:"1.9.0";s:4:"name";s:7:"Integer";s:7:"authors";s:0:"";s:11:"description";s:371:"The organization of boost integer headers and
    classes is designed to take advantage of <stdint.h> types
    from the 1999 C standard without resorting to undefined
    behavior in terms of the 1998 C++ standard. The header
    <boost/cstdint.hpp> makes the standard integer types
    safely available in namespace boost without placing any names
    in namespace std.";s:13:"documentation";s:23:"libs/integer/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:12:"interprocess";a:10:{s:3:"key";s:12:"interprocess";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:12:"Interprocess";s:7:"authors";s:14:"Ion Gaztañaga";s:11:"description";s:111:"Shared memory, memory mapped files, process-shared mutexes,
    condition variables, containers and allocators.";s:13:"documentation";s:26:"doc/html/interprocess.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:10:"Concurrent";}}s:9:"intrusive";a:10:{s:3:"key";s:9:"intrusive";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:9:"Intrusive";s:7:"authors";s:14:"Ion Gaztañaga";s:11:"description";s:36:"Intrusive containers and algorithms.";s:13:"documentation";s:23:"doc/html/intrusive.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:10:"Containers";}}s:2:"io";a:10:{s:3:"key";s:2:"io";s:13:"boost-version";s:6:"1.28.0";s:4:"name";s:15:"IO State Savers";s:7:"authors";s:13:"Daryle Walker";s:11:"description";s:179:"The I/O sub-library of Boost helps segregate the
    large number of Boost headers. This sub-library should contain
    various items to use with/for the standard I/O
    library.";s:13:"documentation";s:26:"libs/io/doc/ios_state.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:2:"IO";}}s:9:"iostreams";a:10:{s:3:"key";s:9:"iostreams";s:13:"boost-version";s:6:"1.33.0";s:4:"name";s:9:"Iostreams";s:7:"authors";s:17:"Jonathan Turkanis";s:11:"description";s:94:"Boost.IOStreams provides a framework for defining
    streams, stream buffers and i/o filters.";s:13:"documentation";s:29:"libs/iostreams/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:2:{i:0;s:6:"String";i:1;s:2:"IO";}}s:8:"iterator";a:10:{s:3:"key";s:8:"iterator";s:13:"boost-version";s:6:"1.21.0";s:4:"name";s:9:"Iterators";s:7:"authors";s:43:"Dave Abrahams, Jeremy Siek, and Thomas Witt";s:11:"description";s:292:"The Boost Iterator Library contains two parts. The
    first is a system of concepts which extend the C++ standard
    iterator requirements. The second is a framework of components
    for building iterators based on these extended concepts and
    includes several useful iterator adaptors.";s:13:"documentation";s:28:"libs/iterator/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:9:"Iterators";}}s:6:"lambda";a:10:{s:3:"key";s:6:"lambda";s:13:"boost-version";s:6:"1.28.0";s:4:"name";s:6:"Lambda";s:7:"authors";s:29:"Jaakko Järvi and Gary Powell";s:11:"description";s:76:"Define small unnamed function objects at the
    actual call site, and more.";s:13:"documentation";s:20:"doc/html/lambda.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:12:"lexical_cast";a:10:{s:3:"key";s:12:"lexical_cast";s:13:"boost-version";s:6:"1.20.0";s:4:"name";s:12:"Lexical Cast";s:7:"authors";s:13:"Kevlin Henney";s:11:"description";s:109:"General literal text conversions, such as an int
    represented a string, or vice-versa, from Kevlin Henney.";s:13:"documentation";s:32:"libs/conversion/lexical_cast.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:6:"String";i:1;s:13:"Miscellaneous";}}s:13:"logic/tribool";a:10:{s:3:"key";s:13:"logic/tribool";s:13:"boost-version";s:6:"1.32.0";s:4:"name";s:7:"Tribool";s:7:"authors";s:11:"Doug Gregor";s:11:"description";s:29:"3-state boolean type library.";s:13:"documentation";s:21:"doc/html/tribool.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:4:"math";a:10:{s:3:"key";s:4:"math";s:13:"boost-version";s:6:"1.23.0";s:4:"name";s:4:"Math";s:7:"authors";s:7:"various";s:11:"description";s:721:"Boost.Math includes several contributions in the
    domain of mathematics: The Greatest Common Divisor and Least
    Common Multiple library provides run-time and compile-time
    evaluation of the greatest common divisor (GCD) or least common
    multiple (LCM) of two integers. The Special Functions library
    currently provides eight templated special functions, in
    namespace boost. The Complex Number Inverse Trigonometric
    Functions are the inverses of trigonometric functions currently
    present in the C++ standard. Quaternions are a relative of
    complex numbers often used to parameterise rotations in three
    dimentional space. Octonions, like quaternions, are a relative
    of complex numbers.";s:13:"documentation";s:20:"libs/math/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:18:"math/common_factor";a:10:{s:3:"key";s:18:"math/common_factor";s:13:"boost-version";s:6:"1.26.0";s:4:"name";s:18:"Math Common Factor";s:7:"authors";s:13:"Daryle Walker";s:11:"description";s:54:"Greatest common divisor and least common
    multiple.";s:13:"documentation";s:32:"libs/math/doc/common_factor.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:13:"math/octonion";a:10:{s:3:"key";s:13:"math/octonion";s:13:"boost-version";s:6:"1.23.0";s:4:"name";s:13:"Math Octonion";s:7:"authors";s:12:"Hubert Holin";s:11:"description";s:10:"Octonions.";s:13:"documentation";s:38:"libs/math/doc/octonion/html/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:15:"math/quaternion";a:10:{s:3:"key";s:15:"math/quaternion";s:13:"boost-version";s:6:"1.23.0";s:4:"name";s:15:"Math Quaternion";s:7:"authors";s:12:"Hubert Holin";s:11:"description";s:12:"Quaternions.";s:13:"documentation";s:40:"libs/math/doc/quaternion/html/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:22:"math/special_functions";a:10:{s:3:"key";s:22:"math/special_functions";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:22:"Math/Special Functions";s:7:"authors";s:59:"John Maddock, Paul Bristow, Hubert Holin and Xiaogang Zhang";s:11:"description";s:51:"A wide selection of mathematical special functions.";s:13:"documentation";s:41:"libs/math/doc/sf_and_dist/html/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:4:"Math";}}s:30:"math/statistical_distributions";a:10:{s:3:"key";s:30:"math/statistical_distributions";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:30:"Math/Statistical Distributions";s:7:"authors";s:29:"John Maddock and Paul Bristow";s:11:"description";s:96:"A wide selection of univariate statistical distributions and
    functions that operate on them.";s:13:"documentation";s:41:"libs/math/doc/sf_and_dist/html/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:3:"mpi";a:10:{s:3:"key";s:3:"mpi";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:3:"MPI";s:7:"authors";s:34:"Douglas Gregor and Matthias Troyer";s:11:"description";s:102:"Message Passing Interface library, for use in distributed-memory
    parallel application programming.";s:13:"documentation";s:17:"doc/html/mpi.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:10:"Concurrent";}}s:3:"mpl";a:10:{s:3:"key";s:3:"mpl";s:13:"boost-version";s:6:"1.30.0";s:4:"name";s:3:"MPL";s:7:"authors";s:16:"Aleksey Gurtovoy";s:11:"description";s:372:"The Boost.MPL library is a general-purpose,
    high-level C++ template metaprogramming framework of
    compile-time algorithms, sequences and metafunctions. It
    provides a conceptual foundation and an extensive set of
    powerful and coherent tools that make doing explict
    metaprogramming in C++ as easy and enjoyable as possible within
    the current language.";s:13:"documentation";s:23:"libs/mpl/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:15:"Metaprogramming";}}s:3:"msm";a:10:{s:3:"key";s:3:"msm";s:13:"boost-version";s:6:"1.44.0";s:4:"name";s:18:"Meta State Machine";s:7:"authors";s:16:"Christophe Henry";s:11:"description";s:74:"A very high-performance library for expressive UML2 finite state machines.";s:13:"documentation";s:19:"libs/msm/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:11:"multi_array";a:10:{s:3:"key";s:11:"multi_array";s:13:"boost-version";s:6:"1.29.0";s:4:"name";s:11:"Multi-Array";s:7:"authors";s:10:"Ron Garcia";s:11:"description";s:128:"Boost.MultiArray provides a generic N-dimensional
    array concept definition and common implementations of that
    interface.";s:13:"documentation";s:31:"libs/multi_array/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:10:"Containers";i:1;s:4:"Math";}}s:11:"multi_index";a:10:{s:3:"key";s:11:"multi_index";s:13:"boost-version";s:6:"1.32.0";s:4:"name";s:11:"Multi-Index";s:7:"authors";s:24:"Joaquín M López Muñoz";s:11:"description";s:228:"The Boost Multi-index Containers Library provides
    a class template named multi_index_container which enables the
    construction of containers maintaining one or more indices with
    different sorting and access semantics.";s:13:"documentation";s:31:"libs/multi_index/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:10:"Containers";i:1;s:4:"Data";}}s:18:"numeric/conversion";a:10:{s:3:"key";s:18:"numeric/conversion";s:13:"boost-version";s:6:"1.32.0";s:4:"name";s:18:"Numeric Conversion";s:7:"authors";s:17:"Fernando Cacciola";s:11:"description";s:47:"Optimized Policy-based Numeric
    Conversions.";s:13:"documentation";s:34:"libs/numeric/conversion/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:4:"Math";i:1;s:13:"Miscellaneous";}}s:16:"numeric/interval";a:10:{s:3:"key";s:16:"numeric/interval";s:13:"boost-version";s:6:"1.30.0";s:4:"name";s:8:"Interval";s:7:"authors";s:60:"Guillaume Melquiond, Hervé Brönnimann and
    Sylvain Pion";s:11:"description";s:69:"Extends the usual arithmetic functions to
    mathematical intervals.";s:13:"documentation";s:38:"libs/numeric/interval/doc/interval.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:13:"numeric/ublas";a:10:{s:3:"key";s:13:"numeric/ublas";s:13:"boost-version";s:6:"1.29.0";s:4:"name";s:5:"uBLAS";s:7:"authors";s:29:"Joerg Walter and Mathias Koch";s:11:"description";s:154:"uBLAS provides matrix and vector classes as well
    as basic linear algebra routines. Several dense, packed and
    sparse storage schemes are supported.";s:13:"documentation";s:32:"libs/numeric/ublas/doc/index.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:8:"optional";a:10:{s:3:"key";s:8:"optional";s:13:"boost-version";s:6:"1.30.0";s:4:"name";s:8:"Optional";s:7:"authors";s:17:"Fernando Cacciola";s:11:"description";s:52:"Discriminated-union wrapper for optional
    values.";s:13:"documentation";s:24:"libs/optional/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:9:"parameter";a:10:{s:3:"key";s:9:"parameter";s:13:"boost-version";s:6:"1.33.0";s:4:"name";s:9:"Parameter";s:7:"authors";s:32:"David Abrahams and Daniel Wallin";s:11:"description";s:76:"Boost.Parameter Library - Write functions that
    accept arguments by name.";s:13:"documentation";s:34:"libs/parameter/doc/html/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:11:"Programming";}}s:7:"phoenix";a:10:{s:3:"key";s:7:"phoenix";s:13:"boost-version";s:6:"1.47.0";s:4:"name";s:7:"Phoenix";s:7:"authors";s:45:"Joel de Guzman, Dan Marsden and Thomas Heller";s:11:"description";s:76:"Define small unnamed function objects at the actual
    call site, and more.";s:13:"documentation";s:23:"libs/phoenix/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:7:"polygon";a:10:{s:3:"key";s:7:"polygon";s:13:"boost-version";s:6:"1.44.0";s:4:"name";s:7:"Polygon";s:7:"authors";s:16:"Lucanus Simonson";s:11:"description";s:94:"Booleans/clipping, resizing/offsetting and more for planar polygons with integral coordinates.";s:13:"documentation";s:23:"libs/polygon/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:4:"pool";a:10:{s:3:"key";s:4:"pool";s:13:"boost-version";s:6:"1.21.0";s:4:"name";s:4:"Pool";s:7:"authors";s:12:"Steve Cleary";s:11:"description";s:23:"Memory pool management.";s:13:"documentation";s:24:"libs/pool/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:6:"Memory";}}s:12:"preprocessor";a:10:{s:3:"key";s:12:"preprocessor";s:13:"boost-version";s:6:"1.26.0";s:4:"name";s:12:"Preprocessor";s:7:"authors";s:33:"Vesa Karvonen and Paul Mensonides";s:11:"description";s:74:"Preprocessor metaprogramming tools including
    repetition and recursion.";s:13:"documentation";s:32:"libs/preprocessor/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:12:"Preprocessor";}}s:15:"program_options";a:10:{s:3:"key";s:15:"program_options";s:13:"boost-version";s:6:"1.32.0";s:4:"name";s:15:"Program Options";s:7:"authors";s:13:"Vladimir Prus";s:11:"description";s:198:"The program_options library allows program
    developers to obtain program options, that is (name, value)
    pairs from the user, via conventional methods such as command
    line and config file.";s:13:"documentation";s:29:"doc/html/program_options.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:2:{i:0;s:2:"IO";i:1;s:13:"Miscellaneous";}}s:12:"property_map";a:10:{s:3:"key";s:12:"property_map";s:13:"boost-version";s:6:"1.19.0";s:4:"name";s:12:"Property Map";s:7:"authors";s:11:"Jeremy Siek";s:11:"description";s:72:"Concepts defining interfaces which map key objects
    to value objects.";s:13:"documentation";s:28:"libs/property_map/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:10:"Containers";i:1;s:7:"Generic";}}s:13:"property_tree";a:10:{s:3:"key";s:13:"property_tree";s:13:"boost-version";s:6:"1.41.0";s:4:"name";s:13:"Property Tree";s:7:"authors";s:14:"Sebastian Redl";s:11:"description";s:70:"A tree data structure especially suited to storing configuration data.";s:13:"documentation";s:29:"libs/property_tree/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:10:"Containers";i:1;s:4:"Data";}}s:5:"proto";a:10:{s:3:"key";s:5:"proto";s:13:"boost-version";s:6:"1.37.0";s:4:"name";s:5:"Proto";s:7:"authors";s:12:"Eric Niebler";s:11:"description";s:101:"Expression template library and compiler construction toolkit for domain-specific embedded languages.";s:13:"documentation";s:21:"libs/proto/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:15:"Metaprogramming";}}s:13:"ptr_container";a:10:{s:3:"key";s:13:"ptr_container";s:13:"boost-version";s:6:"1.33.0";s:4:"name";s:17:"Pointer Container";s:7:"authors";s:16:"Thorsten Ottosen";s:11:"description";s:85:"Containers for storing heap-allocated polymorphic
    objects to ease OO-programming.";s:13:"documentation";s:41:"libs/ptr_container/doc/ptr_container.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:10:"Containers";i:1;s:4:"Data";}}s:6:"python";a:9:{s:3:"key";s:6:"python";s:13:"boost-version";s:6:"1.19.0";s:4:"name";s:6:"Python";s:7:"authors";s:13:"Dave Abrahams";s:11:"description";s:245:"The Boost Python Library is a framework for
    interfacing Python and C++. It allows you to quickly and
    seamlessly expose C++ classes functions and objects to Python,
    and vice-versa, using no special tools -- just your C++
    compiler.";s:13:"documentation";s:26:"libs/python/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:8:"category";a:1:{i:0;s:14:"Inter-language";}}s:6:"random";a:10:{s:3:"key";s:6:"random";s:13:"boost-version";s:6:"1.15.0";s:4:"name";s:6:"Random";s:7:"authors";s:11:"Jens Maurer";s:11:"description";s:51:"A complete system for random number
    generation.";s:13:"documentation";s:22:"libs/random/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:5:"range";a:10:{s:3:"key";s:5:"range";s:13:"boost-version";s:6:"1.32.0";s:4:"name";s:5:"Range";s:7:"authors";s:29:"Niel Groves, Thorsten Ottosen";s:11:"description";s:96:"A new infrastructure for generic algorithms that
    builds on top of the new iterator concepts.";s:13:"documentation";s:21:"libs/range/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:10:"Algorithms";}}s:5:"ratio";a:10:{s:3:"key";s:5:"ratio";s:13:"boost-version";s:6:"1.47.0";s:4:"name";s:5:"Ratio";s:7:"authors";s:25:"Vicente J. Botet Escribá";s:11:"description";s:33:"Compile time rational arithmetic.";s:13:"documentation";s:21:"libs/ratio/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:8:"rational";a:10:{s:3:"key";s:8:"rational";s:13:"boost-version";s:6:"1.11.0";s:4:"name";s:8:"Rational";s:7:"authors";s:10:"Paul Moore";s:11:"description";s:24:"A rational number class.";s:13:"documentation";s:24:"libs/rational/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Math";}}s:5:"regex";a:10:{s:3:"key";s:5:"regex";s:13:"boost-version";s:6:"1.18.0";s:4:"name";s:5:"Regex";s:7:"authors";s:12:"John Maddock";s:11:"description";s:27:"Regular expression library.";s:13:"documentation";s:21:"libs/regex/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:6:"String";}}s:10:"scope_exit";a:10:{s:3:"key";s:10:"scope_exit";s:13:"boost-version";s:6:"1.38.0";s:4:"name";s:10:"Scope Exit";s:7:"authors";s:17:"Alexander Nasonov";s:11:"description";s:37:"Execute arbitrary code at scope exit.";s:13:"documentation";s:35:"libs/scope_exit/doc/html/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:13:"serialization";a:10:{s:3:"key";s:13:"serialization";s:13:"boost-version";s:6:"1.32.0";s:4:"name";s:13:"Serialization";s:7:"authors";s:12:"Robert Ramey";s:11:"description";s:50:"Serialization for persistence and
    marshalling.";s:13:"documentation";s:33:"libs/serialization/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:2:"IO";}}s:7:"signals";a:10:{s:3:"key";s:7:"signals";s:13:"boost-version";s:6:"1.29.0";s:4:"name";s:7:"Signals";s:7:"authors";s:11:"Doug Gregor";s:11:"description";s:52:"Managed signals & slots callback
    implementation.";s:13:"documentation";s:21:"doc/html/signals.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:8:"signals2";a:10:{s:3:"key";s:8:"signals2";s:13:"boost-version";s:6:"1.39.0";s:4:"name";s:8:"Signals2";s:7:"authors";s:15:"Frank Mori Hess";s:11:"description";s:76:"Managed signals & slots callback
    implementation (thread-safe version 2).";s:13:"documentation";s:14:"libs/signals2/";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:9:"smart_ptr";a:10:{s:3:"key";s:9:"smart_ptr";s:13:"boost-version";s:6:"1.23.0";s:4:"name";s:9:"Smart Ptr";s:7:"authors";s:58:"Greg Colvin, Beman Dawes, Peter Dimov, and Darin
    Adler";s:11:"description";s:30:"Smart pointer class templates.";s:13:"documentation";s:28:"libs/smart_ptr/smart_ptr.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:6:"Memory";}}s:13:"static_assert";a:10:{s:3:"key";s:13:"static_assert";s:13:"boost-version";s:6:"1.19.0";s:4:"name";s:13:"Static Assert";s:7:"authors";s:12:"John Maddock";s:11:"description";s:48:"Static assertions (compile time
    assertions).";s:13:"documentation";s:32:"doc/html/boost_staticassert.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:3:{i:0;s:7:"Generic";i:1;s:15:"Metaprogramming";i:2;s:11:"Correctness";}}s:6:"spirit";a:10:{s:3:"key";s:6:"spirit";s:13:"boost-version";s:6:"1.30.0";s:4:"name";s:6:"Spirit";s:7:"authors";s:46:"Joel de Guzman, Hartmut Kaiser, and Dan Nuffer";s:11:"description";s:84:"LL parser framework represents parsers directly as
    EBNF grammars in inlined C++.";s:13:"documentation";s:22:"libs/spirit/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:6:"String";i:1;s:7:"Parsing";}}s:10:"statechart";a:10:{s:3:"key";s:10:"statechart";s:13:"boost-version";s:6:"1.34.0";s:4:"name";s:10:"Statechart";s:7:"authors";s:20:"Andreas Huber Dönni";s:11:"description";s:133:"Boost.Statechart - Arbitrarily complex finite
    state machines can be implemented in easily readable and
    maintainable C++ code.";s:13:"documentation";s:30:"libs/statechart/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:6:"system";a:10:{s:3:"key";s:6:"system";s:13:"boost-version";s:6:"1.35.0";s:4:"name";s:6:"System";s:7:"authors";s:11:"Beman Dawes";s:11:"description";s:112:"Operating system support, including the diagnostics support
    that will be part of the C++0x standard library.";s:13:"documentation";s:26:"libs/system/doc/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:4:"test";a:10:{s:3:"key";s:4:"test";s:13:"boost-version";s:6:"1.21.0";s:4:"name";s:4:"Test";s:7:"authors";s:17:"Gennadiy Rozental";s:11:"description";s:96:"Support for simple program testing, full unit
    testing, and for program execution monitoring.";s:13:"documentation";s:20:"libs/test/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:11:"Correctness";}}s:6:"thread";a:10:{s:3:"key";s:6:"thread";s:13:"boost-version";s:6:"1.25.0";s:4:"name";s:6:"Thread";s:7:"authors";s:43:"Anthony Williams (originally William Kempf)";s:11:"description";s:29:"Portable C++ multi-threading.";s:13:"documentation";s:20:"doc/html/thread.html";s:12:"std-proposal";b:1;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:10:"Concurrent";}}s:5:"timer";a:10:{s:3:"key";s:5:"timer";s:13:"boost-version";s:5:"1.9.0";s:4:"name";s:5:"Timer";s:7:"authors";s:11:"Beman Dawes";s:11:"description";s:62:"Event timer, progress timer, and progress display
    classes.";s:13:"documentation";s:21:"libs/timer/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:9:"tokenizer";a:10:{s:3:"key";s:9:"tokenizer";s:13:"boost-version";s:6:"1.23.0";s:4:"name";s:9:"Tokenizer";s:7:"authors";s:12:"John Bandela";s:11:"description";s:74:"Break of a string or other character sequence into
    a series of tokens.";s:13:"documentation";s:25:"libs/tokenizer/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:6:"String";i:1;s:9:"Iterators";}}s:3:"tr1";a:10:{s:3:"key";s:3:"tr1";s:13:"boost-version";s:6:"1.34.0";s:4:"name";s:3:"TR1";s:7:"authors";s:12:"John Maddock";s:11:"description";s:388:"The TR1 library provides an implementation of the
    C++ Technical Report on Standard Library Extensions. This
    library does not itself implement the TR1 components, rather
    it's a thin wrapper that will include your standard library's
    TR1 implementation (if it has one), otherwise it will include
    the Boost Library equivalents, and import them into namespace
    std::tr1.";s:13:"documentation";s:23:"doc/html/boost_tr1.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:5:"tuple";a:10:{s:3:"key";s:5:"tuple";s:13:"boost-version";s:6:"1.24.0";s:4:"name";s:5:"Tuple";s:7:"authors";s:13:"Jaakko Järvi";s:11:"description";s:69:"Ease definition of functions returning multiple
    values, and more.";s:13:"documentation";s:37:"libs/tuple/doc/tuple_users_guide.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Data";}}s:11:"type_traits";a:10:{s:3:"key";s:11:"type_traits";s:13:"boost-version";s:6:"1.13.0";s:4:"name";s:11:"Type Traits";s:7:"authors";s:33:"John Maddock, Steve Cleary, et al";s:11:"description";s:50:"Templates for fundamental properties of
    types.";s:13:"documentation";s:27:"libs/type_traits/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:7:"Generic";i:1;s:15:"Metaprogramming";}}s:6:"typeof";a:10:{s:3:"key";s:6:"typeof";s:13:"boost-version";s:6:"1.34.0";s:4:"name";s:6:"Typeof";s:7:"authors";s:28:"Arkadiy Vertleyb, Peder Holt";s:11:"description";s:26:"Typeof operator emulation.";s:13:"documentation";s:20:"doc/html/typeof.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:5:"units";a:10:{s:3:"key";s:5:"units";s:13:"boost-version";s:6:"1.36.0";s:4:"name";s:5:"Units";s:7:"authors";s:36:"Matthias Schabel and Steven Watanabe";s:11:"description";s:81:"Zero-overhead dimensional analysis and unit/quantity manipulation and conversion.";s:13:"documentation";s:21:"libs/units/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:9:"unordered";a:10:{s:3:"key";s:9:"unordered";s:13:"boost-version";s:6:"1.36.0";s:4:"name";s:9:"Unordered";s:7:"authors";s:12:"Daniel James";s:11:"description";s:33:"Unordered associative containers.";s:13:"documentation";s:25:"libs/unordered/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:1;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:10:"Containers";}}s:7:"utility";a:10:{s:3:"key";s:7:"utility";s:13:"boost-version";s:6:"1.13.0";s:4:"name";s:7:"Utility";s:7:"authors";s:24:"Dave Abrahams and others";s:11:"description";s:137:"Class noncopyable plus checked_delete(),
    checked_array_delete(), next(), prior() function templates,
    plus base-from-member idiom.";s:13:"documentation";s:24:"libs/utility/utility.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:4:{i:0;s:10:"Algorithms";i:1;s:16:"Function-objects";i:2;s:6:"Memory";i:3;s:13:"Miscellaneous";}}s:19:"utility/call_traits";a:10:{s:3:"key";s:19:"utility/call_traits";s:13:"boost-version";s:6:"1.13.0";s:4:"name";s:11:"Call Traits";s:7:"authors";s:35:"John Maddock, Howard Hinnant, et al";s:11:"description";s:41:"Defines types for passing
    parameters.";s:13:"documentation";s:28:"libs/utility/call_traits.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:7:"Generic";}}s:23:"utility/compressed_pair";a:10:{s:3:"key";s:23:"utility/compressed_pair";s:13:"boost-version";s:6:"1.13.0";s:4:"name";s:15:"Compressed Pair";s:7:"authors";s:35:"John Maddock, Howard Hinnant, et al";s:11:"description";s:26:"Empty member optimization.";s:13:"documentation";s:32:"libs/utility/compressed_pair.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:4:"Data";i:1;s:13:"Miscellaneous";}}s:17:"utility/enable_if";a:10:{s:3:"key";s:17:"utility/enable_if";s:13:"boost-version";s:6:"1.31.0";s:4:"name";s:9:"Enable If";s:7:"authors";s:58:"Jaakko Järvi, Jeremiah Willcock, and Andrew
    Lumsdaine";s:11:"description";s:55:"Selective inclusion of function template
    overloads.";s:13:"documentation";s:27:"libs/utility/enable_if.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:7:"Generic";}}s:26:"utility/in_place_factories";a:10:{s:3:"key";s:26:"utility/in_place_factories";s:13:"boost-version";s:5:"1.9.0";s:4:"name";s:40:"In Place Factory, Typed In Place Factory";s:7:"authors";s:17:"Fernando Cacciola";s:11:"description";s:85:"Generic in-place construction of contained objects
    with a variadic argument-list.";s:13:"documentation";s:36:"libs/utility/in_place_factories.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:7:"Generic";}}s:17:"utility/operators";a:10:{s:3:"key";s:17:"utility/operators";s:13:"boost-version";s:5:"1.9.0";s:4:"name";s:9:"Operators";s:7:"authors";s:29:"Dave Abrahams and Jeremy Siek";s:11:"description";s:52:"Templates ease arithmetic classes and
    iterators.";s:13:"documentation";s:26:"libs/utility/operators.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:3:{i:0;s:9:"Iterators";i:1;s:7:"Generic";i:2;s:4:"Math";}}s:17:"utility/result_of";a:10:{s:3:"key";s:17:"utility/result_of";s:13:"boost-version";s:6:"1.32.0";s:4:"name";s:9:"Result Of";s:7:"authors";s:0:"";s:11:"description";s:50:"Determines the type of a function call expression.";s:13:"documentation";s:34:"libs/utility/utility.htm#result_of";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:16:"Function-objects";}}s:12:"utility/swap";a:10:{s:3:"key";s:12:"utility/swap";s:13:"boost-version";s:6:"1.38.0";s:4:"name";s:4:"Swap";s:7:"authors";s:15:"Joseph Gauterin";s:11:"description";s:31:"Enhanced generic swap function.";s:13:"documentation";s:22:"libs/utility/swap.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:25:"utility/value_initialized";a:10:{s:3:"key";s:25:"utility/value_initialized";s:13:"boost-version";s:5:"1.9.0";s:4:"name";s:17:"Value Initialized";s:7:"authors";s:17:"Fernando Cacciola";s:11:"description";s:98:"Wrapper for uniform-syntax value initialization,
    based on the original idea of David Abrahams.";s:13:"documentation";s:27:"libs/utility/value_init.htm";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:13:"Miscellaneous";}}s:4:"uuid";a:10:{s:3:"key";s:4:"uuid";s:13:"boost-version";s:6:"1.42.0";s:4:"name";s:4:"Uuid";s:7:"authors";s:13:"Andy Tompkins";s:11:"description";s:32:"A universally unique identifier.";s:13:"documentation";s:20:"libs/uuid/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:4:"Data";}}s:7:"variant";a:10:{s:3:"key";s:7:"variant";s:13:"boost-version";s:6:"1.31.0";s:4:"name";s:7:"Variant";s:7:"authors";s:28:"Eric Friedman and Itay Maman";s:11:"description";s:61:"Safe, generic, stack-based discriminated union
    container.";s:13:"documentation";s:21:"doc/html/variant.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:2:{i:0;s:10:"Containers";i:1;s:4:"Data";}}s:4:"wave";a:10:{s:3:"key";s:4:"wave";s:13:"boost-version";s:6:"1.33.0";s:4:"name";s:4:"Wave";s:7:"authors";s:14:"Hartmut Kaiser";s:11:"description";s:200:"The Boost.Wave library is a Standards conformant,
    and highly configurable implementation of the mandated C99/C++
    preprocessor functionality packed behind an easy to use
    iterator interface.";s:13:"documentation";s:20:"libs/wave/index.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:8:"autolink";s:8:"category";a:1:{i:0;s:6:"String";}}s:9:"xpressive";a:10:{s:3:"key";s:9:"xpressive";s:13:"boost-version";s:6:"1.34.0";s:4:"name";s:9:"Xpressive";s:7:"authors";s:12:"Eric Niebler";s:11:"description";s:192:"Regular expressions that can be written as strings
    or as expression templates, and which can refer to each other
    and themselves recursively with the power of context-free
    grammars.";s:13:"documentation";s:23:"doc/html/xpressive.html";s:12:"std-proposal";b:0;s:7:"std-tr1";b:0;s:5:"build";s:11:"header-only";s:8:"category";a:1:{i:0;s:6:"String";}}}s:12:"build_values";a:3:{s:11:"header-only";s:11:"Header only";s:8:"autolink";s:17:"Automatic linking";s:19:"autolink-dependency";s:35:"Automatic linking due to dependency";}}