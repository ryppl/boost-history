[/
 / Copyright (c) 2010 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[library Toward Boost.Enums
    [quickbook 1.5]
    [version 0.1.0]
    [authors [Botet Escriba, Vicente J.]]
    [copyright 2010 Vicente J. Botet Escriba]
    [category Utilities]
    [id boost.enums]
    [dirname enums]
    [purpose C++0x scoped enums emulation]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[:[C enumerations constitute a curiously half-baked concept.
]]
[:[*['-Stroustrup ]]]

[warning Enums is not a part of the Boost libraries.]

[/========================]
[section Overview]
[/========================]



[/====================================]
[heading How to Use This Documentation]
[/====================================]


This documentation makes use of the following naming and formatting conventions.

* Code is in `fixed width font` and is syntax-highlighted.
* Replaceable text that you will need to supply is in [~italics].
* If a name refers to a free function, it is specified like this:
  `free_function()`; that is, it is in code font and its name is followed by `()`   to indicate that it is a free function.
* If a name refers to a class template, it is specified like this:   `class_template<>`; that is, it is in code font and its name is followed by `<>`   to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in code font and its name is followed by `()` to   indicate that it is a function-like macro. Object-like macros appear without the   trailing `()`.
* Names that refer to /concepts/ in the generic programming sense are specified in CamelCase.

[note In addition, notes such as this one specify non-essential information that provides additional background or rationale.]

Finally, you can mentally add the following to any code fragments in this document:

    // Include all of the core Enums files
    #include <boost/enums.hpp>

    using namespace boost;

[section Motivation]

The David E. Miller, Herb Sutter and Bjarne Stroustrup's proposal ([@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1891.pdf [*N1891: Strongly Typed Enums (revision 3)]  includes a clear motivation for "Strongly Typed Enums".

On compilers not providing "Strongly Typed Enums" we can make a quite close emulation. This allows to write programs that are portable on comilers providing this feature natively and using the emulation on the others.

[endsect]
[/==================]
[section Description]
[/==================]


[*Boost.Enums] intends to provide a library partial solution to this problem.

[*Boost.Enums] provides:

* Some language-like macros helping to define scoped enum classes.
* Some meta-functions and functions helping to write portable programs using scoped enum classes under comilers supporting them natively or by an emulation on the others.

[endsect]
[endsect]

[/==============================]
[section:users_guide Users' Guide]
[/==============================]

[/======================================]
[section:getting_started Getting Started]
[/======================================]

[/======================================]
[section:install Installing Boost.Enums]
[/======================================]

[/=================================]
[heading Getting Boost.Enums]
[/=================================]

You can get the last stable release of [*Boost.Enums] by downloading [^enums.zip] from the
[@http://www.boostpro.com/vault/index.php?action=downloadfile&filename=enums.zip&directory=Utilities& Boost Vault Utilities directory]

You can also access the latest (unstable?) state from the [@https://svn.boost.org/svn/boost/sandbox/enums Boost Sandbox].

[/=================================]
[heading Building Boost.Enums]
[/=================================]

There is no need to compile [*Boost.Enums], since it's
a header only library. Just include your Boost header directory in your
compiler include path.

[/=========================]
[heading Requirements]
[/=========================]

[*Boost.Enums] depends only on Boost.Conversion and Boost.Config  (and all libraries they depends on).


[/========================]
[heading Exceptions safety]
[/========================]

All functions in the library are exception-neutral and provide strong guarantee of exception safety as long as the underlying parameters provide it.

[/====================]
[heading Thread safety]
[/====================]

All functions in the library are thread-unsafe except when noted explicitly.

[/=======================]
[heading Tested compilers]
[/=======================]

The implementation will eventually work with most C++03 conforming compilers.
Current version has been tested on:

Windows with

* MSVC 10.0

Cygwin 1.7 with

* GCC 4.3.4

MinGW with

* GCC 4.4.0
* GCC 4.5.0
* GCC 4.5.0 C++0x
* GCC 4.6.0
* GCC 4.6.0 C++0x

Ubuntu 10.10

* GCC 4.4.5
* GCC 4.4.5 -std=c++0x
* GCC 4.5.1
* GCC 4.5.1 -std=c++0x
* clang 2.8

[note Please let us know how this works on other platforms/compilers.]

[note Please send any questions, comments and bug reports to boost <at> lists <dot> boost <dot> org.]

[endsect]
[/=============================]
[section Hello World! ]
[/=============================]


[endsect]

[endsect]

[section Tutorial]

[section How to define a scoped enum class?]

You can define the equivalent of 

  enum class EnumClass : unsigned char) {
    Enum0 = 0,
    Enum1,
    Enum2
  };
  
using the provided macros as follows

  BOOST_ENUM_CLASS_START(EnumClass, unsigned char) {
    Enum0 = 0,
    Enum1,
    Enum2
  } BOOST_ENUM_CLASS_END(EnumClass, unsigned char)
  
Simple, isn't it?

[endsect]
[section How to use scoped enum classes and the associated literals?]

Scoped enums classes and the associated literals can be used as the C++0x counterparts in almost all the situations.

[endsect]
[section Are scoped enum classes convertible to the underlying type?]

Scoped enums classes are strong types and the conversion to the underlying type is not implicit. You will need to use the enums::get_value function to get explicitly the value.

[endsect]
[section How to define a scoped enum type?]

scoped enum types add implicit conversion to the underlying type. They can be defined as follows

  BOOST_ENUM_TYPE_START(EnumType, int) {
    Enum0 = 0,
    Enum1,
    Enum2
  } BOOST_ENUM_TYPE_END(EnumType, int)

  EnumType e = EnumType::Enum2;
  int i = e;

[endsect]

[section Can these scoped enums be used inside unions?]

All this depends on your compiler. If the compiler support user classes with constructors, there is no problem. But in the oposite case, you will need to  inhibit the constructor.

[section How to inhibit the constructors generation?]

You will need to use the BOOST_ENUM_XXX_NO_CONS_END macros to inhibit the constructor generation 

The problem with removing the constructors is that we are unable to have default constructor and copy constructors syntax. So we will need to use a different syntax to get portable programs.

[endsect]
[section How to replace the default constructor?]

The following compiles but the test can fails depending on the implementation

  { // defaults to the enum default
    EnumClass e ;
    BOOST_TEST(e==EnumClass::Enum0);
  }

You need to state explicitly that you want the defaul value

  { // defaults to the enum default
    EnumClass e =EnumClass();
    BOOST_TEST(e==EnumClass::Enum0);
  }

If you have inhibited the constructors, the preceding code fail to compile. The library provides a function that creates scoped enums instances initialized with the default value.

  { // defaults to the enum default
    EnumClass e = default_value<EnumClass>();
    BOOST_TEST(e==EnumClass::Enum0);
  }

[endsect]
[section How to replace the copy constructor?]

The following fails to compile if constructors have been removed:

  { // copy constructor emulation
    EnumClass e(EnumClass::Enum2);  // COMPILE ERROR HERE
  }

The library provides a function convert_to that creates scoped enums instances

  { // copy constructor emulation
    EnumClass e=boost::convert_to<EnumClass>(EnumClass::Enum2);
    BOOST_TEST(e==EnumClass::Enum2);
  }


[endsect]

[endsect]
[section How to use scoped enums in siwtch statements?]

The following fails to compile if constructors have been removed:
 
  const char* c_str(EnumClass e)
  {
      switch (e) // COMPILE ERROR HERE
      {
      case EnumClass::Enum0 :   return("EnumClass::Enum0");
      case EnumClass::Enum1:    return("EnumClass::Enum1");
      case EnumClass::Enum2 :   return("EnumClass::Enum2");
      default:
        return("EnumClass::???");
      }
  }

The library provides a function get_value that return the native enum in a portable way.

  const char* c_str(EnumClass e)
  {
      switch (boost::enums::get_value(e))
      {
      case EnumClass::Enum0 :   return("EnumClass::Enum0");
      case EnumClass::Enum1:    return("EnumClass::Enum1");
      case EnumClass::Enum2 :   return("EnumClass::Enum2");
      default:
        return("EnumClass::???");
      }
  }

[endsect]
[section How to use scoped enums as non type template parameters?]

The following fails to compile if constructors have been removed:
 
  template <EnumClass e>
  struct ex;

The library provides a meta-function enum_type that return the native enum type in a portable way.

  template <enums::enum_type<EnumClass>::type e>
  struct ex;

[endsect]
[endsect]

[section Examples]
[section aligned]


[endsect]
[section cv_status]


[endsect]
[endsect]



[section:ext_references External Resources]

[variablelist
[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf [*N2347: Strongly Typed Enums (revision 3)]]]
    [Alisdair Meredith]
]

[
    [[@http://www.gimpel.com/html/strong.htm [*PC-lint/FlexeLint Strong Type Checking]]]
    [Gimpel Software]
]

[
    [[@http://www.drdobbs.com/article/printableArticle.jhtml;jsessionid=KPRMREL51P2LZQE1GHPCKH4ATMY32JVN?articleId=184401797&dept_url=/ [*Enumerations]]]
    [Herb Sutter and Jim Hyslop ]
]

[
    [[@http://www.eetimes.com/discussion/programming-pointers/4024556/Enumerations-Q--A [*Enumerations Q & A]]]
    [Dan Saks]
]

]

[endsect]

[endsect]


[section Reference]

[/==========================================================================================]
[section:enums_hpp Header `<boost/enums.hpp>`]
[/==========================================================================================]

Include all the enums public header files.

    #include <boost/enums/include.hpp>

[endsect]


[/==========================================================================================]
[section:include_hpp Header `<boost/enums/include.hpp>`]
[/==========================================================================================]

Include all the enums public header files.

    #include <boost/enums/default_value.hpp>
    #include <boost/enums/underlying_type.hpp>
    #include <boost/enums/enum_type.hpp>
    #include <boost/enums/get_value.hpp>
    #include <boost/enums/emmulation.hpp>
    
[endsect]

[/==========================================================================================]
[section:default_value_hpp Header `<boost/enums/default_value.hpp>`]
[/==========================================================================================]

Builds a enum class with the default value

  namespace boost {
    namespace enums {

      template <typename EC>
      EC default_value();

    }
  }    
  
[endsect]

[/==========================================================================================]
[section:underlying_type_hpp Header `<boost/enums/underlying_type.hpp>`]
[/==========================================================================================]

Metafunction to retrieve the underlying type of a scoped enum.

  namespace boost {
    namespace enums {
      template <typename EC>
      struct underlying_type
      {
        typedef <see below> type;
      };

    }
  }
  
[endsect]

[/==========================================================================================]
[section:enum_type_hpp Header `<boost/enums/enum_type.hpp>`]
[/==========================================================================================]

Metafunction to retrieve the native enumeration type of a scoped enum.

  namespace boost {
    namespace enums {
      template <typename EC>
      struct enum_type
      {
        typedef <see below> type;
      };

    }
  }
  
[endsect]

[/==========================================================================================]
[section:get_value_hpp Header `<boost/enums/get_value.hpp>`]
[/==========================================================================================]

Returns the associated native enumeration type of an enum class.

  namespace boost {
    namespace enums {

      template <typename EC>
      typename enum_type<EC>::type
      get_value(EC e);
      
    }
  }

[endsect]


[/==========================================================================================]
[section:emulation_hpp Header `<boost/enums/emulation.hpp>`]
[/==========================================================================================]

Macro language-like emulating scoped enum classes and types.

  #define BOOST_ENUM_CLASS_START(EC, UT)
  #define BOOST_ENUM_CLASS_END(EC, UT)
  #define BOOST_ENUM_CLASS_NO_CONS_END(EC, UT)

  #define BOOST_ENUM_TYPE_START(EC, UT) 
  #define BOOST_ENUM_TYPE_END(EC, UT)
  #define BOOST_ENUM_TYPE_NO_CONS_END(EC, UT)
    
[endsect]
    
[endsect]

[/=================]
[section Appendices]
[/=================]

[section:history Appendix A: History]

[section [*Version 0.1.0, Feb 27, 2011] ]

Initial version committed on the sandbox

[*Features:]

* Some language-like macros helping to define scoped enum classes.
* Some meta-functions and functions helping to write portable programs using scoped enum classes under comilers supporting them natively or by an emulation on the others.

[endsect]
[endsect]

[section:rationale Appendix B: Design Rationale]

[heading lala]


[endsect]

[section:implementation Appendix C: Implementation Notes]


[heading lala]


[endsect]
[section:acknowledgements Appendix D: Acknowledgements]

Thanks to Beman Dawes for opening the initial discussion. Daniel James for giving the idea of the alternative implementation and to Matt Calabrese for his inshighfull comments on the ML. This library will never be created without the exchanges they made on the ML (see [@http://boost.2283326.n4.nabble.com/Boost-Dev-f2600599.html here]).

[endsect]
[section  Appendix E: Tests]

[section scoped_enum_class]

[table Contructors and Assignement
    [[Name]                             [kind]      [Description]                                   [Result]]
]

[endsect]
[section scoped_enum_type]

[table Contructors and Assignement
    [[Name]                             [kind]      [Description]                                   [Result]]
]

[endsect]
[section scoped_enum_no_cons_class]

[table Contructors and Assignement
    [[Name]                             [kind]      [Description]                                   [Result]]
]

[endsect]
[section scoped_enum_no_cons_type]

[table Contructors and Assignement
    [[Name]                             [kind]      [Description]                                   [Result]]
]

[endsect]

[endsect]
[section  Appendix F: Tickets]

[endsect]

[/=====================================]
[section:todo  Appendix F: Future plans]
[/=====================================]

[heading Tasks to do before review]

* Complete the doc and the tests

[heading For later releases]

* Add first, last, next, prior, index functions.
* Add enum_array.
* Add enum_set.
* Conversion to and from strings.


[endsect]
[endsect]


