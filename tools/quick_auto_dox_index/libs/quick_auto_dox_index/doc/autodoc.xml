<?xml version="1.0" standalone="yes"?>
<library-reference id="quickbookdoxygenautoindex_reference"><title>QuickbookDoxygenAutoindex Reference</title><header name="boost/quick_auto_dox_index/detail/FP_compare.hpp"><para>Two types of floating-point comparison "Very close" and "Close enough" to a chosen tolerance. </para><para>Derived from Boost.Test Copyright Gennadiy Rozental 2001-2007. See <ulink url="http://www.boost.org/libs/test">http://www.boost.org/libs/test</ulink> for the Boost.Test library home page. Deliberately removed any treatment of percent to avoid further potential confusion! <para>Mar 2009 </para>
<para>Paul A. Bristow </para>
</para><class name="close_to"><template>
      <template-type-parameter name="FPT"><default>double</default><purpose><para>floating-point type.</para></purpose></template-type-parameter>
    </template><purpose>Test if two floating-point values are close within a chosen tolerance. </purpose><description><para>
Close can be one of two types of floating-point comparison "Very close" and "Close enough". equations in Dougles E. Knuth, Seminumerical algorithms (3rd Ed) section 4.2.4, Vol II, pp 213-225, Addison-Wesley, 1997, ISBN: 0201896842. Strong requires closeness relative to BOTH values begin compared, Weak only requires only closeness to EITHER ONE value. </para></description><method-group name="public member functions"><method name="operator()" cv="const"><type>bool</type><parameter name="left"><paramtype>FPT</paramtype></parameter><parameter name="right"><paramtype>FPT</paramtype></parameter><description><para>Test if two floating-point values are close within a chosen tolerance.</para><para>Tolerance can be interpreted as Knuth's "Very close" (equation 1), the default, or "Close enough" (equation 2). </para></description></method><method name="size" cv=""><type>FPT</type><description><para>
</para></description><returns><para>the chosen tolerance, as a <emphasis role="bold">fraction</emphasis> (not a percentage). </para></returns></method><method name="strength" cv=""><type>floating_point_comparison_type</type><description><para>
</para></description><returns><para>strength of comparison, Knuth's "Very close" (equation 1), the default, or "Close enough" (equation 2). </para></returns></method></method-group><constructor specifiers="explicit"><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name="tolerance"><paramtype>FPT</paramtype></parameter><parameter name="fpc_type"><paramtype>floating_point_comparison_type</paramtype><default>FPC_STRONG</default></parameter><purpose>Constructor for <classname alt="close_to">close_to</classname> from tolerance and strength. (By design, percent is NOT implemented). </purpose></constructor><constructor><description><para>Default is two epsilon for the FPT.<sbr/>
 Note that some user-defined floating-point types may not specialize std::numeric_limits&lt;FPT&gt;::epsilon() so it is convenient to use boost::math::tools::epsilon&lt;FPT&gt;(); instead.</para></description></constructor></class><class name="smallest"><template>
      <template-type-parameter name="FPT"><default>double</default><purpose><para>A floating-point type, float, double, long double or user-defined like NTL quad_float or RR. </para></purpose></template-type-parameter>
    </template><purpose>Check floating-point value is smaller than a chosen small value, default is twice min_value() for the floating-point type FPT. </purpose><description><para>It is somewhat common for beginners to add a comparison check to 0 before computing a division, in order to avoid possible division-by-zero exceptions or the generation of infinite results.<sbr/>
 A first objection to this practise is that, anyway, computing 1/x for x very close to zero will generate very large numbers that will most probably result in overflows later.<sbr/>
 Another objection, which few programmers know about and that we wish to draw attention to, is that it may actually fail to work, depending on what the compiler does, that is, the program may actually test that x == 0, then, further down, find that x = 0 without any apparent change to x!<sbr/>
 David Monniaux, <ulink url="http://arxiv.org/abs/cs/0701192v4.">http://arxiv.org/abs/cs/0701192v4.</ulink> 
</para></description><method-group name="public member functions"><method name="operator()" cv=""><type>bool</type><parameter name="fp_value"><paramtype>FPT</paramtype></parameter><parameter name="s"><paramtype>FPT</paramtype></parameter><description><para>True if value is smaller than a smallest value s. </para></description></method><method name="operator()" cv=""><type>bool</type><parameter name="fp_value"><paramtype>FPT</paramtype></parameter><description><para>True if value is smaller than chosen smallest value. </para></description></method><method name="size" cv=""><type>FPT</type><description><para>
</para></description><returns><para>chosen smallest value that will be counted as effectively zero. </para></returns></method></method-group><constructor specifiers="explicit"><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name="s"><paramtype>FPT</paramtype></parameter><description><para>Constructor with user defined value of smallest, for example 10 * min_value&lt;FPT&gt;. Note that some user-defined floating-point types may not specialize std::numeric_limits&lt;FPT&gt;::min_value() so it is convenient to use boost::math::tools::min_value&lt;FPT&gt;(); instead.</para></description></constructor><constructor><description><para>Default Constructor with smallest_ = 2. * boost::math::tools::min_value&lt;double&gt;();<sbr/>
 multiplier m = 2 (must be integer or static_cast&lt;FPT&gt;()) is chosen to allow for a few bits of computation error.<sbr/>
 Pessimistic multiplier is the number of arithmetic operations, assuming every operation causes a 1 least significant bit error, but a more realistic average might be half this.</para></description></constructor></class><typedef name="neareq"><purpose>Allow neareq as a shorthand for twice double epsilon = 4.44e-16. </purpose><description><para>Since double and the default <classname alt="close_to">close_to</classname> value 2 * epsilon = std::numeric_limits&lt;double&gt;::epsilon = 2 * 2.220446e-016 = 4.440892e-016 is a very common requirement, provide an convenience alias for this. </para></description><type><classname>close_to</classname>&lt; double &gt;</type></typedef><typedef name="tiny"><purpose>Allow tiny as a shorthand for twice the double min_value 4.45e-308. </purpose><description><para>Since double and the default smallest value 2 * std::numeric_limits&lt;double&gt;::min_value() = 2 * 2.22507e-308 + 4.45015e-308 is a very common requirement, provide an convenience alias for this. </para></description><type><classname>smallest</classname>&lt; double &gt;</type></typedef><function name="epsilon"><type>FPT</type><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name=""><paramtype>FPT</paramtype></parameter><purpose>epsilon for type T (about 1e-16 for double) </purpose></function><function name="fpt_abs"><type>FPT</type><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name="arg"><paramtype>FPT</paramtype></parameter><description><para>abs function (just in case abs is not defined for a user-defined FPT). </para></description></function><function name="max_value"><type>FPT</type><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name=""><paramtype>FPT</paramtype></parameter><purpose>maximum value for floating-point type T. </purpose></function><function name="min_value"><type>FPT</type><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name=""><paramtype>FPT</paramtype></parameter><purpose>minimum value for floating-point type T. </purpose></function><function name="safe_fpt_division"><type>FPT</type><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name="f1"><paramtype>FPT</paramtype></parameter><parameter name="f2"><paramtype>FPT</paramtype></parameter><description><para>Division safe from underflow and overflow. (Both f1 and f2 must be unsigned here). </para></description></function></header><header name="boost/quick_auto_dox_index/quick_auto_dox_index.hpp"><para>Template for documentation. </para><para>Example file for creating Boost documentation using Quickbook, Doxygen and Auto-Indexing. Example code with comment taken from /doxygen/html/docblocks.html using Boost naming conventions. <sbr/>
 The style of this example takes a lot of lines, so other Boost-style examples are much more compact. They do rely on syntax coloring to make the comments stand clear and not obscure the real C++ code.</para><para><para>Mar 2011 </para>
<para>Paul A. Bristow </para>
</para><class name="test"><purpose>A test class - a comment description that preceeds the class. </purpose><description><para>a class by comment that is tucked in under the class (to reduce the line count). BUT you must explicitly link to the class or it will be applied to the next member. Using a &lt; doesn't work for classes as it does for members. </para></description><enum name="test_enum"><enumvalue name="test_enum_val1"><purpose>Enum value TVal1 (Note the &lt; to link to the same line). </purpose></enumvalue><enumvalue name="test_enum_val2"><purpose>Enum value TVal2. (Using C++ // comment markers, and &lt; to link to the same line. </purpose></enumvalue><enumvalue name="test_enum_val3"><description><para>Enum value TVal3. (using C style comment markers). </para></description></enumvalue><purpose>Example of documenting an enum. </purpose><description><para>More detailed enum description. This description needs more than one line, so convenient to use C style comment markers. </para></description></enum><data-member name="handler"><type>int(*</type><purpose>A function variable. </purpose><description><para>Details about what the function does. <para>This is an implementation detail and not for user code. </para>


</para></description></data-member><data-member name="public_var"><type>int</type><purpose>A public variable. </purpose><description><para>Details about the variable. </para></description></data-member><method-group name="public member functions"><method name="test_me" cv=""><type>int</type><parameter name="a"><paramtype>int</paramtype><description><para>an integer argument. </para></description></parameter><parameter name="s"><paramtype>const char *</paramtype><description><para>a constant character pointer. </para></description></parameter><purpose>A normal member function taking two arguments and returning an integer value. </purpose><description><para>



<para><emphasis role="bold">See Also:</emphasis><para>Test(), ~Test(), testMeToo() and publicVar() </para></para>
</para></description><requires><para>No preconditions. </para></requires><postconditions><para>No side effects. </para></postconditions><returns><para>The test result. </para></returns></method><method name="test_me_too" cv=""><type>void</type><parameter name="c1"><paramtype>char</paramtype><description><para>the first argument. </para></description></parameter><parameter name="c2"><paramtype>char</paramtype><description><para>the second argument. </para></description></parameter><description><para>A pure virtual member with descriptions of parameters. And a 'see also' reference to another version of the function.</para><para><para><emphasis role="bold">See Also:</emphasis><para>test_me() </para></para>
<xrefsect id="deprecated_1_deprecated000001"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Will be removed in the next but one version. Use test_me() instead. </para></xrefdescription></xrefsect>

</para></description><returns><para>The test result. </para></returns></method></method-group><constructor><purpose>A constructor. </purpose><description><para>A more elaborate description of the constructor. </para></description></constructor><destructor><purpose>A destructor. </purpose><description><para>A more elaborate description of the destructor. 

<para>This descructor may blow up? </para>
</para></description><requires><para>No preconditions. </para></requires><postconditions><para>A test object constructed, with no side effects. </para></postconditions></destructor></class></header></library-reference>
