<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>VMD and Boost PP</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.0">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;The Variadic Macro Data Library 1.3">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;The Variadic Macro Data Library 1.3">
<link rel="prev" href="../VMD_PP_SEQ_TO_DATA.html" title="Macro VMD_PP_SEQ_TO_DATA">
<link rel="next" href="vmd_design.html" title="Design">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../VMD_PP_SEQ_TO_DATA.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="vmd_design.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="the_variadic_macro_data_library.vmd_comparison"></a><a class="link" href="vmd_comparison.html" title="VMD and Boost PP">VMD and
    Boost PP</a>
</h2></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="vmd_comparison.html#the_variadic_macro_data_library.vmd_comparison.vmd_comp_example">An
      example design</a></span></dt></dl></div>
<p>
      Boost PP already has the ability to pass variadic data as a single macro argument
      through any of its data types. It may then be reasonably asked why there is
      any need to use variadic macros to pass preprocessor data instead.
    </p>
<p>
      There are two considerations for using variadic macros:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          The syntax for using variadic macros is the more natural syntax for passing
          macro arguments. Providing a comma-separated list of data mimics the way
          macro arguments are usually passed.
        </li>
<li class="listitem">
          The length of the variadic data does not have to be passed. In Boost PP
          the length does not have to be passed for the sequences and lists, but
          it has to be specified as part of an array, and must be separately passed,
          or known in advance, for tuples. Functionality in this library, however,
          alleviates this last requirement for tuples.
        </li>
</ol></div>
<p>
      On the other hand there are considerations for using Boost PP data types for
      passing variadic data to macros:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          Boost PP data types can be passed multiple times in any macro whereas variadic
          macros can only pass its variadic macro data a single time as the final
          set of arguments to a macro.
        </li>
<li class="listitem">
          Boost PP data types, which are single macro arguments, fit in well with
          Boost PP functionality.
        </li>
<li class="listitem">
          Boost PP data types have a rich set of functionality for manipulating the
          data in the data type.
        </li>
</ol></div>
<p>
      The more natural syntax of variadic macro data still provides enough importance,
      from the end-user's point of view, for using this library's facilities. A macro
      writer can design macros for the end-user which take variadic data using variadic
      macros while internally using Boost PP data types to manipulate that data and
      pass that data to other Boost PP macros. This library provides functionality
      to do just that with its macros which convert from variadic macro data to Boost
      PP data types.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="the_variadic_macro_data_library.vmd_comparison.vmd_comp_example"></a><a class="link" href="vmd_comparison.html#the_variadic_macro_data_library.vmd_comparison.vmd_comp_example" title="An example design">An
      example design</a>
</h3></div></div></div>
<p>
        We will design a macro for end-users which takes variadic data as its argument.
        Let's call this macro, just as an example, ENDUSER_MACRO.
      </p>
<p>
        Without variadic macro support, but in keeping with Boost PP, the best way
        of designing this macro is probably to use a Boost PP sequence. Our design
        of the macro might look like this:
      </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">ENDUSER_MACRO</span><span class="special">(</span><span class="identifier">ppSequence</span><span class="special">)</span> <span class="identifier">ENDUSER_DETAIL_MACRO</span><span class="special">(</span><span class="identifier">ppSequence</span><span class="special">)</span>
</pre>
<p>
        The reason for calling another macro which does the actual work of expansion
        will be explained below when discussing how to design this macro using VMD.
      </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">ENDUSER_DETAIL_MACRO</span><span class="special">(</span><span class="identifier">ppSequence</span><span class="special">)</span> <span class="special">\</span>
<span class="comment">/* expansion which manipulates the data
  using the Boost PP facilities for a sequence.
  In Boost PP one can find out the size of the 
  sequence, extract any token from the sequence, 
  and much more...
*/</span>
</pre>
<p>
        The end-user would pass data to this macro in this way:
      </p>
<pre class="programlisting"><span class="identifier">ENDUSER_MACRO</span><span class="special">((</span><span class="identifier">a</span><span class="special">)(</span><span class="identifier">b</span><span class="special">)(</span><span class="identifier">c</span><span class="special">)(</span><span class="identifier">d</span><span class="special">)(</span><span class="identifier">e</span><span class="special">))</span> <span class="comment">// etc. with each "token" in the sequence surrounded by ()
</span></pre>
<p>
        That is certainly acceptable, and without variadic macros, it is certainly
        excellent to have the Boost PP functionality that allows us to design macros
        taking variadic data and manipulate that data using the functionality of
        Boost PP.
      </p>
<p>
        With variadic macro support and VMD, but wishing to use our variadic data
        in exactly the same way as above, we could design our macro like this:
      </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">ENDUSER_MACRO</span><span class="special">(...)</span> <span class="identifier">ENDUSER_DETAIL_MACRO</span><span class="special">(</span><span class="identifier">VMD_DATA_TO_PP_SEQ</span><span class="special">(</span><span class="identifier">__VA_ARGS__</span><span class="special">))</span>
</pre>
<p>
        Here we again call the macro which does the actual work. This is the reason
        why I designed my version of the macro without variadic macro support in
        the way that I did.
      </p>
<p>
        The end-user would pass data to this macro in this way:
      </p>
<pre class="programlisting"><span class="identifier">ENDUSER_MACRO</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span><span class="identifier">b</span><span class="special">,</span><span class="identifier">c</span><span class="special">,</span><span class="identifier">d</span><span class="special">,</span><span class="identifier">e</span><span class="special">)</span> <span class="comment">// etc. with each token being somma-separated from each other 
</span></pre>
<p>
        I think this last way of passing variadic data is more natural to an end-user
        than using a Boost PP sequence directly, but of course it depends on having
        compiler variadic macro support.
      </p>
<p>
        One decision to be made is whether to support, for any given variadic data
        macro functionality, a single macro or two macros with slightly different
        names.
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Single macro design: <p>In our example, if we wish to support a single macro,
            for compilers that both support or do not support variadic macros, the
            code would be:</p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#if</span> <span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_NO_VARIADIC_MACROS</span><span class="special">)</span>
  <span class="preprocessor">#define</span> <span class="identifier">ENDUSER_MACRO</span><span class="special">(</span><span class="identifier">ppSequence</span><span class="special">)</span> <span class="identifier">ENDUSER_DETAIL_MACRO</span><span class="special">(</span><span class="identifier">ppSequence</span><span class="special">)</span>
<span class="preprocessor">#else</span>
  <span class="preprocessor">#define</span> <span class="identifier">ENDUSER_MACRO</span><span class="special">(...)</span> <span class="identifier">ENDUSER_DETAIL_MACRO</span><span class="special">(</span><span class="identifier">VMD_DATA_TO_PP_SEQ</span><span class="special">(</span><span class="identifier">__VA_ARGS__</span><span class="special">))</span>
<span class="preprocessor">#endif</span>  
</pre>
<p>
            </p>
<p>We would now have a single macro which would be used slightly differently
            by the end-user depending on whether the compiler being used supported
            variadic macros or not. This might not be best if the end-user's code
            needed to work for different compilers, some of which support variadic
            macros and some of which do not. In that latter case, a dual macro design
            ( see below ) might be better.</p>
<p>Another solution supporting a single macro
            is to just ignore variadic macros, and then our solution would be:</p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">ENDUSER_MACRO</span><span class="special">(</span><span class="identifier">ppSequence</span><span class="special">)</span> <span class="identifier">ENDUSER_DETAIL_MACRO</span><span class="special">(</span><span class="identifier">ppSequence</span><span class="special">)</span>
</pre>
<p>
            </p>
<p>We could also ignore any compilers which do not support variadic macros,
            and then our solution would be:</p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#if</span> <span class="special">!</span><span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_NO_VARIADIC_MACROS</span><span class="special">)</span>
  <span class="preprocessor">#define</span> <span class="identifier">ENDUSER_MACRO</span><span class="special">(...)</span> <span class="identifier">ENDUSER_DETAIL_MACRO</span><span class="special">(</span><span class="identifier">VMD_DATA_TO_PP_SEQ</span><span class="special">(</span><span class="identifier">__VA_ARGS__</span><span class="special">))</span>
<span class="preprocessor">#endif</span>
</pre>
<p>
            </p>

          </li>
<li class="listitem">
            Dual macro design: <p>Perhaps best is to provide two macros with slightly
            different names. Our solution would then be:</p>
<p>
</p>
<pre class="programlisting">  <span class="preprocessor">#define</span> <span class="identifier">ENDUSER_MACRO</span><span class="special">(</span><span class="identifier">ppSequence</span><span class="special">)</span> <span class="identifier">ENDUSER_DETAIL_MACRO</span><span class="special">(</span><span class="identifier">ppSequence</span><span class="special">)</span>
<span class="preprocessor">#if</span> <span class="special">!</span><span class="identifier">defined</span><span class="special">(</span><span class="identifier">BOOST_NO_VARIADIC_MACROS</span><span class="special">)</span>
  <span class="preprocessor">#define</span> <span class="identifier">ENDUSER_MACRO_VM</span><span class="special">(...)</span> <span class="identifier">ENDUSER_DETAIL_MACRO</span><span class="special">(</span><span class="identifier">VMD_DATA_TO_PP_SEQ</span><span class="special">(</span><span class="identifier">__VA_ARGS__</span><span class="special">))</span>
<span class="preprocessor">#endif</span>
</pre>
<p>
            </p>
<p>Here I have attached an '_VM' to the name of the macro which supports
            variadic macros.</p>

          </li>
</ol></div>
<p>
        In an ideal world, once the new C++ standard is ratified, all compilers will
        support variadic macros, and then we can design a single macro which takes
        variadic macro data.
      </p>
<p>
        Of course using variadic macro data works smoothly if there is only a single
        set of variadic data which a macro needs. If there is more than one set of
        variadic data, then we can consider using a combination of Boost PP variadic
        data functionality and variadic macro data. This is because variadic macro
        data can only be specified once for a variadic macro and must be the last
        parameter in the variadic macro.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2010 Tropic Software East Inc</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../VMD_PP_SEQ_TO_DATA.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="vmd_design.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
