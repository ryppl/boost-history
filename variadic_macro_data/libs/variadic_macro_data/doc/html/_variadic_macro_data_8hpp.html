<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VariadicMacroData: VariadicMacroData.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<h1>VariadicMacroData.hpp File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &lt;boost/config.hpp&gt;</code><br/>
<code>#include &lt;boost/preprocessor/array/data.hpp&gt;</code><br/>
<code>#include &lt;boost/preprocessor/list/to_tuple.hpp&gt;</code><br/>
<code>#include &lt;boost/preprocessor/seq/to_tuple.hpp&gt;</code><br/>
<code>#include &lt;boost/preprocessor/tuple/rem.hpp&gt;</code><br/>
<code>#include &lt;boost/preprocessor/tuple/eat.hpp&gt;</code><br/>
<code>#include &lt;boost/preprocessor/repetition/repeat.hpp&gt;</code><br/>
<code>#include &quot;detail/VMDDetail.hpp&quot;</code><br/>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a9c702f476a06a6e25e168dba9e5f169b">VMD_DATA_SIZE</a>(...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to the number of comma-separated variable macro data arguments.  <a href="#a9c702f476a06a6e25e168dba9e5f169b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#afc59f250855d3174c9f5ecbdaa1b7027">VMD_DATA_ELEMENT</a>(n,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to a particular variable macro data argument.  <a href="#afc59f250855d3174c9f5ecbdaa1b7027"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a2fcd6f5b228bb3379c09457d3feed5dd">VMD_DATA_TO_PP_TUPLE</a>(...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expand to a Boost PP tuple data type.  <a href="#a2fcd6f5b228bb3379c09457d3feed5dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a23099c5dda37ba7353ecdeb47a039aec">VMD_DATA_TO_PP_ARRAY</a>(...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expand to a Boost PP array data type.  <a href="#a23099c5dda37ba7353ecdeb47a039aec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a5fd1cf8739e03f835d574488d66859cb">VMD_DATA_TO_PP_LIST</a>(...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expand to a Boost PP list data type.  <a href="#a5fd1cf8739e03f835d574488d66859cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a35a2eea2abbbec359621d93ed498f499">VMD_DATA_TO_PP_SEQ</a>(...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expand to a Boost PP sequence data type.  <a href="#a35a2eea2abbbec359621d93ed498f499"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a142becd2891042b870cdc32adda0d0b5">VMD_PP_TUPLE_SIZE</a>(tuple)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to the number of elements in a tuple.  <a href="#a142becd2891042b870cdc32adda0d0b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a5c645fee7591a40aa173b7dd989c758f">VMD_PP_TUPLE_ELEM</a>(n, tuple)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to a particular tuple element.  <a href="#a5c645fee7591a40aa173b7dd989c758f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a112de8b9571ff160beab7e9d1e66a011">VMD_PP_TUPLE_EAT</a>(size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to a macro that eats a tuple of the specified size.  <a href="#a112de8b9571ff160beab7e9d1e66a011"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a1facbd95654768f329db54b76f009b40">VMD_PP_TUPLE_REM</a>(size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to a macro that removes the parentheses from a tuple of the specified size.  <a href="#a1facbd95654768f329db54b76f009b40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a0e31d2b35fa81c051b83bc6b9556b36e">VMD_PP_TUPLE_REM_CTOR</a>(tuple)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to a series of tokens which are equivalent to removing the parentheses from a tuple.  <a href="#a0e31d2b35fa81c051b83bc6b9556b36e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a8c81c6e964c9fb60b850c6cb1f71382d">VMD_PP_TUPLE_REVERSE</a>(tuple)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to a tuple whose elements are in reversed order.  <a href="#a8c81c6e964c9fb60b850c6cb1f71382d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#ab4f99fd1f6008a036db7fc9b92583e38">VMD_PP_TUPLE_TO_LIST</a>(tuple)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to a list whose elements are the same as a tuple.  <a href="#ab4f99fd1f6008a036db7fc9b92583e38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a1399f161c3a47bb2d39b49e9b4c9432b">VMD_PP_TUPLE_TO_SEQ</a>(tuple)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to a sequence whose elements are the same as a tuple.  <a href="#a1399f161c3a47bb2d39b49e9b4c9432b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a0c3a5919752a07022f036d31a6cf8342">VMD_PP_TUPLE_TO_DATA</a>(tuple)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to variable macro data whose arguments are the same as a tuple's elements.  <a href="#a0c3a5919752a07022f036d31a6cf8342"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#aa7cd1ea1b6acc0bc2925524118856196">VMD_PP_ARRAY_TO_DATA</a>(array)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to variable macro data whose arguments are the same as an array's elements.  <a href="#aa7cd1ea1b6acc0bc2925524118856196"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a5643216d29dabbeb24176f1c2cff68a4">VMD_PP_LIST_TO_DATA</a>(list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to variable macro data whose arguments are the same as a list's elements.  <a href="#a5643216d29dabbeb24176f1c2cff68a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a0701b18f9f3852515cd9710b77b41879">VMD_PP_SEQ_TO_DATA</a>(seq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands to variable macro data whose arguments are the same as a sequence's elements.  <a href="#a0701b18f9f3852515cd9710b77b41879"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#a475143272d92866fdc88cfcff2c7d8cf">VMD_PP_REPEAT</a>(count, macro, data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A replacement macro for BOOST_PP_REPEAT where count is calculated.  <a href="#a475143272d92866fdc88cfcff2c7d8cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_variadic_macro_data_8hpp.html#aaa1566ca3ab8c1240be3b4a70825f470">VMD_PP_REPEAT_TUPLE</a>(macro, tuple)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A replacement macro for BOOST_PP_REPEAT where count is the tuple data size.  <a href="#aaa1566ca3ab8c1240be3b4a70825f470"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The term 'Boost PP library' in this dopcumentation is shorthand for the Boost preprocessor library.</p>
<p>The macros provide support for variadic macro usage as well as integrating variadic macros with the Boost PP library without changing anything in the Boost PP library in any way. The latter is done by providing means of converting variadic macro data to Boost PP data types and by providing means of converting Boost PP data types back to variadic macro data.</p>
<p>The macros will only work for compilers in which the Boost configuration macro, BOOST_NO_VARIADIC_MACROS, is not defined.</p>
<p>Currently All of the macros in this library begin with the prefix of VMD_. If this library were accepted as a Boost library, the macros could be changed to start with a prefix of BOOST_VMD_ .</p>
<p>The word DATA in the name of some of the macros refers to variadic macro data, as represented by '...' when passed as the final parameter of a variadic macro and as __VA_ARGS__ when expanded by the variadic macro definition.</p>
<p>The words TUPLE, ARRAY, LIST, and SEQ in the name of some of the macros refer to the Boost PP library data types of tuples, arrays, lists, and sequences respectively. All mention in the comments of tuples, arrays, lists, and sequences refer to the Boost PP library definitions of these data types.</p>
<p>The macros can be divided into these groups of functionality:</p>
<ul>
<li>Macros which directly support variadic macro data processing.<ul>
<li>VMD_DATA_SIZE(...)</li>
<li>VMD_DATA_ELEMENT(n,...)</li>
</ul>
</li>
<li>Macros which convert variadic macro data to Boost PP data types.<ul>
<li>VMD_DATA_TO_PP_TUPLE(...)</li>
<li>VMD_DATA_TO_PP_ARRAY(...)</li>
<li>VMD_DATA_TO_PP_LIST(...)</li>
<li>VMD_DATA_TO_PP_SEQ(...)</li>
</ul>
</li>
<li>Macros which convert Boost PP data types to variadic macro data.<ul>
<li><a class="el" href="_variadic_macro_data_8hpp.html#a0c3a5919752a07022f036d31a6cf8342" title="Expands to variable macro data whose arguments are the same as a tuple&#39;s elements.">VMD_PP_TUPLE_TO_DATA(tuple)</a></li>
<li><a class="el" href="_variadic_macro_data_8hpp.html#aa7cd1ea1b6acc0bc2925524118856196" title="Expands to variable macro data whose arguments are the same as an array&#39;s elements.">VMD_PP_ARRAY_TO_DATA(array)</a></li>
<li><a class="el" href="_variadic_macro_data_8hpp.html#a5643216d29dabbeb24176f1c2cff68a4" title="Expands to variable macro data whose arguments are the same as a list&#39;s elements.">VMD_PP_LIST_TO_DATA(list)</a></li>
<li><a class="el" href="_variadic_macro_data_8hpp.html#a0701b18f9f3852515cd9710b77b41879" title="Expands to variable macro data whose arguments are the same as a sequence&#39;s elements.">VMD_PP_SEQ_TO_DATA(seq)</a></li>
</ul>
</li>
<li>Macros which ease the use of the Boost PP tuple data type by not requiring that a tuple size be passed.<ul>
<li><a class="el" href="_variadic_macro_data_8hpp.html#a142becd2891042b870cdc32adda0d0b5" title="Expands to the number of elements in a tuple.">VMD_PP_TUPLE_SIZE(tuple)</a></li>
<li><a class="el" href="_variadic_macro_data_8hpp.html#a5c645fee7591a40aa173b7dd989c758f" title="Expands to a particular tuple element.">VMD_PP_TUPLE_ELEM(n,tuple)</a></li>
<li><a class="el" href="_variadic_macro_data_8hpp.html#a8c81c6e964c9fb60b850c6cb1f71382d" title="Expands to a tuple whose elements are in reversed order.">VMD_PP_TUPLE_REVERSE(tuple)</a></li>
<li><a class="el" href="_variadic_macro_data_8hpp.html#ab4f99fd1f6008a036db7fc9b92583e38" title="Expands to a list whose elements are the same as a tuple.">VMD_PP_TUPLE_TO_LIST(tuple)</a></li>
<li><a class="el" href="_variadic_macro_data_8hpp.html#a1399f161c3a47bb2d39b49e9b4c9432b" title="Expands to a sequence whose elements are the same as a tuple.">VMD_PP_TUPLE_TO_SEQ(tuple)</a></li>
<li><a class="el" href="_variadic_macro_data_8hpp.html#aaa1566ca3ab8c1240be3b4a70825f470" title="A replacement macro for BOOST_PP_REPEAT where count is the tuple data size.">VMD_PP_REPEAT_TUPLE(macro,tuple)</a></li>
</ul>
</li>
<li>Macros which allow the Boost PP macro functionality to be used when the 'count' or 'size' parameter is calculated from .._SIZE macros in this library and one is using Microsoft's Visual C++.<ul>
<li><a class="el" href="_variadic_macro_data_8hpp.html#a112de8b9571ff160beab7e9d1e66a011" title="Expands to a macro that eats a tuple of the specified size.">VMD_PP_TUPLE_EAT(size)</a></li>
<li><a class="el" href="_variadic_macro_data_8hpp.html#a1facbd95654768f329db54b76f009b40" title="Expands to a macro that removes the parentheses from a tuple of the specified size.">VMD_PP_TUPLE_REM(size)</a></li>
<li><a class="el" href="_variadic_macro_data_8hpp.html#a475143272d92866fdc88cfcff2c7d8cf" title="A replacement macro for BOOST_PP_REPEAT where count is calculated.">VMD_PP_REPEAT(count,macro,data)</a> </li>
</ul>
</li>
</ul>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a9c702f476a06a6e25e168dba9e5f169b"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_DATA_SIZE" ref="a9c702f476a06a6e25e168dba9e5f169b" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_DATA_SIZE</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to the number of comma-separated variable macro data arguments. </p>
<p>... = variable macro data.</p>
<p>returns = the number of comma-separated variable macro data arguments being passed to it.</p>
<p>The value returned can be between 1 and 64.</p>
<p>When using the results of this macro as the first parameter to BOOST_PP_REPEAT, whether using the result directly or in a Boost PP library calculation, use the macro VMD_PP_REPEAT instead. </p>

</div>
</div>
<a class="anchor" id="afc59f250855d3174c9f5ecbdaa1b7027"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_DATA_ELEMENT" ref="afc59f250855d3174c9f5ecbdaa1b7027" args="(n,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_DATA_ELEMENT</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to a particular variable macro data argument. </p>
<p>n = number of the variable macro data argument. The number starts from 0 to the number of variable macro data arguments - 1.</p>
<p>... = variable macro data.</p>
<p>returns = the particular macro data argument as specified by n. The argument returned can be any valid preprocessing token. </p>

</div>
</div>
<a class="anchor" id="a2fcd6f5b228bb3379c09457d3feed5dd"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_DATA_TO_PP_TUPLE" ref="a2fcd6f5b228bb3379c09457d3feed5dd" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_DATA_TO_PP_TUPLE</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand to a Boost PP tuple data type. </p>
<p>... = variable macro data.</p>
<p>returns = a Boost PP library tuple data type.</p>
<p>You can use the result of this macro whenever you need to pass a Boost PP library tuple as data to a Boost PP library macro. </p>

</div>
</div>
<a class="anchor" id="a23099c5dda37ba7353ecdeb47a039aec"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_DATA_TO_PP_ARRAY" ref="a23099c5dda37ba7353ecdeb47a039aec" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_DATA_TO_PP_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand to a Boost PP array data type. </p>
<p>... = variable macro data.</p>
<p>returns = a Boost PP library array data type.</p>
<p>You can use the result of this macro whenever you need to pass a Boost PP library array as data to a Boost PP library macro. </p>

</div>
</div>
<a class="anchor" id="a5fd1cf8739e03f835d574488d66859cb"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_DATA_TO_PP_LIST" ref="a5fd1cf8739e03f835d574488d66859cb" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_DATA_TO_PP_LIST</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand to a Boost PP list data type. </p>
<p>... = variable macro data.</p>
<p>returns = a Boost PP library list data type.</p>
<p>You can use the result of this macro whenever you need to pass a Boost PP library list as data to a Boost PP library macro. </p>

</div>
</div>
<a class="anchor" id="a35a2eea2abbbec359621d93ed498f499"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_DATA_TO_PP_SEQ" ref="a35a2eea2abbbec359621d93ed498f499" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_DATA_TO_PP_SEQ</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand to a Boost PP sequence data type. </p>
<p>... = variable macro data.</p>
<p>returns = a Boost PP library sequence data type.</p>
<p>You can use the result of this macro whenever you need to pass a Boost PP library sequence as data to a Boost PP library macro. </p>

</div>
</div>
<a class="anchor" id="a142becd2891042b870cdc32adda0d0b5"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_TUPLE_SIZE" ref="a142becd2891042b870cdc32adda0d0b5" args="(tuple)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_TUPLE_SIZE</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">tuple</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to the number of elements in a tuple. </p>
<p>tuple = a Boost PP library tuple data type.</p>
<p>returns = the number of elements in the tuple, commonly referred to as the tuple size.</p>
<p>In the Boost PP library there is no way to calculate the size of a tuple, so that the size must be known in order to be used by Boost PP library tuple macros. With variadic macros the size of a tuple can be calculated from the tuple itself.</p>
<p>When using the results of this macro as the first parameter to BOOST_PP_REPEAT, whether using the result directly or in a Boost PP library calculation, use the macro VMD_PP_REPEAT instead.</p>
<p>If you need to call BOOST_PP_REPEAT with the first parameter being exactly the tuple size, you can more easily use VMD_PP_REPEAT_TUPLE instead. </p>

</div>
</div>
<a class="anchor" id="a5c645fee7591a40aa173b7dd989c758f"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_TUPLE_ELEM" ref="a5c645fee7591a40aa173b7dd989c758f" args="(n, tuple)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_TUPLE_ELEM</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">tuple</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to a particular tuple element. </p>
<p>n = number of the tuple element. The number starts from 0 to the size of the tuple - 1.</p>
<p>tuple = a Boost PP library tuple data type.</p>
<p>returns = the particular tuple element as specified by n.</p>
<p>In the Boost PP library there is no way to calculate the size of a tuple, so that the size must be known in order to be used by Boost PP library tuple macros. With variadic macros the size of a tuple can be calculated from the tuple itself.</p>
<p>Therefore this macro is a replacement for the BOOST_PP_TUPLE_ELEM macro without the necessity of having to pass a size. </p>

</div>
</div>
<a class="anchor" id="a112de8b9571ff160beab7e9d1e66a011"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_TUPLE_EAT" ref="a112de8b9571ff160beab7e9d1e66a011" args="(size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_TUPLE_EAT</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">size</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to a macro that eats a tuple of the specified size. </p>
<p>size = the number of elements in the subsequent tuple.</p>
<p>returns = a macro which eats a subsequent tuple. This means that when applied to the subsequent tuple the returned macro expands to nothing.</p>
<p>For Microsoft's Visual C++ this macro is a replacement for BOOST_PP_TUPLE_EAT when the count parameter is calculated with either VMD_DATA_SIZE(...) or <a class="el" href="_variadic_macro_data_8hpp.html#a142becd2891042b870cdc32adda0d0b5" title="Expands to the number of elements in a tuple.">VMD_PP_TUPLE_SIZE(tuple)</a>. In that case BOOST_PP_TUPLE_EAT will not expand properly but using this macro, which delays the call to BOOST_PP_TUPLE_REM until the VMD_DATA_SIZE(...) or <a class="el" href="_variadic_macro_data_8hpp.html#a142becd2891042b870cdc32adda0d0b5" title="Expands to the number of elements in a tuple.">VMD_PP_TUPLE_SIZE(tuple)</a> are fully expanded, does work properly.</p>
<p>Other compilers can use BOOST_PP_TUPLE_EAT directly, but this macro will also work. </p>

</div>
</div>
<a class="anchor" id="a1facbd95654768f329db54b76f009b40"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_TUPLE_REM" ref="a1facbd95654768f329db54b76f009b40" args="(size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_TUPLE_REM</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">size</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to a macro that removes the parentheses from a tuple of the specified size. </p>
<p>size = the number of elements in the subsequent tuple.</p>
<p>returns = a macro which can remove the parentheses from a subsequent tuple.</p>
<p>For Microsoft's Visual C++ this macro is a replacement for BOOST_PP_TUPLE_REM when the count parameter is calculated with either VMD_DATA_SIZE(...) or <a class="el" href="_variadic_macro_data_8hpp.html#a142becd2891042b870cdc32adda0d0b5" title="Expands to the number of elements in a tuple.">VMD_PP_TUPLE_SIZE(tuple)</a>. In that case BOOST_PP_TUPLE_REM will not expand properly but using this macro, which delays the call to BOOST_PP_TUPLE_REM until the VMD_DATA_SIZE(...) or <a class="el" href="_variadic_macro_data_8hpp.html#a142becd2891042b870cdc32adda0d0b5" title="Expands to the number of elements in a tuple.">VMD_PP_TUPLE_SIZE(tuple)</a> are fully expanded, does work properly.</p>
<p>Other compilers can use BOOST_PP_TUPLE_REM directly but this macro will also work. </p>

</div>
</div>
<a class="anchor" id="a0e31d2b35fa81c051b83bc6b9556b36e"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_TUPLE_REM_CTOR" ref="a0e31d2b35fa81c051b83bc6b9556b36e" args="(tuple)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_TUPLE_REM_CTOR</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">tuple</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to a series of tokens which are equivalent to removing the parentheses from a tuple. </p>
<p>tuple = a Boost PP library tuple data type.</p>
<p>returns = a series of comma-separated tokens equivalent to removing the parentheses from a tuple.</p>
<p>This result is actually equivalent to the form of variadic macro data and can be used as an alternative to VMD_PP_TUPLE_TO_DATA to convert the tuple to variadic macro data.</p>
<p>In the Boost PP library there is no way to calculate the size of a tuple, so that the size must be known in order to be used by Boost PP library tuple macros. With variadic macros the size of a tuple can be calculated from the tuple itself.</p>
<p>Therefore this macro is a replacement for the BOOST_PP_TUPLE_REM_CTOR macro without the necessity of having to pass a size. </p>

</div>
</div>
<a class="anchor" id="a8c81c6e964c9fb60b850c6cb1f71382d"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_TUPLE_REVERSE" ref="a8c81c6e964c9fb60b850c6cb1f71382d" args="(tuple)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_TUPLE_REVERSE</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">tuple</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to a tuple whose elements are in reversed order. </p>
<p>tuple = a Boost PP library tuple data type.</p>
<p>returns = a tuple whose elements are in reversed order from the original tuple.</p>
<p>In the Boost PP library there is no way to calculate the size of a tuple, so that the size must be known in order to be used by Boost PP library tuple macros. With variadic macros the size of a tuple can be calculated from the tuple itself.</p>
<p>Therefore this macro is a replacement for the BOOST_PP_TUPLE_REVERSE macro without the necessity of having to pass a size. </p>

</div>
</div>
<a class="anchor" id="ab4f99fd1f6008a036db7fc9b92583e38"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_TUPLE_TO_LIST" ref="ab4f99fd1f6008a036db7fc9b92583e38" args="(tuple)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_TUPLE_TO_LIST</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">tuple</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to a list whose elements are the same as a tuple. </p>
<p>tuple = a Boost PP library tuple data type.</p>
<p>returns = a list whose elements are the same as the tuple that is inputted.</p>
<p>In the Boost PP library there is no way to calculate the size of a tuple, so that the size must be known in order to be used by Boost PP library tuple macros. With variadic macros the size of a tuple can be calculated from the tuple itself.</p>
<p>Therefore this macro is a replacement for the BOOST_PP_TUPLE_TO_LIST macro without the necessity of having to pass a size. </p>

</div>
</div>
<a class="anchor" id="a1399f161c3a47bb2d39b49e9b4c9432b"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_TUPLE_TO_SEQ" ref="a1399f161c3a47bb2d39b49e9b4c9432b" args="(tuple)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_TUPLE_TO_SEQ</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">tuple</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to a sequence whose elements are the same as a tuple. </p>
<p>tuple = a Boost PP library tuple data type.</p>
<p>returns = a sequence whose elements are the same as the tuple that is inputted.</p>
<p>In the Boost PP library there is no way to calculate the size of a tuple, so that the size must be known in order to be used by Boost PP library tuple macros. With variadic macros the size of a tuple can be calculated from the tuple itself.</p>
<p>Therefore this macro is a replacement for the BOOST_PP_TUPLE_TO_SEQ macro without the necessity of having to pass a size. </p>

</div>
</div>
<a class="anchor" id="a0c3a5919752a07022f036d31a6cf8342"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_TUPLE_TO_DATA" ref="a0c3a5919752a07022f036d31a6cf8342" args="(tuple)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_TUPLE_TO_DATA</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">tuple</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to variable macro data whose arguments are the same as a tuple's elements. </p>
<p>tuple = a Boost PP library tuple data type.</p>
<p>returns = variable macro data whose arguments are the same as the elements of a tuple that is inputted.</p>
<p>The variable macro data that is returned is in the form of of comma separated arguments. The variable macro data can be passed to any macro which takes variable macro data in the form of a final variable macro data '...' macro parameter. </p>

</div>
</div>
<a class="anchor" id="aa7cd1ea1b6acc0bc2925524118856196"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_ARRAY_TO_DATA" ref="aa7cd1ea1b6acc0bc2925524118856196" args="(array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_ARRAY_TO_DATA</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">array</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to variable macro data whose arguments are the same as an array's elements. </p>
<p>array = a Boost PP library array data type.</p>
<p>returns = variable macro data whose arguments are the same as the elements of an array that is inputted.</p>
<p>The variable macro data that is returned is in the form of of comma separated arguments. The variable macro data can be passed to any macro which takes variable macro data in the form of a final variable macro data '...' macro parameter. </p>

</div>
</div>
<a class="anchor" id="a5643216d29dabbeb24176f1c2cff68a4"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_LIST_TO_DATA" ref="a5643216d29dabbeb24176f1c2cff68a4" args="(list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_LIST_TO_DATA</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">list</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to variable macro data whose arguments are the same as a list's elements. </p>
<p>list = a Boost PP library list data type.</p>
<p>returns = variable macro data whose arguments are the same as the elements of a list that is inputted.</p>
<p>The variable macro data that is returned is in the form of of comma separated arguments. The variable macro data can be passed to any macro which takes variable macro data in the form of a final variable macro data '...' macro parameter. </p>

</div>
</div>
<a class="anchor" id="a0701b18f9f3852515cd9710b77b41879"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_SEQ_TO_DATA" ref="a0701b18f9f3852515cd9710b77b41879" args="(seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_SEQ_TO_DATA</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">seq</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to variable macro data whose arguments are the same as a sequence's elements. </p>
<p>seq = a Boost PP library sequence data type.</p>
<p>returns = variable macro data whose arguments are the same as the elements of a sequence that is inputted.</p>
<p>The variable macro data that is returned is in the form of of comma separated arguments. The variable macro data can be passed to any macro which takes variable macro data in the form of a final variable macro data '...' macro parameter. </p>

</div>
</div>
<a class="anchor" id="a475143272d92866fdc88cfcff2c7d8cf"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_REPEAT" ref="a475143272d92866fdc88cfcff2c7d8cf" args="(count, macro, data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_REPEAT</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">macro, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">data</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A replacement macro for BOOST_PP_REPEAT where count is calculated. </p>
<p>count = The number of repetitious calls to macro. Valid values range from 0 to BOOST_PP_LIMIT_REPEAT.</p>
<p>macro = A ternary operation of the form macro(z, n, data). This macro is expanded by BOOST_PP_REPEAT with the next available repetition depth, the current repetition number, and the auxiliary data argument.</p>
<p>data = Auxiliary data passed to macro.</p>
<p>returns = The macro expands to the sequence: macro(z, 0, data) macro(z, 1, data) ... macro(z, count - 1, data). See BOOST_PP_REPEAT for further explanation.</p>
<p>For Microsoft's Visual C++ this macro is a replacement for BOOST_PP_REPEAT when the count parameter is calculated with either VMD_DATA_SIZE(...) or <a class="el" href="_variadic_macro_data_8hpp.html#a142becd2891042b870cdc32adda0d0b5" title="Expands to the number of elements in a tuple.">VMD_PP_TUPLE_SIZE(tuple)</a>. In that case BOOST_PP_REPEAT will not expand properly but using this macro, which delays the call to BOOST_PP_REPEAT until the VMD_DATA_SIZE(...) or <a class="el" href="_variadic_macro_data_8hpp.html#a142becd2891042b870cdc32adda0d0b5" title="Expands to the number of elements in a tuple.">VMD_PP_TUPLE_SIZE(tuple)</a> are fully expanded, does work properly.</p>
<p>Other compilers can use BOOST_PP_REPEAT directly but this macro will also work. </p>

</div>
</div>
<a class="anchor" id="aaa1566ca3ab8c1240be3b4a70825f470"></a><!-- doxytag: member="VariadicMacroData.hpp::VMD_PP_REPEAT_TUPLE" ref="aaa1566ca3ab8c1240be3b4a70825f470" args="(macro, tuple)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMD_PP_REPEAT_TUPLE</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">macro, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">tuple</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A replacement macro for BOOST_PP_REPEAT where count is the tuple data size. </p>
<p>macro = A ternary operation of the form macro(z, n, data). This macro is expanded by BOOST_PP_REPEAT with the next available repetition depth, the current repetition number, and the auxiliary data argument.</p>
<p>tuple = Auxiliary data, which must be a tuple, passed to macro.</p>
<p>returns = The macro expands to the sequence: macro(z, 0, tuple) macro(z, 1, tuple) ... macro(z, tuple size - 1, tuple). See BOOST_PP_REPEAT for further explanation.</p>
<p>This macro is a replacement for BOOST_PP_REPEAT when the count parameter is exactly the size of the tuple data.</p>
<p>For the other Boost PP data types, the size of the data type is directly accessible through functionality in the Boost PP library, so there is no problem calling BOOST_PP_REPEAT directly with that size as the first parameter. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
