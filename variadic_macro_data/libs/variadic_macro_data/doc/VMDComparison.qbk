[section:vmd_comparison VMD and Boost PP]

Boost PP already has the ability to pass variadic data
as a single macro argument through any of its data types. 
It may then be reasonably asked why there is any need to 
use variadic macros to pass preprocessor data instead.

There are two considerations for using variadic macros:

# The syntax for using variadic macros is the more natural 
  syntax for passing macro arguments. Providing a comma-separated 
  list of data mimics the way macro arguments are usually passed.
# The length of the variadic data does not have to be passed.
  In Boost PP the length does not have to be passed for the 
  sequences and lists, but it has to be specified as part of an 
  array, and must be separately passed, or known in advance, for 
  tuples. Functionality in this library, however, alleviates this 
  last requirement for tuples.
  
On the other hand there are considerations for using 
Boost PP data types for passing variadic data to macros:

# Boost PP data types can be passed multiple times in any macro 
  whereas variadic macros can only pass its variadic macro data 
  a single time as the final set of arguments to a macro. 
# Boost PP data types, which are single macro arguments, fit 
  in well with Boost PP functionality.
# Boost PP data types have a rich set of functionality for 
  manipulating the data in the data type.

The more natural syntax of variadic macro data still provides 
enough importance, from the end-user's point of view, for using 
this library's facilities. A macro writer can design macros for 
the end-user which take variadic data using variadic macros while 
internally using Boost PP data types to manipulate that data and 
pass that data to other Boost PP macros. This library provides 
functionality to do just that with its macros which convert from 
variadic macro data to Boost PP data types.

[section:vmd_comp_example Use-case example]

A typical situation is designing a macro for end-users which 
takes variadic data as its argument. Let's call this macro, 
just as an example, ENDUSER_MACRO. 

Without variadic macro support, but in keeping with Boost PP, the 
best way of designing this macro is probably to use a Boost PP sequence. 
Our design of the macro might look like this:

  #define ENDUSER_MACRO(ppSequence) ENDUSER_DETAIL_MACRO(ppSequence)

The reason for calling another macro which does the actual work of 
expansion will be explained below when discussing how to design 
this macro using VMD.

 #define ENDUSER_DETAIL_MACRO(ppSequence) \
 /* expansion which manipulates the data
   using the Boost PP facilities for a sequence.
   In Boost PP one can find out the size of the 
   sequence, extract any token from the sequence, 
   and much more...
 */

The end-user would pass data to this macro in this way:

 ENDUSER_MACRO((a)(b)(c)(d)(e)) // etc. with each "token" in the sequence surrounded by ()

That is certainly acceptable, and without variadic macros, it is certainly 
excellent to have the Boost PP functionality that allows us to design macros 
taking variadic macro and manipulate that data using the functionality of 
Boost PP.

With variadic macro support and VMD, but wishing to use our variadic data 
in exactly the same way as above, we could design our macro like this:

 #define ENDUSER_MACRO(...) ENDUSER_DETAIL_MACRO(VMD_DATA_TO_PP_SEQ(__VA_ARGS__))

Here we again call the macro which does the actual work. 
This is the reason why I designed my version of the macro 
without variadic macro support in the way that I did.

The end-user would pass data to this macro in this way:

 ENDUSER_MACRO(a,b,c,d,e)

I think this last way of passing variadic data is more 
natural to an end-user than using a Boost PP sequence 
directly, but of course it depends on compiler variadic 
macro support.

[endsect]

[endsect]
