[section:vmd_comparison VMD and Boost PP]
[template mpara[text]
'''<para>'''[text]'''</para>'''
]

Boost PP already has the ability to pass variadic data
as a single macro argument through any of its data types. 
It may then be reasonably asked why there is any need to 
use variadic macros to pass preprocessor data instead.

There are two considerations for using variadic macros:

# The syntax for using variadic macros is the more natural 
  syntax for passing macro arguments. Providing a comma-separated 
  list of data mimics the way macro arguments are usually passed.
# The length of the variadic data does not have to be passed.
  In Boost PP the length does not have to be passed for the 
  sequences and lists, but it has to be specified as part of an 
  array, and must be separately passed, or known in advance, for 
  tuples. Functionality in this library, however, alleviates this 
  last requirement for tuples.
  
On the other hand there are considerations for using 
Boost PP data types for passing variadic data to macros:

# Boost PP data types can be passed multiple times in any macro 
  whereas variadic macros can only pass its variadic macro data 
  a single time as the final set of arguments to a macro. 
# Boost PP data types, which are single macro arguments, fit 
  in well with Boost PP functionality.
# Boost PP data types have a rich set of functionality for 
  manipulating the data in the data type.

The more natural syntax of variadic macro data still provides 
enough importance, from the end-user's point of view, for using 
this library's facilities. A macro writer can design macros for 
the end-user which take variadic data using variadic macros while 
internally using Boost PP data types to manipulate that data and 
pass that data to other Boost PP macros. This library provides 
functionality to do just that with its macros which convert from 
variadic macro data to Boost PP data types.

[section:vmd_comp_example An example design]

We will design a macro for end-users which 
takes variadic data as its argument. Let's call this macro, 
just as an example, ENDUSER_MACRO. 

Without variadic macro support, but in keeping with Boost PP, the 
best way of designing this macro is probably to use a Boost PP sequence. 
Our design of the macro might look like this:

  #define ENDUSER_MACRO(ppSequence) ENDUSER_DETAIL_MACRO(ppSequence)

The reason for calling another macro which does the actual work of 
expansion will be explained below when discussing how to design 
this macro using VMD.

 #define ENDUSER_DETAIL_MACRO(ppSequence) \
 /* expansion which manipulates the data
   using the Boost PP facilities for a sequence.
   In Boost PP one can find out the size of the 
   sequence, extract any token from the sequence, 
   and much more...
 */

The end-user would pass data to this macro in this way:

 ENDUSER_MACRO((a)(b)(c)(d)(e)) // etc. with each "token" in the sequence surrounded by ()

That is certainly acceptable, and without variadic macros, it is certainly 
excellent to have the Boost PP functionality that allows us to design macros 
taking variadic data and manipulate that data using the functionality of 
Boost PP.

With variadic macro support and VMD, but wishing to use our variadic data 
in exactly the same way as above, we could design our macro like this:

 #define ENDUSER_MACRO(...) ENDUSER_DETAIL_MACRO(VMD_DATA_TO_PP_SEQ(__VA_ARGS__))

Here we again call the macro which does the actual work. 
This is the reason why I designed my version of the macro 
without variadic macro support in the way that I did.

The end-user would pass data to this macro in this way:

 ENDUSER_MACRO(a,b,c,d,e) // etc. with each token being somma-separated from each other 

I think this last way of passing variadic data is more 
natural to an end-user than using a Boost PP sequence 
directly, but of course it depends on having compiler variadic 
macro support.

One decision to be made is whether to support, for any given variadic data 
macro functionality, a single macro or two macros with slightly different 
names.

# Single macro design:
'''<para>'''In our example, if we wish to support a single macro, for compilers that 
both support or do not support variadic macros, the code would be:'''</para>'''
'''<para>'''``
  #if defined(BOOST_NO_VARIADIC_MACROS)
    #define ENDUSER_MACRO(ppSequence) ENDUSER_DETAIL_MACRO(ppSequence)
  #else
    #define ENDUSER_MACRO(...) ENDUSER_DETAIL_MACRO(VMD_DATA_TO_PP_SEQ(__VA_ARGS__))
  #endif  
``'''</para>'''
'''<para>'''We would now have a single macro which would be used slightly differently by the 
end-user depending on whether the compiler being used supported variadic macros 
or not. This might not be best if the end-user's code needed to work for different 
compilers, some of which support variadic macros and some of which do not. In that 
latter case, a dual macro design ( see below ) might be better.'''</para>'''
'''<para>'''Another solution supporting a single macro is to just ignore variadic macros, 
and then our solution would be:'''</para>'''
'''<para>'''``
  #define ENDUSER_MACRO(ppSequence) ENDUSER_DETAIL_MACRO(ppSequence)
``'''</para>'''
'''<para>'''We could also ignore any compilers which do not support variadic macros,
and then our solution would be:'''</para>'''
'''<para>'''``
  #if !defined(BOOST_NO_VARIADIC_MACROS)
    #define ENDUSER_MACRO(...) ENDUSER_DETAIL_MACRO(VMD_DATA_TO_PP_SEQ(__VA_ARGS__))
  #endif
``'''</para>'''
# Dual macro design:
'''<para>'''Perhaps best is to provide two macros with slightly different names. Our solution 
would then be:'''</para>'''
'''<para>'''``
    #define ENDUSER_MACRO(ppSequence) ENDUSER_DETAIL_MACRO(ppSequence)
  #if !defined(BOOST_NO_VARIADIC_MACROS)
    #define ENDUSER_MACRO_VM(...) ENDUSER_DETAIL_MACRO(VMD_DATA_TO_PP_SEQ(__VA_ARGS__))
  #endif
``'''</para>'''
'''<para>'''Here I have attached an '_VM' to the name of the macro which supports 
variadic macros.'''</para>'''
  
In an ideal world, once the new C++ standard is ratified, all compilers   
will support variadic macros, and then we can design a single macro 
which takes variadic macro data.

Of course using variadic macro data works smoothly if there is only a single 
set of variadic data which a macro needs. If there is more than one set of 
variadic data, then we can consider using a combination of Boost PP 
variadic data functionality and variadic macro data. This is because variadic 
macro data can only be specified once for a variadic macro and must be the 
last parameter in the variadic macro.

[endsect]

[endsect]
