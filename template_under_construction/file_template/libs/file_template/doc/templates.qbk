The FileTemplate processor offers basic functionality when dealing with
file / directory templates.  It copies
a template directory tree into a new location, renaming files where applicable,
substituting the contents where specified, and processing scripts embedded in
the template tree.

To get a general idea of how this is done, please read the
[link filetemplate.templates.phases processing phases] documentation.

To learn about creating new templates or extending existing templates,
you should also read about __template_options__ and 
__substitution_templates__.

[section:phases Processing phases]

[section:invocation Invocation]

[section:command_line Command line]

The template processor begins by processing the command line for __template_options__.
The options are specified via [~option=value] arguments.  In simple cases, such
as when using only one template, the ordering of the command line arguments should not
affect the output.  However, when multiple templates are used symoultaneously for a
__template_merge__, the order matters.  The order is as follows.

#  __global_options__ can be specified at any point, but are recommended to be
placed at the beginning for consistency.
# __template_options__ that should be applied to all templates are specified before any
template is listed.
# __template_options__ that should be applied to an individual template only should be
specified after listing the template (and before the next template is listed).

[tip The template can be specified without explicitly using =template\==.  E.g., you can run
[^ python file_template.py sandbox] instead of [^ python file_template.py template=sandbox]]

The following examples illustrates this structure:

[table Command line structure examples:
    [[invocation][global options][options for all templates][first template][second template]]

    [[=python file_template.py=][][][sandbox][]]

    [[=python file_template.py=][[^ destination=/boost_sandbox]]
    []
    [[^ sandbox library=boostified_library vc8ide\=y ignore\=$template_library$/boost]]
    [ /old_library/include/old_library into\=boostified_library/boost/boostified_library]]
]

Some __template_options__, such as =ignore= and =fignore=, can be specified multiple times
for the same template.

[endsect]

After processing the command line, or prompting the user if necessary, the template
processor will initialize
each __template_object__ (which processes the template and can be used by any in-template
__python_script__ to customize the behavior of the template)
and the global __template_options__.

The template processor will then
[link filetemplate.templates.phases.examination examine the template tree].

[endsect]

[section:examination Examination of the template tree]

After the startup script has been executed, the template processor will
perform a top-down traversal of the template tree.  By default, it will record
the names of all directories and files located in the tree, which will then
be copied / processed in the next phase.

[section:template_script Template scripts]

To customize what information is to be copied, and to specify additional
customization possibilites (e.g., via __substitution_templates__),
template scripts may be inserted in the template tree.

Template scripts are python files which begin with the following text on their first line:

    # template script

Every script found during the transversal will be executed.  The script can
interact with the template processor through the __template_object__.

[endsect]

[endsect]

[section:processing Producing the resulting file tree]
Finally, the template processor will produce the resulting file tree from the template.
Different kinds of files will be processed as follows:

[h4 Verbatim file copies]
A file for which no specific substitution templates are specified will be copied verbatim.

[h4 Processed file content]
A file for which at least one specific __substitution_template__ is specified will be processed
for both global __substitution_templates__ and specific __substitution_templates__.

[section:python_file Python generated files]
A file of the name /filename/=.py= can be used to generate the file /filename/.  To do so,
it must begin with

    # template file
    
When the script generates the content, it supplies it to the template processor via the
`template.submit_content(content)` or `template.append_content(content)` commands
(see the __template_object__ reference).

[endsect]

[endsect]

[endsect]

[section:merges Template merges]

FileTemplate can be used to merge results created by several templates.  If a template uses
the __results_object__ to customize its output based on files created by all processed templates,
this can be used to seamlessly integrate additional files in the template results.

The __sandbox_template__ uses this to allow additional files (e.g., existing source code) to be
integrated in the newly created Boost sandbox library project.
    
[endsect]

[section:reference Reference]
[section:options Options]

Options are used to fine-tune the behavior of the FileTemplate template processor as well
as the behavior of the template.

[h4 Global options]
/Global options/ govern the behavior of the template processor.

[table Global options
    [[option][desctiption][valid values][default value]]

    [[destination][Destination directory where the results will be constructed.]
    [valid directory path (will be created if it does not exist)][current directory]]
    
]

[h4 Template options]
/Template options/ can be used to specify how a particular template is processed.
Templates may use additional, template-specific options, as is the case with __sandbox_options__.

[table Template options
    [[option][desctiption][valid values][default value]]
    [[template][Template directory][valid directory][]]

    [[into][Determines where the output of the template will be placed inside the resulting tree]
    [valid directoy in resulting tree][root of the resulting tree]]
    
    [[ignore][Ignores a file or directory of the source template tree][file or directory in source template tree]
    []]
    
    [[fignore][Ignores all files in the source template tree that have the specified suffix][file suffix]
    []]

    [/    [[erase][Determines whether the template processor should erase the destination
    directory tree if it already exists][y/n]]]
]

Options can be specified using the command line.  See the __invocation_phase__ reference
for more information.  If an option
is not specified in the command line, and it has no default value, the user will be prompted for the value.

[endsect]

[section:substitutions Substitution templates and special templates]

[h4 Substitution templates]

Substitution templates are the simplest form of template customization.  For specified file
extensions, the template processor will replace each occurence of a substitution template
with the substituted text.  For some examples, see
the [link filetemplate.sandbox.substitutions substitutions] of the sandbox template.

Substitution templates are divided into two categories - /specific/ and /general/.
Specific substitution templates are only applied to
specific file extensions.  General substitution templates are applied to any file
extension that has [*at least one] specific substitution defined.  Files with no
specific substitution templates will be copied verbatim.

[tip Substitutions are applied in the order they are specified in the template scripts, so
substituted text for one substitution template can include substitution templates
specified after it. For example, in the sandbox template
$template\_copyright$ expands into text which includes $template\_authors$.]

[h4 Special templates]

There are also /special/ templates, which are also applied whenever substitution templates
are applied (i.e., for file extensions with at least one specific extension defined).
The FileTemplate processor uses one special template:

[table Special templates used by the FileTemplate template processor
    [[special template][desctiption]]
    [[$template\_start$][Everything up to the line of the file containing
    the first occurrence of this special template will be ignored.]]
]

[endsect]

[section:template Template object]
The template object contains several functions which can be used from template
scripts to customize template behavior.

The following examples quickly illustrate some of the use:

To get a user-specified option:

    docs = template.options.get('docs')

To get a user-specified option verified against a regular expression and with a default value:

    template.options.get('docs', re.compile(r'(qb|qb\+doxyref|qb\+doxy)$'), 'qb+doxyref')

To get a boolean (y/n) user specified option with a default value:

    template.options.get_boolean('vc8ide', False):

To set up a substitution template for file names:

    template.name_replacement('$template_library$', library_name)

To set up a specific __substitution_template__:

    template.content_replacement(['.hpp', '.cpp'], '$template_created$', '// Created in $template_year$')

To set up a general __substitution_template__:

    template.general_content_replacement('$template_year$', str(time.localtime().tm_year))

To ignore (not process) an entire subdirectory in the same directory as the script:

    template.ignore_subdirectory('vc8ide')

To ignore (not process) a file in the same directory as the script:

    template.ignore_subfile('boostbook_doxygen.css')

To submit python-generated file content from a python template file:

    content="""
    This is a script-generated file."""
    content += """
    Yes it is."""
    
    template.submit_content(content)
   
or

    template.append_content("""
    This is a script-generated file.""")
    template.append_content("""
    Yes it is.""")

[endsect]

[section:results Results object]

The results object holds information about the files and directories which will
be generated by the template processor.  It includes files and directories from
*all* templates being processed, and can therefore be used to allow seamless
integration of templates.

For example, if a template includes a file whose
contents depend on the directory tree below a certain directory,
you can =walk= the results object and extract the directory tree.
The following example does so to include all non-detail include
directories for the __sandbox_template__:

    doxy_source_files = list()
    for root, dirs, files in results.walk(
        # we want the returned root to be relative to $template_library$
        template.replace_name('$template_library$'),
        # and want to walk the boost/$template_library$ directory underneath that
        template.replace_name('boost/$template_library$')):
        if os.path.basename(root) != 'detail':
            doxy_source_files.append(
                template.replace_name(os.path.join(os.path.join('../../..',
                root), '*.hpp').replace('\\','/')))

A similar example uses the =files_in= and =directories_in= functions of the
result object to construct the list of files and filters for a MSVC IDE:

        def vc_list_files(level, output_base, destination_base, directory):
            tabs = ''.join(['\t' for x in range(level)])
            output_base_directory = os.path.join(output_base, directory)
            destination_base_directory = os.path.join(destination_base, directory)
            for name in results.files_in(destination_base_directory):
                template.append_content("""
    """ + tabs + """<File
    """ + tabs + '\tRelativePath="'+os.path.join(output_base_directory,name)+""""
    """ + tabs + """\t>
    """ + tabs + """</File>""")

            for name in results.directories_in(destination_base_directory):
                template.append_content("""
    """ + tabs + """<Filter
    """ + tabs + '\tName="'+name+""""
    """ + tabs + """\t>""")
                vc_list_files(level+1, output_base_directory, destination_base_directory, name)
                template.append_content("""
    """ + tabs + """</Filter>""")

[endsect]

[endsect]

[section:changes Version History and Proposed changes]

[heading Version History]

[*version 0.94]

* =make_template.py= changed to =file_template.py=
* `template.all_content_replacement` changed to `template.general_content_replacement` 
* added `template.ignore` function which can ignore any file/directory in the source tree
  (available as [^ignore=] command line option)
* added testing
* made to work on non-windows and on Python 2.3

[heading Proposed Changes]

* a =no-scripts= option should be introduced to disallow processing of
in-template scripts (in case a template
should be copied verbatim with minor processing to make another template)

[/
* The =erase= option should require the user to type =erase= for the value
instead of =y=, just to be safe.
]

[endsect]