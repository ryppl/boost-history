/*----------------------------------------------------------------------------+
Copyright (c) 2007-2008: Joachim Faulhaber
+-----------------------------------------------------------------------------+
Copyright (c) 1999-2006: Cortex Software GmbH, Kantstrasse 57, Berlin
+-----------------------------------------------------------------------------+
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------------*/
#ifndef __itl_interval_JOFA_000626_H__
#define __itl_interval_JOFA_000626_H__

#ifdef USE_CONCEPTS
#include <bits/concepts.h>
#endif

#include <ostream>
#include <functional>
#include <limits>
#include <string>
#include <boost/assert.hpp> 
#include <boost/static_assert.hpp> 
#include <boost/call_traits.hpp> 
#include <boost/mpl/bool.hpp> 
#include <boost/mpl/if.hpp> 
#include <boost/itl/notate.hpp>
#include <boost/itl/type_traits/neutron.hpp>
#include <boost/itl/type_traits/unon.hpp>
#include <boost/itl/type_traits/is_continuous.hpp>
#include <boost/itl/type_traits/difference.hpp>
#include <boost/itl/type_traits/size.hpp>
#include <boost/itl/type_traits/to_string.hpp>

#undef min
#undef max

#define BOUND_VAL first
#define BOUND_TYPES second

typedef unsigned char ITV_BOUNDTYPES;

namespace boost{namespace itl
{

/**
    \mainpage The Interval Template Library

    \section news_sec News

    New examples are available showing applications of interval containers
    that use boost::date_time. Boost::gregorian dates and boost::posix times
    are used in examples boost_party.cpp, man_power.cpp, user_groups.cpp
    and month_and_week_grid.cpp.

    \section intro_sec Introduction

    The Interval Template Library (ITL) is a collection of
    generic c++ template classes for computations on <em>collections of
    intervals</em>. The most important instance of their use is the computation
    with containers of time intervals that are associated to values. We call
    such containers \e histories and their elements \e episodes. In addition to
    intervals and interval containers the library provides classes for
    generalized crosstables, which are tuple containers. We call such
    containers <em>tuple computers</em> or \e cubes.
    \n \n
    The Interval Template Library is currently hosted at the open source
    platform sourceforge and can be downloaded from http://sourceforge.net/projects/itl .
    This doxygen generated html documentation is part of the library release.
    In addition it is available at http://www.herold-faulhaber.de/itl .
    \n \n
    Basic parts of the ITL (interval conainers) are currently discussed at the
    boost developers mailing list as a contribution to the boost libraries.
    Although the sourcecode of the ITL is mature and very well tested it's 
    design may be refactored significantly in a process of adapting to the
    boost library design principles and coding standards.
    \n \n \n

    \section sample_sec Examples

    We do provide a collection of examples that demonstrate the purpose and basic
    characteristics of the classes offered by the library. To get an instant 
    impression you may browse these examples first.
    \n \n \n

    \subsection party_subsec Party

    boost_party.cpp is the ITL's <em>flagship example</em> because it demonstrates
    at least two important aspects of the library design in a 
    comprehensible way.
    In boost_party.cpp the change of guests of a party in time is calculated using
    an interval_map simply by adding pairs of intervals and guest sets
    to the interval_map. As can be seen from this example interval_map has a 
    <em>decompositional behavior</em> on the time part: time intervals are
    split up whenever the set of guests is changing. And it has an 
    <em>aggregational behavior</em> on the associated values: Guest sets are 
    added up on insertion. (party.cpp is a variant of the example that does not use 
    boost::date_time).
    \n \n

    \subsection interval_subsec Intervals 
    
    Interval.cpp gives a short example of different instances of the class interval
    \n \n

    \subsection interval_container_subsec Interval container

    Sample interval_container.cpp demonstrates basic charactersistics of 
    interval container objects: interval_set, split_interval_set and split_interval_map.
    \n \n

    \subsection month_and_week_grid Partitioning of times using split_interval_set

    Example month_and_week_grid.cpp shows how the <em>border preserving</em>
    split_interval_set can be used to create time partitionigs where different
    periodic time intervals overlay each other. The example uses boost::date_time.
    \n \n



    \subsection overlap_counter_subsec Overlap counter: The most basic interval_map application

    The most basic application of an interval_map is a counter counting
    the number of overlaps of intervals inserted into it as shown in overlap_counter.cpp.
    \n \n

    \subsection man_power Man-power: Set operations on interval containers

    Set style operations on interval_sets and interval_maps like union, difference
    and intersection can be used to obtain calculations in a flexible way. Example
    man_power.cpp demontrates such operations in the process of calculating the
    available man-power of a company in a given time interval. The example uses 
    boost::date_time.
    \n \n

    \subsection history_subsec History

    History is a more sophisticated application of an interval_map to decompose
    data in time. Sample history.cpp shows how we can monitor a set of attributes in a history.
    \n \n


    \subsection user_groups_subsec User Groups: Union and intersecion of histories

    Example user_groups.cpp shows how interval_maps can be unified (+=) or 
    intersected (&=) to calculate desired informations. 
	
	We have a group of
    admin users and    of medcial staff, who have different authorisations in
    a ficticious system. The interval_maps for
    the groups show the history of the group membership: The members
    and how they change in time. The union of the groups is a 
    history that shows the memberships of employees who have
    any rights (admin or medical). And the intersection represents the
    group of employees who have both rights: The superusers.


    \subsection amount_cube_subsec Amount cube

    Cubes or tuple computers allow to perform computations on values associated 
    to tuples. A ITL tuple computer works similar to pivot tables (in spreadsheet programs)
    olap cubes (online analytic    processing) or crosstables (in statistical programs). 
    Sample amount_cube.cpp presents an application where values are \e 'amounts', 
    which is the simplest instance.
    \n \n \n

    \section content_sec Content of the ITL 

    \subsection itv_subsec Intervals and sets of intervals 

    A set of intervals represents again a set. The implementation of a set as a set of
    intervals is a very efficient implementation of a set if it's elements are
    clustered in intervals. Examples for interval sets are given in sample
    interval_container.cpp. 
    \n \n

    \subsection aov_subsec Interval maps and 'aggregation on overlap' 

    On of the most fruitful concept of the ITL is the <em>aggregation on overlap</em>
    mechanism on interval maps. The associated values of an interval map are 
    aggregated on insertion, whenever an interval value pair is added and
    the added interval overlaps intervals within the map. Depending on the value
    type this aggregation can be summation (for numbers), concatentation 
    (for lists, strings), set union (for sets) and more. Samples of the 
    <em>aggreation on overlap</em> mechanics are demonstrated in
    files boost_party.cpp (party.cpp), overlap_counter.cpp, man_power.cpp 
    and history.cpp.
    \n \n \n

    \subsection itv_cont_subsec Overview over interval containers 

    Interval containers are sets or maps that are implemented as sets or maps of
    intervals. They are efficient and useful containers in all problem domains
    where elements of sets apperar in continguous chunks (intervals).

    The design of the itl provides five kinds of interval containers: 3 set
    class templates and 2 map class templated. The above table presents an
    overview over interval containers:

    <table>
        <tr>
            <th></td>
            <th>joining</td>
            <th>separating</td>    
            <th>splitting</td>       
        </tr>
        <tr>
            <td>set</td>
            <td>interval_set</td>
            <td>separate_interval_set</td>    
            <td>split_interval_set</td>       
        </tr>
        <tr>
            <td>map</td>
            <td>interval_map</td>
            <td></td>                   
            <td>split_interval_map</td>
        </tr>
        <tr>
            <td></td>
            <td><em>intervals are joined on overlap or touch<br>
                    (if associated values are equal)</em></td>
            <td><em>intervals are joined on overlap, not on touch</em></td>                   
            <td><em>intervals are split on overlap.<br>All interval borders are thus preserved</em></td>
        </tr>
        <tr>
            <td></td><td colspan=3 align="center">
                The different behavior of interval_containers is clarified 
                in interval_container_conduct.h by example.
            </td>
        </tr>
    </table>

    Aspects of the interval container's desing are presented in interval_container_design.h .


    \subsection decom_subsec Decomposition of Histories

    Using interval maps we can build a so called <em>product history</em>, 
    where a product of attributes (or objects) is associated to intervals
    and then inserted to a history. A product history keeps itself always
    in a normal form. Whenever any of the attributes changes, the intervals
    are split such that all attributes associated to an interval are constant.
    So here we get a general mechanism for decomposition of (time) intervals for
    the change of monitored attributes. An example for product histories is
    given in file history.cpp. 
    \n \n


    \subsection cubes_subsec Cubes 

    Tuple computer or cubes are implemented as maps of tuples in the ITL. 
    Cubes are known as crosstables from statistical packages, OLAP 
    (online analytic processing) cubes from data warehouse technology 
    and pivot tables from spradsheet programs (e.g. excel). In the ITL 
    we offer a generic implementation of such cubes in c++. Aggregation
    (e.g. summation) can be expressed by omitting elements of the tuple 
    type of the cube, which we call projection. Other things like grouping
    and sorting can be done quite elegantly. An example for cubes is 
    provided by file amount_cube.cpp. 
    \n \n

    \section thanks_sec Acknowledgements

    I would like to thank CEO Hermann Steppe and Chief Developer Peter Wuttke
    of Cortex Software GmbH for their friendly support of my work on the
    ITL and their permission to release the library as open source.
    
*/

/// A class template for intervals
/**    Bounds of the interval may be closed or open.
    Discrete or continuous datatypes may be used as domain datatypes DomainT.

       Template parameter <b>DomainT</b>:
    The intervals domain type or type of the elements of the interval.
    The interface <b>DomainT</b> has to be implemented by any actual template
    parameter.

    The class defines intervals with closed or open bounds for discrete
    <tt>(short, int, date, time etc.)</tt> and continuous 
    <tt>float, double, Rational etc.</tt> elements. The domain parameter
    may be a built in c++ datatype or a class type. It has to implement
    the interface DomainT.
*/
template <class DomainT, ITL_COMPARE Compare = ITL_COMPARE_INSTANCE(std::less, DomainT)>
#ifdef USE_CONCEPTS
	requires std::LessThanComparable<DomainT>
#endif
class interval
{
public:

    /// Domain type or element type
    typedef DomainT domain_type;
	/// Compare order on the data
    typedef ITL_COMPARE_DOMAIN(Compare,DomainT) domain_compare;

    /// The difference type of an interval which is sometimes different form the domain_type
    typedef typename itl::difference<DomainT>::type difference_type;

    /// The size type of an interval which is mostly std::size_t
    typedef typename itl::size<DomainT>::type size_type;

    /// Interval bounds as bitset
    typedef unsigned char bound_types;

    /// Constants for intervalbounds
    enum BoundTypes {
        /// Both open: <tt>(x,y)</tt>
        OPEN                     = 0x0, 
        /// Left open right closed: <tt>(x,y]</tt>
        LEFT_OPEN                = 0x1, 
        /// Left closed right open: <tt>[x,y)</tt>
        RIGHT_OPEN               = 0x2,
        /// Both closed: <tt>[x,y]</tt>
        CLOSED                   = 0x3,
    } ;


    /** Default constructor; yields an empty interval <tt>[1,0]</tt> */
    interval() : _lwb(unon<DomainT>::value()), _upb(neutron<DomainT>::value()), 
                 _boundtypes(CLOSED) {}

    //NOTE: Compiler generated copy constructor is used

    /** Constructor for a closed singleton interval <tt>[val,val]</tt> */
    explicit interval(const DomainT& val) : 
        _lwb(val), _upb(val), _boundtypes(CLOSED) {}

    /** Interval from <tt>low</tt> to <tt>up</tt> with bounds <tt>bt</tt> */
    interval(const DomainT& low, const DomainT& up, bound_types bt = CLOSED) : 
        _lwb(low), _upb(up), _boundtypes(bt) {}

	/** Closed interval <tt>[low,up]</tt> */
	static interval closed(const DomainT& low, const DomainT& up)
	{ return interval(low, up, CLOSED); }

	/** Rightopen interval <tt>[low,up)</tt> */
	static interval rightopen(const DomainT& low, const DomainT& up)
	{ return interval(low, up, RIGHT_OPEN); }

	/** Leftopen interval <tt>(low,up]</tt> */
	static interval leftopen(const DomainT& low, const DomainT& up)
	{ return interval(low, up, LEFT_OPEN); }

	/** Open interval <tt>(low,up)</tt> */
	static interval open(const DomainT& low, const DomainT& up)
	{ return interval(low, up, OPEN); }

    //NOTE: Compiler generated assignment operator = used

    /** Lower bound of the interval */
    DomainT lower()const { return _lwb; }
    /** Upper bound of the interval */
    DomainT upper()const { return _upb; }
    /** Typ of interval bounds */
    bound_types boundtypes()const { return _boundtypes; }

    /** Is the interval empty? */
    bool empty()const;
    /** Does the interval contain <tt>x</tt>? */
    bool contains(const DomainT& x)const;

    /** Both closed: <tt>[x,y]</tt> ? */
    bool is_closed()const { return _boundtypes == CLOSED; }
    /** Left open right closed: <tt>(x,y]</tt> ? */
    bool is_leftopen()const  { return _boundtypes == LEFT_OPEN; }
    /** Left closed right open: <tt>[x,y)</tt> ? */
    bool is_rightopen()const  { return _boundtypes == RIGHT_OPEN; }
    /** Both open: <tt>(x,y)</tt> ? */
    bool is_open()const   { return _boundtypes == OPEN; }

    /** Left bound is open right unknown <tt>(x,y|</tt> ? */
    bool leftbound_open()const { return !leftbound_closed(); }
    /** Right bound is open left unknown <tt>|x,y)</tt> ? */
    bool rightbound_open()const { return !rightbound_closed(); }
    /** Left closed right unknown <tt>[x,y|</tt> ? */
    bool leftbound_closed()const { return 0 != (_boundtypes & RIGHT_OPEN); }
    /** Right closed left unknown <tt>|x,y]</tt> */
    bool rightbound_closed()const { return 0 != (_boundtypes & LEFT_OPEN); }

    /** <tt>*this</tt> is subset of <tt>super</tt> */
    bool contained_in(const interval& super)const ;
    /** <tt>*this</tt> is superset of <tt>sub</tt> */
    bool contains(const interval& sub)const;

    /** Equality on intervals */
    bool equal(const interval& x2)const
    { return (empty() && x2.empty()) || (lower_equal(x2) && upper_equal(x2)); }

    /**  <tt>*this</tt> and <tt>x2</tt> are disjoint; their intersection is empty */
    bool is_disjoint(const interval& x2)const
    { return exclusive_less(x2) || x2.exclusive_less(*this); }
    /** There is no gap between <tt>*this</tt> and <tt>x2</tt> but they have no element in common */
    bool touches(const interval& x2)const;

    /** Maximal element of <tt>*this</tt> is less than the minimal element of <tt>x2</tt> */
    bool exclusive_less(const interval& x2)const;

    /** Less on intervals */
    bool less(const interval& x2)const
    { return lower_less(x2) || ( lower_equal(x2) && upper_less(x2) ); }

    /** Set the interval empty */
    void clear()
    { set_lwb(unon<DomainT>::value()); set_upb(neutron<DomainT>::value()); _boundtypes=CLOSED; }

	/** Set \c *this interval to from \c low to \c up with boundtypes \c bt */
    interval& set(const DomainT& low, const DomainT& up, bound_types bt) 
    { _lwb=low; _upb=up; _boundtypes=bt; return *this; }

    /** Extend <tt>*this</tt> to <tt>x2</tt> yielding an interval from the minimum of lower bounds
        to the maximum of upper bounds */
    interval& extend(const interval& x2);

	/** Intersection with the interval  <tt>x2</tt>; assign result to <tt>isec</tt> */
    void intersect(interval& isec, const interval& x2)const;

    /** subtract \c x2 from \c *this interval on it's left side. Assign the difference 
		to \c right_over. The result \c right_over is the part of \c *this right of \c x2.
\code
right_over = x1 - x2; //on the left.
...      d) : x1
... c)      : x2; x1.left_subtract(right_over, x2);
     [c  d) : right_over
\endcode
	*/
    void left_subtract(interval& rsur, const interval& x2)const;

    /** subtract \c x2 from \c *this interval on it's right side. Assign the difference 
		to \c left_over. The result \c left_over is the part of \c *this left of \c x2.
\code
left_over = x1 - x2; //on the right side.
[a      ...  : x1
     [b ...  : x2; x1.right_subtract(left_over, x2);
[a  b)       : left_over
\endcode
	*/
    void right_subtract(interval& left_over, const interval& x2)const;

    /** subtract \c x2 from \c *this interval on it's left side.
\code
*this = *this - x2; //on the left.
...      d) : *this
... c)      : x2;
     [c  d) : *this
\endcode
	*/
	interval& left_subtract(const interval& x2);

    /** subtract \c x2 from \c *this interval on it's right side. 
\code
*this = *this - x2; //on the right side.
[a      ...  : *this
     [b ...  : x2;
[a  b)       : *this
\endcode
	*/
	interval& right_subtract(const interval& x2);

    /** Interval spanning from lower bound of *this interval to the upper bound of rhs.
        Bordertypes according to the lower bound of *this and the upper bound of rhs.   */
    interval span(const interval& rhs)const
    {
        if(empty())          return rhs;
        else if(rhs.empty()) return *this;
        else return 
                interval(_lwb, rhs._upb, span(boundtypes(), rhs.boundtypes()));
    }

	
	/// Interval as string
    const std::string as_string()const;



    /// First (smallest) element of the interval
    DomainT first()const;
    /// Last (largest) element of the interval
    DomainT last()const;

    /// Cardinality of the interval: The number of elements
    size_type cardinality()const;

    size_type continuous_cardinality()const
    { 
        if(empty()) 
            return itl::neutron<size_type>::value();
        else if(is_closed() && domain_equal(_lwb, _upb))
            return itl::unon<size_type>::value();
        else 
            return std::numeric_limits<size_type>::infinity();
    }

    size_type discrete_cardinality()const
    { return empty()? itl::neutron<size_type>::value() : succ(last()-first()); }


    /// Arithmetic size of the interval
    difference_type length()const;

    difference_type continuous_length()const
    { return empty() ? itl::neutron<difference_type>::value() : _upb - _lwb; }

    difference_type discrete_length()const
    {
        return empty() ? 
            itl::neutron<difference_type>::value() : 
            succ(last() - first()); 
    }

    /// Size of the interval
    size_type size()const { return cardinality(); }

    /// <tt>*this</tt> interval as closed <tt>[x,y]</tt> interval
    interval as_closed_interval()const;
    /// <tt>*this</tt> interval as open  <tt>[x,y]</tt> interval
    interval as_rightopen_interval()const;

    /** Transforms the interval to the bound-type <tt>bound_types bt</tt> without
        changing it's content
    */
    void transform_bounds(bound_types bt);

    /** Sets left border closed. */
    void close_left_bound();

    /** Sets right border open. */
    void open_right_bound();
    

	/// Maximum Interval
    static interval always()
    { return interval<DomainT>::closed(std::numeric_limits<DomainT>::min(), 
                                       std::numeric_limits<DomainT>::max()); }


private:
    void set_lwb(DomainT lw) { _lwb=lw; }
    void set_upb(DomainT up) { _upb=up; }

public:
    bool lower_less(const interval& x2)const;
    bool upper_less(const interval& x2)const;
    bool lower_less_equal(const interval& x2)const;
    bool upper_less_equal(const interval& x2)const;
    bool lower_equal(const interval& x2)const;
    bool upper_equal(const interval& x2)const;

public:
    typedef typename boost::call_traits<DomainT>::param_type DomainP;

	inline static bool domain_less(DomainP left, DomainP right)       
	{return domain_compare()(left, right) ;}

	inline static bool domain_less_equal(DomainP left, DomainP right) 
	{return !domain_compare()(right, left );}

	inline static bool domain_equal(DomainP left, DomainP right)
	{return !domain_compare()(left, right) && !domain_compare()(right, left);}

private:
    // public?
    typedef std::pair<DomainT, bound_types> BoundT;

    void set_lwb_type(bound_types bt) 
    { _boundtypes = (unsigned char)((LEFT_OPEN & _boundtypes) | (RIGHT_OPEN & bt)); }

    void set_upb_type(bound_types bt) 
    { _boundtypes = (unsigned char)((RIGHT_OPEN & _boundtypes) | (LEFT_OPEN & bt)); }

    static bound_types span(bound_types left, bound_types right)
    { return (unsigned char)((LEFT_OPEN | left) & (RIGHT_OPEN | right)) ; }

    bound_types succession_bounds()const;

    void set_lwb(const BoundT& lw) { _lwb=lw.BOUND_VAL; set_lwb_type(lw.BOUND_TYPES); }
    void set_upb(const BoundT& up) { _upb=up.BOUND_VAL; set_upb_type(up.BOUND_TYPES); }

    BoundT lwb_min(const interval& x2)const;
    BoundT lwb_max(const interval& x2)const;
    BoundT upb_min(const interval& x2)const;
    BoundT upb_max(const interval& x2)const;

    BoundT lwb_rightOf(const interval& x2)const;
    BoundT upb_leftOf(const interval& x2)const;

private:
    DomainT _lwb;
    DomainT _upb;
    bound_types _boundtypes;
} ;


template <class DomainT, ITL_COMPARE Compare>
typename interval<DomainT,Compare>::bound_types interval<DomainT,Compare>::succession_bounds()const
{
    if(_boundtypes==RIGHT_OPEN) return RIGHT_OPEN;
    if(_boundtypes==LEFT_OPEN)  return LEFT_OPEN;
    if(_boundtypes==CLOSED)     return OPEN;
    return CLOSED;
}


template<class IntervalT> 
struct continuous_type
{
	typedef typename IntervalT::domain_type domain_type;
    typedef typename boost::call_traits<domain_type>::param_type DomainP;

	static bool open_bound_less_equal(DomainP x, DomainP y) 
	{ return IntervalT::domain_less_equal(x,y); } //{ return x <= y; }
    static bool open_bound_less      (DomainP x, DomainP y) 
	{ return IntervalT::domain_less(x,y); } //{ return x < y; }
};

template<class IntervalT> 
struct discrete_type
{
	typedef typename IntervalT::domain_type domain_type;
    typedef typename boost::call_traits<domain_type>::param_type DomainP;

    static bool open_bound_less_equal(DomainP x, DomainP y) 
	{ return IntervalT::domain_less_equal(x, succ(y)); } //{ return      x  <= succ(y); }
    static bool open_bound_less      (DomainP x, DomainP y) 
	{ return IntervalT::domain_less(succ(x),y); }        //{ return succ(x) <       y ; }
};

template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::empty()const
{
    using namespace boost::mpl;

    if(rightbound_closed() && leftbound_closed()) return domain_less(_upb, _lwb);       //_upb <  _lwb;
    if(rightbound_open()   && leftbound_closed()) return domain_less_equal(_upb, _lwb); //_upb <= _lwb;
    if(rightbound_closed() && leftbound_open())   return domain_less_equal(_upb, _lwb); //_upb <= _lwb;

    // OTHERWISE (rightbound_open() && leftbound_open())
    return 
        if_<
            bool_<is_continuous<DomainT>::value>, 
            continuous_type<interval<DomainT,Compare> >, 
            discrete_type<interval<DomainT,Compare> > 
           >
           ::type::open_bound_less_equal(_upb, _lwb);
}

template<class IntervalT> 
struct continuous_interval
{
    static typename IntervalT::size_type 
        cardinality(const IntervalT& x) 
    { return x.continuous_cardinality(); }

    static typename IntervalT::difference_type 
        length(const IntervalT& x) 
    { return x.continuous_length(); }

    static bool unaligned_lwb_equal(const IntervalT& x1, const IntervalT& x2)
    { return false; }

    static bool unaligned_upb_equal(const IntervalT& x1, const IntervalT& x2)
    { return false; }

    static bool has_equal_border_touch(const IntervalT& x1, const IntervalT& x2)
    { return false; }
};

template<class IntervalT> 
struct discrete_interval
{
	typedef typename IntervalT::domain_type domain_type;

    static typename IntervalT::size_type 
        cardinality(const IntervalT& x) 
    { return x.discrete_cardinality(); }

    static typename IntervalT::difference_type 
        length(const IntervalT& x) 
    { return x.discrete_length(); }

    static bool unaligned_lwb_equal(const IntervalT& x1, const IntervalT& x2)
    { 
        if(x1.leftbound_open() &&  x2.leftbound_closed()) 
			 return IntervalT::domain_equal(succ(x1.lower()),     x2.lower() );
        else return IntervalT::domain_equal(     x1.lower(), succ(x2.lower()));
    }

    static bool unaligned_upb_equal(const IntervalT& x1, const IntervalT& x2)
    { 
        if(x1.rightbound_closed() && x2.rightbound_open())  
             return IntervalT::domain_equal(succ(x1.upper()),      x2.upper() );
        else return IntervalT::domain_equal(     x1.upper(),  succ(x2.upper()));
    }

    static bool has_equal_border_touch(const IntervalT& x1, const IntervalT& x2)
    {
        if(x1.rightbound_closed() && x2.leftbound_closed()) 
            return IntervalT::domain_equal(succ(x1.upper()), x2.lower());
        if(x1.rightbound_open()  && x2.leftbound_open() ) 
			return IntervalT::domain_equal(x1.upper(), succ(x2.lower()));
        return false;    
    }

};

// NOTE structural similarities between empty and exclusive_less! 
// emptieness can be defined as being exclusive less to oneself.
template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::exclusive_less(const interval& x2)const
{
    using namespace boost::mpl;
    if(rightbound_closed() && x2.leftbound_closed()) return domain_less(_upb, x2._lwb); //_upb < x2._lwb
    if(rightbound_open()   && x2.leftbound_closed()) return domain_less_equal(_upb, x2._lwb); //_upb <= x2._lwb;
    if(rightbound_closed() && x2.leftbound_open() )  return domain_less_equal(_upb, x2._lwb); //_upb <= x2._lwb;

    return 
        if_<
            bool_<is_continuous<DomainT>::value>, 
            continuous_type<interval<DomainT,Compare> >, 
            discrete_type<interval<DomainT,Compare> > 
           >
           ::type::open_bound_less_equal(_upb, x2._lwb);
}


template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::lower_less(const interval& x2)const
{
    using namespace boost::mpl;
    if(leftbound_closed() && x2.leftbound_closed()) return domain_less(_lwb, x2._lwb);
    if(leftbound_open()   && x2.leftbound_open())   return domain_less(_lwb, x2._lwb);
    if(leftbound_closed() && x2.leftbound_open())   return domain_less_equal(_lwb, x2._lwb);//domain_less_equal(_lwb, x2._lwb);

    // OTHERWISE (leftbound_open()  && x2.leftbound_closed())
    return 
        if_<
            bool_<is_continuous<DomainT>::value>, 
            continuous_type<interval<DomainT,Compare> >, 
            discrete_type<interval<DomainT,Compare> > 
           >
           ::type::open_bound_less(_lwb, x2._lwb);
}

template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::upper_less(const interval& x2)const
{
    using namespace boost::mpl;
    if(rightbound_closed() && x2.rightbound_closed()) return domain_less(_upb, x2._upb);
    if(rightbound_open()   && x2.rightbound_open())   return domain_less(_upb, x2._upb);
    if(rightbound_open()   && x2.rightbound_closed()) return domain_less_equal(_upb, x2._upb);//domain_less_equal(_upb, x2._upb);

    // OTHERWISE (rightbound_closed()  && x2.rightbound_open())
    return 
        if_<
            bool_<is_continuous<DomainT>::value>, 
            continuous_type<interval<DomainT,Compare> >, 
            discrete_type<interval<DomainT,Compare> > 
           >
           ::type::open_bound_less(_upb, x2._upb);
}


template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::lower_less_equal(const interval& x2)const
{
    using namespace boost::mpl;
    if(leftbound_closed() && x2.leftbound_closed()) return domain_less_equal(_lwb, x2._lwb);
    if(leftbound_open()   && x2.leftbound_open())   return domain_less_equal(_lwb, x2._lwb);
    if(leftbound_open()   && x2.leftbound_closed()) return domain_less(_lwb, x2._lwb);

    // OTHERWISE (leftbound_closed() && x2.leftbound_open())
    return 
        if_<
            bool_<is_continuous<DomainT>::value>, 
            continuous_type<interval<DomainT,Compare> >, 
            discrete_type<interval<DomainT,Compare> > 
           >
           ::type::open_bound_less_equal(_lwb, x2._lwb);
}


template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::upper_less_equal(const interval& x2)const
{
    using namespace boost::mpl;
    if(rightbound_closed() && x2.rightbound_closed()) return domain_less_equal(_upb, x2._upb);
    if(rightbound_open()   && x2.rightbound_open())   return domain_less_equal(_upb, x2._upb);
    if(rightbound_closed() && x2.rightbound_open())   return domain_less(_upb, x2._upb);

    // OTHERWISE (rightbound_open()  && x2.rightbound_closed())
    return 
        if_<
            bool_<is_continuous<DomainT>::value>, 
            continuous_type<interval<DomainT,Compare> >, 
            discrete_type<interval<DomainT,Compare> > 
           >
           ::type::open_bound_less_equal(_upb, x2._upb);
}


//NOTE THINK: This implementation is rather interesting wrt. continuous value types.
// An alternative implementation was x.lwb_equal(y)={return x.lower_less_equal(y) && y.lower_less_equal(x)}
template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::lower_equal(const interval& x2)const
{
    using namespace boost::mpl;
    if(leftbound_closed() && x2.leftbound_closed()) return domain_equal(_lwb, x2._lwb);
    if(leftbound_open()   && x2.leftbound_open()  ) return domain_equal(_lwb, x2._lwb);

    return 
        if_<
            bool_<is_continuous<DomainT>::value>, 
            continuous_interval<interval<DomainT,Compare> >, 
            discrete_interval<interval<DomainT,Compare> > 
           >
           ::type::unaligned_lwb_equal(*this, x2);
}

//NOTE THINK: This implementation is rather interesting wrt. continuous value types.
// An alternative implementation was x.lwb_equal(y)={return x.lower_less_equal(y) && y.lower_less_equal(x)}
template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::upper_equal(const interval& x2)const
{
    using namespace boost::mpl;
    if(rightbound_closed() && x2.rightbound_closed()) return domain_equal(_upb, x2._upb);
    if(rightbound_open()   && x2.rightbound_open()  ) return domain_equal(_upb, x2._upb);

    return 
        if_<
            bool_<is_continuous<DomainT>::value>, 
            continuous_interval<interval<DomainT,Compare> >, 
            discrete_interval<interval<DomainT,Compare> > 
           >
           ::type::unaligned_upb_equal(*this, x2);
}



template <class DomainT, ITL_COMPARE Compare>
typename interval<DomainT,Compare>::BoundT interval<DomainT,Compare>::lwb_min(const interval& x2)const
{
    if( x2.lower_less(*this) )
        return BoundT(x2._lwb, x2.boundtypes());
    else
        return BoundT(_lwb, boundtypes());
}

template <class DomainT, ITL_COMPARE Compare>
typename interval<DomainT,Compare>::BoundT interval<DomainT,Compare>::upb_max(const interval& x2)const
{
    if( upper_less(x2) )
        return BoundT(x2._upb, x2.boundtypes());
    else
        return BoundT(_upb, boundtypes());
}


// JODO THINK URG do borders reverse when lwb_max is used as upb etc. ?
template <class DomainT, ITL_COMPARE Compare>
typename interval<DomainT,Compare>::BoundT interval<DomainT,Compare>::lwb_max(const interval& x2)const
{
    if( lower_less(x2) )
        return BoundT(x2._lwb, x2.boundtypes());
    else
        return BoundT(_lwb, boundtypes());
}

template <class DomainT, ITL_COMPARE Compare>
typename interval<DomainT,Compare>::BoundT interval<DomainT,Compare>::upb_min(const interval& x2)const
{
    if( x2.upper_less(*this) )
        return BoundT(x2._upb, x2.boundtypes());
    else
        return BoundT(_upb, boundtypes());
}


template <class DomainT, ITL_COMPARE Compare>
typename interval<DomainT,Compare>::BoundT interval<DomainT,Compare>::upb_leftOf(const interval& x2)const
{
    return BoundT(x2._lwb, x2.succession_bounds());
}

template <class DomainT, ITL_COMPARE Compare>
typename interval<DomainT,Compare>::BoundT interval<DomainT,Compare>::lwb_rightOf(const interval& x2)const
{
    return BoundT(x2._upb, x2.succession_bounds());
}


// NOTE non symmetric version: *this[upb].touches(x2[lwb])   
template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::touches(const interval& x2)const
{
    using namespace boost::mpl;
    if(rightbound_open() && x2.leftbound_closed()) return domain_equal(_upb, x2._lwb);
    if(rightbound_closed() && x2.leftbound_open()) return domain_equal(_upb, x2._lwb);

    return 
        if_<
            bool_<is_continuous<DomainT>::value>, 
            continuous_interval<interval<DomainT,Compare> >, 
            discrete_interval<interval<DomainT,Compare> > 
           >
           ::type::has_equal_border_touch(*this, x2);
}

template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::contains(const DomainT& x)const
{
    if(rightbound_closed() && leftbound_closed()) return domain_less_equal(_lwb, x) && domain_less_equal(x, _upb);
    if(rightbound_closed() && leftbound_open()  ) return domain_less(_lwb, x)       && domain_less_equal(x, _upb);
    if(rightbound_open()   && leftbound_closed()) return domain_less_equal(_lwb, x) && domain_less(x, _upb);
                                                  return domain_less(_lwb, x)       && domain_less(x, _upb);
}

template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::contained_in(const interval& super)const
{ return super.lower_less_equal(*this) && upper_less_equal(super); }

template <class DomainT, ITL_COMPARE Compare>
bool interval<DomainT,Compare>::contains(const interval& sub)const
{ return lower_less_equal(sub) && sub.upper_less_equal(*this); }


template <class DomainT, ITL_COMPARE Compare>
interval<DomainT,Compare>& interval<DomainT,Compare>::extend(const interval<DomainT,Compare>& x2)
{
    if(x2.empty()) return *this;
    else if(empty())
    {
        *this = x2; 
        return *this;
    }
    else 
    {
        set_lwb(lwb_min(x2));
        set_upb(upb_max(x2));
        return *this; 
    } 
}


template <class DomainT, ITL_COMPARE Compare>
inline interval<DomainT,Compare>& interval<DomainT,Compare>::left_subtract(const interval& x2)
{
	if(!x2.exclusive_less(*this))
		set_lwb( BoundT(x2._upb, x2.succession_bounds()) );
    return *this; 
}

template <class DomainT, ITL_COMPARE Compare>
inline interval<DomainT,Compare>& interval<DomainT,Compare>::right_subtract(const interval& x2)
{
	if(!exclusive_less(x2))
		set_upb( BoundT(x2._lwb, x2.succession_bounds()) );
    return *this; 
}


template <class DomainT, ITL_COMPARE Compare>
void interval<DomainT,Compare>::intersect(interval<DomainT,Compare>& isec, const interval<DomainT,Compare>& x2)const
{
    isec.set_lwb(lwb_max(x2));
    isec.set_upb(upb_min(x2));
}


template <class DomainT, ITL_COMPARE Compare>
void interval<DomainT,Compare>::right_subtract(interval<DomainT,Compare>& lsur, const interval<DomainT,Compare>& x2)const
{
    if(lower_less(x2)) {
        lsur.set_lwb( BoundT(_lwb,boundtypes()) );
		if(exclusive_less(x2))
			lsur.set_upb( BoundT(_upb,boundtypes()) );
		else
            lsur.set_upb( upb_leftOf(x2) );
    }
    else lsur.clear();
}

template <class DomainT, ITL_COMPARE Compare>
void interval<DomainT,Compare>::left_subtract(interval<DomainT,Compare>& rsur, const interval<DomainT,Compare>& x2)const
{
    if(x2.upper_less(*this)) {
		if(x2.exclusive_less(*this))
            rsur.set_lwb( BoundT(_lwb,boundtypes()) ); 
		else
            rsur.set_lwb(lwb_rightOf(x2)); 
        rsur.set_upb( BoundT(_upb,boundtypes()) );
    }
    else rsur.clear();
}


template <class DomainT, ITL_COMPARE Compare>
const std::string interval<DomainT,Compare>::as_string()const
{
    std::string itvRep("");
    std::string lwbRep, ubpRep;

    itvRep += leftbound_open() ? "(" : "[" ;
    itvRep += itl::to_string<DomainT>::apply(_lwb);
    itvRep += ",";
    itvRep += itl::to_string<DomainT>::apply(_upb);
    itvRep += rightbound_open() ? ")" : "]" ;

    return itvRep;
}


// NOTE ------- DISCRETE ONLY ------- DISCRETE ONLY ------- DISCRETE ONLY ------- 
// these functions do only compile with discrete DomainT-Types that implement 
// operators ++ and --
// NOTE: they must be used in any function that is essential to all instances
// of DomainT

template <class DomainT, ITL_COMPARE Compare>
DomainT interval<DomainT,Compare>::first()const
{
    //JODO: BOOST_STATIC_ASSERT generates compiletime error even if 
    // code is correctly not used
    //BOOST_STATIC_ASSERT(!itl::is_continuous<DomainT>::value);
    BOOST_ASSERT(!itl::is_continuous<DomainT>::value);
    return leftbound_closed() ? _lwb : succ(_lwb); 
}

template <class DomainT, ITL_COMPARE Compare>
DomainT interval<DomainT,Compare>::last()const
{ 
    BOOST_ASSERT(!itl::is_continuous<DomainT>::value);
    return rightbound_closed() ? _upb : pred(_upb); 
}

template <class DomainT, ITL_COMPARE Compare>
typename interval<DomainT,Compare>::size_type interval<DomainT,Compare>::cardinality()const
{
    using namespace boost::mpl;
    return if_<
                bool_<is_continuous<DomainT>::value>,
                continuous_interval<interval<DomainT,Compare> >,
                discrete_interval<interval<DomainT,Compare> >
              >
              ::type::cardinality(*this);
}

template <class DomainT, ITL_COMPARE Compare>
typename interval<DomainT,Compare>::difference_type interval<DomainT,Compare>::length()const
{
    using namespace boost::mpl;
    return if_<
                bool_<is_continuous<DomainT>::value>,
                continuous_interval<interval<DomainT,Compare> >,
                discrete_interval<interval<DomainT,Compare> >
              >
              ::type::length(*this);
}


template <class DomainT, ITL_COMPARE Compare>
interval<DomainT,Compare> interval<DomainT,Compare>::as_closed_interval()const
{ 
    return interval(first(), last(), CLOSED); 
}

template <class DomainT, ITL_COMPARE Compare>
interval<DomainT,Compare> interval<DomainT,Compare>::as_rightopen_interval()const
{ 
    return interval(first(), pred(last()), RIGHT_OPEN); 
}

template <class DomainT, ITL_COMPARE Compare>
void interval<DomainT,Compare>::transform_bounds(bound_types bt)
{ 
    switch(bt)
    {
    case CLOSED:    set(first(), last(), bt);              break;
    case RIGHT_OPEN:set(first(), succ(last()), bt);        break;
    case LEFT_OPEN: set(pred(first()), last(), bt);        break;
    case OPEN:      set(pred(first()), succ(last()), bt);  break;
    }
}

template <class DomainT, ITL_COMPARE Compare>
void interval<DomainT,Compare>::close_left_bound()
{
    if(leftbound_open())
    {
        _boundtypes |= RIGHT_OPEN;
        _lwb++;
    }
}

template <class DomainT, ITL_COMPARE Compare>
void interval<DomainT,Compare>::open_right_bound()
{
    if(rightbound_closed())
    {
        _boundtypes &= RIGHT_OPEN;
        _upb++;
    }
}



template <class DomainT, ITL_COMPARE Compare>
inline bool operator == (const interval<DomainT,Compare>& lhs, const interval<DomainT,Compare>& rhs)
{
    return lhs.equal(rhs);
}

template <class DomainT, ITL_COMPARE Compare>
inline bool operator < (const interval<DomainT,Compare>& lhs, const interval<DomainT,Compare>& rhs)
{
    return lhs.less(rhs);
}


/// Comparison functor on intervals implementing an overlap free less 
/**    
    <b>Template-Klasse exclusive_less: Comparison Functor for Intervals</b>

       Template parameter <b>IntervalType</b>: needs to implement the boolean function

    <tt>bool IntervalType::exclusive_less(IntervalType x2)const; </tt>
    
    <b>exclusive_less</b> implements a strict weak ordering that serves to
    sort sets and maps of intervals interval_set, split_interval_set and
    split_interval_map. 
    
    Function <tt>bool IntervalType::exclusive_less(IntervalType x2)const; </tt> is true if every
    element of the interval <tt>*this</tt> is less than any element of <tt>x2</tt>

    @author  Joachim Faulhaber
*/
template <class IntervalType>
struct exclusive_less {
    /** Operator <tt>operator()</tt> implements a strict weak ordering on intervals. */
    bool operator()(const IntervalType& x1, const IntervalType& x2)const
    { return x1.exclusive_less(x2); }
};


// ----------------------------------------------------------------------------
// operators
// ----------------------------------------------------------------------------
template <class DomainT, ITL_COMPARE Compare>
itl::interval<DomainT,Compare>& operator &= (      itl::interval<DomainT,Compare>& section, 
                                             const itl::interval<DomainT,Compare>& sectant)
{
    section.intersect(section, sectant);
    return section;
}

template <class DomainT, ITL_COMPARE Compare>
itl::interval<DomainT,Compare> operator & (const itl::interval<DomainT,Compare>& left, 
                                           const itl::interval<DomainT,Compare>& right)
{
	return itl::interval<DomainT,Compare>(left) &= right;
}

template<class CharType, class CharTraits, class DomainT, ITL_COMPARE Compare>
std::basic_ostream<CharType, CharTraits> &operator<<
  (std::basic_ostream<CharType, CharTraits> &stream, interval<DomainT,Compare> const& x)
{
    if(x.empty())
        return stream << "[]";
    else
    {
        return stream << std::string(x.leftbound_open() ? "(" : "[")
                      << x.lower() << "," << x.upper()
                      << std::string(x.rightbound_open()? ")" : "]");
    }
}



}} // namespace itl boost

#endif

