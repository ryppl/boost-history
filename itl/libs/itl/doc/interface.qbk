[/
    Copyright (c) 2008-2008 Joachim Faulhaber

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
]

[section Interface]

Section *Interface* gives an overview over the types and functions
of the *Itl*. Synoptical tables allow to review the overall structure of
the libraries design and to recognize structural equalities and differences
with the corresponding containers of the standard template library.

In the table of associated types of interval_sets
there are types like key_type, value_type and key_compare
for the __iterative__ aspect.

[section Class templates]

The next two tables give an overview over ['*set class templates*] of
the itl and compares them to std::set. Included is the __itv__ class
template, because an interval is considered to be a set as well. 

[/              interval]
[/          interval_set]
[/ separate_interval_set]
[/    split_interval_set]
[/              itl::set]

[table set class templates
[[group]        [template]       [instance parameters]]
[[__itv__]      [__itv__]        [`<DomainT,Compare>`]]
[[__itv_bsets__][__itv_set__]    [`<DomainT,Compare,Interval,Alloc>`]]
[[]             [__sep_itv_set__][`<DomainT,Compare,Interval,Alloc>`]]
[[]             [__spl_itv_set__][`<DomainT,Compare,Interval,Alloc>`]]
[[__itl_set__]  [__itl_set__]    [`<DomainT,Compare,Alloc>`]]
[[=std::set=]   [`std::set`]     [`<_Key,_Compare,_Alloc>`]]
[[][]]
]

Templates and template parameters, given in the preceeding table are 
described in detail below.
__Itv_bsets__ represent three
class templates __itv_set__, __sep_itv_set__ and __spl_itv_set__
that all have equal template parameters.

[table Parameters of set class templates
[[]                   [type of elements][order of elements]    [type of intervals]                             [memory allocation]]
[[template parameter] [`class`]  [`template <class>class`]     [`template <class, template<class>class> class`][`template <class>class`]]    
[[__itv__]            [`DomainT`][`Compare = std::less`]       []                                              []]
[[__itv_bsets__]      [`DomainT`][`Compare = std::less`]       [`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[__itl_set__]        [`DomainT`][`Compare = std::less`]       []                                              [`Alloc = std::alloc`]]
[[template parameter] [`class`]  [`class`]                     [`class`]                                       [class]]
[[=std::set=]         [`_Key`]   [`_Compare = std::less<_Key>`][]                                              [`Alloc = std::alloc<_Key>`]]
]

The next two tables give an overview over ['*map class templates*] of
the itl and compares them to =std::map=. 

[/       interval_map]
[/ split_interval_map]
[/           itl::map]

[table map class templates
[[group]        [template]       [instance parameters]]
[[__itv_bmaps__][__itv_map__]    [`<DomainT,CodomainT,Compare,Combine,Traits,Interval,Alloc>`]]
[[]             [__spl_itv_map__][`<DomainT,CodomainT,Compare,Combine,Traits,Interval,Alloc>`]]
[[__itl_map__]  [__itl_map__]    [`<DomainT,CodomainT,Compare,Combine,Traits,Alloc>`]]
[[=std::map=]   [`std::map`]     [`<_Key,_Data,_Compare,_Alloc>`]]
]


Templates and template parameters, given in the preceeding table are 
described in detail below.
__Itv_bmaps__ represent two
class templates __itv_map__ and __spl_itv_map__
that all have equal template parameters.

[table Parameters of map class templates
[[]                   [elements][mapped values][order of elements]          [aggregation]              [traits]                     [type of intervals]                             [memory allocation]]
[[template parameter] [`class`]  [`class`]    [`template <class>class`]     [`template <class>class`]  [`class`]                    [`template <class, template<class>class> class`][`template <class>class`]]    
[[__itv_bmaps__]      [`DomainT`][`CodomainT`][`Compare = std::less`]       [`Combine = inplace_plus`] [`Traits = neutron_absorber`][`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[__itl_map__]        [`DomainT`][`CodomainT`][`Compare = std::less`]       [`Combine = inplace_plus`] [`Traits = neutron_absorber`][`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[template parameter] [`class`]  [`class`]    [`class`]                     []                         []                           []                                              [`class`]]
[[=std::map=]         [`_Key`]   [`_Data`]    [`_Compare = std::less<_Key>`][]                         []                           []                                              [`Alloc = std::alloc<_Key>`]]
]

Using the following placeholders,

``
D  := class DomainT,
C  := class CodomainT,
Cp := class Compare = std::less<DomainT>,
cp := template<class D>class Compare = std::less,
cb := template<class C>class Combine = itl::inplace_plus,
T  := class Traits,
i  := template<class D,template<class>class cp>class Interval = itl::interval
Ad := class Alloc = std::allocator<DomainT>
Av := class Alloc = std::allocator<std::pair<DomainT,CodomainT> >
a  := template<class>class Alloc = std::allocator
``

we arrive at a final synoptical matrix of class templates and their parameters.

[pre
interval     <D,    cp,             >
interval_sets<D,    cp,        i, a >
itl::set     <D,    cp,           a >
std::set     <D,    Cp,           Ad>
interval_maps<D, C, cp, cb, T, i, a >
itl::map     <D, C, cp, cb, T,    a >
std::map     <D, C  Cp,           Av>
]

The choice of parameters and their positions follow the std::containers
as close a possible, so that usage of interval sets and maps does only
require minimal additional knowlege.

Additional knowledge is required when instantiating a comparison parameter
`Compare` or an allocation parameter `Alloc`. In contrast to std::contianers
these have to be instantiated as templates, like e.g.
``
interval_set<string, german_compare>      sections; // 2nd parameter is a template
std::set<string, german_compare<string> > words;    // 2nd parameter is a type
``
This choice has been made, because template parameters have to be 
instantiated with different types inside itl class templates. This problem
is described in detail in section JODO.

Required Concepts



[table Associated types of sets
[[Aspects]        []        [type]            [interval]                  [interval_sets]                 [itl::set]        [std::set]]
[[__conceptual__] [data]    [domain_type]     [DomainT]                   [DomainT]                       [DomainT]         []]
[[]               [ordering][domain_compare]  [Compare<DomainT>]          [Compare<DomainT>]              [Compare<DomainT>][]]
[[iterative]      [data]    [interval_type]   []                          [Interval<DomainT,Compare>]     []                []]
[[]               []        [key_type]        []                          [Interval<DomainT,Compare>]     []                [_Key]]
[[]               []        [value_type]      []                          [Interval<DomainT,Compare>]     []                [_Key]]
[[]               [ordering][interval_compare][]                          [exclusive_less <interval_type>][]                []]
[[]               []        [key_compare]     []                          [exclusive_less <interval_type>][]                [_Compare]]
[[__conceptual__] [size]    [size_type]       [size<DomainT>::type]       [interval_type:: size_type]      [std::size_t]     []]
[[]               []        [difference_type] [difference <DomainT>::type][interval_type:: difference_type][std::size_t]     []]
]                                     

[endsect]

[section Function Matrix]

[table
[[Placeholder]                  [Argument types]          [Description]]             
[[[#element_type]         [*e]] [T::domain_type]          [the element type of the container]]
[[[#interval_type]        [*i]] [T::interval_type]        [the interval type of the container]]
[[[#interval_set_types]   [*S]] [interval_sets]           [one of the interval set types]]
[[[#element_mapping_type] [*b]] [T::element_mapping_type] [type of the element mapping of the map]]
[[[#interval_mapping_type][*p]] [T::interval_mapping_type][type of the interval mapping of the map]]
[[[#interval_map_types]   [*M]] [interval_maps]           [one of the interval map types]]
]

[table Itl Interfaces
[[T]      [interval][interval\nsets][interval\nmaps][itl::set][itl::map][std::set][std::map]]                                                      								   
[/                                   interval  itvset   itvmap  itl:set  itl:map  std:set  std:map]
[[['*Construct, copy, destruct*]]    [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T()]                               [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[T(const T&)]                       [A]       [1]      [1]     [1]      [1]      [1]      [1]]
[[T(const P&)]                       [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& operator=(const T&)]            [A]       [1]      [1]     [1]      [1]      [1]      [1]]
[[void swap(T&)]                     [ ]       [1]      [1]     [1]      [1]      [1]      [1]]
[[['*Emptieness, containment*]]      [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[void clear()]                      [E]       [1]      [1]     [1]      [1]      [1]      [1]]
[[bool empty()const]                 [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[bool contains(const P&)const]    [__ei]  [__eiS][__eiS __bpM][?__e]   [?__b]    [ ]      [ ]]
[[bool contained_in(const P&)const] [__e]     [__S]    [__M]   [?__e]   [?__p]    [ ]      [ ]]
[[['*Size*]]                         [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[size_type size()const]             [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[size_type cardinality()const]      [1]       [1]      [1]     [?]      [?]      [ ]      [ ]]
[[difference_type length()const]     [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[size_t iterative_size()const]      [1]       [1]      [1]     [?]      [?]      [ ]      [ ]]
[[size_t interval_count()const]      [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[['*Range*]]                        [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[domain_type lower()const]          [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[domain_type upper()const]          [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[['*Addition*]]                     [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& add<F>(const P&, const F&)]     [ ]       [ ]     [__bp]   [ ]     [?__b]    [ ]      [ ]]
[[T& add(const P&)]                  [ ]     [__ei]    [__bp]   [__e]   [__b]     [ ]      [ ]]
[[T& operator+=(T&, const P&)]       [ ]     [__eiS]   [__bpM]  [?__eS]   [?__bM]     [ ]      [ ]]
[[['*Subtraction*]]        [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& subtract<F>(const P&, const F&)][ ]       [ ]     [__bp]   [ ]     [?__b]    [ ]      [ ]]
[[T& subtract(const P&)]             [ ]     [__ei]    [__bp]   [__e]   [__b]     [ ]      [ ]]
[[T& operator-=(T&, const P&)]       [ ]     [__eiS]   [__bpM]  [?__eS]   [?__bM]     [ ]      [ ]]
[[['*Insertion, erasure*]]           [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& insert(const P&)]               [ ]     [__ei]    [__bp]   [__e]   [__b]  [?__e]   [?__b]]
[[T& erase(const P&)]                [ ]    [__eiS][__eiS __bpM][__e]   [__b]  [?__e]   [?__b]]
[[['*Intersection*]]                 [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[void intersect(T&, const P&)const] [__i]  [__eiS][__eiS __bpM][ ]      [ ]      [ ]      [ ]]
[[void add_intersection(T&, const P&)const][][__eiS][__eiS __bpM][ ]     [ ]      [ ]      [ ]]
[[T& operator*=(T&, const P&)]       [__i]  [__eiS][__eiS __bpM][?__eS][?__bM]    [ ]      [ ]]
[[['*Iterator related*]]             [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[J begin()]                         [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J end()]                           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J rbegin()]                        [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J rend()]                          [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J lower_bound(const I&)]           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J upper_bound(const I&)]           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
]

[endsect]

[endsect]