[/
    Copyright (c) 2008-2008 Joachim Faulhaber

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
]

[section Concepts]

[section Abstract Sets and Maps]

On the __conceptual__ aspect the __itl_set__ and all __itv_bset__ are a model 
of a concept Set.
The Set concept of the Interval Template Library refers to the
mathematical notion of a set.

[table
[[Function]        [Variant][implemented as]                                 ]  
[[empty set   ]    []       [`Set::Set()`]                                   ]
[[subset relation] []       [`bool Set::contained_in(const Set& s2)const`]   ]
[[equality       ] []       [`bool is_element_equal(const Set& s1, const Set& s2)`]]
[[set union]       [inplace][`Set& operator += (Set& s1, const Set& s2)`]    ]
[[]                []       [`Set  operator +  (const Set& s1, const Set& s2)`]]
[[set difference]  [inplace][`Set& operator -= (Set& s1, const Set& s2)`]        ]
[[]                []       [`Set  operator -  (const Set& s1, const Set& s2)`]]
[[set intersection][inplace][`Set& operator *= (Set& s1, const Set& s2)`]        ]
[[]                []       [`Set  operator *  (const Set& s1, const Set& s2)`]]
]

Equality on Sets is not implemented as `operator ==`, because `==` is used for
the stronger lexicographical equality, that takes the sequence of elements into 
account.

Being models of concept Set, __itl_set__ and all __itv_bsets__ and __itl_set__ 
implement these 
operations and obey the associated laws on Sets. See e.g. 
[@http://en.wikipedia.org/wiki/Algebra_of_sets an algebra of sets here].


On the __conceptual__ aspect __itl_map__ and all __itv_bmaps__ are models of a 
concept Map.
Since a map is a set of pairs, we try to design the map concept in accordance
to the Set concept above. 

[table
[[Function]        [Variant][implemented as]                                 ]  
[[empty map   ]    []       [`Map::Map()`]                                   ]
[[subset relation] []       [`bool Map::contained_in(const Map& s2)const`]   ]
[[equality       ] []       [`bool is_element_equal(const Map& s1, const Map& s2)`]]
[[set union]       [inplace][`Map& operator += (Map& s1, const Map& s2)`]        ]
[[]                []       [`Map  operator +  (const Map& s1, const Map& s2)`]]
[[set difference]  [inplace][`Map& operator -= (Map& s1, const Map& s2)`]        ]
[[]                []       [`Map  operator -  (const Map& s1, const Map& s2)`]]
[[set intersection][inplace][`Map& operator *= (Map& s1, const Map& s2)`]        ]
[[]                []       [`Map  operator *  (const Map& s1, const Map& s2)`]]
]

As one can see, on the abstract kernel the signatures of the itl's Set and Map
concepts are identical, except for the typename. This is not a trivial 
signature since the major
operations that are used in fundamental axioms that make up the semantics
of the concepts are given. Interestingly, while signatures are identical
The set of valid laws are different.

[/ This is due to the fact, that Map::operator+= is not just adding and
Map::operator-= is not only removing ... liegt and der implementierung von 
add und subtract.] 

[/ Auf dem Kern sind die Signaturen (fast) gleich. Unterschiede Semantik.
vor allem +=, -= und erst recht *=]

[/ insert = add<inplace_identity>]
[/ erase  = subtract<inplace_identity>]

[/ Kind of nuclear]

Itl maps differ in their behavior dependent on how they handle
neutral elements of the associated value type CodomainT. In the
itl we call neutral elements neutrons. The way, in which
neutrons are dealt with can be specified by the template parameter
Traits.

[/ Tabellchen absorber, enricher, emitter]

From a pragmatic perspective value pairs that carry neutrons as 
mapped values can often be deleted. A Map that does never insert
associated neutrons or deletes them when they emerge, is called
a neutron_absorber. To be a neutron_absorber is the default setting
for the Trait parameter. Moreover a neutron_absorber is able
to erase a pair (x,y) from a map {(x,y)} by calling subtract((x,y)) 
{(x,y)}.subtract((x,y)) == {}. 

With a neutron_enricher, on the contrary, subtraction of a 
pair (x,y) that is in the map results in a pair (x,0).
{(x,y)}.subtract((x,y)) == {(x,0)}. Mapping pairs that carry
neutrons may emerge as a result of computations and they can
not be erased by subtractions, so they are enriched in the map.

A neutron enricher carries the information, if values have
been aggregated for certain keys and resulted in a neutron value
or if they have not been aggregated at all: No values
exists for a key. 

For a neutron_absorber this distinction can not be made:
# key k exists and associated value is a neutron: 
  There where aggregations.
# key k does not exist: No aggregation at all for k.

Sometimes this distictin is needed. Then a neutron_enricher
is the right choice. Also, If we want to give to itl::Maps
A common set of keys in order to say iterate synchroniously
over both maps, we need neutron_enrichers. 

The third neutronic trait is called neutron_emitter.
A map that is a neutron_emitter is defined on every value
of it's domain. It emits a neutron value for
every key value, that has not been set or aggregated to
a values unequal to the neutron value.

That way a neutron emitter map is an infinite array, that
is always initialized with neutron values.

[endsect]

[endsect]

[section Interface]

Section Interface gives an overview over the types and functions
of the ITL. Synoptical tables allow to review the overall structure of
the libraries design and to recognize structural equalities and differences
with the corresponding containers of the standard template library.

There are two majaor aspects or views of itl containers. The first and predominant
aspect is called __conceptual__. The second and minor aspect is called iterative or
iteration related.

[table
[[Aspect]    [Abstraction level][]                  []                    [Practical]]
[[__Conceptual__][more abstract][concept related]       [iterator independent][interval_sets(maps) can be used as sets(maps) 
                                                                           except for element iteration.]]
[[Iterative] [less abstract][implementation related][iterator dependent]  [interval_sets(maps) iterate over intervals]]
]

On the __conceptual__ aspect

* in interval implements a set of elements partially.
* an interval_set implements a set of elements.
* an interval_map implements a map of element value pairs.

On the iteration related or iterative aspect

* an interval_set implements a set of intervals.
* an interval_map implements a map of interval value pairs.



In the table of associated types of interval_sets
there are types like key_type, value_type and key_compare
for the iterative aspect.

[section Class templates]

The next two tables give an overview over ['*set class templates*] of
the itl and compares them to std::set. Included is the __itv__ class
template, because an interval is considered to be a set as well. 

[/              interval]
[/          interval_set]
[/ separate_interval_set]
[/    split_interval_set]
[/              itl::set]

[table set class templates
[[group]        [template]       [instance parameters]]
[[__itv__]      [__itv__]        [`<DomainT,Compare>`]]
[[__itv_bsets__][__itv_set__]    [`<DomainT,Compare,Interval,Alloc>`]]
[[]             [__sep_itv_set__][`<DomainT,Compare,Interval,Alloc>`]]
[[]             [__spl_itv_set__][`<DomainT,Compare,Interval,Alloc>`]]
[[__itl_set__]  [__itl_set__]    [`<DomainT,Compare,Alloc>`]]
[[=std::set=]   [`std::set`]     [`<_Key,_Compare,_Alloc>`]]
[[][]]
]

Templates and template parameters, given in the preceeding table are 
described in detail below.
__Itv_bsets__ represent three
class templates __itv_set__, __sep_itv_set__ and __spl_itv_set__
that all have equal template parameters.

[table Parameters of set class templates
[[]                   [type of elements][order of elements]    [type of intervals]                             [memory allocation]]
[[template parameter] [`class`]  [`template <class>class`]     [`template <class, template<class>class> class`][`template <class>class`]]    
[[__itv__]            [`DomainT`][`Compare = std::less`]       []                                              []]
[[__itv_bsets__]      [`DomainT`][`Compare = std::less`]       [`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[__itl_set__]        [`DomainT`][`Compare = std::less`]       []                                              [`Alloc = std::alloc`]]
[[template parameter] [`class`]  [`class`]                     [`class`]                                       [class]]
[[=std::set=]         [`_Key`]   [`_Compare = std::less<_Key>`][]                                              [`Alloc = std::alloc<_Key>`]]
]

The next two tables give an overview over ['*map class templates*] of
the itl and compares them to =std::map=. 

[/       interval_map]
[/ split_interval_map]
[/           itl::map]

[table map class templates
[[group]        [template]       [instance parameters]]
[[__itv_bmaps__][__itv_map__]    [`<DomainT,CodomainT,Compare,Combine,Traits,Interval,Alloc>`]]
[[]             [__spl_itv_map__][`<DomainT,CodomainT,Compare,Combine,Traits,Interval,Alloc>`]]
[[__itl_map__]  [__itl_map__]    [`<DomainT,CodomainT,Compare,Combine,Traits,Alloc>`]]
[[=std::map=]   [`std::map`]     [`<_Key,_Data,_Compare,_Alloc>`]]
]


Templates and template parameters, given in the preceeding table are 
described in detail below.
__Itv_bmaps__ represent two
class templates __itv_map__ and __spl_itv_map__
that all have equal template parameters.

[table Parameters of map class templates
[[]                   [elements][mapped values][order of elements]          [aggregation]              [traits]                     [type of intervals]                             [memory allocation]]
[[template parameter] [`class`]  [`class`]    [`template <class>class`]     [`template <class>class`]  [`class`]                    [`template <class, template<class>class> class`][`template <class>class`]]    
[[__itv_bmaps__]      [`DomainT`][`CodomainT`][`Compare = std::less`]       [`Combine = inplace_plus`] [`Traits = neutron_absorber`][`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[__itl_map__]        [`DomainT`][`CodomainT`][`Compare = std::less`]       [`Combine = inplace_plus`] [`Traits = neutron_absorber`][`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[template parameter] [`class`]  [`class`]    [`class`]                     []                         []                           []                                              [`class`]]
[[=std::map=]         [`_Key`]   [`_Data`]    [`_Compare = std::less<_Key>`][]                         []                           []                                              [`Alloc = std::alloc<_Key>`]]
]

Using the following placeholders,

``
D  := class DomainT,
C  := class CodomainT,
Cp := class Compare = std::less<DomainT>,
cp := template<class D>class Compare = std::less,
cb := template<class C>class Combine = itl::inplace_plus,
T  := class Traits,
i  := template<class D,template<class>class cp>class Interval = itl::interval
Ad := class Alloc = std::allocator<DomainT>
Av := class Alloc = std::allocator<std::pair<DomainT,CodomainT> >
a  := template<class>class Alloc = std::allocator
``

we arrive at a final synoptical matrix of class templates and their parameters.

[pre
interval     <D,    cp,             >
interval_sets<D,    cp,        i, a >
itl::set     <D,    cp,           a >
std::set     <D,    Cp,           Ad>
interval_maps<D, C, cp, cb, T, i, a >
itl::map     <D, C, cp, cb, T,    a >
std::map     <D, C  Cp,           Av>
]

The choice of parameters and their positions follow the std::containers
as close a possible, so that usage of interval sets and maps does only
require minimal additional knowlege.

Additional knowledge is required when instantiating a comparison parameter
`Compare` or an allocation parameter `Alloc`. In contrast to std::contianers
these have to be instantiated as templates, like e.g.
``
interval_set<string, german_compare>      sections; // 2nd parameter is a template
std::set<string, german_compare<string> > words;    // 2nd parameter is a type
``
This choice has been made, because template parameters have to be 
instantiated with different types inside itl class templates. This problem
is described in detail in section JODO.

Required Concepts



[table Associated types of sets
[[Aspects]        []        [type]            [interval]                  [interval_sets]                 [itl::set]        [std::set]]
[[__conceptual__] [data]    [domain_type]     [DomainT]                   [DomainT]                       [DomainT]         []]
[[]               [ordering][domain_compare]  [Compare<DomainT>]          [Compare<DomainT>]              [Compare<DomainT>][]]
[[iterative]      [data]    [interval_type]   []                          [Interval<DomainT,Compare>]     []                []]
[[]               []        [key_type]        []                          [Interval<DomainT,Compare>]     []                [_Key]]
[[]               []        [value_type]      []                          [Interval<DomainT,Compare>]     []                [_Key]]
[[]               [ordering][interval_compare][]                          [exclusive_less <interval_type>][]                []]
[[]               []        [key_compare]     []                          [exclusive_less <interval_type>][]                [_Compare]]
[[__conceptual__] [size]    [size_type]       [size<DomainT>::type]       [interval_type:: size_type]      [std::size_t]     []]
[[]               []        [difference_type] [difference <DomainT>::type][interval_type:: difference_type][std::size_t]     []]
]                                     

[endsect]

[section Function Matrix]

[table
[[Placeholder]                  [Argument types]          [Description]]             
[[[#element_type]         [*e]] [T::domain_type]          [the element type of the container]]
[[[#interval_type]        [*i]] [T::interval_type]        [the interval type of the container]]
[[[#interval_set_types]   [*S]] [interval_sets]           [one of the interval set types]]
[[[#element_mapping_type] [*b]] [T::element_mapping_type] [type of the element mapping of the map]]
[[[#interval_mapping_type][*p]] [T::interval_mapping_type][type of the interval mapping of the map]]
[[[#interval_map_types]   [*M]] [interval_maps]           [one of the interval map types]]
]

[table Itl Interfaces
[[T]      [interval][interval\nsets][interval\nmaps][itl::set][itl::map][std::set][std::map]]                                                      								   
[/                                   interval  itvset   itvmap  itl:set  itl:map  std:set  std:map]
[[['*Construct, copy, destruct*]]    [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T()]                               [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[T(const T&)]                       [A]       [1]      [1]     [1]      [1]      [1]      [1]]
[[T(const P&)]                       [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& operator=(const T&)]            [A]       [1]      [1]     [1]      [1]      [1]      [1]]
[[void swap(T&)]                     [ ]       [1]      [1]     [1]      [1]      [1]      [1]]
[[['*Emptieness, containment*]]      [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[void clear()]                      [E]       [1]      [1]     [1]      [1]      [1]      [1]]
[[bool empty()const]                 [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[bool contains(const P&)const]    [__ei]  [__eiS][__eiS __bpM][?__e]   [?__b]    [ ]      [ ]]
[[bool contained_in(const P&)const] [__e]     [__S]    [__M]   [?__e]   [?__p]    [ ]      [ ]]
[[['*Size*]]                         [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[size_type size()const]             [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[size_type cardinality()const]      [1]       [1]      [1]     [?]      [?]      [ ]      [ ]]
[[difference_type length()const]     [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[size_t iterative_size()const]      [1]       [1]      [1]     [?]      [?]      [ ]      [ ]]
[[size_t interval_count()const]      [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[['*Range*]]                        [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[domain_type lower()const]          [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[domain_type upper()const]          [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[['*Addition*]]                     [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& add<F>(const P&, const F&)]     [ ]       [ ]     [__bp]   [ ]     [?__b]    [ ]      [ ]]
[[T& add(const P&)]                  [ ]     [__ei]    [__bp]   [__e]   [__b]     [ ]      [ ]]
[[T& operator+=(T&, const P&)]       [ ]     [__eiS]   [__bpM]  [?__eS]   [?__bM]     [ ]      [ ]]
[[['*Subtraction*]]        [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& subtract<F>(const P&, const F&)][ ]       [ ]     [__bp]   [ ]     [?__b]    [ ]      [ ]]
[[T& subtract(const P&)]             [ ]     [__ei]    [__bp]   [__e]   [__b]     [ ]      [ ]]
[[T& operator-=(T&, const P&)]       [ ]     [__eiS]   [__bpM]  [?__eS]   [?__bM]     [ ]      [ ]]
[[['*Insertion, erasure*]]           [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& insert(const P&)]               [ ]     [__ei]    [__bp]   [__e]   [__b]  [?__e]   [?__b]]
[[T& erase(const P&)]                [ ]    [__eiS][__eiS __bpM][__e]   [__b]  [?__e]   [?__b]]
[[['*Intersection*]]                 [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[void intersect(T&, const P&)const] [__i]  [__eiS][__eiS __bpM][ ]      [ ]      [ ]      [ ]]
[[void add_intersection(T&, const P&)const][][__eiS][__eiS __bpM][ ]     [ ]      [ ]      [ ]]
[[T& operator*=(T&, const P&)]       [__i]  [__eiS][__eiS __bpM][?__eS][?__bM]    [ ]      [ ]]
[[['*Iterator related*]]             [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[J begin()]                         [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J end()]                           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J rbegin()]                        [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J rend()]                          [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J lower_bound(const I&)]           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J upper_bound(const I&)]           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
]

[endsect]

[endsect]