[/
    Copyright (c) 2008-2008 Joachim Faulhaber

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
]

[section Interface]

Section *Interface* gives an overview over the types and functions
of the *Itl*. Synoptical tables allow to review the overall structure of
the libraries design and to recognize structural equalities and differences
with the corresponding containers of the standard template library.

In the table of associated types of interval_sets
there are types like key_type, value_type and key_compare
for the __iterative__ aspect.

[section Class templates]

The next two tables give an overview over ['*set class templates*] of
the itl and compares them to std::set. Included is the __itv__ class
template, because an interval is considered to be a set as well. 

[/              interval]
[/          interval_set]
[/ separate_interval_set]
[/    split_interval_set]
[/              itl::set]

[table set class templates
[[group]        [template]       [instance parameters]]
[[__itv__]      [__itv__]        [`<DomainT,Compare>`]]
[[__itv_bsets__][__itv_set__]    [`<DomainT,Compare,Interval,Alloc>`]]
[[]             [__sep_itv_set__][`<DomainT,Compare,Interval,Alloc>`]]
[[]             [__spl_itv_set__][`<DomainT,Compare,Interval,Alloc>`]]
[[__itl_set__]  [__itl_set__]    [`<DomainT,Compare,Alloc>`]]
[[=std::set=]   [`std::set`]     [`<_Key,_Compare,_Alloc>`]]
[[][]]
]

Templates and template parameters, given in the preceeding table are 
described in detail below.
__Itv_bsets__ represent three
class templates __itv_set__, __sep_itv_set__ and __spl_itv_set__
that all have equal template parameters.

[table Parameters of set class templates
[[]                   [type of elements][order of elements]    [type of intervals]                             [memory allocation]]
[[template parameter] [`class`]  [`template <class>class`]     [`template <class, template<class>class> class`][`template <class>class`]]    
[[__itv__]            [`DomainT`][`Compare = std::less`]       []                                              []]
[[__itv_bsets__]      [`DomainT`][`Compare = std::less`]       [`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[__itl_set__]        [`DomainT`][`Compare = std::less`]       []                                              [`Alloc = std::alloc`]]
[[template parameter] [`class`]  [`class`]                     [`class`]                                       [class]]
[[=std::set=]         [`_Key`]   [`_Compare = std::less<_Key>`][]                                              [`Alloc = std::alloc<_Key>`]]
]

The next two tables give an overview over ['*map class templates*] of
the itl and compares them to =std::map=. 

[/       interval_map]
[/ split_interval_map]
[/           itl::map]

[table map class templates
[[group]        [template]       [instance parameters]]
[[__itv_bmaps__][__itv_map__]    [`<DomainT,CodomainT,Compare,Combine,Traits,Interval,Alloc>`]]
[[]             [__spl_itv_map__][`<DomainT,CodomainT,Compare,Combine,Traits,Interval,Alloc>`]]
[[__itl_map__]  [__itl_map__]    [`<DomainT,CodomainT,Compare,Combine,Traits,Alloc>`]]
[[=std::map=]   [`std::map`]     [`<_Key,_Data,_Compare,_Alloc>`]]
]


Templates and template parameters, given in the preceeding table are 
described in detail below.
__Itv_bmaps__ represent two
class templates __itv_map__ and __spl_itv_map__
that all have equal template parameters.

[table Parameters of map class templates
[[]                   [elements][mapped values][order of elements]          [aggregation]              [traits]                     [type of intervals]                             [memory allocation]]
[[template parameter] [`class`]  [`class`]    [`template <class>class`]     [`template <class>class`]  [`class`]                    [`template <class, template<class>class> class`][`template <class>class`]]    
[[__itv_bmaps__]      [`DomainT`][`CodomainT`][`Compare = std::less`]       [`Combine = inplace_plus`] [`Traits = neutron_absorber`][`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[__itl_map__]        [`DomainT`][`CodomainT`][`Compare = std::less`]       [`Combine = inplace_plus`] [`Traits = neutron_absorber`][`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[template parameter] [`class`]  [`class`]    [`class`]                     []                         []                           []                                              [`class`]]
[[=std::map=]         [`_Key`]   [`_Data`]    [`_Compare = std::less<_Key>`][]                         []                           []                                              [`Alloc = std::alloc<_Key>`]]
]

Using the following placeholders,

``
D  := class DomainT,
C  := class CodomainT,
Cp := class Compare = std::less<DomainT>,
cp := template<class D>class Compare = std::less,
cb := template<class C>class Combine = itl::inplace_plus,
T  := class Traits,
i  := template<class D,template<class>class cp>class Interval = itl::interval
Ad := class Alloc = std::allocator<DomainT>
Av := class Alloc = std::allocator<std::pair<DomainT,CodomainT> >
a  := template<class>class Alloc = std::allocator
``

we arrive at a final synoptical matrix of class templates and their parameters.

[pre
interval     <D,    cp,             >
interval_sets<D,    cp,        i, a >
itl::set     <D,    cp,           a >
std::set     <D,    Cp,           Ad>
interval_maps<D, C, cp, cb, T, i, a >
itl::map     <D, C, cp, cb, T,    a >
std::map     <D, C  Cp,           Av>
]

The choice of parameters and their positions follow the std::containers
as close a possible, so that usage of interval sets and maps does only
require minimal additional knowlege.

Additional knowledge is required when instantiating a comparison parameter
`Compare` or an allocation parameter `Alloc`. In contrast to std::contianers
these have to be instantiated as templates, like e.g.
``
interval_set<string, german_compare>      sections; // 2nd parameter is a template
std::set<string, german_compare<string> > words;    // 2nd parameter is a type
``
This choice has been made, because template parameters have to be 
instantiated with different types inside itl class templates. This problem
is described in detail in section JODO.

[endsect][/ Class templates]

[section Required Concepts]

There are uniform requirements for the template parameters 
across *itl's* class templates. The template parameters can
be grouped with respect to those requirements.

[table 
[[]                    [used in]             [Kind]        [Parameter]  [Instance]                     [Description] ]
[[Domain order]        [`interval, Sets, Maps`][`typename`][`DomainT`]  []                             [For the type `DomainT` of key elements]]
[[]                    []                    [`template`]  [`Compare`]  [`Compare<DomainT>`]           [there is an order `Compare`] ]
[[Interval type]       [`interval_sets/maps`][`template`]  [`Interval`] [`Interval<DomainT,Compare>`]  [the `Interval` parameter has to use the same element type and order ] ]
[[Codomain aggregation][`Maps`]              [`typename`]  [`CodomainT`][]                             [For the type `CodomainT` of associated values]]
[[]                    []                    [`template`]  [`Combine`]  [`Combine<CodomainT>`]         [there is a binary functor `Combine<CodomainT>()` to combine them ] ]
[[]                    []                    []            []           [`Inverse<Combine<CodomainT>>`][and implicity an `Inverse` functor to inversely combine them.  ] ]
[[Memory allocation]   [`Sets, Maps`]        [`template`]  [`Alloc`]    [`Alloc<`/various/`>`]         [An allocator can be chosen for memory allocation.]]
]

[/ table 
[[Kind]      [Parameter]  [Condition]                   [Requirement]                                             ]
[[`typename`][`DomainT`]  []                            [`Regular<DomainT> && LessThanComparable<DomainT,Compare>` 
                                                         `&& (IsIncrementable<DomainT>||HasUnon<DomainT>)`] ]
[[][]                     [`IsIntegral<DomainT>`]       [`IsIncrementable<DomainT> && IsDecrementable<DomainT>`] ] 
[[`typename`][`CodomainT`][`Combine` and `Inverse<Combine>` unused]         []]
[[][]                     [only `Combine` used ]        [`EqualityComparable<CodomainT> && Addable<CodomainT,Combine>`] ] 
[[][]                     [also `Inverse<Combine>` used][`&& Subtractable<CodomainT,Inverse<Combine> >`] ] 
[[`template`][`Compare`]  []                            [`LessThanComparable<DomainT,Compare>`]                     ]
[[`template`][`Combine`]  [only `Combine` used]         [`Addable<CodomainT,Combine>`]] 
[[][]                     [also `Inverse<Combine>` used][`&& Subtractable<CodomainT,Inverse<Combine> >`] ] 
]

[h4 Requirements on DomainT]

The next table gives an overview over the requirements for
template parameter `DomainT`. Some requirements are dependent
on /conditions/. Column /operators/ shows the operators and
functions that are expected for `DomainT`, if the default order
`Compare = std::less` is used.

[table 
[[Parameter]  [Condition]            [Operators]                     [Requirement]                                              ]
[[`DomainT`]  []                     [`DomainT(), <`]                [`Regular<DomainT> && StrictWeakOrdering<DomainT,Compare>`]] 
[[]           []                     [`++, unon<CodomainT>::value()`][`&& (IsIncrementable<DomainT>||HasUnon<DomainT>)`]        ]
[[]           [`IsIntegral<DomainT>`][`++, --`]                      [`IsIncrementable<DomainT> && IsDecrementable<DomainT>`]   ] 
]

A domain type `DomainT` for intervals and interval conainers
has to satisfy the requirements of concept  
[@http://www.generic-programming.org/languages/conceptcpp/issues/concepts-closed.html `Regular`]
which
implies among other properties the existence of a copy and
a default constructor. In addition `IsIncrementable`
*or* `HasUnon` is required for `DomainT`.
In the *itl* we represent an empty interval by a closed
interval `[b,a]` where `a < b` (here `<` represents `Compare<DomainT>()`). 
To construct one of these empty intervals as default constructor
for any type `DomainT` we choose `[1,0]`, where `0` is a null-value or `neutron`
and `1` is a one-value or `unon`:
`` 
interval() := [unon<DomainT>::value(), neutron<DomainT>::value()] //pseudocode
``
`Neutrons` are implemented via call of the default constructor of
`DomainT`. An `unon<T>::value()` is implemented 
[classref boost::itl::unon by default] as a `neutron`, 
that is incremented once. 
``
template <class Type> 
inline Type unon<Type>::value(){ return succ(neutron<Type>::value()); };
``
So a type `DomainT` that is `incrementable` will
also have an `unon`. If it does not, an `unon` can be provided.
An `unon` can be any value, that is greater as the `neutron` value
in the `Compare` order given.
An example of a type, that has a `neutron` but no increment is
`string`. So for `std::string` an unon is implemented like this:
``
// Smallest 'visible' string that is greater than the empty string.
template <>    
inline std::string unon<std::string>::value(){ return std::string(" "); };
``

Just as for the key type of std::sets and maps 
template parameter `Compare`  is required to be a 
[@http://en.wikipedia.org/wiki/Strict_weak_ordering strict weak ordering] on `DomainT`.

Finally, if `DomainT` is an integral type, `DomainT` needs to
be `incrementable` and `decrementable`. This [''bicrementability']
needs to be implemented on the smallest possible unit of the
integral type. This seems like being trivial but there are types like e.g.
`boost::date_time::ptime`, that are integral in nature but do
not provide the required in- and decrementation on the least incrementable unit.
For __itl_itvs__ incementation and decementation is used
for computations between open to closed interval borders like e.g.
`[2,43) == [2,42]`. Such computations always need only
one in- or decrementation, if `DomainT` is an integral type. 

[h4 Requirements on CodomainT]

Summarized in the next table are requirements for template parameter
`CodomainT` of associated values for `Maps`. Again there are
/conditions/ for some of the requirements. Column /operators/
contains the operators and functions required for `CodomainT`, if we are
using the default combiner `Combine = itl::inplace_plus`.

[table 
[[Parameter]  [Condition]                  [Operators]        [Requirement]                                 ]
[[`CodomainT`][`add` and `subtract` unused][`CodomainT(), ==`][`Regular<CodomainT>` which implies]          ]
[[]           []                           []                 [`DefaultConstructible<CodomainT> && EqualityComparable<CodomainT>`]          ] 
[[]           [only `add` used ]           [`+=`]             [`&& Combinable<CodomainT,Combine>`]          ] 
[[]           [also `subtract` used]       [`-=`]             [`&& Combinable<CodomainT,Inverse<Combine> >`]] 
]

The requirements on the type `CodomainT` of associated values for a __itl_map__ or __itv_map__
depend on the usage of their aggregation functionality. If aggregation on overlap
is never used, that is to say neither `+, +=, add` nor `-, -=, subtract` are used on the 
__itv_map__, then `CodomainT` only needs to be `Regular`.  
Concept
[@http://www.generic-programming.org/languages/conceptcpp/issues/concepts-closed.html `Regular` is under construction]
but it can be said that it expresses the properties of common ['*regular*]
object semantics that particularly implies `DefaultConstructible` and
`EqualityComparable` which means it has 
a default ctor `CodomainT()` and an `operator ==`.

Use __itv_maps__ ['*without aggregation*], if the associated values are not 
addable but still
are attached to intervals so you want to use __itv_maps__ to handle them.
As long as those values are added with `insert` and deleted with `erase` 
__itv_maps__ will work fine with such values.

If ['*only addition*] is used via __itv_map_s__ `+, +=` or `add` but no subtraction, 
then `CodomainT` need to be `Combinable` for functor template `Combine`. That
means in most cases when the default implementation `inplace_plus` for
`Combine` is used, that `CodomainT` has to implement `operator +=`. 

For associated value types, that are addable but not subtractable like 
e.g. `std::string` it usually makes sense to use addition to combine values
but the inverse combination is not desired.
``
interval_map<int,std::string> cat_map;
cat_map += make_pair(interval<int>::rightopen(1,5),std::string("Hello"));
cat_map += make_pair(interval<int>::rightopen(3,7),std::string(" world"));
cout << "cat_map: " << cat_map << endl;
//cat_map: {([1,3)->Hello)([3,5)->Hello world)([5,7)-> world)}
``

For ['complete aggregation functionality] and inverse aggregation functor on 
a `Map`'s `CodomainT` is needed. The itl provides a 
metafunction [classref boost::itl::inverse inverse] 
for that purpose. Using the default
`Combine = inplace_plus` that relies on the existence of `operator +=`
on type `CodomainT` 
metafunction [classref boost::itl::inverse inverse] 
will infer [classref boost::itl::inplace_minus inplace_minus]
as inverse functor, that requries `operator -=` on type `CodomainT`.

The `CodomainT` parameter of Itl's `Maps` is designed under the
assumption that for a `Combiner` functor particularly for the 
default functor 
[classref boost::itl::inplace_minus inplace_plus] are 

In the itl's design we make the assumption,
in particular for the default setting of parameters
`Combine = `[classref boost::itl::inplace_minus inplace_plus],
type `CodomainT` has a neutral element or `neutron` 
with respect to the `Combine` functor. This `neutron`


[endsect][/ Required Concepts]


[section Associated Types]

[table Associated types of sets
[[Aspects]        []        [type]            [interval]                  [interval_sets]                 [itl::set]        [std::set]]
[[__conceptual__] [data]    [domain_type]     [DomainT]                   [DomainT]                       [DomainT]         []]
[[]               [ordering][domain_compare]  [Compare<DomainT>]          [Compare<DomainT>]              [Compare<DomainT>][]]
[[iterative]      [data]    [interval_type]   []                          [Interval<DomainT,Compare>]     []                []]
[[]               []        [key_type]        []                          [Interval<DomainT,Compare>]     []                [_Key]]
[[]               []        [value_type]      []                          [Interval<DomainT,Compare>]     []                [_Key]]
[[]               [ordering][interval_compare][]                          [exclusive_less <interval_type>][]                []]
[[]               []        [key_compare]     []                          [exclusive_less <interval_type>][]                [_Compare]]
[[__conceptual__] [size]    [size_type]       [size<DomainT>::type]       [interval_type:: size_type]      [std::size_t]     []]
[[]               []        [difference_type] [difference <DomainT>::type][interval_type:: difference_type][std::size_t]     []]
]                                     

[endsect][/ Associated Types]

[section Function Matrix]

[table
[[Placeholder]                  [Argument types]          [Description]]             
[[[#element_type]         [*e]] [T::domain_type]          [the element type of the container]]
[[[#interval_type]        [*i]] [T::interval_type]        [the interval type of the container]]
[[[#interval_set_types]   [*S]] [interval_sets]           [one of the interval set types]]
[[[#element_mapping_type] [*b]] [T::element_mapping_type] [type of the element mapping of the map]]
[[[#interval_mapping_type][*p]] [T::interval_mapping_type][type of the interval mapping of the map]]
[[[#interval_map_types]   [*M]] [interval_maps]           [one of the interval map types]]
]

[table Itl Interfaces
[[T]      [interval][interval\nsets][interval\nmaps][itl::set][itl::map][std::set][std::map]]                                                      								   
[/                                   interval  itvset   itvmap  itl:set  itl:map  std:set  std:map]
[[['*Construct, copy, destruct*]]    [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T()]                               [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[T(const T&)]                       [A]       [1]      [1]     [1]      [1]      [1]      [1]]
[[T(const P&)]                       [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& operator=(const T&)]            [A]       [1]      [1]     [1]      [1]      [1]      [1]]
[[void swap(T&)]                     [ ]       [1]      [1]     [1]      [1]      [1]      [1]]
[[['*Emptieness, containment*]]      [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[void clear()]                      [E]       [1]      [1]     [1]      [1]      [1]      [1]]
[[bool empty()const]                 [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[bool contains(const P&)const]    [__ei]  [__eiS][__eiS __bpM][?__e]   [?__b]    [ ]      [ ]]
[[bool contained_in(const P&)const] [__e]     [__S]    [__M]   [?__e]   [?__p]    [ ]      [ ]]
[[['*Size*]]                         [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[size_type size()const]             [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[size_type cardinality()const]      [1]       [1]      [1]     [?]      [?]      [ ]      [ ]]
[[difference_type length()const]     [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[size_t iterative_size()const]      [1]       [1]      [1]     [?]      [?]      [ ]      [ ]]
[[size_t interval_count()const]      [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[['*Range*]]                        [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[domain_type lower()const]          [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[domain_type upper()const]          [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[['*Addition*]]                     [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& add<F>(const P&, const F&)]     [ ]       [ ]     [__bp]   [ ]     [?__b]    [ ]      [ ]]
[[T& add(const P&)]                  [ ]     [__ei]    [__bp]   [__e]   [__b]     [ ]      [ ]]
[[T& operator+=(T&, const P&)]       [ ]     [__eiS]   [__bpM]  [?__eS]   [?__bM]     [ ]      [ ]]
[[['*Subtraction*]]        [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& subtract<F>(const P&, const F&)][ ]       [ ]     [__bp]   [ ]     [?__b]    [ ]      [ ]]
[[T& subtract(const P&)]             [ ]     [__ei]    [__bp]   [__e]   [__b]     [ ]      [ ]]
[[T& operator-=(T&, const P&)]       [ ]     [__eiS]   [__bpM]  [?__eS]   [?__bM]     [ ]      [ ]]
[[['*Insertion, erasure*]]           [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& insert(const P&)]               [ ]     [__ei]    [__bp]   [__e]   [__b]  [?__e]   [?__b]]
[[T& erase(const P&)]                [ ]    [__eiS][__eiS __bpM][__e]   [__b]  [?__e]   [?__b]]
[[['*Intersection*]]                 [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[void intersect(T&, const P&)const] [__i]  [__eiS][__eiS __bpM][ ]      [ ]      [ ]      [ ]]
[[void add_intersection(T&, const P&)const][][__eiS][__eiS __bpM][ ]     [ ]      [ ]      [ ]]
[[T& operator*=(T&, const P&)]       [__i]  [__eiS][__eiS __bpM][?__eS][?__bM]    [ ]      [ ]]
[[['*Iterator related*]]             [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[J begin()]                         [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J end()]                           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J rbegin()]                        [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J rend()]                          [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J lower_bound(const I&)]           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J upper_bound(const I&)]           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
]

[endsect]

[endsect]