[/
    Copyright (c) 2008-2008 Joachim Faulhaber

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
]

[section Interface]

Section Interface gives an overview over the types and functions
of the ITL. Synoptical tables allow to review the overall structure of
the libraries design and to recognize structural equalities and differences
with the corresponding containers of the standard template library.

There are two majaor aspects or views of itl containers. The first and predominant
aspect is called conceptual. The second and minor aspect is called iterative or
iteration related.

[table
[[Aspect]    [Abstraction level][]                  []                   [Practical]]
[[Conceptual][more abstract][concept related]       [iterator independent][interval_sets(maps) can be used as sets(maps) 
                                                                          except for element iteration.]]
[[Iterative] [less abstract][implementation related][iterator dependent] [interval_sets(maps) iterate over intervals]]
]

On the conceptual aspect

* in interval implements a set of elements partially.
* an interval_set implements a set of elements.
* an interval_map implements a map of element value pairs.

On the iteration related or iterative aspect

* an interval_set implements a set of intervals.
* an interval_map implements a map of interval value pairs.



In the table of associated types of interval_sets
there are types like key_type, value_type and key_compare
for the iterative aspect.

[section Class templates]

The next two tables give an overview over ['*set class templates*] of
the itl and compares them to std::set. Included is the __itv__ class
template, because an interval is considered to be a set as well. 

[/              interval]
[/          interval_set]
[/ separate_interval_set]
[/    split_interval_set]
[/              itl::set]

[table set class templates
[[group]        [template]       [instance parameters]]
[[__itv__]      [__itv__]        [`<DomainT,Compare>`]]
[[__itv_bsets__][__itv_set__]    [`<DomainT,Compare,Interval,Alloc>`]]
[[]             [__sep_itv_set__][`<DomainT,Compare,Interval,Alloc>`]]
[[]             [__spl_itv_set__][`<DomainT,Compare,Interval,Alloc>`]]
[[__itl_set__]  [__itl_set__]    [`<DomainT,Compare,Alloc>`]]
[[=std::set=]   [`std::set`]     [`<_Key,_Compare,_Alloc>`]]
[[][]]
]

Templates and template parameters, given in the preceeding table are 
described in detail below.
__Itv_bsets__ represent three
class templates __itv_set__, __sep_itv_set__ and __spl_itv_set__
that all have equal template parameters.

[table Parameters of set class templates
[[]                   [type of elements][order of elements]    [type of intervals]                             [memory allocation]]
[[template parameter] [`class`]  [`template <class>class`]     [`template <class, template<class>class> class`][`template <class>class`]]    
[[__itv__]            [`DomainT`][`Compare = std::less`]       []                                              []]
[[__itv_bsets__]      [`DomainT`][`Compare = std::less`]       [`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[__itl_set__]        [`DomainT`][`Compare = std::less`]       []                                              [`Alloc = std::alloc`]]
[[template parameter] [`class`]  [`class`]                     [`class`]                                       [class]]
[[=std::set=]         [`_Key`]   [`_Compare = std::less<_Key>`][]                                              [`Alloc = std::alloc<_Key>`]]
]

The next two tables give an overview over ['*map class templates*] of
the itl and compares them to =std::map=. 

[/       interval_map]
[/ split_interval_map]
[/           itl::map]

[table map class templates
[[group]        [template]       [instance parameters]]
[[__itv_bmaps__][__itv_map__]    [`<DomainT,CodomainT,Compare,Combine,Traits,Interval,Alloc>`]]
[[]             [__spl_itv_map__][`<DomainT,CodomainT,Compare,Combine,Traits,Interval,Alloc>`]]
[[__itl_map__]  [__itl_map__]    [`<DomainT,CodomainT,Compare,Combine,Traits,Alloc>`]]
[[=std::map=]   [`std::map`]     [`<_Key,_Data,_Compare,_Alloc>`]]
]


Templates and template parameters, given in the preceeding table are 
described in detail below.
__Itv_bmaps__ represent two
class templates __itv_map__ and __spl_itv_map__
that all have equal template parameters.

[table Parameters of map class templates
[[]                   [elements][mapped values][order of elements]          [aggregation]              [traits]                     [type of intervals]                             [memory allocation]]
[[template parameter] [`class`]  [`class`]    [`template <class>class`]     [`template <class>class`]  [`class`]                    [`template <class, template<class>class> class`][`template <class>class`]]    
[[__itv_bmaps__]      [`DomainT`][`CodomainT`][`Compare = std::less`]       [`Combine = inplace_plus`] [`Traits = neutron_absorber`][`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[__itl_map__]        [`DomainT`][`CodomainT`][`Compare = std::less`]       [`Combine = inplace_plus`] [`Traits = neutron_absorber`][`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[template parameter] [`class`]  [`class`]    [`class`]                     []                         []                           []                                              [`class`]]
[[=std::map=]         [`_Key`]   [`_Data`]    [`_Compare = std::less<_Key>`][]                         []                           []                                              [`Alloc = std::alloc<_Key>`]]
]


[table Associated types of sets
[[Aspects]    []        [type]            [interval]        [interval_sets]                [itl::set]        [std::set]]
[[conceptual] [data]    [domain_type]     [DomainT]         [DomainT]                      [DomainT]         []]
[[]           [ordering][domain_compare]  [Compare<DomainT>][Compare<DomainT>]             [Compare<DomainT>][]]
[[iterative]  [data]    [interval_type]   []                [Interval<DomainT,Compare>]    []                []]
[[]           []        [key_type]        []                [Interval<DomainT,Compare>]    []                [_Key]]
[[]           []        [value_type]      []                [Interval<DomainT,Compare>]    []                [_Key]]
[[]           [ordering][interval_compare][]                [exclusive_less<interval_type>][]                []]
[[]           []        [key_compare]     []                [exclusive_less<interval_type>][]                [_Compare]]
]                                     

[endsect]

[section Function Matrix]

[table
[[Placeholder]                  [Argument types]          [Description]]             
[[[#element_type]         [*e]] [T::domain_type]          [the element type of the container]]
[[[#interval_type]        [*i]] [T::interval_type]        [the interval type of the container]]
[[[#interval_set_types]   [*S]] [interval_sets]           [one of the interval set types]]
[[[#element_mapping_type] [*b]] [T::element_mapping_type] [type of the element mapping of the map]]
[[[#interval_mapping_type][*p]] [T::interval_mapping_type][type of the interval mapping of the map]]
[[[#interval_map_types]   [*M]] [interval_maps]           [one of the interval map types]]
]

[table Itl Interfaces
[[T]      [interval][interval\nsets][interval\nmaps][itl::set][itl::map][std::set][std::map]]                                                      								   
[/                                   interval  itvset   itvmap  itl:set  itl:map  std:set  std:map]
[[['*Construct, copy, destruct*]]    [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T()]                               [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[T(const T&)]                       [A]       [1]      [1]     [1]      [1]      [1]      [1]]
[[T(const P&)]                       [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& operator=(const T&)]            [A]       [1]      [1]     [1]      [1]      [1]      [1]]
[[void swap(T&)]                     [ ]       [1]      [1]     [1]      [1]      [1]      [1]]
[[['*Emptieness, containment*]]      [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[void clear()]                      [E]       [1]      [1]     [1]      [1]      [1]      [1]]
[[bool empty()const]                 [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[bool contains(const P&)const]    [__ei]  [__eiS][__eiS __bpM][?__e]   [?__b]    [ ]      [ ]]
[[bool contained_in(const P&)const] [__e]     [__S]    [__M]   [?__e]   [?__p]    [ ]      [ ]]
[[['*Size*]]                         [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[size_type size()const]             [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[size_type cardinality()const]      [1]       [1]      [1]     [?]      [?]      [ ]      [ ]]
[[difference_type length()const]     [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[size_t iterative_size()const]      [1]       [1]      [1]     [?]      [?]      [ ]      [ ]]
[[size_t interval_count()const]      [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[['*Range*]]                        [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[domain_type lower()const]          [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[domain_type upper()const]          [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[['*Addition*]]                     [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& add<F>(const P&, const F&)]     [ ]       [ ]     [__bp]   [ ]     [?__b]    [ ]      [ ]]
[[T& add(const P&)]                  [ ]     [__ei]    [__bp]   [__e]   [__b]     [ ]      [ ]]
[[T& operator+=(T&, const P&)]       [ ]     [__eiS]   [__bpM]  [?__eS]   [?__bM]     [ ]      [ ]]
[[['*Subtraction*]]        [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& subtract<F>(const P&, const F&)][ ]       [ ]     [__bp]   [ ]     [?__b]    [ ]      [ ]]
[[T& subtract(const P&)]             [ ]     [__ei]    [__bp]   [__e]   [__b]     [ ]      [ ]]
[[T& operator-=(T&, const P&)]       [ ]     [__eiS]   [__bpM]  [?__eS]   [?__bM]     [ ]      [ ]]
[[['*Insertion, erasure*]]           [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[T& insert(const P&)]               [ ]     [__ei]    [__bp]   [__e]   [__b]  [?__e]   [?__b]]
[[T& erase(const P&)]                [ ]    [__eiS][__eiS __bpM][__e]   [__b]  [?__e]   [?__b]]
[[['*Intersection*]]                 [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[void intersect(T&, const P&)const] [__i]  [__eiS][__eiS __bpM][ ]      [ ]      [ ]      [ ]]
[[void add_intersection(T&, const P&)const][][__eiS][__eiS __bpM][ ]     [ ]      [ ]      [ ]]
[[T& operator*=(T&, const P&)]       [__i]  [__eiS][__eiS __bpM][?__eS][?__bM]    [ ]      [ ]]
[[['*Iterator related*]]             [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[J begin()]                         [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J end()]                           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J rbegin()]                        [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J rend()]                          [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J lower_bound(const I&)]           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[J upper_bound(const I&)]           [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
]

[endsect]

[endsect]