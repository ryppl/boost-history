[/
    Copyright (c) 2008-2008 Joachim Faulhaber

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
]

[section Interface]

Section *Interface* gives an overview over the types and functions
of the *Itl*. Synoptical tables allow to review the overall structure of
the libraries design and to focus on structural equalities and differences
with the corresponding containers of the standard template library.


[section Class templates]

The next two tables give an overview over ['*set class templates*] of
the itl and compares them to std::set. Included is the __itv__ class
template, because an interval is considered to be a set as well. 

[/              interval]
[/          interval_set]
[/ separate_interval_set]
[/    split_interval_set]
[/              itl::set]

[table set class templates
[[group]        [template]       [instance parameters]]
[[__itv__]      [__itv__]        [`<DomainT,Compare>`]]
[[__itv_bsets__][__itv_set__]    [`<DomainT,Compare,Interval,Alloc>`]]
[[]             [__sep_itv_set__][`<DomainT,Compare,Interval,Alloc>`]]
[[]             [__spl_itv_set__][`<DomainT,Compare,Interval,Alloc>`]]
[[__itl_set__]  [__itl_set__]    [`<DomainT,Compare,         Alloc>`]]
[[=std::set=]   [`std::set`]     [`<_Key,  _Compare,        _Alloc>`]]
]

Templates and template parameters, given in the preceeding table are 
described in detail below.
__Itv_bsets__ represent three
class templates __itv_set__, __sep_itv_set__ and __spl_itv_set__
that all have equal template parameters.

[table Parameters of set class templates
[[]                   [type of elements][order of elements]    [type of intervals]                             [memory allocation]]
[[template parameter] [`class`]  [`template <class>class`]     [`template <class, template<class>class> class`][`template <class>class`]]    
[[__itv__]            [`DomainT`][`Compare = std::less`]       []                                              []]
[[__itv_bsets__]      [`DomainT`][`Compare = std::less`]       [`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[__itl_set__]        [`DomainT`][`Compare = std::less`]       []                                              [`Alloc = std::alloc`]]
[[template parameter] [`class`]  [`class`]                     [`class`]                                       [class]]
[[=std::set=]         [`_Key`]   [`_Compare = std::less<_Key>`][]                                              [`Alloc = std::alloc<_Key>`]]
]

The next two tables give an overview over ['*map class templates*] of
the itl and compares them to =std::map=. 

[/       interval_map]
[/ split_interval_map]
[/           itl::map]

[table map class templates
[[group]        [template]       [instance parameters]]
[[__itv_bmaps__][__itv_map__]    [`<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc>`]]
[[]             [__spl_itv_map__][`<DomainT,CodomainT,Traits,Compare,Combine,Section,Interval,Alloc>`]]
[[__itl_map__]  [__itl_map__]    [`<DomainT,CodomainT,Traits,Compare,Combine,Section,Alloc>`]]
[[=std::map=]   [`std::map`]     [`<_Key,   _Data,          _Compare,               _Alloc>`]]
]


Templates and template parameters, given in the preceeding table are 
described in detail below.
__Itv_bmaps__ represent two
class templates __itv_map__ and __spl_itv_map__
that all have equal template parameters.

[table Parameters of map class templates
[[]                   [elements][mapped values][traits]                      [order of elements]           [aggregation propagation]  [intersection propagation]                      [type of intervals]                             [memory allocation]]
[[template parameter] [`class`]  [`class`]     [`class`]                     [`template <class>class`]     [`template <class>class`]  [`template <class, template<class>class> class`][`template <class, template<class>class> class`][`template <class>class`]]    
[[__itv_bmaps__]      [`DomainT`][`CodomainT`] [`Traits = neutron_absorber`] [`Compare = std::less`]       [`Combine = inplace_plus`] [`Section = itl::inplace_star`]                 [`Interval = itl::interval`]                    [`Alloc = std::alloc`]]
[[__itl_map__]        [`DomainT`][`CodomainT`] [`Traits = neutron_absorber`] [`Compare = std::less`]       [`Combine = inplace_plus`] [`Section = itl::inplace_star`]                 [`Alloc = std::alloc`]]
[[template parameter] [`class`]  [`class`]     []                            [`class`]                     []                         []                                              []                                              [`class`]]
[[=std::map=]         [`_Key`]   [`_Data`]     []                            [`_Compare = std::less<_Key>`][]                         []                                              []                                              [`Alloc = std::alloc<_Key>`]]
]

Using the following placeholders,

``
D  := class DomainT,
C  := class CodomainT,
T  := class Traits,
Cp := class Compare = std::less<DomainT>,
cp := template<class D>class Compare = std::less,
cb := template<class C>class Combine = itl::inplace_plus,
s  := template<class C>class Section = itl::inplace_star,
i  := template<class D,template<class>class cp>class Interval = itl::interval
Ad := class Alloc = std::allocator<DomainT>
Av := class Alloc = std::allocator<std::pair<DomainT,CodomainT> >
a  := template<class>class Alloc = std::allocator
``

we arrive at a final synoptical matrix of class templates and their parameters.

[pre
interval     <D,       cp,             >
interval_sets<D,       cp,        i, a >
itl::set     <D,       cp,           a >
std::set     <D,       Cp,           Ad>
interval_maps<D, C, T, cp, cb, s, i, a >
itl::map     <D, C, T, cp, cb, s,    a >
std::map     <D, C     Cp,           Av>
]

The choice of parameters and their positions follow the std::containers
as close a possible, so that usage of interval sets and maps does only
require minimal additional knowlege.

Additional knowledge is required when instantiating a comparison parameter
`Compare` or an allocation parameter `Alloc`. In contrast to std::contianers
these have to be instantiated as templates, like e.g.
``
interval_set<string, german_compare>      sections; // 2nd parameter is a template
std::set<string, german_compare<string> > words;    // 2nd parameter is a type
``
This choice has been made, because template parameters have to be 
instantiated with different types inside itl class templates. This problem
is described in detail in section JODO.

[endsect][/ Class templates]

[section Required Concepts]

There are uniform requirements for the template parameters 
across *itl's* class templates. The template parameters can
be grouped with respect to those requirements.

[table 
[[]                    [used in]             [Kind]        [Parameter]  [Instance]                     [Description] ]
[[Domain order]        [`interval, Sets, Maps`][`typename`][`DomainT`]  []                             [For the type `DomainT` of key elements `...`]]
[[]                    []                    [`template`]  [`Compare`]  [`Compare<DomainT>`]           [`...` there is an order `Compare`] ]
[[Interval type]       [`interval_sets/maps`][`template`]  [`Interval`] [`Interval<DomainT,Compare>`]  [`...` the `Interval` parameter has to use the same element type and order. ] ]
[[Codomain aggregation][`Maps`]              [`typename`]  [`CodomainT`][]                             [For the type `CodomainT` of associated values `...`]]
[[]                    []                    [`template`]  [`Combine`]  [`Combine<CodomainT>`]         [`...` there is a binary functor `Combine<CodomainT>()` to combine them ] ]
[[]                    []                    []            []           [`Inverse<Combine<CodomainT>>`][`...` and implicity an `Inverse` functor to inversely combine them.  ] ]
[[]                    []                    [`template`]  [`Section`]  [`Section<CodomainT>`]         [For a intersection operation intersection is propagated to CodomainT values via functor `Section<CodomainT>()`] ]
[[Memory allocation]   [`Sets, Maps`]        [`template`]  [`Alloc`]    [`Alloc<`/various/`>`]         [An allocator can be chosen for memory allocation.]]
]

[/ table 
[[Kind]      [Parameter]  [Condition]                              [Requirement]                                             ]
[[`typename`][`DomainT`]  []                                       [`Regular<DomainT> && LessThanComparable<DomainT,Compare>` 
                                                                    `&& (IsIncrementable<DomainT>||HasUnon<DomainT>)`] ]
[[][]                     [`IsIntegral<DomainT>`]                  [`IsIncrementable<DomainT> && IsDecrementable<DomainT>`] ] 
[[`typename`][`CodomainT`][`Combine` and `Inverse<Combine>` unused]         []]
[[][]                     [only `Combine` used ]                   [`EqualityComparable<CodomainT> && Addable<CodomainT,Combine>`] ] 
[[][]                     [also `Inverse<Combine>` used]           [`&& Subtractable<CodomainT,Inverse<Combine> >`] ] 
[[`template`][`Compare`]  []                                       [`LessThanComparable<DomainT,Compare>`]                     ]
[[`template`][`Combine`]  [only `Combine` used]                    [`Addable<CodomainT,Combine>`]] 
[[][]                     [and `Inverse<Combine>` used]            [`&& Subtractable<CodomainT,Inverse<Combine> >`] ] 
[[][]                     [`Section` used and `CodomainT` is a set][`Intersectable<CodomainT,Section>`] ] 
]

[h4 Requirements on DomainT]

The next table gives an overview over the requirements for
template parameter `DomainT`. Some requirements are dependent
on /conditions/. Column /operators/ shows the operators and
functions that are expected for `DomainT`, if the default order
`Compare = std::less` is used.

[table 
[[Parameter]  [Condition]            [Operators]                     [Requirement]                                              ]
[[`DomainT`]  []                     [`DomainT(), <`]                [`Regular<DomainT> && StrictWeakOrdering<DomainT,Compare>`]] 
[[]           []                     [`++, unon<CodomainT>::value()`][`&& (IsIncrementable<DomainT>||HasUnon<DomainT>)`]        ]
[[]           [`IsIntegral<DomainT>`][`++, --`]                      [`IsIncrementable<DomainT> && IsDecrementable<DomainT>`]   ] 
]

A domain type `DomainT` for intervals and interval conainers
has to satisfy the requirements of concept  
[@http://www.generic-programming.org/languages/conceptcpp/issues/concepts-closed.html `Regular`]
which
implies among other properties the existence of a copy and
a default constructor. In addition `IsIncrementable`
*or* `HasUnon` is required for `DomainT`.
In the *itl* we represent an empty interval by a closed
interval `[b,a]` where `a < b` (here `<` represents `Compare<DomainT>()`). 
To construct one of these empty intervals as default constructor
for any type `DomainT` we choose `[1,0]`, where `0` is a null-value or `neutron`
and `1` is a one-value or `unon`:
`` 
interval() := [unon<DomainT>::value(), neutron<DomainT>::value()] //pseudocode
``
`Neutrons` are implemented via call of the default constructor of
`DomainT`. An `unon<T>::value()` is implemented 
[classref boost::itl::unon by default] as a `neutron`, 
that is incremented once. 
``
template <class Type> 
inline Type unon<Type>::value(){ return succ(neutron<Type>::value()); };
``
So a type `DomainT` that is `incrementable` will
also have an `unon`. If it does not, an `unon` can be provided.
An `unon` can be any value, that is greater as the `neutron` value
in the `Compare` order given.
An example of a type, that has a `neutron` but no increment is
`string`. So for `std::string` an unon is implemented like this:
``
// Smallest 'visible' string that is greater than the empty string.
template <>    
inline std::string unon<std::string>::value(){ return std::string(" "); };
``

Just as for the key type of std::sets and maps 
template parameter `Compare`  is required to be a 
[@http://en.wikipedia.org/wiki/Strict_weak_ordering strict weak ordering] on `DomainT`.

Finally, if `DomainT` is an integral type, `DomainT` needs to
be `incrementable` and `decrementable`. This [''bicrementability']
needs to be implemented on the smallest possible unit of the
integral type. This seems like being trivial but there are types like e.g.
`boost::date_time::ptime`, that are integral in nature but do
not provide the required in- and decrementation on the least incrementable unit.
For __itl_itvs__ incementation and decementation is used
for computations between open to closed interval borders like e.g.
`[2,43) == [2,42]`. Such computations always need only
one in- or decrementation, if `DomainT` is an integral type. 

[h5 Requirements on Interval]

Requirements on the `Interval` parameter are closely related to the 
`DomainT` parameter. `template Interval` has two template parameters
itself for an element type and a compare order and it is of course
internally always instantiated as `Interval<DomainT,Compare>`.
`Interval<DomainT,Compare>` then has to implement an order called
`exclusive_less`. Two intervals `x, y` are exclusive_less 
``x.exclusive_less(y)``
if all `DomainT` elements of `x` are less than elements of `y` in the
`Compare` order. 
 
[table 
[[Parameter]  [Operators]                     [Requirement]                                              ]
[[`Interval`] [`exclusive_less`]              [`IsExclusiveLessComparable<Interval<DomainT,Compare> >`]   ] 
]

[h4 Requirements on CodomainT]

Summarized in the next table are requirements for template parameter
`CodomainT` of associated values for `Maps`. Again there are
/conditions/ for some of the requirements. Column /operators/
contains the operators and functions required for `CodomainT`, if we are
using the default combiner `Combine = itl::inplace_plus`.

[table 
[[Parameter]  [Condition]                              [Operators]        [Requirement]                                 ]
[[`CodomainT`][`add`, `subtract`, `intersect` unused]  [`CodomainT(), ==`][`Regular<CodomainT>` which implies]          ]
[[]           []                                       []                 [`DefaultConstructible<CodomainT> && EqualityComparable<CodomainT>`]          ] 
[[]           [only `add` used ]                       [`+=`]             [`&& Combinable<CodomainT,Combine>`]          ] 
[[]           [... and also `subtract` used]           [`-=`]             [`&& Combinable<CodomainT,Inverse<Combine> >`]] 
[[]           [`Section` used and `CodomainT` is a set][`&=`]             [`&& Intersectable<CodomainT,Section>`] ] 
]

The requirements on the type `CodomainT` of associated values for a __itl_map__ or __itv_map__
depend on the usage of their aggregation functionality. If aggregation on overlap
is never used, that is to say that none of the addition, subtraction and intersection
operations (`+, +=, add`, `-, -=, subtract`, &, &=, add_intersection) are used on the 
__itv_map__, then `CodomainT` only needs to be 
[@http://www.generic-programming.org/languages/conceptcpp/issues/concepts-closed.html Regular].
['*Regular*]
object semantics implies `DefaultConstructible` and
`EqualityComparable` which means it has 
a default ctor `CodomainT()` and an `operator ==`.

Use __itv_maps__ ['*without aggregation*], if the associated values are not 
addable but still
are attached to intervals so you want to use __itv_maps__ to handle them.
As long as those values are added with `insert` and deleted with `erase` 
__itv_maps__ will work fine with such values.

If ['*only addition*] is used via __itv_map_s__ `+, +=` or `add` but no subtraction, 
then `CodomainT` need to be `Combinable` for functor template `Combine`. That
means in most cases when the default implementation `inplace_plus` for
`Combine` is used, that `CodomainT` has to implement `operator +=`. 

For associated value types, that are addable but not subtractable like 
e.g. `std::string` it usually makes sense to use addition to combine values
but the inverse combination is not desired.
``
interval_map<int,std::string> cat_map;
cat_map += make_pair(interval<int>::rightopen(1,5),std::string("Hello"));
cat_map += make_pair(interval<int>::rightopen(3,7),std::string(" world"));
cout << "cat_map: " << cat_map << endl;
//cat_map: {([1,3)->Hello)([3,5)->Hello world)([5,7)-> world)}
``

For ['complete aggregation functionality] and inverse aggregation functor on 
a `Map`'s `CodomainT` is needed. The itl provides a 
metafunction [classref boost::itl::inverse inverse] 
for that purpose. Using the default
`Combine = inplace_plus` that relies on the existence of `operator +=`
on type `CodomainT` 
metafunction [classref boost::itl::inverse inverse] 
will infer [classref boost::itl::inplace_minus inplace_minus]
as inverse functor, that requries `operator -=` on type `CodomainT`.

The `CodomainT` parameter of Itl's `Maps` is designed under the
assumption that for a `Combiner` functor particularly for the 
default functor 
[classref boost::itl::inplace_minus inplace_plus] are 

In the itl's design we make the assumption,
in particular for the default setting of parameters
`Combine = `[classref boost::itl::inplace_minus inplace_plus],
type `CodomainT` has a neutral element or `neutron` 
with respect to the `Combine` functor. This `neutron`


[endsect][/ Required Concepts]


[section Associated Types]

[table Associated types of sets
[[Aspects]        []        [type]              [__itv__]                     [__itv_sets__]                     [__itl_set__]       [`std::set`]]
[[__conceptual__] [data]    [`domain_type`]     [`DomainT`]                   [`DomainT`]                        [`DomainT`]         []]
[[]               [ordering][`domain_compare`]  [`Compare<DomainT>`]          [`Compare<DomainT>`]               [`Compare<DomainT>`][]]
[[__iterative__]  [data]    [`interval_type`]   []                            [`Interval<DomainT,Compare>`]      []                  []]
[[]               []        [`key_type`]        []                            [`Interval<DomainT,Compare>`]      []                  [`_Key`]]
[[]               []        [`value_type`]      []                            [`Interval<DomainT,Compare>`]      []                  [`_Key`]]
[[]               [ordering][`interval_compare`][]                            [`exclusive_less <interval_type>`] []                  []]
[[]               []        [`key_compare`]     []                            [`exclusive_less <interval_type>`] []                  [`_Compare`]]
[[__conceptual__] [size]    [`size_type`]       [`size<DomainT>::type`]       [`interval_type:: size_type`]      [`std::size_t`]     []]
[[]               []        [`difference_type`] [`difference <DomainT>::type`][`interval_type:: difference_type`][`std::size_t`]     []]
]                                     

[endsect][/ Associated Types]

[section Function Matrix]

[table
[[Placeholder]                  [Argument types]          [Description]]
[[`T`                         ] []                        [a container type]]             
[[`P`                         ] []                        [polymorhical container argument type]]             
[[`I,J`                       ] []                        [polymorhical iterator type]]
[[1,2,...                     ] []                        [number of implementations for this function]]             
[[A                           ] []                        [implementation generated by compilers]]             
[[[#element_type]         [*e]] [T::domain_type]          [the element type of the container]]
[[[#interval_type]        [*i]] [T::interval_type]        [the interval type of the container]]
[[[#itl_set_type]         [*s]] [__itl_set__]             [itl's set type]]
[[[#interval_set_types]   [*S]] [interval_sets]           [one of the interval set types]]
[[[#element_mapping_type] [*b]] [T::element_mapping_type] [type of the element mapping of the map]]
[[[#interval_mapping_type][*p]] [T::interval_mapping_type][type of the interval mapping of the map]]
[[[#itl_map_type]         [*m]] [__itl_map__]             [itl's map type]]
[[[#interval_map_types]   [*M]] [interval_maps]           [one of the interval map types]]
]

[memberref boost::itl::set::iterative_size `iterative_size`]

[table Itl Interfaces
[[T]      [interval][interval\nsets][interval\nmaps][itl::set][itl::map][std::set][std::map]]                                                      								   
[/                                           interval  itvset   itvmap  itl:set  itl:map  std:set  std:map]
[[['*Construct, copy, destruct*]]              [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[`T::T()`]                                    [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`T::T(const T&)`]                            [A]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`T::T(const P&)`]                            [ ]   [__eiS]  [__bpM]     [ ]      [ ]      [ ]      [ ]]
[[`T::T(const P&,...)`]                        [3]       [ ]      [ ]     [3]      [3]      [3]      [3]]
[[`T& T::operator=(const T&)`]                 [A]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`void T::swap(T&)`]                          [ ]       [1]      [1]     [1]      [1]      [1]      [1]]
[[['*Emptieness, containment*]]  [interval][interval\nsets][interval\nmaps][itl::set][itl::map][std::set][std::map]]
[[`void T::clear()`]                           [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`bool T::empty()const`]                      [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`bool T::contains(const P&)const`]         [__ei]  [__eiS][__eiS __bpM][__es]   [__bm]    [ ]      [ ]]
[[`bool T::contained_in(const P&)const`]      [__e]     [__S]    [__M]   [__s]    [__m]     [ ]      [ ]]
[[['*Equivalences and Orderings*]][interval][interval\nsets][interval\nmaps][itl::set][itl::map][std::set][std::map]]
[[`bool operator == (const T&, const T&)`]     [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`bool operator != (const T&, const T&)`]     [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`bool is_element_equal(const T&, const T&)`] [ ]       [1]      [1]     [1]      [1]      [ ]      [ ]]
[[`bool is_protonic_equal(const T&, const T&)`][ ]       [ ]      [1]     [ ]      [1]      [ ]      [ ]]
[[`bool operator <  (const T&, const T&)`]     [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`bool operator >  (const T&, const T&)`]     [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`bool operator <= (const T&, const T&)`]     [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`bool operator >= (const T&, const T&)`]     [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[['*Size*]]                    [interval][interval\nsets][interval\nmaps][itl::set][itl::map][std::set][std::map]]
[[`size_type T::size()const`]                  [1]       [1]      [1]     [1]      [1]      [1]      [1]]
[[`size_type T::cardinality()const`]           [1]       [1]      [1]     [1]      [1]      [ ]      [ ]]
[[`difference_type T::length()const`]          [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[`size_t T::iterative_size()const`]           [1]       [1]      [1]     [1]      [1]      [ ]      [ ]]
[[`size_t T::interval_count()const`]           [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[['*Range*]]                                  [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[`domain_type T::lower()const`]               [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[`domain_type T::upper()const`]               [1]       [1]      [1]     [ ]      [ ]      [ ]      [ ]]
[[['*Selection*]]                              [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[`J T::find(const domain_type&)`]             [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[`codomain_type& operator[] (const domain_type&)`][ ]    [ ]      [??]     [ ]      [1]      [ ]      [1]]
[[`codomain_type operator() (const domain_type&)const`][ ][ ]      [1?]     [ ]      [1?]      [ ]      [ ]]
[[['*Addition*]]                [interval][interval\nsets][interval\nmaps][itl::set][itl::map][std::set][std::map]]
[[`T& T::add(const P&)`]                       [ ]     [__ei]    [__bp]   [__e]   [__b]     [ ]      [ ]]
[[`T& operator +=(      T&, const P&)`]        [ ]     [__eiS]   [__bpM]  [__es]  [__bm]    [ ]      [ ]]
[[`T  operator + (const T&, const P&)`]        [ ]     [__eiS]   [__bpM]  [__es]  [__bm]    [ ]      [JODO test]]
[[`T& operator |=(      T&, const P&)`]        [ ]     [__eiS]   [__bpM]  [__es]  [__bm]    [ ]      [JODO test]]
[[`T operator  | (const T&, const P&)`]        [ ]     [__eiS]   [__bpM]  [__es]  [__bm]    [ ]      [JODO test]]
[[['*Subtraction*]]                            [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[`T& T::subtract(const P&)`]                  [ ]     [__ei]    [__bp]   [__e]   [__b]     [ ]      [ ]]
[[`T& operator -=(      T&, const P&)`]        [ ]     [__eiS]   [__bpM]  [__es]  [__bm]    [ ]      [ ]]
[[`T  operator - (const T&, const P&)`]        [ ]     [__eiS]   [__bpM]  [__es]  [__bm]    [ ]      [JODO test]]
[[['*Insertion, erasure*]]      [interval][interval\nsets][interval\nmaps][itl::set][itl::map][std::set][std::map]]
[[`V T::insert(const P&)`]                     [ ]     [__ei]    [__bp]   [__e]   [__b]    [__e]     [__b]]
[[`T& T::set(const P&)`]                       [ ]       [ ]    [__bp?]   [ ]    [__b?]     [ ]   [JODO]]
[[`T& T::erase(const P&)`]                     [ ]    [__eiS][__eiS __bpM][__e]   [__b]  [?__e]   [?__b]]
[[['*Intersection, symmetric difference*]]     [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[`void T::intersect(T&, const P&)const`]      [__i]  [__eiS][__eiS __bpM][ ]      [ ]      [ ]      [ ]]
[[`void T::add_intersection(T&, const P&)const`][][__eiS][__eiS __bpM][ ]     [ ]      [ ]      [ ]]
[[`T& operator &=(T&, const P&)`]              [__i]  [__eiS][__eiS __bpM][?__es][?__bm]    [ ]      [JODO]]
[[`T  operator & (const T&, const P&)`]        [__i]  [__eiS][__eiS __bpM][?__es][?__bm]    [ ]      [JODO]]
[[`T& operator ^=(T&, const P&)`]              [__i]  [__eiS][__eiS __bpM][?__es][?__bm]    [ ]      [JODO]]
[[`T  operator ^ (const T&, const P&)`]        [__i]  [__eiS][__eiS __bpM][?__es][?__bm]    [ ]      [JODO]]
[[['*Iterator related*]]                       [ ]       [ ]      [ ]     [ ]      [ ]      [ ]      [ ]]
[[`J T::begin()`]                              [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[`J T::end()`]                                [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[`J T::rbegin()`]                             [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[`J T::rend()`]                               [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[`J T::lower_bound(const I&)`]                [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
[[`J T::upper_bound(const I&)`]                [ ]       [2]      [2]     [2]      [2]      [2]      [2]]
]

[endsect]

[endsect]