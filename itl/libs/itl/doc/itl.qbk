[library Boost.Itl
    [quickbook 1.4]
    [authors [Faulhaber, Joachim]]
    [copyright 2007-2008 Joachim Faulhaber]
    [copyright 1999-2006 Cortex Software GmbH]
    [category container]
    [id optional]
    [dirname optional]
    [purpose
        Implements sets and maps as sets and maps of intervals
    ]
    [source-mode c++]
    [license
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
[@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ Macros will be used for links so we have a central place to change them ]
[def __itv__          [classref boost::itl::interval interval]]
[def __Itv__          [classref boost::itl::interval Interval]]
[def __itvs__         [classref boost::itl::interval intervals]]
[def __Itvs__         [classref boost::itl::interval Intervals]]
[def __itv_set__      [classref boost::itl::interval_set interval_set]]
[def __itv_sets__     [classref boost::itl::interval_set interval_sets]]
[def __itv_bsets__    [classref boost::itl::interval_base_set interval_sets]]
[def __Itv_bsets__    [classref boost::itl::interval_base_set Interval_sets]]

[def __Itv_set__      [classref boost::itl::interval_set Interval_set]]
[def __spl_itv_set__  [classref boost::itl::split_interval_set split_interval_set]]
[def __spl_itv_sets__ [classref boost::itl::split_interval_set split_interval_sets]]
[def __Spl_itv_set__  [classref boost::itl::split_interval_set Split_interval_set]]
[def __sep_itv_set__  [classref boost::itl::separate_interval_set separate_interval_set]]
[def __Sep_itv_set__  [classref boost::itl::separate_interval_set Separate_interval_set]]
[def __itv_map__      [classref boost::itl::interval_map interval_map]]
[def __itv_maps__     [classref boost::itl::interval_map interval_maps]]
[def __itv_bmaps__    [classref boost::itl::interval_base_map interval_maps]]
[def __Itv_bmaps__    [classref boost::itl::interval_base_map Interval_maps]]
[def __Itv_map__      [classref boost::itl::interval_map Interval_map]]
[def __spl_itv_map__  [classref boost::itl::split_interval_map split_interval_map]]
[def __Spl_itv_map__  [classref boost::itl::split_interval_map Split_interval_map]]

[def __itv_bse_set__  [classref boost::itl::interval_base_set interval_base_set]]
[def __e              [link element_type *e*]]
[def __i              [link interval_type *i*]]
[def __S              [link interval_set_types *S*]]
[def __b              [link element_mapping_type *b*]]
[def __p              [link interval_mapping_type *p*]]
[def __M              [link interval_map_types *M*]]
[def __ei             [link element_type *e*] [link interval_type *i*]]
[def __bp             [link element_mapping_type *b*] [link interval_mapping_type *p*]]
[def __eS             [link element_type *e*] [link interval_set_types *S*]]
[def __bM             [link element_mapping_type *b*] [link interval_map_types *M*]]
[def __eiS            [link element_type *e*] [link interval_type *i*] [link interval_set_types *S*]]
[def __bpM            [link element_mapping_type *b*] [link interval_mapping_type *p*] [link interval_map_types *M*]]


[/ Cited Boost resources ]

[/ Other web resources ]

[/ Icons ]

[def __SPACE__ [$images/space.png]]
[def __GO_TO__ [$images/callouts/R.png]]


[section Introduction]

[section Definition and Basic Example]

The Interval Template Library (ITL) offers *intervals* and two kinds of 
interval containers: *interval_sets* and *interval_maps*.

An __itv_bsets__ implements a [*set] ['(of elements)] using a ['*set*] of intervals.[br]
An __itv_bmaps__ implements a [*map] ['(of element value pairs)] using a ['*map*] of interval value pairs.

__Itv_bsets__ and __itv_bmaps__ thus expose two different aspects in
their interfaces: (1) The functionality of a set or a map, which is the more 
['abstract aspect]. And (2) the functionality of an interval container which
is the more specific and ['implementation related aspect]. In practice both 
aspects are useful and are therefore supported. 

The first aspect, that will be called ['*conceptual aspect*], is the more important one.
It means that we will commonly use any interval_set or interval_map like a normal
set or map ['*of elements*].

``
interval_set<int> mySet;
mySet.insert(42);
bool has_answer = mySet.contains(42);
``

The second aspect, that will be called ['*iterative aspect*], allows to exploit the
fact, that the elements of __itv_sets__ and __itv_maps__ are commonly clustered in
__itvs__ that we can iterate over.

``
// Switch on my favorite telecasts using an interval_set
interval<seconds> news(make_seconds("20:00:00"), make_seconds("20:15:00"));
interval<seconds> talk_show(make_seconds("22:45:30"), make_seconds("23:30:50"));
interval_set<seconds> myTvProgam;
myTVProgram.add(news).add(talk_show);

// Iterating over elements (seconds) would be silly
for(interval_set<seconds>::iterator telecast = myTvProgam.begin(); 
    telecast != myTvProgam.end(); ++telecast)
   TV.switch_on(*telecast);
``

Working with interval_sets and interval_maps can be 
beneficial whenever the elements of 
sets appear in contiguous chunks: __itvs__. This is obviously the 
case in many problem domains, namely in fields that deal with problems 
related to date and time. 

This is a first motivating example of a very small party, demonstrationg the 
['*aggregate on overlap*] principle ['*(aggrovering)*] on __itv_maps__:

In the example Mary enters the party first. She attends during the 
time interval [20:00,22:00). Harry enters later he stays within [21:00,23:00).
``
typedef set<string> guests;
interval_map<time, guests> party; 
party += make_pair(interval<time>::rightopen(20:00, 22:00), guests("Mary"));
party += make_pair(interval<time>::rightopen(21:00, 23:00), guests("Harry")); 
// party now contains
[20:00, 21:00)->{"Mary"} 
[21:00, 22:00)->{"Harry","Mary"} //guest sets aggregated on overlap
[22:00, 23:00)->{"Harry"}
``
On overlap of intervals, the corresponding name sets are accumulated. At
the points of overlap the intervals are split. The accumulation of content on
overlap of intervals is done via an operator += that has to be implemented
for the content parameter of the __itv_map__.

As can be seen from the example an __itv_map__ has both 
a ['*decompositional behavior*] (on the time dimension) as well as 
an ['*accumulative one*] (on the associated values). 
[endsect]

[section Interval Combining Styles]

When we add intervals or interval value pairs to interval containers,
the intervals can be added in different ways: Intervals can be
joined or splitted or kept separate. The different interval combining
styles are shown by example in the tables below.

[table Interval container's ways to combine intervals 
    [[]         [joining]       [separating]            [splitting]]
    [[set]      [[classref boost::itl::interval_set          interval_set]]  
	            [[classref boost::itl::separate_interval_set separate_interval_set]] 
				[[classref boost::itl::split_interval_set    split_interval_set]]]
    [[map]      [[classref boost::itl::interval_map          interval_map]]      
	            []   
				[[classref boost::itl::split_interval_map    split_interval_map]]]
	[[]         [Intervals are joined on overlap or touch\n(if associated values are equal).]
				[Intervals are joined on overlap, not on touch.]
				[Intervals are split on overlap.\nAll interval borders are preserved.]]
]

[table Interval combining styles by example
    [[]         [joining]       [separating]            [splitting]]
    [[set]      [[classref boost::itl::interval_set          interval_set] /A/]  
	            [[classref boost::itl::separate_interval_set separate_interval_set] /B/] 
				[[classref boost::itl::split_interval_set    split_interval_set] /C/]]
[[]			
[``
  {[1      3)          }
+       [2      4)
+                 [4 5)
= {[1                5)}``]
[``
  {[1      3)}         }
+       [2      4)
+                 [4 5)
= {[1           4)[4 5)}``]
[``
  {[1      3)          }
+       [2      4)
+                 [4 5)
= {[1 2)[2 3)[3 4)[4 5)}``]
]

    [[map]      [[classref boost::itl::interval_map          interval_map] /D/]      
	            []   
				[[classref boost::itl::split_interval_map    split_interval_map] /E/]]

[[]			
[``
  {[1      3)->1          }
+       [2      4)->1
+                 [4 5)->1
= {[1 2)[2 3)[3      5)   }
  | ->1  ->2     ->1      |``]
[]
[``
  {[1      3)->1          }
+       [2      4)->1
+                 [4 5)->1
= {[1 2)[2 3)[3 4)[4 5)   }
  | ->1  ->2  ->1  ->1    |``]
]
]

Note that =interval_sets= /A/, /B/ and /C/ represent the same set of elements ={1,2,3,4}= 
and =interval_maps= /D/ and /E/ represent the same map of elements [^{1->1, 2->2, 3->1, 4->1}].

[h4 Joining interval containers]

__Itv_set__ and __itv_map__ are always 
in a ['*minimal representation*]. This is useful in many cases, where the 
points of insertion or intersecton of intervals are not relevant. So in most 
instances [classref boost::itl::interval_set interval_set] and 
[classref boost::itl::interval_map Interval_map] will be the first choice 
for an interval container.

[h4 Splitting interval containers]

__Spl_itv_set__ and __spl_itv_map__ on the contrary 
have an ['*insertion memory*]. They do accumulate interval borders both 
from additions and intersections. This is specifically useful, if we want
to enrich an interval container with certain time grids, like e.g. months 
or calendar weeks or both. See example month_and_week_grid.cpp.

[endsect]

[endsect]

[/aggregate on overlap  aggrovering]
[/aggregate on collide  aggrolliding]
[/split on insertion sploning splonsing; split on addition splonadding, 
  spladding, splinsertion; decomposition on insertion]

[include examples.qbk]
[include interface.qbk]
[include acknowledgments.qbk]
[xinclude itldoc.xml]


14:46 18.11.2008