<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>The Extended Integer (XInt) Library: detail/internals.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>detail/internals.hpp</h1><a href="internals_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">/*</span>
<a name="l00003"></a>00003 <span class="comment">    The Extended Integer (XInt) Library</span>
<a name="l00004"></a>00004 <span class="comment">    A fast, portable C++ library for multi-precision integer math</span>
<a name="l00005"></a>00005 <span class="comment">    Copyright 2010 by Chad Nelson</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">    Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00008"></a>00008 <span class="comment">    See accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00009"></a>00009 <span class="comment">        http://www.boost.org/LICENSE_1_0.txt</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">    See http://www.boost.org/libs/xint for library home page.</span>
<a name="l00012"></a>00012 <span class="comment">*/</span>
<a name="l00013"></a>00013 
<a name="l00020"></a>00020 <span class="preprocessor">#ifndef BOOST_INCLUDED_XINT_INTERNALS_HPP</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_INCLUDED_XINT_INTERNALS_HPP</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="comment">// Leave this commented out to use it as a header-only library.</span>
<a name="l00024"></a>00024 <span class="comment">//#define BOOST_XINT_COMPILED_LIB</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;queue&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;cstddef&gt;</span> <span class="comment">// for size_t</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;boost/integer.hpp&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;boost/cstdint.hpp&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;boost/function.hpp&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;boost/type_traits.hpp&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;boost/static_assert.hpp&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="comment">// Uncomment this to use Boost.Move, which can improve the speed when using</span>
<a name="l00039"></a>00039 <span class="comment">// extremely large numbers.</span>
<a name="l00040"></a>00040 <span class="comment">//#define BOOST_XINT_USE_MOVE</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#ifdef BOOST_XINT_USE_MOVE</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;boost/move/move.hpp&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">    #define BOOST_XINT_COPY_ASSIGN_REF(type) BOOST_COPY_ASSIGN_REF(type)</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">    #define BOOST_XINT_COPYABLE_AND_MOVABLE(type) BOOST_COPYABLE_AND_MOVABLE(type)</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor">    #define BOOST_XINT_RV_REF(type) BOOST_RV_REF(type)</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">    #define BOOST_XINT_MOVE(value) boost::move(value)</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">    #define BOOST_XINT_FORWARD(type, value) boost::forward&lt;type&gt;(value)</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00050"></a><a class="code" href="classdisable__boost__rv__ref.html">00050</a> <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="classdisable__boost__rv__ref.html">disable_boost_rv_ref</a>: <span class="keyword">public</span> T { };
<a name="l00051"></a><a class="code" href="internals_8hpp.html#a8177a6a6c68ea042f7e644d8ef7128f9">00051</a> <span class="preprocessor">    #define BOOST_XINT_COPY_ASSIGN_REF(type) const type&amp;</span>
<a name="l00052"></a><a class="code" href="internals_8hpp.html#a5f5634ec80010f0f87b93320fa3419f9">00052</a> <span class="preprocessor"></span><span class="preprocessor">    #define BOOST_XINT_COPYABLE_AND_MOVABLE(type)</span>
<a name="l00053"></a><a class="code" href="internals_8hpp.html#a0533c283bce9e4d9468ea9b3a5ab509b">00053</a> <span class="preprocessor"></span><span class="preprocessor">    #define BOOST_XINT_RV_REF(type) disable_boost_rv_ref&lt;type&gt;</span>
<a name="l00054"></a><a class="code" href="internals_8hpp.html#a73c3b02410381da656b7cb59c7ba9314">00054</a> <span class="preprocessor"></span><span class="preprocessor">    #define BOOST_XINT_MOVE(value) value</span>
<a name="l00055"></a><a class="code" href="internals_8hpp.html#ad30e9ec163d1981dfee69c97d09ffd28">00055</a> <span class="preprocessor"></span><span class="preprocessor">    #define BOOST_XINT_FORWARD(type, value) value</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00058"></a><a class="code" href="namespaceboost.html">00058</a> <span class="keyword">namespace </span>boost {
<a name="l00059"></a>00059 
<a name="l00061"></a><a class="code" href="namespaceboost_1_1xint.html">00061</a> <span class="keyword">namespace </span>xint {
<a name="l00062"></a>00062 
<a name="l00064"></a><a class="code" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">00064</a> <span class="keyword">typedef</span> boost::function&lt;bool ()&gt; <a class="code" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547" title="A callback function takes no parameters and returns a bool.">callback_t</a>;
<a name="l00065"></a>00065 
<a name="l00067"></a><a class="code" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696">00067</a> <span class="keyword">const</span> <a class="code" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547" title="A callback function takes no parameters and returns a bool.">callback_t</a> <a class="code" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696" title="An empty callback_t, used as a default parameter for some functions.">no_callback</a>;
<a name="l00068"></a>00068 
<a name="l00070"></a><a class="code" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">00070</a> <span class="keyword">typedef</span> std::vector&lt;unsigned char&gt; <a class="code" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58" title="The format for the binary representations of integers.">binary_t</a>;
<a name="l00071"></a>00071 
<a name="l00074"></a><a class="code" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">00074</a> <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398" title="A value that can be used for the &amp;#39;base&amp;#39; parameter of the string-to-integer...">autobase</a> = (std::numeric_limits&lt;size_t&gt;::max)();
<a name="l00075"></a>00075 
<a name="l00077"></a>00077 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00078"></a><a class="code" href="classboost_1_1xint_1_1base__divide__t.html">00078</a> <span class="keyword">class </span><a class="code" href="classboost_1_1xint_1_1base__divide__t.html" title="Holds the results from a division-with-remainder call.">base_divide_t</a> {
<a name="l00079"></a>00079     <span class="keyword">public</span>:
<a name="l00080"></a><a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a78e4dd66f424388d1db839ef53e25997">00080</a>     <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a78e4dd66f424388d1db839ef53e25997">base_divide_t</a>() { }
<a name="l00081"></a><a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a1b7962768058ad19d8d3e848b1fc019e">00081</a>     <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a1b7962768058ad19d8d3e848b1fc019e">base_divide_t</a>(<span class="keyword">const</span> T&amp; q, <span class="keyword">const</span> T&amp; r): <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a7b3f254223974ed79663f9a0e4d1649c">quotient</a>(q), <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">remainder</a>(r) { }
<a name="l00082"></a><a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa9f43e464f328b0cc618f67e6e4d1d6f">00082</a>     <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a78e4dd66f424388d1db839ef53e25997">base_divide_t</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1xint_1_1base__divide__t.html" title="Holds the results from a division-with-remainder call.">base_divide_t&lt;T&gt;</a>&amp; copy):
<a name="l00083"></a>00083         <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a7b3f254223974ed79663f9a0e4d1649c">quotient</a>(copy.<a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a7b3f254223974ed79663f9a0e4d1649c">quotient</a>), <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">remainder</a>(copy.<a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">remainder</a>) { }
<a name="l00084"></a><a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aaa2df86aa70e8ac849cd6289a1f459b1">00084</a>     <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aaa2df86aa70e8ac849cd6289a1f459b1">base_divide_t</a>(<a class="code" href="internals_8hpp.html#a0533c283bce9e4d9468ea9b3a5ab509b">BOOST_XINT_RV_REF</a>(<a class="code" href="classboost_1_1xint_1_1base__divide__t.html" title="Holds the results from a division-with-remainder call.">base_divide_t</a>) move) {
<a name="l00085"></a>00085         <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a7b3f254223974ed79663f9a0e4d1649c">quotient</a>._swap(move.<a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a7b3f254223974ed79663f9a0e4d1649c">quotient</a>); <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">remainder</a>._swap(move.<a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">remainder</a>); }
<a name="l00086"></a>00086 
<a name="l00087"></a><a class="code" href="classboost_1_1xint_1_1base__divide__t.html#ac74a636871dd2988a4f654fc745426c7">00087</a>     <a class="code" href="classboost_1_1xint_1_1base__divide__t.html" title="Holds the results from a division-with-remainder call.">base_divide_t</a>&amp; <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#ac74a636871dd2988a4f654fc745426c7">operator=</a>(<a class="code" href="internals_8hpp.html#a8177a6a6c68ea042f7e644d8ef7128f9">BOOST_XINT_COPY_ASSIGN_REF</a>(<a class="code" href="classboost_1_1xint_1_1base__divide__t.html" title="Holds the results from a division-with-remainder call.">base_divide_t</a>) copy)
<a name="l00088"></a>00088         { <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a7b3f254223974ed79663f9a0e4d1649c">quotient</a> = copy.<a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a7b3f254223974ed79663f9a0e4d1649c">quotient</a>; <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">remainder</a> = copy.<a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">remainder</a>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00089"></a><a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a5f66ee628dc58d181b8c2886354909fb">00089</a>     <a class="code" href="classboost_1_1xint_1_1base__divide__t.html" title="Holds the results from a division-with-remainder call.">base_divide_t</a>&amp; <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a5f66ee628dc58d181b8c2886354909fb">operator=</a>(<a class="code" href="internals_8hpp.html#a0533c283bce9e4d9468ea9b3a5ab509b">BOOST_XINT_RV_REF</a>(<a class="code" href="classboost_1_1xint_1_1base__divide__t.html" title="Holds the results from a division-with-remainder call.">base_divide_t</a>) move) {
<a name="l00090"></a>00090         <span class="keyword">using</span> <a class="code" href="namespaceboost_1_1xint.html#a00ebb69a2c4e772f6ae9de36b4430d62">std::swap</a>;
<a name="l00091"></a>00091         <a class="code" href="namespaceboost_1_1xint.html#a00ebb69a2c4e772f6ae9de36b4430d62">swap</a>(<a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a7b3f254223974ed79663f9a0e4d1649c">quotient</a>, move.<a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a7b3f254223974ed79663f9a0e4d1649c">quotient</a>);
<a name="l00092"></a>00092         <a class="code" href="namespaceboost_1_1xint.html#a00ebb69a2c4e772f6ae9de36b4430d62">swap</a>(<a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">remainder</a>, move.<a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">remainder</a>);
<a name="l00093"></a>00093         <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00094"></a>00094 
<a name="l00095"></a><a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">00095</a>     T <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#a7b3f254223974ed79663f9a0e4d1649c">quotient</a>, <a class="code" href="classboost_1_1xint_1_1base__divide__t.html#aa79bd57f1bc85ceb86913fd0f81c9e2d">remainder</a>;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097     <span class="keyword">private</span>:
<a name="l00098"></a>00098     <a class="code" href="internals_8hpp.html#a5f5634ec80010f0f87b93320fa3419f9">BOOST_XINT_COPYABLE_AND_MOVABLE</a>(<a class="code" href="classboost_1_1xint_1_1base__divide__t.html" title="Holds the results from a division-with-remainder call.">base_divide_t</a>)
<a name="l00099"></a>00099 };
<a name="l00100"></a>00100 
<a name="l00102"></a><a class="code" href="namespaceboost_1_1xint_1_1detail.html">00102</a> <span class="keyword">namespace </span>detail {
<a name="l00104"></a>00104 
<a name="l00110"></a>00110 <span class="keyword">typedef</span> boost::uintmax_t doubledigit_t;
<a name="l00111"></a>00111 
<a name="l00117"></a>00117 <span class="keyword">typedef</span> boost::uint_t&lt;std::numeric_limits&lt;doubledigit_t&gt;::digits / 2&gt;::fast
<a name="l00118"></a>00118     digit_t;
<a name="l00119"></a>00119 
<a name="l00122"></a>00122 <span class="keyword">const</span> <span class="keywordtype">size_t</span>        minimum_digits    = 1;
<a name="l00123"></a>00123 <span class="keyword">const</span> <span class="keywordtype">size_t</span>        bits_per_digit    = std::numeric_limits&lt;digit_t&gt;::digits;
<a name="l00124"></a>00124 <span class="keyword">const</span> <span class="keywordtype">size_t</span>        digits_in_uintmax =
<a name="l00125"></a>00125     (std::numeric_limits&lt;boost::uintmax_t&gt;::digits + bits_per_digit - 1) /
<a name="l00126"></a>00126     bits_per_digit;
<a name="l00127"></a>00127 <span class="keyword">const</span> digit_t       digit_hibit       = (digit_t(1) &lt;&lt; (bits_per_digit-1));
<a name="l00128"></a>00128 <span class="keyword">const</span> doubledigit_t doubledigit_hibit = (doubledigit_t(1) &lt;&lt; (bits_per_digit*2-1));
<a name="l00129"></a>00129 <span class="keyword">const</span> doubledigit_t digit_overflowbit = (doubledigit_t(1) &lt;&lt; bits_per_digit);
<a name="l00130"></a>00130 <span class="keyword">const</span> digit_t       digit_mask        = digit_t(digit_overflowbit-1);
<a name="l00132"></a>00132 
<a name="l00134"></a>00134 
<a name="l00137"></a>00137 <span class="keyword">struct </span>raw_digits_t {
<a name="l00138"></a>00138     <span class="keyword">private</span>:
<a name="l00139"></a>00139     <span class="keywordtype">size_t</span> copy_count;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     <span class="keyword">public</span>:
<a name="l00142"></a>00142     <span class="keyword">const</span> <span class="keywordtype">size_t</span> max_length;
<a name="l00143"></a>00143     <span class="keyword">const</span> <span class="keywordtype">bool</span> readonly;
<a name="l00144"></a>00144     digit_t digits[minimum_digits]; <span class="comment">// Must be last data item, see &quot;struct hack&quot;</span>
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     raw_digits_t(<span class="keywordtype">size_t</span> max_len = 1, <span class="keywordtype">bool</span> ro = <span class="keyword">false</span>);
<a name="l00147"></a>00147     raw_digits_t(<span class="keywordtype">size_t</span> max_len, <span class="keywordtype">bool</span> ro, digit_t init);
<a name="l00148"></a>00148     <span class="keywordtype">size_t</span> copy(<span class="keyword">const</span> raw_digits_t&amp; c, <span class="keywordtype">size_t</span> length = 0);
<a name="l00149"></a>00149     <span class="keywordtype">void</span> copy(<span class="keyword">const</span> digit_t *s, <span class="keywordtype">size_t</span> length);
<a name="l00150"></a>00150     <span class="keywordtype">size_t</span> zero(<span class="keywordtype">size_t</span> length = 0);
<a name="l00151"></a>00151     <span class="keywordtype">size_t</span> copies() <span class="keyword">const</span>;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153     <span class="keyword">friend</span> <span class="keyword">class </span>base_digitmanager_t;
<a name="l00154"></a>00154 };
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="keyword">const</span> <span class="keywordtype">size_t</span> datasize = (<span class="keyword">sizeof</span>(raw_digits_t) + <span class="keyword">sizeof</span>(digit_t) - 1) /
<a name="l00157"></a>00157     <span class="keyword">sizeof</span>(digit_t);
<a name="l00158"></a>00158 
<a name="l00160"></a>00160 <span class="keyword">class </span>base_digitmanager_t {
<a name="l00161"></a>00161     <span class="keyword">public</span>:
<a name="l00162"></a>00162     base_digitmanager_t(): raw_data(0) { }
<a name="l00163"></a>00163     <span class="keyword">virtual</span> ~base_digitmanager_t() { };
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     raw_digits_t *<span class="keyword">get</span>() { <span class="keywordflow">return</span> raw_data; }
<a name="l00166"></a>00166     <span class="keyword">const</span> raw_digits_t *<span class="keyword">get</span>() <span class="keyword">const</span> { <span class="keywordflow">return</span> raw_data; }
<a name="l00167"></a>00167     <span class="keywordtype">void</span> reset(raw_digits_t *p) { <span class="keywordflow">if</span> (raw_data != p) { dec(); raw_data = p;
<a name="l00168"></a>00168         inc(); } }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170     raw_digits_t* operator-&gt;() { <span class="keywordflow">return</span> raw_data; }
<a name="l00171"></a>00171     <span class="keyword">const</span> raw_digits_t* operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> raw_data; }
<a name="l00172"></a>00172     <span class="keywordtype">void</span> copy(base_digitmanager_t *c, <span class="keywordtype">size_t</span> length) { raw_data-&gt;copy(
<a name="l00173"></a>00173         *c-&gt;raw_data, length); }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175     <span class="keywordtype">void</span> resize_and_uniquify(<span class="keywordtype">size_t</span> new_requested_max_length = 0);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177     <span class="keyword">virtual</span> base_digitmanager_t *new_of_type(base_digitmanager_t *copy = 0)
<a name="l00178"></a>00178         <span class="keyword">const</span> = 0;
<a name="l00179"></a>00179     <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> fixed_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00180"></a>00180 
<a name="l00188"></a>00188     <span class="keyword">virtual</span> <span class="keywordtype">void</span> beforemod() { }
<a name="l00189"></a>00189     <span class="keyword">virtual</span> <span class="keywordtype">void</span> aftermod() { }
<a name="l00190"></a>00190     <span class="keyword">virtual</span> <span class="keywordtype">void</span> endmod_hook(digit_t*) { }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     <span class="keyword">protected</span>:
<a name="l00194"></a>00194     <span class="keywordtype">void</span> inc() { <span class="keywordflow">if</span> (raw_data) ++raw_data-&gt;copy_count; }
<a name="l00195"></a>00195     <span class="keywordtype">void</span> dec() { <span class="keywordflow">if</span> (raw_data &amp;&amp; --raw_data-&gt;copy_count == 0)
<a name="l00196"></a>00196             dealloc(raw_data); }
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     raw_digits_t *alloc(<span class="keywordtype">size_t</span> requested_length, <span class="keywordtype">bool</span> readonly = <span class="keyword">false</span>)
<a name="l00199"></a>00199         <span class="keyword">const</span>;
<a name="l00200"></a>00200     raw_digits_t *realloc(raw_digits_t *data, <span class="keywordtype">size_t</span> new_requested_length)
<a name="l00201"></a>00201         <span class="keyword">const</span>;
<a name="l00202"></a>00202     <span class="keywordtype">void</span> dealloc(raw_digits_t *data) <span class="keyword">const</span>;
<a name="l00203"></a>00203 
<a name="l00210"></a>00210     <span class="keyword">virtual</span> digit_t* raw_allocate(<span class="keywordtype">size_t</span> requested_length) <span class="keyword">const</span> = 0;
<a name="l00211"></a>00211     <span class="keyword">virtual</span> digit_t* raw_reallocate(digit_t *data, <span class="keywordtype">size_t</span> new_requested_length)<span class="keyword"></span>
<a name="l00212"></a>00212 <span class="keyword">        const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00213"></a>00213     <span class="keyword">virtual</span> <span class="keywordtype">void</span> raw_deallocate(digit_t *data, <span class="keywordtype">size_t</span> length) <span class="keyword">const</span> = 0;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     <span class="keyword">virtual</span> raw_digits_t *zerodata() <span class="keyword">const</span> = 0;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218     raw_digits_t *raw_data;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a00ebb69a2c4e772f6ae9de36b4430d62">swap</a>(base_digitmanager_t&amp; p1, base_digitmanager_t&amp; p2);
<a name="l00221"></a>00221 };
<a name="l00222"></a>00222 
<a name="l00225"></a>00225 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Alloc = std::allocator&lt;digit_t&gt;, <span class="keywordtype">bool</span> Threadsafe = true, <span class="keywordtype">bool</span>
<a name="l00226"></a>00226     Secure = false&gt;
<a name="l00227"></a>00227 <span class="keyword">class </span>digitmanager_t: <span class="keyword">public</span> base_digitmanager_t {
<a name="l00228"></a>00228     BOOST_STATIC_ASSERT(<span class="keyword">sizeof</span>(<span class="keyword">typename</span> Alloc::value_type) == <span class="keyword">sizeof</span>(digit_t));
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     <span class="keyword">public</span>:
<a name="l00231"></a>00231     digitmanager_t() { reset(zerodata()); }
<a name="l00232"></a>00232     digitmanager_t(<span class="keywordtype">size_t</span> requested_length, <span class="keywordtype">bool</span> readonly = <span class="keyword">false</span>)
<a name="l00233"></a>00233         { <span class="keywordflow">if</span> (requested_length &gt; 0) reset(alloc(requested_length, readonly)); }
<a name="l00234"></a>00234     digitmanager_t(<span class="keyword">const</span> base_digitmanager_t&amp; copy) {
<a name="l00235"></a>00235         base_digitmanager_t&amp; c(const_cast&lt;base_digitmanager_t&amp;&gt;(copy));
<a name="l00236"></a>00236         reset(c.get()); }
<a name="l00237"></a>00237     <span class="keyword">virtual</span> ~digitmanager_t() { dec(); }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="keyword">virtual</span> base_digitmanager_t *new_of_type(base_digitmanager_t *copy = 0)<span class="keyword"></span>
<a name="l00240"></a>00240 <span class="keyword">        const </span>{ <span class="keywordflow">if</span> (copy != 0) <span class="keywordflow">return</span> <span class="keyword">new</span> digitmanager_t&lt;Alloc, Threadsafe,
<a name="l00241"></a>00241         Secure&gt;(*copy); <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">new</span> digitmanager_t&lt;Alloc, Threadsafe,
<a name="l00242"></a>00242         Secure&gt;; }
<a name="l00243"></a>00243     <span class="keyword">virtual</span> <span class="keywordtype">void</span> aftermod() { <span class="keywordflow">if</span> (Threadsafe &amp;&amp; raw_data &amp;&amp; raw_data-&gt;copies() &gt;
<a name="l00244"></a>00244         1) resize_and_uniquify(); }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     <span class="keyword">protected</span>:
<a name="l00247"></a>00247     <span class="keyword">virtual</span> digit_t* raw_allocate(<span class="keywordtype">size_t</span> requested_length)<span class="keyword"> const </span>{
<a name="l00248"></a>00248         <span class="keywordflow">return</span> allocator.allocate(requested_length); }
<a name="l00249"></a>00249     <span class="keyword">virtual</span> <span class="keywordtype">void</span> raw_deallocate(digit_t *data, <span class="keywordtype">size_t</span> length)<span class="keyword"> const </span>{
<a name="l00250"></a>00250         <span class="keywordflow">if</span> (Secure) memset(data, 0, length * <span class="keyword">sizeof</span>(digit_t));
<a name="l00251"></a>00251         allocator.deallocate(data, length); }
<a name="l00252"></a>00252     <span class="keyword">virtual</span> raw_digits_t *zerodata()<span class="keyword"> const </span>{ <span class="keyword">static</span> digitmanager_t z(1, <span class="keyword">true</span>);
<a name="l00253"></a>00253         <span class="keywordflow">return</span> z.raw_data; }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     <span class="keyword">static</span> Alloc allocator;
<a name="l00256"></a>00256 };
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Alloc, <span class="keywordtype">bool</span> Threadsafe, <span class="keywordtype">bool</span> Secure&gt;
<a name="l00259"></a>00259 Alloc digitmanager_t&lt;Alloc, Threadsafe, Secure&gt;::allocator;
<a name="l00260"></a>00260 
<a name="l00262"></a>00262 
<a name="l00264"></a>00264 <span class="keyword">struct </span>data_t {
<a name="l00265"></a>00265     <span class="keyword">typedef</span> <a class="code" href="classboost_1_1xint_1_1base__divide__t.html" title="Holds the results from a division-with-remainder call.">base_divide_t&lt;data_t&gt;</a> divide_t;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267     <span class="keywordtype">size_t</span> length;
<a name="l00268"></a>00268     <span class="keywordtype">bool</span> negative;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270     <span class="keyword">explicit</span> data_t(base_digitmanager_t &amp;holder, <span class="keywordtype">size_t</span> len = 1, <span class="keywordtype">bool</span> neg =
<a name="l00271"></a>00271         <span class="keyword">false</span>);
<a name="l00272"></a>00272     <span class="keyword">explicit</span> data_t(base_digitmanager_t *holder);
<a name="l00273"></a>00273     data_t(<span class="keyword">const</span> data_t&amp; copy);
<a name="l00274"></a>00274     data_t(<span class="keyword">const</span> data_t&amp; copy, <span class="keywordtype">bool</span> negative);
<a name="l00275"></a>00275     ~data_t();
<a name="l00276"></a>00276 
<a name="l00277"></a>00277     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00278"></a>00278     data_t(base_digitmanager_t *holder_to_copy, T n, <span class="keywordtype">size_t</span> prealloc = 0,
<a name="l00279"></a>00279         <span class="keyword">typename</span> boost::enable_if&lt;boost::is_integral&lt;T&gt; &gt;::type* = 0);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     base_digitmanager_t *new_holder() <span class="keyword">const</span>;
<a name="l00282"></a>00282     <span class="keyword">const</span> base_digitmanager_t *holder() <span class="keyword">const</span>;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     data_t duplicate() <span class="keyword">const</span>;
<a name="l00285"></a>00285     <span class="keywordtype">void</span> duplicate_data(<span class="keyword">const</span> data_t copy);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     <span class="keywordtype">void</span> reset(data_t p);
<a name="l00288"></a>00288     data_t&amp; operator=(<span class="keyword">const</span> data_t&amp; p);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290     <span class="keywordtype">bool</span> same_storage(<span class="keyword">const</span> data_t n) <span class="keyword">const</span>;
<a name="l00291"></a>00291     <span class="keywordtype">bool</span> is_unique() <span class="keyword">const</span>;
<a name="l00292"></a>00292     <span class="keywordtype">void</span> make_unique();
<a name="l00293"></a>00293 
<a name="l00294"></a>00294     <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keywordtype">int</span> n);
<a name="l00295"></a>00295     <span class="keywordtype">void</span> set_signed(boost::intmax_t n);
<a name="l00296"></a>00296     <span class="keywordtype">void</span> set_unsigned(boost::uintmax_t n, <span class="keywordtype">bool</span> neg = <span class="keyword">false</span>);
<a name="l00297"></a>00297 
<a name="l00298"></a>00298     digit_t get_digit(<span class="keywordtype">size_t</span> i) <span class="keyword">const</span>;
<a name="l00299"></a>00299     digit_t operator[](<span class="keywordtype">size_t</span> i);
<a name="l00300"></a>00300     digit_t operator[](<span class="keywordtype">size_t</span> i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> get_digit(i); }
<a name="l00301"></a>00301     digit_t *digits();
<a name="l00302"></a>00302     <span class="keyword">const</span> digit_t *digits() <span class="keyword">const</span>;
<a name="l00303"></a>00303     <span class="keywordtype">size_t</span> max_length() <span class="keyword">const</span>;
<a name="l00304"></a>00304     <span class="keywordtype">bool</span> is_fixed_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (dataholder-&gt;fixed_length() &gt; 0); }
<a name="l00305"></a>00305 
<a name="l00306"></a>00306     <span class="keywordtype">bool</span> is_zero() <span class="keyword">const</span>;
<a name="l00307"></a>00307     <span class="keyword">const</span> data_t <a class="code" href="namespaceboost_1_1xint.html#a22c29f49cfee8ee7bf809db665e1d9d7">abs</a>() <span class="keyword">const</span>;
<a name="l00308"></a>00308     <span class="keyword">const</span> data_t negate() <span class="keyword">const</span>;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keywordtype">void</span> extend(<span class="keywordtype">size_t</span> new_length = 0, <span class="keywordtype">bool</span> skip_mod = <span class="keyword">false</span>);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     <span class="keywordtype">void</span> from_string(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">size_t</span> length, <span class="keywordtype">size_t</span> base);
<a name="l00313"></a>00313     <span class="keywordtype">void</span> from_string(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">char</span> **endptr, <span class="keywordtype">size_t</span> base);
<a name="l00314"></a>00314     <span class="keywordtype">void</span> from_string(<span class="keyword">const</span> std::string&amp; str, <span class="keywordtype">size_t</span> base = 10);
<a name="l00315"></a>00315     <span class="keywordtype">void</span> from_binary(<a class="code" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58" title="The format for the binary representations of integers.">xint::binary_t</a> b, <span class="keywordtype">size_t</span> bits = 0);
<a name="l00316"></a>00316 
<a name="l00323"></a>00323 
<a name="l00324"></a>00324     <span class="keywordtype">void</span> beginmod(<span class="keywordtype">size_t</span> requested_size = 0, <span class="keywordtype">bool</span> extend = <span class="keyword">false</span>);
<a name="l00325"></a>00325     <span class="keywordtype">void</span> endmod(<span class="keywordtype">bool</span> allow_negative_zero = <span class="keyword">false</span>);
<a name="l00326"></a>00326     <span class="keywordtype">void</span> beginendmod() { beginmod(); digits(); endmod(<span class="keyword">true</span>); }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329     <span class="keywordtype">int</span> sign(<span class="keywordtype">bool</span> signed_zero = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00330"></a>00330     <span class="keywordtype">bool</span> is_odd() <span class="keyword">const</span>;
<a name="l00331"></a>00331     <span class="keywordtype">bool</span> is_even() <span class="keyword">const</span>;
<a name="l00332"></a>00332     <span class="keywordtype">bool</span> is_nan()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (dataholder-&gt;get() == 0); }
<a name="l00333"></a>00333     <span class="keywordtype">size_t</span> hex_digits() <span class="keyword">const</span>;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     data_t&amp;       operator++();    <span class="comment">// Preincrement</span>
<a name="l00336"></a>00336     data_t&amp;       operator--();    <span class="comment">// Predecrement</span>
<a name="l00337"></a>00337     data_t        operator++(<span class="keywordtype">int</span>); <span class="comment">// Postincrement</span>
<a name="l00338"></a>00338     data_t        operator--(<span class="keywordtype">int</span>); <span class="comment">// Postdecrement</span>
<a name="l00339"></a>00339 
<a name="l00340"></a>00340     <span class="keywordtype">bool</span>          operator!()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> is_zero(); }
<a name="l00341"></a>00341     data_t        <a class="code" href="namespaceboost_1_1xint.html#af29f603561c73ae4dfefa314f854a9b9">operator-</a>() <span class="keyword">const</span>;
<a name="l00342"></a>00342     data_t&amp;       <a class="code" href="namespaceboost_1_1xint.html#a1e894e947435664ba17c27a93c7325e1">operator+</a>()       { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00343"></a>00343     <span class="keyword">const</span> data_t&amp; <a class="code" href="namespaceboost_1_1xint.html#a1e894e947435664ba17c27a93c7325e1">operator+</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00344"></a>00344     <span class="comment">// Fixed-size types can also implement operator~</span>
<a name="l00345"></a>00345 
<a name="l00346"></a>00346     data_t&amp;       operator+=(<span class="keyword">const</span> data_t b);
<a name="l00347"></a>00347     data_t&amp;       operator-=(<span class="keyword">const</span> data_t b);
<a name="l00348"></a>00348     data_t&amp;       operator*=(<span class="keyword">const</span> data_t b);
<a name="l00349"></a>00349     data_t&amp;       operator/=(<span class="keyword">const</span> data_t b);
<a name="l00350"></a>00350     data_t&amp;       operator%=(<span class="keyword">const</span> data_t b);
<a name="l00351"></a>00351 
<a name="l00352"></a>00352     data_t&amp;       operator&amp;=(<span class="keyword">const</span> data_t n);
<a name="l00353"></a>00353     data_t&amp;       operator|=(<span class="keyword">const</span> data_t n);
<a name="l00354"></a>00354     data_t&amp;       operator^=(<span class="keyword">const</span> data_t n);
<a name="l00355"></a>00355     data_t&amp;       operator&lt;&lt;=(<span class="keywordtype">size_t</span> shift);
<a name="l00356"></a>00356     data_t&amp;       operator&gt;&gt;=(<span class="keywordtype">size_t</span> shift);
<a name="l00357"></a>00357 
<a name="l00358"></a>00358     <span class="keyword">static</span> <span class="keywordtype">size_t</span> bits_to_digits(<span class="keywordtype">size_t</span> bits) { <span class="keywordflow">return</span> (bits + bits_per_digit -
<a name="l00359"></a>00359         1) / bits_per_digit; }
<a name="l00360"></a>00360 
<a name="l00362"></a>00362     <span class="keyword">private</span>:
<a name="l00363"></a>00363     digit_t *digits(<span class="keywordtype">bool</span>) { <span class="keywordflow">return</span> (*dataholder)-&gt;digits; }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365     base_digitmanager_t * <span class="keyword">const</span> dataholder;
<a name="l00366"></a>00366     <span class="keyword">const</span> <span class="keywordtype">bool</span> holder_managed_elsewhere;
<a name="l00367"></a>00367     <span class="keywordtype">size_t</span> modcount;
<a name="l00368"></a>00368     <span class="keywordtype">size_t</span> mod_requested_size;
<a name="l00369"></a>00369     <span class="keywordtype">bool</span> mod_requested_extend;
<a name="l00370"></a>00370     <span class="keywordtype">bool</span> call_endmod_hook;
<a name="l00371"></a>00371 
<a name="l00372"></a>00372     <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a00ebb69a2c4e772f6ae9de36b4430d62">swap</a>(data_t&amp; p1, data_t&amp; p2);
<a name="l00373"></a>00373 };
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="comment">// Conversion functions</span>
<a name="l00376"></a>00376 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T <a class="code" href="namespaceboost_1_1xint.html#addfb10ab763fc55ecd4123c9a93769a0">to</a>(<span class="keyword">const</span> data_t n, <span class="keyword">typename</span>
<a name="l00377"></a>00377     boost::enable_if&lt;boost::is_integral&lt;T&gt; &gt;::type* = 0);
<a name="l00378"></a>00378 std::string <a class="code" href="namespaceboost_1_1xint.html#a6ae4ddf930587218746f08a2a5982746">to_string</a>(<span class="keyword">const</span> data_t n, <span class="keywordtype">size_t</span> base = 10, <span class="keywordtype">bool</span> uppercase = <span class="keyword">false</span>);
<a name="l00379"></a>00379 <a class="code" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58" title="The format for the binary representations of integers.">xint::binary_t</a> <a class="code" href="namespaceboost_1_1xint.html#ac1c6eb0f3c5166761d81503fa68f4b78">to_binary</a>(<span class="keyword">const</span> data_t n, <span class="keywordtype">size_t</span> bits = 0);
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="comment">// Bit-manipulation functions</span>
<a name="l00382"></a>00382 <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1xint.html#ab9f07ea184f62952ec0bc51ae7f63946">getbit</a>(<span class="keyword">const</span> data_t n, <span class="keywordtype">size_t</span> bit_index);
<a name="l00383"></a>00383 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a677abb914051570846048717ff0a7172">setbit</a>(data_t&amp; n, <span class="keywordtype">size_t</span> bit_index);
<a name="l00384"></a>00384 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a05dfa039837daba29cfac939335b8364">clearbit</a>(data_t&amp; n, <span class="keywordtype">size_t</span> bit_index);
<a name="l00385"></a>00385 <span class="keywordtype">size_t</span> <a class="code" href="namespaceboost_1_1xint.html#a88132067ca7e259160bcb7ed0b51e34f">lowestbit</a>(<span class="keyword">const</span> data_t n, <span class="keywordtype">size_t</span> valueIfZero = 0);
<a name="l00386"></a>00386 <span class="keywordtype">size_t</span> <a class="code" href="namespaceboost_1_1xint.html#a4eb6d95cc77c2f1fe1e7c7c1bf81260b">highestbit</a>(<span class="keyword">const</span> data_t n, <span class="keywordtype">size_t</span> valueIfZero = 0);
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 <span class="comment">// Random and prime number functions</span>
<a name="l00389"></a>00389 <span class="keywordtype">int</span> <a class="code" href="namespaceboost_1_1xint.html#a0f70e8b365600e14df023c83435a56ff">is_prime</a>(<span class="keyword">const</span> data_t n, <a class="code" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547" title="A callback function takes no parameters and returns a bool.">callback_t</a> callback = <a class="code" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696" title="An empty callback_t, used as a default parameter for some functions.">no_callback</a>);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="comment">// Comparison Operators</span>
<a name="l00392"></a>00392 <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1xint.html#a921174a41a68a6eef2584526590c18cf">operator&lt;</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00393"></a>00393 <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1xint.html#a492d33d92db8bf3b6b6221b8e1933228">operator&gt;</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00394"></a>00394 <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1xint.html#a980f9747bff82e9cf8744151fc91a108">operator&lt;=</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00395"></a>00395 <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1xint.html#ab47039ec5d5e120f869cf2d5f8d63843">operator&gt;=</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00396"></a>00396 <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1xint.html#ac9268bd409f006775f248d03213282d5">operator==</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00397"></a>00397 <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1xint.html#a3ae00595a180a21d326ad50a072add0f">operator!=</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="comment">// Mathematical operators</span>
<a name="l00400"></a>00400 data_t <a class="code" href="namespaceboost_1_1xint.html#a1e894e947435664ba17c27a93c7325e1">operator+</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00401"></a>00401 data_t <a class="code" href="namespaceboost_1_1xint.html#af29f603561c73ae4dfefa314f854a9b9">operator-</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00402"></a>00402 data_t <a class="code" href="namespaceboost_1_1xint.html#af877fa3d7e129eb0ea0d873396868723">operator*</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00403"></a>00403 data_t <a class="code" href="namespaceboost_1_1xint.html#a2606613cee80fbd4fd17100d6d0e09b9">operator/</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00404"></a>00404 data_t <a class="code" href="namespaceboost_1_1xint.html#a3b804d111a60509665d6a7227039aee9">operator%</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 <span class="comment">// Bitwise operators</span>
<a name="l00407"></a>00407 data_t <a class="code" href="namespaceboost_1_1xint.html#ad86517e5d3b5826470694001075de255">operator&amp;</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00408"></a>00408 data_t <a class="code" href="namespaceboost_1_1xint.html#a2e0a49149f74db4161870090d948e817">operator|</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00409"></a>00409 data_t <a class="code" href="namespaceboost_1_1xint.html#a964396cc2b187769a3f45a7b348ce60c">operator^</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2);
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="comment">// Shift operators</span>
<a name="l00412"></a>00412 data_t <a class="code" href="namespaceboost_1_1xint.html#a21f7b0cbf5d79162f157c107873db431">operator&lt;&lt;</a>(<span class="keyword">const</span> data_t n, <span class="keywordtype">size_t</span> by);
<a name="l00413"></a>00413 data_t <a class="code" href="namespaceboost_1_1xint.html#a177570efda84175d3ea979894f63e5b8">operator&gt;&gt;</a>(<span class="keyword">const</span> data_t n, <span class="keywordtype">size_t</span> by);
<a name="l00414"></a>00414 
<a name="l00415"></a>00415 <span class="comment">// Miscellaneous</span>
<a name="l00416"></a>00416 data_t <a class="code" href="namespaceboost_1_1xint.html#a22c29f49cfee8ee7bf809db665e1d9d7">abs</a>(<span class="keyword">const</span> data_t n);
<a name="l00417"></a>00417 <span class="keywordtype">size_t</span> <a class="code" href="namespaceboost_1_1xint.html#a9d9b4f302607bcf96bd2ab2c3145f453">log2</a>(<span class="keyword">const</span> data_t n);
<a name="l00418"></a>00418 <span class="keywordtype">int</span> <a class="code" href="namespaceboost_1_1xint.html#a39a3143ef1f03a35f2b7409b365fc853">compare</a>(<span class="keyword">const</span> data_t n1, <span class="keyword">const</span> data_t n2, <span class="keywordtype">bool</span> ignoresign = <span class="keyword">false</span>);
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a29a7d787472df22c7c554af6588e9102">pow</a>(data_t&amp; target, <span class="keyword">const</span> data_t n, <span class="keyword">const</span> data_t exponent);
<a name="l00421"></a>00421 <span class="keywordtype">void</span> pow2(data_t&amp; target, <span class="keywordtype">size_t</span> exponent);
<a name="l00422"></a>00422 <span class="keywordtype">void</span> factorial(data_t&amp; target, <span class="keywordtype">size_t</span> n);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a3f266530ae26fd9553a7b965fa1db2ea">sqrt</a>(data_t&amp; target, <span class="keyword">const</span> data_t n);
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a808dafe43afa6f06a5a44b0e956b885a">gcd</a>(data_t&amp; target, <span class="keyword">const</span> data_t num1, <span class="keyword">const</span> data_t num2);
<a name="l00427"></a>00427 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a0ef1c4af129617e9d5f01f96edf2b867">lcm</a>(data_t&amp; target, <span class="keyword">const</span> data_t num1, <span class="keyword">const</span> data_t num2);
<a name="l00428"></a>00428 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#ac628e1a39065df013c263455992c00eb">invmod</a>(data_t&amp; target, <span class="keyword">const</span> data_t n, <span class="keyword">const</span> data_t modulus);
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a08936f9fc3d9b799f98604bedefb1ee8">mulmod</a>(data_t&amp; target, <span class="keyword">const</span> data_t n, <span class="keyword">const</span> data_t by, <span class="keyword">const</span> data_t
<a name="l00431"></a>00431     modulus);
<a name="l00432"></a>00432 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a250379d4753bbd26002eac066114b756">sqrmod</a>(data_t&amp; target, <span class="keyword">const</span> data_t n, <span class="keyword">const</span> data_t modulus);
<a name="l00433"></a>00433 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a3df211c7086c4652a7e12492d7d103f7">powmod</a>(data_t&amp; target, <span class="keyword">const</span> data_t n, <span class="keyword">const</span> data_t exponent, <span class="keyword">const</span> data_t
<a name="l00434"></a>00434     modulus, <span class="keywordtype">bool</span> noMontgomery=<span class="keyword">false</span>);
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#ac3f13e684b487865506362e4b382bc11">square</a>(data_t&amp; target, <span class="keyword">const</span> data_t n);
<a name="l00437"></a>00437 data_t::divide_t <a class="code" href="namespaceboost_1_1xint.html#a729653da022f22652cd5aa2d29f0c8fd">divide</a>(<span class="keyword">const</span> data_t d1, <span class="keyword">const</span> data_t d2);
<a name="l00438"></a>00438 <span class="keywordtype">void</span> <a class="code" href="namespaceboost_1_1xint.html#a729653da022f22652cd5aa2d29f0c8fd">divide</a>(data_t&amp; qtarget, data_t&amp; rtarget, <span class="keyword">const</span> data_t d1, <span class="keyword">const</span> data_t d2);
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="keywordtype">size_t</span> log10_bits(<span class="keywordtype">size_t</span> bits);
<a name="l00441"></a>00441 
<a name="l00443"></a>00443 } <span class="comment">// namespace detail</span>
<a name="l00444"></a>00444 } <span class="comment">// namespace xint</span>
<a name="l00445"></a>00445 } <span class="comment">// namespace boost</span>
<a name="l00446"></a>00446 
<a name="l00448"></a>00448 <span class="comment">// Function templates</span>
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 <span class="preprocessor">#include &quot;../exceptions.hpp&quot;</span>
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 <span class="keyword">namespace </span>boost {
<a name="l00453"></a>00453 <span class="keyword">namespace </span>xint {
<a name="l00454"></a>00454 <span class="keyword">namespace </span>detail {
<a name="l00456"></a>00456 
<a name="l00457"></a>00457 <span class="keywordtype">size_t</span> log2_base(boost::uintmax_t n, <span class="keywordtype">size_t</span> maxbits);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00460"></a>00460 data_t::data_t(base_digitmanager_t *holder, T n, <span class="keywordtype">size_t</span> prealloc, <span class="keyword">typename</span>
<a name="l00461"></a>00461     boost::enable_if&lt;boost::is_integral&lt;T&gt; &gt;::type*): dataholder(holder),
<a name="l00462"></a>00462     holder_managed_elsewhere(false), modcount(0)
<a name="l00463"></a>00463 {
<a name="l00464"></a>00464     beginmod(prealloc);
<a name="l00465"></a>00465     <span class="keywordflow">if</span> (std::numeric_limits&lt;T&gt;::is_signed) set_signed(n);
<a name="l00466"></a>00466     <span class="keywordflow">else</span> set_unsigned(n);
<a name="l00467"></a>00467     endmod();
<a name="l00468"></a>00468 }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00471"></a>00471 <span class="keywordtype">size_t</span> log2_helper(<span class="keyword">const</span> T n,
<a name="l00472"></a>00472     <span class="keyword">typename</span> boost::enable_if&lt;boost::is_unsigned&lt;T&gt; &gt;::type* = 0)
<a name="l00473"></a>00473 {
<a name="l00474"></a>00474     <span class="keywordflow">return</span> log2_base(n, std::numeric_limits&lt;T&gt;::digits);
<a name="l00475"></a>00475 }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00478"></a>00478 <span class="keywordtype">size_t</span> log2_helper(<span class="keyword">const</span> T n,
<a name="l00479"></a>00479     <span class="keyword">typename</span> boost::enable_if&lt;boost::is_signed&lt;T&gt; &gt;::type* = 0)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::make_unsigned&lt;T&gt;::type uT;
<a name="l00482"></a>00482     T nn = (n &lt; 0 ? -n : n);
<a name="l00483"></a>00483     <span class="keywordflow">return</span> log2_base(static_cast&lt;uT&gt;(nn), std::numeric_limits&lt;T&gt;::digits);
<a name="l00484"></a>00484 }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00487"></a>00487 <span class="keywordtype">size_t</span> <a class="code" href="namespaceboost_1_1xint.html#a9d9b4f302607bcf96bd2ab2c3145f453">log2</a>(<span class="keyword">const</span> T n,
<a name="l00488"></a>00488     <span class="keyword">typename</span> boost::enable_if&lt;boost::is_integral&lt;T&gt; &gt;::type* = 0)
<a name="l00489"></a>00489 {
<a name="l00490"></a>00490     <span class="keywordflow">return</span> log2_helper(n);
<a name="l00491"></a>00491 }
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00494"></a>00494 T <a class="code" href="namespaceboost_1_1xint.html#addfb10ab763fc55ecd4123c9a93769a0">to</a>(<span class="keyword">const</span> data_t n, <span class="keyword">typename</span> boost::enable_if&lt;boost::is_integral&lt;T&gt; &gt;::type*) {
<a name="l00495"></a>00495     <span class="keyword">using</span> std::numeric_limits;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497     <span class="comment">// We&#39;ve got to use an unfixed manager, rather than n&#39;s manager, because</span>
<a name="l00498"></a>00498     <span class="comment">// the first n might be a fixed_integer_t which would screw up later calls</span>
<a name="l00499"></a>00499     <span class="comment">// for other types.</span>
<a name="l00500"></a>00500     <span class="keyword">static</span> digitmanager_t&lt;&gt; unfixed_manager;
<a name="l00501"></a>00501     <span class="keyword">static</span> <span class="keyword">const</span> data_t min(unfixed_manager.new_of_type(),
<a name="l00502"></a>00502         (numeric_limits&lt;T&gt;::min)());
<a name="l00503"></a>00503     <span class="keyword">static</span> <span class="keyword">const</span> data_t max(unfixed_manager.new_of_type(),
<a name="l00504"></a>00504         (numeric_limits&lt;T&gt;::max)());
<a name="l00505"></a>00505     <span class="keywordflow">if</span> (n &lt; min || n &gt; max) <span class="keywordflow">throw</span> exceptions::too_big(<span class="stringliteral">&quot;value out of range for &quot;</span>
<a name="l00506"></a>00506         <span class="stringliteral">&quot;requested conversion&quot;</span>);
<a name="l00507"></a>00507 
<a name="l00508"></a>00508     T rval = 0, shift = T(digit_overflowbit);
<a name="l00509"></a>00509     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; n.length; ++x) {
<a name="l00510"></a>00510         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(T) &gt; <span class="keyword">sizeof</span>(digit_t)) rval *= shift;
<a name="l00511"></a>00511         rval += <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(n[n.length - x - 1]);
<a name="l00512"></a>00512     }
<a name="l00513"></a>00513     <span class="keywordflow">if</span> (n.negative) rval *= -1;
<a name="l00514"></a>00514     <span class="keywordflow">return</span> rval;
<a name="l00515"></a>00515 }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keywordtype">char</span>T, <span class="keyword">typename</span> traits&gt;
<a name="l00518"></a>00518 <span class="keyword">inline</span> std::basic_ostream&lt;charT,traits&gt;&amp; <a class="code" href="namespaceboost_1_1xint.html#a21f7b0cbf5d79162f157c107873db431">operator&lt;&lt;</a>(std::basic_ostream&lt;charT,
<a name="l00519"></a>00519     traits&gt;&amp; out, <span class="keyword">const</span> data_t n)
<a name="l00520"></a>00520 {
<a name="l00521"></a>00521     <span class="keywordtype">int</span> base=((out.flags() &amp; std::ios::hex) ? 16
<a name="l00522"></a>00522         : (out.flags() &amp; std::ios::oct) ? 8
<a name="l00523"></a>00523         : 10);
<a name="l00524"></a>00524     <span class="keywordtype">bool</span> upperCase=(out.flags() &amp; std::ios::uppercase ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l00525"></a>00525 
<a name="l00526"></a>00526     <span class="keywordtype">int</span> nsign = (n.is_zero() ? 0 : n.negative ? -1 : 1);
<a name="l00527"></a>00527     <span class="keywordflow">if</span> ((out.flags() &amp; std::ios::showpos) &amp;&amp; nsign &gt;= 0) out &lt;&lt; <span class="stringliteral">&quot;+&quot;</span>;
<a name="l00528"></a>00528 
<a name="l00529"></a>00529     <span class="keywordflow">if</span> (out.flags() &amp; std::ios::showbase) {
<a name="l00530"></a>00530         <span class="keywordflow">if</span> (nsign &lt; 0) out &lt;&lt; <span class="stringliteral">&quot;-&quot;</span>;
<a name="l00531"></a>00531 
<a name="l00532"></a>00532         <span class="keywordflow">if</span> (base==16 &amp;&amp; upperCase) out &lt;&lt; <span class="stringliteral">&quot;0X&quot;</span>;
<a name="l00533"></a>00533         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base==16) out &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span>;
<a name="l00534"></a>00534         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (base==8) out &lt;&lt; <span class="stringliteral">&quot;0&quot;</span>;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         out &lt;&lt; <a class="code" href="namespaceboost_1_1xint.html#a6ae4ddf930587218746f08a2a5982746">to_string</a>(n.abs(), base, upperCase);
<a name="l00537"></a>00537     } <span class="keywordflow">else</span> {
<a name="l00538"></a>00538         out &lt;&lt; <a class="code" href="namespaceboost_1_1xint.html#a6ae4ddf930587218746f08a2a5982746">to_string</a>(n, base, upperCase);
<a name="l00539"></a>00539     }
<a name="l00540"></a>00540     <span class="keywordflow">return</span> out;
<a name="l00541"></a>00541 }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keywordtype">char</span>T, <span class="keyword">typename</span> traits&gt;
<a name="l00544"></a>00544 <span class="keyword">inline</span> std::basic_istream&lt;charT,traits&gt;&amp; <a class="code" href="namespaceboost_1_1xint.html#a177570efda84175d3ea979894f63e5b8">operator&gt;&gt;</a>(std::basic_istream&lt;charT,
<a name="l00545"></a>00545     traits&gt;&amp; in, data_t&amp; n)
<a name="l00546"></a>00546 {
<a name="l00547"></a>00547     <span class="keywordtype">int</span> hex=(in.flags() &amp; std::ios::hex) ? 1 : 0;
<a name="l00548"></a>00548     <span class="keywordtype">int</span> dec=(in.flags() &amp; std::ios::dec) ? 1 : 0;
<a name="l00549"></a>00549     <span class="keywordtype">int</span> oct=(in.flags() &amp; std::ios::oct) ? 1 : 0;
<a name="l00550"></a>00550     <span class="keywordtype">int</span> count=hex+dec+oct;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552     <span class="keywordtype">size_t</span> base=<a class="code" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398" title="A value that can be used for the &amp;#39;base&amp;#39; parameter of the string-to-integer...">autobase</a>;
<a name="l00553"></a>00553     <span class="keywordflow">if</span> (count==1) {
<a name="l00554"></a>00554         <span class="keywordflow">if</span> (hex) base=16;
<a name="l00555"></a>00555         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oct) base=8;
<a name="l00556"></a>00556         <span class="keywordflow">else</span> base=10;
<a name="l00557"></a>00557     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count&gt;1) base=10;
<a name="l00558"></a>00558     <span class="comment">// else auto-base</span>
<a name="l00559"></a>00559 
<a name="l00560"></a>00560     std::string s;
<a name="l00561"></a>00561     <span class="keywordflow">if</span> (in.peek()==<span class="charliteral">&#39;+&#39;</span>) {
<a name="l00562"></a>00562         in.ignore();
<a name="l00563"></a>00563     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in.peek()==<span class="charliteral">&#39;-&#39;</span>) {
<a name="l00564"></a>00564         in.ignore();
<a name="l00565"></a>00565         s.push_back(<span class="charliteral">&#39;-&#39;</span>);
<a name="l00566"></a>00566     }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="keywordflow">if</span> (base==<a class="code" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398" title="A value that can be used for the &amp;#39;base&amp;#39; parameter of the string-to-integer...">autobase</a>) {
<a name="l00569"></a>00569         <span class="keywordflow">if</span> (in.peek()==<span class="charliteral">&#39;0&#39;</span>) {
<a name="l00570"></a>00570             in.ignore();
<a name="l00571"></a>00571             <span class="keywordtype">int</span> c=in.peek();
<a name="l00572"></a>00572             <span class="keywordflow">if</span> (c==<span class="charliteral">&#39;x&#39;</span> || c==<span class="charliteral">&#39;X&#39;</span>) {
<a name="l00573"></a>00573                 in.ignore();
<a name="l00574"></a>00574                 base=16;
<a name="l00575"></a>00575             } <span class="keywordflow">else</span> base=8;
<a name="l00576"></a>00576         } <span class="keywordflow">else</span> base=10;
<a name="l00577"></a>00577     }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     <span class="keywordflow">while</span> (in) {
<a name="l00580"></a>00580         <span class="keywordtype">int</span> c=in.peek();
<a name="l00581"></a>00581         <span class="keywordflow">if</span> ((base==8 &amp;&amp; (c&gt;=<span class="charliteral">&#39;0&#39;</span> &amp;&amp; c&lt;=<span class="charliteral">&#39;7&#39;</span>)) ||
<a name="l00582"></a>00582             (base==10 &amp;&amp; (c&gt;=<span class="charliteral">&#39;0&#39;</span> &amp;&amp; c&lt;=<span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l00583"></a>00583             (base==16 &amp;&amp; ((c&gt;=<span class="charliteral">&#39;0&#39;</span> &amp;&amp; c&lt;=<span class="charliteral">&#39;9&#39;</span>) || (c&gt;=<span class="charliteral">&#39;a&#39;</span> &amp;&amp; c&lt;=<span class="charliteral">&#39;f&#39;</span>) ||
<a name="l00584"></a>00584                 (c&gt;=<span class="charliteral">&#39;A&#39;</span> &amp;&amp; c&lt;=<span class="charliteral">&#39;F&#39;</span>))))
<a name="l00585"></a>00585         {
<a name="l00586"></a>00586             in.ignore();
<a name="l00587"></a>00587             s.push_back(<span class="keywordtype">char</span>(c));
<a name="l00588"></a>00588         } <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
<a name="l00589"></a>00589     }
<a name="l00590"></a>00590 
<a name="l00591"></a>00591     <span class="keywordflow">try</span> {
<a name="l00592"></a>00592         n.from_string(s, base);
<a name="l00593"></a>00593     } <span class="keywordflow">catch</span> (std::exception&amp;) {
<a name="l00594"></a>00594         <span class="comment">// Catch invalid strings</span>
<a name="l00595"></a>00595         in.setstate(std::ios::failbit);
<a name="l00596"></a>00596     }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598     <span class="keywordflow">return</span> in;
<a name="l00599"></a>00599 }
<a name="l00600"></a>00600 
<a name="l00602"></a>00602 } <span class="comment">// namespace detail</span>
<a name="l00603"></a>00603 } <span class="comment">// namespace xint</span>
<a name="l00604"></a>00604 } <span class="comment">// namespace boost</span>
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 <span class="keyword">namespace </span>boost {
<a name="l00607"></a>00607 <span class="keyword">namespace </span>xint {
<a name="l00609"></a><a class="code" href="classboost_1_1xint_1_1any__integer.html">00609</a> <span class="keyword">class </span><a class="code" href="classboost_1_1xint_1_1any__integer.html" title="A base class for all integer types.">any_integer</a> {
<a name="l00610"></a>00610 <span class="preprocessor">    #ifndef BOOST_XINT_DOXYGEN_IGNORE</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span>    <span class="keyword">public</span>:
<a name="l00612"></a>00612     detail::data_t&amp; _data() { <span class="keywordflow">return</span> data; }
<a name="l00613"></a>00613     <span class="keyword">const</span> detail::data_t&amp; _data()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data; }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615     <span class="keywordtype">size_t</span> _get_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data.length; }
<a name="l00616"></a>00616     detail::digit_t _get_digit(<span class="keywordtype">size_t</span> index)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data[index]; }
<a name="l00617"></a>00617     <span class="keywordtype">bool</span> _is_fixed()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data.is_fixed_length(); }
<a name="l00618"></a>00618 
<a name="l00619"></a>00619     <span class="keyword">protected</span>:
<a name="l00620"></a>00620     <a class="code" href="classboost_1_1xint_1_1any__integer.html" title="A base class for all integer types.">any_integer</a>(detail::base_digitmanager_t &amp;holder, <span class="keywordtype">size_t</span> len, <span class="keywordtype">bool</span> neg =
<a name="l00621"></a>00621         <span class="keyword">false</span>): data(holder, len, neg) { }
<a name="l00622"></a>00622     <span class="keywordtype">bool</span> _is_nan()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data.is_nan(); }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624     detail::data_t data;
<a name="l00625"></a>00625 <span class="preprocessor">    #endif</span>
<a name="l00626"></a>00626 <span class="preprocessor"></span>};
<a name="l00627"></a>00627 
<a name="l00628"></a><a class="code" href="namespaceboost_1_1xint.html#ab256530d9916860983abdb6f0c6fad63">00628</a> <span class="keyword">typedef</span> <span class="keywordtype">size_t</span> <a class="code" href="namespaceboost_1_1xint.html#ab256530d9916860983abdb6f0c6fad63">bitsize_t</a>;
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 } <span class="comment">// namespace xint</span>
<a name="l00631"></a>00631 } <span class="comment">// namespace boost</span>
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 <span class="preprocessor">#ifndef BOOST_XINT_COMPILED_LIB</span>
<a name="l00634"></a>00634 <span class="preprocessor"></span><span class="preprocessor">    #include &quot;../exceptions.hpp&quot;</span>
<a name="l00635"></a>00635 <span class="preprocessor">    #include &quot;../random.hpp&quot;</span>
<a name="l00636"></a>00636 <span class="preprocessor">    #include &quot;<a class="code" href="bitqueue_8hpp.html" title="Contains the bitqueue_t class, used internally.">bitqueue.hpp</a>&quot;</span>
<a name="l00637"></a>00637 <span class="preprocessor">    #ifdef _WIN32</span>
<a name="l00638"></a>00638 <span class="preprocessor"></span><span class="preprocessor">        #define STRICT</span>
<a name="l00639"></a>00639 <span class="preprocessor"></span><span class="preprocessor">        #define WIN32_LEAN_AND_MEAN</span>
<a name="l00640"></a>00640 <span class="preprocessor"></span><span class="preprocessor">        #define NOMINMAX</span>
<a name="l00641"></a>00641 <span class="preprocessor"></span><span class="preprocessor">        #include &lt;windows.h&gt;</span>
<a name="l00642"></a>00642 <span class="preprocessor">    #endif</span>
<a name="l00643"></a>00643 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;sstream&gt;</span>
<a name="l00644"></a>00644 <span class="preprocessor">    #include &lt;fstream&gt;</span>
<a name="l00645"></a>00645 <span class="preprocessor">    #include &lt;ctime&gt;</span>
<a name="l00646"></a>00646 <span class="preprocessor">    #include &lt;boost/scoped_array.hpp&gt;</span>
<a name="l00647"></a><a class="code" href="internals_8hpp.html#ad98e63b2824264e53b562c9a833ffeab">00647</a> <span class="preprocessor">    #define BOOST_XINT_INLINE inline</span>
<a name="l00648"></a>00648 <span class="preprocessor"></span>
<a name="l00649"></a><a class="code" href="internals_8hpp.html#a7621c4fd1f5760b878ca8f5e5e6bb4c2">00649</a> <span class="preprocessor">    #define BOOST_XINT_FROM_HEADER</span>
<a name="l00650"></a>00650 <span class="preprocessor"></span><span class="preprocessor">    #include &quot;<a class="code" href="data__t_8cpp.html" title="Contains the function definitions for data_t and raw_digits_t.">data_t.cpp</a>&quot;</span>
<a name="l00651"></a>00651 <span class="preprocessor">    #include &quot;<a class="code" href="compare_8cpp.html" title="Contains the definitions for the comparison functions.">compare.cpp</a>&quot;</span>
<a name="l00652"></a>00652 <span class="preprocessor">    #include &quot;<a class="code" href="shift_8cpp.html" title="Contains the bit-shifting function definitions.">shift.cpp</a>&quot;</span>
<a name="l00653"></a>00653 <span class="preprocessor">    #include &quot;<a class="code" href="bitfunctions_8cpp.html" title="Contains the definitions for the bit-manipulation functions.">bitfunctions.cpp</a>&quot;</span>
<a name="l00654"></a>00654 <span class="preprocessor">    #include &quot;<a class="code" href="andorxor_8cpp.html" title="Contains the functions for ANDing, ORing, and XORing.">andorxor.cpp</a>&quot;</span>
<a name="l00655"></a>00655 <span class="preprocessor">    #include &quot;<a class="code" href="addsubtract_8cpp.html" title="Contains the definitions of the addition and subtraction functions.">addsubtract.cpp</a>&quot;</span>
<a name="l00656"></a>00656 <span class="preprocessor">    #include &quot;<a class="code" href="multiply_8cpp.html" title="Contains the multiplication and squaring functions.">multiply.cpp</a>&quot;</span>
<a name="l00657"></a>00657 <span class="preprocessor">    #include &quot;<a class="code" href="divide_8cpp.html" title="Contains the definitions of the divide function, and its supporting functions.">divide.cpp</a>&quot;</span>
<a name="l00658"></a>00658 <span class="preprocessor">    #include &quot;<a class="code" href="powers_8cpp.html" title="Contains functions related to powers of a number.">powers.cpp</a>&quot;</span>
<a name="l00659"></a>00659 <span class="preprocessor">    #include &quot;<a class="code" href="roots_8cpp.html" title="Contains the square-root function definition, and any future root-related ones.">roots.cpp</a>&quot;</span>
<a name="l00660"></a>00660 <span class="preprocessor">    #include &quot;<a class="code" href="monty_8cpp.html" title="Contains the Montgomery Reduction functions.">monty.cpp</a>&quot;</span>
<a name="l00661"></a>00661 <span class="preprocessor">    #include &quot;<a class="code" href="modular_8cpp.html" title="Contains the modular math functions.">modular.cpp</a>&quot;</span>
<a name="l00662"></a>00662 <span class="preprocessor">    #include &quot;<a class="code" href="gcd_8cpp.html" title="Contains functions using the Greatest Common Denominator algorithm.">gcd.cpp</a>&quot;</span>
<a name="l00663"></a>00663 <span class="preprocessor">    #include &quot;<a class="code" href="convert_8cpp.html" title="Contains the conversion functions.">convert.cpp</a>&quot;</span>
<a name="l00664"></a>00664 <span class="preprocessor">    #include &quot;<a class="code" href="prime_8cpp.html" title="Contains the function definitions for the prime number functions.">prime.cpp</a>&quot;</span>
<a name="l00665"></a>00665 <span class="preprocessor">    #include &quot;<a class="code" href="random_8cpp.html" title="Contains the function definitions for the random number functions.">random.cpp</a>&quot;</span>
<a name="l00666"></a>00666 <span class="preprocessor">    #undef BOOST_XINT_FROM_HEADER</span>
<a name="l00667"></a>00667 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00668"></a>00668 <span class="preprocessor"></span><span class="preprocessor">    #define BOOST_XINT_INLINE</span>
<a name="l00669"></a>00669 <span class="preprocessor"></span><span class="preprocessor">#endif // BOOST_XINT_COMPILED_LIB</span>
<a name="l00670"></a>00670 <span class="preprocessor"></span>
<a name="l00671"></a>00671 <span class="preprocessor">#endif // BOOST_INCLUDED_XINT_INTERNALS_HPP</span>
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Jun 3 00:00:36 2010 for The Extended Integer (XInt) Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
