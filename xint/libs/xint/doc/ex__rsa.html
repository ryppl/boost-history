<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>The Extended Integer (XInt) Library: RSA Encryption</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">The Extended Integer (XInt) Library</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="ex_rsa">RSA Encryption </a></h1><p>Here is an RSA encryption example. It uses unsigned, fixed-length integers with the "secure" option.</p>
<p>Please note that this example, while fairly complete, is minimal. It does not include signing or verification of signatures, and does nothing to prevent a known attack method (the "low encryption exponent" attack).</p>
<p>You can find this example as the file <code>rsa.cpp</code> in the <code>example</code> directory.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;sstream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;boost/limits.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/integer.hpp&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="integer_8hpp.html" title="Declares the arbitrary-length integer type.">boost/xint/integer.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;boost/static_assert.hpp&gt;</span>

<span class="keyword">namespace </span>xopt = boost::xint::options;
<span class="keyword">using</span> <a class="code" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547" title="A callback function takes no parameters and returns a bool.">boost::xint::callback_t</a>;
<span class="keyword">using</span> <a class="code" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696" title="An empty callback_t, used as a default parameter for some functions.">boost::xint::no_callback</a>;

<span class="keyword">static</span> <span class="keyword">const</span> std::size_t cbits = std::numeric_limits&lt;char&gt;::digits;

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
<span class="keyword">class </span>Rsa {
    <span class="keyword">public</span>:
    <span class="comment">// We&#39;re going to use a fixed-length type for this example, primarily to</span>
    <span class="comment">// show how they would be used. The calculations require intermediate</span>
    <span class="comment">// results that are between two and three times the bit-size of the number</span>
    <span class="comment">// though. We&#39;ll also make it unsigned, and use secure mode to reduce the</span>
    <span class="comment">// chance that the key data gets written to disk anywhere.</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classboost_1_1xint_1_1integer__t.html" title="The integer_t class template.">boost::xint::integer_t&lt;xopt::fixedlength&lt;Bits * 3&gt;</a>,
        xopt::secure, xopt::negative_modulus&gt; KeyNumber;

    <span class="comment">// We also need the smallest type that can hold a Bits-length number of</span>
    <span class="comment">// characters.</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::uint_value_t&lt;(Bits + cbits - 1) / cbits&gt;::least
        SizeT;

    <span class="comment">// There must be at least enough bits to handle one character and a SizeT.</span>
    BOOST_STATIC_ASSERT(Bits &gt; ((<span class="keyword">sizeof</span>(SizeT) + 1) * cbits));

    <span class="comment">// The number of bits needs to be even.</span>
    BOOST_STATIC_ASSERT((Bits &amp; 0x01) == 0);

    Rsa(<span class="keyword">const</span> std::string keys);

    std::string publickey() <span class="keyword">const</span>;
    std::string privatekey() <span class="keyword">const</span>;

    std::string encrypt(<span class="keyword">const</span> std::string data) <span class="keyword">const</span>;
    std::string decrypt(<span class="keyword">const</span> std::string data) <span class="keyword">const</span>;

    <span class="keyword">static</span> Rsa generate(<a class="code" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547" title="A callback function takes no parameters and returns a bool.">callback_t</a> callback = <a class="code" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696" title="An empty callback_t, used as a default parameter for some functions.">no_callback</a>);

    <span class="keyword">private</span>:
    <span class="keyword">static</span> std::size_t calculate_blocksize(KeyNumber n);

    Rsa(<span class="keyword">const</span> KeyNumber _n, <span class="keyword">const</span> KeyNumber _d, <span class="keyword">const</span> KeyNumber _e): n(_n),
        d(_d), e(_e) { blocksize = calculate_blocksize(n); };

    std::string number_to_binary_string(<span class="keyword">const</span> KeyNumber num) <span class="keyword">const</span>;
    KeyNumber binary_string_to_number(<span class="keyword">const</span> std::string s) <span class="keyword">const</span>;

    KeyNumber n, d, e;
    std::size_t blocksize;
};

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::size_t Rsa&lt;Bits&gt;::calculate_blocksize(KeyNumber n) {
    <span class="comment">// Round the size of n (in bits) down to the next lower multiple of the</span>
    <span class="comment">// number of bits in a character. That&#39;s how many characters we can fit into</span>
    <span class="comment">// a single block, for encryption purposes.</span>
    std::size_t size_in_bits = <a class="code" href="namespaceboost_1_1xint.html#aec7b803cbc9245ccae1f88e4efab327b" title="Get the log2 value of an integer.">log2</a>(n) - 1;
    <span class="keywordflow">return</span> (size_in_bits + cbits - 1) / cbits;
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::string Rsa&lt;Bits&gt;::number_to_binary_string(<span class="keyword">const</span> KeyNumber num)<span class="keyword"> const </span>{
    <a class="code" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58" title="The format for the binary representations of integers.">boost::xint::binary_t</a> b = <a class="code" href="namespaceboost_1_1xint.html#a36d0321bee2aade461e0f504400c7c1b" title="Creates a binary representation of an integer.">to_binary</a>(num);
    std::string s;
    std::copy(b.begin(), b.end(), std::back_inserter(s));
    <span class="keywordflow">return</span> s;
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
<span class="keyword">typename</span> Rsa&lt;Bits&gt;::KeyNumber Rsa&lt;Bits&gt;::binary_string_to_number(<span class="keyword">const</span>
    std::string s)<span class="keyword"> const</span>
<span class="keyword"></span>{
    <a class="code" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58" title="The format for the binary representations of integers.">boost::xint::binary_t</a> b;
    std::copy(s.begin(), s.end(), std::back_inserter(b));
    <span class="keywordflow">return</span> KeyNumber(b);
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
Rsa&lt;Bits&gt;::Rsa(<span class="keyword">const</span> std::string keys) {
    <span class="comment">// Make sure it&#39;s a proper key, by checking the signature.</span>
    <span class="keywordtype">bool</span> goodkey = <span class="keyword">true</span>;
    <span class="keywordflow">if</span> (keys.substr(0, 4) == <span class="stringliteral">&quot;{RSA&quot;</span>) {
        std::istringstream str(keys.substr(4));
        std::size_t recordedbits = 0;
        <span class="keywordtype">char</span> c1 = 0, c2 = 0, c3 = 0, c4 = 0;
        str &gt;&gt; recordedbits &gt;&gt; c1 &gt;&gt; e &gt;&gt; c2 &gt;&gt; n &gt;&gt; c3;
        <span class="keywordflow">if</span> (c1 == <span class="charliteral">&#39;,&#39;</span> &amp;&amp; c2 == <span class="charliteral">&#39;,&#39;</span>) {
            <span class="keywordflow">if</span> (c3 == <span class="charliteral">&#39;,&#39;</span>) {
                <span class="comment">// It&#39;s a private key, including the decryption key.</span>
                str &gt;&gt; d &gt;&gt; c4;
                <span class="keywordflow">if</span> (c4 != <span class="charliteral">&#39;}&#39;</span>) goodkey = <span class="keyword">false</span>;
            } <span class="keywordflow">else</span> {
                <span class="comment">// It&#39;s a public key, no decryption key is included.</span>
                <span class="keywordflow">if</span> (c3 != <span class="charliteral">&#39;}&#39;</span>) goodkey = <span class="keyword">false</span>;
            }
        } <span class="keywordflow">else</span> goodkey = <span class="keyword">false</span>;

        <span class="comment">// Make sure it&#39;s the right size</span>
        <span class="keywordflow">if</span> (goodkey &amp;&amp; recordedbits != Bits)
            <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;Wrong number of bits&quot;</span>);
    } <span class="keywordflow">else</span> goodkey = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (!goodkey) <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Not a valid key&quot;</span>);
    blocksize = calculate_blocksize(n);
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::string Rsa&lt;Bits&gt;::publickey()<span class="keyword"> const </span>{
    std::ostringstream str;
    str &lt;&lt; <span class="stringliteral">&quot;{RSA&quot;</span> &lt;&lt; Bits &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; e &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; n &lt;&lt; <span class="charliteral">&#39;}&#39;</span>;
    <span class="keywordflow">return</span> str.str();
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::string Rsa&lt;Bits&gt;::privatekey()<span class="keyword"> const </span>{
    std::ostringstream str;
    str &lt;&lt; <span class="stringliteral">&quot;{RSA&quot;</span> &lt;&lt; Bits &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; e &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; n &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; d &lt;&lt; <span class="charliteral">&#39;}&#39;</span>;
    <span class="keywordflow">return</span> str.str();
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::string Rsa&lt;Bits&gt;::encrypt(<span class="keyword">const</span> std::string data)<span class="keyword"> const </span>{
    <span class="comment">// A proper implementation would pad the message with additional random</span>
    <span class="comment">// data, to avoid the low encryption exponent attack. This example</span>
    <span class="comment">// implementation does not.</span>

    <span class="comment">// The message may contain up to (blocksize - 1) extra bytes when it&#39;s</span>
    <span class="comment">// decrypted. Prepend a SizeT with the number of bytes to remove from the</span>
    <span class="comment">// end.</span>
    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask = (<span class="keywordtype">unsigned</span> char)(-1);
    std::string msg;
    SizeT trimblock = blocksize - ((data.length() + <span class="keyword">sizeof</span>(SizeT)) % blocksize);
    <span class="keywordflow">if</span> (trimblock == blocksize) trimblock = 0;
    <span class="keywordflow">for</span> (std::size_t i = <span class="keyword">sizeof</span>(SizeT); i &gt; 0; --i) {
        msg += <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(trimblock &amp; mask);
        trimblock &gt;&gt;= cbits;
    }
    msg += data;

    <span class="comment">// Split the message into blocks of blocksize and encrypt each one.</span>
    std::string encrypted_msg;
    <span class="keywordflow">for</span> (std::size_t block = 0; block * blocksize &lt; msg.length(); ++block) {
        <span class="comment">// Grab a block of blocksize bytes.</span>
        std::string tblock = msg.substr(block * blocksize, blocksize);

        <span class="comment">// Turn it into a KeyNumber.</span>
        KeyNumber mnumber = binary_string_to_number(tblock);

        <span class="comment">// Encrypt that number</span>
        mnumber = <a class="code" href="namespaceboost_1_1xint.html#a9c1648ef679123bb2bf77681ffdfa815" title="Get the result of ne % m, keeping the intermediate results (relatively) small.">powmod</a>(mnumber, e, n);

        <span class="comment">// Append the encrypted data to the return value, padded to the proper</span>
        <span class="comment">// block length.</span>
        tblock = number_to_binary_string(mnumber);
        <span class="keywordflow">if</span> (tblock.length() &lt; blocksize) tblock += std::string(blocksize -
            tblock.length(), 0);
        encrypted_msg += tblock;
    }

    <span class="keywordflow">return</span> encrypted_msg;
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
std::string Rsa&lt;Bits&gt;::decrypt(<span class="keyword">const</span> std::string encrypted_msg)<span class="keyword"> const </span>{
    std::string decrypted_msg;

    <span class="comment">// Split the message into blocks of blocksize and decrypt each one.</span>
    <span class="keywordflow">for</span> (std::size_t block = 0; block * blocksize &lt; encrypted_msg.length();
        ++block)
    {
        <span class="comment">// Grab a block of blocksize bytes.</span>
        std::string tblock = encrypted_msg.substr(block * blocksize, blocksize);

        <span class="comment">// Turn it into a KeyNumber.</span>
        KeyNumber mnumber = binary_string_to_number(tblock);

        <span class="comment">// Decrypt that number</span>
        mnumber = <a class="code" href="namespaceboost_1_1xint.html#a9c1648ef679123bb2bf77681ffdfa815" title="Get the result of ne % m, keeping the intermediate results (relatively) small.">powmod</a>(mnumber, d, n);

        <span class="comment">// Append the encrypted data to the return value, padded to the proper</span>
        <span class="comment">// block length.</span>
        tblock = number_to_binary_string(mnumber);
        <span class="keywordflow">if</span> (tblock.length() &lt; blocksize) tblock += std::string(blocksize -
            tblock.length(), 0);
        decrypted_msg += tblock;
    }

    <span class="comment">// Trim the added bytes off of it.</span>
    SizeT trimblock = 0;
    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; <span class="keyword">sizeof</span>(SizeT); ++i)
        trimblock |= (SizeT(decrypted_msg[i]) &lt;&lt; (i * cbits));
    decrypted_msg = decrypted_msg.substr(<span class="keyword">sizeof</span>(SizeT), decrypted_msg.length() -
        trimblock - <span class="keyword">sizeof</span>(SizeT));

    <span class="keywordflow">return</span> decrypted_msg;
}

<span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> Bits&gt;
Rsa&lt;Bits&gt; Rsa&lt;Bits&gt;::generate(<a class="code" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547" title="A callback function takes no parameters and returns a bool.">callback_t</a> callback) {
    <span class="comment">// Use the system&#39;s strong random number generator, via the XInt-provided</span>
    <span class="comment">// convenience class.</span>
    <a class="code" href="namespaceboost_1_1xint.html#ac38b0aafb375c80ff42b5488a52d9e8f" title="A convenience class for cryptographically-secure random numbers.">boost::xint::strong_random_generator</a> gen;

    <span class="comment">// Generate two random prime numbers, each containing no more than half of</span>
    <span class="comment">// the requested bits, and compute the product.</span>
    KeyNumber p = KeyNumber::random_prime(gen, Bits / 2, callback);
    KeyNumber q = KeyNumber::random_prime(gen, Bits / 2, callback);
    assert(p != q); <span class="comment">// If they&#39;re identical, there&#39;s almost certainly a problem</span>

    <span class="comment">// Compute the product of the primes.</span>
    KeyNumber n(p * q);

    <span class="comment">// Select an encryption key e, such that e and (p - 1) * (q - 1) are</span>
    <span class="comment">// relatively prime. Encryption goes a lot faster if you use small primes</span>
    <span class="comment">// for this value, and 65537 is recommended by X.509 and PKCS #1.</span>
    KeyNumber e(65537);

    <span class="comment">// Compute the decryption key.</span>
    KeyNumber d(<a class="code" href="namespaceboost_1_1xint.html#aca3ee91c50b15fa902c37fa16763f52b" title="Get the modular inverse of a number in a modulus, if there is one.">invmod</a>(e, (p - 1) * (q - 1)));

    <span class="comment">// That&#39;s all we have to do. Just plug those numbers into an Rsa object and</span>
    <span class="comment">// return it.</span>
    <span class="keywordflow">return</span> Rsa&lt;Bits&gt;(n, d, e);
}



<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::endl;
<span class="keyword">using</span> std::flush;

<span class="keyword">const</span> <span class="keywordtype">int</span> max_statusline_length = 40;

<span class="keywordtype">void</span> clearline(<span class="keywordtype">int</span> length) {
    cout &lt;&lt; <span class="charliteral">&#39;\r&#39;</span> &lt;&lt; std::string(length, <span class="charliteral">&#39; &#39;</span>) &lt;&lt; <span class="charliteral">&#39;\r&#39;</span> &lt;&lt; flush;
}

<span class="keywordtype">bool</span> callback() {
    <span class="keyword">static</span> <span class="keywordtype">int</span> n = 0;
    <span class="keywordflow">if</span> (++n == max_statusline_length) {
        clearline(max_statusline_length);
        n = 0;
    }
    cout &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; flush;
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="keywordtype">int</span> main() {
    <span class="keyword">typedef</span> Rsa&lt;512&gt; Cipher;

    <span class="comment">// In this test program, we&#39;ll generate a new key every time. 512-bit keys</span>
    <span class="comment">// should generate within 100 attempts or less, most of the time, so it&#39;ll</span>
    <span class="comment">// be pretty quick. You would normally generate a new key only once, store</span>
    <span class="comment">// the private key securely, and publish the public key.</span>
    Cipher c = Cipher::generate(callback);
    clearline(max_statusline_length);

    std::string source(<span class="stringliteral">&quot;This is a test message.&quot;</span>);
    std::string encrypted = c.encrypt(source);
    std::string decrypted = c.decrypt(encrypted);

    <span class="keywordflow">if</span> (decrypted == source) {
        cout &lt;&lt; <span class="stringliteral">&quot;Decryption was successful!&quot;</span> &lt;&lt; endl &lt;&lt; endl;
        cout &lt;&lt; <span class="stringliteral">&quot;The key is: &quot;</span> &lt;&lt; c.privatekey() &lt;&lt; endl;
    } <span class="keywordflow">else</span> {
        cout &lt;&lt; <span class="stringliteral">&quot;Error in decryption!&quot;</span> &lt;&lt; endl;
        cout &lt;&lt; source &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; source.length() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; endl;
        cout &lt;&lt; decrypted &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; decrypted.length() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; endl;
    }

    <span class="keywordflow">return</span> EXIT_SUCCESS;
}
</pre></div> </div>
<hr>
<p><i>&copy; Copyright Chad Nelson, 2010. Distributed under the Boost Software
License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
<a href=http://www.boost.org/LICENSE_1_0.txt>http://www.boost.org/LICENSE_1_0.txt</a>)
</i></p>
