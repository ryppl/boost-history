<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>The Extended Integer (XInt) Library: boost::xint Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceboost.html">boost</a>::<a class="el" href="namespaceboost_1_1xint.html">xint</a>
  </div>
</div>
<div class="contents">
<h1>boost::xint Namespace Reference</h1>
<p>All the types and functions of the library are within this namespace.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1detail.html">detail</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The items within this namespace are meant for internal use only. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1exceptions.html">exceptions</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Every exception the library throws is from this namespace. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1options.html">options</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Options for the <a class="el" href="classboost_1_1xint_1_1integer__t.html" title="The integer_t class template.">integer_t</a> template are stored in this namespace. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1xint_1_1base__divide__t.html">base_divide_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds the results from a division-with-remainder call.  <a href="classboost_1_1xint_1_1base__divide__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1xint_1_1default__random__generator.html">default_random_generator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience class for general-purpose (insecure) random numbers.  <a href="classboost_1_1xint_1_1default__random__generator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classboost_1_1xint_1_1integer__t.html" title="The integer_t class template.">integer_t</a> class template.  <a href="classboost_1_1xint_1_1integer__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; unsigned <br class="typebreak"/>
char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">binary_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The format for the binary representations of integers.  <a href="#aae3128529370506165793f2771834e58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This makes it easier to tell when an item is measured in bits.  <a href="#ae9f6d103df04ad19a841ed3f8b94a764"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; bool()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function takes no parameters and returns a bool.  <a href="#a48deb76c9c428a4b3a50177b1b0cb547"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a3f9537c30e9c1f7341574fcd0223147c">integer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default arbitrary-length integer type.  <a href="#a3f9537c30e9c1f7341574fcd0223147c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a><br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1xint_1_1options_1_1nothrow.html">options::nothrow</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#adb761045d90aee163058a57489b51df2">nothrow_integer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default arbitrary-length nothrow_integer type.  <a href="#adb761045d90aee163058a57489b51df2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
detail::strong_random_generator_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac38b0aafb375c80ff42b5488a52d9e8f">strong_random_generator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience class for cryptographically-secure random numbers.  <a href="#ac38b0aafb375c80ff42b5488a52d9e8f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab4aafdf3645cbad0cb3af54fdec4caff">swap</a> (<a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; &amp;left, <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; &amp;right)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical primitives</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp196dd2a5f50860e057df961a96d84ea3"></a> There are only a few functions here because almost all mathematical primitives are implemented as operators. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a331d95962aedbdb34f04ef373555dd8a">abs</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the absolute value of an integer.  <a href="#a331d95962aedbdb34f04ef373555dd8a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae58734c3f93951819e43af9fff2b9496">difference</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the absolute difference between two integers.  <a href="#ae58734c3f93951819e43af9fff2b9496"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;::divide_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a9696321a0a8ddea617223472a62f2452">divide</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; dividend, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; divisor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate how many <code>dividends</code> would fit into <code>divisor</code>, with the remainder.  <a href="#a9696321a0a8ddea617223472a62f2452"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Bit-manipulation functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpcc775c18f98f26f2b84ac7a2558636f2"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a5643216f91a4bb39bd88c1dc877e6ab8">clearbit</a> (<a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; &amp;n, <a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a> bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a specific bit in an integer to zero.  <a href="#a5643216f91a4bb39bd88c1dc877e6ab8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a1f2a052f7f391bddace5348c3adcc97a">getbit</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, <a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a> bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the value of a particular bit in an integer.  <a href="#a1f2a052f7f391bddace5348c3adcc97a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#adee99f516c2480b2381f6c9b1a2abc6e">highestbit</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, <a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a> return_if_zero=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the index of the highest bit in an integer with a value of one.  <a href="#adee99f516c2480b2381f6c9b1a2abc6e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a8512b348c82472dca48edb63f2a1f0e7">lowestbit</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, <a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a> return_if_zero=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the index of the lowest bit in an integer with a value of one.  <a href="#a8512b348c82472dca48edb63f2a1f0e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae957235f76cb2fa0e1530255ccbfa8d0">setbit</a> (<a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; &amp;n, <a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a> bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a specific bit in an integer to one.  <a href="#ae957235f76cb2fa0e1530255ccbfa8d0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp458f92801f3edfaf2e30b1f530c324e2"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab832646bf44c70bae41518688d9f5cb5">compare</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2, bool ignoresign=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two integer objects.  <a href="#ab832646bf44c70bae41518688d9f5cb5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ad58ca08a1482ae77a979027da61d17f4">gcd</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; num1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; num2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the Greatest Common Denominator of two integers.  <a href="#ad58ca08a1482ae77a979027da61d17f4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7740825a61553e51cead8af64ec763c0">lcm</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; num1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; num2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the Least Common Multiple of two integers.  <a href="#a7740825a61553e51cead8af64ec763c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aec7b803cbc9245ccae1f88e4efab327b">log2</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the log<sub>2</sub> value of an integer.  <a href="#aec7b803cbc9245ccae1f88e4efab327b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Modular math functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpbf63e6a6a1029bb25b7aa51052b38655"></a> A common reason to use a large-integer library is to implement public-key encryption, and the algorithms for such encryption often use modular math.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>operator%(integer_t, integer_t) </dd>
<dd>
<a class="el" href="classboost_1_1xint_1_1integer__t.html#a2144da90955b26120f5cfc724a24b8fc">integer_t::operator%=</a> </dd></dl>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aca3ee91c50b15fa902c37fa16763f52b">invmod</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; modulus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular inverse of a number in a modulus, if there is one.  <a href="#aca3ee91c50b15fa902c37fa16763f52b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aca6917c25cdd7cac7c3eda4684567625">mulmod</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; by, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; modulus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular product of two integers.  <a href="#aca6917c25cdd7cac7c3eda4684567625"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a9c1648ef679123bb2bf77681ffdfa815">powmod</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; exponent, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; modulus, bool no_monty=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the result of <code>n<sup>e</sup></code> % <code>m</code>, keeping the intermediate results (relatively) small.  <a href="#a9c1648ef679123bb2bf77681ffdfa815"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aa41f48c60b257cb321fe89fe0b65b6c3">sqrmod</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; modulus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular product of squaring an integer.  <a href="#aa41f48c60b257cb321fe89fe0b65b6c3"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Random and prime number functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa3caa0f3187a2dcc617c005b6b75011b"></a> </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classboost_1_1xint_1_1integer__t.html#a60157b68c2e375faac4d325091fd1683" title="Generates a random integer with specific attributes.">integer_t::random_by_size</a> </dd>
<dd>
<a class="el" href="classboost_1_1xint_1_1integer__t.html#a87ea7ddc800621ebf2d9dda0d68d0947" title="Generate a randomly-generated prime number of a particular bit-size.">integer_t::random_prime</a> </dd></dl>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a22c8ff3260bcb5c4c8e09e632c488ace">is_prime</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> callback=<a class="el" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696">no_callback</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests an integer for primality.  <a href="#a22c8ff3260bcb5c4c8e09e632c488ace"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp54923b9793dae891d9489cc5947f263a"></a> The nothrow versions of these functions return <code>false</code> instead of throwing.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>compare(integer_t, integer_t, bool) </dd></dl>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a07e81815254a7ca3afddd5398695a2b7">operator!=</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#af5698b6ba852f5a119429b17c2a08450">operator&lt;</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac3daab81a55daeceedd256ce49634d4d">operator&lt;=</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7d9f811ac514e033c7fc965b5cd62ee3">operator==</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ad1ac6fb8431b231faecf34a5a2d01626">operator&gt;</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a00c5ad6cf63ecc8ea3a2294ccedac7d3">operator&gt;=</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical and Bitwise Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp8eb1e0f0af70edd858d54ba68b80ce7e"></a> These act exactly the same as for the built-in integer types. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0ac4116f3a9285a7f2f10d0104b870f7">operator%</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remainder after dividing a number by another.  <a href="#a0ac4116f3a9285a7f2f10d0104b870f7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ad3bc201c8c1f3e87611abce8e6972538">operator&amp;</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>AND</code> operation.  <a href="#ad3bc201c8c1f3e87611abce8e6972538"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab33a5481a4a4b16ab592be6a88cd245c">operator*</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the product of two integers.  <a href="#ab33a5481a4a4b16ab592be6a88cd245c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a15c7951bc910713f8209b7ebd78396da">operator+</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the sum of two integers.  <a href="#a15c7951bc910713f8209b7ebd78396da"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab6132105fbe7d7bf7a756b868b6a372e">operator-</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the difference between two integers.  <a href="#ab6132105fbe7d7bf7a756b868b6a372e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a806df63b92124039591a4ca09a8538e0">operator/</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; dividend, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; divisor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate how many <code>dividends</code> would fit into <code>divisor</code>.  <a href="#a806df63b92124039591a4ca09a8538e0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0d1ce319bfb004fb6b93283bcb4f98c2">operator^</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>XOR</code> operation.  <a href="#a0d1ce319bfb004fb6b93283bcb4f98c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0b58f99b2c5bab4f7eec71d6058b23dd">operator|</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n1, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>OR</code> operation.  <a href="#a0b58f99b2c5bab4f7eec71d6058b23dd"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream input/output functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9927783c44c1aad288df0ab8bfa9ddf"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits , ... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0e501790ec0437c226ce54f98493aad9">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;out, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits , ... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7ad17ed38204ec9a774788ea28368701">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;in, <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; &amp;n)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Powers and roots</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp928a8cb047602f789d7433e262ed4560"></a> </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classboost_1_1xint_1_1integer__t.html#af1ba624cd3a118bad2f8b603837bd952" title="Calculate the value of 2e">integer_t::pow2</a> </dd>
<dd>
<a class="el" href="classboost_1_1xint_1_1integer__t.html#aaa28dad29e0a3fd16ec4bb26ec241a65" title="Calculate the value of n! ">integer_t::factorial</a> </dd></dl>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a483e2fdc6cef9afa1295afeceda4a644">pow</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of n<sup>e</sup>  <a href="#a483e2fdc6cef9afa1295afeceda4a644"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac40d60956ef5af3b64804c7a9abffcdd">square</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of n<sup>2</sup>  <a href="#ac40d60956ef5af3b64804c7a9abffcdd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#abb957c86cae5940b06172eb23345fe42">square_root</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the square root of <code>an</code> integer.  <a href="#abb957c86cae5940b06172eb23345fe42"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp9c2e8a06d85d2c9b83b5a0d27e85d535"></a> Note that these only convert an integer type to something else. See the integer constructors for conversions the other way. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , ... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a9aa52eb4533b04c27329b3f6b7aa842b">to</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an <a class="el" href="namespaceboost_1_1xint.html#a3f9537c30e9c1f7341574fcd0223147c" title="The default arbitrary-length integer type.">xint::integer</a> type to a built-in integer type.  <a href="#a9aa52eb4533b04c27329b3f6b7aa842b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a36d0321bee2aade461e0f504400c7c1b">to_binary</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, <a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a> bits=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a binary representation of an integer.  <a href="#a36d0321bee2aade461e0f504400c7c1b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a2fb5a8cfac3e97a1641d424aac04a71f">to_string</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, std::size_t base=10, bool uppercase=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A shorthand function that calls <a class="el" href="namespaceboost_1_1xint.html#a12e9d9268bae5d099227af78c1dea758">to_stringtype&lt;char&gt;</a>.  <a href="#a2fb5a8cfac3e97a1641d424aac04a71f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , ... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; charT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a12e9d9268bae5d099227af78c1dea758">to_stringtype</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, std::size_t base=10, bool uppercase=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a string representation of the specified integer.  <a href="#a12e9d9268bae5d099227af78c1dea758"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::wstring&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a6f24b4e0dc6e6c5de02480f5fb352030">to_wstring</a> (const <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; n, std::size_t base=10, bool uppercase=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A shorthand function that calls <a class="el" href="namespaceboost_1_1xint.html#a12e9d9268bae5d099227af78c1dea758">to_stringtype&lt;wchar_t&gt;</a>.  <a href="#a6f24b4e0dc6e6c5de02480f5fb352030"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a6e2c55f95b91dfcb7586599faca34cb2">autobase</a> = (std::numeric_limits&lt;size_t&gt;::max)()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A value that can be used for the 'base' parameter of the string-to-integer constructor functions.  <a href="#a6e2c55f95b91dfcb7586599faca34cb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696">no_callback</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An empty callback_t, used as a default parameter for some functions.  <a href="#a758d415a476a5eeed28dc6b5869b1696"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>All the types and functions of the library are within this namespace. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aae3128529370506165793f2771834e58"></a><!-- doxytag: member="boost::xint::binary_t" ref="aae3128529370506165793f2771834e58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;unsigned char&gt; <a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">boost::xint::binary_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The format for the binary representations of integers. </p>

<p>Definition at line <a class="el" href="basic__types__and__includes_8hpp_source.html#l00082">82</a> of file <a class="el" href="basic__types__and__includes_8hpp_source.html">basic_types_and_includes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9f6d103df04ad19a841ed3f8b94a764"></a><!-- doxytag: member="boost::xint::bitsize_t" ref="ae9f6d103df04ad19a841ed3f8b94a764" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">boost::xint::bitsize_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This makes it easier to tell when an item is measured in bits. </p>

<p>Definition at line <a class="el" href="basic__types__and__includes_8hpp_source.html#l00089">89</a> of file <a class="el" href="basic__types__and__includes_8hpp_source.html">basic_types_and_includes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48deb76c9c428a4b3a50177b1b0cb547"></a><!-- doxytag: member="boost::xint::callback_t" ref="a48deb76c9c428a4b3a50177b1b0cb547" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;bool ()&gt; <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">boost::xint::callback_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function takes no parameters and returns a bool. </p>

<p>Definition at line <a class="el" href="basic__types__and__includes_8hpp_source.html#l00076">76</a> of file <a class="el" href="basic__types__and__includes_8hpp_source.html">basic_types_and_includes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f9537c30e9c1f7341574fcd0223147c"></a><!-- doxytag: member="boost::xint::integer" ref="a3f9537c30e9c1f7341574fcd0223147c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a> <a class="el" href="classboost_1_1xint_1_1integer__t.html">boost::xint::integer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default arbitrary-length integer type. </p>
<p>This uses the default parameters for the <a class="el" href="classboost_1_1xint_1_1integer__t.html" title="The integer_t class template.">integer_t</a> template. </p>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02520">2520</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb761045d90aee163058a57489b51df2"></a><!-- doxytag: member="boost::xint::nothrow_integer" ref="adb761045d90aee163058a57489b51df2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt;<a class="el" href="structboost_1_1xint_1_1options_1_1nothrow.html">options::nothrow</a>&gt; <a class="el" href="classboost_1_1xint_1_1integer__t.html">boost::xint::nothrow_integer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default arbitrary-length nothrow_integer type. </p>
<p>This uses the default parameters for the <a class="el" href="classboost_1_1xint_1_1integer__t.html" title="The integer_t class template.">integer_t</a> template, other than the <code>nothrow</code> one. </p>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02527">2527</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac38b0aafb375c80ff42b5488a52d9e8f"></a><!-- doxytag: member="boost::xint::strong_random_generator" ref="ac38b0aafb375c80ff42b5488a52d9e8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef detail::strong_random_generator_t <a class="el" href="namespaceboost_1_1xint.html#ac38b0aafb375c80ff42b5488a52d9e8f">boost::xint::strong_random_generator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience class for cryptographically-secure random numbers. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="random.html">The XInt Random Number System</a> </dd>
<dd>
<a class="el" href="classboost_1_1xint_1_1integer__t.html#a60157b68c2e375faac4d325091fd1683">integer_t::random_by_size</a> </dd>
<dd>
<a class="el" href="classboost_1_1xint_1_1integer__t.html#a87ea7ddc800621ebf2d9dda0d68d0947">integer_t::random_prime</a> </dd></dl>

<p>Definition at line <a class="el" href="random_8hpp_source.html#l00097">97</a> of file <a class="el" href="random_8hpp_source.html">random.hpp</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a331d95962aedbdb34f04ef373555dd8a"></a><!-- doxytag: member="boost::xint::abs" ref="a331d95962aedbdb34f04ef373555dd8a" args="(const integer_t&lt; ... &gt; n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::abs </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the absolute value of an integer. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If <code>n</code> is zero or positive, returns <code>n</code>. Otherwise returns <code>-n</code>. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01215">1215</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5643216f91a4bb39bd88c1dc877e6ab8"></a><!-- doxytag: member="boost::xint::clearbit" ref="a5643216f91a4bb39bd88c1dc877e6ab8" args="(integer_t&lt; ... &gt; &amp;n, bitsize_t bit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::clearbit </td>
          <td>(</td>
          <td class="paramtype">integer_t&lt; ... &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitsize_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a specific bit in an integer to zero. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01605">1605</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab832646bf44c70bae41518688d9f5cb5"></a><!-- doxytag: member="boost::xint::compare" ref="ab832646bf44c70bae41518688d9f5cb5" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2, bool ignoresign=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int boost::xint::compare </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoresign</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two integer objects. </p>
<ul>
<li>Complexity: varies between O(n) if the numbers are equal (the worst case), down to O(1) if they have different signs or wildly different magnitudes.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to compare. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignoresign</em>&nbsp;</td><td>If <code>true</code>, the absolute values of n1 and n2 are compared, instead of their signed values. Used internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 if <code>n1</code> &lt; <code>n2</code>; zero if <code>n1</code> == <code>n2</code>, or 1 if <code>n1</code> &gt; <code>n2</code>. The nothrow version returns 2 instead of throwing. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02312">2312</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae58734c3f93951819e43af9fff2b9496"></a><!-- doxytag: member="boost::xint::difference" ref="ae58734c3f93951819e43af9fff2b9496" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::difference </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the absolute difference between two integers. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The absolute difference between the parameters.</dd></dl>
<p>This function is especially useful when using unsigned types, because it's faster than doing a comparison to see which integer is larger before doing a subtraction. </p>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01297">1297</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9696321a0a8ddea617223472a62f2452"></a><!-- doxytag: member="boost::xint::divide" ref="a9696321a0a8ddea617223472a62f2452" args="(const integer_t&lt; ... &gt; dividend, const integer_t&lt; ... &gt; divisor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt;::divide_t boost::xint::divide </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>, with the remainder. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dividend,divisor</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>divide_t</code> class containing the quotient and remainder of <code>dividend</code> divided by <code>divisor</code>. The nothrow version returns a <code>divide_t</code> with both items set to Not-a-Number instead of throwing.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1divide__by__zero.html">exceptions::divide_by_zero</a></em>&nbsp;</td><td>if <code>d2</code> is zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator/(integer_t, integer_t) </dd>
<dd>
operator%(integer_t, integer_t) </dd>
<dd>
<a class="el" href="classboost_1_1xint_1_1integer__t.html#a4bf7befde3cb5eff8e6e84b290c0ce50">integer_t::operator/=</a> </dd>
<dd>
<a class="el" href="classboost_1_1xint_1_1integer__t.html#a2144da90955b26120f5cfc724a24b8fc">integer_t::operator%=</a> </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01253">1253</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad58ca08a1482ae77a979027da61d17f4"></a><!-- doxytag: member="boost::xint::gcd" ref="ad58ca08a1482ae77a979027da61d17f4" args="(const integer_t&lt; ... &gt; num1, const integer_t&lt; ... &gt; num2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::gcd </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Greatest Common Denominator of two integers. </p>
<ul>
<li>Complexity: O((log n)<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The greatest common denominator of the two integers, which will always be a positive number. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02242">2242</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f2a052f7f391bddace5348c3adcc97a"></a><!-- doxytag: member="boost::xint::getbit" ref="a1f2a052f7f391bddace5348c3adcc97a" args="(const integer_t&lt; ... &gt; n, bitsize_t bit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::getbit </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitsize_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queries the value of a particular bit in an integer. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit you're asking about.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the specified bit is set (has a value of one), <code>false</code> if it is clear. The nothrow version returns <code>false</code> instead of throwing. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01558">1558</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adee99f516c2480b2381f6c9b1a2abc6e"></a><!-- doxytag: member="boost::xint::highestbit" ref="adee99f516c2480b2381f6c9b1a2abc6e" args="(const integer_t&lt; ... &gt; n, bitsize_t return_if_zero=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a> boost::xint::highestbit </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitsize_t&nbsp;</td>
          <td class="paramname"> <em>return_if_zero</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the index of the highest bit in an integer with a value of one. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>return_if_zero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the highest one-bit in the integer, or <code>return_if_zero</code> if the integer contains no set bits. The nothrow version returns <code>return_if_zero</code> instead of throwing. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01662">1662</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca3ee91c50b15fa902c37fa16763f52b"></a><!-- doxytag: member="boost::xint::invmod" ref="aca3ee91c50b15fa902c37fa16763f52b" args="(const integer_t&lt; ... &gt; n, const integer_t&lt; ... &gt; modulus)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::invmod </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>modulus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular inverse of a number in a modulus, if there is one. </p>
<ul>
<li>Complexity: O((log n)<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to calculate the inverse of. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The modular inverse of <code>n</code> in <code>modulus</code>. If <code>n</code> has no modular inverse in <code>modulus</code>, returns zero.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__modulus.html">exceptions::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01824">1824</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22c8ff3260bcb5c4c8e09e632c488ace"></a><!-- doxytag: member="boost::xint::is_prime" ref="a22c8ff3260bcb5c4c8e09e632c488ace" args="(const integer_t&lt; ... &gt; n, callback_t callback=no_callback)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int boost::xint::is_prime </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em> = <code>no_callback</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests an integer for primality. </p>
<ul>
<li>Complexity: Varies</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to test. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <code>n</code> seems to be prime, 0 if it isn't, or -1 if the provided callback function cancelled the operation. The nothrow version returns -2 instead of throwing.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>n</code> is less than 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the Rabin-Miller probabilistic primality test. There is an infinitesimally small chance that it will think that a composite number is actually prime, but that is so small that it can be ignored for most practical purposes. If even that chance is too much, you can run this function over the number several times, it will use different randomly-selected "witness" numbers each time.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01878">1878</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7740825a61553e51cead8af64ec763c0"></a><!-- doxytag: member="boost::xint::lcm" ref="a7740825a61553e51cead8af64ec763c0" args="(const integer_t&lt; ... &gt; num1, const integer_t&lt; ... &gt; num2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::lcm </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Least Common Multiple of two integers. </p>
<ul>
<li>Complexity: O((log n)<sup>3</sup> + n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The least common multiple of the two integers. If either integer is zero, then the return value will be zero, by convention; in all other cases, the return value will be a positive number. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02276">2276</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec7b803cbc9245ccae1f88e4efab327b"></a><!-- doxytag: member="boost::xint::log2" ref="aec7b803cbc9245ccae1f88e4efab327b" args="(const integer_t&lt; ... &gt; n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::log2 </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the log<sub>2</sub> value of an integer. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer log<sub>2</sub> value of the integer. The nothrow version returns zero instead of throwing.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>pow2(log2(n)-1) will give you an integer with the highest set bit of <code>n</code>, assuming that <code>n</code> is non-zero.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Similar to the <a class="el" href="namespaceboost_1_1xint.html#adee99f516c2480b2381f6c9b1a2abc6e" title="Obtains the index of the highest bit in an integer with a value of one.">highestbit</a> function. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02344">2344</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8512b348c82472dca48edb63f2a1f0e7"></a><!-- doxytag: member="boost::xint::lowestbit" ref="a8512b348c82472dca48edb63f2a1f0e7" args="(const integer_t&lt; ... &gt; n, bitsize_t return_if_zero=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1xint.html#ae9f6d103df04ad19a841ed3f8b94a764">bitsize_t</a> boost::xint::lowestbit </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitsize_t&nbsp;</td>
          <td class="paramname"> <em>return_if_zero</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the index of the lowest bit in an integer with a value of one. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>return_if_zero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the lowest one-bit in the integer, or <code>return_if_zero</code> if the integer contains no set bits. The nothrow version returns <code>return_if_zero</code> instead of throwing. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01633">1633</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca6917c25cdd7cac7c3eda4684567625"></a><!-- doxytag: member="boost::xint::mulmod" ref="aca6917c25cdd7cac7c3eda4684567625" args="(const integer_t&lt; ... &gt; n, const integer_t&lt; ... &gt; by, const integer_t&lt; ... &gt; modulus)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::mulmod </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>modulus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular product of two integers. </p>
<ul>
<li>Complexity: O(2n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to multiply. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>n</code> * <code>by</code> % <code>modulus</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01703">1703</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07e81815254a7ca3afddd5398695a2b7"></a><!-- doxytag: member="boost::xint::operator!=" ref="a07e81815254a7ca3afddd5398695a2b7" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator!= </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01976">1976</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ac4116f3a9285a7f2f10d0104b870f7"></a><!-- doxytag: member="boost::xint::operator%" ref="a0ac4116f3a9285a7f2f10d0104b870f7" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::operator% </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the remainder after dividing a number by another. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1</em>&nbsp;</td><td>The dividend. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n2</em>&nbsp;</td><td>The divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The remainder after dividing <code>n1</code> by <code>n2</code>. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02126">2126</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3bc201c8c1f3e87611abce8e6972538"></a><!-- doxytag: member="boost::xint::operator&amp;" ref="ad3bc201c8c1f3e87611abce8e6972538" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>AND</code> operation. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in both parameters turned on. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02154">2154</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab33a5481a4a4b16ab592be6a88cd245c"></a><!-- doxytag: member="boost::xint::operator*" ref="ab33a5481a4a4b16ab592be6a88cd245c" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::operator* </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the product of two integers. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The product of the parameters.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Automatically uses the more-efficient squaring algorithm if it can trivially detect that the two parameters are copies of the same number. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02069">2069</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15c7951bc910713f8209b7ebd78396da"></a><!-- doxytag: member="boost::xint::operator+" ref="a15c7951bc910713f8209b7ebd78396da" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::operator+ </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the sum of two integers. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sum of the parameters. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02007">2007</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6132105fbe7d7bf7a756b868b6a372e"></a><!-- doxytag: member="boost::xint::operator&#45;" ref="ab6132105fbe7d7bf7a756b868b6a372e" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::operator- </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the difference between two integers. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The difference between the parameters. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02034">2034</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a806df63b92124039591a4ca09a8538e0"></a><!-- doxytag: member="boost::xint::operator/" ref="a806df63b92124039591a4ca09a8538e0" args="(const integer_t&lt; ... &gt; dividend, const integer_t&lt; ... &gt; divisor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::operator/ </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dividend,divisor</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of <code>dividend</code> divided by <code>divisor</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1divide__by__zero.html">exceptions::divide_by_zero</a></em>&nbsp;</td><td>if <code>divisor</code> is zero. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02098">2098</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5698b6ba852f5a119429b17c2a08450"></a><!-- doxytag: member="boost::xint::operator&lt;" ref="af5698b6ba852f5a119429b17c2a08450" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01901">1901</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e501790ec0437c226ce54f98493aad9"></a><!-- doxytag: member="boost::xint::operator&lt;&lt;" ref="a0e501790ec0437c226ce54f98493aad9" args="(std::basic_ostream&lt; charT, traits &gt; &amp;out, const integer_t&lt; ... &gt; n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits , ... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;charT,traits&gt;&amp; boost::xint::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02469">2469</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3daab81a55daeceedd256ce49634d4d"></a><!-- doxytag: member="boost::xint::operator&lt;=" ref="ac3daab81a55daeceedd256ce49634d4d" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01931">1931</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d9f811ac514e033c7fc965b5cd62ee3"></a><!-- doxytag: member="boost::xint::operator==" ref="a7d9f811ac514e033c7fc965b5cd62ee3" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator== </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01961">1961</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1ac6fb8431b231faecf34a5a2d01626"></a><!-- doxytag: member="boost::xint::operator&gt;" ref="ad1ac6fb8431b231faecf34a5a2d01626" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01916">1916</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00c5ad6cf63ecc8ea3a2294ccedac7d3"></a><!-- doxytag: member="boost::xint::operator&gt;=" ref="a00c5ad6cf63ecc8ea3a2294ccedac7d3" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01946">1946</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ad17ed38204ec9a774788ea28368701"></a><!-- doxytag: member="boost::xint::operator&gt;&gt;" ref="a7ad17ed38204ec9a774788ea28368701" args="(std::basic_istream&lt; charT, traits &gt; &amp;in, integer_t&lt; ... &gt; &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits , ... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;charT,traits&gt;&amp; boost::xint::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer_t&lt; ... &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02478">2478</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d1ce319bfb004fb6b93283bcb4f98c2"></a><!-- doxytag: member="boost::xint::operator^" ref="a0d1ce319bfb004fb6b93283bcb4f98c2" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::operator^ </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>XOR</code> operation. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in either parameter, but not both, turned on. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02210">2210</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b58f99b2c5bab4f7eec71d6058b23dd"></a><!-- doxytag: member="boost::xint::operator|" ref="a0b58f99b2c5bab4f7eec71d6058b23dd" args="(const integer_t&lt; ... &gt; n1, const integer_t&lt; ... &gt; n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::operator| </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>OR</code> operation. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in either parameter turned on. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02182">2182</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a483e2fdc6cef9afa1295afeceda4a644"></a><!-- doxytag: member="boost::xint::pow" ref="a483e2fdc6cef9afa1295afeceda4a644" args="(const integer_t&lt; ... &gt; n, const integer_t&lt; ... &gt; e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::pow </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of n<sup>e</sup> </p>
<ul>
<li>Complexity: O(n<sub>n</sub><sup>2</sup>n<sub>e</sub>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,e</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> to the power of <code>e</code>. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01353">1353</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c1648ef679123bb2bf77681ffdfa815"></a><!-- doxytag: member="boost::xint::powmod" ref="a9c1648ef679123bb2bf77681ffdfa815" args="(const integer_t&lt; ... &gt; n, const integer_t&lt; ... &gt; exponent, const integer_t&lt; ... &gt; modulus, bool no_monty=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::powmod </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>exponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>no_monty</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the result of <code>n<sup>e</sup></code> % <code>m</code>, keeping the intermediate results (relatively) small. </p>
<ul>
<li>Complexity: O(n<sub>n</sub><sup>2</sup>n<sub>e</sub>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to exponentiate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>exponent</em>&nbsp;</td><td>The exponent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>no_monty</em>&nbsp;</td><td>Used for testing, leave false for normal operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>pow</code>(n, <code>exponent</code>) % <code>modulus</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__modulus.html">exceptions::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Because this function keeps the intermediate results small, it is far faster and uses far less memory than a naive implementation.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition, this function will use the Montgomery Reduction internally, if the modulus is an odd number (and if <code>no_monty</code> isn't set), which is almost always faster than the non-Montgomery method. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01787">1787</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae957235f76cb2fa0e1530255ccbfa8d0"></a><!-- doxytag: member="boost::xint::setbit" ref="ae957235f76cb2fa0e1530255ccbfa8d0" args="(integer_t&lt; ... &gt; &amp;n, bitsize_t bit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::setbit </td>
          <td>(</td>
          <td class="paramtype">integer_t&lt; ... &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitsize_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a specific bit in an integer to one. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01581">1581</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa41f48c60b257cb321fe89fe0b65b6c3"></a><!-- doxytag: member="boost::xint::sqrmod" ref="aa41f48c60b257cb321fe89fe0b65b6c3" args="(const integer_t&lt; ... &gt; n, const integer_t&lt; ... &gt; modulus)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::sqrmod </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>modulus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular product of squaring an integer. </p>
<ul>
<li>Complexity: O(2n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to square. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>modulus</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>square(n)</code> % <code>modulus</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01742">1742</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac40d60956ef5af3b64804c7a9abffcdd"></a><!-- doxytag: member="boost::xint::square" ref="ac40d60956ef5af3b64804c7a9abffcdd" args="(const integer_t&lt; ... &gt; n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::square </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of n<sup>2</sup> </p>
<ul>
<li>Complexity: O(n(n+1)/2)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> times <code>n</code>.</dd></dl>
<p>The repetitive nature of the input (multiplying a number by itself) allows this function to use a more-efficient algorithm than standard multiplication. </p>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01326">1326</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb957c86cae5940b06172eb23345fe42"></a><!-- doxytag: member="boost::xint::square_root" ref="abb957c86cae5940b06172eb23345fe42" args="(const integer_t&lt; ... &gt; n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer__t.html">integer_t</a>&lt; ... &gt; boost::xint::square_root </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the square root of <code>an</code> integer. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The largest integer that, when squared, is less than or equal to <code>n</code>. If <code>n</code> is not a perfect square, then this value will not be the exact square root.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1cannot__represent.html">exceptions::cannot_represent</a></em>&nbsp;</td><td>if <code>n</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01389">1389</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4aafdf3645cbad0cb3af54fdec4caff"></a><!-- doxytag: member="boost::xint::swap" ref="ab4aafdf3645cbad0cb3af54fdec4caff" args="(integer_t&lt; ... &gt; &amp;left, integer_t&lt; ... &gt; &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::swap </td>
          <td>(</td>
          <td class="paramtype">integer_t&lt; ... &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer_t&lt; ... &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l02510">2510</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9aa52eb4533b04c27329b3f6b7aa842b"></a><!-- doxytag: member="boost::xint::to" ref="a9aa52eb4533b04c27329b3f6b7aa842b" args="(const integer_t&lt; ... &gt; n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , ... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T boost::xint::to </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an <a class="el" href="namespaceboost_1_1xint.html#a3f9537c30e9c1f7341574fcd0223147c" title="The default arbitrary-length integer type.">xint::integer</a> type to a built-in integer type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>The type to convert it to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The numeric value of <code>n</code>, converted to the specified type.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1too__big.html">exceptions::too_big</a></em>&nbsp;</td><td>if <code>n</code> would not fit into the specified type.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides the most efficient means of converting to a built-in integral type. The nothrow version returns T(0) instead of throwing. </p>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01429">1429</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36d0321bee2aade461e0f504400c7c1b"></a><!-- doxytag: member="boost::xint::to_binary" ref="a36d0321bee2aade461e0f504400c7c1b" args="(const integer_t&lt; ... &gt; n, bitsize_t bits=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a> boost::xint::to_binary </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitsize_t&nbsp;</td>
          <td class="paramname"> <em>bits</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a binary representation of an integer. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The number of bits to pack into each character (for portability with systems that might not have characters with the same number of bits), or zero (the default) to assume the number of bits in the current system's unsigned character type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58" title="The format for the binary representations of integers.">xint::binary_t</a></code> containing the binary representation, lowest byte first. The nothrow version returns an empty <code>binary_t</code> object instead of throwing.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>bits</code> is greater than the number of bits in an unsigned character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function only stores the absolute value of <code>n</code>; if you need the sign, you must store it separately.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A binary representation is sometimes desirable for persistent storage or transmission, as it is more space-efficient than a string representation.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classboost_1_1xint_1_1integer__t.html#a864a599e2de326e6e339ffc820fd849e" title="Converts a portable binary representation of a number into an integer.">integer_t::integer_t(xint::binary_t, bitsize_t bits)</a> </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01528">1528</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fb5a8cfac3e97a1641d424aac04a71f"></a><!-- doxytag: member="boost::xint::to_string" ref="a2fb5a8cfac3e97a1641d424aac04a71f" args="(const integer_t&lt; ... &gt; n, std::size_t base=10, bool uppercase=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string boost::xint::to_string </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>uppercase</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A shorthand function that calls <a class="el" href="namespaceboost_1_1xint.html#a12e9d9268bae5d099227af78c1dea758">to_stringtype&lt;char&gt;</a>. </p>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01484">1484</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12e9d9268bae5d099227af78c1dea758"></a><!-- doxytag: member="boost::xint::to_stringtype" ref="a12e9d9268bae5d099227af78c1dea758" args="(const integer_t&lt; ... &gt; n, std::size_t base=10, bool uppercase=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , ... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt;charT&gt; boost::xint::to_stringtype </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>uppercase</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a string representation of the specified integer. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>charT</em>&nbsp;</td><td>The type of string to create.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>The base, between 2 and 36 inclusive, to convert it to. Defaults to base 10. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uppercase</em>&nbsp;</td><td>Whether to make alphabetic characters (for bases greater than ten) uppercase or not. Defaults to <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string value of <code>n</code>. The nothrow version returns the string "#NaN#" if <code>n</code> is a Not-a-Number, and an empty string instead of throwing.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__base.html">exceptions::invalid_base</a></em>&nbsp;</td><td>if base is less than two or greater than 36.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when you ask the library to write an integer to a stream, but it's more flexible because you can specify any base between 2 and 36. (Streams only allow base-8, base-10, or base-16.) </dd></dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01465">1465</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f24b4e0dc6e6c5de02480f5fb352030"></a><!-- doxytag: member="boost::xint::to_wstring" ref="a6f24b4e0dc6e6c5de02480f5fb352030" args="(const integer_t&lt; ... &gt; n, std::size_t base=10, bool uppercase=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::wstring boost::xint::to_wstring </td>
          <td>(</td>
          <td class="paramtype">const integer_t&lt; ... &gt;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>uppercase</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A shorthand function that calls <a class="el" href="namespaceboost_1_1xint.html#a12e9d9268bae5d099227af78c1dea758">to_stringtype&lt;wchar_t&gt;</a>. </p>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l01494">1494</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a6e2c55f95b91dfcb7586599faca34cb2"></a><!-- doxytag: member="boost::xint::autobase" ref="a6e2c55f95b91dfcb7586599faca34cb2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::size_t <a class="el" href="namespaceboost_1_1xint.html#a6e2c55f95b91dfcb7586599faca34cb2">boost::xint::autobase</a> = (std::numeric_limits&lt;size_t&gt;::max)()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A value that can be used for the 'base' parameter of the string-to-integer constructor functions. </p>

<p>Definition at line <a class="el" href="basic__types__and__includes_8hpp_source.html#l00086">86</a> of file <a class="el" href="basic__types__and__includes_8hpp_source.html">basic_types_and_includes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a758d415a476a5eeed28dc6b5869b1696"></a><!-- doxytag: member="boost::xint::no_callback" ref="a758d415a476a5eeed28dc6b5869b1696" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> <a class="el" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696">boost::xint::no_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An empty callback_t, used as a default parameter for some functions. </p>

<p>Definition at line <a class="el" href="basic__types__and__includes_8hpp_source.html#l00079">79</a> of file <a class="el" href="basic__types__and__includes_8hpp_source.html">basic_types_and_includes.hpp</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Jun 18 20:03:13 2010 for The Extended Integer (XInt) Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
