<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>The Extended Integer (XInt) Library: xint Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xint Namespace Reference</h1>
<p>All of the functions in the XInt library are within this namespace.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint_1_1detail.html">detail</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The items within this namespace are meant for internal use only. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1integer.html">integer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The extended integer class.  <a href="classxint_1_1integer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1strong__random__generator.html">strong_random_generator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience class for cryptographically-secure random numbers.  <a href="classxint_1_1strong__random__generator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1invalid__base.html">invalid_base</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class.  <a href="classxint_1_1invalid__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1invalid__digit.html">invalid_digit</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class.  <a href="classxint_1_1invalid__digit.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1invalid__modulus.html">invalid_modulus</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class.  <a href="classxint_1_1invalid__modulus.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1divide__by__zero.html">divide_by_zero</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class.  <a href="classxint_1_1divide__by__zero.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1cannot__represent.html">cannot_represent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class.  <a href="classxint_1_1cannot__represent.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1too__big.html">too_big</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class.  <a href="classxint_1_1too__big.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1not__a__number.html">not_a_number</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class.  <a href="classxint_1_1not__a__number.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1no__strong__random.html">no_strong_random</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class.  <a href="classxint_1_1no__strong__random.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxint_1_1overflow__error.html">overflow_error</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception class.  <a href="classxint_1_1overflow__error.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="structxint_1_1detail_1_1token.html">detail::token</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ad63045584f06221eb6a7581ad3091582">token</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for the exception-blocker.  <a href="#ad63045584f06221eb6a7581ad3091582"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; bool()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ac8a660c33746c536469d347307b8da7a">callback_t</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Bit-manipulation functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpcc775c18f98f26f2b84ac7a2558636f2"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a07bc7378c8a55e5f92aaef6d8b8ce952">getbit</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the value of a particular bit in an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>.  <a href="#a07bc7378c8a55e5f92aaef6d8b8ce952"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#adf2652627e78682c17e120816987984a">setbit</a> (<a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a specific bit in an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to one.  <a href="#adf2652627e78682c17e120816987984a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a8982e3e3ab7c1c763416eadc479d9724">clearbit</a> (<a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a specific bit in an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to zero.  <a href="#a8982e3e3ab7c1c763416eadc479d9724"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ae04d70f50c4ce73d27ab32b1bf3520f2">lowestbit</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, size_t valueIfZero)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the index of the lowest bit in an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with a value of one.  <a href="#ae04d70f50c4ce73d27ab32b1bf3520f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ae08828243165ef3f397461507368a6e5">highestbit</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, size_t valueIfZero)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the index of the highest bit in an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with a value of one.  <a href="#ae08828243165ef3f397461507368a6e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a06138585f07fe098e24718c46e3078e1">bitwise_and</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>AND</code> operation.  <a href="#a06138585f07fe098e24718c46e3078e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a8cd0a0dbc779e5a75c9e2f8027474e9a">bitwise_or</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>OR</code> operation.  <a href="#a8cd0a0dbc779e5a75c9e2f8027474e9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a9ffe18a09f5dd354af7b967b032d3cbe">bitwise_xor</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>XOR</code> operation.  <a href="#a9ffe18a09f5dd354af7b967b032d3cbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a4f4dacd6f9398aaa500112731ab713ce">shift</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, int byBits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-shift an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>, in either direction.  <a href="#a4f4dacd6f9398aaa500112731ab713ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a6799cc3c4d8c963279be64b209bfd3b6">shift_left</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, size_t byBits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Left-shift an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> by a specified number of bits.  <a href="#a6799cc3c4d8c963279be64b209bfd3b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a49a5a4220cb88b7446545e4b65950473">shift_right</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, size_t byBits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Right-shift an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> by a specified number of bits.  <a href="#a49a5a4220cb88b7446545e4b65950473"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp458f92801f3edfaf2e30b1f530c324e2"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#aff82dd47fae4297b96282371abf4db06">compare</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;b1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;b2, bool ignoresign)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> objects.  <a href="#aff82dd47fae4297b96282371abf4db06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ac9e11516ac502e97be1902cde50f97e7">gcd</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the Greatest Common Denominator of two integers.  <a href="#ac9e11516ac502e97be1902cde50f97e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a17c5e4e807cfa425f48d9f5b464bc8dc">lcm</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the Least Common Multiple of two integers.  <a href="#a17c5e4e807cfa425f48d9f5b464bc8dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a820d89c1d761a0a2c06479b1c1f9cecd">opt_secure_mode</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the library was compiled with <a class="el" href="securemode.html">Secure Mode </a> enabled.  <a href="#a820d89c1d761a0a2c06479b1c1f9cecd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ad55aa4d44083238d9ec313511f5b1dfa">opt_thread_safe</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the library was compiled with the <a class="el" href="threadsafe.html">Thread Safe Operation option </a> enabled.  <a href="#ad55aa4d44083238d9ec313511f5b1dfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#aa074495871d366c760c5b0713f5ef048">log2</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the log<sub>2</sub> value of an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>.  <a href="#aa074495871d366c760c5b0713f5ef048"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb3c5827f54218753bb2c3338236446c2"></a> These act exactly the same as for the built-in integer types. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a675c4fe6ddda6db915450d054ed640ba">operator!</a> (const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ad32051708c2a2baafa0340e19e90217b">operator==</a> (const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#aefda934d0ffacd0f44fcbbdfee19a139">operator!=</a> (const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a4f4a4771bf443e6724abbd18173ecc86">operator&lt;</a> (const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a1229d1f1efbdf3ffeac8b2964ca66093">operator&gt;</a> (const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ab9d5f34c4d4bed1c86380d4f72edcd9b">operator&lt;=</a> (const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a766324a6f216f3b49a3e9aa885e9531c">operator&gt;=</a> (const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a586fb0eb69100ec74be94008ac26670d">operator+</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a8a510361ed458133ebfa5fd95f8d9c27">operator-</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a211ff80bb081c08674272cfcae736a93">operator+</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a1e09422b575c6d29ea5c0d627b79c28e">operator-</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#aea36ad9037f109576d4f95ec72b5c825">operator*</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a701217f7824c3e935fca25147da23807">operator/</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ae0505757986a9c7133552552471aae24">operator%</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a742550f1c62ac8c2bde8e1ceab2a466c">operator&amp;</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#afa8f2a0ac996ad45efc73b2aa056cae2">operator|</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a81722cd257bc950ba7c56a202492544f">operator^</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp9c2e8a06d85d2c9b83b5a0d27e85d535"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a016c9573ff48411847edf86c406946a0">to_string</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, size_t base, bool uppercase)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a string representation of the specified <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>.  <a href="#a016c9573ff48411847edf86c406946a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ad9dcb2b835be5f8ee918979945911ac0">from_string</a> (const std::string &amp;str, size_t base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a string into an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>.  <a href="#ad9dcb2b835be5f8ee918979945911ac0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ac2ac2f74b45e4179560d845e6310be9a">from_binary</a> (const std::string &amp;str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a binary representation of a number into an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>.  <a href="#ac2ac2f74b45e4179560d845e6310be9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ab8f33201a251e3e118dc82f214e22aeb">to_binary</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a binary representation of an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>, lowest byte first.  <a href="#ab8f33201a251e3e118dc82f214e22aeb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexint.html#a21bd738b96eec205eedc7a9960e9a6e5">to</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Efficiently converts from an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">xint::integer</a> to a built-in integer type.  <a href="#a21bd738b96eec205eedc7a9960e9a6e5"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Exception-blocking and -allowing functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6b736a9df3b9afabec548528235f28b6"></a> See the <a class="el" href="exceptions.html">exception-blocking page</a> for details on these functions and how to use them. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ac8be41374700d89400f5ecddf0f789e3">exceptions_allowed</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query whether exceptions are currently allowed or blocked.  <a href="#ac8be41374700d89400f5ecddf0f789e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxint_1_1detail_1_1token.html">token</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ae7e3f6afc701f6e8873a407bb418d04c">block_exceptions</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporarily prevent the library from throwing blockable exceptions.  <a href="#ae7e3f6afc701f6e8873a407bb418d04c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structxint_1_1detail_1_1token.html">token</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a4b5a1a791ba11bb8f158a3b56bd9723e">allow_exceptions</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temprarily counteract an <a class="el" href="namespacexint.html#ae7e3f6afc701f6e8873a407bb418d04c" title="Temporarily prevent the library from throwing blockable exceptions.">xint::block_exceptions</a> token to allow all exceptions.  <a href="#a4b5a1a791ba11bb8f158a3b56bd9723e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Modular math functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpbf63e6a6a1029bb25b7aa51052b38655"></a>A common reason to use a large-integer library is to implement public-key encryption, and the algorithms for such encryption often use modular math. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a4a79f60ebe198eadf10b63924018ce66">invmod</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular inverse of a number in a modulus, if there is one.  <a href="#a4a79f60ebe198eadf10b63924018ce66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ad5a8cc6e57ee8abdc21be98275657cc8">mod</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remainder after dividing a number by another.  <a href="#ad5a8cc6e57ee8abdc21be98275657cc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#adbbde6cc4b65e9a3df8c52adad9c540f">mulmod</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;by, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular product of two integers.  <a href="#adbbde6cc4b65e9a3df8c52adad9c540f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#aa5564979e78556afdc68dbbd744a0bcb">sqrmod</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular product of squaring an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>.  <a href="#aa5564979e78556afdc68dbbd744a0bcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ac54e9be3a8b131f882f88e57b0ef1c9c">powmod</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;e, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;m, bool noMontgomery)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the result of <code>n<sup>e</sup></code> % <code>m</code>, keeping the intermediate results (relatively) small.  <a href="#ac54e9be3a8b131f882f88e57b0ef1c9c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Montgomery Reduction functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpef45384829a28a8031424a8c453ceaa0"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">digit_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#afd561fd7c7631267fbc7e5c75c2bde71">inverse0</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the low digit of the inverse of a number. Used internally.  <a href="#afd561fd7c7631267fbc7e5c75c2bde71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#aaf3b26669d4e61f6af5dcae42b20e08b">montgomeryR</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the most efficient R value for a number and the library's internal representation. Used internally.  <a href="#aaf3b26669d4e61f6af5dcae42b20e08b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ab8e85cd5425fcec419c07155e2a91e13">toMontgomeryForm</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the Montgomery form of a number. Used for testing.  <a href="#ab8e85cd5425fcec419c07155e2a91e13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a93ed16c5350b34ca22108e48b51918a5">fromMontgomeryForm</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> from the Montgomery form of a number. Used for testing.  <a href="#a93ed16c5350b34ca22108e48b51918a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a722769c7d01e06d9f82eae07a280160c">montgomeryMultiplyMod</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;a, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;b, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, digit_t nPrime0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the Montgomery equivalent of <code>mulmod(a, b, n)</code>. Used internally.  <a href="#a722769c7d01e06d9f82eae07a280160c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a7d7e8604c467bc007820c60e1bc21626">montgomeryPowerMod</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;a, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;e, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the Montgomery equivalent of <code>powmod(a, b, n)</code>. Used internally.  <a href="#a7d7e8604c467bc007820c60e1bc21626"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Powers and roots</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp928a8cb047602f789d7433e262ed4560"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a6b723c30c28eb57f611442e0b512f551">pow2</a> (size_t e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of 2<sup>e</sup>.  <a href="#a6b723c30c28eb57f611442e0b512f551"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a0aec423511839fd784b1654389dfcf5b">sqr</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of n<sup>2</sup>.  <a href="#a0aec423511839fd784b1654389dfcf5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a186b14f991b32a818abd553b56a13a62">pow</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of n<sup>e</sup>.  <a href="#a186b14f991b32a818abd553b56a13a62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#aba188df925c87a0f33a79328e31e1a50">factorial</a> (size_t n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of <code>n!</code>  <a href="#aba188df925c87a0f33a79328e31e1a50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a74891726f8af86736169dd43b929ad0a">sqrt</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the square root of <code>an</code> <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>.  <a href="#a74891726f8af86736169dd43b929ad0a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Prime number functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp540e8e12721acbe497d2b9b53ecc76ec"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ab205c4e52dbc6825cefe3a251f6ca99f">is_prime</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, <a class="el" href="namespacexint.html#ac8a660c33746c536469d347307b8da7a">callback_t</a> callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> for primality.  <a href="#ab205c4e52dbc6825cefe3a251f6ca99f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#afc8ba5f62561b4d2b42e32dde1a10ef3">random_prime</a> (size_t size_in_bits, <a class="el" href="namespacexint.html#ac8a660c33746c536469d347307b8da7a">callback_t</a> callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a randomly-generated prime number of a particular bit-size.  <a href="#afc8ba5f62561b4d2b42e32dde1a10ef3"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical primitives</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp196dd2a5f50860e057df961a96d84ea3"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ac9e4ed282bafa93dbf608350df0127ba">abs</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the absolute value of an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>.  <a href="#ac9e4ed282bafa93dbf608350df0127ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ab393826381b1abd9f1aca1cdb45f41f6">negate</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the additive inverse of an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>.  <a href="#ab393826381b1abd9f1aca1cdb45f41f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a7cc636a05af16eba73014bf88273d163">add</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the sum of two integers.  <a href="#a7cc636a05af16eba73014bf88273d163"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#af196cd74cb23970032fddcce71957a80">subtract</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the difference between two integers.  <a href="#af196cd74cb23970032fddcce71957a80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#af3d7059ec08bf075cec5685deca55c5d">multiply</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;by)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the product of two integers.  <a href="#af3d7059ec08bf075cec5685deca55c5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#abf3d47f1ef1fdf334097fab055886a44">divide</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;dividend, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;divisor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate how many <code>dividends</code> would fit into <code>divisor</code>.  <a href="#abf3d47f1ef1fdf334097fab055886a44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classxint_1_1integer.html">integer</a>, <a class="el" href="classxint_1_1integer.html">integer</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a23d0a0bb05cec1917d96d6aaceeb875d">divide_r</a> (const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;d1, const <a class="el" href="classxint_1_1integer.html">integer</a> &amp;d2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate how many <code>dividends</code> would fit into <code>divisor</code>, with the remainder.  <a href="#a23d0a0bb05cec1917d96d6aaceeb875d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Random number functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpdd4713a71c208a173c1f2436d4e32ff7"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a5da6e81cb78913cc61c9f14857700b5e">random_by_size</a> (size_t bits, bool high_bit_on, bool low_bit_on, bool can_be_negative)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a random <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with specific attributes.  <a href="#a5da6e81cb78913cc61c9f14857700b5e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexint.html#a9c50302b216b64d17d9c1d6350e88036">set_random_generator</a> (T *gen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the random generator that the library uses.  <a href="#a9c50302b216b64d17d9c1d6350e88036"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream input/output functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9927783c44c1aad288df0ab8bfa9ddf"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexint.html#aa5b0dc228caee6523766326cf40297cd">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;out, const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexint.html#a27a0715c66d7350b0f3800f6e161816f">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;in, <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;n)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Self-Testing Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpe91fba8935c0c10717694cc0393febf3"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a509778d505a3c8a0b335817150eaead2">testBitManipulations</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a6b7f5122683b6d924bf86c7d1507206b">testAddSubtract</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#affe2e221777d4263a420d014fa9640d0">testMultiply</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a4ed78ff75865ae44a00d3709dd88c3a1">testDivideMod</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ae4ef5f20964fa995df7828f27bd7adbe">testConvert</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ae3305f62ca9be58fbc11dbd4c703f38b">testStreams</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#ac40068d64f8c4d9002a0687935888c42">testMontyMultiply</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a9cce0401174b9ae173671b0800c5f457">testMontyPowerMod</a> ()</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacexint.html#ac8a660c33746c536469d347307b8da7a">callback_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a44496f258b36237d4cea35558a71017a">no_callback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexint.html#a7a5434a5f5fb1db19f0de18014c4fc41">autobase</a> = (std::numeric_limits&lt;size_t&gt;::max)()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>All of the functions in the XInt library are within this namespace. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ac8a660c33746c536469d347307b8da7a"></a><!-- doxytag: member="xint::callback_t" ref="ac8a660c33746c536469d347307b8da7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;bool ()&gt; <a class="el" href="namespacexint.html#ac8a660c33746c536469d347307b8da7a">xint::callback_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A callback function takes no parameters and returns a bool. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacexint.html#ab205c4e52dbc6825cefe3a251f6ca99f" title="Tests an integer for primality.">xint::is_prime</a> </dd>
<dd>
<a class="el" href="namespacexint.html#afc8ba5f62561b4d2b42e32dde1a10ef3" title="Generate a randomly-generated prime number of a particular bit-size.">xint::random_prime</a> </dd></dl>

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00113">113</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad63045584f06221eb6a7581ad3091582"></a><!-- doxytag: member="xint::token" ref="ad63045584f06221eb6a7581ad3091582" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::auto_ptr&lt;<a class="el" href="structxint_1_1detail_1_1token.html">detail::token</a>&gt; <a class="el" href="structxint_1_1detail_1_1token.html">xint::token</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used for the exception-blocker. </p>

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00108">108</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac9e4ed282bafa93dbf608350df0127ba"></a><!-- doxytag: member="xint::abs" ref="ac9e4ed282bafa93dbf608350df0127ba" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::abs </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the absolute value of an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If <code>n</code> is zero or positive, returns <code>n</code>. Otherwise returns <code>-n</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cc636a05af16eba73014bf88273d163"></a><!-- doxytag: member="xint::add" ref="a7cc636a05af16eba73014bf88273d163" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::add </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the sum of two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sum of the parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b5a1a791ba11bb8f158a3b56bd9723e"></a><!-- doxytag: member="xint::allow_exceptions" ref="a4b5a1a791ba11bb8f158a3b56bd9723e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxint_1_1detail_1_1token.html">token</a> xint::allow_exceptions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Temprarily counteract an <a class="el" href="namespacexint.html#ae7e3f6afc701f6e8873a407bb418d04c" title="Temporarily prevent the library from throwing blockable exceptions.">xint::block_exceptions</a> token to allow all exceptions. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="namespacexint.html#ad63045584f06221eb6a7581ad3091582" title="Used for the exception-blocker.">xint::token</a>. Until this token is destroyed, blockable exceptions can be thrown, unless explicitly re-blocked.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Exceptions are allowed by default.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>When the library is compiled for <a class="el" href="threadsafe.html">thread-safe operation</a>, exceptions are blocked or allowed on a per-thread basis. Otherwise they are blocked or allowed globally.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="exceptions.html">Exceptions and Exception-Blocking</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a06138585f07fe098e24718c46e3078e1"></a><!-- doxytag: member="xint::bitwise_and" ref="a06138585f07fe098e24718c46e3078e1" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::bitwise_and </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>AND</code> operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with all bits that are set in both parameters turned on. </dd></dl>

</div>
</div>
<a class="anchor" id="a8cd0a0dbc779e5a75c9e2f8027474e9a"></a><!-- doxytag: member="xint::bitwise_or" ref="a8cd0a0dbc779e5a75c9e2f8027474e9a" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::bitwise_or </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>OR</code> operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with all bits that are set in either parameter turned on. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ffe18a09f5dd354af7b967b032d3cbe"></a><!-- doxytag: member="xint::bitwise_xor" ref="a9ffe18a09f5dd354af7b967b032d3cbe" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::bitwise_xor </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>XOR</code> operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with all bits that are set in either parameter, but not both, turned on. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7e3f6afc701f6e8873a407bb418d04c"></a><!-- doxytag: member="xint::block_exceptions" ref="ae7e3f6afc701f6e8873a407bb418d04c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structxint_1_1detail_1_1token.html">token</a> xint::block_exceptions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Temporarily prevent the library from throwing blockable exceptions. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="namespacexint.html#ad63045584f06221eb6a7581ad3091582" title="Used for the exception-blocker.">xint::token</a>. Until this token is destroyed, blockable exceptions are blocked, unless explicitly re-enabled.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>When the library is compiled for <a class="el" href="threadsafe.html">thread-safe operation</a>, exceptions are blocked or allowed on a per-thread basis. Otherwise they are blocked or allowed globally.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="exceptions.html">Exceptions and Exception-Blocking</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8982e3e3ab7c1c763416eadc479d9724"></a><!-- doxytag: member="xint::clearbit" ref="a8982e3e3ab7c1c763416eadc479d9724" args="(integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xint::clearbit </td>
          <td>(</td>
          <td class="paramtype">integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a specific bit in an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="aff82dd47fae4297b96282371abf4db06"></a><!-- doxytag: member="xint::compare" ref="aff82dd47fae4297b96282371abf4db06" args="(const integer &amp;b1, const integer &amp;b2, bool ignoresign)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xint::compare </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoresign</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b1,b2</em>&nbsp;</td><td>The integers to compare. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignoresign</em>&nbsp;</td><td>If <code>true</code>, the absolute values of b1 and b2 are compared, instead of their signed values. Used internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative number if <code>b1</code> &lt; <code>b2</code>; zero if <code>b1</code> == <code>b2</code>, or a positive number if <code>b1</code> &gt; <code>b2</code>.</dd></dl>
<p>This is the function behind all of the comparison operators. It might sometimes be useful directly as well. </p>

</div>
</div>
<a class="anchor" id="abf3d47f1ef1fdf334097fab055886a44"></a><!-- doxytag: member="xint::divide" ref="abf3d47f1ef1fdf334097fab055886a44" args="(const integer &amp;dividend, const integer &amp;divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::divide </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dividend,divisor</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> value of <code>dividend</code> divided by <code>divisor</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classxint_1_1divide__by__zero.html" title="Exception class.">xint::divide_by_zero</a></em>&nbsp;</td><td>if <code>divisor</code> is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23d0a0bb05cec1917d96d6aaceeb875d"></a><!-- doxytag: member="xint::divide_r" ref="a23d0a0bb05cec1917d96d6aaceeb875d" args="(const integer &amp;d1, const integer &amp;d2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classxint_1_1integer.html">integer</a>, <a class="el" href="classxint_1_1integer.html">integer</a> &gt; xint::divide_r </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>d2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>, with the remainder. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d1</em>&nbsp;</td><td>The dividend. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d2</em>&nbsp;</td><td>The divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code>std::pair</code> containing the quotient and remainder of <code>d1</code> divided by <code>d2</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classxint_1_1divide__by__zero.html" title="Exception class.">xint::divide_by_zero</a></em>&nbsp;</td><td>if <code>d2</code> is zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If exceptions are blocked, it will return an std::pair with two Not-a-Number values instead of throwing. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8be41374700d89400f5ecddf0f789e3"></a><!-- doxytag: member="xint::exceptions_allowed" ref="ac8be41374700d89400f5ecddf0f789e3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::exceptions_allowed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query whether exceptions are currently allowed or blocked. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if exceptions are currently allowed (the default state), <code>false</code> if they're blocked.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>When the library is compiled for <a class="el" href="threadsafe.html">thread-safe operation</a>, exceptions are blocked or allowed on a per-thread basis. Otherwise they are blocked or allowed globally. </dd></dl>

</div>
</div>
<a class="anchor" id="aba188df925c87a0f33a79328e31e1a50"></a><!-- doxytag: member="xint::factorial" ref="aba188df925c87a0f33a79328e31e1a50" args="(size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::factorial </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of <code>n!</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> factorial, defined as <code>1*2*3*...*n</code></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Factorials get ridiculously huge, even with fairly small values of <code>n</code>. This function, when used with a large parameter, is the easiest way to exhaust the system's memory. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2ac2f74b45e4179560d845e6310be9a"></a><!-- doxytag: member="xint::from_binary" ref="ac2ac2f74b45e4179560d845e6310be9a" args="(const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::from_binary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a binary representation of a number into an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>str</em>&nbsp;</td><td>An <code>std::string</code> containing the bytes to convert, lowest byte first.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> representing the bytes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacexint.html#ab8f33201a251e3e118dc82f214e22aeb" title="Creates a binary representation of an integer, lowest byte first.">xint::to_binary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad9dcb2b835be5f8ee918979945911ac0"></a><!-- doxytag: member="xint::from_string" ref="ad9dcb2b835be5f8ee918979945911ac0" args="(const std::string &amp;str, size_t base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a string into an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>str</em>&nbsp;</td><td>The string to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>the base that the string representation of the number is in. This can be any number between 2 and 36 (inclusive). It can also be the constant <a class="el" href="namespacexint.html#a7a5434a5f5fb1db19f0de18014c4fc41">xint::autobase</a>, in which case the function will follow the standard C/C++ rules for interpreting a numeric constant: any number with a zero as the first digit is assumed to be base-8; any number with a leading zero-x or zero-X (such as 0x1f) is base-16, and anything else is base-10.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with the numeric value of the string in base <code>base</code>. If the string is <code>#NaN#</code>, then it will return <a class="el" href="nan.html">Not-a-Number</a>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classxint_1_1overflow__error.html" title="Exception class.">xint::overflow_error</a></em>&nbsp;</td><td>if there is not enough free memory to create the <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classxint_1_1invalid__base.html" title="Exception class.">xint::invalid_base</a></em>&nbsp;</td><td>if the base parameter is not between 2 and 36 (inclusive) or the constant <a class="el" href="namespacexint.html#a7a5434a5f5fb1db19f0de18014c4fc41">xint::autobase</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classxint_1_1invalid__digit.html" title="Exception class.">xint::invalid_digit</a></em>&nbsp;</td><td>if the string contains any digit that cannot be part of a number in the specified base, or if there are no valid digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when reading an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> from a stream, or when contructing one from a string.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classxint_1_1integer.html#a6dfc86dfc539cfda1062ef1bc24aa526" title="Create an integer from a string representation.">integer::integer(const std::string&amp; str, size_t base)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a93ed16c5350b34ca22108e48b51918a5"></a><!-- doxytag: member="xint::fromMontgomeryForm" ref="a93ed16c5350b34ca22108e48b51918a5" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::fromMontgomeryForm </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> from the Montgomery form of a number. Used for testing. </p>

</div>
</div>
<a class="anchor" id="ac9e11516ac502e97be1902cde50f97e7"></a><!-- doxytag: member="xint::gcd" ref="ac9e11516ac502e97be1902cde50f97e7" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::gcd </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Greatest Common Denominator of two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The greatest common denominator of the two integers, which will always be a positive number. </dd></dl>

</div>
</div>
<a class="anchor" id="a07bc7378c8a55e5f92aaef6d8b8ce952"></a><!-- doxytag: member="xint::getbit" ref="a07bc7378c8a55e5f92aaef6d8b8ce952" args="(const integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::getbit </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queries the value of a particular bit in an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit you're asking about.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the specified bit is set (has a value of one), <code>false</code> if it is clear. </dd></dl>

</div>
</div>
<a class="anchor" id="ae08828243165ef3f397461507368a6e5"></a><!-- doxytag: member="xint::highestbit" ref="ae08828243165ef3f397461507368a6e5" args="(const integer &amp;n, size_t valueIfZero)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t xint::highestbit </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>valueIfZero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the index of the highest bit in an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with a value of one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>valueIfZero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the highest one-bit in the <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>, or <code>valueIfZero</code> if the <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> contains no set bits. </dd></dl>

</div>
</div>
<a class="anchor" id="afd561fd7c7631267fbc7e5c75c2bde71"></a><!-- doxytag: member="xint::inverse0" ref="afd561fd7c7631267fbc7e5c75c2bde71" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacexint_1_1detail.html#a8843fb7e364832d8d5983de28bdbcf34">detail::digit_t</a> xint::inverse0 </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the low digit of the inverse of a number. Used internally. </p>

</div>
</div>
<a class="anchor" id="a4a79f60ebe198eadf10b63924018ce66"></a><!-- doxytag: member="xint::invmod" ref="a4a79f60ebe198eadf10b63924018ce66" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::invmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular inverse of a number in a modulus, if there is one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to retrieve the inverse of. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The modular inverse of <code>n</code> in <code>m</code>. If <code>n</code> has no modular inverse in <code>m</code>, returns zero.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classxint_1_1invalid__modulus.html" title="Exception class.">xint::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If exceptions are blocked, it returns zero instead of throwing an exception. </dd></dl>

</div>
</div>
<a class="anchor" id="ab205c4e52dbc6825cefe3a251f6ca99f"></a><!-- doxytag: member="xint::is_prime" ref="ab205c4e52dbc6825cefe3a251f6ca99f" args="(const integer &amp;n, callback_t callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xint::is_prime </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> for primality. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to test. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <code>n</code> seems to be prime, 0 if it isn't, or -1 if the provided callback function cancelled the operation.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>if <code>n</code> is less than 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If exceptions are blocked, it will return -1 instead of throwing an exception.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the Rabin-Miller probabilistic primality test. There is an infinitesimally small chance that it will think that a composite number is actually prime, but that is so small that it can be ignored for most practical purposes. If even that chance is too much, you can run this function over the number several times, it will use different random "witness" numbers each time.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a17c5e4e807cfa425f48d9f5b464bc8dc"></a><!-- doxytag: member="xint::lcm" ref="a17c5e4e807cfa425f48d9f5b464bc8dc" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::lcm </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Least Common Multiple of two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The least common multiple of the two integers. If either <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> is zero, then the return value will be zero, by convention; in all other cases, the return value will be a positive number. </dd></dl>

</div>
</div>
<a class="anchor" id="aa074495871d366c760c5b0713f5ef048"></a><!-- doxytag: member="xint::log2" ref="aa074495871d366c760c5b0713f5ef048" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t xint::log2 </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the log<sub>2</sub> value of an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer log<sub>2</sub> value of the <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="namespacexint.html#a6b723c30c28eb57f611442e0b512f551" title="Calculate the value of 2e.">xint::pow2</a>(xint::log2(n)-1) will give you an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with the highest set bit of <code>n</code>, assuming that <code>n</code> is non-zero.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Similar to the <a class="el" href="namespacexint.html#ae08828243165ef3f397461507368a6e5" title="Obtains the index of the highest bit in an integer with a value of one.">xint::highestbit</a> function. </dd></dl>

</div>
</div>
<a class="anchor" id="ae04d70f50c4ce73d27ab32b1bf3520f2"></a><!-- doxytag: member="xint::lowestbit" ref="ae04d70f50c4ce73d27ab32b1bf3520f2" args="(const integer &amp;n, size_t valueIfZero)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t xint::lowestbit </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>valueIfZero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the index of the lowest bit in an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with a value of one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>valueIfZero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the lowest one-bit in the <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>, or <code>valueIfZero</code> if the <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> contains no set bits. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5a8cc6e57ee8abdc21be98275657cc8"></a><!-- doxytag: member="xint::mod" ref="ad5a8cc6e57ee8abdc21be98275657cc8" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::mod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the remainder after dividing a number by another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The dividend. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>n</code> % <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a722769c7d01e06d9f82eae07a280160c"></a><!-- doxytag: member="xint::montgomeryMultiplyMod" ref="a722769c7d01e06d9f82eae07a280160c" args="(const integer &amp;a, const integer &amp;b, const integer &amp;n, digit_t nPrime0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::montgomeryMultiplyMod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">digit_t&nbsp;</td>
          <td class="paramname"> <em>nPrime0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Montgomery equivalent of <code>mulmod(a, b, n)</code>. Used internally. </p>

</div>
</div>
<a class="anchor" id="a7d7e8604c467bc007820c60e1bc21626"></a><!-- doxytag: member="xint::montgomeryPowerMod" ref="a7d7e8604c467bc007820c60e1bc21626" args="(const integer &amp;a, const integer &amp;e, const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::montgomeryPowerMod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Montgomery equivalent of <code>powmod(a, b, n)</code>. Used internally. </p>

</div>
</div>
<a class="anchor" id="aaf3b26669d4e61f6af5dcae42b20e08b"></a><!-- doxytag: member="xint::montgomeryR" ref="aaf3b26669d4e61f6af5dcae42b20e08b" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::montgomeryR </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the most efficient R value for a number and the library's internal representation. Used internally. </p>

</div>
</div>
<a class="anchor" id="adbbde6cc4b65e9a3df8c52adad9c540f"></a><!-- doxytag: member="xint::mulmod" ref="adbbde6cc4b65e9a3df8c52adad9c540f" args="(const integer &amp;n, const integer &amp;by, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::mulmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular product of two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to multiply. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>n</code> * <code>by</code> % <code>m</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>

</div>
</div>
<a class="anchor" id="af3d7059ec08bf075cec5685deca55c5d"></a><!-- doxytag: member="xint::multiply" ref="af3d7059ec08bf075cec5685deca55c5d" args="(const integer &amp;n, const integer &amp;by)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::multiply </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the product of two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The product of the parameters.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Automatically uses the more-efficient squaring algorithm if it can trivially detect that the two parameters are copies of the same number. </dd></dl>

</div>
</div>
<a class="anchor" id="ab393826381b1abd9f1aca1cdb45f41f6"></a><!-- doxytag: member="xint::negate" ref="ab393826381b1abd9f1aca1cdb45f41f6" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::negate </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the additive inverse of an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>-n</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a675c4fe6ddda6db915450d054ed640ba"></a><!-- doxytag: member="xint::operator!" ref="a675c4fe6ddda6db915450d054ed640ba" args="(const xint::integer &amp;num1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aefda934d0ffacd0f44fcbbdfee19a139"></a><!-- doxytag: member="xint::operator!=" ref="aefda934d0ffacd0f44fcbbdfee19a139" args="(const xint::integer &amp;num1, const xint::integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae0505757986a9c7133552552471aae24"></a><!-- doxytag: member="xint::operator%" ref="ae0505757986a9c7133552552471aae24" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::operator% </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a742550f1c62ac8c2bde8e1ceab2a466c"></a><!-- doxytag: member="xint::operator&amp;" ref="a742550f1c62ac8c2bde8e1ceab2a466c" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea36ad9037f109576d4f95ec72b5c825"></a><!-- doxytag: member="xint::operator*" ref="aea36ad9037f109576d4f95ec72b5c825" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::operator* </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a211ff80bb081c08674272cfcae736a93"></a><!-- doxytag: member="xint::operator+" ref="a211ff80bb081c08674272cfcae736a93" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::operator+ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a586fb0eb69100ec74be94008ac26670d"></a><!-- doxytag: member="xint::operator+" ref="a586fb0eb69100ec74be94008ac26670d" args="(const integer &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxint_1_1integer.html">integer</a> &amp; xint::operator+ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e09422b575c6d29ea5c0d627b79c28e"></a><!-- doxytag: member="xint::operator&#45;" ref="a1e09422b575c6d29ea5c0d627b79c28e" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::operator- </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a510361ed458133ebfa5fd95f8d9c27"></a><!-- doxytag: member="xint::operator&#45;" ref="a8a510361ed458133ebfa5fd95f8d9c27" args="(const integer &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::operator- </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a701217f7824c3e935fca25147da23807"></a><!-- doxytag: member="xint::operator/" ref="a701217f7824c3e935fca25147da23807" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::operator/ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4f4a4771bf443e6724abbd18173ecc86"></a><!-- doxytag: member="xint::operator&lt;" ref="a4f4a4771bf443e6724abbd18173ecc86" args="(const xint::integer &amp;num1, const xint::integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa5b0dc228caee6523766326cf40297cd"></a><!-- doxytag: member="xint::operator&lt;&lt;" ref="aa5b0dc228caee6523766326cf40297cd" args="(std::basic_ostream&lt; charT, traits &gt; &amp;out, const xint::integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;charT,traits&gt;&amp; xint::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00630">630</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9d5f34c4d4bed1c86380d4f72edcd9b"></a><!-- doxytag: member="xint::operator&lt;=" ref="ab9d5f34c4d4bed1c86380d4f72edcd9b" args="(const xint::integer &amp;num1, const xint::integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad32051708c2a2baafa0340e19e90217b"></a><!-- doxytag: member="xint::operator==" ref="ad32051708c2a2baafa0340e19e90217b" args="(const xint::integer &amp;num1, const xint::integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1229d1f1efbdf3ffeac8b2964ca66093"></a><!-- doxytag: member="xint::operator&gt;" ref="a1229d1f1efbdf3ffeac8b2964ca66093" args="(const xint::integer &amp;num1, const xint::integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a766324a6f216f3b49a3e9aa885e9531c"></a><!-- doxytag: member="xint::operator&gt;=" ref="a766324a6f216f3b49a3e9aa885e9531c" args="(const xint::integer &amp;num1, const xint::integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a27a0715c66d7350b0f3800f6e161816f"></a><!-- doxytag: member="xint::operator&gt;&gt;" ref="a27a0715c66d7350b0f3800f6e161816f" args="(std::basic_istream&lt; charT, traits &gt; &amp;in, xint::integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;charT,traits&gt;&amp; xint::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxint_1_1integer.html">xint::integer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00657">657</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81722cd257bc950ba7c56a202492544f"></a><!-- doxytag: member="xint::operator^" ref="a81722cd257bc950ba7c56a202492544f" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::operator^ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afa8f2a0ac996ad45efc73b2aa056cae2"></a><!-- doxytag: member="xint::operator|" ref="afa8f2a0ac996ad45efc73b2aa056cae2" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::operator| </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a820d89c1d761a0a2c06479b1c1f9cecd"></a><!-- doxytag: member="xint::opt_secure_mode" ref="a820d89c1d761a0a2c06479b1c1f9cecd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::opt_secure_mode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the library was compiled with <a class="el" href="securemode.html">Secure Mode </a> enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if Secure Mode is active, <code>false</code> if it isn't. </dd></dl>

</div>
</div>
<a class="anchor" id="ad55aa4d44083238d9ec313511f5b1dfa"></a><!-- doxytag: member="xint::opt_thread_safe" ref="ad55aa4d44083238d9ec313511f5b1dfa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::opt_thread_safe </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the library was compiled with the <a class="el" href="threadsafe.html">Thread Safe Operation option </a> enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if it was compiled with Thread Safe Operation enabled, <code>false</code> if it wasn't. </dd></dl>

</div>
</div>
<a class="anchor" id="a186b14f991b32a818abd553b56a13a62"></a><!-- doxytag: member="xint::pow" ref="a186b14f991b32a818abd553b56a13a62" args="(const integer &amp;n, const integer &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::pow </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of n<sup>e</sup>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,e</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> to the power of <code>e</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b723c30c28eb57f611442e0b512f551"></a><!-- doxytag: member="xint::pow2" ref="a6b723c30c28eb57f611442e0b512f551" args="(size_t e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::pow2 </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of 2<sup>e</sup>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>The exponent to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>2 to the power of <code>e</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a convenience function, to help with self-documenting code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac54e9be3a8b131f882f88e57b0ef1c9c"></a><!-- doxytag: member="xint::powmod" ref="ac54e9be3a8b131f882f88e57b0ef1c9c" args="(const integer &amp;n, const integer &amp;e, const integer &amp;m, bool noMontgomery)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::powmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>noMontgomery</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the result of <code>n<sup>e</sup></code> % <code>m</code>, keeping the intermediate results (relatively) small. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to exponentiate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>The exponent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>noMontgomery</em>&nbsp;</td><td>Used for testing, leave false for normal operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>pow</code>(n, <code>exponent</code>) % <code>modulus</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classxint_1_1invalid__modulus.html" title="Exception class.">xint::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Because this function keeps the intermediate results small, it is far faster and uses far less memory than writing out the equivalent calculations.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition, this function will use the Montgomery Reduction internally, if the modulus is an odd number (and if <code>noMontgomery</code> isn't set), which is almost always faster than the non-Montgomery method. </dd></dl>

</div>
</div>
<a class="anchor" id="a5da6e81cb78913cc61c9f14857700b5e"></a><!-- doxytag: member="xint::random_by_size" ref="a5da6e81cb78913cc61c9f14857700b5e" args="(size_t bits, bool high_bit_on, bool low_bit_on, bool can_be_negative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::random_by_size </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>high_bit_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>low_bit_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>can_be_negative</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates a random <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with specific attributes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The maximum number of bits that you want the returned number to have. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>high_bit_on</em>&nbsp;</td><td>If <code>true</code>, the returned number will have exactly the requested size. If <code>false</code>, the upper bits may be zero, resulting in a number that is slightly smaller than requested. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>low_bit_on</em>&nbsp;</td><td>If <code>true</code>, the returned number will always be odd. If <code>false</code>, it has an equal chance of being odd or even. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>can_be_negative</em>&nbsp;</td><td>If <code>true</code>, the returned value has an equal chance of being positive or negative. If <code>false</code>, it will always be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A random <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with the requested attributes.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the currently-defined random generator.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="random.html">The XInt Random Number System</a> </dd>
<dd>
<a class="el" href="namespacexint.html#a9c50302b216b64d17d9c1d6350e88036" title="Change the random generator that the library uses.">xint::set_random_generator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afc8ba5f62561b4d2b42e32dde1a10ef3"></a><!-- doxytag: member="xint::random_prime" ref="afc8ba5f62561b4d2b42e32dde1a10ef3" args="(size_t size_in_bits, callback_t callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::random_prime </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size_in_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a randomly-generated prime number of a particular bit-size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size_in_bits</em>&nbsp;</td><td>The number of bits that you want the returned value to have. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A randomly-generated prime <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> with the specified number of bits, or zero if the provided callback function cancelled the operation.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::invalid_argument</em>&nbsp;</td><td>if <code>size_in_bits</code> is less than two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function uses <a class="el" href="namespacexint.html#ab205c4e52dbc6825cefe3a251f6ca99f" title="Tests an integer for primality.">xint::is_prime</a>. See the description of it for details of its limitations.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>It also uses the library's currently-set random number generator. See the <a class="el" href="random.html">Random Number Functions page</a> for details on its limitations and requirements, and how to get cryptographically-secure random numbers.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9c50302b216b64d17d9c1d6350e88036"></a><!-- doxytag: member="xint::set_random_generator" ref="a9c50302b216b64d17d9c1d6350e88036" args="(T *gen)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void xint::set_random_generator </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>gen</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the random generator that the library uses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gen</em>&nbsp;</td><td>A pointer to the new generator to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The generator must be a heap-allocated pointer (one created with <code>new</code>), which the XInt library assumes ownership of. Don't pass in a stack-created item, don't try to delete the item that you passed in, and don't attempt to use it separately after passing it to this function, or the behavior is undefined.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>See the <a class="el" href="random.html">Random Number page</a> for an example of how to use it. </dd></dl>

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00622">622</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf2652627e78682c17e120816987984a"></a><!-- doxytag: member="xint::setbit" ref="adf2652627e78682c17e120816987984a" args="(integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xint::setbit </td>
          <td>(</td>
          <td class="paramtype">integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a specific bit in an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f4dacd6f9398aaa500112731ab713ce"></a><!-- doxytag: member="xint::shift" ref="a4f4dacd6f9398aaa500112731ab713ce" args="(const integer &amp;n, int byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::shift </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit-shift an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>, in either direction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to shift it. If positive, it will shift left, negative will shift right.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6799cc3c4d8c963279be64b209bfd3b6"></a><!-- doxytag: member="xint::shift_left" ref="a6799cc3c4d8c963279be64b209bfd3b6" args="(const integer &amp;n, size_t byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::shift_left </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Left-shift an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> by a specified number of bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to left-shift it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a49a5a4220cb88b7446545e4b65950473"></a><!-- doxytag: member="xint::shift_right" ref="a49a5a4220cb88b7446545e4b65950473" args="(const integer &amp;n, size_t byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::shift_right </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Right-shift an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> by a specified number of bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to right-shift it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0aec423511839fd784b1654389dfcf5b"></a><!-- doxytag: member="xint::sqr" ref="a0aec423511839fd784b1654389dfcf5b" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::sqr </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of n<sup>2</sup>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> times <code>n</code>.</dd></dl>
<p>This function uses a faster algorithm than the standard multiplication one.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Rewrite this to eliminate the inefficient addOverflow. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5564979e78556afdc68dbbd744a0bcb"></a><!-- doxytag: member="xint::sqrmod" ref="aa5564979e78556afdc68dbbd744a0bcb" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::sqrmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular product of squaring an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to square. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>sqr(n)</code> % <code>m</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>

</div>
</div>
<a class="anchor" id="a74891726f8af86736169dd43b929ad0a"></a><!-- doxytag: member="xint::sqrt" ref="a74891726f8af86736169dd43b929ad0a" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::sqrt </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the square root of <code>an</code> <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The largest <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> that, when squared, is less than or equal to <code>n</code>. If <code>n</code> is not a perfect square, then this value will not be the exact square root.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classxint_1_1cannot__represent.html" title="Exception class.">xint::cannot_represent</a></em>&nbsp;</td><td>if <code>n</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af196cd74cb23970032fddcce71957a80"></a><!-- doxytag: member="xint::subtract" ref="af196cd74cb23970032fddcce71957a80" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::subtract </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the difference between two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The difference between the parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b7f5122683b6d924bf86c7d1507206b"></a><!-- doxytag: member="xint::testAddSubtract" ref="a6b7f5122683b6d924bf86c7d1507206b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::testAddSubtract </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a509778d505a3c8a0b335817150eaead2"></a><!-- doxytag: member="xint::testBitManipulations" ref="a509778d505a3c8a0b335817150eaead2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::testBitManipulations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4ef5f20964fa995df7828f27bd7adbe"></a><!-- doxytag: member="xint::testConvert" ref="ae4ef5f20964fa995df7828f27bd7adbe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::testConvert </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ed78ff75865ae44a00d3709dd88c3a1"></a><!-- doxytag: member="xint::testDivideMod" ref="a4ed78ff75865ae44a00d3709dd88c3a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::testDivideMod </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac40068d64f8c4d9002a0687935888c42"></a><!-- doxytag: member="xint::testMontyMultiply" ref="ac40068d64f8c4d9002a0687935888c42" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::testMontyMultiply </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9cce0401174b9ae173671b0800c5f457"></a><!-- doxytag: member="xint::testMontyPowerMod" ref="a9cce0401174b9ae173671b0800c5f457" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::testMontyPowerMod </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="affe2e221777d4263a420d014fa9640d0"></a><!-- doxytag: member="xint::testMultiply" ref="affe2e221777d4263a420d014fa9640d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::testMultiply </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae3305f62ca9be58fbc11dbd4c703f38b"></a><!-- doxytag: member="xint::testStreams" ref="ae3305f62ca9be58fbc11dbd4c703f38b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xint::testStreams </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a21bd738b96eec205eedc7a9960e9a6e5"></a><!-- doxytag: member="xint::to" ref="a21bd738b96eec205eedc7a9960e9a6e5" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T xint::to </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Efficiently converts from an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">xint::integer</a> to a built-in integer type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>The type to convert it to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The numeric value of <code>n</code>, converted to the specified type.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classxint_1_1too__big.html" title="Exception class.">xint::too_big</a></em>&nbsp;</td><td>if <code>n</code> would not fit into the specified type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00593">593</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8f33201a251e3e118dc82f214e22aeb"></a><!-- doxytag: member="xint::to_binary" ref="ab8f33201a251e3e118dc82f214e22aeb" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xint::to_binary </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a binary representation of an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>, lowest byte first. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the binary representation.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function only stores the absolute value of <code>n</code>; if you need the sign, you must store it separately.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A binary representation is sometimes used for persistent storage or transmission, as it is more space-efficient than a string representation.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacexint.html#ac2ac2f74b45e4179560d845e6310be9a" title="Converts a binary representation of a number into an integer.">xint::from_binary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a016c9573ff48411847edf86c406946a0"></a><!-- doxytag: member="xint::to_string" ref="a016c9573ff48411847edf86c406946a0" args="(const integer &amp;n, size_t base, bool uppercase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xint::to_string </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>uppercase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a string representation of the specified <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>The base, between 2 and 36 inclusive, to convert it to. Defaults to base 10. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uppercase</em>&nbsp;</td><td>Whether to make alphabetic characters (for bases greater than ten) uppercase or not. Defaults to <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string value of <code>n</code>. If <code>n</code> is Not-a-Number, returns the string <code>#NaN#</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classxint_1_1invalid__base.html" title="Exception class.">xint::invalid_base</a></em>&nbsp;</td><td>if base is less than two or greater than 36.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If exceptions are blocked, it returns an empty string instead of throwing an exception.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when you ask the library to write an <a class="el" href="classxint_1_1integer.html" title="The extended integer class.">integer</a> to a stream, but it's more flexible because you can specify any base between 2 and 36. (Streams only allow base-8, base-10, or base-16.) </dd></dl>

</div>
</div>
<a class="anchor" id="ab8e85cd5425fcec419c07155e2a91e13"></a><!-- doxytag: member="xint::toMontgomeryForm" ref="ab8e85cd5425fcec419c07155e2a91e13" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxint_1_1integer.html">integer</a> xint::toMontgomeryForm </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Montgomery form of a number. Used for testing. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a7a5434a5f5fb1db19f0de18014c4fc41"></a><!-- doxytag: member="xint::autobase" ref="a7a5434a5f5fb1db19f0de18014c4fc41" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="namespacexint.html#a7a5434a5f5fb1db19f0de18014c4fc41">xint::autobase</a> = (std::numeric_limits&lt;size_t&gt;::max)()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A value that can be used for the 'base' parameter of the string-to-integer functions </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classxint_1_1integer.html#a6dfc86dfc539cfda1062ef1bc24aa526" title="Create an integer from a string representation.">xint::integer::integer(const std::string&amp; str, size_t base)</a> </dd>
<dd>
<a class="el" href="namespacexint.html#ad9dcb2b835be5f8ee918979945911ac0" title="Converts a string into an integer.">xint::from_string</a> </dd></dl>

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00123">123</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44496f258b36237d4cea35558a71017a"></a><!-- doxytag: member="xint::no_callback" ref="a44496f258b36237d4cea35558a71017a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacexint.html#ac8a660c33746c536469d347307b8da7a">callback_t</a> <a class="el" href="namespacexint.html#a44496f258b36237d4cea35558a71017a">xint::no_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An empty callback_t, used as a default parameter for some functions. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacexint.html#ab205c4e52dbc6825cefe3a251f6ca99f" title="Tests an integer for primality.">xint::is_prime</a> </dd>
<dd>
<a class="el" href="namespacexint.html#afc8ba5f62561b4d2b42e32dde1a10ef3" title="Generate a randomly-generated prime number of a particular bit-size.">xint::random_prime</a> </dd></dl>

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00118">118</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Apr 6 01:22:08 2010 for The Extended Integer (XInt) Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
