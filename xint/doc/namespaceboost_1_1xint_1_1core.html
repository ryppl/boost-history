<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>The Extended Integer (XInt) Library: boost::xint::core Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceboost.html">boost</a>::<a class="el" href="namespaceboost_1_1xint.html">xint</a>::<a class="el" href="namespaceboost_1_1xint_1_1core.html">core</a>
  </div>
</div>
<div class="contents">
<h1>boost::xint::core Namespace Reference</h1>
<p>Contains the "pure" integer type, and functions to operate on it.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The core integer class.  <a href="classboost_1_1xint_1_1core_1_1integer.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Bit-manipulation functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpcc775c18f98f26f2b84ac7a2558636f2"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a06f4b3f75bb5e648e865f20990f8154c">getbit</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the value of a particular bit in an integer.  <a href="#a06f4b3f75bb5e648e865f20990f8154c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#aae966bbb23d33801b34108f4490b0778">setbit</a> (<a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a specific bit in an integer to one.  <a href="#aae966bbb23d33801b34108f4490b0778"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#abd43d348da182e32e931743d1837f849">clearbit</a> (<a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a specific bit in an integer to zero.  <a href="#abd43d348da182e32e931743d1837f849"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#afbb649428a445bd8a6e7d9bcfab69707">lowestbit</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, size_t valueIfZero)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the index of the lowest bit in an integer with a value of one.  <a href="#afbb649428a445bd8a6e7d9bcfab69707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a2a32641fadc89dc7385b2f1a0af862dc">highestbit</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, size_t valueIfZero)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the index of the highest bit in an integer with a value of one.  <a href="#a2a32641fadc89dc7385b2f1a0af862dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#aab6badbf5997e33714d0dbe54c16375f">bitwise_and</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>AND</code> operation.  <a href="#aab6badbf5997e33714d0dbe54c16375f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a04384ebf492038c4ba83af9736412c9b">bitwise_or</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>OR</code> operation.  <a href="#a04384ebf492038c4ba83af9736412c9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a86446e5e38a977b68f041dfa4b82a385">bitwise_xor</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>XOR</code> operation.  <a href="#a86446e5e38a977b68f041dfa4b82a385"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ab5d1310559b3ac9857e3475889b06b1a">shift</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, int byBits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-shift an integer, in either direction.  <a href="#ab5d1310559b3ac9857e3475889b06b1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a51a385d6a7e71b555b152de0f40cd9fc">shift_left</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, size_t byBits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Left-shift an integer by a specified number of bits.  <a href="#a51a385d6a7e71b555b152de0f40cd9fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ac456d45328b682c029af422923298253">shift_right</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, size_t byBits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Right-shift an integer by a specified number of bits.  <a href="#ac456d45328b682c029af422923298253"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp458f92801f3edfaf2e30b1f530c324e2"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a37bbe9d9165afb0a3f20df233a9db07f">compare</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;b1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;b2, bool ignoresign)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two integer objects.  <a href="#a37bbe9d9165afb0a3f20df233a9db07f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ab914d21c7168f03fc844746be068bf25">gcd</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the Greatest Common Denominator of two integers.  <a href="#ab914d21c7168f03fc844746be068bf25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ad8783802f3252c9c3143eaca76acd9a6">lcm</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the Least Common Multiple of two integers.  <a href="#ad8783802f3252c9c3143eaca76acd9a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#aa3924902931d74fe0a7d2c6daf9ab028">log2</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the log<sub>2</sub> value of an integer.  <a href="#aa3924902931d74fe0a7d2c6daf9ab028"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb3c5827f54218753bb2c3338236446c2"></a> These act exactly the same as for the built-in integer types. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#aa86f6238d476cfdb8f534a8cb289a7e5">operator!</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ab91cfea31de4287970ae678b4a951a13">operator==</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a422409aa6897f3169f9be22fba746466">operator!=</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ad66c54269633ec8a0609bafecad430dc">operator&lt;</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ae4725524123f4ba5544d47cce68606fb">operator&gt;</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a5548f1bea201f1de80fc3d847d58d8d7">operator&lt;=</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#acd8e6b8505268237b7fe55bea9a23b2e">operator&gt;=</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a0e26ec58adc380b930eb3c47723a7d6a">operator+</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a94dda733eac933cee9a5e307ba030b88">operator-</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a017539f78cba665d5cbb6b6ba00e1d42">operator+</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#af4587327ba62268fe3267ca09bd8f4a2">operator-</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#abc738f0d18724bbdda6d956dabd77b0c">operator*</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a9704cdf0b9adc7cca4118b2e20737a65">operator/</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#abd7c9499bde867d7b8c7eae5b08bd54d">operator%</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a3913ac27d582f4f5c162cd2c763b91a1">operator&amp;</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a3124de335da66bcf5a4141dccc1a9458">operator|</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a2c93fc2437215ef1e54c67276bfde742">operator^</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp9c2e8a06d85d2c9b83b5a0d27e85d535"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a28e4e76808cb1a05102e9c3d66fe0027">to_string</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, size_t base, bool uppercase)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a string representation of the specified integer.  <a href="#a28e4e76808cb1a05102e9c3d66fe0027"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#adaa2e5c8f2ff92faee861a68bc7e4cca">from_string</a> (const std::string &amp;str, size_t base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a string into an integer.  <a href="#adaa2e5c8f2ff92faee861a68bc7e4cca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a626c8b1f3bd3f6b03a18412c8419bad8">from_binary</a> (const std::string &amp;str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a binary representation of a number into an integer.  <a href="#a626c8b1f3bd3f6b03a18412c8419bad8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a32564e3da6e4e65ae8b937614cdca95c">to_binary</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a binary representation of an integer, lowest byte first.  <a href="#a32564e3da6e4e65ae8b937614cdca95c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a2cc4b19211f94878d3fe4fc50dbe24a3">to</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Efficiently converts from an xint::integer to a built-in integer type.  <a href="#a2cc4b19211f94878d3fe4fc50dbe24a3"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Modular math functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpbf63e6a6a1029bb25b7aa51052b38655"></a>A common reason to use a large-integer library is to implement public-key encryption, and the algorithms for such encryption often use modular math. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a4cbae3e54ac73cfb3573c4e4f316abe4">invmod</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular inverse of a number in a modulus, if there is one.  <a href="#a4cbae3e54ac73cfb3573c4e4f316abe4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ae02fe53b2dc0340dcd66c44e689e7338">mod</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remainder after dividing a number by another.  <a href="#ae02fe53b2dc0340dcd66c44e689e7338"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a46494daacb938b204aba5a5a3d957e3a">mulmod</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;by, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular product of two integers.  <a href="#a46494daacb938b204aba5a5a3d957e3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#abaf712bcc261145845c49e2e07a8c23c">sqrmod</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular product of squaring an integer.  <a href="#abaf712bcc261145845c49e2e07a8c23c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a6d465ee56d6ba0263ac4648bd8b68bc4">powmod</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;e, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;m, bool noMontgomery)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the result of <code>n<sup>e</sup></code> % <code>m</code>, keeping the intermediate results (relatively) small.  <a href="#a6d465ee56d6ba0263ac4648bd8b68bc4"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Montgomery Reduction functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpef45384829a28a8031424a8c453ceaa0"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">digit_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#aa6942deffea28a32072479fe663acaa2">inverse0</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the low digit of the inverse of a number. Used internally.  <a href="#aa6942deffea28a32072479fe663acaa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#aff045b62b20e88d2e086dd64dcbba02e">montgomeryR</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the most efficient R value for a number and the library's internal representation. Used internally.  <a href="#aff045b62b20e88d2e086dd64dcbba02e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a4a33279cf67c53f80a4e5935f0515d4d">toMontgomeryForm</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the Montgomery form of a number. Used for testing.  <a href="#a4a33279cf67c53f80a4e5935f0515d4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a1d598caa371e7bffba98f78df726674e">fromMontgomeryForm</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the integer from the Montgomery form of a number. Used for testing.  <a href="#a1d598caa371e7bffba98f78df726674e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a902d87635063ba89629799b032e6a53d">montgomeryMultiplyMod</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;a, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;b, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, digit_t nPrime0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the Montgomery equivalent of <code>mulmod(a, b, n)</code>. Used internally.  <a href="#a902d87635063ba89629799b032e6a53d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a407dceba39038bf606814ea84ff4d964">montgomeryPowerMod</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;a, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;e, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the Montgomery equivalent of <code>powmod(a, b, n)</code>. Used internally.  <a href="#a407dceba39038bf606814ea84ff4d964"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Powers and roots</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp928a8cb047602f789d7433e262ed4560"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a72afdedb16eff4404641511681e08116">pow2</a> (size_t e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of 2<sup>e</sup>  <a href="#a72afdedb16eff4404641511681e08116"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a9bd005ab3992dc51d6c95fdee987f2fe">sqr</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of n<sup>2</sup>  <a href="#a9bd005ab3992dc51d6c95fdee987f2fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a4bf3bb563c2a9a3c1dd98f8975253a30">pow</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of n<sup>e</sup>  <a href="#a4bf3bb563c2a9a3c1dd98f8975253a30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ab82432c3d99638bb2f56304cf44a405a">factorial</a> (size_t n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of <code>n!</code>  <a href="#ab82432c3d99638bb2f56304cf44a405a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a9ebf35bf53baa1eddf9a84dc719a5d15">sqrt</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the square root of <code>an</code> integer.  <a href="#a9ebf35bf53baa1eddf9a84dc719a5d15"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Prime number functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp540e8e12721acbe497d2b9b53ecc76ec"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a79626b71d9ebb21c2c07e105c8b1ad89">is_prime</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests an integer for primality.  <a href="#a79626b71d9ebb21c2c07e105c8b1ad89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a5f117503768fded4de58ded6d0c5513e">random_prime</a> (size_t size_in_bits, <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a randomly-generated prime number of a particular bit-size.  <a href="#a5f117503768fded4de58ded6d0c5513e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical primitives</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp196dd2a5f50860e057df961a96d84ea3"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ab1b84a6eb65676fdb85e71c1fe06e792">abs</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the absolute value of an integer.  <a href="#ab1b84a6eb65676fdb85e71c1fe06e792"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a0103381c7bca2e5a904ad3b75904e982">negate</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the additive inverse of an integer.  <a href="#a0103381c7bca2e5a904ad3b75904e982"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#aa8ac1151e65f51b3dca51e827c29af66">add</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the sum of two integers.  <a href="#aa8ac1151e65f51b3dca51e827c29af66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#aa1d93a8d3a437f7b9df70ea00d48f355">subtract</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the difference between two integers.  <a href="#aa1d93a8d3a437f7b9df70ea00d48f355"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a1a4424b4d8b045a3484463e588368593">multiply</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;by)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the product of two integers.  <a href="#a1a4424b4d8b045a3484463e588368593"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ad09c66a61457feb23505d26adc116530">divide</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;dividend, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;divisor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate how many <code>dividends</code> would fit into <code>divisor</code>.  <a href="#ad09c66a61457feb23505d26adc116530"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>, <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a731b3943a2e1bc95ec34a32291754ad4">divide_r</a> (const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;d1, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;d2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate how many <code>dividends</code> would fit into <code>divisor</code>, with the remainder.  <a href="#a731b3943a2e1bc95ec34a32291754ad4"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Random number functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpdd4713a71c208a173c1f2436d4e32ff7"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#ace96723bc59d89473ab9c750330d4451">random_by_size</a> (size_t bits, bool high_bit_on, bool low_bit_on, bool can_be_negative)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a random integer with specific attributes.  <a href="#ace96723bc59d89473ab9c750330d4451"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream input/output functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9927783c44c1aad288df0ab8bfa9ddf"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#af8fd339a3a68d1de9d8c3991c4952835">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;out, const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1core.html#a39b5e2f0e689ba91809cc1eaebe40428">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;in, <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp;n)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Contains the "pure" integer type, and functions to operate on it. </p>
<p>The types and functions in the <a class="el" href="namespaceboost_1_1xint_1_1core.html" title="Contains the &quot;pure&quot; integer type, and functions to operate on it.">xint::core</a> namespace ignore exception-blocking and do not support the Not-a-Number value. If you attempt to assign a Not-a-Number to a <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html" title="The core integer class.">core::integer</a>, it will throw a not_a_number exception. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ab1b84a6eb65676fdb85e71c1fe06e792"></a><!-- doxytag: member="boost::xint::core::abs" ref="ab1b84a6eb65676fdb85e71c1fe06e792" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::abs </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the absolute value of an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If <code>n</code> is zero or positive, returns <code>n</code>. Otherwise returns <code>-n</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8ac1151e65f51b3dca51e827c29af66"></a><!-- doxytag: member="boost::xint::core::add" ref="aa8ac1151e65f51b3dca51e827c29af66" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::add </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the sum of two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sum of the parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="aab6badbf5997e33714d0dbe54c16375f"></a><!-- doxytag: member="boost::xint::core::bitwise_and" ref="aab6badbf5997e33714d0dbe54c16375f" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::bitwise_and </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>AND</code> operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer with all bits that are set in both parameters turned on. </dd></dl>

</div>
</div>
<a class="anchor" id="a04384ebf492038c4ba83af9736412c9b"></a><!-- doxytag: member="boost::xint::core::bitwise_or" ref="a04384ebf492038c4ba83af9736412c9b" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::bitwise_or </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>OR</code> operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer with all bits that are set in either parameter turned on. </dd></dl>

</div>
</div>
<a class="anchor" id="a86446e5e38a977b68f041dfa4b82a385"></a><!-- doxytag: member="boost::xint::core::bitwise_xor" ref="a86446e5e38a977b68f041dfa4b82a385" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::bitwise_xor </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>XOR</code> operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer with all bits that are set in either parameter, but not both, turned on. </dd></dl>

</div>
</div>
<a class="anchor" id="abd43d348da182e32e931743d1837f849"></a><!-- doxytag: member="boost::xint::core::clearbit" ref="abd43d348da182e32e931743d1837f849" args="(integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::core::clearbit </td>
          <td>(</td>
          <td class="paramtype">integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a specific bit in an integer to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a37bbe9d9165afb0a3f20df233a9db07f"></a><!-- doxytag: member="boost::xint::core::compare" ref="a37bbe9d9165afb0a3f20df233a9db07f" args="(const integer &amp;b1, const integer &amp;b2, bool ignoresign)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int boost::xint::core::compare </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoresign</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two integer objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b1,b2</em>&nbsp;</td><td>The integers to compare. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignoresign</em>&nbsp;</td><td>If <code>true</code>, the absolute values of b1 and b2 are compared, instead of their signed values. Used internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative number if <code>b1</code> &lt; <code>b2</code>; zero if <code>b1</code> == <code>b2</code>, or a positive number if <code>b1</code> &gt; <code>b2</code>.</dd></dl>
<p>This is the function behind all of the comparison operators. It might sometimes be useful directly as well. </p>

</div>
</div>
<a class="anchor" id="ad09c66a61457feb23505d26adc116530"></a><!-- doxytag: member="boost::xint::core::divide" ref="ad09c66a61457feb23505d26adc116530" args="(const integer &amp;dividend, const integer &amp;divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::divide </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dividend,divisor</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of <code>dividend</code> divided by <code>divisor</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1divide__by__zero.html">exception::divide_by_zero</a></em>&nbsp;</td><td>if <code>divisor</code> is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a731b3943a2e1bc95ec34a32291754ad4"></a><!-- doxytag: member="boost::xint::core::divide_r" ref="a731b3943a2e1bc95ec34a32291754ad4" args="(const integer &amp;d1, const integer &amp;d2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a>, <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &gt; boost::xint::core::divide_r </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>d2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>, with the remainder. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d1</em>&nbsp;</td><td>The dividend. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d2</em>&nbsp;</td><td>The divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code>std::pair</code> containing the quotient and remainder of <code>d1</code> divided by <code>d2</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1divide__by__zero.html">exception::divide_by_zero</a></em>&nbsp;</td><td>if <code>d2</code> is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab82432c3d99638bb2f56304cf44a405a"></a><!-- doxytag: member="boost::xint::core::factorial" ref="ab82432c3d99638bb2f56304cf44a405a" args="(size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::factorial </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of <code>n!</code> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> factorial, defined as <code>1*2*3*...*n</code></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Factorials get ridiculously huge, even with fairly small values of <code>n</code>. This function, when used with a large parameter, is the easiest way to exhaust the system's memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a626c8b1f3bd3f6b03a18412c8419bad8"></a><!-- doxytag: member="boost::xint::core::from_binary" ref="a626c8b1f3bd3f6b03a18412c8419bad8" args="(const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::from_binary </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a binary representation of a number into an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>str</em>&nbsp;</td><td>An <code>std::string</code> containing the bytes to convert, lowest byte first.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer representing the bytes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>xint::to_binary </dd></dl>

</div>
</div>
<a class="anchor" id="adaa2e5c8f2ff92faee861a68bc7e4cca"></a><!-- doxytag: member="boost::xint::core::from_string" ref="adaa2e5c8f2ff92faee861a68bc7e4cca" args="(const std::string &amp;str, size_t base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a string into an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>str</em>&nbsp;</td><td>The string to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>the base that the string representation of the number is in. This can be any number between 2 and 36 (inclusive). It can also be the constant <a class="el" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">xint::autobase</a>, in which case the function will follow the standard C/C++ rules for interpreting a numeric constant: any number with a zero as the first digit is assumed to be base-8; any number with a leading zero-x or zero-X (such as 0x1f) is base-16, and anything else is base-10.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer with the numeric value of the string in base <code>base</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1overflow__error.html">exception::overflow_error</a></em>&nbsp;</td><td>if there is not enough free memory to create the integer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1invalid__base.html">exception::invalid_base</a></em>&nbsp;</td><td>if the base parameter is not between 2 and 36 (inclusive) or the constant <a class="el" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">xint::autobase</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1invalid__digit.html">exception::invalid_digit</a></em>&nbsp;</td><td>if the string contains any digit that cannot be part of a number in the specified base, or if there are no valid digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when reading an integer from a stream, or when contructing one from a string.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html#aa5b9d9f104ce714700b4a3a40eefb80f" title="Create an integer from a string representation.">integer::integer(const std::string&amp; str, size_t base)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1d598caa371e7bffba98f78df726674e"></a><!-- doxytag: member="boost::xint::core::fromMontgomeryForm" ref="a1d598caa371e7bffba98f78df726674e" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::fromMontgomeryForm </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the integer from the Montgomery form of a number. Used for testing. </p>

</div>
</div>
<a class="anchor" id="ab914d21c7168f03fc844746be068bf25"></a><!-- doxytag: member="boost::xint::core::gcd" ref="ab914d21c7168f03fc844746be068bf25" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::gcd </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Greatest Common Denominator of two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The greatest common denominator of the two integers, which will always be a positive number. </dd></dl>

</div>
</div>
<a class="anchor" id="a06f4b3f75bb5e648e865f20990f8154c"></a><!-- doxytag: member="boost::xint::core::getbit" ref="a06f4b3f75bb5e648e865f20990f8154c" args="(const integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::core::getbit </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queries the value of a particular bit in an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit you're asking about.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the specified bit is set (has a value of one), <code>false</code> if it is clear. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a32641fadc89dc7385b2f1a0af862dc"></a><!-- doxytag: member="boost::xint::core::highestbit" ref="a2a32641fadc89dc7385b2f1a0af862dc" args="(const integer &amp;n, size_t valueIfZero)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::core::highestbit </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>valueIfZero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the index of the highest bit in an integer with a value of one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>valueIfZero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the highest one-bit in the integer, or <code>valueIfZero</code> if the integer contains no set bits. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6942deffea28a32072479fe663acaa2"></a><!-- doxytag: member="boost::xint::core::inverse0" ref="aa6942deffea28a32072479fe663acaa2" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1xint_1_1detail.html#a46b5dc5524403d8a09d1bb419abcc347">detail::digit_t</a> boost::xint::core::inverse0 </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the low digit of the inverse of a number. Used internally. </p>

</div>
</div>
<a class="anchor" id="a4cbae3e54ac73cfb3573c4e4f316abe4"></a><!-- doxytag: member="boost::xint::core::invmod" ref="a4cbae3e54ac73cfb3573c4e4f316abe4" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::invmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular inverse of a number in a modulus, if there is one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to retrieve the inverse of. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The modular inverse of <code>n</code> in <code>m</code>. If <code>n</code> has no modular inverse in <code>m</code>, returns zero.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1invalid__modulus.html">exception::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79626b71d9ebb21c2c07e105c8b1ad89"></a><!-- doxytag: member="boost::xint::core::is_prime" ref="a79626b71d9ebb21c2c07e105c8b1ad89" args="(const integer &amp;n, callback_t callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int boost::xint::core::is_prime </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests an integer for primality. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to test. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <code>n</code> seems to be prime, 0 if it isn't, or -1 if the provided callback function cancelled the operation.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1invalid__argument.html">exception::invalid_argument</a></em>&nbsp;</td><td>if <code>n</code> is less than 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the Rabin-Miller probabilistic primality test. There is an infinitesimally small chance that it will think that a composite number is actually prime, but that is so small that it can be ignored for most practical purposes. If even that chance is too much, you can run this function over the number several times, it will use different random "witness" numbers each time.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8783802f3252c9c3143eaca76acd9a6"></a><!-- doxytag: member="boost::xint::core::lcm" ref="ad8783802f3252c9c3143eaca76acd9a6" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::lcm </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Least Common Multiple of two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The least common multiple of the two integers. If either integer is zero, then the return value will be zero, by convention; in all other cases, the return value will be a positive number. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3924902931d74fe0a7d2c6daf9ab028"></a><!-- doxytag: member="boost::xint::core::log2" ref="aa3924902931d74fe0a7d2c6daf9ab028" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::core::log2 </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the log<sub>2</sub> value of an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer log<sub>2</sub> value of the integer.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="namespaceboost_1_1xint_1_1core.html#a72afdedb16eff4404641511681e08116" title="Calculate the value of 2e">pow2</a>(log2(n)-1) will give you an integer with the highest set bit of <code>n</code>, assuming that <code>n</code> is non-zero.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Similar to the <a class="el" href="namespaceboost_1_1xint_1_1core.html#a2a32641fadc89dc7385b2f1a0af862dc" title="Obtains the index of the highest bit in an integer with a value of one.">highestbit</a> function. </dd></dl>

</div>
</div>
<a class="anchor" id="afbb649428a445bd8a6e7d9bcfab69707"></a><!-- doxytag: member="boost::xint::core::lowestbit" ref="afbb649428a445bd8a6e7d9bcfab69707" args="(const integer &amp;n, size_t valueIfZero)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::core::lowestbit </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>valueIfZero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the index of the lowest bit in an integer with a value of one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>valueIfZero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the lowest one-bit in the integer, or <code>valueIfZero</code> if the integer contains no set bits. </dd></dl>

</div>
</div>
<a class="anchor" id="ae02fe53b2dc0340dcd66c44e689e7338"></a><!-- doxytag: member="boost::xint::core::mod" ref="ae02fe53b2dc0340dcd66c44e689e7338" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::mod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the remainder after dividing a number by another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The dividend. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>n</code> % <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a902d87635063ba89629799b032e6a53d"></a><!-- doxytag: member="boost::xint::core::montgomeryMultiplyMod" ref="a902d87635063ba89629799b032e6a53d" args="(const integer &amp;a, const integer &amp;b, const integer &amp;n, digit_t nPrime0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::montgomeryMultiplyMod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">digit_t&nbsp;</td>
          <td class="paramname"> <em>nPrime0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Montgomery equivalent of <code>mulmod(a, b, n)</code>. Used internally. </p>

</div>
</div>
<a class="anchor" id="a407dceba39038bf606814ea84ff4d964"></a><!-- doxytag: member="boost::xint::core::montgomeryPowerMod" ref="a407dceba39038bf606814ea84ff4d964" args="(const integer &amp;a, const integer &amp;e, const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::montgomeryPowerMod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Montgomery equivalent of <code>powmod(a, b, n)</code>. Used internally. </p>

</div>
</div>
<a class="anchor" id="aff045b62b20e88d2e086dd64dcbba02e"></a><!-- doxytag: member="boost::xint::core::montgomeryR" ref="aff045b62b20e88d2e086dd64dcbba02e" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::montgomeryR </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the most efficient R value for a number and the library's internal representation. Used internally. </p>

</div>
</div>
<a class="anchor" id="a46494daacb938b204aba5a5a3d957e3a"></a><!-- doxytag: member="boost::xint::core::mulmod" ref="a46494daacb938b204aba5a5a3d957e3a" args="(const integer &amp;n, const integer &amp;by, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::mulmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular product of two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to multiply. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>n</code> * <code>by</code> % <code>m</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a4424b4d8b045a3484463e588368593"></a><!-- doxytag: member="boost::xint::core::multiply" ref="a1a4424b4d8b045a3484463e588368593" args="(const integer &amp;n, const integer &amp;by)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::multiply </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the product of two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The product of the parameters.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Automatically uses the more-efficient squaring algorithm if it can trivially detect that the two parameters are copies of the same number. </dd></dl>

</div>
</div>
<a class="anchor" id="a0103381c7bca2e5a904ad3b75904e982"></a><!-- doxytag: member="boost::xint::core::negate" ref="a0103381c7bca2e5a904ad3b75904e982" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::negate </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the additive inverse of an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>-n</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa86f6238d476cfdb8f534a8cb289a7e5"></a><!-- doxytag: member="boost::xint::core::operator!" ref="aa86f6238d476cfdb8f534a8cb289a7e5" args="(const integer &amp;num1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::core::operator! </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a422409aa6897f3169f9be22fba746466"></a><!-- doxytag: member="boost::xint::core::operator!=" ref="a422409aa6897f3169f9be22fba746466" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::core::operator!= </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abd7c9499bde867d7b8c7eae5b08bd54d"></a><!-- doxytag: member="boost::xint::core::operator%" ref="abd7c9499bde867d7b8c7eae5b08bd54d" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::operator% </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3913ac27d582f4f5c162cd2c763b91a1"></a><!-- doxytag: member="boost::xint::core::operator&amp;" ref="a3913ac27d582f4f5c162cd2c763b91a1" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abc738f0d18724bbdda6d956dabd77b0c"></a><!-- doxytag: member="boost::xint::core::operator*" ref="abc738f0d18724bbdda6d956dabd77b0c" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::operator* </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a017539f78cba665d5cbb6b6ba00e1d42"></a><!-- doxytag: member="boost::xint::core::operator+" ref="a017539f78cba665d5cbb6b6ba00e1d42" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::operator+ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0e26ec58adc380b930eb3c47723a7d6a"></a><!-- doxytag: member="boost::xint::core::operator+" ref="a0e26ec58adc380b930eb3c47723a7d6a" args="(const integer &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> &amp; boost::xint::core::operator+ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af4587327ba62268fe3267ca09bd8f4a2"></a><!-- doxytag: member="boost::xint::core::operator&#45;" ref="af4587327ba62268fe3267ca09bd8f4a2" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::operator- </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a94dda733eac933cee9a5e307ba030b88"></a><!-- doxytag: member="boost::xint::core::operator&#45;" ref="a94dda733eac933cee9a5e307ba030b88" args="(const integer &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::operator- </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9704cdf0b9adc7cca4118b2e20737a65"></a><!-- doxytag: member="boost::xint::core::operator/" ref="a9704cdf0b9adc7cca4118b2e20737a65" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::operator/ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad66c54269633ec8a0609bafecad430dc"></a><!-- doxytag: member="boost::xint::core::operator&lt;" ref="ad66c54269633ec8a0609bafecad430dc" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::core::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af8fd339a3a68d1de9d8c3991c4952835"></a><!-- doxytag: member="boost::xint::core::operator&lt;&lt;" ref="af8fd339a3a68d1de9d8c3991c4952835" args="(std::basic_ostream&lt; charT, traits &gt; &amp;out, const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;charT,traits&gt;&amp; boost::xint::core::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00871">871</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5548f1bea201f1de80fc3d847d58d8d7"></a><!-- doxytag: member="boost::xint::core::operator&lt;=" ref="a5548f1bea201f1de80fc3d847d58d8d7" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::core::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab91cfea31de4287970ae678b4a951a13"></a><!-- doxytag: member="boost::xint::core::operator==" ref="ab91cfea31de4287970ae678b4a951a13" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::core::operator== </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4725524123f4ba5544d47cce68606fb"></a><!-- doxytag: member="boost::xint::core::operator&gt;" ref="ae4725524123f4ba5544d47cce68606fb" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::core::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acd8e6b8505268237b7fe55bea9a23b2e"></a><!-- doxytag: member="boost::xint::core::operator&gt;=" ref="acd8e6b8505268237b7fe55bea9a23b2e" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::core::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a39b5e2f0e689ba91809cc1eaebe40428"></a><!-- doxytag: member="boost::xint::core::operator&gt;&gt;" ref="a39b5e2f0e689ba91809cc1eaebe40428" args="(std::basic_istream&lt; charT, traits &gt; &amp;in, integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;charT,traits&gt;&amp; boost::xint::core::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00897">897</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c93fc2437215ef1e54c67276bfde742"></a><!-- doxytag: member="boost::xint::core::operator^" ref="a2c93fc2437215ef1e54c67276bfde742" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::operator^ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3124de335da66bcf5a4141dccc1a9458"></a><!-- doxytag: member="boost::xint::core::operator|" ref="a3124de335da66bcf5a4141dccc1a9458" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::operator| </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4bf3bb563c2a9a3c1dd98f8975253a30"></a><!-- doxytag: member="boost::xint::core::pow" ref="a4bf3bb563c2a9a3c1dd98f8975253a30" args="(const integer &amp;n, const integer &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::pow </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of n<sup>e</sup> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,e</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> to the power of <code>e</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a72afdedb16eff4404641511681e08116"></a><!-- doxytag: member="boost::xint::core::pow2" ref="a72afdedb16eff4404641511681e08116" args="(size_t e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::pow2 </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of 2<sup>e</sup> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>The exponent to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>2 to the power of <code>e</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a convenience function, to help with self-documenting code. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d465ee56d6ba0263ac4648bd8b68bc4"></a><!-- doxytag: member="boost::xint::core::powmod" ref="a6d465ee56d6ba0263ac4648bd8b68bc4" args="(const integer &amp;n, const integer &amp;e, const integer &amp;m, bool noMontgomery)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::powmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>noMontgomery</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the result of <code>n<sup>e</sup></code> % <code>m</code>, keeping the intermediate results (relatively) small. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to exponentiate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>The exponent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>noMontgomery</em>&nbsp;</td><td>Used for testing, leave false for normal operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>pow</code>(n, <code>exponent</code>) % <code>modulus</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1invalid__modulus.html">exception::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Because this function keeps the intermediate results small, it is far faster and uses far less memory than writing out the equivalent calculations.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition, this function will use the Montgomery Reduction internally, if the modulus is an odd number (and if <code>noMontgomery</code> isn't set), which is almost always faster than the non-Montgomery method. </dd></dl>

</div>
</div>
<a class="anchor" id="ace96723bc59d89473ab9c750330d4451"></a><!-- doxytag: member="boost::xint::core::random_by_size" ref="ace96723bc59d89473ab9c750330d4451" args="(size_t bits, bool high_bit_on, bool low_bit_on, bool can_be_negative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::random_by_size </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>high_bit_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>low_bit_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>can_be_negative</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates a random integer with specific attributes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The maximum number of bits that you want the returned number to have. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>high_bit_on</em>&nbsp;</td><td>If <code>true</code>, the returned number will have exactly the requested size. If <code>false</code>, the upper bits may be zero, resulting in a number that is slightly smaller than requested. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>low_bit_on</em>&nbsp;</td><td>If <code>true</code>, the returned number will always be odd. If <code>false</code>, it has an equal chance of being odd or even. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>can_be_negative</em>&nbsp;</td><td>If <code>true</code>, the returned value has an equal chance of being positive or negative. If <code>false</code>, it will always be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A random integer with the requested attributes.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the currently-defined random generator.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="random.html">The XInt Random Number System</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#a201d33fafe577133130cd16dec3422b6" title="Change the random generator that the library uses.">xint::set_random_generator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5f117503768fded4de58ded6d0c5513e"></a><!-- doxytag: member="boost::xint::core::random_prime" ref="a5f117503768fded4de58ded6d0c5513e" args="(size_t size_in_bits, callback_t callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::random_prime </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size_in_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a randomly-generated prime number of a particular bit-size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size_in_bits</em>&nbsp;</td><td>The number of bits that you want the returned value to have. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A randomly-generated prime integer with the specified number of bits, or zero if the provided callback function cancelled the operation.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1invalid__argument.html">exception::invalid_argument</a></em>&nbsp;</td><td>if <code>size_in_bits</code> is less than two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function uses xint::is_prime. See the description of it for details of its limitations.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>It also uses the library's currently-set random number generator. See the <a class="el" href="random.html">Random Number Functions page</a> for details on its limitations and requirements, and how to get cryptographically-secure random numbers.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aae966bbb23d33801b34108f4490b0778"></a><!-- doxytag: member="boost::xint::core::setbit" ref="aae966bbb23d33801b34108f4490b0778" args="(integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::core::setbit </td>
          <td>(</td>
          <td class="paramtype">integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a specific bit in an integer to one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5d1310559b3ac9857e3475889b06b1a"></a><!-- doxytag: member="boost::xint::core::shift" ref="ab5d1310559b3ac9857e3475889b06b1a" args="(const integer &amp;n, int byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::shift </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit-shift an integer, in either direction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to shift it. If positive, it will shift left, negative will shift right.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a51a385d6a7e71b555b152de0f40cd9fc"></a><!-- doxytag: member="boost::xint::core::shift_left" ref="a51a385d6a7e71b555b152de0f40cd9fc" args="(const integer &amp;n, size_t byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::shift_left </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Left-shift an integer by a specified number of bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to left-shift it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ac456d45328b682c029af422923298253"></a><!-- doxytag: member="boost::xint::core::shift_right" ref="ac456d45328b682c029af422923298253" args="(const integer &amp;n, size_t byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::shift_right </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Right-shift an integer by a specified number of bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to right-shift it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bd005ab3992dc51d6c95fdee987f2fe"></a><!-- doxytag: member="boost::xint::core::sqr" ref="a9bd005ab3992dc51d6c95fdee987f2fe" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::sqr </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of n<sup>2</sup> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> times <code>n</code>.</dd></dl>
<p>This function uses a faster algorithm than the standard multiplication one.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Rewrite this to eliminate the inefficient addOverflow. </dd></dl>

</div>
</div>
<a class="anchor" id="abaf712bcc261145845c49e2e07a8c23c"></a><!-- doxytag: member="boost::xint::core::sqrmod" ref="abaf712bcc261145845c49e2e07a8c23c" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::sqrmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular product of squaring an integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to square. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>sqr(n)</code> % <code>m</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ebf35bf53baa1eddf9a84dc719a5d15"></a><!-- doxytag: member="boost::xint::core::sqrt" ref="a9ebf35bf53baa1eddf9a84dc719a5d15" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::sqrt </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the square root of <code>an</code> integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The largest integer that, when squared, is less than or equal to <code>n</code>. If <code>n</code> is not a perfect square, then this value will not be the exact square root.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1cannot__represent.html">exception::cannot_represent</a></em>&nbsp;</td><td>if <code>n</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1d93a8d3a437f7b9df70ea00d48f355"></a><!-- doxytag: member="boost::xint::core::subtract" ref="aa1d93a8d3a437f7b9df70ea00d48f355" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::subtract </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the difference between two integers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The difference between the parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cc4b19211f94878d3fe4fc50dbe24a3"></a><!-- doxytag: member="boost::xint::core::to" ref="a2cc4b19211f94878d3fe4fc50dbe24a3" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T boost::xint::core::to </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Efficiently converts from an xint::integer to a built-in integer type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>The type to convert it to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The numeric value of <code>n</code>, converted to the specified type.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1too__big.html">exception::too_big</a></em>&nbsp;</td><td>if <code>n</code> would not fit into the specified type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="xint_8hpp_source.html#l00853">853</a> of file <a class="el" href="xint_8hpp_source.html">xint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32564e3da6e4e65ae8b937614cdca95c"></a><!-- doxytag: member="boost::xint::core::to_binary" ref="a32564e3da6e4e65ae8b937614cdca95c" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string boost::xint::core::to_binary </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a binary representation of an integer, lowest byte first. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing the binary representation.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function only stores the absolute value of <code>n</code>; if you need the sign, you must store it separately.</dd></dl>
<dl class="user"><dt><b>If exceptions are blocked, returns an empty std::string instead of</b></dt><dd>throwing.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A binary representation is sometimes used for persistent storage or transmission, as it is more space-efficient than a string representation.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>xint::from_binary </dd></dl>

</div>
</div>
<a class="anchor" id="a28e4e76808cb1a05102e9c3d66fe0027"></a><!-- doxytag: member="boost::xint::core::to_string" ref="a28e4e76808cb1a05102e9c3d66fe0027" args="(const integer &amp;n, size_t base, bool uppercase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string boost::xint::core::to_string </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>uppercase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a string representation of the specified integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>The base, between 2 and 36 inclusive, to convert it to. Defaults to base 10. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uppercase</em>&nbsp;</td><td>Whether to make alphabetic characters (for bases greater than ten) uppercase or not. Defaults to <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string value of <code>n</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exception_1_1invalid__base.html">exception::invalid_base</a></em>&nbsp;</td><td>if base is less than two or greater than 36.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when you ask the library to write an integer to a stream, but it's more flexible because you can specify any base between 2 and 36. (Streams only allow base-8, base-10, or base-16.) </dd></dl>

</div>
</div>
<a class="anchor" id="a4a33279cf67c53f80a4e5935f0515d4d"></a><!-- doxytag: member="boost::xint::core::toMontgomeryForm" ref="a4a33279cf67c53f80a4e5935f0515d4d" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1core_1_1integer.html">integer</a> boost::xint::core::toMontgomeryForm </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Montgomery form of a number. Used for testing. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Apr 14 22:09:19 2010 for The Extended Integer (XInt) Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
