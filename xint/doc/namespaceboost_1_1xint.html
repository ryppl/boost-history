<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>The Extended Integer (XInt) Library: boost::xint Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceboost.html">boost</a>::<a class="el" href="namespaceboost_1_1xint.html">xint</a>
  </div>
</div>
<div class="contents">
<h1>boost::xint Namespace Reference</h1>
<p>All the types and functions of the library are within this namespace.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1detail.html">detail</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The items within this namespace are meant for internal use only. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint_1_1exceptions.html">exceptions</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Every exception the library throws is from this namespace. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1xint_1_1base__divide__t.html">base_divide_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds the results from a division-with-remainder call.  <a href="classboost_1_1xint_1_1base__divide__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A fixed-size integer type.  <a href="classboost_1_1xint_1_1fixed__integer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base class for all <a class="el" href="classboost_1_1xint_1_1fixed__integer.html" title="A fixed-size integer type.">fixed_integer</a> types.  <a href="classboost_1_1xint_1_1fixed__integer__any.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The core integer class.  <a href="classboost_1_1xint_1_1integer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The nothrow_integer class.  <a href="classboost_1_1xint_1_1nothrow__integer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1xint_1_1strong__random__generator.html">strong_random_generator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience class for cryptographically-secure random numbers.  <a href="classboost_1_1xint_1_1strong__random__generator.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; unsigned <br class="typebreak"/>
char &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">binary_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; bool()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a92ee4f1138215a36f4374a356fa5a359">operator-</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;a)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae64e3e8c8da2f0a1cb7064d1775fbf54">set_random_generator</a> (T *gen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the random generator that the library uses.  <a href="#ae64e3e8c8da2f0a1cb7064d1775fbf54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a27c1978abf1c401febe61285e8a3af0b">swap</a> (<a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;left, <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;right)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7832686d860601f27625d42b7532639e">swap</a> (<a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;left, <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;right)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7f5d22465d4dab8985c13479ec0e5e79">swap</a> (<a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;left, <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;right)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical primitives</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp196dd2a5f50860e057df961a96d84ea3"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ace023b79b24b4df655c1d86be77df99a">abs</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a19a0491b2825f010e9dd66ca50ab5672">abs</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the absolute value of an integer.  <a href="#a19a0491b2825f010e9dd66ca50ab5672"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0e114c276fc9affcc068dd5f0fbd9ff9">abs</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a74c947ce6c6d25b54c25b5c5427a9c62">add</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a5f82fa6b23e9af01292440248b89210d">add</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the sum of two integers.  <a href="#a5f82fa6b23e9af01292440248b89210d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7b7903cb879b60d0d5e3403b3c6a1cdd">add</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a4711eee4f69e1a7cc5c5393bd4d44361">divide</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;dividend, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;divisor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a4892543bb8ccfa8acb188a63a3d4723b">divide</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;dividend, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;divisor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate how many <code>dividends</code> would fit into <code>divisor</code>.  <a href="#a4892543bb8ccfa8acb188a63a3d4723b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a5b884361c54aa64a1974879cb3464c9a">divide</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;dividend, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;divisor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;::divide_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a95d8f6a792d953e6f1b3b1d1b43a05dc">divide_r</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;dividend, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;divisor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1base__divide__t.html">integer::divide_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aab594b314b957c668fb8d21cea175ff4">divide_r</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;d1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;d2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate how many <code>dividends</code> would fit into <code>divisor</code>, with the remainder.  <a href="#aab594b314b957c668fb8d21cea175ff4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1base__divide__t.html">nothrow_integer::divide_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a620fde117268b303531129d00247e24f">divide_r</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;d1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;d2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a6a548d944523cfc7c22823014bb6dcb6">multiply</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;by)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a9e0d6ad947fa3e979ed6e26d7e81ab7f">multiply</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;by)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the product of two integers.  <a href="#a9e0d6ad947fa3e979ed6e26d7e81ab7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#af844548a421cfc751133081b334dbe4b">multiply</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;by)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ade2e4d02cf0aa413f7e6f4d943ca341d">negate</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a84190f7b286de191e8026e440f104731">negate</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the additive inverse of an integer.  <a href="#a84190f7b286de191e8026e440f104731"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aedc1654de47ce6d6635e5339b236f94d">negate</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a218c0f1ddaaa8c978b3f84219ef712d2">subtract</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a86eb0099596fe66bd46be244323f44e5">subtract</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the difference between two integers.  <a href="#a86eb0099596fe66bd46be244323f44e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a385b3869d8dcceab2ffb68ff33c95062">subtract</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n2)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bit-manipulation functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpcc775c18f98f26f2b84ac7a2558636f2"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac9ac26e06d3665264feab3e02677a552">bitwise_and</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#abd4c2a471ad1e603ce5ef032071dd2ef">bitwise_and</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab828c0be1559b60537b959ef75092fb2">bitwise_and</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>AND</code> operation.  <a href="#ab828c0be1559b60537b959ef75092fb2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a47b675e2d348c9c53d4423e6c5eee354">bitwise_or</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a1221efa42739f309024e1715adc58917">bitwise_or</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab38ce0764a4b6433e11e30efa2175fec">bitwise_or</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>OR</code> operation.  <a href="#ab38ce0764a4b6433e11e30efa2175fec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a9ef262badd4547baacbf46206eb4a880">bitwise_xor</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab4996f013ac222b53bea0b46ff95e1df">bitwise_xor</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a6afd5af4550b698f6a7065f457fcb0a1">bitwise_xor</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two integers using a bitwise <code>XOR</code> operation.  <a href="#a6afd5af4550b698f6a7065f457fcb0a1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a41bef4baff8a6b4928fc9699d434a2bf">clearbit</a> (<a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, size_t bit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a6b82b4f0911b258e82b9c11b4413c8bf">clearbit</a> (<a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a96d452df71ac6799a7041647b4b106df">clearbit</a> (<a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a specific bit in an integer to zero.  <a href="#a96d452df71ac6799a7041647b4b106df"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a090f7c7d819b3c1a0f7cc0bd69dc4878">getbit</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, size_t bit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a125277404ae139bee70547f2d51d3e0e">getbit</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac00836bdc530b3eaf0a9b9f2e208273b">getbit</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the value of a particular bit in an integer.  <a href="#ac00836bdc530b3eaf0a9b9f2e208273b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a058c69285b794392f3e5853355d0fa3e">highestbit</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, size_t valueIfZero)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab817edabf5a6709c753dc6c07186ea75">highestbit</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, size_t valueIfZero)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aec002c076eff13d0382c5d2cd6de1d60">highestbit</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, size_t valueIfZero)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the index of the highest bit in an integer with a value of one.  <a href="#aec002c076eff13d0382c5d2cd6de1d60"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a6d7bfe0c5806902b377df0934f027f38">lowestbit</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, size_t valueIfZero)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a09477129544d4bdb08ddd63644683f5c">lowestbit</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, size_t valueIfZero)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a783e728f8221cd424d6f7f5d5f67ec40">lowestbit</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, size_t valueIfZero)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains the index of the lowest bit in an integer with a value of one.  <a href="#a783e728f8221cd424d6f7f5d5f67ec40"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aaf72216ae1986d06d4f39c27cada42d6">setbit</a> (<a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, size_t bit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac76235b31dcadded8193443b78743948">setbit</a> (<a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a6278915cf51b0d448a9db40031226182">setbit</a> (<a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, size_t bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a specific bit in an integer to one.  <a href="#a6278915cf51b0d448a9db40031226182"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a24944978923b67b2547c0f7245e4d7b9">shift</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, int byBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ad62ca08dc3d7600eee872dc5a95c338c">shift</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, int byBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aaed048f3dc3a442152ebffa3f721d014">shift</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, int byBits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bit-shift an integer, in either direction.  <a href="#aaed048f3dc3a442152ebffa3f721d014"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a1b096bd6583148b84b5f8020dfad4865">shift_left</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, size_t byBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a4bc41e443d230352f7c099e60f4056f4">shift_left</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, size_t byBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae22c3492ecf08370a9a972c8d6fb8e96">shift_left</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, size_t byBits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Left-shift an integer by a specified number of bits.  <a href="#ae22c3492ecf08370a9a972c8d6fb8e96"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aa01c60a4f969a7df6368f5c82695824c">shift_right</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, size_t byBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a295196e5fa8931578d27468cb5154f07">shift_right</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, size_t byBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aca7453fa9e276ebefacc9827b55f69d2">shift_right</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, size_t byBits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Right-shift an integer by a specified number of bits.  <a href="#aca7453fa9e276ebefacc9827b55f69d2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp458f92801f3edfaf2e30b1f530c324e2"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a2745c08384519957ceaf26c3e421d485">compare</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;b1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;b2, bool ignoresign)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a1b2d5e551626a5e2deac80e325c82ab2">compare</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;b1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;b2, bool ignoresign)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two <a class="el" href="classboost_1_1xint_1_1fixed__integer.html" title="A fixed-size integer type.">fixed_integer</a> objects.  <a href="#a1b2d5e551626a5e2deac80e325c82ab2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a23f712f01d6589687d2984b1c5efea8b">compare</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;b1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;b2, bool ignoresign)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two integer objects.  <a href="#a23f712f01d6589687d2984b1c5efea8b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab04ceb2184645859dcbbc00b7b9ff4ca">gcd</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;num1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a3ae2716e04bebbb74be08845db7132e2">gcd</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab551ac5968fdbcc639318b6f294da2cd">gcd</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the Greatest Common Denominator of two integers.  <a href="#ab551ac5968fdbcc639318b6f294da2cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a4e4bf24a99b565005d75630de66c5316">lcm</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;num1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a8782636245af4772735f6e7510a7d3da">lcm</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0096ae57d50e4fe8b5413ea7a4e60495">lcm</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the Least Common Multiple of two integers.  <a href="#a0096ae57d50e4fe8b5413ea7a4e60495"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a206fbae1c02ec96cb274aae1ad611da7">log2</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a080731f708e62fc429687bf450f36fa2">log2</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0cd277cd7a80cda764f889781f0140cd">log2</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the log<sub>2</sub> value of an integer.  <a href="#a0cd277cd7a80cda764f889781f0140cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0492c49fda91b5f498074d3f812906dd">opt_secure_mode</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the library was compiled with <a class="el" href="securemode.html">Secure Mode </a> enabled.  <a href="#a0492c49fda91b5f498074d3f812906dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac80750e62d5ffa2484332aae4b23d379">opt_thread_safe</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the library was compiled with the <a class="el" href="threadsafe.html">Thread Safe Operation option </a> enabled.  <a href="#ac80750e62d5ffa2484332aae4b23d379"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Powers and roots</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp928a8cb047602f789d7433e262ed4560"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a942e346f6e6d069dc19c28e7e56634ab">factorial</a> (size_t n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of <code>n!</code>  <a href="#a942e346f6e6d069dc19c28e7e56634ab"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a63ac6898cbfa81d7de658e359fdfbe36">fixed_factorial</a> (size_t n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac115a2ae7492ac4bae0fe5b2878ca7b1">fixed_pow2</a> (size_t e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0098148e09b3c1fb2aed15dc9badc7c6">nothrow_factorial</a> (size_t n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7dd5b57bcf282d01f39cddf425418287">nothrow_pow2</a> (size_t e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae92b86a29007f48749f17d54f36f469a">pow</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aa7d7b30f587c98ad31b8d421b8813c61">pow</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of n<sup>e</sup>  <a href="#aa7d7b30f587c98ad31b8d421b8813c61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7f73207284ff1f32b20fb8a6a7a82649">pow</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#af710e4b39cfa66096c202f17d12cc7b7">pow2</a> (size_t e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of 2<sup>e</sup>  <a href="#af710e4b39cfa66096c202f17d12cc7b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a041e980b0d5d3f48cd94bec1fb6d42a5">sqr</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#afbba1eeb86e4e7610a75afbb89d594e3">sqr</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the value of n<sup>2</sup>  <a href="#afbba1eeb86e4e7610a75afbb89d594e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a83ce32006b45117f9b3dc6c673fc9f01">sqr</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7516b17b5c54a012c9dbdc9a45e2142b">sqrt</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#afdf79cc57e434b9c7f4cb3b6bd68dbd6">sqrt</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the square root of <code>an</code> integer.  <a href="#afdf79cc57e434b9c7f4cb3b6bd68dbd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0825d8d9d4644df8d9b6922f5b0d7064">sqrt</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp9c2e8a06d85d2c9b83b5a0d27e85d535"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#af792bffef18de798c1b37be425baaa61">fixed_from_binary</a> (const <a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a> &amp;b, size_t bits)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a5fed365142e2728924d9fca3396c0efe">fixed_from_string</a> (const std::string &amp;str, size_t base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a4ac395fda0e4553da82a8e967e188280">from_binary</a> (const <a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a> &amp;b, size_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a portable binary representation of a number into an integer.  <a href="#a4ac395fda0e4553da82a8e967e188280"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#af263105e57d48eff5fe14d4d03ca10e1">from_string</a> (const std::string &amp;str, size_t base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a string to an integer.  <a href="#af263105e57d48eff5fe14d4d03ca10e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ad7e6b2629b12014d16bbc7b2383d72cd">nothrow_from_binary</a> (const <a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a> &amp;b, size_t bits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae40f9a912e985490d7291d56e597a464">nothrow_from_string</a> (const std::string &amp;str, size_t base)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ad8a1d63acfebbbdfce1047c966682a93">to</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae90546b0cb6cf2f27fc5ce65bb43a21e">to</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Efficiently converts from an <a class="el" href="classboost_1_1xint_1_1integer.html" title="The core integer class.">xint::integer</a> to a built-in integer type.  <a href="#ae90546b0cb6cf2f27fc5ce65bb43a21e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits, typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a2078ed71644ee71a1ce2e616d28e5baa">to</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a2691e17588d7a0bb6614d5bdeb66cd4c">to_binary</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;n, size_t bits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac6b8b0fa807a6a216314af2b4bcca45d">to_binary</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, size_t bits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a61303b2b007d23cc8c9b7450c848c14d">to_binary</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, size_t bits)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a binary representation of an integer.  <a href="#a61303b2b007d23cc8c9b7450c848c14d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a41f8922f3a2328a3c8f0d50264643ca7">to_string</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, size_t base, bool uppercase)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a185dd459850bfd588a4a9b3c67e8c09c">to_string</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;n, size_t base, bool uppercase)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac0454fdc47e70a493c7bf5d92dda33d4">to_string</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, size_t base, bool uppercase)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a string representation of the specified integer.  <a href="#ac0454fdc47e70a493c7bf5d92dda33d4"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Random number functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpdd4713a71c208a173c1f2436d4e32ff7"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a96c7867b9ad53a718c08db8226edec62">fixed_random_by_size</a> (size_t bits, bool high_bit_on, bool low_bit_on, bool can_be_negative)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a1b55b4b192aa6abc491e3ed8c5ef2627">nothrow_random_by_size</a> (size_t bits, bool high_bit_on, bool low_bit_on, bool can_be_negative)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac8d879e19a6608b21184236e00806be5">random_by_size</a> (size_t bits, bool high_bit_on, bool low_bit_on, bool can_be_negative)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a random integer with specific attributes.  <a href="#ac8d879e19a6608b21184236e00806be5"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Prime number functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp540e8e12721acbe497d2b9b53ecc76ec"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#afab685e9431b90c98079030eae8bdb35">fixed_random_prime</a> (size_t size_in_bits, <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0711bdafefe7d376e5cc603731318fc6">is_prime</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;n, <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a58aa3df545d1da848922c13de2a87fc9">is_prime</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests an integer for primality.  <a href="#a58aa3df545d1da848922c13de2a87fc9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ad581832932a4816cbc9f24740732c3a0">is_prime</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aed98791058e6a589b06f8015ae0acaef">nothrow_random_prime</a> (size_t size_in_bits, <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aaf58d56e1a47ac55e0aa97a55e6fb2c9">random_prime</a> (size_t size_in_bits, <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a randomly-generated prime number of a particular bit-size.  <a href="#aaf58d56e1a47ac55e0aa97a55e6fb2c9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Modular math functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpbf63e6a6a1029bb25b7aa51052b38655"></a>A common reason to use a large-integer library is to implement public-key encryption, and the algorithms for such encryption often use modular math. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0ae43d82587191d69d4f0b44226fc12f">invmod</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a02c28345b397cb1508bad8d2bd36ca53">invmod</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a1e2477157ea768d8c57fac1c31a8f7ca">invmod</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular inverse of a number in a modulus, if there is one.  <a href="#a1e2477157ea768d8c57fac1c31a8f7ca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a30c0cd9ad317c1a373cdc059b6f81cb9">mod</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;modBy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#af91fe435810928b98d6e2b36ea4c3b53">mod</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a9b8c31b64eb9700beea8b95edec31a73">mod</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remainder after dividing a number by another.  <a href="#a9b8c31b64eb9700beea8b95edec31a73"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a6dd657413c395d346e59b282aa6138d8">mulmod</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;by, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a3deaa6f8a44d454129bb06691a6035c7">mulmod</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;by, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac9af74aa79d9cc7f51c57cc7707824ba">mulmod</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;by, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular product of two integers.  <a href="#ac9af74aa79d9cc7f51c57cc7707824ba"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a8f97bd640a2e3a45313fd1893dc854e3">powmod</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;e, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;m, bool noMontgomery)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aa0d4bbcf5391accad798da207180894e">powmod</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;e, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;m, bool noMontgomery)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a35e7556e9f2d8fb944dbf732ed3f96cd">powmod</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;e, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;m, bool noMontgomery)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the result of <code>n<sup>e</sup></code> % <code>m</code>, keeping the intermediate results (relatively) small.  <a href="#a35e7556e9f2d8fb944dbf732ed3f96cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a35ff2132479ee8c99dd8017af679828e">sqrmod</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae64aa02c6217ea9f53f25d4f44ddddd1">sqrmod</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#adb9a9cb117e7346a3b56c369cd438b0e">sqrmod</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the modular product of squaring an integer.  <a href="#adb9a9cb117e7346a3b56c369cd438b0e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb3c5827f54218753bb2c3338236446c2"></a> These act exactly the same as for the built-in integer types. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a43189615a1bfb4904c969efe846cefc6">operator!=</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ad85d78b5be317ed9a3cfa512953fa800">operator!=</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac5d5cb8db57fd0247aa4e36d9b25c492">operator!=</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a115e84b56b4e5e00d0b2b5c8a407ef97">operator%</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a2261cdd3b6c689b76cc379ac515e5d45">operator%</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab054d123a003a31c06bac92a1f325805">operator&amp;</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a97db617d1b8d73ca35c8ef41ec7e9a31">operator&amp;</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae3770c0e356d50b5f3e2be573e6100cd">operator*</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aadeb3206628bdfd3112db2d80fff7c92">operator*</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a0f6171689ef68ff6672e43a1e24ea494">operator+</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a69d186688f404f1608663142da86158c">operator+</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac16aa971521ae015a62ec015f1fe56d0">operator-</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ad51e8e59ad1ff61dcdd462bf9d8acf08">operator-</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a9a2859e7b5e532eaa0cc51aba4f958c2">operator/</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a83d07bf51fce0b4644b2190278c30413">operator/</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#aab98cd20fa3761900de197363bac0fcb">operator&lt;</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ad6104aaba26d6b8d801cce276f154fe8">operator&lt;</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#af845afe18e9b1326d630e5c0696e679d">operator&lt;</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a8a72cb95a5e25a310215eaa2cc93349f">operator&lt;=</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a40319361b76e6c7fea92867ea76695c2">operator&lt;=</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7749bff2e150c55649324ba9797aa6d0">operator&lt;=</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">detail bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#accccaec2c2a8ccfadfc559adbb7ff6ed">operator==</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a1ecc233f5b5f1fc24a7aa9bab3868c2c">operator==</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a66b558cce023df7b3e10ee22dfe653d0">operator==</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a002b54ae65c6c265d773e7b491bd90fb">operator&gt;</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ac04d99142bc67642325ac524a8523f63">operator&gt;</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab09672bca82a7f4fbdca4443492210bc">operator&gt;</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a2e213ecd798c6bc331460dff13b35173">operator&gt;=</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#af6fd110351f7aebd589bd482eab3696a">operator&gt;=</a> (const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1fixed__integer__any.html">fixed_integer_any</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a1ace7bde7533ff9d8a3f38978e7bb046">operator&gt;=</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;num2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a9524e5e34757cb10a146012bc4192643">operator^</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a2b27999f391ede4a2ec60ee83e6e5060">operator^</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a4896e1fc3c8d0adb4911cf5b78304f49">operator|</a> (const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ae1b86fdde7f84fbcbe39cec5ecc0bc8c">operator|</a> (const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n1, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n2)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stream input/output functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd9927783c44c1aad288df0ab8bfa9ddf"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a4b7b76c7fb4b03cf086773a55604d6a2">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;out, const <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a8d1a90f08d8ad3547627f2c2590ab20d">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;out, const <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits , size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a7188dd65026fde2ae4a690d55ef7b648">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;out, const <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a01075dbe629f0b3bd58d4d18fce80637">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;in, <a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a3a5967ac54c1a269f0b4ed555391ca4f">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;in, <a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> &amp;n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename charT , typename traits , size_t Bits&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; charT, <br class="typebreak"/>
traits &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#ab027908e04b71c8be33172768c6a2f67">operator&gt;&gt;</a> (std::basic_istream&lt; charT, traits &gt; &amp;in, <a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; &amp;n)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">autobase</a> = (std::numeric_limits&lt;size_t&gt;::max)()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696">no_callback</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>All the types and functions of the library are within this namespace. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aae3128529370506165793f2771834e58"></a><!-- doxytag: member="boost::xint::binary_t" ref="aae3128529370506165793f2771834e58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;unsigned char&gt; <a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">boost::xint::binary_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The format for the binary representations of integers. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#a61303b2b007d23cc8c9b7450c848c14d" title="Creates a binary representation of an integer.">xint::to_binary</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#a4ac395fda0e4553da82a8e967e188280" title="Converts a portable binary representation of a number into an integer.">xint::from_binary</a> </dd></dl>

<p>Definition at line <a class="el" href="internals_8hpp_source.html#l00090">90</a> of file <a class="el" href="internals_8hpp_source.html">internals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48deb76c9c428a4b3a50177b1b0cb547"></a><!-- doxytag: member="boost::xint::callback_t" ref="a48deb76c9c428a4b3a50177b1b0cb547" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;bool ()&gt; <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">boost::xint::callback_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A callback function takes no parameters and returns a bool. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#ad581832932a4816cbc9f24740732c3a0">xint::is_prime</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#aaf58d56e1a47ac55e0aa97a55e6fb2c9" title="Generate a randomly-generated prime number of a particular bit-size.">xint::random_prime</a> </dd></dl>

<p>Definition at line <a class="el" href="internals_8hpp_source.html#l00080">80</a> of file <a class="el" href="internals_8hpp_source.html">internals.hpp</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ace023b79b24b4df655c1d86be77df99a"></a><!-- doxytag: member="boost::xint::abs" ref="ace023b79b24b4df655c1d86be77df99a" args="(const fixed_integer&lt; Bits &gt; &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::abs </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the absolute value of an integer. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If <code>n</code> is zero or positive, returns <code>n</code>. Otherwise returns <code>-n</code>. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00513">513</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19a0491b2825f010e9dd66ca50ab5672"></a><!-- doxytag: member="boost::xint::abs" ref="a19a0491b2825f010e9dd66ca50ab5672" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::abs </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the absolute value of an integer. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If <code>n</code> is zero or positive, returns <code>n</code>. Otherwise returns <code>-n</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e114c276fc9affcc068dd5f0fbd9ff9"></a><!-- doxytag: member="boost::xint::abs" ref="a0e114c276fc9affcc068dd5f0fbd9ff9" args="(const nothrow_integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::abs </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the absolute value of an integer. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If <code>n</code> is zero or positive, returns <code>n</code>. Otherwise returns <code>-n</code>. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a74c947ce6c6d25b54c25b5c5427a9c62"></a><!-- doxytag: member="boost::xint::add" ref="a74c947ce6c6d25b54c25b5c5427a9c62" args="(const fixed_integer&lt; Bits &gt; &amp;n1, const fixed_integer&lt; Bits &gt; &amp;n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::add </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the sum of two integers. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sum of the parameters. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00531">531</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f82fa6b23e9af01292440248b89210d"></a><!-- doxytag: member="boost::xint::add" ref="a5f82fa6b23e9af01292440248b89210d" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::add </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the sum of two integers. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sum of the parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b7903cb879b60d0d5e3403b3c6a1cdd"></a><!-- doxytag: member="boost::xint::add" ref="a7b7903cb879b60d0d5e3403b3c6a1cdd" args="(const nothrow_integer &amp;n1, const nothrow_integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::add </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the sum of two integers. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sum of the parameters. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ac9ac26e06d3665264feab3e02677a552"></a><!-- doxytag: member="boost::xint::bitwise_and" ref="ac9ac26e06d3665264feab3e02677a552" args="(const fixed_integer&lt; Bits &gt; &amp;n1, const fixed_integer&lt; Bits &gt; &amp;n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::bitwise_and </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Combine two integers using a bitwise <code>AND</code> operation. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in both parameters turned on. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00684">684</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abd4c2a471ad1e603ce5ef032071dd2ef"></a><!-- doxytag: member="boost::xint::bitwise_and" ref="abd4c2a471ad1e603ce5ef032071dd2ef" args="(const nothrow_integer &amp;n1, const nothrow_integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::bitwise_and </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Combine two integers using a bitwise <code>AND</code> operation. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in both parameters turned on. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ab828c0be1559b60537b959ef75092fb2"></a><!-- doxytag: member="boost::xint::bitwise_and" ref="ab828c0be1559b60537b959ef75092fb2" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::bitwise_and </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>AND</code> operation. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in both parameters turned on. </dd></dl>

</div>
</div>
<a class="anchor" id="a47b675e2d348c9c53d4423e6c5eee354"></a><!-- doxytag: member="boost::xint::bitwise_or" ref="a47b675e2d348c9c53d4423e6c5eee354" args="(const fixed_integer&lt; Bits &gt; &amp;n1, const fixed_integer&lt; Bits &gt; &amp;n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::bitwise_or </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Combine two integers using a bitwise <code>OR</code> operation. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in either parameter turned on. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00694">694</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1221efa42739f309024e1715adc58917"></a><!-- doxytag: member="boost::xint::bitwise_or" ref="a1221efa42739f309024e1715adc58917" args="(const nothrow_integer &amp;n1, const nothrow_integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::bitwise_or </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Combine two integers using a bitwise <code>OR</code> operation. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in either parameter turned on. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ab38ce0764a4b6433e11e30efa2175fec"></a><!-- doxytag: member="boost::xint::bitwise_or" ref="ab38ce0764a4b6433e11e30efa2175fec" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::bitwise_or </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>OR</code> operation. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in either parameter turned on. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ef262badd4547baacbf46206eb4a880"></a><!-- doxytag: member="boost::xint::bitwise_xor" ref="a9ef262badd4547baacbf46206eb4a880" args="(const fixed_integer&lt; Bits &gt; &amp;n1, const fixed_integer&lt; Bits &gt; &amp;n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::bitwise_xor </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Combine two integers using a bitwise <code>XOR</code> operation. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in either parameter, but not both, turned on. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00704">704</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4996f013ac222b53bea0b46ff95e1df"></a><!-- doxytag: member="boost::xint::bitwise_xor" ref="ab4996f013ac222b53bea0b46ff95e1df" args="(const nothrow_integer &amp;n1, const nothrow_integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::bitwise_xor </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Combine two integers using a bitwise <code>XOR</code> operation. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in either parameter, but not both, turned on. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a6afd5af4550b698f6a7065f457fcb0a1"></a><!-- doxytag: member="boost::xint::bitwise_xor" ref="a6afd5af4550b698f6a7065f457fcb0a1" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::bitwise_xor </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine two integers using a bitwise <code>XOR</code> operation. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive integer with all bits that are set in either parameter, but not both, turned on. </dd></dl>

</div>
</div>
<a class="anchor" id="a41bef4baff8a6b4928fc9699d434a2bf"></a><!-- doxytag: member="boost::xint::clearbit" ref="a41bef4baff8a6b4928fc9699d434a2bf" args="(fixed_integer&lt; Bits &gt; &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::clearbit </td>
          <td>(</td>
          <td class="paramtype">fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets a specific bit in an integer to zero. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00666">666</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b82b4f0911b258e82b9c11b4413c8bf"></a><!-- doxytag: member="boost::xint::clearbit" ref="a6b82b4f0911b258e82b9c11b4413c8bf" args="(nothrow_integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::clearbit </td>
          <td>(</td>
          <td class="paramtype">nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets a specific bit in an integer to zero. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a96d452df71ac6799a7041647b4b106df"></a><!-- doxytag: member="boost::xint::clearbit" ref="a96d452df71ac6799a7041647b4b106df" args="(integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::clearbit </td>
          <td>(</td>
          <td class="paramtype">integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a specific bit in an integer to zero. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a2745c08384519957ceaf26c3e421d485"></a><!-- doxytag: member="boost::xint::compare" ref="a2745c08384519957ceaf26c3e421d485" args="(const nothrow_integer &amp;b1, const nothrow_integer &amp;b2, bool ignoresign)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int boost::xint::compare </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoresign</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare two integer objects. <ul>
<li>Complexity: O(n) at worst</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b1,b2</em>&nbsp;</td><td>The integers to compare. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignoresign</em>&nbsp;</td><td>If <code>true</code>, the absolute values of b1 and b2 are compared, instead of their signed values. Used internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative number if <code>b1</code> &lt; <code>b2</code>; zero if <code>b1</code> == <code>b2</code>, or a positive number if <code>b1</code> &gt; <code>b2</code>. </dd></dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns 0 instead of throwing. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b2d5e551626a5e2deac80e325c82ab2"></a><!-- doxytag: member="boost::xint::compare" ref="a1b2d5e551626a5e2deac80e325c82ab2" args="(const fixed_integer_any &amp;b1, const fixed_integer_any &amp;b2, bool ignoresign)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int boost::xint::compare </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoresign</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two <a class="el" href="classboost_1_1xint_1_1fixed__integer.html" title="A fixed-size integer type.">fixed_integer</a> objects. </p>
<ul>
<li>Complexity: O(n) at worst</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b1,b2</em>&nbsp;</td><td>The integers to compare. They can be the same size or different sizes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignoresign</em>&nbsp;</td><td>If <code>true</code>, the absolute values of b1 and b2 are compared, instead of their signed values. Used internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative number if <code>b1</code> &lt; <code>b2</code>; zero if <code>b1</code> == <code>b2</code>, or a positive number if <code>b1</code> &gt; <code>b2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a23f712f01d6589687d2984b1c5efea8b"></a><!-- doxytag: member="boost::xint::compare" ref="a23f712f01d6589687d2984b1c5efea8b" args="(const integer &amp;b1, const integer &amp;b2, bool ignoresign)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int boost::xint::compare </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ignoresign</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two integer objects. </p>
<ul>
<li>Complexity: O(n) at worst</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b1,b2</em>&nbsp;</td><td>The integers to compare. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ignoresign</em>&nbsp;</td><td>If <code>true</code>, the absolute values of b1 and b2 are compared, instead of their signed values. Used internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative number if <code>b1</code> &lt; <code>b2</code>; zero if <code>b1</code> == <code>b2</code>, or a positive number if <code>b1</code> &gt; <code>b2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4711eee4f69e1a7cc5c5393bd4d44361"></a><!-- doxytag: member="boost::xint::divide" ref="a4711eee4f69e1a7cc5c5393bd4d44361" args="(const fixed_integer&lt; Bits &gt; &amp;dividend, const fixed_integer&lt; Bits &gt; &amp;divisor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::divide </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dividend,divisor</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of <code>dividend</code> divided by <code>divisor</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1divide__by__zero.html">exceptions::divide_by_zero</a></em>&nbsp;</td><td>if <code>divisor</code> is zero. </td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00561">561</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4892543bb8ccfa8acb188a63a3d4723b"></a><!-- doxytag: member="boost::xint::divide" ref="a4892543bb8ccfa8acb188a63a3d4723b" args="(const integer &amp;dividend, const integer &amp;divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::divide </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dividend,divisor</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of <code>dividend</code> divided by <code>divisor</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1divide__by__zero.html">exceptions::divide_by_zero</a></em>&nbsp;</td><td>if <code>divisor</code> is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b884361c54aa64a1974879cb3464c9a"></a><!-- doxytag: member="boost::xint::divide" ref="a5b884361c54aa64a1974879cb3464c9a" args="(const nothrow_integer &amp;dividend, const nothrow_integer &amp;divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::divide </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dividend,divisor</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of <code>dividend</code> divided by <code>divisor</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1divide__by__zero.html">exceptions::divide_by_zero</a></em>&nbsp;</td><td>if <code>divisor</code> is zero. </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="a95d8f6a792d953e6f1b3b1d1b43a05dc"></a><!-- doxytag: member="boost::xint::divide_r" ref="a95d8f6a792d953e6f1b3b1d1b43a05dc" args="(const fixed_integer&lt; Bits &gt; &amp;dividend, const fixed_integer&lt; Bits &gt; &amp;divisor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt;::divide_t boost::xint::divide_r </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dividend,divisor</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer value of <code>dividend</code> divided by <code>divisor</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1divide__by__zero.html">exceptions::divide_by_zero</a></em>&nbsp;</td><td>if <code>divisor</code> is zero. </td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00571">571</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab594b314b957c668fb8d21cea175ff4"></a><!-- doxytag: member="boost::xint::divide_r" ref="aab594b314b957c668fb8d21cea175ff4" args="(const integer &amp;d1, const integer &amp;d2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1base__divide__t.html">integer::divide_t</a> boost::xint::divide_r </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>d2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>, with the remainder. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d1</em>&nbsp;</td><td>The dividend. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d2</em>&nbsp;</td><td>The divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>divide_t</code> class containing the quotient and remainder of <code>d1</code> divided by <code>d2</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1divide__by__zero.html">exceptions::divide_by_zero</a></em>&nbsp;</td><td>if <code>d2</code> is zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a620fde117268b303531129d00247e24f"></a><!-- doxytag: member="boost::xint::divide_r" ref="a620fde117268b303531129d00247e24f" args="(const nothrow_integer &amp;d1, const nothrow_integer &amp;d2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1base__divide__t.html">nothrow_integer::divide_t</a> boost::xint::divide_r </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>d2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate how many <code>dividends</code> would fit into <code>divisor</code>, with the remainder. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d1</em>&nbsp;</td><td>The dividend. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>d2</em>&nbsp;</td><td>The divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>divide_t</code> class containing the quotient and remainder of <code>d1</code> divided by <code>d2</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1divide__by__zero.html">exceptions::divide_by_zero</a></em>&nbsp;</td><td>if <code>d2</code> is zero. </td></tr>
  </table>
  </dd>
</dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns two Not-a-Number values instead of throwing. </dd></dl>

</div>
</div>
<a class="anchor" id="a942e346f6e6d069dc19c28e7e56634ab"></a><!-- doxytag: member="boost::xint::factorial" ref="a942e346f6e6d069dc19c28e7e56634ab" args="(size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::factorial </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of <code>n!</code> </p>
<ul>
<li>Complexity: O(n<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> factorial, defined as <code>1*2*3*...*n</code></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Factorials get ridiculously huge, even with fairly small values of <code>n</code>. This function, when used with a large parameter, is the easiest way to exhaust the system's memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a63ac6898cbfa81d7de658e359fdfbe36"></a><!-- doxytag: member="boost::xint::fixed_factorial" ref="a63ac6898cbfa81d7de658e359fdfbe36" args="(size_t n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::fixed_factorial </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the value of <code>n!</code> <ul>
<li>Complexity: O(n<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> factorial, defined as <code>1*2*3*...*n</code></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Factorials get ridiculously huge, even with fairly small values of <code>n</code>. This function, when used with a large parameter, is the easiest way to exhaust the system's memory. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00608">608</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af792bffef18de798c1b37be425baaa61"></a><!-- doxytag: member="boost::xint::fixed_from_binary" ref="af792bffef18de798c1b37be425baaa61" args="(const xint::binary_t &amp;b, size_t bits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::fixed_from_binary </td>
          <td>(</td>
          <td class="paramtype">const xint::binary_t &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a portable binary representation of a number into an integer. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b</em>&nbsp;</td><td>An <code><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a></code> containing the bytes to convert, lowest byte first. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The number of bits packed into each character (for portability with systems that might not have characters with the same number of bits), or zero (the default) to assume the number of bits in the current system's unsigned character type.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>bits</code> is greater than the number of bits in an unsigned character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer representing the bytes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#a61303b2b007d23cc8c9b7450c848c14d" title="Creates a binary representation of an integer.">xint::to_binary</a> </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00646">646</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5fed365142e2728924d9fca3396c0efe"></a><!-- doxytag: member="boost::xint::fixed_from_string" ref="a5fed365142e2728924d9fca3396c0efe" args="(const std::string &amp;str, size_t base)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::fixed_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a string to an integer. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>str</em>&nbsp;</td><td>The string to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>the base that the string representation of the number is in. This can be any number between 2 and 36 (inclusive). It can also be the constant <a class="el" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">xint::autobase</a>, in which case the function will follow the standard C/C++ rules for interpreting a numeric constant: any number with a zero as the first digit is assumed to be base-8; any number with a leading zero-x or zero-X (such as 0x1f) is base-16, and anything else is base-10.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer with the numeric value of the string in base <code>base</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1overflow__error.html">exceptions::overflow_error</a></em>&nbsp;</td><td>if there is not enough free memory to create the integer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__base.html">exceptions::invalid_base</a></em>&nbsp;</td><td>if the base parameter is not between 2 and 36 (inclusive) or the constant <a class="el" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">xint::autobase</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__digit.html">exceptions::invalid_digit</a></em>&nbsp;</td><td>if the string contains any digit that cannot be part of a number in the specified base, or if there are no valid digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when reading an integer from a stream, or when contructing one from a string. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00630">630</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac115a2ae7492ac4bae0fe5b2878ca7b1"></a><!-- doxytag: member="boost::xint::fixed_pow2" ref="ac115a2ae7492ac4bae0fe5b2878ca7b1" args="(size_t e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::fixed_pow2 </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the value of 2<sup>e</sup> <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>The exponent to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>2 to the power of <code>e</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a convenience function, to help with self-documenting code. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00600">600</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96c7867b9ad53a718c08db8226edec62"></a><!-- doxytag: member="boost::xint::fixed_random_by_size" ref="a96c7867b9ad53a718c08db8226edec62" args="(size_t bits, bool high_bit_on, bool low_bit_on, bool can_be_negative)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::fixed_random_by_size </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>high_bit_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>low_bit_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>can_be_negative</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates a random integer with specific attributes. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The maximum number of bits that you want the returned number to have. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>high_bit_on</em>&nbsp;</td><td>If <code>true</code>, the returned number will have exactly the requested size. If <code>false</code>, the upper bits may be zero, resulting in a number that is slightly smaller than requested. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>low_bit_on</em>&nbsp;</td><td>If <code>true</code>, the returned number will always be odd. If <code>false</code>, it has an equal chance of being odd or even. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>can_be_negative</em>&nbsp;</td><td>If <code>true</code>, the returned value has an equal chance of being positive or negative. If <code>false</code>, it will always be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A random integer with the requested attributes.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the currently-defined random generator.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="random.html">The XInt Random Number System</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#ae64e3e8c8da2f0a1cb7064d1775fbf54" title="Change the random generator that the library uses.">xint::set_random_generator</a> </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00781">781</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afab685e9431b90c98079030eae8bdb35"></a><!-- doxytag: member="boost::xint::fixed_random_prime" ref="afab685e9431b90c98079030eae8bdb35" args="(size_t size_in_bits, callback_t callback)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::fixed_random_prime </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size_in_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a randomly-generated prime number of a particular bit-size. <ul>
<li>Complexity: Varies</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size_in_bits</em>&nbsp;</td><td>The number of bits that you want the returned value to have. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A randomly-generated prime integer with the specified number of bits, or zero if the provided callback function cancelled the operation.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>size_in_bits</code> is less than two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function uses <a class="el" href="namespaceboost_1_1xint.html#ad581832932a4816cbc9f24740732c3a0">xint::is_prime</a>. See the description of it for details of its limitations.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>It also uses the library's currently-set random number generator. See the <a class="el" href="random.html">Random Number Functions page</a> for details on its limitations and requirements, and how to get cryptographically-secure random numbers.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00790">790</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ac395fda0e4553da82a8e967e188280"></a><!-- doxytag: member="boost::xint::from_binary" ref="a4ac395fda0e4553da82a8e967e188280" args="(const xint::binary_t &amp;b, size_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::from_binary </td>
          <td>(</td>
          <td class="paramtype">const xint::binary_t &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a portable binary representation of a number into an integer. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b</em>&nbsp;</td><td>An <code><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a></code> containing the bytes to convert, lowest byte first. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The number of bits packed into each character (for portability with systems that might not have characters with the same number of bits), or zero (the default) to assume the number of bits in the current system's unsigned character type.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>bits</code> is greater than the number of bits in an unsigned character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer representing the bytes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#a61303b2b007d23cc8c9b7450c848c14d" title="Creates a binary representation of an integer.">xint::to_binary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af263105e57d48eff5fe14d4d03ca10e1"></a><!-- doxytag: member="boost::xint::from_string" ref="af263105e57d48eff5fe14d4d03ca10e1" args="(const std::string &amp;str, size_t base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a string to an integer. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>str</em>&nbsp;</td><td>The string to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>the base that the string representation of the number is in. This can be any number between 2 and 36 (inclusive). It can also be the constant <a class="el" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">xint::autobase</a>, in which case the function will follow the standard C/C++ rules for interpreting a numeric constant: any number with a zero as the first digit is assumed to be base-8; any number with a leading zero-x or zero-X (such as 0x1f) is base-16, and anything else is base-10.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer with the numeric value of the string in base <code>base</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1overflow__error.html">exceptions::overflow_error</a></em>&nbsp;</td><td>if there is not enough free memory to create the integer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__base.html">exceptions::invalid_base</a></em>&nbsp;</td><td>if the base parameter is not between 2 and 36 (inclusive) or the constant <a class="el" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">xint::autobase</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__digit.html">exceptions::invalid_digit</a></em>&nbsp;</td><td>if the string contains any digit that cannot be part of a number in the specified base, or if there are no valid digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when reading an integer from a stream, or when contructing one from a string. </dd></dl>

</div>
</div>
<a class="anchor" id="ab04ceb2184645859dcbbc00b7b9ff4ca"></a><!-- doxytag: member="boost::xint::gcd" ref="ab04ceb2184645859dcbbc00b7b9ff4ca" args="(const fixed_integer&lt; Bits &gt; &amp;num1, const fixed_integer&lt; Bits &gt; &amp;num2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::gcd </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the Greatest Common Denominator of two integers. <ul>
<li>Complexity: O((log n)<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The greatest common denominator of the two integers, which will always be a positive number. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00798">798</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ae2716e04bebbb74be08845db7132e2"></a><!-- doxytag: member="boost::xint::gcd" ref="a3ae2716e04bebbb74be08845db7132e2" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::gcd </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the Greatest Common Denominator of two integers. <ul>
<li>Complexity: O((log n)<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The greatest common denominator of the two integers, which will always be a positive number. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ab551ac5968fdbcc639318b6f294da2cd"></a><!-- doxytag: member="boost::xint::gcd" ref="ab551ac5968fdbcc639318b6f294da2cd" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::gcd </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Greatest Common Denominator of two integers. </p>
<ul>
<li>Complexity: O((log n)<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The greatest common denominator of the two integers, which will always be a positive number. </dd></dl>

</div>
</div>
<a class="anchor" id="a090f7c7d819b3c1a0f7cc0bd69dc4878"></a><!-- doxytag: member="boost::xint::getbit" ref="a090f7c7d819b3c1a0f7cc0bd69dc4878" args="(const fixed_integer&lt; Bits &gt; &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::getbit </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queries the value of a particular bit in an integer. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit you're asking about.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the specified bit is set (has a value of one), <code>false</code> if it is clear. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00654">654</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a125277404ae139bee70547f2d51d3e0e"></a><!-- doxytag: member="boost::xint::getbit" ref="a125277404ae139bee70547f2d51d3e0e" args="(const nothrow_integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::getbit </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Queries the value of a particular bit in an integer. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit you're asking about.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the specified bit is set (has a value of one), <code>false</code> if it is clear. </dd></dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns false instead of throwing. </dd></dl>

</div>
</div>
<a class="anchor" id="ac00836bdc530b3eaf0a9b9f2e208273b"></a><!-- doxytag: member="boost::xint::getbit" ref="ac00836bdc530b3eaf0a9b9f2e208273b" args="(const integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::getbit </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queries the value of a particular bit in an integer. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit you're asking about.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the specified bit is set (has a value of one), <code>false</code> if it is clear. </dd></dl>

</div>
</div>
<a class="anchor" id="a058c69285b794392f3e5853355d0fa3e"></a><!-- doxytag: member="boost::xint::highestbit" ref="a058c69285b794392f3e5853355d0fa3e" args="(const fixed_integer&lt; Bits &gt; &amp;n, size_t valueIfZero)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::highestbit </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>valueIfZero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Obtains the index of the highest bit in an integer with a value of one. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>valueIfZero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the highest one-bit in the integer, or <code>valueIfZero</code> if the integer contains no set bits. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00678">678</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab817edabf5a6709c753dc6c07186ea75"></a><!-- doxytag: member="boost::xint::highestbit" ref="ab817edabf5a6709c753dc6c07186ea75" args="(const nothrow_integer &amp;n, size_t valueIfZero)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::highestbit </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>valueIfZero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Obtains the index of the highest bit in an integer with a value of one. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>valueIfZero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the highest one-bit in the integer, or <code>valueIfZero</code> if the integer contains no set bits. </dd></dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns zero instead of throwing. </dd></dl>

</div>
</div>
<a class="anchor" id="aec002c076eff13d0382c5d2cd6de1d60"></a><!-- doxytag: member="boost::xint::highestbit" ref="aec002c076eff13d0382c5d2cd6de1d60" args="(const integer &amp;n, size_t valueIfZero)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::highestbit </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>valueIfZero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the index of the highest bit in an integer with a value of one. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>valueIfZero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the highest one-bit in the integer, or <code>valueIfZero</code> if the integer contains no set bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ae43d82587191d69d4f0b44226fc12f"></a><!-- doxytag: member="boost::xint::invmod" ref="a0ae43d82587191d69d4f0b44226fc12f" args="(const fixed_integer&lt; Bits &gt; &amp;n, const fixed_integer&lt; Bits &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::invmod </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the modular inverse of a number in a modulus, if there is one. <ul>
<li>Complexity: O((log n)<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to calculate the inverse of. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The modular inverse of <code>n</code> in <code>m</code>. If <code>n</code> has no modular inverse in <code>m</code>, returns zero.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__modulus.html">exceptions::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one. </td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00771">771</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02c28345b397cb1508bad8d2bd36ca53"></a><!-- doxytag: member="boost::xint::invmod" ref="a02c28345b397cb1508bad8d2bd36ca53" args="(const nothrow_integer &amp;n, const nothrow_integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::invmod </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the modular inverse of a number in a modulus, if there is one. <ul>
<li>Complexity: O((log n)<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to calculate the inverse of. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The modular inverse of <code>n</code> in <code>m</code>. If <code>n</code> has no modular inverse in <code>m</code>, returns zero.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__modulus.html">exceptions::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one. </td></tr>
  </table>
  </dd>
</dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns zero instead of throwing. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e2477157ea768d8c57fac1c31a8f7ca"></a><!-- doxytag: member="boost::xint::invmod" ref="a1e2477157ea768d8c57fac1c31a8f7ca" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::invmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular inverse of a number in a modulus, if there is one. </p>
<ul>
<li>Complexity: O((log n)<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to calculate the inverse of. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The modular inverse of <code>n</code> in <code>m</code>. If <code>n</code> has no modular inverse in <code>m</code>, returns zero.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__modulus.html">exceptions::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0711bdafefe7d376e5cc603731318fc6"></a><!-- doxytag: member="boost::xint::is_prime" ref="a0711bdafefe7d376e5cc603731318fc6" args="(const fixed_integer_any &amp;n, callback_t callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int boost::xint::is_prime </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tests an integer for primality. <ul>
<li>Complexity: Varies</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to test. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <code>n</code> seems to be prime, 0 if it isn't, or -1 if the provided callback function cancelled the operation.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>n</code> is less than 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the Rabin-Miller probabilistic primality test. There is an infinitesimally small chance that it will think that a composite number is actually prime, but that is so small that it can be ignored for most practical purposes. If even that chance is too much, you can run this function over the number several times, it will use different random "witness" numbers each time.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a58aa3df545d1da848922c13de2a87fc9"></a><!-- doxytag: member="boost::xint::is_prime" ref="a58aa3df545d1da848922c13de2a87fc9" args="(const integer &amp;n, callback_t callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int boost::xint::is_prime </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests an integer for primality. </p>
<ul>
<li>Complexity: Varies</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to test. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <code>n</code> seems to be prime, 0 if it isn't, or -1 if the provided callback function cancelled the operation.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>n</code> is less than 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the Rabin-Miller probabilistic primality test. There is an infinitesimally small chance that it will think that a composite number is actually prime, but that is so small that it can be ignored for most practical purposes. If even that chance is too much, you can run this function over the number several times, it will use different random "witness" numbers each time.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad581832932a4816cbc9f24740732c3a0"></a><!-- doxytag: member="boost::xint::is_prime" ref="ad581832932a4816cbc9f24740732c3a0" args="(const nothrow_integer &amp;n, callback_t callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int boost::xint::is_prime </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tests an integer for primality. <ul>
<li>Complexity: Varies</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The number to test. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <code>n</code> seems to be prime, 0 if it isn't, or -1 if the provided callback function cancelled the operation.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>n</code> is less than 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the Rabin-Miller probabilistic primality test. There is an infinitesimally small chance that it will think that a composite number is actually prime, but that is so small that it can be ignored for most practical purposes. If even that chance is too much, you can run this function over the number several times, it will use different random "witness" numbers each time.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns -1 instead of throwing. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e4bf24a99b565005d75630de66c5316"></a><!-- doxytag: member="boost::xint::lcm" ref="a4e4bf24a99b565005d75630de66c5316" args="(const fixed_integer&lt; Bits &gt; &amp;num1, const fixed_integer&lt; Bits &gt; &amp;num2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::lcm </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the Least Common Multiple of two integers. <ul>
<li>Complexity: O((log n)<sup>3</sup> + n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The least common multiple of the two integers. If either integer is zero, then the return value will be zero, by convention; in all other cases, the return value will be a positive number. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00808">808</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8782636245af4772735f6e7510a7d3da"></a><!-- doxytag: member="boost::xint::lcm" ref="a8782636245af4772735f6e7510a7d3da" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::lcm </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the Least Common Multiple of two integers. <ul>
<li>Complexity: O((log n)<sup>3</sup> + n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The least common multiple of the two integers. If either integer is zero, then the return value will be zero, by convention; in all other cases, the return value will be a positive number. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a0096ae57d50e4fe8b5413ea7a4e60495"></a><!-- doxytag: member="boost::xint::lcm" ref="a0096ae57d50e4fe8b5413ea7a4e60495" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::lcm </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the Least Common Multiple of two integers. </p>
<ul>
<li>Complexity: O((log n)<sup>3</sup> + n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num1,num2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The least common multiple of the two integers. If either integer is zero, then the return value will be zero, by convention; in all other cases, the return value will be a positive number. </dd></dl>

</div>
</div>
<a class="anchor" id="a206fbae1c02ec96cb274aae1ad611da7"></a><!-- doxytag: member="boost::xint::log2" ref="a206fbae1c02ec96cb274aae1ad611da7" args="(const nothrow_integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::log2 </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the log<sub>2</sub> value of an integer. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer log<sub>2</sub> value of the integer.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#af710e4b39cfa66096c202f17d12cc7b7" title="Calculate the value of 2e">pow2</a>(log2(n)-1) will give you an integer with the highest set bit of <code>n</code>, assuming that <code>n</code> is non-zero.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Similar to the <a class="el" href="namespaceboost_1_1xint.html#aec002c076eff13d0382c5d2cd6de1d60" title="Obtains the index of the highest bit in an integer with a value of one.">highestbit</a> function. </dd></dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns 0 instead of throwing. </dd></dl>

</div>
</div>
<a class="anchor" id="a080731f708e62fc429687bf450f36fa2"></a><!-- doxytag: member="boost::xint::log2" ref="a080731f708e62fc429687bf450f36fa2" args="(const fixed_integer_any &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::log2 </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the log<sub>2</sub> value of an integer. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer log<sub>2</sub> value of the integer.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#af710e4b39cfa66096c202f17d12cc7b7" title="Calculate the value of 2e">pow2</a>(log2(n)-1) will give you an integer with the highest set bit of <code>n</code>, assuming that <code>n</code> is non-zero.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Similar to the <a class="el" href="namespaceboost_1_1xint.html#aec002c076eff13d0382c5d2cd6de1d60" title="Obtains the index of the highest bit in an integer with a value of one.">highestbit</a> function. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a0cd277cd7a80cda764f889781f0140cd"></a><!-- doxytag: member="boost::xint::log2" ref="a0cd277cd7a80cda764f889781f0140cd" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::log2 </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the log<sub>2</sub> value of an integer. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer log<sub>2</sub> value of the integer.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#af710e4b39cfa66096c202f17d12cc7b7" title="Calculate the value of 2e">pow2</a>(log2(n)-1) will give you an integer with the highest set bit of <code>n</code>, assuming that <code>n</code> is non-zero.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Similar to the <a class="el" href="namespaceboost_1_1xint.html#aec002c076eff13d0382c5d2cd6de1d60" title="Obtains the index of the highest bit in an integer with a value of one.">highestbit</a> function. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d7bfe0c5806902b377df0934f027f38"></a><!-- doxytag: member="boost::xint::lowestbit" ref="a6d7bfe0c5806902b377df0934f027f38" args="(const fixed_integer&lt; Bits &gt; &amp;n, size_t valueIfZero)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::lowestbit </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>valueIfZero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Obtains the index of the lowest bit in an integer with a value of one. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>valueIfZero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the lowest one-bit in the integer, or <code>valueIfZero</code> if the integer contains no set bits. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00672">672</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09477129544d4bdb08ddd63644683f5c"></a><!-- doxytag: member="boost::xint::lowestbit" ref="a09477129544d4bdb08ddd63644683f5c" args="(const nothrow_integer &amp;n, size_t valueIfZero)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::lowestbit </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>valueIfZero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Obtains the index of the lowest bit in an integer with a value of one. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>valueIfZero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the lowest one-bit in the integer, or <code>valueIfZero</code> if the integer contains no set bits. </dd></dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns zero instead of throwing. </dd></dl>

</div>
</div>
<a class="anchor" id="a783e728f8221cd424d6f7f5d5f67ec40"></a><!-- doxytag: member="boost::xint::lowestbit" ref="a783e728f8221cd424d6f7f5d5f67ec40" args="(const integer &amp;n, size_t valueIfZero)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t boost::xint::lowestbit </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>valueIfZero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtains the index of the lowest bit in an integer with a value of one. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>valueIfZero</em>&nbsp;</td><td>The value to return if <code>n</code> is zero (as there is no correct answer in that case).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the lowest one-bit in the integer, or <code>valueIfZero</code> if the integer contains no set bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a30c0cd9ad317c1a373cdc059b6f81cb9"></a><!-- doxytag: member="boost::xint::mod" ref="a30c0cd9ad317c1a373cdc059b6f81cb9" args="(const fixed_integer&lt; Bits &gt; &amp;n, const fixed_integer&lt; Bits &gt; &amp;modBy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::mod </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>modBy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00735">735</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af91fe435810928b98d6e2b36ea4c3b53"></a><!-- doxytag: member="boost::xint::mod" ref="af91fe435810928b98d6e2b36ea4c3b53" args="(const nothrow_integer &amp;n, const nothrow_integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::mod </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the remainder after dividing a number by another. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The dividend. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>n</code> % <code>m</code>. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a9b8c31b64eb9700beea8b95edec31a73"></a><!-- doxytag: member="boost::xint::mod" ref="a9b8c31b64eb9700beea8b95edec31a73" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::mod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the remainder after dividing a number by another. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The dividend. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The divisor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>n</code> % <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6dd657413c395d346e59b282aa6138d8"></a><!-- doxytag: member="boost::xint::mulmod" ref="a6dd657413c395d346e59b282aa6138d8" args="(const fixed_integer&lt; Bits &gt; &amp;n, const fixed_integer&lt; Bits &gt; &amp;by, const fixed_integer&lt; Bits &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::mulmod </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the modular product of two integers. <ul>
<li>Complexity: O(2n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to multiply. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>n</code> * <code>by</code> % <code>m</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00745">745</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3deaa6f8a44d454129bb06691a6035c7"></a><!-- doxytag: member="boost::xint::mulmod" ref="a3deaa6f8a44d454129bb06691a6035c7" args="(const nothrow_integer &amp;n, const nothrow_integer &amp;by, const nothrow_integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::mulmod </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the modular product of two integers. <ul>
<li>Complexity: O(2n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to multiply. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>n</code> * <code>by</code> % <code>m</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ac9af74aa79d9cc7f51c57cc7707824ba"></a><!-- doxytag: member="boost::xint::mulmod" ref="ac9af74aa79d9cc7f51c57cc7707824ba" args="(const integer &amp;n, const integer &amp;by, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::mulmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular product of two integers. </p>
<ul>
<li>Complexity: O(2n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to multiply. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>n</code> * <code>by</code> % <code>m</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a548d944523cfc7c22823014bb6dcb6"></a><!-- doxytag: member="boost::xint::multiply" ref="a6a548d944523cfc7c22823014bb6dcb6" args="(const fixed_integer&lt; Bits &gt; &amp;n, const fixed_integer&lt; Bits &gt; &amp;by)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::multiply </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the product of two integers. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The product of the parameters.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Automatically uses the more-efficient squaring algorithm if it can trivially detect that the two parameters are copies of the same number. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00551">551</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e0d6ad947fa3e979ed6e26d7e81ab7f"></a><!-- doxytag: member="boost::xint::multiply" ref="a9e0d6ad947fa3e979ed6e26d7e81ab7f" args="(const integer &amp;n, const integer &amp;by)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::multiply </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the product of two integers. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The product of the parameters.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Automatically uses the more-efficient squaring algorithm if it can trivially detect that the two parameters are copies of the same number. </dd></dl>

</div>
</div>
<a class="anchor" id="af844548a421cfc751133081b334dbe4b"></a><!-- doxytag: member="boost::xint::multiply" ref="af844548a421cfc751133081b334dbe4b" args="(const nothrow_integer &amp;n, const nothrow_integer &amp;by)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::multiply </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the product of two integers. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,by</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The product of the parameters.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Automatically uses the more-efficient squaring algorithm if it can trivially detect that the two parameters are copies of the same number. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ade2e4d02cf0aa413f7e6f4d943ca341d"></a><!-- doxytag: member="boost::xint::negate" ref="ade2e4d02cf0aa413f7e6f4d943ca341d" args="(const fixed_integer&lt; Bits &gt; &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::negate </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the additive inverse of an integer. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>-n</code>. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00523">523</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84190f7b286de191e8026e440f104731"></a><!-- doxytag: member="boost::xint::negate" ref="a84190f7b286de191e8026e440f104731" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::negate </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the additive inverse of an integer. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>-n</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aedc1654de47ce6d6635e5339b236f94d"></a><!-- doxytag: member="boost::xint::negate" ref="aedc1654de47ce6d6635e5339b236f94d" args="(const nothrow_integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::negate </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the additive inverse of an integer. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>-n</code>. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a0098148e09b3c1fb2aed15dc9badc7c6"></a><!-- doxytag: member="boost::xint::nothrow_factorial" ref="a0098148e09b3c1fb2aed15dc9badc7c6" args="(size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::nothrow_factorial </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the value of <code>n!</code> <ul>
<li>Complexity: O(n<sup>3</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> factorial, defined as <code>1*2*3*...*n</code></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Factorials get ridiculously huge, even with fairly small values of <code>n</code>. This function, when used with a large parameter, is the easiest way to exhaust the system's memory. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ad7e6b2629b12014d16bbc7b2383d72cd"></a><!-- doxytag: member="boost::xint::nothrow_from_binary" ref="ad7e6b2629b12014d16bbc7b2383d72cd" args="(const xint::binary_t &amp;b, size_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::nothrow_from_binary </td>
          <td>(</td>
          <td class="paramtype">const xint::binary_t &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a portable binary representation of a number into an integer. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b</em>&nbsp;</td><td>An <code><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a></code> containing the bytes to convert, lowest byte first. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The number of bits packed into each character (for portability with systems that might not have characters with the same number of bits), or zero (the default) to assume the number of bits in the current system's unsigned character type.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>bits</code> is greater than the number of bits in an unsigned character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer representing the bytes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#a61303b2b007d23cc8c9b7450c848c14d" title="Creates a binary representation of an integer.">xint::to_binary</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ae40f9a912e985490d7291d56e597a464"></a><!-- doxytag: member="boost::xint::nothrow_from_string" ref="ae40f9a912e985490d7291d56e597a464" args="(const std::string &amp;str, size_t base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::nothrow_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a string to an integer. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>str</em>&nbsp;</td><td>The string to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>the base that the string representation of the number is in. This can be any number between 2 and 36 (inclusive). It can also be the constant <a class="el" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">xint::autobase</a>, in which case the function will follow the standard C/C++ rules for interpreting a numeric constant: any number with a zero as the first digit is assumed to be base-8; any number with a leading zero-x or zero-X (such as 0x1f) is base-16, and anything else is base-10.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer with the numeric value of the string in base <code>base</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1overflow__error.html">exceptions::overflow_error</a></em>&nbsp;</td><td>if there is not enough free memory to create the integer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__base.html">exceptions::invalid_base</a></em>&nbsp;</td><td>if the base parameter is not between 2 and 36 (inclusive) or the constant <a class="el" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">xint::autobase</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__digit.html">exceptions::invalid_digit</a></em>&nbsp;</td><td>if the string contains any digit that cannot be part of a number in the specified base, or if there are no valid digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when reading an integer from a stream, or when contructing one from a string. </dd></dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the string is <code>#NaN#</code>, then it will return <a class="el" href="nan.html">Not-a-Number</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dd5b57bcf282d01f39cddf425418287"></a><!-- doxytag: member="boost::xint::nothrow_pow2" ref="a7dd5b57bcf282d01f39cddf425418287" args="(size_t e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::nothrow_pow2 </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the value of 2<sup>e</sup> <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>The exponent to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>2 to the power of <code>e</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a convenience function, to help with self-documenting code. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a1b55b4b192aa6abc491e3ed8c5ef2627"></a><!-- doxytag: member="boost::xint::nothrow_random_by_size" ref="a1b55b4b192aa6abc491e3ed8c5ef2627" args="(size_t bits, bool high_bit_on, bool low_bit_on, bool can_be_negative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::nothrow_random_by_size </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>high_bit_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>low_bit_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>can_be_negative</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates a random integer with specific attributes. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The maximum number of bits that you want the returned number to have. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>high_bit_on</em>&nbsp;</td><td>If <code>true</code>, the returned number will have exactly the requested size. If <code>false</code>, the upper bits may be zero, resulting in a number that is slightly smaller than requested. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>low_bit_on</em>&nbsp;</td><td>If <code>true</code>, the returned number will always be odd. If <code>false</code>, it has an equal chance of being odd or even. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>can_be_negative</em>&nbsp;</td><td>If <code>true</code>, the returned value has an equal chance of being positive or negative. If <code>false</code>, it will always be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A random integer with the requested attributes.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the currently-defined random generator.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="random.html">The XInt Random Number System</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#ae64e3e8c8da2f0a1cb7064d1775fbf54" title="Change the random generator that the library uses.">xint::set_random_generator</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="aed98791058e6a589b06f8015ae0acaef"></a><!-- doxytag: member="boost::xint::nothrow_random_prime" ref="aed98791058e6a589b06f8015ae0acaef" args="(size_t size_in_bits, callback_t callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::nothrow_random_prime </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size_in_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a randomly-generated prime number of a particular bit-size. <ul>
<li>Complexity: Varies</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size_in_bits</em>&nbsp;</td><td>The number of bits that you want the returned value to have. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A randomly-generated prime integer with the specified number of bits, or zero if the provided callback function cancelled the operation.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>size_in_bits</code> is less than two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function uses <a class="el" href="namespaceboost_1_1xint.html#ad581832932a4816cbc9f24740732c3a0">xint::is_prime</a>. See the description of it for details of its limitations.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>It also uses the library's currently-set random number generator. See the <a class="el" href="random.html">Random Number Functions page</a> for details on its limitations and requirements, and how to get cryptographically-secure random numbers.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a43189615a1bfb4904c969efe846cefc6"></a><!-- doxytag: member="boost::xint::operator!=" ref="a43189615a1bfb4904c969efe846cefc6" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator!= </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad85d78b5be317ed9a3cfa512953fa800"></a><!-- doxytag: member="boost::xint::operator!=" ref="ad85d78b5be317ed9a3cfa512953fa800" args="(const fixed_integer_any &amp;num1, const fixed_integer_any &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator!= </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5d5cb8db57fd0247aa4e36d9b25c492"></a><!-- doxytag: member="boost::xint::operator!=" ref="ac5d5cb8db57fd0247aa4e36d9b25c492" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator!= </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a115e84b56b4e5e00d0b2b5c8a407ef97"></a><!-- doxytag: member="boost::xint::operator%" ref="a115e84b56b4e5e00d0b2b5c8a407ef97" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::operator% </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2261cdd3b6c689b76cc379ac515e5d45"></a><!-- doxytag: member="boost::xint::operator%" ref="a2261cdd3b6c689b76cc379ac515e5d45" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::operator% </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab054d123a003a31c06bac92a1f325805"></a><!-- doxytag: member="boost::xint::operator&amp;" ref="ab054d123a003a31c06bac92a1f325805" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a97db617d1b8d73ca35c8ef41ec7e9a31"></a><!-- doxytag: member="boost::xint::operator&amp;" ref="a97db617d1b8d73ca35c8ef41ec7e9a31" args="(const nothrow_integer &amp;n1, const nothrow_integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae3770c0e356d50b5f3e2be573e6100cd"></a><!-- doxytag: member="boost::xint::operator*" ref="ae3770c0e356d50b5f3e2be573e6100cd" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::operator* </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aadeb3206628bdfd3112db2d80fff7c92"></a><!-- doxytag: member="boost::xint::operator*" ref="aadeb3206628bdfd3112db2d80fff7c92" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::operator* </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f6171689ef68ff6672e43a1e24ea494"></a><!-- doxytag: member="boost::xint::operator+" ref="a0f6171689ef68ff6672e43a1e24ea494" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::operator+ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a69d186688f404f1608663142da86158c"></a><!-- doxytag: member="boost::xint::operator+" ref="a69d186688f404f1608663142da86158c" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::operator+ </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac16aa971521ae015a62ec015f1fe56d0"></a><!-- doxytag: member="boost::xint::operator&#45;" ref="ac16aa971521ae015a62ec015f1fe56d0" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::operator- </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a92ee4f1138215a36f4374a356fa5a359"></a><!-- doxytag: member="boost::xint::operator&#45;" ref="a92ee4f1138215a36f4374a356fa5a359" args="(const integer &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::operator- </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="operators_8cpp_source.html#l00022">22</a> of file <a class="el" href="operators_8cpp_source.html">operators.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad51e8e59ad1ff61dcdd462bf9d8acf08"></a><!-- doxytag: member="boost::xint::operator&#45;" ref="ad51e8e59ad1ff61dcdd462bf9d8acf08" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::operator- </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a2859e7b5e532eaa0cc51aba4f958c2"></a><!-- doxytag: member="boost::xint::operator/" ref="a9a2859e7b5e532eaa0cc51aba4f958c2" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::operator/ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a83d07bf51fce0b4644b2190278c30413"></a><!-- doxytag: member="boost::xint::operator/" ref="a83d07bf51fce0b4644b2190278c30413" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::operator/ </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aab98cd20fa3761900de197363bac0fcb"></a><!-- doxytag: member="boost::xint::operator&lt;" ref="aab98cd20fa3761900de197363bac0fcb" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad6104aaba26d6b8d801cce276f154fe8"></a><!-- doxytag: member="boost::xint::operator&lt;" ref="ad6104aaba26d6b8d801cce276f154fe8" args="(const fixed_integer_any &amp;num1, const fixed_integer_any &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af845afe18e9b1326d630e5c0696e679d"></a><!-- doxytag: member="boost::xint::operator&lt;" ref="af845afe18e9b1326d630e5c0696e679d" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b7b76c7fb4b03cf086773a55604d6a2"></a><!-- doxytag: member="boost::xint::operator&lt;&lt;" ref="a4b7b76c7fb4b03cf086773a55604d6a2" args="(std::basic_ostream&lt; charT, traits &gt; &amp;out, const nothrow_integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;charT,traits&gt;&amp; boost::xint::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nothrow__integer_8hpp_source.html#l00320">320</a> of file <a class="el" href="nothrow__integer_8hpp_source.html">nothrow_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d1a90f08d8ad3547627f2c2590ab20d"></a><!-- doxytag: member="boost::xint::operator&lt;&lt;" ref="a8d1a90f08d8ad3547627f2c2590ab20d" args="(std::basic_ostream&lt; charT, traits &gt; &amp;out, const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;charT,traits&gt;&amp; boost::xint::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l00277">277</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7188dd65026fde2ae4a690d55ef7b648"></a><!-- doxytag: member="boost::xint::operator&lt;&lt;" ref="a7188dd65026fde2ae4a690d55ef7b648" args="(std::basic_ostream&lt; charT, traits &gt; &amp;out, const fixed_integer&lt; Bits &gt; &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits , size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;charT,traits&gt;&amp; boost::xint::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00819">819</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a72cb95a5e25a310215eaa2cc93349f"></a><!-- doxytag: member="boost::xint::operator&lt;=" ref="a8a72cb95a5e25a310215eaa2cc93349f" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a40319361b76e6c7fea92867ea76695c2"></a><!-- doxytag: member="boost::xint::operator&lt;=" ref="a40319361b76e6c7fea92867ea76695c2" args="(const fixed_integer_any &amp;num1, const fixed_integer_any &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7749bff2e150c55649324ba9797aa6d0"></a><!-- doxytag: member="boost::xint::operator&lt;=" ref="a7749bff2e150c55649324ba9797aa6d0" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="accccaec2c2a8ccfadfc559adbb7ff6ed"></a><!-- doxytag: member="boost::xint::operator==" ref="accccaec2c2a8ccfadfc559adbb7ff6ed" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator== </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ecc233f5b5f1fc24a7aa9bab3868c2c"></a><!-- doxytag: member="boost::xint::operator==" ref="a1ecc233f5b5f1fc24a7aa9bab3868c2c" args="(const fixed_integer_any &amp;num1, const fixed_integer_any &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator== </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a66b558cce023df7b3e10ee22dfe653d0"></a><!-- doxytag: member="boost::xint::operator==" ref="a66b558cce023df7b3e10ee22dfe653d0" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator== </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a002b54ae65c6c265d773e7b491bd90fb"></a><!-- doxytag: member="boost::xint::operator&gt;" ref="a002b54ae65c6c265d773e7b491bd90fb" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac04d99142bc67642325ac524a8523f63"></a><!-- doxytag: member="boost::xint::operator&gt;" ref="ac04d99142bc67642325ac524a8523f63" args="(const fixed_integer_any &amp;num1, const fixed_integer_any &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab09672bca82a7f4fbdca4443492210bc"></a><!-- doxytag: member="boost::xint::operator&gt;" ref="ab09672bca82a7f4fbdca4443492210bc" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e213ecd798c6bc331460dff13b35173"></a><!-- doxytag: member="boost::xint::operator&gt;=" ref="a2e213ecd798c6bc331460dff13b35173" args="(const nothrow_integer &amp;num1, const nothrow_integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af6fd110351f7aebd589bd482eab3696a"></a><!-- doxytag: member="boost::xint::operator&gt;=" ref="af6fd110351f7aebd589bd482eab3696a" args="(const fixed_integer_any &amp;num1, const fixed_integer_any &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ace7bde7533ff9d8a3f38978e7bb046"></a><!-- doxytag: member="boost::xint::operator&gt;=" ref="a1ace7bde7533ff9d8a3f38978e7bb046" args="(const integer &amp;num1, const integer &amp;num2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>num2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a01075dbe629f0b3bd58d4d18fce80637"></a><!-- doxytag: member="boost::xint::operator&gt;&gt;" ref="a01075dbe629f0b3bd58d4d18fce80637" args="(std::basic_istream&lt; charT, traits &gt; &amp;in, nothrow_integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;charT,traits&gt;&amp; boost::xint::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nothrow__integer_8hpp_source.html#l00332">332</a> of file <a class="el" href="nothrow__integer_8hpp_source.html">nothrow_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a5967ac54c1a269f0b4ed555391ca4f"></a><!-- doxytag: member="boost::xint::operator&gt;&gt;" ref="a3a5967ac54c1a269f0b4ed555391ca4f" args="(std::basic_istream&lt; charT, traits &gt; &amp;in, integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;charT,traits&gt;&amp; boost::xint::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l00284">284</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab027908e04b71c8be33172768c6a2f67"></a><!-- doxytag: member="boost::xint::operator&gt;&gt;" ref="ab027908e04b71c8be33172768c6a2f67" args="(std::basic_istream&lt; charT, traits &gt; &amp;in, fixed_integer&lt; Bits &gt; &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename charT , typename traits , size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;charT,traits&gt;&amp; boost::xint::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; charT, traits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00826">826</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9524e5e34757cb10a146012bc4192643"></a><!-- doxytag: member="boost::xint::operator^" ref="a9524e5e34757cb10a146012bc4192643" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::operator^ </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b27999f391ede4a2ec60ee83e6e5060"></a><!-- doxytag: member="boost::xint::operator^" ref="a2b27999f391ede4a2ec60ee83e6e5060" args="(const nothrow_integer &amp;n1, const nothrow_integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::operator^ </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4896e1fc3c8d0adb4911cf5b78304f49"></a><!-- doxytag: member="boost::xint::operator|" ref="a4896e1fc3c8d0adb4911cf5b78304f49" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::operator| </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1b86fdde7f84fbcbe39cec5ecc0bc8c"></a><!-- doxytag: member="boost::xint::operator|" ref="ae1b86fdde7f84fbcbe39cec5ecc0bc8c" args="(const nothrow_integer &amp;n1, const nothrow_integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::operator| </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0492c49fda91b5f498074d3f812906dd"></a><!-- doxytag: member="boost::xint::opt_secure_mode" ref="a0492c49fda91b5f498074d3f812906dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::opt_secure_mode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the library was compiled with <a class="el" href="securemode.html">Secure Mode </a> enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if Secure Mode is active, <code>false</code> if it isn't. </dd></dl>

</div>
</div>
<a class="anchor" id="ac80750e62d5ffa2484332aae4b23d379"></a><!-- doxytag: member="boost::xint::opt_thread_safe" ref="ac80750e62d5ffa2484332aae4b23d379" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::xint::opt_thread_safe </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the library was compiled with the <a class="el" href="threadsafe.html">Thread Safe Operation option </a> enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if it was compiled with Thread Safe Operation enabled, <code>false</code> if it wasn't. </dd></dl>

</div>
</div>
<a class="anchor" id="ae92b86a29007f48749f17d54f36f469a"></a><!-- doxytag: member="boost::xint::pow" ref="ae92b86a29007f48749f17d54f36f469a" args="(const fixed_integer&lt; Bits &gt; &amp;n, const fixed_integer_any &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::pow </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the value of n<sup>e</sup> <ul>
<li>Complexity: O(n<sub>n</sub><sup>2</sup>n<sub>e</sub>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,e</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> to the power of <code>e</code>. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00590">590</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7d7b30f587c98ad31b8d421b8813c61"></a><!-- doxytag: member="boost::xint::pow" ref="aa7d7b30f587c98ad31b8d421b8813c61" args="(const integer &amp;n, const integer &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::pow </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of n<sup>e</sup> </p>
<ul>
<li>Complexity: O(n<sub>n</sub><sup>2</sup>n<sub>e</sub>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,e</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> to the power of <code>e</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f73207284ff1f32b20fb8a6a7a82649"></a><!-- doxytag: member="boost::xint::pow" ref="a7f73207284ff1f32b20fb8a6a7a82649" args="(const nothrow_integer &amp;n, const nothrow_integer &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::pow </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the value of n<sup>e</sup> <ul>
<li>Complexity: O(n<sub>n</sub><sup>2</sup>n<sub>e</sub>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n,e</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> to the power of <code>e</code>. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="af710e4b39cfa66096c202f17d12cc7b7"></a><!-- doxytag: member="boost::xint::pow2" ref="af710e4b39cfa66096c202f17d12cc7b7" args="(size_t e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::pow2 </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of 2<sup>e</sup> </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>The exponent to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>2 to the power of <code>e</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is a convenience function, to help with self-documenting code. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f97bd640a2e3a45313fd1893dc854e3"></a><!-- doxytag: member="boost::xint::powmod" ref="a8f97bd640a2e3a45313fd1893dc854e3" args="(const fixed_integer&lt; Bits &gt; &amp;n, const fixed_integer&lt; Bits &gt; &amp;e, const fixed_integer&lt; Bits &gt; &amp;m, bool noMontgomery)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::powmod </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>noMontgomery</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the result of <code>n<sup>e</sup></code> % <code>m</code>, keeping the intermediate results (relatively) small. <ul>
<li>Complexity: O(n<sub>n</sub><sup>2</sup>n<sub>e</sub>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to exponentiate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>The exponent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>noMontgomery</em>&nbsp;</td><td>Used for testing, leave false for normal operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>pow</code>(n, <code>exponent</code>) % <code>modulus</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__modulus.html">exceptions::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Because this function keeps the intermediate results small, it is far faster and uses far less memory than a naive implementation.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition, this function will use the Montgomery Reduction internally, if the modulus is an odd number (and if <code>noMontgomery</code> isn't set), which is almost always faster than the non-Montgomery method. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00761">761</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0d4bbcf5391accad798da207180894e"></a><!-- doxytag: member="boost::xint::powmod" ref="aa0d4bbcf5391accad798da207180894e" args="(const nothrow_integer &amp;n, const nothrow_integer &amp;e, const nothrow_integer &amp;m, bool noMontgomery)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::powmod </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>noMontgomery</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the result of <code>n<sup>e</sup></code> % <code>m</code>, keeping the intermediate results (relatively) small. <ul>
<li>Complexity: O(n<sub>n</sub><sup>2</sup>n<sub>e</sub>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to exponentiate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>The exponent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>noMontgomery</em>&nbsp;</td><td>Used for testing, leave false for normal operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>pow</code>(n, <code>exponent</code>) % <code>modulus</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__modulus.html">exceptions::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Because this function keeps the intermediate results small, it is far faster and uses far less memory than a naive implementation.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition, this function will use the Montgomery Reduction internally, if the modulus is an odd number (and if <code>noMontgomery</code> isn't set), which is almost always faster than the non-Montgomery method. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a35e7556e9f2d8fb944dbf732ed3f96cd"></a><!-- doxytag: member="boost::xint::powmod" ref="a35e7556e9f2d8fb944dbf732ed3f96cd" args="(const integer &amp;n, const integer &amp;e, const integer &amp;m, bool noMontgomery)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::powmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>noMontgomery</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the result of <code>n<sup>e</sup></code> % <code>m</code>, keeping the intermediate results (relatively) small. </p>
<ul>
<li>Complexity: O(n<sub>n</sub><sup>2</sup>n<sub>e</sub>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to exponentiate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td>The exponent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>noMontgomery</em>&nbsp;</td><td>Used for testing, leave false for normal operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>pow</code>(n, <code>exponent</code>) % <code>modulus</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__modulus.html">exceptions::invalid_modulus</a></em>&nbsp;</td><td>if the modulus is less than one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Because this function keeps the intermediate results small, it is far faster and uses far less memory than a naive implementation.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition, this function will use the Montgomery Reduction internally, if the modulus is an odd number (and if <code>noMontgomery</code> isn't set), which is almost always faster than the non-Montgomery method. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8d879e19a6608b21184236e00806be5"></a><!-- doxytag: member="boost::xint::random_by_size" ref="ac8d879e19a6608b21184236e00806be5" args="(size_t bits, bool high_bit_on, bool low_bit_on, bool can_be_negative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::random_by_size </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>high_bit_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>low_bit_on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>can_be_negative</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates a random integer with specific attributes. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The maximum number of bits that you want the returned number to have. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>high_bit_on</em>&nbsp;</td><td>If <code>true</code>, the returned number will have exactly the requested size. If <code>false</code>, the upper bits may be zero, resulting in a number that is slightly smaller than requested. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>low_bit_on</em>&nbsp;</td><td>If <code>true</code>, the returned number will always be odd. If <code>false</code>, it has an equal chance of being odd or even. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>can_be_negative</em>&nbsp;</td><td>If <code>true</code>, the returned value has an equal chance of being positive or negative. If <code>false</code>, it will always be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A random integer with the requested attributes.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function uses the currently-defined random generator.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="random.html">The XInt Random Number System</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#ae64e3e8c8da2f0a1cb7064d1775fbf54" title="Change the random generator that the library uses.">xint::set_random_generator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaf58d56e1a47ac55e0aa97a55e6fb2c9"></a><!-- doxytag: member="boost::xint::random_prime" ref="aaf58d56e1a47ac55e0aa97a55e6fb2c9" args="(size_t size_in_bits, callback_t callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::random_prime </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size_in_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callback_t&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a randomly-generated prime number of a particular bit-size. </p>
<ul>
<li>Complexity: Varies</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size_in_bits</em>&nbsp;</td><td>The number of bits that you want the returned value to have. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>An optional function that will be called regularly during the operation. If it returns <code>false</code>, the function will immediately return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A randomly-generated prime integer with the specified number of bits, or zero if the provided callback function cancelled the operation.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>size_in_bits</code> is less than two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function uses <a class="el" href="namespaceboost_1_1xint.html#ad581832932a4816cbc9f24740732c3a0">xint::is_prime</a>. See the description of it for details of its limitations.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>It also uses the library's currently-set random number generator. See the <a class="el" href="random.html">Random Number Functions page</a> for details on its limitations and requirements, and how to get cryptographically-secure random numbers.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="primes.html">Generating Prime Numbers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae64e3e8c8da2f0a1cb7064d1775fbf54"></a><!-- doxytag: member="boost::xint::set_random_generator" ref="ae64e3e8c8da2f0a1cb7064d1775fbf54" args="(T *gen)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail void boost::xint::set_random_generator </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>gen</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the random generator that the library uses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gen</em>&nbsp;</td><td>A pointer to the new generator to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The generator must be a heap-allocated pointer (one created with <code>new</code>), which the XInt library assumes ownership of. Don't pass in a stack-created item, don't try to delete the item that you passed in, and don't attempt to use it separately after passing it to this function, or the behavior is undefined.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>See the <a class="el" href="random.html">Random Number page</a> for an example of how to use it. </dd></dl>

<p>Definition at line <a class="el" href="random_8hpp_source.html#l00105">105</a> of file <a class="el" href="random_8hpp_source.html">random.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf72216ae1986d06d4f39c27cada42d6"></a><!-- doxytag: member="boost::xint::setbit" ref="aaf72216ae1986d06d4f39c27cada42d6" args="(fixed_integer&lt; Bits &gt; &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::setbit </td>
          <td>(</td>
          <td class="paramtype">fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets a specific bit in an integer to one. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00660">660</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac76235b31dcadded8193443b78743948"></a><!-- doxytag: member="boost::xint::setbit" ref="ac76235b31dcadded8193443b78743948" args="(nothrow_integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::setbit </td>
          <td>(</td>
          <td class="paramtype">nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets a specific bit in an integer to one. <ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a6278915cf51b0d448a9db40031226182"></a><!-- doxytag: member="boost::xint::setbit" ref="a6278915cf51b0d448a9db40031226182" args="(integer &amp;n, size_t bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::setbit </td>
          <td>(</td>
          <td class="paramtype">integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a specific bit in an integer to one. </p>
<ul>
<li>Complexity: O(1)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bit</em>&nbsp;</td><td>The zero-based index of the bit to change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a24944978923b67b2547c0f7245e4d7b9"></a><!-- doxytag: member="boost::xint::shift" ref="a24944978923b67b2547c0f7245e4d7b9" args="(const fixed_integer&lt; Bits &gt; &amp;n, int byBits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::shift </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bit-shift an integer, in either direction. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to shift it. If positive, it will shift left, negative will shift right.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00714">714</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad62ca08dc3d7600eee872dc5a95c338c"></a><!-- doxytag: member="boost::xint::shift" ref="ad62ca08dc3d7600eee872dc5a95c338c" args="(const nothrow_integer &amp;n, int byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::shift </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bit-shift an integer, in either direction. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to shift it. If positive, it will shift left, negative will shift right.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="aaed048f3dc3a442152ebffa3f721d014"></a><!-- doxytag: member="boost::xint::shift" ref="aaed048f3dc3a442152ebffa3f721d014" args="(const integer &amp;n, int byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::shift </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit-shift an integer, in either direction. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to shift it. If positive, it will shift left, negative will shift right.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b096bd6583148b84b5f8020dfad4865"></a><!-- doxytag: member="boost::xint::shift_left" ref="a1b096bd6583148b84b5f8020dfad4865" args="(const fixed_integer&lt; Bits &gt; &amp;n, size_t byBits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::shift_left </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Left-shift an integer by a specified number of bits. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to left-shift it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00720">720</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4bc41e443d230352f7c099e60f4056f4"></a><!-- doxytag: member="boost::xint::shift_left" ref="a4bc41e443d230352f7c099e60f4056f4" args="(const nothrow_integer &amp;n, size_t byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::shift_left </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Left-shift an integer by a specified number of bits. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to left-shift it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ae22c3492ecf08370a9a972c8d6fb8e96"></a><!-- doxytag: member="boost::xint::shift_left" ref="ae22c3492ecf08370a9a972c8d6fb8e96" args="(const integer &amp;n, size_t byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::shift_left </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Left-shift an integer by a specified number of bits. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to left-shift it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>

</div>
</div>
<a class="anchor" id="aa01c60a4f969a7df6368f5c82695824c"></a><!-- doxytag: member="boost::xint::shift_right" ref="aa01c60a4f969a7df6368f5c82695824c" args="(const fixed_integer&lt; Bits &gt; &amp;n, size_t byBits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::shift_right </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Right-shift an integer by a specified number of bits. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to right-shift it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00728">728</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a295196e5fa8931578d27468cb5154f07"></a><!-- doxytag: member="boost::xint::shift_right" ref="a295196e5fa8931578d27468cb5154f07" args="(const nothrow_integer &amp;n, size_t byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::shift_right </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Right-shift an integer by a specified number of bits. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to right-shift it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="aca7453fa9e276ebefacc9827b55f69d2"></a><!-- doxytag: member="boost::xint::shift_right" ref="aca7453fa9e276ebefacc9827b55f69d2" args="(const integer &amp;n, size_t byBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::shift_right </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>byBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Right-shift an integer by a specified number of bits. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byBits</em>&nbsp;</td><td>The number of bits to right-shift it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit-shifted integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a041e980b0d5d3f48cd94bec1fb6d42a5"></a><!-- doxytag: member="boost::xint::sqr" ref="a041e980b0d5d3f48cd94bec1fb6d42a5" args="(const fixed_integer&lt; Bits &gt; &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::sqr </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the value of n<sup>2</sup> <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> times <code>n</code>.</dd></dl>
<p>This function uses a faster algorithm than the standard multiplication one.  </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00582">582</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbba1eeb86e4e7610a75afbb89d594e3"></a><!-- doxytag: member="boost::xint::sqr" ref="afbba1eeb86e4e7610a75afbb89d594e3" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::sqr </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the value of n<sup>2</sup> </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> times <code>n</code>.</dd></dl>
<p>This function uses a faster algorithm than the standard multiplication one. </p>

</div>
</div>
<a class="anchor" id="a83ce32006b45117f9b3dc6c673fc9f01"></a><!-- doxytag: member="boost::xint::sqr" ref="a83ce32006b45117f9b3dc6c673fc9f01" args="(const nothrow_integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::sqr </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the value of n<sup>2</sup> <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>n</code> times <code>n</code>.</dd></dl>
<p>This function uses a faster algorithm than the standard multiplication one.  </p>

</div>
</div>
<a class="anchor" id="a35ff2132479ee8c99dd8017af679828e"></a><!-- doxytag: member="boost::xint::sqrmod" ref="a35ff2132479ee8c99dd8017af679828e" args="(const fixed_integer&lt; Bits &gt; &amp;n, const fixed_integer&lt; Bits &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::sqrmod </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the modular product of squaring an integer. <ul>
<li>Complexity: O(2n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to square. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>sqr(n)</code> % <code>m</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00753">753</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae64aa02c6217ea9f53f25d4f44ddddd1"></a><!-- doxytag: member="boost::xint::sqrmod" ref="ae64aa02c6217ea9f53f25d4f44ddddd1" args="(const nothrow_integer &amp;n, const nothrow_integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::sqrmod </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the modular product of squaring an integer. <ul>
<li>Complexity: O(2n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to square. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>sqr(n)</code> % <code>m</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="adb9a9cb117e7346a3b56c369cd438b0e"></a><!-- doxytag: member="boost::xint::sqrmod" ref="adb9a9cb117e7346a3b56c369cd438b0e" args="(const integer &amp;n, const integer &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::sqrmod </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the modular product of squaring an integer. </p>
<ul>
<li>Complexity: O(2n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to square. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>The modulus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result of <code>sqr(n)</code> % <code>m</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is purely a convenience function, to make it easier to write self-documenting code. It does not provide any additional efficiency over writing out the calculation. </dd></dl>

</div>
</div>
<a class="anchor" id="a7516b17b5c54a012c9dbdc9a45e2142b"></a><!-- doxytag: member="boost::xint::sqrt" ref="a7516b17b5c54a012c9dbdc9a45e2142b" args="(const fixed_integer&lt; Bits &gt; &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::sqrt </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the square root of <code>an</code> integer. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The largest integer that, when squared, is less than or equal to <code>n</code>. If <code>n</code> is not a perfect square, then this value will not be the exact square root.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1cannot__represent.html">exceptions::cannot_represent</a></em>&nbsp;</td><td>if <code>n</code> is negative. </td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00616">616</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afdf79cc57e434b9c7f4cb3b6bd68dbd6"></a><!-- doxytag: member="boost::xint::sqrt" ref="afdf79cc57e434b9c7f4cb3b6bd68dbd6" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::sqrt </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the square root of <code>an</code> integer. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The largest integer that, when squared, is less than or equal to <code>n</code>. If <code>n</code> is not a perfect square, then this value will not be the exact square root.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1cannot__represent.html">exceptions::cannot_represent</a></em>&nbsp;</td><td>if <code>n</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0825d8d9d4644df8d9b6922f5b0d7064"></a><!-- doxytag: member="boost::xint::sqrt" ref="a0825d8d9d4644df8d9b6922f5b0d7064" args="(const nothrow_integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::sqrt </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the square root of <code>an</code> integer. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The value to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The largest integer that, when squared, is less than or equal to <code>n</code>. If <code>n</code> is not a perfect square, then this value will not be the exact square root.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1cannot__represent.html">exceptions::cannot_represent</a></em>&nbsp;</td><td>if <code>n</code> is negative. </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="a218c0f1ddaaa8c978b3f84219ef712d2"></a><!-- doxytag: member="boost::xint::subtract" ref="a218c0f1ddaaa8c978b3f84219ef712d2" args="(const fixed_integer&lt; Bits &gt; &amp;n1, const fixed_integer&lt; Bits &gt; &amp;n2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1fixed__integer.html">fixed_integer</a>&lt; Bits &gt; boost::xint::subtract </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the difference between two integers. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The difference between the parameters. </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00541">541</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86eb0099596fe66bd46be244323f44e5"></a><!-- doxytag: member="boost::xint::subtract" ref="a86eb0099596fe66bd46be244323f44e5" args="(const integer &amp;n1, const integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1integer.html">integer</a> boost::xint::subtract </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the difference between two integers. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The difference between the parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a385b3869d8dcceab2ffb68ff33c95062"></a><!-- doxytag: member="boost::xint::subtract" ref="a385b3869d8dcceab2ffb68ff33c95062" args="(const nothrow_integer &amp;n1, const nothrow_integer &amp;n2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1xint_1_1nothrow__integer.html">nothrow_integer</a> boost::xint::subtract </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the difference between two integers. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n1,n2</em>&nbsp;</td><td>The integers to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The difference between the parameters. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a27c1978abf1c401febe61285e8a3af0b"></a><!-- doxytag: member="boost::xint::swap" ref="a27c1978abf1c401febe61285e8a3af0b" args="(nothrow_integer &amp;left, nothrow_integer &amp;right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::swap </td>
          <td>(</td>
          <td class="paramtype">nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="nothrow__integer_8hpp_source.html#l00359">359</a> of file <a class="el" href="nothrow__integer_8hpp_source.html">nothrow_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7832686d860601f27625d42b7532639e"></a><!-- doxytag: member="boost::xint::swap" ref="a7832686d860601f27625d42b7532639e" args="(integer &amp;left, integer &amp;right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::swap </td>
          <td>(</td>
          <td class="paramtype">integer &amp;&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer &amp;&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l00291">291</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f5d22465d4dab8985c13479ec0e5e79"></a><!-- doxytag: member="boost::xint::swap" ref="a7f5d22465d4dab8985c13479ec0e5e79" args="(fixed_integer&lt; Bits &gt; &amp;left, fixed_integer&lt; Bits &gt; &amp;right)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void boost::xint::swap </td>
          <td>(</td>
          <td class="paramtype">fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00837">837</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad8a1d63acfebbbdfce1047c966682a93"></a><!-- doxytag: member="boost::xint::to" ref="ad8a1d63acfebbbdfce1047c966682a93" args="(const nothrow_integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T boost::xint::to </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently converts from an <a class="el" href="classboost_1_1xint_1_1integer.html" title="The core integer class.">xint::integer</a> to a built-in integer type. <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>The type to convert it to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The numeric value of <code>n</code>, converted to the specified type.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1too__big.html">exceptions::too_big</a></em>&nbsp;</td><td>if <code>n</code> would not fit into the specified type. </td></tr>
  </table>
  </dd>
</dl>
 </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns T(0) instead of throwing. </dd></dl>

<p>Definition at line <a class="el" href="nothrow__integer_8hpp_source.html#l00309">309</a> of file <a class="el" href="nothrow__integer_8hpp_source.html">nothrow_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae90546b0cb6cf2f27fc5ce65bb43a21e"></a><!-- doxytag: member="boost::xint::to" ref="ae90546b0cb6cf2f27fc5ce65bb43a21e" args="(const integer &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T boost::xint::to </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Efficiently converts from an <a class="el" href="classboost_1_1xint_1_1integer.html" title="The core integer class.">xint::integer</a> to a built-in integer type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>The type to convert it to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The numeric value of <code>n</code>, converted to the specified type.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1too__big.html">exceptions::too_big</a></em>&nbsp;</td><td>if <code>n</code> would not fit into the specified type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="integer_8hpp_source.html#l00270">270</a> of file <a class="el" href="integer_8hpp_source.html">integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2078ed71644ee71a1ce2e616d28e5baa"></a><!-- doxytag: member="boost::xint::to" ref="a2078ed71644ee71a1ce2e616d28e5baa" args="(const fixed_integer&lt; Bits &gt; &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T boost::xint::to </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer&lt; Bits &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently converts from an <a class="el" href="classboost_1_1xint_1_1integer.html" title="The core integer class.">xint::integer</a> to a built-in integer type. <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>The type to convert it to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The numeric value of <code>n</code>, converted to the specified type.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1too__big.html">exceptions::too_big</a></em>&nbsp;</td><td>if <code>n</code> would not fit into the specified type. </td></tr>
  </table>
  </dd>
</dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00624">624</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2691e17588d7a0bb6614d5bdeb66cd4c"></a><!-- doxytag: member="boost::xint::to_binary" ref="a2691e17588d7a0bb6614d5bdeb66cd4c" args="(const fixed_integer_any &amp;n, size_t bits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Bits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a> boost::xint::to_binary </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a binary representation of an integer. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The number of bits to pack into each character (for portability with systems that might not have characters with the same number of bits), or zero (the default) to assume the number of bits in the current system's unsigned character type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a></code> containing the binary representation, lowest byte first.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>bits</code> is greater than the number of bits in an unsigned character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function only stores the absolute value of <code>n</code>; if you need the sign, you must store it separately.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A binary representation is sometimes used for persistent storage or transmission, as it is more space-efficient than a string representation.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#a4ac395fda0e4553da82a8e967e188280" title="Converts a portable binary representation of a number into an integer.">xint::from_binary</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#af792bffef18de798c1b37be425baaa61">xint::fixed_from_binary</a> </dd></dl>
 </p>

<p>Definition at line <a class="el" href="fixed__integer_8hpp_source.html#l00638">638</a> of file <a class="el" href="fixed__integer_8hpp_source.html">fixed_integer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6b8b0fa807a6a216314af2b4bcca45d"></a><!-- doxytag: member="boost::xint::to_binary" ref="ac6b8b0fa807a6a216314af2b4bcca45d" args="(const nothrow_integer &amp;n, size_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a> boost::xint::to_binary </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a binary representation of an integer. <ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The number of bits to pack into each character (for portability with systems that might not have characters with the same number of bits), or zero (the default) to assume the number of bits in the current system's unsigned character type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a></code> containing the binary representation, lowest byte first.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>bits</code> is greater than the number of bits in an unsigned character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function only stores the absolute value of <code>n</code>; if you need the sign, you must store it separately.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A binary representation is sometimes used for persistent storage or transmission, as it is more space-efficient than a string representation.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#a4ac395fda0e4553da82a8e967e188280" title="Converts a portable binary representation of a number into an integer.">xint::from_binary</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#af792bffef18de798c1b37be425baaa61">xint::fixed_from_binary</a> </dd></dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns an empty <a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a> instead of throwing. </dd></dl>

</div>
</div>
<a class="anchor" id="a61303b2b007d23cc8c9b7450c848c14d"></a><!-- doxytag: member="boost::xint::to_binary" ref="a61303b2b007d23cc8c9b7450c848c14d" args="(const integer &amp;n, size_t bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a> boost::xint::to_binary </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a binary representation of an integer. </p>
<ul>
<li>Complexity: O(n)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bits</em>&nbsp;</td><td>The number of bits to pack into each character (for portability with systems that might not have characters with the same number of bits), or zero (the default) to assume the number of bits in the current system's unsigned character type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code><a class="el" href="namespaceboost_1_1xint.html#aae3128529370506165793f2771834e58">xint::binary_t</a></code> containing the binary representation, lowest byte first.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__argument.html">exceptions::invalid_argument</a></em>&nbsp;</td><td>if <code>bits</code> is greater than the number of bits in an unsigned character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function only stores the absolute value of <code>n</code>; if you need the sign, you must store it separately.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>A binary representation is sometimes used for persistent storage or transmission, as it is more space-efficient than a string representation.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#a4ac395fda0e4553da82a8e967e188280" title="Converts a portable binary representation of a number into an integer.">xint::from_binary</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#af792bffef18de798c1b37be425baaa61">xint::fixed_from_binary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a41f8922f3a2328a3c8f0d50264643ca7"></a><!-- doxytag: member="boost::xint::to_string" ref="a41f8922f3a2328a3c8f0d50264643ca7" args="(const nothrow_integer &amp;n, size_t base, bool uppercase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string boost::xint::to_string </td>
          <td>(</td>
          <td class="paramtype">const nothrow_integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>uppercase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a string representation of the specified integer. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>The base, between 2 and 36 inclusive, to convert it to. Defaults to base 10. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uppercase</em>&nbsp;</td><td>Whether to make alphabetic characters (for bases greater than ten) uppercase or not. Defaults to <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string value of <code>n</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__base.html">exceptions::invalid_base</a></em>&nbsp;</td><td>if base is less than two or greater than 36.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when you ask the library to write an integer to a stream, but it's more flexible because you can specify any base between 2 and 36. (Streams only allow base-8, base-10, or base-16.) </dd></dl>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Returns an empty std::string instead of throwing.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <code>n</code> is Not-a-Number, returns the string <code>#NaN#</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a185dd459850bfd588a4a9b3c67e8c09c"></a><!-- doxytag: member="boost::xint::to_string" ref="a185dd459850bfd588a4a9b3c67e8c09c" args="(const fixed_integer_any &amp;n, size_t base, bool uppercase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string boost::xint::to_string </td>
          <td>(</td>
          <td class="paramtype">const fixed_integer_any &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>uppercase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a string representation of the specified integer. <ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>The base, between 2 and 36 inclusive, to convert it to. Defaults to base 10. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uppercase</em>&nbsp;</td><td>Whether to make alphabetic characters (for bases greater than ten) uppercase or not. Defaults to <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string value of <code>n</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__base.html">exceptions::invalid_base</a></em>&nbsp;</td><td>if base is less than two or greater than 36.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when you ask the library to write an integer to a stream, but it's more flexible because you can specify any base between 2 and 36. (Streams only allow base-8, base-10, or base-16.) </dd></dl>
</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ac0454fdc47e70a493c7bf5d92dda33d4"></a><!-- doxytag: member="boost::xint::to_string" ref="ac0454fdc47e70a493c7bf5d92dda33d4" args="(const integer &amp;n, size_t base, bool uppercase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string boost::xint::to_string </td>
          <td>(</td>
          <td class="paramtype">const integer &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>uppercase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a string representation of the specified integer. </p>
<ul>
<li>Complexity: O(n<sup>2</sup>)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>n</em>&nbsp;</td><td>The integer to convert. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>base</em>&nbsp;</td><td>The base, between 2 and 36 inclusive, to convert it to. Defaults to base 10. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uppercase</em>&nbsp;</td><td>Whether to make alphabetic characters (for bases greater than ten) uppercase or not. Defaults to <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string value of <code>n</code>.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classboost_1_1xint_1_1exceptions_1_1invalid__base.html">exceptions::invalid_base</a></em>&nbsp;</td><td>if base is less than two or greater than 36.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the function that's called when you ask the library to write an integer to a stream, but it's more flexible because you can specify any base between 2 and 36. (Streams only allow base-8, base-10, or base-16.) </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a086ec65a0273dccedca0fbfbddb03398"></a><!-- doxytag: member="boost::xint::autobase" ref="a086ec65a0273dccedca0fbfbddb03398" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="namespaceboost_1_1xint.html#a086ec65a0273dccedca0fbfbddb03398">boost::xint::autobase</a> = (std::numeric_limits&lt;size_t&gt;::max)()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A value that can be used for the 'base' parameter of the string-to-integer functions </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classboost_1_1xint_1_1integer.html#a179df60f5dc32f98b9f564ec20aff5a8" title="Create an integer from a string representation.">xint::integer::integer(const std::string&amp; str, size_t base)</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#af263105e57d48eff5fe14d4d03ca10e1" title="Converts a string to an integer.">xint::from_string</a> </dd></dl>

<p>Definition at line <a class="el" href="internals_8hpp_source.html#l00100">100</a> of file <a class="el" href="internals_8hpp_source.html">internals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a758d415a476a5eeed28dc6b5869b1696"></a><!-- doxytag: member="boost::xint::no_callback" ref="a758d415a476a5eeed28dc6b5869b1696" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceboost_1_1xint.html#a48deb76c9c428a4b3a50177b1b0cb547">callback_t</a> <a class="el" href="namespaceboost_1_1xint.html#a758d415a476a5eeed28dc6b5869b1696">boost::xint::no_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An empty callback_t, used as a default parameter for some functions. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceboost_1_1xint.html#ad581832932a4816cbc9f24740732c3a0">xint::is_prime</a> </dd>
<dd>
<a class="el" href="namespaceboost_1_1xint.html#aaf58d56e1a47ac55e0aa97a55e6fb2c9" title="Generate a randomly-generated prime number of a particular bit-size.">xint::random_prime</a> </dd></dl>

<p>Definition at line <a class="el" href="internals_8hpp_source.html#l00095">95</a> of file <a class="el" href="internals_8hpp_source.html">internals.hpp</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sun May 2 18:42:51 2010 for The Extended Integer (XInt) Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
