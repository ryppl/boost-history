[section:tti_metafunctions Nested Type Metafunctions]

The nested type metafunctions parallel the macro metafunctions but more easily allow 
nested types to be used without compiler errors and without needing to use the 
T::InnerType notation for nested types.

For each of these metafunctions the first parameter is the class template of its corresponding macro metafunction 
and the remaining parameter are 'types'. These 'types' always consist first of the enclosing type and then 
possibly other types which make up the signature of whatever inner element we are introspecting. Each of these
'types' is passed as a nullary metafunction whose typedef 'type' is the actual type.

For a type which is in scope, we can always use 
boost::mpl::identity to create our nullary metafunction, and there can never be a compiler error for
such known types as long as such declarations for them exist. For nested types, which may or may not 
exist, we can pass the result of TTI\_MEMBER\_TYPE or its equivalent 
nested type metafunction tti::mf\_member\_type ( explained later ).

To use these metafunctions you need to include the main header file 'TTIntrospection.hpp',
unless otherwise noted.

[tip The header file <boost/mpl/identity.hpp> is included by the TTI header files so you need not 
manually include it in order to use boost::mpl::identity to wrap a known type as a nullary 
metafunction for the nested type metafunctions.]

A table of these metafunctions is given, based on the inner element whose 
existence the metaprogrammer is introspecting. A more detailed explanation can be found 
in the reference section, and examples of usage can be found in the 
[link sectti_usingNTM "Using the Nested Type Metafunctions"] section.
All of the metafunctions are in the top-level 'tti' namespace,
all have a particular name based on the type of its functionality, and all begin with the prefix 
'mf_' so as not to conflict with the macro metafunction names generated by the library.

[table:tbmetafunctions TTI Metafunctions
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Macro Equivalent]
  ]
  [
    [Type]
    [
    [classref tti::mf_has_type]
    ]
    [
    template<class,class = unspecified type> class HasType
    
    = generated macro metafunction
    
    class T = enclosing type nullary metafunction
    ]
    [TTI\_HAS\_TYPE]
  ]
  [
    [Type with check]
    [
    [classref tti::mf_has_type]
    ]
    [
    template<class,class = unspecified type> class HasType
    
    = generated macro metafunction
    
    class T = enclosing type nullary metafunction
    
    class U = type to check against nullary metafunction
    ]
    [TTI\_HAS\_TYPE]
  ]
  [
    [Class Template]
    [
    [classref tti::mf_has_template]
    ]
    [
    template<class> class HasTemplate
    
    = generated macro metafunction
    
    class T = enclosing type nullary metafunction
    ]
    [TTI\_HAS\_TEMPLATE]
  ]
  [
    [Class Template with params]
    [
    [classref tti::mf_has_template_check_params]
    ]
    [
    template<class> class HasTemplateCheckParams
    
    = generated macro metafunction
    
    class T = enclosing type nullary metafunction
    ]
    [
    TTI\_HAS\_TEMPLATE\_CHECK\_PARAMS
    
    TTI\_VM\_HAS\_TEMPLATE\_CHECK\_PARAMS
    ]
  ]
  [
    [Member data]
    [
    [classref tti::mf_has_member_data]
    ]
    [
    template<class> class HasMember
    
    = generated macro metafunction
    
    class T = enclosing type nullary metafunction
    
    class R = type of member data nullary Metafunction
    ]
    [TTI\_HAS\_MEMBER]
  ]
  [
    [Member function]
    [
    [classref tti::mf_has_member_function]
    ]
    [
    template<class> class HasMember
    
    = generated macro metafunction
    
    class T = enclosing type nullary metafunction
    
    class R = return value nullary metafunction
    
    class Types... = parameter types as nullary metafunctions
    ]
    [TTI\_HAS\_MEMBER]
  ]
  [
    [Static data]
    [
    [classref tti::mf_has_static_data]
    ]
    [
    template<class,class> class HasStaticMember
    
    = generated macro metafunction
    
    class T = enclosing type nullary metafunction
    
    class R = type of static data nullary metafunction
    ]
    [TTI\_HAS\_STATIC\_MEMBER]
  ]
  [
    [Static function]
    [
    [classref tti::mf_has_static_function]
    ]
    [
    template<class,class> class HasStaticMember
    
    = generated macro metafunction
    
    class T = enclosing type nullary metafunction
    
    class R = return value nullary metafunction
    
    class Types... = parameter types as nullary metafunctions
    ]
    [TTI\_HAS\_STATIC\_MEMBER]
  ]
]

Other than the use of all types as nullary metafunctions, one other difference
in the nested type metafunctions from their macro metafunction counterparts is 
that the signature for member functions, member data, and static member functions 
is broken down into individual types, rather than the combined type notation which 
the macro metafunctions use. This allows us to specify nested types 
in those signatures without using the T::InnerType notation. One can even take our 
nested types and create new types from them.

[heading Nested type metafunction member_type equivalent]

Just as there is the macro TTI\_MEMBER\_TYPE for creating 
a macro metafunction which returns a nested type if it exists, else an unspecified 
type, there is also the equivalent metafunction.

[table:tbmetanested TTI Nested Type Metafunction
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Macro Equivalent]
  ]
  [
    [Type]
    [
    [classref tti::mf_member_type]
    ]
    [
    template<class> class MemberType
    
    = generated macro metafunction
    
    class T = enclosing type nullary metafunction
    ]
    [TTI\_MEMBER\_TYPE]
  ]
]

The use of this metafunction allows us to created deeply nested types, 
which may or may not exist, as nullary metafunctions in much the same way
that TTI\_MEMBER\_TYPE can. The difference is 
the simpler syntax when using mf\_member\_type.

As an example, given the theoretical relationship of types we used before:

 struct T
   {
   struct AType
     {
     struct BType
       {
       struct CType
         {
         struct FindType
           {
           };
         }
       };
     };
   };
  
We can use mf_member_type as follows. First we create our corresponding macro metafunctions:

 TTI_MEMBER_TYPE(FindType)
 TTI_MEMBER_TYPE(AType)
 TTI_MEMBER_TYPE(BType)
 TTI_MEMBER_TYPE(CType)

Next we can create a typedef to reflect a nested type called FindType which has the relationship
as specified above by instantiating using mf_member_type.

 typedef
 tti::mf_member_type
   <
   tti::member_type_FindType,
   tti::mf_member_type
     <
     tti::member_type_CType,
     tti::mf_member_type
       <
       tti::member_type_BType,
       tti::member_type_AType
         <
         T
         >
       >
     >
   > MyFindType;
  
The nested type created can be used with the other nested type metafunctions above. 
The key information above is that the enclosing type is a nullary metafunction, 
which means that the enclosing type can be specified as the result 
of using TTI\_MEMBER\_TYPE as well as the 
result of using mf\_member\_type itself. Both techniques are shown in the example 
above, and the same technique for creating nested types as nullary metafunctions 
can be used with the other functionality of the nested type metafunctions when 
nested types are needed as 'types'.

In our next section we will look at examples of nested type metafunction use.

[endsect]
