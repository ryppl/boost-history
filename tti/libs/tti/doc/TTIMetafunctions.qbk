[section:tti_metafunctions Nullary Type Metafunctions]

The macro metafunctions provide a complete set of functionality for 
anything one would like to do using the TTI library. Why then do we 
have another set of parallel functionality as nullary type metafunctions ?

The nullary type metafunctions parallel those macro metafunctions in which types are specified
individually rather than in a composite manner. The individual types are passed to the nullary 
type metafunctions as nullary metafunctions, hence the name of this group of metafunctions.
They more easily allow a syntax where nested types can be specified without needing to manually 
reach into the 'type' member of TTI\_MEMBER\_TYPE or the 'type' member of its nullary type 
metafunction equivalent called tti::mf\_member\_type.

In a very real way the nullary type metafunctions exist just to provide syntactic improvements
over the macro metafunctions and are not needed to use the library, since all of the library 
functionality is already provided with the macro metafunctions. Nonetheless syntactic ease of use 
is a very real goal of the TTI library and therefore these metafunctions are provided to allow 
that syntactic improvement.

The nullary type metafunctions reuse the metafunctions generated by the macro metafunctions.
To do this the result of a corresponding macro metafunction needs to be passed as metadata to a given 
nullary metafunction.
  
A lambda expression, in the form of a metafunction class or a placeholder expression, is passed as the 
first parameter to our nullary type metafunctions. We have already seen how the TTI library supplies
metafunction classes through the use of metafunction class macros for each of the macro metafunctions. 
The end-user can use these metafunction classes directly, or can use placeholder expressions with the 
metafunctions generated by the macro metafunctions.

The remaining parameters are 'types'. These 'types' always consist first of the enclosing type and then 
possibly other types which make up the signature of whatever inner element we are introspecting. Each of these
'types' is passed as a nullary metafunction whose typedef 'type' is the actual type.

The only exception to this use of nullary type metafunctions when specifying 'types' is when a Boost 
function_types tag type, which is optional, is specified as an addition to the function signature. 
Also when dealing with a function signature and parameter types being passed, while the 
parameter 'types' themselves are in the form of nullary metafunctions, the MPL forward sequence 
which contains the parameter 'types' is a plain type and should not be wrapped as a nullary metafunction.

For a type which is in scope, we can always use 
boost::mpl::identity to create our nullary metafunction, and there can never be a compiler error for
such known types as long as declarations for them exist or it is a built-in C++ type. 
For nested types, which may or may not exist, we can pass the result of TTI\_MEMBER\_TYPE 
or its equivalent nullary type metafunction tti::mf\_member\_type ( explained later ).

To use these metafunctions you need to include the main header file 'tti.hpp',
unless otherwise noted.

[tip The header file <boost/mpl/identity.hpp> is included by the TTI header files so you need not 
manually include it in order to use boost::mpl::identity to wrap a known type as a nullary 
metafunction for the nullary type metafunctions. Also the header file <boost/mpl/vector.hpp> is 
included by the main TTI header file 'tti.hpp' so if you use an MPL vector as your 
forward sequence wrapper for parameter types, you need not manually include the header file. Finally
the header file <boost/mpl/placeholders.hpp> is also included by 'tti.hpp' so you need
not manually include it yourself in order to use placeholder expressions.]

A table of these metafunctions is given, based on the inner element whose 
existence the metaprogrammer is introspecting. A more detailed explanation can be found 
in the reference section, and examples of usage can be found in the 
[link sectti_usingNTM "Using the Nullary Type Metafunctions"] section.
All of the metafunctions are in the top-level 'tti' namespace,
all have a particular name based on the type of its functionality, and all begin with the prefix 
'mf_' so as not to conflict with the macro metafunction names generated by the library.

[table:tbmetafunctions TTI Nullary Type Metafunctions
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Macro Equivalent]
  ]
  [
    [Type]
    [
    [classref tti::mf_has_type]
    ]
    [
    class HasType = macro metafunction as lambda expression 
    
    class T = enclosing type nullary metafunction
    ]
    [TTI\_HAS\_TYPE]
  ]
  [
    [Type with check]
    [
    [classref tti::mf_has_type]
    ]
    [
    class HasType = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class U = type to check against nullary metafunction
    ]
    [TTI\_HAS\_TYPE]
  ]
  [
    [Class Template]
    [
    [classref tti::mf_has_template]
    ]
    [
    class HasTemplate = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [TTI\_HAS\_TEMPLATE]
  ]
  [
    [Class Template with params]
    [
    [classref tti::mf_has_template_check_params]
    ]
    [
    class HasTemplateCheckParams = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [
    TTI\_HAS\_TEMPLATE\_CHECK\_PARAMS
    
    TTI\_VM\_HAS\_TEMPLATE\_CHECK\_PARAMS
    ]
  ]
  [
    [Member data]
    [
    [classref tti::mf_has_member_data]
    ]
    [
    class HasMemberData = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = type of member data nullary Metafunction
    ]
    [TTI\_HAS\_MEMBER\_DATA]
  ]
  [
    [Member function]
    [
    [classref tti::mf_has_member_function]
    ]
    [
    class HasMemberFunction = macro metafunction as lambda expression
    
    class T   = enclosing type nullary metafunction
    
    class R   = return value nullary metafunction
    
    class FS  = (optional) a Boost MPL forward sequence of parameter types as nullary metafunctions.
                The forward sequence as a type is not presented as a nullary metafunction.
                If there are no parameters, this may be omitted.
                
    class TAG = (optional) a Boost function_types tag type.
    ]
    [TTI\_HAS\_MEMBER\_FUNCTION]
  ]
  [
    [Static data]
    [
    [classref tti::mf_has_static_data]
    ]
    [
    class HasStaticMember = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = type of static data nullary metafunction
    ]
    [TTI\_HAS\_STATIC\_MEMBER]
  ]
  [
    [Static function]
    [
    [classref tti::mf_has_static_member_function]
    ]
    [
    class HasStaticMemberFunction = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = return value nullary metafunction
    
    class FS  = (optional) a Boost MPL forward sequence of parameter types as nullary metafunctions.
                The forward sequence as a type is not presented as a nullary metafunction.
                If there are no parameters, this may be omitted.
                
    class TAG = (optional) a Boost function_types tag type.
    ]
    [TTI\_HAS\_STATIC\_MEMBER\_FUNCTION]
  ]
]

Other than the use of nearly all types as nullary metafunctions, one other difference
in the nullary type metafunctions from their macro metafunction counterparts is 
that the signature for member functions, member data, and static member functions 
always involves individual types rather than the combined type notation which 
some of the macro metafunctions use. This allows us to specify nested types 
in those signatures without using the T::InnerType notation.

[heading Nullary type metafunction member_type equivalent]

Just as there is the macro TTI\_MEMBER\_TYPE for creating 
a macro metafunction which returns a nested type if it exists, else an unspecified 
type, there is also the equivalent nullary type metafunction.

[table:tbmetanested TTI Nested Type Nullary Type Metafunction
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Macro Equivalent]
  ]
  [
    [Type]
    [
    [classref tti::mf_member_type]
    ]
    [
    class MemberType = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [TTI\_MEMBER\_TYPE]
  ]
]

The difference between the macro metafunction TTI\_MEMBER\_TYPE and  
tti::mf\_member\_type is simply that, like the other nullary type metafunctions,
the latter takes its enclosing type as a nullary metafunction. Both produce the 
exact same result.

The use of this metafunction allows us to created deeply nested types, 
which may or may not exist, as nullary metafunctions in much the same way
that TTI\_MEMBER\_TYPE can. The difference is 
the simpler syntax when using tti::mf\_member\_type.

As an example, given the theoretical relationship of types we used before:

 struct T
   {
   struct AType
     {
     struct BType
       {
       struct CType
         {
         struct FindType
           {
           };
         }
       };
     };
   };
  
We can use tti::mf_member_type as follows. First we create our corresponding macro metafunctions:

 TTI_MEMBER_TYPE(FindType)
 TTI_MEMBER_TYPE(AType)
 TTI_MEMBER_TYPE(BType)
 TTI_MEMBER_TYPE(CType)

Next we can create a typedef to reflect a nested type called FindType, as a nullary metafunction, 
which has the relationship as specified above by using tti::mf\_member\_type.

 typedef
 tti::mf_member_type
   <
   tti::member_type_FindType<_>,
   tti::mf_member_type
     <
     tti::member_type_CType<_>,
     tti::mf_member_type
       <
       tti::member_type_BType<_>,
       tti::member_type_AType
         <
         T
         >
       >
     >
   > MyFindType;
  
The nested type created can be used with the other nullary type metafunctions above. 
The key information above is that the enclosing type, as in all of the nullary type 
metafunctions, is a nullary metafunction itself, 
which means that the enclosing type can be specified as the result 
of using TTI\_MEMBER\_TYPE as well as the 
result of using mf\_member\_type itself. 

Both techniques are shown in the example 
above, and the same technique for creating nested types as nullary metafunctions 
can be used with the other functionality of the nullary type metafunctions when 
nested types are needed as 'types'.

Also similar to the macro metafunctions, we have an easy way of testing whether or not 
our tti::mf_member_type nested type actually exists.

[table:existtbmetanested TTI Nested Type Nullary Type Metafunction Existence
  [
    [Inner Element]
    [Template]
    [Parameters]
  ]
  [
    [Type]
    [
    [classref tti::mf_valid_member_type]
    ]
    [
    class T = a type as a nullary metafunction
    
    returns = true if the nullary metafunction's inner 'type' exists, false if it does not.
              'Existence' is determined by whether the type does not equal an unspecified type.
    ]
  ]
]

Again note the difference here from the equivalent macro metafunction tti::valid\_member\_type.
In the example above the type T is passed as a nullary metafunction holding the actual type, 
where for the macro metafunction equivalent the type T is passed as the actual type being tested.

In our next section we will look at examples of nullary type metafunction use.

[endsect]
