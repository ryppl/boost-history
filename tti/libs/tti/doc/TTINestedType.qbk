[section:tti_nested_type Nested Types]

[heading The Problem]

The goal of the TTI library is never to produce a compiler error by just 
using the functionality in the library, whether it is invoking its function-like macros 
or instantiating the metafunctions created by them. In this sense The TTI library macros 
for querying an enclosing type for an inner element work very well, except in one general case.
That general case is the crux of the discussion regarding nested types which follows, 
and explains the reason for the separate group of TTI metafunctions which mirror the 
functionality of the macros and their generated metafunctions.

The metafunctions generated by the TTI macros all work with types, whether in specifying
an enclosing type or in specifying the type of some inner element. The C++ notation for
a nested type, given an enclosing type 'E' and an inner type 'I', is 'E::I'. If either the 
enclosing type 'E' does not exist, or the inner type 'I' does not exist within 'E', the expression 
'E::I' will give a compiler error if we attempt to use it in our template instantiation
of one of TTI's macro metafunctions. We want to be able to query for the existence of inner 
elements to an enclosing type without producing compiler errors. Of course if we absolutely 
know what types we have and that a nested type exists we can always use an expression like 
E::I without error, or even E::I::AnotherInnerType as we drill down further into nested types.
But this is often not the case when doing template programming since the type being 
passed to us at compile-time in a class or function template is chosen at instantiation 
time.

One solution to this is afforded by the library itself. Given an enclosing type 'E' 
which we know must exist, either because it is a top-level type we know about or 
it is passed to us in some template as a 'class E' or 'typename E', and given an inner type 
named 'I' whose existence we would like ascertain, we can use a TTI_HAS_TYPE(I) macro and it's related 
tti::has_type_I metafunction to determine if the nested type 'I' exists. This solution is perfectly valid 
and, with Boost MPL's selection metafunctions, we can do compile-time selection to generate the 
correct template code. 

However this does not scale that well syntactically if we need to drill down further from a 
top-level enclosing type to a deeply nested type. We are going to be generating a great deal 
of boost::mpl::if_ and/or boost::mpl::eval_if type selection statements to get to some 
final condition where we know we can generate the compile-time code which we want.

[heading The Solution]

The TTI library offers a better solution in the form of a set of constructs which work with 
nested types without producing a compiler error if the nested type does not exist, but still 
are able to do the querying for inner elements that our TTI macro metafunctions do.

We have already seen one of those constructs, the macro TTI_MEMBER_TYPE 
( and equivalent TTI_TRAIT_MEMBER_TYPE ), which generates a metafunction based on the name 
of an inner type. But instead of telling us whether that inner type exists it instead returns
a typedef 'type' which is that inner type if it exists, else it is an unspecified type if it 
does not. In this way we have created a metafunction, very similar in functionality to 
boost::mpl::identity, but which still returns some marker 'type' if our nested type is invalid.

The remaining metafunctions in the TTI library use this concept of a nested type which does 
not exist not producing a compiler error to query the same things that our macro metafunctions 
do, but without having to use the notation 'E::I' to express a nested type. 

For each of these metafunctions the first class template parameter is its corresponding macro metafunction 
template and the remaining parameter are 'types', which always consists first of the enclosing type and then 
possibly other types which make up the signature of whatever inner element we are querying. The most important 
thing to understand about these 'types' is that they are passed in the form of a nullary metafunction 
whose typedef 'type' is the actual type. This lets us pass not only the result of 
TTI_MEMBER_TYPE ( TTI_TRAIT_MEMBER_TYPE ) as one of the 'types', which may not actually exist, but also 
the result of its equivalent metafunction, tti::mf_member_type ( explained later ). For a type not 
generated by either the TTI_MEMBER_TYPE ( TTI_TRAIT_MEMBER_TYPE ) macro metafunction or tti::mf_member_type 
metafunction, and therefore exists in our scope, we can use boost::mpl::identity to create our 
nullary metafunction.

[tip The header file <boost/mpl/identity.hpp> is included by the TTI main header file TTIntrospection.hpp
so you need not manually include it in order to use boost::mpl::identity to wrap a known type as a nullary
metafunction for the TTI metafunctions.]

[endsect]
