<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>General Functionality</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.0">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.3">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.3">
<link rel="prev" href="tti_terminology.html" title="Terminology">
<link rel="next" href="tti_detail.html" title="Macro Metafunctions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_terminology.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_detail.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="the_type_traits_introspection_library.tti_functionality"></a><a class="link" href="tti_functionality.html" title="General Functionality">General
    Functionality</a>
</h2></div></div></div>
<p>
      The elements about which a template metaprogrammer might be interested in finding
      out at compile time about a type are:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          Does it have a nested type with a particular name ?
        </li>
<li class="listitem">
          Does it have a nested type with a particular name which is a typedef for
          a particular type ?
        </li>
<li class="listitem">
          Does it have a nested class template with a particular name ?
        </li>
<li class="listitem">
          Does it have a nested class template with a particular name and a particular
          signature ?
        </li>
<li class="listitem">
          Does it have a member function with a particular name and a particular
          signature ?
        </li>
<li class="listitem">
          Does it have a member data with a particular name and of a particular type
          ?
        </li>
<li class="listitem">
          Does it have a static member function with a particular name and a particular
          signature ?
        </li>
<li class="listitem">
          Does it have a static member data with a particular name and of a particular
          type ?
        </li>
</ul></div>
<p>
      These are the compile-time questions which the TTI library answers.
    </p>
<p>
      All of the questions above attempt to find an answer about an inner element
      with a particular name. In order to do this using template metaprogramming,
      macros are used so that the name of the inner element can be passed to the
      macro. The macro will then generate an appropriate metafunction, which the
      template metaprogrammer can then use to introspect the information that is
      needed. The name itself of the inner element is always passed to the macro
      as a macro parameter, but other macro parameters may also be needed in some
      cases.
    </p>
<p>
      All of the macros start with the prefix TTI_, create their metafunctions in
      a top-level namespace called 'tti', and come in two forms:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          In the simplest form the 'name' of the inner element is used directly to
          generate the name of the metafunction as well as serving as the 'name'
          to introspect. To generate the name of the metafunction the 'name' is appended
          to the name of the macro, with the TTI_ prefix removed, a final underscore
          added, and the macro part of the name in lower case. As an example, for
          the macro TTI_HAS_TYPE(MyType) the name of the metafunction is 'tti::has_type_MyType'
          and it will look for an inner type called 'MyType'.
        </li>
<li class="listitem">
          In the slightly more complicated form, which I call the complex form, the
          macro starts with TTI_TRAIT_ and a 'trait' name is passed as the first
          parameter, with the 'name' of the inner element as the second parameter.
          The 'trait' name serves only to completely name the metafunction in the
          tti namespace. As an example, for the macro TTI_TRAIT_HAS_TYPE(MyTrait,MyType)
          the name of the metafunction is 'tti::MyTrait' and it will look for an
          inner type called 'MyType'. Every macro has a corresponding complex form.
        </li>
</ol></div>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
        When introspecting a particular inner element any given macro metafunction
        generated can be reused with any combination of template parameters which
        involve the same type of inner element. Furthermore once a macro metafunction
        is generated, attempting to generate another macro metafunction of the same
        name will create ODR violations since two C++ constructs with the same name/type
        in the same namespace will have been created. This latter possibility has
        much less chance of occurence if you use the simple form of each macro and
        just reuse the macro metafunction. You can even do this if you are introspecting
        for two entities of the same name in different enclosing types, or in the
        same enclosing type but with different signatures, as with overloaded member
        functions.
      </p></td></tr>
</table></div>
<p>
      Once either of these two macro forms are used for a particular type of inner
      element, the corresponding macro metafunction has the exact same functionality.
    </p>
<p>
      In the succeeding documentation all macro metafunctions will be referred by
      their simple form name, but remember that the complex form name can always
      alternatively be used.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2010 Tropic Software East Inc</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_terminology.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_detail.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
