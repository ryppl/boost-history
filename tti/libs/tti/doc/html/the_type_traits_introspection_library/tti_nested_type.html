<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Nested Types</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.0">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.0">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.0">
<link rel="prev" href="tti_detail.html" title="Macros">
<link rel="next" href="tti_metafunctions.html" title="Metafunctions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_detail.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_metafunctions.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="the_type_traits_introspection_library.tti_nested_type"></a><a class="link" href="tti_nested_type.html" title="Nested Types">Nested
    Types</a>
</h2></div></div></div>
<a name="the_type_traits_introspection_library.tti_nested_type.the_problem"></a><h4>
<a name="id965169"></a>
      <a class="link" href="tti_nested_type.html#the_type_traits_introspection_library.tti_nested_type.the_problem">The
      problem</a>
    </h4>
<p>
      The goal of the TTI library is never to produce a compiler error by just using
      the functionality in the library, whether it is invoking its function-like
      macros or instantiating the macro metafunctions created by them, and whether
      the inner element exists or not. In this sense The TTI library macros for introspecting
      an enclosing type for an inner element work very well. But there is one exception
      to this general case. That exception is the crux of the discussion regarding
      nested types which follows, and explains the reason for the separate group
      of TTI nested type metafunctions which mirror the functionality of the macros
      and their generated macro metafunctions.
    </p>
<p>
      The metafunctions generated by the TTI macros all work with types, whether
      in specifying an enclosing type or in specifying the type of some inner element,
      which may also involve types in the signature of that element, such as a parameter
      or return type of a function. The C++ notation for a nested type, given an
      enclosing type 'T' and an inner type 'InnerType', is 'T::InnerType'. If either
      the enclosing type 'T' does not exist, or the inner type 'InnerType' does not
      exist within 'T', the expression 'T::InnerType' will give a compiler error
      if we attempt to use it in our template instantiation of one of TTI's macro
      metafunctions.
    </p>
<p>
      We want to be able to introspect for the existence of inner elements to an
      enclosing type without producing compiler errors. Of course if we absolutely
      know what types we have and that a nested type exists, and these declarations
      are within our scope, we can always use an expression like T::InnerType without
      error. But this is often not the case when doing template programming since
      the type being passed to us at compile-time in a class or function template
      is chosen at instantiation time.
    </p>
<p>
      One solution to this is afforded by the library itself. Given an enclosing
      type 'T' which we know must exist, either because it is a top-level type we
      know about or it is passed to us in some template as a 'class T' or 'typename
      T', and given an inner type named 'InnerType' whose existence we would like
      ascertain, we can use a TTI_HAS_TYPE(InnerType) macro and it's related tti::has_type_InnerType
      metafunction to determine if the nested type 'InnerType' exists. This solution
      is perfectly valid and, with Boost MPL's selection metafunctions, we can do
      compile-time selection to generate the correct template code.
    </p>
<p>
      However this does not scale that well syntactically if we need to drill down
      further from a top-level enclosing type to a deeply nested type, or even to
      look for some deeply nested type's inner elements. We are going to be generating
      a great deal of boost::mpl::if_ and/or boost::mpl::eval_if type selection statements
      to get to some final condition where we know we can generate the compile-time
      code which we want.
    </p>
<a name="the_type_traits_introspection_library.tti_nested_type.the_solution"></a><h4>
<a name="id965200"></a>
      <a class="link" href="tti_nested_type.html#the_type_traits_introspection_library.tti_nested_type.the_solution">The
      solution</a>
    </h4>
<p>
      The TTI library offers a better solution in the form of a set of constructs
      which work with nested types without producing a compiler error if the nested
      type does not exist, but still are able to do the introspecting for inner elements
      that our TTI macro metafunctions do.
    </p>
<p>
      We have already seen one of those constructs, the macro TTI_MEMBER_TYPE ( TTI_TRAIT_MEMBER_TYPE
      ), which generates a metafunction based on the name of an inner type. But instead
      of telling us whether that inner type exists it instead returns a typedef 'type'
      which is that inner type if it exists, else it is an unspecified type if it
      does not. In this way we have created a metafunction, very similar in functionality
      to boost::mpl::identity, but which still returns some unspecified marker 'type'
      if our nested type is invalid.
    </p>
<p>
      We can use the functionality of TTI_MEMBER_TYPE ( TTI_TRAIT_MEMBER_TYPE ) to
      construct nested types for our other macro metafunctions, without having to
      use the T::InnerType syntax and produce a compiler error if no such type actually
      exists within our scope. We can even do this in deeply nested contexts by stringing
      together, so to speak, a series of these macro metafunction results.
    </p>
<p>
      As an example, given a type T, let us create a metafunction where there is
      a nested type FindType whose enclosing type is CType, where CType's enclosing
      type is BType, where BType's enclosing type is AType, and where AType's enclosing
      type is our original T. We can represent this conventially as:
    </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">T</span>
  <span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">AType</span>
    <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">BType</span>
      <span class="special">{</span>
      <span class="keyword">struct</span> <span class="identifier">CType</span>
        <span class="special">{</span>
        <span class="keyword">struct</span> <span class="identifier">FindType</span>
          <span class="special">{</span>
          <span class="special">};</span>
        <span class="special">}</span>
      <span class="special">};</span>
    <span class="special">};</span>
  <span class="special">};</span>
</pre>
<p>
      We can represent this by first creating a series of member type macros for
      each of our nested types:
    </p>
<pre class="programlisting"><span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">FindType</span><span class="special">)</span>
<span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">AType</span><span class="special">)</span>
<span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">BType</span><span class="special">)</span>
<span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">CType</span><span class="special">)</span>
</pre>
<p>
      Next we can create a typedef to reflect a nested type called FindType which
      has the relationship as specified above by instantiating our macro metafunctions.
    </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="keyword">typename</span>
<span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_FindType</span>
  <span class="special">&lt;</span>
  <span class="keyword">typename</span> <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_CType</span>
    <span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_BType</span>
      <span class="special">&lt;</span>
      <span class="keyword">typename</span> <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_AType</span>
        <span class="special">&lt;</span>
        <span class="identifier">T</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;::</span><span class="identifier">type</span>
  <span class="special">&gt;</span> <span class="identifier">MyFindType</span><span class="special">;</span>
</pre>
<p>
      We can use the above typedef to pass the type of FindType to one of our macro
      metafunctions. FindType may not actually exist but we will not generate a compiler
      error when we use it.
    </p>
<p>
      As one example, let's ask whether FindType has a static member data called
      MyData of type 'int'. We add:
    </p>
<pre class="programlisting"><span class="identifier">TTI_HAS_STATIC_MEMBER</span><span class="special">(</span><span class="identifier">MyData</span><span class="special">)</span>
</pre>
<p>
      Next we create our metafunction:
    </p>
<pre class="programlisting"><span class="identifier">tti</span><span class="special">::</span><span class="identifier">has_static_member_MyData</span>
  <span class="special">&lt;</span>
  <span class="identifier">MyFindType</span><span class="special">,</span>
  <span class="keyword">int</span>
  <span class="special">&gt;</span>
</pre>
<p>
      and use this in our metaprogramming code. Our metafunction now tells us whether
      the nested type FindType has a static member data called MyData of type 'int',
      even if FindType does not actually exist as we have specified it as a type.
    </p>
<p>
      We can also find out whether the deeply nested type 'FindType' actually exists
      in a similar manner. Our metafunction would be:
    </p>
<pre class="programlisting"><span class="identifier">TTI_HAS_TYPE</span><span class="special">(</span><span class="identifier">FindType</span><span class="special">)</span>

<span class="identifier">tti</span><span class="special">::</span><span class="identifier">has_type_FindType</span>
  <span class="special">&lt;</span>
  <span class="keyword">typename</span>
  <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_CType</span>
    <span class="special">&lt;</span>
    <span class="keyword">typename</span>
    <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_BType</span>
      <span class="special">&lt;</span>
      <span class="keyword">typename</span>
      <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_AType</span>
        <span class="special">&lt;</span>
        <span class="identifier">T</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;::</span><span class="identifier">type</span>
  <span class="special">&gt;</span>
</pre>
<p>
      Because this duplicates much of our code to create our nested type as a metafunction,
      TTI_MEMBER_TYPE also has, as a convenience, a boolean compile-time constant
      value called 'valid' which returns 'true' if our nested type exists or 'false'
      if it does not.
    </p>
<a name="the_type_traits_introspection_library.tti_nested_type.a_more_elegant_solution"></a><h4>
<a name="id965753"></a>
      <a class="link" href="tti_nested_type.html#the_type_traits_introspection_library.tti_nested_type.a_more_elegant_solution">A
      more elegant solution</a>
    </h4>
<p>
      Although using TTI_MEMBER_TYPE represents a good solution to creating a nested
      type without the possible compile-time error of the T::InnerType syntax, reaching
      in to specify all those ::type expressions does get syntactically tedious.
      Because of this the TTI library offers a parallel set of metafunctions to the
      macro metafunctions where the 'types' used are themselves nullary metafunctions.
      Furthermore, composite types are broken down into a notation of individual
      types so that nested types can be more easily passed to these metafunctions
      in the formation of data and function signatures. This parallel set of metafunctions,
      using nullary metafunctions to specify individual types, are called 'nested
      type metafunctions' and are fully explained in the next section.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2010 Tropic Software East Inc</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_detail.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_metafunctions.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
