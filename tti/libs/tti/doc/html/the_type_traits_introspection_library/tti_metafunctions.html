<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Metafunctions</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.0">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.0">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.0">
<link rel="prev" href="tti_nested_type.html" title="Nested Types">
<link rel="next" href="../typetraitsintrospection_reference.html" title="TypeTraitsIntrospection Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_nested_type.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="../typetraitsintrospection_reference.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="the_type_traits_introspection_library.tti_metafunctions"></a><a class="link" href="tti_metafunctions.html" title="Metafunctions">Metafunctions</a>
</h2></div></div></div>
<p>
      The nested type metafunctions parallel the macro metafunctions but allow nested
      types to be used without compiler errors and without needing to use the T::InnerType
      notation for nested types.
    </p>
<p>
      For each of these metafunctions the first parameter is the class template of
      its corresponding macro metafunction and the remaining parameter are 'types',
      which always consists first of the enclosing type and then possibly other types
      which make up the signature of whatever inner element we are introspecting.
      Each of these 'types' is passed as a nullary metafunction whose typedef 'type'
      is the actual type.
    </p>
<p>
      For a type which is in scope, we can always use boost::mpl::identity to create
      our nullary metafunction, and there can never be a compiler error for such
      known types as long as such declarations for them exist. For nested types,
      which may or may not exist, we can pass the result of the macro pair TTI_MEMBER_TYPE
      ( TTI_TRAIT_MEMBER_TYPE ) or its equivalent nested type metafunction tti::mf_member_type
      ( explained later ).
    </p>
<p>
      To use these metafunctions you need to include the main header file 'TTIntrospection.hpp',
      unless otherwise noted.
    </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
        The header file &lt;boost/mpl/identity.hpp&gt; is included by the TTI header
        files so you need not manually include it in order to use boost::mpl::identity
        to wrap a known type as a nullary metafunction for the nested type metafunctions.
      </p></td></tr>
</table></div>
<p>
      A table of these metafunctions is given, based on the inner element whose existence
      the metaprogrammer is introspecting. A more detailed explanation can be found
      in the reference section. All of the metafunctions are in the top-level 'tti'
      namespace, all have a particular name based on the type of its functionality,
      and all begin with the prefix 'mf_' so as not to conflict with the macro metafunction
      named generated by the library.
    </p>
<div class="table">
<a name="the_type_traits_introspection_library.tti_metafunctions.tbmetafunctions"></a><p class="title"><b>Table&#160;1.3.&#160;TTI Metafunctions</b></p>
<div class="table-contents"><table class="table" summary="TTI Metafunctions">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Inner Element
              </p>
            </th>
<th>
              <p>
                Template
              </p>
            </th>
<th>
              <p>
                Parameters
              </p>
            </th>
<th>
              <p>
                Macro Equivalent
              </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                Type
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_type.html" title="Struct template mf_has_type">tti::mf_has_type</a></code>
              </p>
            </td>
<td>
              <p>
                template&lt;class&gt; class HasType<br> = generated macro metafunction<br>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_TYPE (TTI_TRAIT_HAS_TYPE)
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Type with check
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_type_check_typedef.html" title="Struct template mf_has_type_check_typedef">tti::mf_has_type_check_typedef</a></code>
              </p>
            </td>
<td>
              <p>
                template&lt;class,class&gt; class HasTypeCheckTypedef<br> = generated
                macro metafunction<br> class T = enclosing type nullary metafunction<br>
                class U = type to check against nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_TYPE_CHECK_TYPEDEF (TTI_TRAIT_HAS_TYPE_CHECK_TYPEDEF)
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Class Template
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_template.html" title="Struct template mf_has_template">tti::mf_has_template</a></code>
              </p>
            </td>
<td>
              <p>
                template&lt;class&gt; class HasTemplate<br> = generated macro metafunction<br>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_TEMPLATE (TTI_TRAIT_HAS_TEMPLATE)
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Class Template with params
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_template_check_p_id413297.html" title="Struct template mf_has_template_check_params">tti::mf_has_template_check_params</a></code>
              </p>
            </td>
<td>
              <p>
                template&lt;class&gt; class HasTemplateCheckParams<br> = generated
                macro metafunction<br> class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_TEMPLATE_CHECK_PARAMS (TTI_TRAIT_HAS_TEMPLATE_CHECK_PARAMS)<br>
                TTI_VM_HAS_TEMPLATE_CHECK_PARAMS (TTI_VM_TRAIT_HAS_TEMPLATE_CHECK_PARAMS)
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Member data
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_member_data.html" title="Struct template mf_has_member_data">tti::mf_has_member_data</a></code>
              </p>
            </td>
<td>
              <p>
                template&lt;class&gt; class HasMember<br> = generated macro metafunction<br>
                class T = enclosing type nullary metafunction<br> class R = type
                of member data nullary Metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_MEMBER (TTI_TRAIT_HAS_MEMBER)
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Member function
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_member_function.html" title="Struct template mf_has_member_function">tti::mf_has_member_function</a></code>
              </p>
            </td>
<td>
              <p>
                template&lt;class&gt; class HasMember<br> = generated macro metafunction<br>
                class T = enclosing type nullary metafunction<br> class R = return
                value nullary metafunction<br> class Types... = parameter types
                as nullary metafunctions
              </p>
            </td>
<td>
              <p>
                TTI_HAS_MEMBER (TTI_TRAIT_HAS_MEMBER)
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Static data
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_static_data.html" title="Struct template mf_has_static_data">tti::mf_has_static_data</a></code>
              </p>
            </td>
<td>
              <p>
                template&lt;class,class&gt; class HasStaticMember<br> = generated
                macro metafunction<br> class T = enclosing type nullary metafunction<br>
                class R = type of static data nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_STATIC_MEMBER (TTI_TRAIT_HAS_STATIC_MEMBER)
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Static function
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_static_function.html" title="Struct template mf_has_static_function">tti::mf_has_static_function</a></code>
              </p>
            </td>
<td>
              <p>
                template&lt;class,class&gt; class HasStaticMember<br> = generated
                macro metafunction<br> class T = enclosing type nullary metafunction<br>
                class R = return value nullary metafunction<br> class Types...
                = parameter types as nullary metafunctions
              </p>
            </td>
<td>
              <p>
                TTI_HAS_STATIC_MEMBER (TTI_TRAIT_HAS_STATIC_MEMBER)
              </p>
            </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
      Other than the use of all types as nullary metafunctions, one other difference
      in the nested type metafunctions from their macro metafunction counterparts
      is that the signature for member functions, member data, and static member
      functions is broken down into individual types, rather than the combined type
      notation which the macro metafunctions use. This allows us to specify nested
      types in those signatures without using the T::InnerType notation. One can
      even take our nested types and create new types from them.
    </p>
<a name="the_type_traits_introspection_library.tti_metafunctions.nested_type_metafunction_member_type_equivalent"></a><h4>
<a name="id966245"></a>
      <a class="link" href="tti_metafunctions.html#the_type_traits_introspection_library.tti_metafunctions.nested_type_metafunction_member_type_equivalent">Nested
      type metafunction member_type equivalent</a>
    </h4>
<p>
      Just as there is the macro pair TTI_MEMBER_TYPE (TTI_TRAIT_MEMBER_TYPE) for
      creating a macro metafunction which returns a nested type if it exists, else
      an unspecified type, there is also the equivalent metafunction.
    </p>
<div class="table">
<a name="the_type_traits_introspection_library.tti_metafunctions.tbmetanested"></a><p class="title"><b>Table&#160;1.4.&#160;TTI Nested Type Metafunction</b></p>
<div class="table-contents"><table class="table" summary="TTI Nested Type Metafunction">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Inner Element
              </p>
            </th>
<th>
              <p>
                Template
              </p>
            </th>
<th>
              <p>
                Parameters
              </p>
            </th>
<th>
              <p>
                Macro Equivalent
              </p>
            </th>
</tr></thead>
<tbody><tr>
<td>
              <p>
                Type
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_member_type.html" title="Struct template mf_member_type">tti::mf_member_type</a></code>
              </p>
            </td>
<td>
              <p>
                template&lt;class&gt; class MemberType<br> = generated macro metafunction<br>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_MEMBER_TYPE (TTI_TRAIT_MEMBER_TYPE)
              </p>
            </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
      The use of this metafunction allows us to created deeply nested types, which
      may or may not exist, as nullary metafunctions in much the same way that TTI_MEMBER_TYPE
      (TTI_TRAIT_MEMBER_TYPE) can. The difference is the simpler syntax when using
      mf_member_type.
    </p>
<p>
      As an example, given the theoretical relationship of types we used before:
    </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">T</span>
  <span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">AType</span>
    <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">BType</span>
      <span class="special">{</span>
      <span class="keyword">struct</span> <span class="identifier">CType</span>
        <span class="special">{</span>
        <span class="keyword">struct</span> <span class="identifier">FindType</span>
          <span class="special">{</span>
          <span class="special">};</span>
        <span class="special">}</span>
      <span class="special">};</span>
    <span class="special">};</span>
  <span class="special">};</span>
</pre>
<p>
      We can use mf_member_type as follows. First we create our corresponding macro
      metafunctions:
    </p>
<pre class="programlisting"><span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">FindType</span><span class="special">)</span>
<span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">AType</span><span class="special">)</span>
<span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">BType</span><span class="special">)</span>
<span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">CType</span><span class="special">)</span>
</pre>
<p>
      Next we can create a typedef to reflect a nested type called FindType which
      has the relationship as specified above by instantiating using mf_member_type.
    </p>
<pre class="programlisting"><span class="keyword">typedef</span>
<span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span>
  <span class="special">&lt;</span>
  <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_FindType</span><span class="special">,</span>
  <span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span>
    <span class="special">&lt;</span>
    <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_CType</span><span class="special">,</span>
    <span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span>
      <span class="special">&lt;</span>
      <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_BType</span><span class="special">,</span>
      <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_AType</span>
        <span class="special">&lt;</span>
        <span class="identifier">T</span>
        <span class="special">&gt;</span>
      <span class="special">&gt;</span>
    <span class="special">&gt;</span>
  <span class="special">&gt;</span> <span class="identifier">MyFindType</span><span class="special">;</span>
</pre>
<p>
      The nested type created can be used with the other nested type metafunctions
      above. The key information above is that the enclosing type is a nullary metafunction,
      which means that the enclosing type can be specified as the result of using
      TTI_MEMBER_TYPE (TTI_TRAIT_MEMBER_TYPE) as well as the result of using mf_member_type
      itself. Both techniques are shown in the example above, and the same technique
      for creating nested types as nullary metafunctions can be used with the other
      functionality of the nested type metafunctions when nested types are used.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2010 Tropic Software East Inc</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_nested_type.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="../typetraitsintrospection_reference.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
