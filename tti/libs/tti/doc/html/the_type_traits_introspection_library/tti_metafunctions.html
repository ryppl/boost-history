<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Nullary Type Metafunctions</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.0">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.0">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.0">
<link rel="prev" href="tti_usingMM.html" title="Using the Macro Metafunctions">
<link rel="next" href="tti_usingNTM.html" title="Using the Nullary Type Metafunctions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_usingMM.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_usingNTM.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="the_type_traits_introspection_library.tti_metafunctions"></a><a class="link" href="tti_metafunctions.html" title="Nullary Type Metafunctions">Nullary
    Type Metafunctions</a>
</h2></div></div></div>
<p>
      The nullary type metafunctions parallel most of the macro metafunctions but
      more easily allow a syntax where nested types can be specified without needing
      to manually reach into the 'type' member of TTI_MEMBER_TYPE or its nullary
      type metafunction equivalent of tti::mf_member_type. In a very real way the
      nullary type metafunctions exist just to provide syntactic improvements over
      the macro metafunctions and are not needed to use the library, since all of
      the library functionality is already provided with the macro metafunctions.
      Nonetheless syntactic ease of use is a very real goal of the TTI library and
      therefore these metafunctions are provided to allow that syntactic improvement.
    </p>
<p>
      For each of these nullary type metafunctions the first parameter is a Boost
      MPL lambda expression using its corresponding the macro metafunction to pass
      metafunctions as data. The easiest way to do this is to use a Boost MPL placeholder
      expression. The syntax for passing the corresponding macro metafunction becomes
      'macrometafunction&lt;<span class="underline">&gt;' etc. depending on how
      many parameters are bring passed. Thus for two parameters we would have 'macrometafunction&lt;</span>,<span class="underline">&gt;' etc., with another placeholder ('</span>') added
      for each subsequent parameter.
    </p>
<p>
      The remaining parameter are 'types'. These 'types' always consist first of
      the enclosing type and then possibly other types which make up the signature
      of whatever inner element we are introspecting. Each of these 'types' is passed
      as a nullary metafunction whose typedef 'type' is the actual type.
    </p>
<p>
      The only exception to this use of nullary type metafunctions when specifying
      'types' is when a Boost function_types tag type, which is optional, is specified
      as an addition to the function signature. Also when dealing with a function
      signature and parameter types are being passed, while the parameter 'types'
      themselves are in the form of nullary metafunctions, the MPL forward sequence
      which contains the parameter 'types' should not be wrapped as a nullary metafunction.
    </p>
<p>
      For a type which is in scope, we can always use boost::mpl::identity to create
      our nullary metafunction, and there can never be a compiler error for such
      known types as long as declarations for them exist or it is a built-in C++
      type. For nested types, which may or may not exist, we can pass the result
      of TTI_MEMBER_TYPE or its equivalent nullary type metafunction tti::mf_member_type
      ( explained later ).
    </p>
<p>
      To use these metafunctions you need to include the main header file 'TTIntrospection.hpp',
      unless otherwise noted.
    </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
        The header file &lt;boost/mpl/identity.hpp&gt; is included by the TTI header
        files so you need not manually include it in order to use boost::mpl::identity
        to wrap a known type as a nullary metafunction for the nullary type metafunctions.
        Also the header file &lt;boost/mpl/vector.hpp&gt; is included by the main
        TTI header file 'TTIntrospection.hpp' so if you use an MPL vector as your
        forward sequence wrapper for parameter types, you need not manually include
        the header file. Finally the header file &lt;boost/mpl/placeholders.hpp&gt;
        is also included by 'TTIntrospection.hpp' so you need not manually include
        it yourself in order to use placeholder expressions.
      </p></td></tr>
</table></div>
<p>
      A table of these metafunctions is given, based on the inner element whose existence
      the metaprogrammer is introspecting. A more detailed explanation can be found
      in the reference section, and examples of usage can be found in the <a class="link" href="tti_usingNTM.html#sectti_usingNTM">"Using
      the Nullary Type Metafunctions"</a> section. All of the metafunctions
      are in the top-level 'tti' namespace, all have a particular name based on the
      type of its functionality, and all begin with the prefix 'mf_' so as not to
      conflict with the macro metafunction names generated by the library.
    </p>
<div class="table">
<a name="the_type_traits_introspection_library.tti_metafunctions.tbmetafunctions"></a><p class="title"><b>Table&#160;1.4.&#160;TTI Nullary Type Metafunctions</b></p>
<div class="table-contents"><table class="table" summary="TTI Nullary Type Metafunctions">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Inner Element
              </p>
            </th>
<th>
              <p>
                Template
              </p>
            </th>
<th>
              <p>
                Parameters
              </p>
            </th>
<th>
              <p>
                Macro Equivalent
              </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                Type
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_type.html" title="Struct template mf_has_type">tti::mf_has_type</a></code>
              </p>
            </td>
<td>
              <p>
                class HasType = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_TYPE
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Type with check
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_type.html" title="Struct template mf_has_type">tti::mf_has_type</a></code>
              </p>
            </td>
<td>
              <p>
                class HasType = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
              <p>
                class U = type to check against nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_TYPE
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Class Template
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_template.html" title="Struct template mf_has_template">tti::mf_has_template</a></code>
              </p>
            </td>
<td>
              <p>
                class HasTemplate = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_TEMPLATE
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Class Template with params
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_template_check_p_id388045.html" title="Struct template mf_has_template_check_params">tti::mf_has_template_check_params</a></code>
              </p>
            </td>
<td>
              <p>
                class HasTemplateCheckParams = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_TEMPLATE_CHECK_PARAMS
              </p>
              <p>
                TTI_VM_HAS_TEMPLATE_CHECK_PARAMS
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Member data
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_member_data.html" title="Struct template mf_has_member_data">tti::mf_has_member_data</a></code>
              </p>
            </td>
<td>
              <p>
                class HasMemberData = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
              <p>
                class R = type of member data nullary Metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_MEMBER_DATA
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Member function
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_member_function.html" title="Struct template mf_has_member_function">tti::mf_has_member_function</a></code>
              </p>
            </td>
<td>
              <p>
                class HasMemberFunction = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
              <p>
                class R = return value nullary metafunction
              </p>
              <p>
                class FS = (optional) a Boost MPL forward sequence of parameter types
                as nullary metafunctions. The forward sequence as a type is not presented
                as a nullary metafunction. If there are no parameters, this may be
                omitted.
              </p>
              <p>
                class TAG = (optional) a Boost function_types tag type.
              </p>
            </td>
<td>
              <p>
                TTI_HAS_MEMBER_FUNCTION
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Static data
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_static_data.html" title="Struct template mf_has_static_data">tti::mf_has_static_data</a></code>
              </p>
            </td>
<td>
              <p>
                class HasStaticMember = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
              <p>
                class R = type of static data nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_HAS_STATIC_MEMBER
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Static function
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_has_static_member_fu_id387209.html" title="Struct template mf_has_static_member_function">tti::mf_has_static_member_function</a></code>
              </p>
            </td>
<td>
              <p>
                class HasStaticMemberFunction = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
              <p>
                class R = return value nullary metafunction
              </p>
              <p>
                class FS = (optional) a Boost MPL forward sequence of parameter types
                as nullary metafunctions. The forward sequence as a type is not presented
                as a nullary metafunction. If there are no parameters, this may be
                omitted.
              </p>
              <p>
                class TAG = (optional) a Boost function_types tag type.
              </p>
            </td>
<td>
              <p>
                TTI_HAS_STATIC_MEMBER_FUNCTION
              </p>
            </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
      Other than the use of nearly all types as nullary metafunctions, one other
      difference in the nullary type metafunctions from their macro metafunction
      counterparts is that the signature for member functions, member data, and static
      member functions always involves individual types rather than the combined
      type notation which some of the macro metafunctions use. This allows us to
      specify nested types in those signatures without using the T::InnerType notation.
    </p>
<a name="the_type_traits_introspection_library.tti_metafunctions.nullary_type_metafunction_member_type_equivalent"></a><h4>
<a name="id924485"></a>
      <a class="link" href="tti_metafunctions.html#the_type_traits_introspection_library.tti_metafunctions.nullary_type_metafunction_member_type_equivalent">Nullary
      type metafunction member_type equivalent</a>
    </h4>
<p>
      Just as there is the macro TTI_MEMBER_TYPE for creating a macro metafunction
      which returns a nested type if it exists, else an unspecified type, there is
      also the equivalent nullary type metafunction.
    </p>
<div class="table">
<a name="the_type_traits_introspection_library.tti_metafunctions.tbmetanested"></a><p class="title"><b>Table&#160;1.5.&#160;TTI Nested Type Nullary Type Metafunction</b></p>
<div class="table-contents"><table class="table" summary="TTI Nested Type Nullary Type Metafunction">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Inner Element
              </p>
            </th>
<th>
              <p>
                Template
              </p>
            </th>
<th>
              <p>
                Parameters
              </p>
            </th>
<th>
              <p>
                Macro Equivalent
              </p>
            </th>
</tr></thead>
<tbody><tr>
<td>
              <p>
                Type
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_member_type.html" title="Struct template mf_member_type">tti::mf_member_type</a></code>
              </p>
            </td>
<td>
              <p>
                class MemberType = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                TTI_MEMBER_TYPE
              </p>
            </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
      The difference between the macro metafunction TTI_MEMBER_TYPE and tti::mf_member_type
      is simply that, like the other nullary type metafunctions, the latter takes
      its enclosing type as a nullary metafunction. Both produce the exact same result.
    </p>
<p>
      The use of this metafunction allows us to created deeply nested types, which
      may or may not exist, as nullary metafunctions in much the same way that TTI_MEMBER_TYPE
      can. The difference is the simpler syntax when using tti::mf_member_type.
    </p>
<p>
      As an example, given the theoretical relationship of types we used before:
    </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">T</span>
  <span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">AType</span>
    <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">BType</span>
      <span class="special">{</span>
      <span class="keyword">struct</span> <span class="identifier">CType</span>
        <span class="special">{</span>
        <span class="keyword">struct</span> <span class="identifier">FindType</span>
          <span class="special">{</span>
          <span class="special">};</span>
        <span class="special">}</span>
      <span class="special">};</span>
    <span class="special">};</span>
  <span class="special">};</span>
</pre>
<p>
      We can use tti::mf_member_type as follows. First we create our corresponding
      macro metafunctions:
    </p>
<pre class="programlisting"><span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">FindType</span><span class="special">)</span>
<span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">AType</span><span class="special">)</span>
<span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">BType</span><span class="special">)</span>
<span class="identifier">TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">CType</span><span class="special">)</span>
</pre>
<p>
      Next we can create a typedef to reflect a nested type called FindType, as a
      nullary metafunction, which has the relationship as specified above by using
      tti::mf_member_type.
    </p>
<pre class="programlisting"><span class="keyword">typedef</span>
<span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span>
  <span class="special">&lt;</span>
  <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_FindType</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;,</span>
  <span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span>
    <span class="special">&lt;</span>
    <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_CType</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;,</span>
    <span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span>
      <span class="special">&lt;</span>
      <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_BType</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;,</span>
      <span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_AType</span>
        <span class="special">&lt;</span>
        <span class="identifier">T</span>
        <span class="special">&gt;</span>
      <span class="special">&gt;</span>
    <span class="special">&gt;</span>
  <span class="special">&gt;</span> <span class="identifier">MyFindType</span><span class="special">;</span>
</pre>
<p>
      The nested type created can be used with the other nullary type metafunctions
      above. The key information above is that the enclosing type, as in all of the
      nullary type metafunctions, is a nullary metafunction itself, which means that
      the enclosing type can be specified as the result of using TTI_MEMBER_TYPE
      as well as the result of using mf_member_type itself.
    </p>
<p>
      Both techniques are shown in the example above, and the same technique for
      creating nested types as nullary metafunctions can be used with the other functionality
      of the nullary type metafunctions when nested types are needed as 'types'.
    </p>
<p>
      Also similar to the macro metafunctions, we have an easy way of testing whether
      or not our tti::mf_member_type nested type actually exists.
    </p>
<div class="table">
<a name="the_type_traits_introspection_library.tti_metafunctions.existtbmetanested"></a><p class="title"><b>Table&#160;1.6.&#160;TTI Nested Type Nullary Type Metafunction Existence</b></p>
<div class="table-contents"><table class="table" summary="TTI Nested Type Nullary Type Metafunction Existence">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Inner Element
              </p>
            </th>
<th>
              <p>
                Template
              </p>
            </th>
<th>
              <p>
                Parameters
              </p>
            </th>
</tr></thead>
<tbody><tr>
<td>
              <p>
                Type
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../tti/mf_valid_member_type.html" title="Struct template mf_valid_member_type">tti::mf_valid_member_type</a></code>
              </p>
            </td>
<td>
              <p>
                class T = a type as a nullary metafunction
              </p>
              <p>
                returns = true if the nullary metafunction's inner 'type' exists,
                false if it does not. 'Existence' is determined by whether the type
                does not equal an unspecified type.
              </p>
            </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
      Again note the difference here from the equivalent macro metafunction tti::valid_member_type.
      In the example above the type T is passed as a nullary metafunction holding
      the actual type, where for the macro metafunction equivalent the type T is
      passed as the actual type being tested.
    </p>
<p>
      In our next section we will look at examples of nullary type metafunction use.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2010 Tropic Software East Inc</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_usingMM.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_usingNTM.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
