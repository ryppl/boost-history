[section:tti_history History]

[heading Version 1.3]

* Changed the filenames to lower case and undescores.
* The names of the main header files are shortened to 'tti.hpp' and 'tti_vm.hpp'.

[heading Version 1.2]

* Added the set of metafunction class macros for passing the macro metafunctions as metadata.
  This complements passing the macro metafunctions as metadata using placeholder expressions.

[heading Version 1.1]

* Library now also compiles with gcc 3.4.2 and gcc 3.4.5.
* Examples of use have been added to the documentation.
* In the documentation the previously mentioned 'nested type metafunctions' are now called "nullary type metafunctions'.
* TTI_HAS_TYPE and tti::mf_has_type now have optional typedef checking.
* New macro metafunction functionality which allows composite typed to be treated as individual types has been implemented. These include:
  * TTI_HAS_MEMBER_DATA
  * TTI_HAS_MEMBER_FUNCTION
  * TTI_HAS_STATIC_MEMBER_FUNCTION
* New nullary type metafunction tti::mf_has_static_member_function uses the new underlying TTI_HAS_STATIC_MEMBER_FUNCTION macro metafunction.
  Its signature uses an optional MPL forward sequence for the parameter types and an optional Boost function_types tag type.
* New nullary type metafunctions tti::valid_member_type and tti::mf_valid_member_type for checking if the 'type' returned from invoking the TTI_MEMBER_TYPE or tti::mf_member_type metafunctions is valid.
* Breaking changes
  * TTI_HAS_TYPE_CHECK_TYPEDEF and tti::mf_has_type_check_typedef have been removed, and the functionality in them folded into TTI_HAS_TYPE and tti::mf_has_type.
  * TTI_MEMBER_TYPE and tti::mf_member_type no longer also return a 'valid' boolean constant. Use tti::valid_member_type or  tti::mf_valid_member_type metafunctions instead ( see above ).
  * tti::mf_has_static_function has been removed and its functionality moved to tti::mf_has_static_member_function ( see above ).
  * tti::mf_member_data uses the new underlying TTI_HAS_MEMBER_DATA macro metafunction.
  * The signature for tti::mf_has_member_function has changed to use an optional MPL forward sequence for the parameter types and an optional Boost function_types tag type.
  * All nullary type metafunctions take their corresponding macro metafunction parameter as a class in the form of a Boost MPL lambda expression instead of as a template template parameter as previously.
    Using a placeholder expression is the easiest way to pass the corresponding macro metafunction to its nullary type metafunction. 

[heading Version 1.0]

Initial version of the library.

[endsect]
