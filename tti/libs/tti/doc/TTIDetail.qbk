[section:tti_detail Macros]

The TTI library uses macros to create metafunctions, in the top-level 'tti' namespace, 
for introspecting an inner element by name. Each macro for a particular type of inner 
element has two forms, the simple one where the first macro parameter designating the 
'name' of the inner element is used to create the name of the metafunction, and the 
complex one where the first macro parameter, called 'trait', designates 
the name of the metafunction and the second macro parameter designates the 'name' to be 
introspected. Other than that difference, the two forms of the macro produce the exact same 
results. All of the introspecting macros create a metafunction whose boolean 'value' 
specifies whether or not the inner element exists. 

To use these metafunctions you need to include the main header file 'TTIntrospection.hpp',
unless otherwise noted.

A table of these macros is given, with the inner element whose 
existence the metaprogrammer is introspecting. A more detailed explanation can be found 
in the reference section. In the Template column only the name generated by the simple form 
of the template is given since the name generated by the complex form is always tti::trait 
where 'trait' is the first parameter to the corresponding complex form macro.

[table:tbmacros TTI Macros
  [
    [Inner Element]
    [Macro]
    [Template]
  ]
  [
    [Type]
    [
    TTI\_HAS\_TYPE(name)[br]
    TTI\_TRAIT\_HAS\_TYPE(trait,name)
    ]
    [
    tti::has\_type\_'name'[br]
    class T = enclosing type
    ]
  ]
  [
    [Type with check]
    [
    TTI\_HAS\_TYPE\_CHECK\_TYPEDEF(name)[br]
    TTI\_TRAIT\_HAS\_TYPE\_CHECK\_TYPEDEF(trait,name)
    ]
    [
    tti::has\_type\_check\_typedef\_'name'[br]
    class T = enclosing type,class U = type to check against
    ]
  ]
  [
    [Class Template]
    [
    TTI\_HAS\_TEMPLATE(name)[br]
    TTI\_TRAIT\_HAS\_TEMPLATE(trait,name)
    ]
    [
    tti::has\_template\_'name'[br]
    class T = enclosing type[br]
    All of the template parameters must be 'class' ( or 'typename' ) parameters
    ]
  ]
  [
    [Class Template with params]
    [
    TTI\_HAS\_TEMPLATE\_CHECK\_PARAMS(name,ppSeq[footnote A Boost PP data sequence with each comma separated portion of the template parameters as its own sequence element.])[br]
    TTI\_TRAIT\_HAS\_TEMPLATE\_CHECK\_PARAMS(trait,name,ppSeq)
    ]
    [
    tti::has\_template\_check\_params\_'name'[br]
    class T = enclosing type
    ]
  ]
  [
    [Class Template with params using variadic macros[footnote Header file is TTIntrospectionVM.hpp.]]
    [
    TTI\_VM\_HAS\_TEMPLATE\_CHECK\_PARAMS(name,...[footnote The template parameters as variadic data.])[br]
    TTI\_VM\_TRAIT\_HAS\_TEMPLATE\_CHECK\_PARAMS(trait,name,...)
    ]
    [
    tti::has\_template\_check\_params\_'name'[br]
    class T = enclosing type
    ]
  ]
  [
    [Data or function member]
    [
    TTI\_HAS\_MEMBER(name)[br]
    TTI\_TRAIT\_HAS\_MEMBER(trait,name)
    ]
    [
    tti::has\_member\_'name'[br]
    class T = pointer to data or function member[br]
    The form for T is 'Type Class::*' for member data[br]
    The form for T is 'ReturnType (Class::*)(Zero or more comma-separated parameter types)' for member function
    ]
  ]
  [
    [Static data or static function member]
    [
    TTI\_HAS\_STATIC\_MEMBER(name)[br]
    TTI\_TRAIT\_HAS\_STATIC\_MEMBER(trait,name)
    ]
    [
    tti::has\_static\_member\_'name'[br]
    class T = enclosing type,class Type = data or function type
    ]
  ]
]

There is one other macro which creates a metafunction which does not introspect
for the existence of an inner element type, but is very useful nonetheless. 
Instead the macro metafunction created returns the nested type if it exists, else 
it returns an unspecified type.

[table:tbmacronested TTI Nested Type Macro
  [
    [Inner Element]
    [Macro]
    [Template]
  ]
  [
    [Type]
    [
    TTI\_MEMBER\_TYPE(name)[br]
    TTI\_TRAIT\_MEMBER\_TYPE(trait,name)
    ]
    [
    tti::member\_type\_'name'[br]
    class T = enclosing type
    ]
  ]
]

The usefulness of this macro, and its corresponding metafunction, will be shown 
in the next section when I explain the problem of nested types and how TTI solves 
it.

[endsect]
