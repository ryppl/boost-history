[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Assignable]
A type `T` is /assignable/ if an object of type `T` can be assigned
the value of another object `u` using the assignment operator. The type
of `u` is either `T` or `const T`. A type `T` is assignable if it has
a compiler-generated or user-defined assignment operator. After the
assignment the object `t` is equivalent to `u`.

This type of assignment is properly referred to as /copy assignment/ since both
assignment operators and constructors can be provided for types that are not
`T` or `const T`, and those operators do not have copy semantics.

[note
Two objects `t` and `u` are equivalent if the expression `t == u` returns
`true`. See [EqualityComparable] for more information.
]

[heading Notation]
[table
    [[Expression] [Description]]
    [[T] [An [Assignable] type.]]
    [[t] [An instance of type `T`.]]
    [[u] [An instance of type `T` or const `T`.]]
]

[heading Requirements]
[table
    [[Expression] [Return Type] [Post-condition]]
    [
        [`t = u`]
        [`T&`]
        [
            Assigns the object `u` to the object `t`.

            *Requirements:* The type of `u` is either `T` or `const T`.

            *Postconditions:* `t` is equivalent to `u`.
        ]
    ]
]

[heading Examples]
A type `T` is required to be [Assignable] when an object of type `T` is
assigned to an object of type `T` or `const T`.

    // The assignment of the object t to the value u requires T to be Assignable.
    template <typename T>
    void assign(T& t, const T& u)
    {
        t = u;
    }

[endsect]