[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Less Than Comparable]
A type `T` is said to be /less than comparable/ if two instances of `T` can be
compared with the less than operator (`<`) and that operator defines a
/strict weak ordering/ of values `T`. A strict weak ordering is a binary relation
between any two instances, `t` and `u` of `T` that denotes their ordering. The
meaning of `t < u` is that `t` occurs before `u`. Strict weak orderings are
required to be be /irreflixive/, /antisymmetric/, and /transitive/.

[heading Notation]
[table
    [[Expression] [Description]]
    [[T] [An [StdLessThanComparable] type.]]
    [[`t`, `u`, `v`] [Instances of `T`.]]
]

[heading Requirements]
[table
    [[Expression] [Return Type] [Requirements]]
    [
        [`t < u`]
        [Convertible to `bool`.]
        [If `t` is ordered before `u`, the return value is convertible to `true`.]
    ]
    [
        [`t > u`]
        [Convertible to `bool`.]
        [If `t` is ordered after `u`, the return value is convertible to `true`.]
    ]
    [
        [`t <= u`]
        [Convertible to `bool`.]
        [If `t` is equivalent to ordered before `u`, the return value is convertible to `true`.]
    ]
    [
        [`t >= u`]
        [Convertible to `bool`.]
        [If `t` is equivalent to ordered after `u`, the return value is convertible to `true`.]
    ]
]

The `>`, `<=` and `>=` operator can all be trivially implemented if the `<` operator is defined
for type `T` as:

    bool operator >(const T& t, const T& u) { return u < v; }
    bool operator <=(const T& t, const T& v) { return !(u < v); }
    bool operator >=(const T& t, const T& v) { return !(v < u); }

[heading Invariants]
The following properties must hold for all models of [StdLessThanComparable].

[table
    [[Property] [Semantics]]
    [[Irreflexivity] [`t < t` is false.]]
    [[Antisymmetry] [`t < u` implies `!(u < t)`.]]
    [[Transitivity] [`t < u` and `u < v` implies `t < v`.]]
]

[heading Notes]
From a mathematical perspective, values of `T` can be incomparable. For example,
to state that `t` and `u` are incomparable means that the `t < u` has no meaning.
This is generally infeasible from a programming perspective since the less than
operator (`<`) typically only has two values: `true` and `false`. If `t` and
`u` were incomparable, then the return type could be neither `true` nor `false`
since that would effectively compare the elements. In this sense, most strict
weak orderings of `T` are also total orderings of `T`.

The original Standard Template Library requires that the less than operator (`<`)
implement a /partial ordering/ over instances `T`. A partial order is required to
be /reflexive/, /antisymmetric/, and /transitive/. Since incomparability is rarely
(if ever) a factor in most programs, the transitivity of `<`  implies that this is
a strict ordering.

As a result, providing the less than operator (`<`) for a type `T` will almost always
guarantee a total ordering and a strict weak ordering over `T`.

[heading C++0x]
In the next version of C++ the `LessThanComparable` concept requires that the less
than operator (`<`) implement a strict weak ordering over instances of `T` rather
than just a partial ordering, and it provides default implementations of the other
relative comparison operators (`>`, `<=`, and `>=`). It is given as:

    auto concept LessThanComparable<typename T, typename U = T>
    {
        bool operator <(const T&, const U&);
        bool operator >(const T& t, const U& u) { return u < v; }
        bool operator <=(const T& t, const U& u) { return !(u < v); }
        bool operator >=(const T& t, const U& u) { return !(v < u); }
    };

[endsect]