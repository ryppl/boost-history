[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Destructible]
A type `T` is /destructible/ if it has a public destructor. The
destructor can be either compiler-generated or user-defined.

[heading Notation]
The following expressions are used within this document:
[table
    [[Expression] [Description]]
    [[T] [A [StdCopyConstructible] type.]]
    [[t] [An object of type `T`.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Destructor]
        [`t.~T()`]
        []
        [
                *Semantics:* The destructor of `t` is called, destroying
                the object.

                *Exceptions:* Destructors must not throw exceptions.
        ]
    ]
]

[heading Notes]
A class that provides a user-defined, `private` or `protected` destructor
is not [StdDestructible].

[heading Examples]
In practice, there are very few types that are not destructible. The
destructors of these types (whether implicitly or user-defined) are
invoked when the lifetime of the [StdDestructible] object ends. For
local (automatic) objects, this is when they go out of scope. For
dynamically allocated (via `new`), this is when they are deleted. For
static objects, this is when the program ends (maybe).

        int main()
        {
            std::string s;
        } // s goes out of scope, calling s.~std::string()

A user-defined types are [StdDestructible] if they have an implicitly
or user-defined destructor. In the following example, both types are
[StdDestructible].

        // This type is destructible since it explicitly provides
        // a public destructor.
        struct foo
        {
                ~foo()
                { }
        };

        // This type is destructible since the destructor is
        // provided by the compiler.
        struct bar
        { };

        // This class is not destructible since the destructor
        // is declared with private visibility.
        class do_not_destroy
        {
                ~do_not_destroy()
                { }
        };

[heading C++0x]
The [StdDestructible] concept will be defined as:

    // The Destructible concept requires a public desctructor,
    // either compiler-generated or user-defined.
    auto concept Destructible<typename T>
    {
        T::~T();
    };

[endsect]