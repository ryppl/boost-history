[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Destructible]
A type `T` is /destructible/ if it has a public destructor. The destructor can
be either compiler-generated or user-defined.

[heading Notation]
The following expressions are used within this document:
[table
    [[Expression] [Description]]
    [[T] [A [Destructible] type.]]
    [[t] [An object of type `T`.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Destructor]
        [`t.~T()`]
        []
        [
                The destructor of `t` is called, destroying the object.

                *Exceptions:* Destructors must not throw exceptions.
        ]
    ]
]

[heading Notes]
A class that provides a user-defined, `private` or `protected` destructor
is not [Destructible].

[heading Examples]
In practice, there are non-[Destructible] types are infrequent. Any type
whose objects are statically or locally declared is required to be model the
[Destructible] concept. Any type whose objects are `delete`d are also required
to be [Destructible].

    // An object of type T that goes out of scope is required to be
    // Destructible. Note that this function also requires T to be
    // DefaultConstructible.
    template <typename T>
    void implicit_destruct()
    {
        T t;
    } // Destructor is called here

    // Invoking the desctructor of an object of type T requires the type to be
    // Destructible.
    template <typename T>
    void explicit_destruct(T& t)
    {
        t.~T();
    }

    // Deleting a dynamically allocated object of type T requires the type to be
    // Destructible.
    template <typename T>
    void dynamic_destruct(T* t)
    {
        delete t;
    }

[endsect]