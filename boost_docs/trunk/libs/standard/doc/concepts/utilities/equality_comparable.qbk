[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Equality Comparable]
A type `T` is /equality comparable/ if it defines an /equivalence relation/ and
can be compared using the equality comparison operator (`==`). An equivalence
relation is a binary relation between any two objects of type `T` that denotes
them as being "equivalent". The specific meaning of "equivalent" depends on the 
semantics of the type modeling this concept.

Equivalence relations exhibit the following properties:

* [*Reflexivity] `x == x`.
* [*Symmetry] If `x == y` then `y == x`.
* [*Transitivity] If `x == y` and `y == z` then `x == z`.

[heading Notation]
[table
    [[Expression] [Description]]
    [[T] [An [StdEqualityComparable] type.]]
    [[`t`, `u`, `v`] [Objects of type `T`.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Equality Comparision]
        [`t == u`]
        [Convertible to `bool`]
        [
            Returns `true` or a value covertible to `true` if the object
            `t` is equivalent to `u`.
        ]
    ]
    [
        [Inequality Comparision]
        [`t != u`]
        [Convertible to `bool`]
        [
            Returns `true` or a value covertible to `true` if the object
            `t` is not equivalent to `u`. Note that `t != u` is equivalent
             to `!(t == u)`.
        ]
    ]
]

[heading Examples]
A type `T` is required to be [StdEqualityComparable] when an object of type `T` is
compared to another object of type `T` using the `==` operator.

    // Using the equality comparison operator to compare two objects of type T
    // requires that type to be EqualityComparable.
    template <typename T>
    bool equality_compare(const T& t, const T& u)
    {
        return t == u;
    }
    
    // Using the inequality comparison operator to compare two objects of type T
    // requires that type to be EqualityComparable since inequality can be
    // implemented in terms of equality.
    template <typename T>
    bool inequality_compare(const T& t, const T& u)
    {
        return t != u;
    }

[endsect]