[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Copy Constructible]
A type `T` is /copy constructible/ if it an object `t` of type `T` can
be constructed as a copy of another object `u`. The type of `u` is either
`T` or `const T`. A type `T` is only copy constructible if it has either a
compiler-generated or user-defined copy constructor that accepts a single
argument: a `const` reference to `T`. After copy construction, the
constructed object is equivalent to the object passed as an argument.

[note
Two objects `t` and `u` are equivalent if the expression `t == u` returns
`true`. See [EqualityComparable] for more information.
]

[heading Refinement of]
[Destructible]

[heading Notation]
The following expressions are used within this document:
[table
    [[Expression] [Description]]
    [[T] [A [CopyConstructible] type.]]
    [[t] [An object of type `T`.]]
    [[u] [An object of type `T` or `const T`.]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Copy Constructor]
        [
                `T t(u);`[br]
                `T t = u;`
        ]
        []
        [
                The object `t` is declared as an object of type `T` whose
                value or state is equivalent to `u`

                *Requirements:* The type of `u` is either `T` or `const T`.

                *Postcondition:* `t` is equivalent to `u`.
        ]
    ]
    [
        [Copy Constructor]
        [`T(u)`]
        [`T`]
        [
                Construct an object of type `T` whose value or state is
                equivalent to `u`.

                *Requirements:* The type of `u` is either `T` or `const T`.

                *Postcondition:* `t` is equivalent to `u`.
        ]
    ]
]

[heading Notes]
A type that explicitly defines a private copy constructor is not
[CopyConstructible]. These types are called non-copyable types.

[heading Examples]
A type `T` is required to be [CopyConstructible] when an object of type `T`
is when the copy constructor of `T` is invoked passing another object of
type `T` as an argument.

    // Declaring a new object of type T as a copy of another requires T to be
    // CopyConstructible.
    template <typename T>
    void copy_declare(const T& u)
    {
        T t(u);
    }

    // Explicitly constructing an object of type T and passing an object of type
    // T or const T to the copy constructor requires T to be CopyConstructible.
    template <typename T>
    T copy_construct(const T& u)
    {
        return T(u);
    }

    // Allocating a new object of type T and passing an object of type T or
    // const T to the copy constructor requires T to be CopyConstructible.
    template <typename T>
    T* dynamic_copy_construct(const T& u)
    {
        return new T(u);
    }

[endsect]
