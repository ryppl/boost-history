[/
 / Copyright (c) 2007 Andrew Sutton
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Copy Constructible]
A type `T` is /copy constructible/ if it is possible to create copies
of that type. `T` is only copy constructible if it has either a
compiler-generated or user-defined copy constructor that accepts a single
argument: a `const` reference to `T`. After construction, a constructed
object is equivalent to the object passed as an argument.

[heading Refinement of]
[StdDestructible]

[heading Notation]
The following expressions are used within this document:
[table
    [[Expression] [Description]]
    [[T] [A [StdCopyConstructible] type.]]
    [[t] [An object of type `T`.]]
    [[u] [An object of type `T` or `const T`]]
]

[heading Requirements]
[table
    [[Name] [Expression] [Result Type] [Description]]
    [
        [Copy Constructor]
        [`T t(u)`]
        []
        [
                *Semantics:* `t` is declared as an object of type `T`.

                *Postcondition:* `t` is equivalent to `u`.
        ]
    ]
    [
        [Copy Constructor]
        [`T(u)`]
        [`T`]
        [
                *Semantics:* Creates an object of type `T`.

                *Postcondition:* `t` is equivalent to `u`.
        ]
    ]
]

[heading C++0x]
In the next version of the C++ language, the destructible and addressable
requirements are removed from this concept and made explicit elsewhere. The
`CopyConstructible` concept is refined from the concepts for `Destructible`
and `MoveConstructible` as follows:

    auto concept Destructible<typename T>
    {
        T::~T();
    };

    auto concept MoveConstructible<typename T>
        : Destructible<T>
    {
        T::T(T&&);
    };

    auto concept CopyConstructible<typename T>
        : MoveConstructible<T>
    {
        T::T(const T&);
    };


[endsect]