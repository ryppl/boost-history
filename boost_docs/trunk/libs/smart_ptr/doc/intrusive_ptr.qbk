[section:intrusive_ptr intrusive_ptr class template]

[def __const_pointer_cast__ [link smart_ptr.reference.intrusive_ptr.members.const_pointer_cast const_pointer_cast]]
[def __dynamic_pointer_cast__ [link smart_ptr.reference.intrusive_ptr.members.dynamic_pointer_cast dynamic_pointer_cast]]
[def __ctor__ [link smart_ptr.reference.intrusive_ptr.members.constructors intrusive_ptr]]
[def __destructor__ [link smart_ptr.reference.intrusive_ptr.members.destructor ~intrusive_ptr]]
[def __element_type__ [link smart_ptr.reference.intrusive_ptr.members.element_type element_type]]
[def __free_swap__ [link smart_ptr.reference.intrusive_ptr.free_functions.swap swap]]
[def __get__ [link smart_ptr.reference.intrusive_ptr.members.get get]]
[def __get_deleter__ [link smart_ptr.reference.intrusive_ptr.members.get_deleter get_deleter]]
[def __get_pointer__ [link smart_ptr.reference.intrusive_ptr.members.get_pointer get_pointer]]
[def __operatorstar__ [link smart_ptr.reference.intrusive_ptr.members.indirection operator*]]
[def __operatorarrow__ [link smart_ptr.reference.intrusive_ptr.members.indirection operator->]]
[def __operatorconv__ [link smart_ptr.reference.intrusive_ptr.members.conversions operator ['unspecified-bool-type]]]
[def __operator_indexing__ [link smart_ptr.reference.intrusive_ptr.members.indexing operator\[\]]]
[def __operator_assign__ [link smart_ptr.reference.intrusive_ptr.members.assignment operator=]] 
[def __operator_insertion__ [link smart_ptr.reference.intrusive_ptr.members.operator_insertion operator<<]]
[def __operator_eq__ [link smart_ptr.reference.intrusive_ptr.members.comparison operator==]]
[def __operator_ne__ [link smart_ptr.reference.intrusive_ptr.members.comparison operator!=]]
[def __operator_lt__ [link smart_ptr.reference.intrusive_ptr.members.comparison operator<]]
[def __reset__ [link smart_ptr.reference.intrusive_ptr.members.reset reset]]
[def __unique__ [link smart_ptr.reference.intrusive_ptr.members.unique unique]]
[def __use_count__ [link smart_ptr.reference.intrusive_ptr.members.use_count use_count]]
[def __static_pointer_cast__ [link smart_ptr.reference.intrusive_ptr.members.static_pointer_cast static_pointer_cast]]
[def __swap__ [link smart_ptr.reference.intrusive_ptr.members.swap swap]]

[section Introduction]

The [*intrusive_ptr] class template stores a pointer to an object with an embedded reference count. Every new [*intrusive_ptr] instance increments the reference count by using an unqualified call to the function intrusive_ptr_add_ref, passing it the pointer as an argument. Similarly, when an intrusive_ptr is destroyed, it calls intrusive_ptr_release; this function is responsible for destroying the object when its reference count drops to zero. The user is expected to provide suitable definitions of these two functions. On compilers that support argument-dependent lookup, intrusive_ptr_add_ref and intrusive_ptr_release should be defined in the namespace that corresponds to their parameter; otherwise, the definitions need to go in namespace boost.

The class template is parameterized on [*T], the type of the object pointed to. intrusive_ptr<T> can be implicitly converted to intrusive_ptr<U> whenever T* can be implicitly converted to U*.

The main reasons to use intrusive_ptr are:
* Some existing frameworks or OSes provide objects with embedded reference counts; 
* The memory footprint of intrusive_ptr is the same as the corresponding raw pointer; 
* intrusive_ptr<T> can be constructed from an arbitrary raw pointer of type T *.

As a general rule, if it isn't obvious whether intrusive_ptr better fits your needs than shared_ptr, try a shared_ptr-based design first.

[endsect] 

[section Synopsis]

    namespace boost {

      template<class T> class intrusive_ptr {

        public:

          typedef T __element_type__;

          __ctor__(); // never throws
          __ctor__(T * p, bool add_ref = true);

          __ctor__(intrusive_ptr const & r);
          template<class Y> __ctor__(intrusive_ptr<Y> const & r);

          __destructor__();

          intrusive_ptr & __operator_assign__(intrusive_ptr const & r);
          template<class Y> intrusive_ptr & __operator_assign__(intrusive_ptr<Y> const & r);
          intrusive_ptr & __operator_assign__(T * r);
          void __reset__(T * r);

          T & __operatorstar__() const; // never throws
          T * __operatorarrow__() const; // never throws
          T * __get__() const; // never throws

          __operatorconv__() const; // never throws

          void __swap__(intrusive_ptr & b); // never throws
      };

      template<class T, class U>
        bool __operator_eq__(intrusive_ptr<T> const & a, intrusive_ptr<U> const & b); // never throws

      template<class T, class U>
        bool __operator_ne__(intrusive_ptr<T> const & a, intrusive_ptr<U> const & b); // never throws

      template<class T>
        bool __operator_eq__(intrusive_ptr<T> const & a, T * b); // never throws

      template<class T>
        bool __operator_ne__(intrusive_ptr<T> const & a, T * b); // never throws

      template<class T>
        bool __operator_eq__(T * a, intrusive_ptr<T> const & b); // never throws

      template<class T>
        bool __operator_ne__(T * a, intrusive_ptr<T> const & b); // never throws

      template<class T, class U>
        bool __operator_lt__(intrusive_ptr<T> const & a, intrusive_ptr<U> const & b); // never throws

      template<class T> void __free_swap__(intrusive_ptr<T> & a, intrusive_ptr<T> & b); // never throws

      template<class T> T * __get_pointer__(intrusive_ptr<T> const & p); // never throws

      template<class T, class U>
        intrusive_ptr<T> __static_pointer_cast__(intrusive_ptr<U> const & r); // never throws

      template<class T, class U>
        intrusive_ptr<T> __const_pointer_cast__(intrusive_ptr<U> const & r); // never throws

      template<class T, class U>
        intrusive_ptr<T> __dynamic_pointer_cast__(intrusive_ptr<U> const & r); // never throws

      template<class E, class T, class Y>
        std::basic_ostream<E, T> & __operator_insertion__ (std::basic_ostream<E, T> & os, intrusive_ptr<Y> const & p);

    }

[endsect]

[section Members]

[heading element_type]

    typedef T element_type;

[: 

Provides the type of the template parameter T.
]

[heading constructors]

    intrusive_ptr(); // never throws

[: 

[*Postconditions:] [^get() == 0].

[*Throws:] nothing.
]

    intrusive_ptr(T * p, bool add_ref = true);

[: 

[*Effects:] [^if(p != 0 && add_ref) intrusive_ptr_add_ref(p);].

[*Postconditions:] [^get() == p].
]


    intrusive_ptr(intrusive_ptr const & r);
    template<class Y> intrusive_ptr(intrusive_ptr<Y> const & r);

[: 

[*Effects:] [^if(r.get() != 0) intrusive_ptr_add_ref(r.get());].

[*Postconditions:] [^get() == r.get()].

[heading destructor]

    ~intrusive_ptr();

[: 

[*Effects:] [^if(get() != 0) intrusive_ptr_release(get());].
]

[heading assignment]

    intrusive_ptr & operator=(intrusive_ptr const & r);
    template<class Y> intrusive_ptr & operator=(intrusive_ptr<Y> const & r);
    intrusive_ptr & operator=(T * r);

[: 

[*Effects:] Equivalent to [^intrusive_ptr(r).swap(*this)].

[*Returns:] [^*this].

]

[heading reset]

    void reset(T * r);

[: 

[*Effects:] Equivalent to [^intrusive_ptr(r).swap(*this)].
]

[heading indirection]

T & operator*() const; // never throws

[: 

[*Requirements:] [^get() != 0].

[*Returns:] [^*get()].

[*Throws:] nothing.
]


    T * operator->() const; // never throws

[: 

[*Requirements:] [^get() != 0].

[*Returns:] [^get()].

[*Throws:] nothing.
]

[heading get]

    T * get() const; // never throws

[: 

[*Returns:] the stored pointer.

[*Throws:] nothing.
]

[heading conversions]

    operator ['unspecified-bool-type] () const; // never throws

[: 

[*Returns:] an unspecified value that, when used in boolean contexts, is equivalent to [^get() != 0].

[*Throws:] nothing.

[*Notes:] This conversion operator allows [*intrusive_ptr] objects to be used in boolean contexts, like [^if (p && p->valid()) {}]. The actual target type is typically a pointer to a member function, avoiding many of the implicit conversion pitfalls.

]

[heading swap]

    void swap(intrusive_ptr & b); // never throws

[: 

[*Effects:] Exchanges the contents of the two smart pointers.

[*Throws:] nothing.
]

[endsect]

[section Free Functions]

[heading comparison]

    template<class T, class U>
      bool operator==(intrusive_ptr<T> const & a, intrusive_ptr<U> const & b); // never throws

[: 

[*Returns:] [^a.get() == b.get()].

[*Throws:] nothing.
]

    template<class T, class U>
      bool operator!=(intrusive_ptr<T> const & a, intrusive_ptr<U> const & b); // never throws

[: 

[*Returns:] [^a.get() != b.get()].

[*Throws:] nothing.
]

    template<class T, class U>
      bool operator==(intrusive_ptr<T> const & a, U * b); // never throws

[: 

[*Returns:] [^a.get() == b].

[*Throws:] nothing.
]


    template<class T, class U>
      bool operator!=(intrusive_ptr<T> const & a, U * b); // never throws

[: 

[*Returns:] [^a.get() != b].

[*Throws:] nothing.
]


    template<class T, class U>
      bool operator==(T * a, intrusive_ptr<U> const & b); // never throws

[: 

[*Returns:] [^a == b.get()].

[*Throws:] nothing.
]


    template<class T, class U>
      bool operator!=(T * a, intrusive_ptr<U> const & b); // never throws

[: 

[*Returns:] [^a != b.get()].

[*Throws:] nothing.
]


    template<class T, class U>
      bool operator<(intrusive_ptr<T> const & a, intrusive_ptr<U> const & b); // never throws

[: 

[*Returns:] [^std::less<T *>()(a.get(), b.get())].

[*Throws:] nothing.

[*Notes:] Allows intrusive_ptr objects to be used as keys in associative containers.
]

[heading swap]

    template<class T>
      void swap(intrusive_ptr<T> & a, intrusive_ptr<T> & b); // never throws

[: 

[*Effects:] Equivalent to [^a.swap(b)].

[*Throws:] nothing.

[*Notes:] Matches the interface of [*std::swap]. Provided as an aid to generic programming.
]

[heading get_pointer]

    template<class T>
      T * get_pointer(intrusive_ptr<T> const & p); // never throws

[: 

[*Returns:] [^p.get()].

[*Throws:] nothing.

[*Notes:] Provided as an aid to generic programming. Used by [@../bind/mem_fn.html mem_fn].
]

[heading static_pointer_cast]

    template<class T, class U>
      intrusive_ptr<T> static_pointer_cast(intrusive_ptr<U> const & r); // never throws

[: 

[*Returns:] [^intrusive_ptr<T>(static_cast<T*>(r.get()))].

[*Throws:] nothing.
]

[heading const_pointer_cast]

    template<class T, class U>
      intrusive_ptr<T> const_pointer_cast(intrusive_ptr<U> const & r); // never throws

[: 

[*Returns:] [^intrusive_ptr<T>(const_cast<T*>(r.get()))].

[*Throws:] nothing.
]

[heading dynamic_pointer_cast]

    template<class T, class U>
      intrusive_ptr<T> dynamic_pointer_cast(intrusive_ptr<U> const & r);

[: 

[*Returns:] [^intrusive_ptr<T>(dynamic_cast<T*>(r.get()))].

[*Throws:] nothing.
]

[heading operator<<]

    template<class E, class T, class Y>
        std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, intrusive_ptr<Y> const & p);

[: 

Effects: [^os << p.get();].

[*Returns:] [^os].
]

[endsect]

$Date: 2007/04/09 21:35:07 $

Copyright 2003-2005 Peter Dimov. Distributed under the Boost Software License, Version 1.0. See accompanying file [@../../LICENSE_1_0.txt LICENSE_1_0.txt] or copy at [@http://www.boost.org/LICENSE_1_0.txt http://www.boost.org/LICENSE_1_0.txt].

[endsect][/intrusive_ptr]