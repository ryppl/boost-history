[article smart_ptr
    [quickbook 1.4]
    [copyright 1999 Greg Colvin and Beman Dawes, 2002 Darin Adler, 2002 Peter Dimov]
    [purpose Five smart pointer class templates, from Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler.]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [authors [Colvin, Greg], [Dawes, Beman], [Dimov, Peter], [Adler, Darin]]
    [category memory]
]

[def __scoped_ptr__ [link smart_ptr.reference.scoped_ptr scoped_ptr]]
[def __scoped_array__ [link smart_ptr.reference.scoped_array scoped_array]]
[def __shared_ptr__ [link smart_ptr.reference.shared_ptr shared_ptr]]
[def __shared_array__ [link smart_ptr.reference.shared_array shared_array]]
[def __weak_ptr__ [link smart_ptr.reference.weak_ptr weak_ptr]]
[def __intrusive_ptr__ [link smart_ptr.reference.intrusive_ptr intrusive_ptr]]

[def __common_requirements__ [link smart_ptr.common_requirements common requirements]]
[def __smart_ptr_test__ [link smart_ptr.examples.smart_ptr_test smart_ptr_test.cpp]]

[def __boost_root__ http://www.boost.org]

[def __scoped_ptr_hpp__ [@http://www.boost.org/boost/scoped_ptr.hpp <boost/scoped_ptr.hpp>]]
[def __scoped_array_hpp__ [@http://www.boost.org/boost/scoped_array.hpp <boost/scoped_array.hpp>]]
[def __shared_ptr_hpp__ [@http://www.boost.org/boost/shared_ptr.hpp <boost/shared_ptr.hpp>]]
[def __shared_array_hpp__ [@http://www.boost.org/boost/shared_array.hpp <boost/shared_array.hpp>]]
[def __weak_ptr_hpp__ [@http://www.boost.org/boost/weak_ptr.hpp <boost/weak_ptr.hpp>]]
[def __intrusive_ptr_hpp__ [@http://www.boost.org/boost/intrusive_ptr.hpp <boost/intrusive_ptr.hpp>]]

[def __exception-specification__ [@http://www.boost.org/more/lib_guide.htm#Exception-specification exception-specification]]
[def __noncopyable__ [@http://www.boost.org/libs/utility/utility.htm#Class_noncopyable noncopyable]]
[def __auto_ptr__ [@http://en.wikipedia.org/wiki/Auto_ptr std::auto_ptr]]

[import ../test/smart_ptr_test.cpp]

[section:introduction Introduction]

Smart pointers are objects which store pointers to dynamically allocated (heap) objects. They behave much like
built-in C++ pointers except that they automatically delete the object pointed to at the appropriate time. Smart
pointers are particularly useful in the face of exceptions as they ensure proper destruction of dynamically
allocated objects. They can also be used to keep track of dynamically allocated objects shared by multiple owners.

Conceptually, smart pointers are seen as owning the object pointed to, and thus responsible for deletion of the
object when it is no longer needed.

The smart pointer library provides five smart pointer class templates:

[table Smart pointer class templates
[[class template][header][description]]
[[__scoped_ptr__]   [__scoped_ptr_hpp__]    [Simple sole ownership of single objects. Noncopyable.]]
[[__scoped_array__] [__scoped_array_hpp__]  [Simple sole ownership of arrays. Noncopyable.]]
[[__shared_ptr__]   [__shared_ptr_hpp__]    [Object ownership shared among multiple pointers]]
[[__shared_array__] [__shared_array_hpp__]  [Array ownership shared among multiple pointers.]]
[[__weak_ptr__]     [__weak_ptr_hpp__]      [Non-owning observers of an object owned by __shared_ptr__.]]
[[__intrusive_ptr__][__intrusive_ptr_hpp__] [Shared ownership of objects with an embedded reference count.]]
]

These templates are designed to complement the __auto_ptr__ template.

They are examples of the "resource acquisition is initialization" idiom described in Bjarne Stroustrup's
"The C++ Programming Language", 3rd edition, Section 14.4, Resource Management.

A test program, __smart_ptr_test__, is provided to verify correct operation.

A page on compatibility with older versions of the Boost smart pointer library describes some of the changes
since earlier versions of the smart pointer implementation.

A page on smart pointer timings will be of interest to those curious about performance issues.

A page on smart pointer programming techniques lists some advanced applications of __shared_ptr__ and __weak_ptr__.

[endsect]

[section:common_requirements Common Requirements]

These smart pointer class templates have a template parameter, `T`, which specifies the type of the object pointed
to by the smart pointer. The behavior of the smart pointer templates is undefined if the destructor or `operator
delete`  for objects of type `T` throw exceptions.

`T` may be an incomplete type at the point of smart pointer declaration. Unless otherwise specified, it is required
that `T` be a complete type at points of smart pointer instantiation. Implementations are required to diagnose
(treat as an error) all violations of this requirement, including deletion of an incomplete type. See the
description of the checked_delete function template.

Note that __shared_ptr__ does not have this restriction, as most of its member functions do not require `T` to be a
complete type.

[heading Rationale]

The requirements on `T` are carefully crafted to maximize safety yet allow handle-body (also called pimpl) and
similar idioms. In these idioms a smart pointer may appear in translation units where `T` is an incomplete type.
This separates interface from implementation and hides implementation from translation units which merely use the
interface. Examples described in the documentation for specific smart pointers illustrate use of smart pointers
in these idioms.

Note that __scoped_ptr__ requires that `T` be a complete type at destruction time, but __shared_ptr__ does not.

[endsect]

[section:exception_safety Exception Safety]

Several functions in these smart pointer classes are specified as having "no effect" or "no effect except
such-and-such" if an exception is thrown. This means that when an exception is thrown by an object of one of these
classes, the entire program state remains the same as it was prior to the function call which resulted in the
exception being thrown. This amounts to a guarantee that there are no detectable side effects. Other functions
never throw exceptions. The only exception ever thrown by functions which do throw (assuming T meets the common
requirements) is std::bad_alloc, and that is thrown only by functions which are explicitly documented as possibly
throwing std::bad_alloc.

[endsect]

[section:exception_specifications Exception-specifications]

Exception-specifications are not used; see __exception-specification__ rationale.

All the smart pointer templates contain member functions which can never throw exceptions, because they neither
throw exceptions themselves nor call other functions which may throw exceptions. These members are indicated by a
comment: `// never throws`.

Functions which destroy objects of the pointed to type are prohibited from throwing exceptions by the common
requirements.

[endsect]


[section:history_and_acknowledgements History and Acknowledgements]

January 2002. Peter Dimov reworked all four classes, adding features, fixing bugs, and splitting them into four
separate headers, and added __weak_ptr__. See the compatibility page for a summary of the changes.

May 2001. Vladimir Prus suggested requiring a complete type on destruction. Refinement evolved in discussions
including Dave Abrahams, Greg Colvin, Beman Dawes, Rainer Deyke, Peter Dimov, John Maddock, Vladimir Prus, Shankar
Sai, and others.

November 1999. Darin Adler provided operator ==, operator !=, and std::swap and std::less specializations for
shared types.

September 1999. Luis Coelho provided shared_ptr::swap and shared_array::swap

May 1999. In April and May, 1999, Valentin Bonnard and David Abrahams made a number of suggestions resulting in
numerous improvements.

October 1998. Beman Dawes proposed reviving the original semantics under the names safe_ptr and counted_ptr,
meeting of Per Andersson, Matt Austern, Greg Colvin, Sean Corfield, Pete Becker, Nico Josuttis, Dietmar K&#252;hl,
Nathan Myers, Chichiang Wan and Judy Ward. During the discussion, the four new class names were finalized, it was
decided that there was no need to exactly follow the std::auto_ptr interface, and various function signatures and
semantics were finalized.

Over the next three months, several implementations were considered for shared_ptr, and discussed on the boost.org
mailing list. The implementation questions revolved around the reference count which must be kept, either attached
to the pointed to object, or detached elsewhere. Each of those variants have themselves two major variants:

* Direct detached: the __shared_ptr__ contains a pointer to the object, and a pointer to the count.
* Indirect detached: the __shared_ptr__ contains a pointer to a helper object, which in turn contains a pointer to the
object and the count.
* Embedded attached: the count is a member of the object pointed to.
* Placement attached: the count is attached via operator new manipulations.

Each implementation technique has advantages and disadvantages. We went so far as to run various timings of the
direct and indirect approaches, and found that at least on Intel Pentium chips there was very little measurable
difference. Kevlin Henney provided a paper he wrote on "Counted Body Techniques." Dietmar K&#252;hl suggested an
elegant partial template specialization technique to allow users to choose which implementation they preferred,
and that was also experimented with.

But Greg Colvin and Jerry Schwarz argued that "parameterization will discourage users", and in the end we choose
to supply only the direct implementation.

Summer, 1994. Greg Colvin proposed to the C++ Standards Committee classes named auto_ptr and counted_ptr which
were very similar to what we now call scoped_ptr and shared_ptr. [Col-94] In one of the very few cases where the
Library Working Group's recommendations were not followed by the full committee, counted_ptr was rejected and
surprising transfer-of-ownership semantics were added to auto_ptr.

[endsect]

[section:references References]

[Col-94] Gregory Colvin, Exception Safe Smart Pointers, C++ committee document 94-168/N0555, July, 1994.

[E&D-94] John R. Ellis & David L. Detlefs, Safe, Efficient Garbage Collection for C++, Usenix Proceedings,
February, 1994. This paper includes an extensive discussion of weak pointers and an extensive bibliography.

[endsect]

[section:reference Reference]

[include scoped_ptr.qbk]
[include scoped_array.qbk]
[include shared_ptr.qbk]
[include shared_array.qbk]
[include weak_ptr.qbk]
[include intrusive_ptr.qbk]

[endsect][/reference]

[section:examples Examples]

[section:smart_ptr_test smart_ptr_test.cpp]
[smart_ptr_test]
[endsect][/smart_ptr_test]

[endsect][/examples]
