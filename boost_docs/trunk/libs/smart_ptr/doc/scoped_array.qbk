[def __reset__ [link smart_ptr.reference.scoped_array.members.reset reset]]
[def __element_type__ [link smart_ptr.reference.scoped_array.members.element_type element_type]]
[def __ctor__ [link smart_ptr.reference.scoped_array.members.constructors scoped_array]]
[def __destructor__ [link smart_ptr.reference.scoped_array.members.destructor ~scoped_array]]
[def __operatorlbrb__ [link smart_ptr.reference.scoped_array.members.subscripting operator\[\]]]
[def __get__ [link smart_ptr.reference.scoped_array.members.get]]
[def __operatorconv__ [link smart_ptr.reference.scoped_array.members.conversions operator ['unspecified-bool-type]]]
[def __swap__ [link smart_ptr.reference.scoped_array.members.swap swap]]
[def __free_swap__ [link smart_ptr.reference.scoped_array.free_functions.swap swap]]

[section:scoped_array scoped_array class template]

[section Introduction]

The __scoped_array__ class template stores a pointer to a dynamically allocated array. (Dynamically allocated arrays are allocated with the C++ [*new\[\]] expression.) The array pointed to is guaranteed to be deleted, either on destruction of the __scoped_array__, or via an explicit __reset__.

The __scoped_array__ template is a simple solution for simple needs. It supplies a basic "resource acquisition is initialization" facility, without shared-ownership or transfer-of-ownership semantics. Both its name and enforcement of semantics (by being __noncopyable__) signal its intent to retain ownership solely within the current scope. Because it is __noncopyable__, it is safer than __shared_array__ for pointers which should not be copied.

Because __scoped_array__ is so simple, in its usual implementation every operation is as fast as a built-in array pointer and it has no more space overhead that a built-in array pointer.

It cannot be used in C++ standard library containers. See __shared_array__ if __scoped_array__ does not meet your needs.

It cannot correctly hold a pointer to a single object. See __scoped_ptr__ for that usage.

A [*std::vector] is an alternative to a __scoped_array__ that is a bit heavier duty but far more flexible. A [*boost::array] is an alternative that does not use dynamic allocation.

The class template is parameterized on [*T], the type of the object pointed to. [*T] must meet the smart pointer __common_requirements__.

[endsect]

[section Synopsis]

    namespace boost {

      template<class T> class scoped_array : __noncopyable__ {

        public:
          typedef T __element_type__;

          explicit __ctor__(T * p = 0); // never throws
          __destructor__(); // never throws

          void __reset__(T * p = 0); // never throws

          T & __operatorlbrb__(std::ptrdiff_t i) const; // never throws
          T * __get__() const; // never throws
         
          __operatorconv__ () const; // never throws

          void __swap__(__scoped_array__ & b); // never throws
      };

      template<class T> void __free_swap__(scoped_array<T> & a, scoped_array<T> & b); // never throws

    }
    
[endsect]

[section Members]

[heading element_type]

    typedef T element_type;

Provides the type of the stored pointer.

[heading constructors]

    explicit scoped_array(T * p = 0); // never throws

Constructs a __scoped_array__, storing a copy of [*p], which must have been allocated via a C++ [*new][] expression or be 0. [*T] is not required be a complete type. See the smart pointer __common_requirements__.

[heading destructor]

    ~scoped_array(); // never throws

Deletes the array pointed to by the stored pointer. Note that [*delete[]] on a pointer with a value of 0 is harmless. The guarantee that this does not throw exceptions depends on the requirement that the deleted array's objects' destructors do not throw exceptions. See the smart pointer __common_requirements__.

[heading reset]

    void reset(T * p = 0); // never throws

Deletes the array pointed to by the stored pointer and then stores a copy of p, which must have been allocated via a C++ [*new[]] expression or be 0. The guarantee that this does not throw exceptions depends on the requirement that the deleted array's objects' destructors do not throw exceptions. See the smart pointer __common_requirements__.

[heading subscripting]

    T & operator[](std::ptrdiff_t i) const; // never throws

Returns a reference to element [*i] of the array pointed to by the stored pointer. Behavior is undefined and almost certainly undesirable if the stored pointer is 0, or if [*i] is less than 0 or is greater than or equal to the number of elements in the array.

[heading get]

    T * get() const; // never throws

Returns the stored pointer. [*T] need not be a complete type. See the smart pointer __common_requirements__.

[heading conversions]

    operator ``['unspecified-bool-type]`` () const; // never throws

Returns an unspecified value that, when used in boolean contexts, is equivalent to `__get__() != 0`.

[heading swap]

    void swap(scoped_array & b); // never throws

Exchanges the contents of the two smart pointers. [*T] need not be a complete type. See the smart pointer __common_requirements__.

[endsect]

[section Free Functions]

[heading swap]
    
    template<class T> void swap(scoped_array<T> & a, scoped_array<T> & b); // never throws

Equivalent to `a.__swap__(b)`. Matches the interface of `*std::swap`. Provided as an aid to generic programming.

Revised 09 January 2003

Copyright 1999 Greg Colvin and Beman Dawes. Copyright 2002 Darin Adler. Copyright 2002-2005 Peter Dimov. Distributed under the Boost Software License, Version 1.0. See accompanying file [@../../LICENSE_1_0.txt LICENSE_1_0.txt] or copy at [@http://www.boost.org/LICENSE_1_0.txt http://www.boost.org/LICENSE_1_0.txt].

[endsect]
[endsect][/scoped_array]