[/
/ Copyright © 1998-2003 Joel de Guzman
/ Copyright © 2007 Darren Garvey
/
/ Distributed under the Boost Software License, Version 1.0. (See accompanying
/ file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
/]

[section Rationale]

[section:vf Virtual functions: From static to dynamic C++]

Rules straddle the border between static and dynamic C++. In effect, a rule transforms compile-time polymorphism (using templates) into run-time polymorphism (using virtual functions). This is necessary due to C++'s inability to automatically declare a variable of a type deduced from an arbitrarily complex expression in the right-hand side (rhs) of an assignment. Basically, we want to do something like:

``
    T rule = an_arbitrarily_complex_expression;
``

without having to know or care about the resulting type of the right-hand side (rhs) of the assignment expression. Apart from this, we also need a facility to forward declare an unknown type:

``
    T rule;
    ...
    rule = a | b;
``

These limitations lead us to this implementation of rules. This comes at the expense of the overhead of a virtual function call, once through each invocation of a rule.

[endsect][/ vf]

[section:md Multiple declaration]

Some BNF variants allow multiple declarations of a rule. The declarations are taken as alternatives. Example:

``
   r = a;    
   r = b;
``

is equivalent to:

``
   r = a | b;
``

[link __Spirit v1.3] allowed this behavior. However, the current version of Spirit no longer allows this because experience shows that this behavior leads to unwanted gotchas (for instance, it does not allow rules to be held in containers). In the current release of Spirit, a second assignment to a rule will simply redefine it. The old definition is destructed. This follows more closely C++ semantics and is more in line with what the user expects the rule to behave.

[endsect][/ md]

[section:ss Sequencing Syntax]

The comma operator as in `a, b` seems to be a better candidate, syntax-wise. But then the problem is with its precedence. It has the lowest precedence in C/C++, which makes it virtually useless.

[@http://research.att.com/~bs Bjarne Stroustrup], in his article [link __references__.generalised_overloading "Generalizing Overloading for C++2000"] talks about overloading whitespace. Such a feature would allow juxtapositioning of parser objects exactly as we do in (E)BNF (e.g. `a b | c` instead of `a >> b | c`). Unfortunately, the article was dated April 1, 1998. Oh well.

[endsect][/ ss]

[section:fi Forward iterators]

In general, the scanner expects at least a standard conforming forward iterator. Forward iterators are needed for backtracking where the iterator needs to be saved and restored later. Generally speaking, Spirit is a backtracking parser. The implication of this is that at some point, the iterator position will have to be saved to allow the parser to backtrack to a previous point. Thus, for backtracking to work, the framework requires at least a forward iterator.

Some parsers might require more specialized iterators (bi-directional or even random access). Perhaps in the future, deterministic parsers when added to the framework, will perform no backtracking and will need just a single token lookahead, hence will require input iterators only.

[endsect][/ fi]

[section:subrules Why are subrules important?]

__Subrules__ open up the oportunity to do aggressive meta programming as well because they do not rely on virtual functions. The virtual function is the meta-programmer's hell. Not only does it slow down the program due to the virtual function indirect call, it is also an opaque wall where no metaprogram can get past. It kills all meta-information beyond the virtual function call. Worse, the virtual function cannot be templated. Which means that its arguments have to be tied to a actual types. Many problems stem from this limitation.

While Spirit is a currently classified as a non-deterministic recursive-descent parser, Doug Gregor first noted that other parsing techniques apart from top-down recursive descent may be applied. For instance, apart from non-deterministic recursive descent, deterministic LL(1) and LR(1) can theoretically be implemented using the same expression template front end. Spirit rules use virtual functions to encode the RHS parser expression in an opaque abstract parser type. While it serves its purpose well, the rule's virtual functions are the stumbling blocks to more advanced metaprogramming. Subrules are free from virtual functions.

[endsect][/ subrules]

[section:greedy Exhaustive backtracking and greedy RD]

Spirit doesn't do exhaustive backtracking like regular expressions are expected to. For example:

``
    *chlit_p('a') >> chlit_p('a');
``

will always fail to match because Spirit's Kleene star does not back off when the rest of the rule fails to match.

Actually, there's a solution to this greedy RD (recursive-descent) problem. Such a scheme is discussed in section 6.6.2 of [@http://www.cs.vu.nl/%7Edick/PTAPG.html Parsing Techniques: A Practical Guide]. The trick involves passing a tail parser (in addition to the scanner) to each parser. The start parser will then simply be: `start >> end_p;` (`end_p` is the start's tail).

Spirit is greedy, using straight forward, naive RD. It is certainly possible to implement the fully backtracking scheme presented above, but there will be also certainly be a performance hit. The scheme will always try to match all possible parser paths (full parser hierarchy traversal) until it reaches a point of certainty, that the whole thing matches or fails to match.

[note
Backtracking and Greedy RD

Spirit is quite consistent and intuitive about when it backtracks and to where, although it may not be obvious to those coming from different backgrounds. In general, any (sub)parser will, given the same input, always match the same portion of the input (or fail to match the input at all). This means that Spirit is inherently greedy. Spirit will only backtrack when a (sub)parser fails to match the input, and it will always backtrack to the next choice point upward (not backward) in the parser structure. In other words `abb|ab` will match `"ab"`, as will `a(bb|b)`, but `(ab|a)b` won't because the `(ab|a)` subparser will always match the `'b'` after the `'a'` if it is available.

--Rainer Deyke
]

There's a strong preference on "simplicity with all the knobs when you need them" approach, right now. On the other hand, the flexibility of Spirit makes it possible to have different optional schemes available. It might be possible to implement an exhaustive backtracking RD scheme as an optional feature in the future. 

[endsect][/ greedy]

[endsect][/ rationale]

