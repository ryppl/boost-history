[/
/ Copyright © 1998-2003 Joel de Guzman
/ Copyright © 2007 Darren Garvey
/
/ Distributed under the Boost Software License, Version 1.0. (See accompanying
/ file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
/]

[section:dynamic_p Dynamic Parsers]

We see dynamic parsing everywhere in Spirit. A special group of parsers, aptly named dynamic parsers, form the most basic building blocks to dynamic parsing. This chapter focuses on these critters. You'll notice the similarity of these parsers with C++'s control structures. The similarity is not a coincidence. These parsers give an imperative flavor to parsing, and, since imperative constructs are not native to declarative EBNF, mimicking the host language, C++, should make their use immediately familiar.

Dynamic parsers modify the parsing behavior according to conditions. Constructing dynamic parsers requires a condition argument and a body parser argument. Additional arguments are required by some parsers.

[section Conditions]

Functions or functors returning values convertable to bool can be used as conditions. When the evaluation of the function/functor yields true it will be considered as meeting the condition.

Parsers can be used as conditions, as well. When the parser matches the condition is met. Parsers used as conditions work in an all-or-nothing manner: the scanner will not be advanced when they don't match.

A failure to meet the condition will not result in a parse error.

[h3 `if_p`]

`if_p` can be used with or without an else-part. The syntax is:

``
    if_p(condition)[then-parser]
``

or

``
    if_p(condition)[then-parser].else_p[else-parser]
``

When the condition is met the then-parser is used next in the parsing process. When the condition is not met and an else-parser is available the else-parser is used next. When the condition isn't met and no else-parser is available then the whole parser matches the empty sequence. 

[note Note: older versions of `if_p` report a failure when the condition isn't met and no else-parser is available.]

Example:

``
    if_p("0x")[hex_p].else_p[uint_p]
``

[h3 `while_p, do_p`]

`while_p/do_p` syntax is:

``
    while_p(condition)[body-parser]
    do_p[body-parser].while_p(condition)
``

As long as the condition is met the dynamic parser constructed by `while_p` will try to match the body-parser. `do_p` returns a parser that tries to match the body-parser and then behaves just like the parser returned by `while_p`. A failure to match the body-parser will cause a failure to be reported by the while/do-parser.

[endsect][/ FIXME(put this here?): conditions]

Example:

``
    uint_p[assign_a(sum)] >> while_p('+')[uint_p(add(sum)]
    '"' >> while_p(~eps_p('"'))[c_escape_ch_p[push_back_a(result)]] >> '"'
``

[h3 `for_p`]

`for_p` requires four arguments. The syntax is:

``
    for_p(init, condition, step)[body-parser]
``

`init` and `step` have to be 0-ary functions/functors. `for_p` returns a parser that will:

1. call `init`
2. check the condition, if the condition isn't met then a match is returned. The match will cover everything that has been matched successfully up to this point.
3. tries to match the body-parser. A failure to match the body-parser will cause a failure to be reported by the for-parser
4. calls `step`
5. goes to 2.

[endsect][/ dynamic_p]

