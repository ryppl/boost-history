[heading Requisites]

We assume in this tutorial that all the header files are included, as shown in section [link full_include Organization]
and
``
	using namespace boost::assign::v2;
``

Headers from other libraries will not be shown in the code snippets of this tutorial, but they can be found in the tutorial's 
actual [@../../tutorial.cpp source file].

[heading Automatic behavior]

We refer, here, to the [link boost_assign_v2.intro introduction]'s example and recall that the ['interpreter] returned by `__fun_put__` is 
variadic and that its arguments are forwarded to a generator of the container's data-member. 
See [link data_gen_rules here] for further detail. 
Furthermore, it also determines an appropriate ['modifier], `insert` in case of a map, based on a set of [link modifier_rules rules],
such that the interface is uniform across different container categories.

[heading Range as argument list]

Consider this example:
[tutorial_assign]

The interpreter is invoked over one set of values (`"+"`, `"-"`, etc.), each specified individually, and another set passed as a 
[tpl_concept_range range] with a special wrapper around it, `__fun_as_arg_list__`, whose elements are parsed individually.

[heading Piping]

Here, we'd like to put a set of values in a container, and in the same statement, pass it through a mutating [tpl_range_algo algorithm]:
[tutorial_piping]
The statement inside the first argument to the algorithm is equivalent to `__fun_put__( __cont__ )( 0 )( 1 )( 2 )( 3 )( 4 )( 5 ).container()`,
the last step of which returns a reference to `__cont__`.The vertical bar, `|`, expresses the on-the-fly modification we were looking for, that we term [link boost_assign_v2.reference.pipe ['piping]]
after the related [tpl_pipe idiom] by the same name [footnote Also see [tpl_range_adaptor Boost.Range ]'s version ]. In addition, notice prefix 
`csv`[footnote ['csv] stands for comma separated values]. By convention, it indicates that each of values in the argument
list is forwarded to the interpreter. Also see section [link csv Csv].

[heading Pointer-containers]

To insert elements in a [tpl_ptr_container pointer container], pretend it is a value-container:
[tutorial_ptr_container]

[heading Container generation]

Having, in the same statement, assigned `cont` and passed it through a 
[@http://www.boost.org/doc/libs/1_46_0/libs/range/doc/html/range/reference/algorithms/mutating/stable_partition.html stable partition] algorithm, 
let's verify the state of the container against that of an in place generated container:
[tutorial_container_generation]

In keeping with our ['csv] convention, container generating function `__fun_csv_deque__` is paired to `__fun_deque__`, which is akin to `__fun_put__`.

[heading Options]

Either of the automatically deduced data-generator or the modifier can be overriden using operator `%` in conjunction with an ['option].
The relevant section is __link_option__. In addition to the [link boost_assign_v2.reference.option  standard modifiers] such as `__kwd_push_back__`,  
the library caters to more complex needs, e.g.
[tutorial_option]

[link option_modifier Extending] the library with a new modifier-option is fairly easy, thanks to macros that manage the overhead.

[/* Create a class template, called a ['tag], that identifies the new class of modifiers. The template parameter specifies a variable aspect of the implementation.
* Specialize a library declared [link interpreter_modifier modifier] on ['tag] to model a concept, with the desired semantics.
* Register the above by expanding two macros taking as input the desired option name and some meta-information.]

[heading Reference arrays]

In the example that precedes, [link boost_assign_v2.reference.ref  `__fun_ref_csv_array__`] could be substituted for `__fun_csv_deque__`. 
The reciprocal is not true, in general, because [link boost_assign_v2.reference.ref  `__fun_ref_csv_array__`] returns a reference-array. The latter
is preferable if the values are expensive to copy, and necessary for working specifically with references, such as as follows:
[tutorial_ref_array]

[heading Chaining]

Chaining ranges is already provided as [tpl_range_join `join`] in __url_boost__. Here's a variant that caters to reference arrays:
[tutorial_chain]

It is noteworthy that this algorithm modifies `six`, `seven` and `eight` even though the array returned by `ref::csv_array` is 
an rvalue. The keyword `ref::_get` is necessary in conjunction with a reference array whose references are to be modified (in read mode, instead, 
implicit conversion takes care of it). 

[heading Conversion]

At container exposes at least a copy constructor, therefore combining a container generating function with a conversion tool is a recipe
for initializing a container from a [tpl_concept_range range]:
[tutorial_conversion]

The conversion, here, is implicit, and is made possible by a conversion operator fitted to the object returned by `__fun_converter__`. See the 
relevant [link boost_assign_v2.reference.conversion section] about explicit conversion.


