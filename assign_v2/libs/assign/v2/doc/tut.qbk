[heading Requisites]

As shown in section [link boost_assign_v2.org Organization], we assume in this tutorial that all the header files are included, and, in
addition,
``
	using namespace boost::assign::v2;
``

Headers from other libraries will not be shown in the code snippets of this tutorial, but they can be found in the tutorial's 
actual [@../../tutorial.cpp source file].

[heading Assigning]

In the [link boost_assign_v2.intro introduction]'s example we encountered the operation which gives this library
its name, assign-ment, in this case, of an [tpl_boost_array array]'s elements. Throughout this library, we call 
[link boost_assign_v2.reference.interpreter ['interpreter]] the object returned by [link boost_assign_v2.reference.put `__fun_put__( __cont__ )`]. 
In this example, it was invoked over one set of values (`"+"`, `"-"`, etc.), each specified individually, and another set passed as a 
[tpl_concept_range range] with a special wrapper around it, `__fun_as_arg_list__( numeric )`. The wrapper tells the interpreter to process each of
its elements as individual arguments.

[heading Pointer-containers]

The same interface works similarly for pointer containers [footnote One exception is `ptr_map<>` whose implementation is pending]:
[tutorial_ptr_container]

[heading Csv]

The call to `csv` that just precedes [footnote ['csv] stands for comma separated values] is equivalent to `__fun_put__( assoc )( x )( y )( z )`. 
Similarly, where ['csv] is the prefix of a generating function's identifier, it indicates that a unary functor, whose identifier is a namesake
of the suffix, is evaluated successively for each of the arguments. For example, container generating function `__fun_csv_deque__` is 
paired to `__fun_deque__`, and `__fun_ref_csv_array__` is paired to `__fun_ref_array__`.

[heading Piping]

Here, we'd like to put a set of values in a container, and in the same statement, pass it through a mutating [tpl_range_algo algorithm]:
[tutorial_piping]

It is the vertical bar, `|`, which expresses the on-the-fly modification we were looking for. Such an expression is referred to as 
[link boost_assign_v2.reference.pipe ['piping]] throughout this library, after the related [tpl_pipe idiom] by the same name
[footnote Also see [tpl_range_adaptor Boost.Range ]'s version ]. What it does is equivalent to invoking `csv( __fun_put__( __cont__ ), 0, 1, 2, 3, 4, 5 )` but,
in addition, returns `__cont__`.

[heading Container generation]

Having, in the same statement, assigned `cont` and passed it through a [@http://www.boost.org/doc/libs/1_46_0/libs/range/doc/html/range/reference/algorithms/mutating/stable_partition.html stable partition algorithm], 
let's verify that what was intended matches the state of the container:
[tutorial_container_generation]

[heading Reference arrays]

There are two other container generating functions, [link boost_assign_v2.reference.ref `__fun_ref_array__`], 
and [link boost_assign_v2.reference.ref  `__fun_ref_csv_array__`].  The returned container is, more specifically, an array of reference wrappers, 
which we designate as ['reference array] in this library. In the example that precedes, either could be substituted for `__fun_csv_deque__`. The
reciprocal is not true, in general. A reference array is preferable if the values are expensive to copy, and necessary for working specifically with
references, such as as follows:

[tutorial_ref_array]

[heading Chaining]

Chaining ranges is already provided as [tpl_range_join `join`] in __url_boost__. Here's a variant that caters in special way to reference arrays:
[tutorial_chain]

The odd thing to notice is that this algorithm modifies `six`, `seven` and `eight` even though the array returned by `ref::csv_array` is 
an rvalue. The keyword `ref::_get` is necessary in conjunction with a reference array whose references are to be modified (in read mode, instead, 
implicit conversion takes care of it). 

[heading Conversion]

Even a not so standard container, such as a [tpl_stl_adapter container adapter], can be copy constructed from a container of the
same type. Combining a container generating function with a conversion tool gives us the recipe, therefore, for initializing such 
(and more versatile) containers:
[tutorial_conversion]

The conversion, here, is implicit, and is made possible by a conversion operator fitted to the object returned by `__fun_converter__`. See the 
relevant [link boost_assign_v2.reference.utility.conversion section] about explicit conversion.

[heading Data-member generation]

The capabalities of `__fun_put__` and `__deque__` vs their csv counterparts become apparent when we need to forward arguments to the  `__cont__`'s value-type. For example, 
[tutorial_data_gen]

[heading Automatic deduction]

We have seen that `__fun_put__` was applied to different containers, whether [tpl_boost_array arrays], [tpl_stl_assoc Associative] containers, etc.
This follows from an internal mechanism that deduces from the container's type appropriate

* Data-generation.  The rules are [link data_gen_rules here]
* Modifier. The rules are [link modifier_rules here].

[heading Options]

Either of the implementation components just mentioned can be overriden. Operator `%` is reserved for this kind of task and can be composed. The
relevant section is __link_option__. 

In addition to the [link boost_assign_v2.reference.option  standard modifiers] such as `__kwd_push_back__`,  the library caters to more complex needs
e.g.
[tutorial_optional]

[heading Custom options]

[link boost_assign_v2.reference.option Extending] the library with new modifiers is fairly easy. We briefly summarize how:

* Create a class template, called a ['tag], that identifies the new class of modifiers. The template parameter specifies a variable aspect of the implementation.
* Specialize a particular [link boost_assign_v2.reference.interpreter.modifier class template] on ['tag], with the desired implementation, within the constraints of a concept.
* Tell the library to register the above by expanding two macros taking as input the desired parameter name and some meta-information.

