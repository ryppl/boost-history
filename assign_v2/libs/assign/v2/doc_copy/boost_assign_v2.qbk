[library Boost.Assign
    [quickbook 1.5]
    [version 2.0]
    [authors [Thorsten, Ottosen],[Rogard, Erwann]]
    [copyright 2003-2004 Thorsten Ottosen, 2010 Erwann Rogard]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [id boost_assign_v2]
]

[/Support]

[def __TO__						[@http://www.boost.org/users/people/thorsten_ottosen.html TO]]
[def __ER__						[@mailto:erDOTciDOT2020ATgmailDOTcom ER]]

[template tpl_user_mailing_list[var]		[@http://www.boost.org/community/groups.html#users [var]]]
[def __user_mailing_list__      			[tpl_user_mailing_list Boost Users Mailing List]]
[def __url_boost_assign_v2_mini_review__ 	[@http://lists.boost.org/Archives/boost/2010/06/168028.php mini-review]]


[/ C++ Standard ]

[def __cpp03__ C++03]
[def __cpp0x__ C++0x]
[template tpl_cpp03[var] [@http://en.wikipedia.org/wiki/C%2B%2B03 [var]]]
[template tpl_cpp0x[var] [@http://www2.research.att.com/~bs/C++0xFAQ.html [var]]]
[def __url_cpp03__ [tpl_cpp03 __cpp03__]]
[def __url_cpp0x__ [tpl_cpp0x __cpp0x__]]

[/ Platform]

[def __mac_os__ OS X 10.6.5]
[def __mac_default_compiler__ gcc4.2]
[def __mac_processor__ 2.4 Ghz Intel Core 2 Duo]
[def __mac_mem__ 4GB 1067 Mhz DDR3]

[def __fink__ Fink]
[template tpl_fink[var] [@http://www.finkproject.org/ [var]]]
[def __url_fink__ [tpl_fink __fink__]]

[/ Libraries ]

[def __boost_assign_v1__ 								Boost.Assign 1.0]
[template tpl_boost_assign_v1[var] 						[@../../../../../libs/assign/doc/index.html [var]]]
[def __url_boost_assign_v1__ 							[tpl_boost_assign_v1 __boost_assign_v1__]]

[def __boost_assign_v2__ 								Boost.Assign 2.0]
[template tpl_boost_assign_v2[var] 						[@./index.html [var]]]
[def __url_boost_assign_v2__ 							[tpl_boost_assign_v2 __boost_assign_v2__]]

[def __boost__											Boost]
[template tpl_boost[var] 								[@http://www.boost.org [var]]]
[def __url_boost__ 										[tpl_boost __boost__]]

[template tpl_boost_array[var] 							[@http://www.boost.org/doc/libs/release/doc/html/array.html [var]]]

[template tpl_mpl[var] 									[@http://www.boost.org/libs/mpl/index.html [var]]]
[def __mpl__ 											[tpl_mpl MPL]]

[template tpl_stl[var] 									[@http://en.wikipedia.org/wiki/Standard_Template_Library [var]]]
[def __stl__ 											[tpl_stl STL]]

[template tpl_stl_assoc[var] 							[@http://www.sgi.com/tech/stl/AssociativeContainer.html [var]]]
[template tpl_stl_seq[var] 								[@http://www.sgi.com/tech/stl/Sequence.html [var]]]
[template tpl_stl_adapter[var]							[@http://flylib.com/books/en/2.674.1.106/1/ [var]]]
[template tpl_stl_deque[var] 							[@http://www.sgi.com/tech/stl/Deque.html [var]]]
[template tpl_stl_cont[var]								[@http://www.sgi.com/tech/stl/Container.html [var]]]


[template tpl_lambda[var] 								[@http://www.boost.org/doc/libs/release/doc/html/lambda.html [var]]]
[def __lambda__											[tpl_lambda lambda]]

[template tpl_ptr_container[var] 						[@http://www.boost.org/doc/libs/release/libs/ptr_container/doc/ptr_container.html [var]]]

[template tpl_range[var] 								[@http://www.boost.org/doc/libs/release/libs/range/index.html [var]]]

[template tpl_range_adaptor[var] 						[@http://svn.boost.org/svn/boost/trunk/libs/range/doc/html/range/reference/adaptors.html [var]]]
[template tpl_range_adaptor_compose[var] 				[@http://svn.boost.org/svn/boost/trunk/libs/range/doc/html/range/reference/adaptors/introduction.html#range.reference.adaptors.introduction.composition_of_adaptors [var]]]
[template tpl_range_algo[var] 							[@http://svn.boost.org/svn/boost/trunk/libs/range/doc/html/range/reference/algorithms.html [var]]]
[template tpl_range_join[var]							[@http://svn.boost.org/svn/boost/trunk/boost/range/join.hpp [var]]]
[template tpl_itr[var]						            [@http://svn.boost.org/svn/boost/trunk/libs/range/doc/html/range/reference/utilities/iterator_range.html [var]]]

[/Concepts]

[template tpl_meta_fun[var] 					[@http://svn.boost.org/svn/boost/trunk/libs/mpl/doc/refmanual/metafunction.html [var]]]
[template tpl_meta_fun_class[var]				[@http://svn.boost.org/svn/boost/trunk/libs/mpl/doc/refmanual/metafunction-class.html [var]]]

[/Headers]

[template tpl_boost_trunk [var]										[@http://svn.boost.org/svn/boost/trunk [var]]]
[def __boost_trunk__												[tpl_boost_trunk [^boost-trunk]]]

[template tpl_boost_type [var]										[@http://svn.boost.org/svn/boost/trunk/boost/type.hpp [var]]]
[def __boost_type__													[@http://svn.boost.org/svn/boost/trunk/boost/type.hpp boost::type]]

[template tpl_dir_boost_assign_v2[var] 								[@../../../../../boost/assign/v2 [var]]]
[def __dir_boost_assign_v2__ 										[tpl_dir_boost_assign_v2 boost/assign/v2]]

[template tpl_dir_libs_assign_v2[var] 								[@../../ [var]]]
[def __dir_libs_assign_v2__ 										[tpl_dir_libs_assign_v2 libs/assign/v2]]

[template tpl_dir_libs_assign_v2_example [var] 						[@../../example [var]]]
[def __dir_libs_assign_v2_example__ 								[tpl_dir_libs_assign_v2_example libs/assign/v2/example]]


[/Files]

[template tpl_foo_h[var] [@../../example/foo.h [var]] ] 
[template tpl_foo_cpp[var] [@../../example/foo.cpp [var]] ] 
[template tpl_ex[var] [@../../example/ [var]] ] 
[template tpl_test[var] [@../../test/ [var]] ] 

[/Concepts]

[template tpl_concept_range[var] [@http://svn.boost.org/svn/boost/trunk/libs/range/doc/html/range/concepts/overview.html [var]]]

[template tpl_crtp[var] [@http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern [var]]]
[def __crtp__ [tpl_crtp crtp]]

[/ CodeLinks]

[def __put_param_pair__		pair]
[def __put_modifier__		modifier]

[def __kwd_csv_put__		_csv_put]
[def __kwd_put__			_put]
[def __kwd_lookup__			_lookup]
[def __kwd_repeat__			_repeat]

[def __sub_range__			sub_range]

[def __put_range__			put_range]
[def __lk_put_range__		[link boost_assign_v2.put.pipe.range __put_range__]]

[def __converter__			converter]

[def __foo__				foo]
[def __foo_type__			Foo]

[/ Templates]

[def __type_ext__ _]
[template tpl_join[a b][a][b]]
[template tpl_typeof[object][tpl_join [object]..__type_ext__]]
[template tpl_seq[index first last] [index] = [first], ..., [last]]
[template tpl_sub[var index] [var]\[[index]\] ]
[template tpl_sub_sub[var index1 index2] [var]\[[index1],[index2]\]]

[/ Note]

[def __header_explicit__ This header has to be explicitly included]

[/ Notation ]

[def __ns_as2__					boost::assign::v2]

[def __implem_defined__ 		'''<replaceable>implementation-defined</replaceable>''']
[def __put_implem__ 			'''<replaceable>put-implementation</replaceable>''']
[def __custom_param__			'''<replaceable>param</replaceable>''']
[def __custom_param_kwd__		'''<replaceable>param_keyword</replaceable>''']
[def __kwd_custom_param__		'''<replaceable>_param</replaceable>''']
[def __param_arg__				'''<replaceable>param_arg</replaceable>''']
[def __custom_fun__				'''<replaceable>fun</replaceable>''']

[def __container__				cont]
[def __map__					map]
[def __list__					list]
[def __from__					from]
[def __from_type_				From]
[def __to__						to]
[def __to_type__				To]
[def __container_type__			Cont]
[def __container___				[tpl_typeof __container__]]
[def __value__					t]
[def __value___					[tpl_typeof __value__]]
[def __value_type__				T]
[def __f__						f]
[def __f___						F]
[def __object__					obj]
[def __range__					r]
[def __range_type__				R]
[def __array__					ar]
[def __array_type__				Ar]

[def __kwd_fun__				_fun]
[def __kwd_nil__				_nil]
[def __param__					p]
[def __kwd_param__				_p]
[def __param___					[tpl_typeof __param__]]
[def __param_type__				P]
[def __param_index__			l]
[def __param_count__			m]

[def __kwd_push_back__			_push_back]
[def __kwd_push_front__			_push_front]
[def __kwd_push__				_push]
[def __kwd_insert__				_insert]

[def __kwd_repeat__				_repeat]
[def __kwd_iterate__			_iterate]
[def __kwd_lookup__				_lookup]

[def __kwd_get__				_get]

[def __kwd_chain__				_chain]

[/Ranges]
[def __r1__						r1]
[def __r1_type__				R1]
[def __r2__						r2]
[def __r2_type__				R2]

[def __1st_value__				x]
[def __2nd_value__				y]
[def __3rd_value__				z]
[def __i__						i] 
[def __n__						n]

[def __arg__ 					arg]
[def __1st_of_arg__ 			a]
[def __2nd_of_arg__ 			b]
[def __3rd_of_arg__ 			c]
[def __j__						j]
[def __k__						k]

[section:intro Introduction]

This library has grown out of __url_boost_assign_v1__ but is functionally independent of it. It provides a small set of tools for carrying out operations 
that can be characterized as either putting a set of values in a container, in simple or complex ways, or manipulating references through a 
[tpl_concept_range range-like] interface. These are referred to as the [link boost_assign_v2.put ['put]] and [link boost_assign_v2.ref ['ref]]
frameworks, respectively. Each allows to code in one sweep, what would ordinarily require repetitive statements, and integrates nicely with 
[tpl_range_algo range algorithms]. [link boost_assign_v2.util Utilities] bridging the above with other container or range functionality are provided. 
The library is open for [link boost_assign_v2.put.modulo.modifier.ext.custom extension] with the help of macros.

[endsect]
[section:qs Quickstart]

To be able to use this library, it is ['necessary] to put the [tpl_boost_trunk directory] containing the __url_boost__ library in the search path of the C++ 
compiler and it ['suffices] to declare
``
	#include <boost/assign/v2.hpp>	
	using namespace __ns_as2__;
``
in order to bring the functionality [footnote Exceptions are singled out by this mention : __header_explicit__] into scope. The examples that follow are taken from actual [tpl_ex source files] that conform to 
certain [link boost_assign_v2.conv.ex conventions], notably that `as2` is the alias for the above `namespace`[footnote Why not use unqualified names, given
the above `using` declaration? To make sure the reader is able to distinguish this library's functionality from that of others which also appears in the 
examples.] .

[import ../example/put/pipe.cpp]
A typical [link boost_assign_v2.put ['put]] call is
[map2]
Each call to `__kwd_put__()` executes two steps. The first forwards each set of arguments to the value-type of `cont`, yielding a value that 
we label `__value__`. The second calls `__container__.insert( __value__ )`, as deemed appropriate by the library, for this category of container 
([tpl_stl_assoc Associative] ). 

The user may wish to override the library's default choice, which is accomodated by a [link boost_assign_v2.put.modulo parameter passing] mechanism. 
Below is an example in which `push_front()` is requested for executing the second step:
[list]
The keyword `__kwd_push_front__` is one of several parameters, some of which perform complex tasks, that are available. In addition, this library makes 
it easy, through the use of macros, to  [link boost_assign_v2.put.modulo.modifier.ext.custom extend the repertoire].

[import ../example/ref/array.cpp]
Framework [link boost_assign_v2.ref ['ref]] provides a generalization of the reference wrapper to an array (like [tpl_boost_array `boost::array<>`], not C-style) e.g.
[csv_array_w]

[link boost_assign_v2.util Utility] that inter-operates with the above are

# [link boost_assign_v2.util.convert Conversion] between containers
# Extending the interface to accomodate such tasks as [link boost_assign_v2.util.sub_range comparison].
# [link boost_assign_v2.util.chain Chaining] ranges, including reference-arrays.

[endsect][/ using]
[section:conv Convention]

In this section, we invite the reader to become acquainted with the conventions used in this documentation. They are hopefully intuitive so that the impatient 
reader can alternatively skip them. 

[section:symb Symbols]

[table 
	[[Symbol][Description]]
	[
		[`__container__`]
		[ A container] 
	]
	[
		[`__value__`]
		[ A value ] 
	]
	[	
		[`__arg__`]
		[ Arguments to a function ]
	]
]

Identifier `__value_type__` represents the type of `__value__` Likewise, `__container_type__` is the type of `__container__` etc.

[endsect][/symb]
[section:index Index]

[table Indexes
	[ 
		[ Expression ] 
		[ Description] 
	]
	[ 
		[ [^[tpl_seq [^__i__]..0..[^__n__]-1]] ] 
		[Indexes a sequence of `__value__`'s] 
	]
	[ 
		[ [^[tpl_seq [^__j__]..0..[^__k__]-1]] ] 
		[Indexes arguments of a [^__k__]-ary function] 
	]
	
]

[table Brackets
	[ 
		[ Expression ] 
		[ Description] 
	]
	[ 
		[ [tpl_sub [^__value__]..[^__i__]] ] 
		[ [^__i__]th value ]
	]
	[ 
		[ [tpl_sub [^__arg__]..[^__j__]] ] 
		[ [^__j__]th argument at unspecified [^__i__] ]
	]
	[ 
		[ [tpl_sub_sub [^__arg__]..[^__i__]..[^__j__]] ] 
		[ [^__j__]th argument at [^__i__] ]
	]
]

[table Alias
	[ 
		[ Expression ] 
		[ Description] 
	]
	[ 
		[ [^__1st_value__], [^__2nd_value__], [^__3rd_value__] ] 
		[ [tpl_sub [^__value__]..[^0]], [tpl_sub [^__value__]..[^1]], [tpl_sub [^__value__]..[^2]] ]
	]
	[ 
		[ [^__1st_of_arg__], [^__2nd_of_arg__], [^__3rd_of_arg__] ] 
		[ [tpl_sub [^__arg__]..[^0]], [tpl_sub [^__arg__]..[^1]], [tpl_sub [^__arg__]..[^2]]]
	]
]

[heading Example]

``
	__value_type__ __1st_value__, __2nd_value__( __1st_of_arg__, __2nd_of_arg__ );
``

[endsect][/index]
[section:syn  Synopsis]

In any code snippet under heading [*Synopsis], and more generally those that describe a feature, identifiers in the `namespace` of this library, 
`__ns_as2__`, are ['not] fully qualified. Another way to say this, is to assume that the code is preceded by the following `using` declaration.
``
	using namespace __ns_as2__;
``

Code that describes a feature is expressed in terms of [link boost_assign_v2.conv.symb symbols] and [link boost_assign_v2.conv.index indexes], 
never actual data-types (such as `int`). 

[endsect][/ syn]
[section:ex  Example]

Snippets of code under heading [*Example] are assumed to be preceded by the statement under heading [*Header] appearing in the nearest enclosing 
section (if not the current one, that of the top level etc.). Furthermore, it is assumed that identifiers defined in the `namespace` of this library are 
fully qualified, with following alias as prefix:
``
	namespace as2 = __ns_as2__;
``
Another alias that appears in examples is 
``
	namespace bl = boost::lambda;
``

Headers or definitions that are not part of this library are not explicitly included in the documentation. They can be found in the sources files of the examples 
located in this [tpl_ex directory]. 

[endsect][/ ex]
[endsect][/ conv]
[section:put Put ]

[heading Header]

[def __header_put__ [@../../../../../boost/assign/v2/put.hpp boost/assign/v2/put.hpp]]

``
	#include <__header_put__>
``

[section:pipe `operator|()` ]

[heading Header]

[def __header_put_pipe__ [@../../../../../boost/assign/v2/put/pipe.hpp boost/assign/v2/put/pipe.hpp]]

``
	#include <__header_put_pipe__>
``

[heading Description]

The semantics of `operator|()`, in this library, emulate those of [tpl_range_adaptor range adaptors] to the extent that they 
are [tpl_range_adaptor_compose composable] and therefore convenient in conjunction with [tpl_range_algo  range algorithms]. 
In the context of [tpl_range_adaptor range adaptors], expression
``
	lhs | rhs
``
maps a [tpl_concept_range range], identified by `lhs`, according to specifications encapsulated by `rhs`. In our context,  
['unless otherwise stated], `lhs` is a [tpl_stl_cont Container] and the above expression modifies its state according to specifications 
embodied by `rhs`, and then returns `lhs` by reference.

[section:csv `__kwd_csv_put__`]

[heading Header]

[def __header_put_pipe_csv__ [@../../../../../boost/assign/v2/put/pipe/csv.hpp boost/assign/v2/put/pipe/csv.hpp]]

``
	#include <__header_put_pipe_csv__>
``

[heading Synopsis]

[table 
	[ [Expression][ Result ][ Side effect ] ]
	[
		[`__container__ | __kwd_csv_put__( __value__[0], ....,__value__[__n__-1] )`]
		[A reference to `__container__`]
		[Puts `__value__[0]`, ....,`__value__[__n__-1]` in  `__container__`] 
	]
]

[heading Modifier]
[#csv_modifier]
The particular side effect is determined by the `__container__` 's category ([tpl_stl_seq Sequence], [tpl_stl_assoc Associative] etc.),
and can be found under [*Keywords] in [link boost_assign_v2.put.modulo.modifier.std.key this section]. 

[heading Miscellanea]
[#csv_misc]

In the right hand side of `operator|`, the result of `__kwd_csv_put__()` internally keeps references to its arguments so as to avoid any storage overhead.

[heading Example]

[vector]

[endsect][/ csv]
[section:functor `__kwd_put__`]

[heading Header]

[def __header_put_pipe_functor__ [@../../../../../boost/assign/v2/put/pipe/functor.hpp boost/assign/v2/put/pipe/functor.hpp]]

``
	#include <__header_put_pipe_functor__>
``

[heading Introduction]

Consider this example
[map]
Instead of explicitly calling `type()` for each set of arguments, what we'd like, the topic of this section, is to automatically forward to the constructor.

[heading Synopsis]

In terms of our [link boost_assign_v2.conv.index notation], for [^__n__ = 1], 

[table 
	[ [Expression][ Result ][ Side effect ] ]
	[
		[`__container__ | __kwd_put__(__arg__[0], ....,__arg__[__k__-1]) `]
		[A reference to `__container__`]
		[Forwards to `__value_type__(__arg__[0], ....,__arg__[__k__-1])` and puts the result in the container.] 
	]
]

The above extends to arbitrary `__n__` as follows:
``
	__container__ | __kwd_put__(__arg__[0][0], ....,__arg__[0][__k__[0]-1])...(__arg__[__n__-1][0], ....,__arg__[__n__-1][__k__[__n__-1]-1])
``

[heading Value-type]

The appropriate type, `__value_type__`, is deduced at compile time, from the type of destination 
container, `__container__`. 

[heading Modifier]

See [link csv_modifier comment].

[heading Miscellanea]

See [link csv_misc comment].

[heading Example]

[map2]

[endsect][/functor]

[section:ptr_cont Pointer container]

This section discusses the side effect of [link boost_assign_v2.put.pipe `operator|()`], with a [tpl_ptr_container pointer container] as left-argument. Consider 
this example:
[ptr_vector]
Copies of `__1st_value__`, `__2nd_value__` and `__3rd_value__` are allocated on the heap, and their pointers put into
`cont`, using `push_back()`, in this case. 

[endsect][/ ptr_cont]
[section:range `__put_range__`]

[heading Header]
[def __header_put_pipe_range__ [@../../../../../boost/assign/v2/put/pipe/range.hpp boost/assign/v2/put/pipe/range.hpp]]
``
	#include <__header_put_pipe_range__>
``

[heading Synopsis]

Let `__value__[0]`...`__value__[__n__]` denote the dereferenced values of [tpl_concept_range range] `__range__`.

[table
	[[Expression][Result][ Implementation ]]
	[
		[``
			__container__ | __put_range__( __range__ );
		``]
		[
			A reference to `__container__`
		]
		[``
			__container__ | __kwd_put__(__value__[0])...(__value__[__n__])
		``]
	]
	[
		[``
			__boost_type__<__container_type__>() | __put_range__( __range__ );
		``]
		[
			Object of type `__container_type__`
		]
		[``
			__container_type__ __container__; __container__ | __put_range__( __range__ ); 
		``]
	]
]

[note The second expression is a [tpl_range_adaptor range adpator]]

[heading Example]

[import ../example/put/range.cpp]
[put_range_queue]

[endsect][/ put_range]
[endsect][/op]
[section:deque Deque]

[heading Header]

[def __header_put_deque__ [@../../../../../boost/assign/v2/put/deque.hpp boost/assign/v2/put/deque.hpp]]

``
	#include <__header_put_deque__>
``

[heading Description]

The functions documented in this section, `csv_deque()` and `deque()` each constructs a container similar to [tpl_stl_deque `std::deque<>`] whose interface 
for putting elements is shared with that of `__kwd_csv_put__` and `__kwd_csv_put__`, respectively.

[section:csv `csv_deque`]

[import ../example/put/deque.cpp]

[heading Synopsis]

[table 
	[ [Expression][ Result type] ]
	[
		[`csv_deque( __value__[0], ..., __value__[__n__-1] )`]
		[`result_of::deque<__value_type__>::type`]
	]
]

[heading Example]

[csv_deque]

[endsect][/csv]
[section:deque `deque`]

[heading Header]

[def __header_put_deque_functor__ [@../../../../../boost/assign/v2/put/deque/functor.hpp boost/assign/v2/put/deque/functor.hpp]]

``
	#include <__header_put_deque_functor__>
``

[heading Synopsis]

[table 
	[ [Expression][ Result type ][[^__n__]] ]
	[
		[
			`deque<__value_type__>(__kwd_nil__)`
		][
			`result_of::deque<__value_type__>::type`
		][ 
			[^0] 
		]
	]
	[
		[
			`deque<__value_type__>( __arg__[0][0], ..., __arg__[0][__k__[0]] )`
		][
			`result_of::deque<__value_type__>::type`
		][ 
			[^1] 
		]
	]
]

[heading Example]

[deque]

Find [tpl_foo_h here] the declaration of `Foo`, and  [tpl_foo_cpp here] its definition.

[endsect][/functor]
[endsect][/deque]
[section:modulo `operator%()`]

[heading Convention]

We add to our [link boost_assign_v2.conv conventions] that `__put_implem__` denotes an object returned by keyword such as 
[link boost_assign_v2.put.pipe.csv `__kwd_csv_put__`], and `__custom_param__` denotes a user-specified parameter.

[heading Description]

The [link boost_assign_v2.put put framework] relies on traits of the container to be modified to determine the appropriate implementation. 
This has the advantage that the same and compact interface works across different container categories, whether [tpl_stl_seq Sequence], 
[tpl_stl_assoc Associative] or [tpl_stl_adapter adapters]. To allow the user to override the implementation, however, this library provides a ['composable] parameter passing mechanism. 

[heading Synopsis]

[table 
	[ [Expression][ Result ] ]
	[
		[`__put_implem__ % __custom_param__`]
		[ An implementation with a new type or state  ]
	]
]

[section:fun `__kwd_fun__`]

[heading Header]

[def __header_put_fun__ [@../../../../../boost/assign/v2/put/generic/new_fun.hpp boost/assign/v2/put/generic/new_fun.hpp]]
``
	#include <__header_put_fun__>
``

[heading Synopsis]

[table 
	[ [Expression][ Result ] ]
	[
		[`__put_implem__ % (__kwd_fun__ = __f__)`]
		[Replaces the internal functor of the lhs by `__f__` ]
	]
]

[heading Example]

[fun]

[endsect][/fun]
[section:modifier Modifier]

[heading Header]

[def __header_put_modifier__ [@../../../../../boost/assign/v2/put/modifier.hpp boost/assign/v2/put/modifier.hpp]]

``
	#include <__header_put_modifier__>
``

[heading Description]

This section documents the mechanisms by which a passed value, `__value__`, is put in a container, `__container__`. These mechanisms are of two kinds,
['standard], and ['extended].

[section:std Standard]

[heading Header]

[def __header_put_modifier_std__ [@../../../../../boost/assign/v2/put/modifier/std.hpp boost/assign/v2/put/modifier/std.hpp]]

``
	#include <__header_put_modifier_std__>
``

[heading Description]

A ['standard modifier] is charaterized by an implementation that, given a passed value, `__value__`,  inserts it in the destination container, `__container__`, 
by calling a member function, `__container__.mf( __value__ )`.

[heading Example]

[deque_front]

[section:key Keyword]

Here's a catalog of the keywords that control standard modifiers, and the container categories
under which they are the default. 

[table 
	[ [ Keyword ][ Implementation ][ Default ] ]
	[ [ `__kwd_insert__` ][ `__container__.insert( __value__ )` ][ [tpl_stl_assoc Associative] ] ]
	[ [ 
		`__kwd_iterate__` [footnote  This keyword does not agree with our definition of a standard modifier which 
		requires that the element be inserted, not merely assigned. However, it makes sense from a user standpoint to leave 
		that keyword in this table. Also see [link boost_assign_v2.put.modulo.modifier.ext.iterate Extended functionality].
		]
	  ]
	  [ `__container__[ __i__++ ] = __value__ ` ]
	  [ [tpl_boost_array Static arrays] ] 
	]
	[ [ `__kwd_push__` ][ `__container__.push( __value__ )` ][ [tpl_stl_adapter Adapters] ]  ]
	[ [ `__kwd_push_back__` ][ `__container__.push_back( __value__ )` ][ [tpl_stl_seq Sequence] ] ]
	[ [ `__kwd_push_front__` ][ `__container__.push_front( __value__ )` ][ ]  ]
]
where index `__i__` is initialized to zero.  

[endsect][/ keys ]
[section:custom Customization ]

[heading Header]

[def __header_put_modifier_std_xxx__ [@../../../../../boost/assign/v2/put/modifier/std/xxx.hpp boost/assign/v2/put/modifier/std/xxx.hpp]]

``
	#include <__header_put_modifier_std_xxx__>
``

[note __header_explicit__]

[heading Synopsis]

[table

	[[Expression][Defines][Implementation]]
	[
		[``
			BOOST_ASSIGN_V2_PUT_MODIFIER_STD_XXX( mf )
		``]
		[``
			__put_implem__ % _mf 
		``]
		[``
			__container__.mf( __value__ )	
		``]
	]
]
where identifier `_mf` is defined in an anonymous namespace nested in `__ns_as2__`.

[heading Example]
``
	BOOST_ASSIGN_V2_PUT_MODIFIER_STD_XXX(push_back)
``

[endsect][/ custom]
[endsect][/ std ]
[section:ext Extended]

[heading Header]

[def __header_put_modifier_ext__ [@../../../../../boost/assign/v2/put/modifier/ext.hpp boost/assign/v2/put/modifier/ext.hpp]]
``
	#include <__header_put_modifier_ext__>
``

[heading Description]

An ['extended] modifier is one that is not standard. 

[section:iterate `__kwd_iterate__` ]

[heading Header]

[def __header_put_modifier_ext_iterate__ [@../../../../../boost/assign/v2/put/modifier/ext/iterate.hpp boost/assign/v2/put/modifier/ext/iterate.hpp]]

``
	#include <__header_put_modifier_ext_iterate__>
``

[heading Synopsis]

[table 
	[ [ Expression ][ Implementation ] ]
	[ [ `__kwd_iterate__ = __n__` ][ `__container__[ __i__++ ] = __value__` ] ]
]
where `__i__` is initialized to `__n__`.

[heading Example]

[iterate]

[endsect]
[section:repeat `__kwd_repeat__`]

[heading Header]

[def __header_put_modifier_ext_repeat__ [@../../../../../boost/assign/v2/put/modifier/ext/repeat.hpp boost/assign/v2/put/modifier/ext/repeat.hpp]]

``
	#include <__header_put_modifier_ext_repeat__>
``

[heading Synopsis]

[table 
	[ [ Expression ][ Implementation ] ]
	[ [ `_repeat = n` ][ `m = n; while(--m) __implem_defined__` ] ]
]
where `__implem_defined__` is the implementation prior to passing the parameter.

[heading Example]

[repeat]

[endsect]
[section:lookup `__kwd_lookup__` ]

[heading Header]

[def __header_put_modifier_ext_lookup__ [@../../../../../boost/assign/v2/put/modifier/ext/lookup.hpp boost/assign/v2/put/modifier/ext/lookup.hpp]]

``
	#include <__header_put_modifier_ext_lookup__>
``

[heading Synopsis]

[def __key__ key]

Let `__key__` denote an [tpl_stl_assoc Associative] container's key. 

[table 
	[ [ Expression ][ Implementation ] ]
	[ [ `__kwd_lookup__ = __f__` ][ `__container__[ __key__ ] = __f__( __container__[ __key__ ] )` ] ]
]

[heading Example]

[lookup]

[endsect]

[section:custom Customization]

[heading Header]

[def __header_put_modifier_ext_xxx__ [@../../../../../boost/assign/v2/put/modifier/ext/xxx.hpp boost/assign/v2/put/modifier/ext/xxx.hpp]]

``
	#include <__header_put_modifier_ext_xxx__>
``

[note __header_explicit__]

[heading Description]

We want to create a keyword `__kwd_custom_param__` such that
``
	__put_implem__ % ( __kwd_custom_param__ = __param_arg__ )
``
a returns a different (but not necessarily independent) implementation, based on the information in the right-hand-side. 


[section:proc Procedure]

In ['each] step below the user is required to write a piece of code ['within] `namespace` `__ns_as2__`. The notation 
`typename...`, here, is not a variadic template parameter. It means that the choice of template parameters are unspecified.

# Define
``
    template<typename Arg>
    struct __custom_param__
    {
    	// Constructor
        __implem_defined__ get()const; 
    };
``

# Define
``
    struct __custom_param_kwd__
    {
    	template<typename Arg>
        __custom_param__<Arg> operator=(Arg const&); 
    };
``
where `Arg` is the type of [^__param_arg__].

# Define
``
	namespace modifier_tag{

    	template<typename ...> struct __custom_param__{};

	}
``

# Define
``
	namespace put_parameter{

    	template<typename Arg>
    	struct __custom_param__{

            template<typename OldFun, typename OldTag>
            struct apply; // must derive from put_parameter::pair<>

    	};

	}
``

# Specialize
``
	namespace put_aux{

        template<typename...>
        class modifier<modifier_tag::__custom_param__<Tag> >
        {
            public:

            modifier(){}
            explicit modifier(__implem_defined__); 

            template<typename V, typename T>
            void impl(V& v, T& t)const; // puts t in v

            template<typename V, typename T>
            void impl(V& v, T* t)const; // for ptr_container
        };
    	
    }
``
where `__implem_defined__` is the result type of 
``
	( __kwd_custom_param__ = __param_arg__ ).get()
``

# Expand
``
	BOOST_ASSIGN_V2_PUT_MODIFIER_EXT_XXX(__custom_param__)
``

[endsect][/ procedure]
[section Example]

# __header_put_modifier_ext_iterate__
# __header_put_modifier_ext_lookup__
# __header_put_modifier_ext_repeat__

[endsect]
[endsect][/ custom]
[endsect][/ ext]
[endsect][/ modifier]
[endsect][/ modulo]
[endsect][/ put]

[section:ref Ref]

[heading Header]

[def __header_ref__ [@../../../../../boost/assign/v2/ref.hpp boost/assign/v2/ref.hpp]]

``
	#include <__header_ref__>
``

[heading Convention]

In addition to our previous [link boost_assign_v2.conv.syn conventions], code describing a feature is assumed to be preceded by
``
	using namespace ref;
``

Furthermore, in terms of our convened [link boost_assign_v2.conv.symb symbols], template argument `U` is either
of `__value_type__` or `__value_type__ const`. Finally, we denote `__array__` either of the objects returned by `csv_array()` or `array()`.

[section:if Interface]

[heading Header]

[def __header_ref_if__ [@../../../../../boost/assign/v2/ref/array/interface.hpp boost/assign/v2/ref/array/interface.hpp]]

``
	#include <__header_ref_if__>
``

[heading Synopsis]

The interface of the containers in this section are akin to [tpl_boost_array `boost::array<>`], but it has, in addition, a `rebind()` member function.

[table
	[[Expression][Description]]
	[
		[``
			__array__.rebind( __i__, __value__ )
		``]
		[ Rebinds the `__i__`th reference to `&__value__`]
	]
]

[endsect][/ if]
[section:csv `csv_array`]

[heading Header]

[def __header_ref_csv__ [@../../../../../boost/assign/v2/ref/array/csv.hpp boost/assign/v2/ref/array/csv.hpp]]

``
	#include <__header_ref_csv__>
``

[heading Synopsis]

[table 
	[ [Expression ][ Result type ]]
	[
		[`csv_array<U>( __kwd_nil__ )`]
		[`nth_result_of::csv_array<0, U>::type`]
	]
	[
		[`csv_array( __value__[0], ..., __value__[__n__-1] )`]
		[`nth_result_of::csv_array<__n__, U>::type`]
	]
]
In the second expression, `U == __value_type__ const` if and only if `__value__[__i__]` is passed 
as a `const` lvalue or an `rvalue`,  for at least one `__i__`, and `U == __value_type__` otherwise.

[heading Example]

[csv_array_r]
[csv_array_w]

[endsect][/ csv_array]
[section:array `array`]

[heading Header]

[def __header_ref_functor__ [@../../../../../boost/assign/v2/ref/array/functor.hpp boost/assign/v2/ref/array/functor.hpp]]

``
	#include <__header_ref_functor__>
``

[heading Synopsis]

[table 
	[ [Expression ][ Result type] ]
	[
		[`array( __kwd_nil__ )`]
		[`nth_result_of::array<0, U>::type`]
	]
	[
		[`array( __value__[0] ) ...( __value__[__n__-1] )`]
		[`nth_result_of::csv_array<__n__, U>::type`]
	]
]
The determination of `U` for the second expression is identical to that for
[link boost_assign_v2.ref.csv.synopsis `csv_array()`].

[heading Example]

[array_r]

[endsect][/ array]
[section:get `__kwd_get__`]
[heading Header]

[def __header_ref_get__ [@../../../../../boost/assign/v2/ref/wrapper/get.hpp boost/assign/v2/ref/wrapper/get.hpp]]

``
	#include <__header_ref_get__>
``


[heading Synopsis]

Let `__range__` denote a range of reference-wrappers.


[table Usage
	[ [Expression ][ Result ] ]
	[
		[`__range__ | __kwd_get__`]
		[A [tpl_concept_range range] of type `result_of::range_get<__range_type__>::type`]
	]
]

Let `it1` denote the iterator of `__range__` and `it2` that of the transformed one. 

[table Property
	[ [Expression ][ Result ] ]
	[ [`*it2`][`it1->get()`] ]
]

[heading Comment]

This transformation is necessary before passing a range of reference-wrappers to a write [tpl_range_algo range algorithm].

[heading Example]

[csv_array_w2]

[endsect][/ get]
[endsect][/ ref]
[section:util Utility]

[heading Header]
[def __header_util__ [@../../../../../boost/assign/v2/utility.hpp boost/assign/v2/utility.hpp]]

``
	#include <__header_util__>
``

[section:convert `__converter__`]

[heading Header]

[def __header_converter__ [@../../../../../boost/assign/v2/utility/convert.hpp boost/assign/v2/utility/convert.hpp]]

``
	#include <__header_converter__>
``

[heading Synopsis]

[table
	[[Expression][ Description ][ Implementation ]]
	[
		[``
			__container_type__ __container__ = __converter__( __range__ );
		``]
		[
			Copy constructs `__container__`
		]
		[
			Forwards to `__converter__( __range__ ).type<__container_type__>()`
		]
	]
	[
		[``
			__converter__( __range__ ).type<__container_type__>();
		``]
		[
			Returns an object of type `__container_type__`
		]
		[
			See rules.
		]
	]
]

[heading Rules]

The rules of conversion are a kind of switch statement, whose (only two) cases and the corresponding
implementation are given below:

[table 
	[[Condition][ Implementation ]]
	[
		[ 
			`__container_type__` is an [tpl_stl_adapter adapter] or [tpl_boost_array `boost_array<>`]  
		]
		[``
			boost::type<__container_type__> | __lk_put_range__( __range__ )
		``]
	]
	[
		[
			True.
		]
		[``
			__container_type__( boost::begin( __range__ ), boost::end( __range__ ) )
		``]
	]
]


[heading Example]

[import ../example/utility/convert.cpp]
[convert_stack]
[convert_array]
[endsect][/ convert]
[section:chain `__kwd_chain__`]

[heading Header]

[def __header_chain__ [@../../../../../boost/assign/v2/utility/chain.hpp boost/assign/v2/utility/chain.hpp]]

``
	#include <__header_chain__>
``

[section:pipe `operator|()`]

[heading Header]

[def __header_chain_pipe__ [@../../../../../boost/assign/v2/utility/chain/pipe.hpp boost/assign/v2/utility/chain/pipe.hpp]]

``
	#include <__header_chain_pipe__>
``

[heading Description]

[tpl_range_adaptor Range adaptor] `_chain` is a variant of [tpl_range_join join()] that has the special property that it is lvalue-preserving : 
the reference of an rvalue [link boost_assign_v2.ref reference-array] (constructed in place) that holds lvalues is treated as an lvalue.

[heading Synopsis]

[table 
	[ [Expression][ Result type ] ]
	[
		[`__r1__ | __kwd_chain__( __r2__ )`]
		[`result_of::chain<__r1_type__,__r2_type__>::type`]
	]
]

[endsect]
[section:short `operator&&()`]

[heading header]

[def __header_chain_short__ [@../../../../../boost/assign/v2/utility/chain/short.hpp boost/assign/v2/utility/chain/short.hpp]]

``
	#include <__header_chain_short__>
``

[note __header_explicit__ ]

[heading Synopsis]

[table 
	[ [Expression][ Result ] ]
	[
		[`__r1__ && __r2__ `]
		[`__r1__ | __kwd_chain__( __r2__ ) `]
	]
]

[endsect]
[heading Example]

[import ../example/utility/chain.cpp]
[chain_r]
[chain_w]

[endsect][/ chain]
[section:sub_range `__sub_range__`]

[heading Header]
[def __header_sub_range__ [@../../../../../boost/assign/v2/utility/sub_range.hpp boost/assign/v2/utility/sub_range.hpp]]

``
	#include <__header_sub_range__>
``

[heading Description]

Fits a container with some functionality such as relational operators, or `operator<<`. 

[heading Synopsis]

[table 
	[ [Expression][ Result type ] ]
	[
		[`__sub_range__( __container__ )`][ [tpl_itr `boost::iterator_range<>`] ]
	]
]

[heading Example]

[import ../example/utility/sub_range.cpp]
[sub_range1]
[sub_range2]

[endsect][/ sub_range]
[endsect][/ util]
[section:nil `__kwd_nil__`]

[heading Header]

[def __header_nil__ [@../../../../../boost/assign/v2/detail/keyword/nil.hpp boost/assign/v2/detail/detail/keyword/nil.hpp]]
``
	#include <__header_nil__>
``

[heading Synopsis]

[table 
	[ [Expression][ Result type ] ]
	[
		[`__kwd_nil__`][ `__implem_defined__` ]
	]
]

[heading Description]

If `__f__` designates some container generating function, `__f__( __kwd_nil__ )` requests that the returned container be empty.
[footnote In particular, `__f__()` usually returns a container of size one, whose element is default initialized. ]

[endsect]
[section:arity Configuring arity]

[heading Header]

[def __header_limit_csv_arity__ 	[@../../../../../boost/assign/v2/detail/config/limit_csv_arity.hpp boost/assign/v2/detail/config/limit_csv_arity.hpp]]
[def __header_limit_lc_artiy__  	[@../../../../../boost/assign/v2/detail/config/limit_lvalue_const_arity.hpp boost/assign/v2/detail/config/limit_lvalue_const_arity.hpp]]
[def __header_limit_arity__			[@../../../../../boost/assign/v2/detail/config/limit_arity.hpp boost/assign/v2/detail/config/limit_arity.hpp]]

``
	#include <__header_limit_csv_arity__>
	#include <__header_limit_lc_artiy__>
	#include <__header_limit_arity__>
``

[note __header_explicit__]

[heading Synopsis]

Below are overridable constants's identifier, default value, and the [link boost_assign_v2.conv.index index] that they control. 

[table
	[[ Constant ][ Default value ][ Index ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_CSV_ARITY`][20][ __n__ ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_LVALUE_CONST_ARITY`][2][ __k__ ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_ARITY`][ `BOOST_MPL_LIMIT_METAFUNCTION_ARITY`][ __k__ ]]
]

[note  Applies to __url_cpp03__, not __url_cpp0x__ ]

[heading Comments]

The first constant is the limit arity for
``
	__kwd_csv_put__( __value__[0], ..., __value__[__n__-1]);
``
and other ['csv] functions. The second and third constants apply only to the functor form:

``
	__kwd_put__( __arg__[0][0], ..., __arg__[0][__k__[0]-1] )...( __arg__[__n__-1][0], ..., __arg__[__n__-1][__k__[__n__-1]-1] );
``

The second constant is the limit for arity `__k__[__i__]` under which any combination of lvalue and rvalue arguments is preserved, for any given `__i__` 
in `[0,...,__n__)`. Beyond this limit, arguments are treated as either all lvalues or all const-lvalues. The third constant is the total limit for arity 
`__k__[__i__]`.

[endsect][/ arity]
[section:apx Appendix]
[section:portability Portability]

[def __ubuntu__ [@http://releases.ubuntu.com/lucid/ Ubuntu 10.04]]
[def __osx__	[@http://support.apple.com/kb/HT4250 Mac OS X 10.6.5]]
[def __ms__     [@http://www.microsoft.com/windowsxp/pro/default.mspx Windows XP ]]
[def __msvc__	[@http://www.microsoft.com/express/Downloads/#2010-Visual-CPP MSVC 10.0]]
[def __log_mac_gcc42__ 			[@../../test/unit_testing/log_mac_gcc42 log_mac_gcc42] ] 
[def __log_ubuntu_gcc44__ 		[@../../test/unit_testing/log_ubuntu_gcc44 log_ubuntu_gcc44] ]
[def __log_ubuntu_gcc440x__ 	[@../../test/unit_testing/log_ubuntu_gcc440x log_ubuntu_gcc440x] ]
[def __na__						Not available]
[def __num_tests__				__na__]
[def __osx_trunk_rev__			[^66823]]
[def __ubu_trunk_rev__			__na__]
[def __ms_trunk_rev__			__na__]
[def __osx_rev__				[^68338]]
[def __ubu_rev__				__na__]
[def __ms_rev__					__na__]

[tpl_test Here] is the test suite. 

[table
	[
		[ OS]
		[ Compiler ]
		[ Option(s) ]
		[[^__boost_trunk__] [br] revision #]
		[ Errors ]
		[ __boost_assign_v2__ [br] revision # ]
	]
	[
		[ __osx__]
		[ __mac_default_compiler__ ]
		[ ]
		[ __osx_trunk_rev__ ]
		[ 0 ]
		[ __osx_rev__ ] 
		[/
			VAR='date \"+%D\"'
			echo $VAR> log_mac_gcc_42
	    	sudo bjam \"toolset=darwin\" variant=debug,release >> log_mac_gcc42
		]	
	]
	[/
		[ __osx__]
		[ gcc4.4 ]
		[ __cpp0x__ (__url_fink__) ]
		[ __osx_trunk_rev__ ]
		[ 0 ]
		[ __osx_rev__ ] 
	]
	[
		[ __ubuntu__ ]
		[ gcc4.4 ]
		[ ]
		[ __osx_trunk_rev__ ]
		[ 0 ]
		[ __ubu_rev__ ] 
		[/
			VAR=`date "+%D"`
			echo $VAR> log_ubuntu_gcc44
	    	sudo bjam "toolset=gcc" debug release >> log_ubuntu_gcc44
		]	
	]
	[
		[ __ubuntu__ ]
		[ gcc4.4 ]
		[ __cpp0x__ ]
		[ __ubu_trunk_rev__ ]
		[ 0 ]
		[ __ubu_rev__ ] 
		[/	
			VAR=`date "+%D"`
			echo $VAR> log_ubuntu_gcc440x
			sudo sudo bjam "toolset=gcc" cxxflags=-std=c++0x >> log_ubuntu_gcc440x 
		]
	]
	[
		[ __ms__ ]
		[ __msvc__ ]
		[ ]
		[ __ms_trunk_rev__ ]
		[ __na__ ]
		[ __ms_rev__ ] 
		[/	bjam ... ]
	]
]

[endsect][/Portability]

[section:change_log Change log]

[section:v2 \[Proposal for\] Upgrading from __boost__ v1.4x : __boost_assign_v2__]

[heading Organization]

[/
	For backward compatibility and to permit a smooth transition for users that are familiar with __url_boost_assign_v1__, 
	the latter will continue to be supported. 
]

To form an impression about the upgrade, please read section [link boost_assign_v2.qs Quick start]. To compare (non-exhaustively) the two versions, 
see section [link boost_assign_v2.apx.run_eff Runtime efficiency]. Note that the two verions' interface don't clash, even though they serve a very
similar purpose.

[heading Ref-framework]

A revision to the generating function `ref_list_of<>()` and the addition of a tool for [link boost_assign_v2.util.chain chaining] were the subject of a 
__url_boost_assign_v2_mini_review__, and carry through to __url_boost_assign_v2__. 

The first of these proposed changes was to eliminate the size template parameter of `ref_list_of<>()`, as it is redundant with the number of arguments. 
It also fitted the returned container with [tpl_boost_array boost::array<>]'s richer functionality. Finally, a type of 
function, termed ['csv], was introduced, as a more elegant alternative (but not a replacement) to multiple calls to a functor. [#change_log_chain] 
The second feature, chaining, served as an alternative to a container-of-references' member function `range()`.  

Since the __url_boost_assign_v2_mini_review__, the proposal has been further improved. For instance, the dual interface, `ref_list_of()` and `cref_list_of()` is 
replaced by a single function, [link boost_assign_v2.ref.array `ref::array()`], that resolves lvalue/const-ness automatically, and likewise for chaining. 
Also, the latter now preserves the lvalue-ness of the chained ranges' elements. See the relevant [link boost_assign_v2.util.chain section].

[heading Miscellanea]

During the same __url_boost_assign_v2_mini_review__, it became apparent that the existing and proposed features lacked homogeneity in their interface, 
and that the relevance of the proposed one was insufficiently outlined in the documentation. Conversely, some newly introduced features, such as the already 
mentioned ['csv] functions, had received enough interest to warrant their generalization throughout the rest of the library. __url_boost_assign_v2__ adresses 
these requests with a completly revised interface. 

Another consensus was the request for exploiting __url_cpp0x__'s features. In __url_boost_assign_v2__, functions are variadic and preserve the lvalue/const-ness of
their arguments. Under __url_cpp03__, these aspects are controlled by [link boost_assign_v2.arity overridable constants] (macros).

Some confusion was voiced as to whether a nullary call to some container generator, `__f__()`, is supposed to return a container
that is empty or one that contains a default constructed value. The latter is the actual convention in __url_boost_assign_v1__ and carries through 
to __url_boost_assign_v2__, but a keyword, [link boost_assign_v2.nil __kwd_nil__ ], is to be used to request an empty container.

[heading Put-framework]

The inception of this framework began after the __url_boost_assign_v2_mini_review__.

A central feature of the interface is [link boost_assign_v2.put.pipe `operator|()`], which emulates [tpl_range_adaptor range-adaptors]. The key to efficiency is to hold arguments on the right 
hand side of  `operator|` as references, a spillover from the work done in the [link boost_assign_v2.ref ref-framework]. The other major addition
is [link boost_assign_v2.put.modulo `operator%`], for selectively overriding the default implementation. 

In terms of code-reuse, while `list_of()` and the ['list inserters] (e.g. `push_back()`) are, under __url_boost_assign_v1__, independently implemented, their 
counterparts, under __url_boost_assign_v2__, [link boost_assign_v2.put.deque `deque()`][footnote The analog __url_boost_assign_v1__'s `list_of()` is, 
in __url_boost_assign_v2__, renamed `deque()`. This is because  `list_of` evokes a particular data-structure  (forward traversal) that is different from the actual 
underlying one, `std::deque<>` (random access).] and [link boost_assign_v2.put `__kwd_put__`], respectively, derive from a common __crtp__ `class`. Thanks to this integrated approach, containers such as `std::map<>` or [tpl_ptr_container pointer containers] fit into the framework without the need for (major)
adjustments. The library is open to customization, a task that is facilitated by macros. See  [link boost_assign_v2.put.modulo.modifier.std.custom here] and [link boost_assign_v2.put.modulo.modifier.ext.custom here]. 

Finally member function `range<>()`, in __url_boost_assign_v1__, is replaced, in  __url_boost_assign_v2__, by in conjunction with `operator|()`
[link boost_assign_v2.put.pipe.range `put_range()`].  

[heading Utility]

This [link boost_assign_v2.util section] of __url_boost_assign_v2__ extends the library's core with functionality that surrounds containers or ranges. 
Whereas this used to be embedded in the objects returned by in __url_boost_assign_v1__, it is in in __url_boost_assign_v2__ supplied by free-functions,
which perhaps improves modularity and ease of maintenance.

Relational operators, for example, are simply relagated to [tpl_itr `boost::iterator_range<>`] via a convenience function
[link boost_assign_v2.util.sub_range `sub_range()`].

Member functions `to_array()`, `to_adapter()`, and `to_container()`, and the implicit conversion operator, in __url_boost_assign_v1__, are captured, 
in __url_boost_assign_v2__, by the free-function [link boost_assign_v2.util.convert `converter()`].  

[endsect][/ v2 ]
[endsect][/log]

[section:help Help]

To get help or make a suggestion, post to the __user_mailing_list__, but also make sure to notify 
__TO__ and __ER__ by cc-ing them.

[endsect][/Getting help]

[section:hist History and acknowledgement]

[heading __boost_assign_v1__]

The idea for an assignment/initialization library is not new. The  functionality of this library 
resembles Leor Zolman's STL Container Initialization Library a great deal, but it does not rely on 
string parsing to achieve its goals. 

Special thanks go to 

* Leor Zolman for our many discussion that eventually led to this library.
* Tom Brinkman for being review manager.
* Joaquín Muñoz for vc6/vc7 portability.
* Pavel Vozenilek for his countless suggestions, improvements and  portability fixes. 
* Rene Rivera for Code Warrior portability.     

[heading __boost_assign_v2__ ]

* Manuel Peinado Gallego identified the need for a (revised) [link boost_assign_v2.ref ref-framework], and provided
  valuable advice throughout the early development of __boost_assign_v2__, such as proposing a [@http://gist.github.com/287791 design] 
  that laid the foundation for [link boost_assign_v2.util.chain chaining].
* __TO__ and John Bytheway have shaped this new version of the library and its documentation, through their feedback as review managers of 
__url_boost_assign_v2_mini_review__, and the main review, respectively. 

[endsect] [/Ackowledgement]

[section:bibl Bibliography]

* Scott. Meyers, "More Effective C++", Item 7, Addison Wesley, 1996       
* K. Czarnecki and U.W. Eisenecker, "Generative programming", Addison-Wesley, 2000        
* [@http://www.oonumerics.org/blitz/ Blitz]
* Gabriel Dos Reis and Bjarne Stroustrup, 
 [@http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1509.pdf Generalized Initializer Lists], 2003
* Abrahams, David and Gurtovoy, Aleksey,
 [@http://portal.acm.org/citation.cfm?id=1044941# C++ Template Metaprogramming]: Concepts, Tools, and Techniques from Boost and Beyond (C++ in Depth Series),
 2004, Addison-Wesley Professional.

[endsect][/ Bibliography]
[endsect][/apx]
[/xinclude ref.xml]
