[library Boost.Assign
    [quickbook 1.5]
    [version 2.0]
    [authors [Thorsten, Ottosen],[Rogard, Erwann]]
    [copyright 2003-2004 Thorsten Ottosen, 2010 Erwann Rogard]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [id boost_assign_v2]
]

[/Support]

[def __TO__						[@http://www.boost.org/users/people/thorsten_ottosen.html TO]]
[def __ER__						[@mailto:erDOTciDOT2020ATgmailDOTcom ER]]

[template tpl_user_mailing_list[var]		[@http://www.boost.org/community/groups.html#users [var]]]
[def __user_mailing_list__      			[tpl_user_mailing_list Boost Users Mailing List]]
[def __url_boost_assign_v2_mini_review__ 	[@http://lists.boost.org/Archives/boost/2010/06/168028.php mini-review]]


[/ C++ Standard ]

[def __cpp03__ C++03]
[def __cpp0x__ C++0x]
[template tpl_cpp03[var] [@http://en.wikipedia.org/wiki/C%2B%2B03 [var]]]
[template tpl_cpp0x[var] [@http://www2.research.att.com/~bs/C++0xFAQ.html [var]]]
[def __url_cpp03__ [tpl_cpp03 __cpp03__]]
[def __url_cpp0x__ [tpl_cpp0x __cpp0x__]]

[/ Platform]

[def __mac_os__ OS X 10.6.5]
[def __mac_default_compiler__ gcc4.2]
[def __mac_processor__ 2.4 Ghz Intel Core 2 Duo]
[def __mac_mem__ 4GB 1067 Mhz DDR3]

[def __fink__ Fink]
[template tpl_fink[var] [@http://www.finkproject.org/ [var]]]
[def __url_fink__ [tpl_fink __fink__]]


[/ Libraries ]

[def __callout__										[@http://www.boost.org/doc/libs/1_45_0/doc/html/quickbook/syntax.html#quickbook.syntax.phrase.anchors callout]]

[def __boost_assign_v1__ 								Boost.Assign 1.0]
[template tpl_boost_assign_v1[var] 						[@../../../../../libs/assign/doc/index.html [var]]]
[def __url_boost_assign_v1__ 							[tpl_boost_assign_v1 __boost_assign_v1__]]

[def __boost_assign_v2__ 								Boost.Assign 2.0]
[template tpl_boost_assign_v2[var] 						[@./index.html [var]]]
[def __url_boost_assign_v2__ 							[tpl_boost_assign_v2 __boost_assign_v2__]]

[def __boost__											Boost]
[template tpl_boost[var] 								[@http://www.boost.org [var]]]
[def __url_boost__ 										[tpl_boost __boost__]]

[template tpl_boost_array[var] 							[@http://www.boost.org/doc/libs/release/doc/html/array.html [var]]]

[template tpl_mpl[var] 									[@http://www.boost.org/libs/mpl/index.html [var]]]
[def __mpl__ 											[tpl_mpl MPL]]

[template tpl_stl[var] 									[@http://en.wikipedia.org/wiki/Standard_Template_Library [var]]]
[def __stl__ 											[tpl_stl STL]]

[template tpl_stl_assoc[var] 							[@http://www.sgi.com/tech/stl/AssociativeContainer.html [var]]]
[template tpl_stl_seq[var] 								[@http://www.sgi.com/tech/stl/Sequence.html [var]]]
[template tpl_stl_adapter[var]							[@http://flylib.com/books/en/2.674.1.106/1/ [var]]]
[template tpl_stl_deque[var] 							[@http://www.sgi.com/tech/stl/Deque.html [var]]]
[template tpl_stl_cont[var]								[@http://www.sgi.com/tech/stl/Container.html [var]]]


[template tpl_lambda[var] 								[@http://www.boost.org/doc/libs/release/doc/html/lambda.html [var]]]
[def __lambda__											[tpl_lambda lambda]]

[template tpl_ptr_container[var] 						[@http://www.boost.org/doc/libs/release/libs/ptr_container/doc/ptr_container.html [var]]]

[template tpl_range[var] 								[@http://www.boost.org/doc/libs/release/libs/range/index.html [var]]]

[template tpl_range_adaptor[var] 						[@http://svn.boost.org/svn/boost/trunk/libs/range/doc/html/range/reference/adaptors.html [var]]]
[template tpl_range_adaptor_compose[var] 				[@http://svn.boost.org/svn/boost/trunk/libs/range/doc/html/range/reference/adaptors/introduction.html#range.reference.adaptors.introduction.composition_of_adaptors [var]]]
[template tpl_range_algo[var] 							[@http://svn.boost.org/svn/boost/trunk/libs/range/doc/html/range/reference/algorithms.html [var]]]
[template tpl_range_join[var]							[@http://svn.boost.org/svn/boost/trunk/boost/range/join.hpp [var]]]
[template tpl_itr[var]						            [@http://svn.boost.org/svn/boost/trunk/libs/range/doc/html/range/reference/utilities/iterator_range.html [var]]]

[template tpl_operators[var]							[@http://www.boost.org/doc/libs/release/libs/utility/operators.htm [var]]]
[template tpl_boost_typeof[var]								[@http://www.boost.org/doc/libs/1_35_0/doc/html/typeof.html [var]]]

[/Concepts]

[template tpl_meta_fun[var] 					[@http://svn.boost.org/svn/boost/trunk/libs/mpl/doc/refmanual/metafunction.html [var]]]
[template tpl_meta_fun_class[var]				[@http://svn.boost.org/svn/boost/trunk/libs/mpl/doc/refmanual/metafunction-class.html [var]]]

[/Headers]

[template tpl_boost_trunk [var]										[@http://svn.boost.org/svn/boost/trunk [var]]]
[def __boost_trunk__												[tpl_boost_trunk [^boost-trunk]]]

[template tpl_boost_type [var]										[@http://svn.boost.org/svn/boost/trunk/boost/type.hpp [var]]]
[def __boost_type__													[@http://svn.boost.org/svn/boost/trunk/boost/type.hpp boost::type]]

[template tpl_dir_boost_assign_v2[var] 								[@../../../../../boost/assign/v2 [var]]]
[def __dir_boost_assign_v2__ 										[tpl_dir_boost_assign_v2 boost/assign/v2]]

[template tpl_dir_libs_assign_v2[var] 								[@../../ [var]]]
[def __dir_libs_assign_v2__ 										[tpl_dir_libs_assign_v2 libs/assign/v2]]

[template tpl_dir_libs_assign_v2_example [var] 						[@../../example [var]]]
[def __dir_libs_assign_v2_example__ 								[tpl_dir_libs_assign_v2_example libs/assign/v2/example]]


[/Files]

[template tpl_test[var] [@../../test/ [var]] ] 
[template tpl_run_eff[var] [@../../speed/results [var]] ] 

[/Concepts]

[template tpl_concept_range[var] [@http://svn.boost.org/svn/boost/trunk/libs/range/doc/html/range/concepts/overview.html [var]]]

[template tpl_crtp[var] [@http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern [var]]]
[def __crtp__ [tpl_crtp crtp]]

[template tpl_class_tpl[var] [@http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fclass_templates.htm [var]]]

[/ CodeLinks]

[def __put_param_pair__		pair]
[def __put_modifier__		modifier]

[def __kwd_put__			_put]
[def __put__				put]
[def __kwd_csv_put__		_csv_put]
[def __csv_put__			csv_put]
[def __kwd_lookup__			_lookup]
[def __kwd_repeat__			_repeat]

[def __ref_csv_array__		ref::csv_array]
[def __ref_array__			ref::array]

[def __put_range__			put_range]
[def __kwd_put_range__		_put_range]
[def __lk_put_range__		[link boost_assign_v2.put.pipe.range __put_range__]]

[def __converter__			converter]

[def __foo__				foo]
[def __foo_type__			Foo]

[/ Templates]

[def __type_ext__ _]
[template tpl_join[a b][a][b]]
[template tpl_typeof[object][tpl_join [object]..__type_ext__]]
[template tpl_seq[index first last] [index] = [first], ..., [last]]
[template tpl_sub[var index] [var]\[[index]\] ]
[template tpl_sub_sub[var index1 index2] [var]\[[index1],[index2]\]]

[/ Note]

[def __explicit_header__ This header has to be explicitly included]
[def __dev_only__		 End-users may wish to skip this part. ]
[def __pervasive_parameters__ These parameters will be encountered in various (meta) expressions, but their description is only shown here: ]

[/ Notation ]

[def __ns_as2__					boost::assign::v2]

[def __unspecified__ 			'''<replaceable>unspecified</replaceable>''']
[def __unspecified__ 		'''<replaceable>implementation-defined</replaceable>''']

[def __put_implem__ 			'''<replaceable>put-implementation</replaceable>''']
[def __custom_param__			'''<replaceable>param</replaceable>''']
[def __custom_param_kwd__		'''<replaceable>param_keyword</replaceable>''']
[def __kwd_custom_param__		'''<replaceable>_param</replaceable>''']
[def __param_arg__				'''<replaceable>param_arg</replaceable>''']
[def __custom_fun__				'''<replaceable>fun</replaceable>''']

[def __custom_modifier_tag__		'''<replaceable>tag</replaceable>''']
[def __custom_modifier_keyword__	'''<replaceable>_tag</replaceable>''']

[def __cont__				cont]
[def __map__					map]
[def __list__					list]
[def __from__					from]
[def __from_type_				From]
[def __to__						to]
[def __to_type__				To]
[def __cont_type__			C]
[def __cont___				[tpl_typeof __cont__]]
[def __value__					t]
[def __value___					[tpl_typeof __value__]]
[def __value_type__				T]
[def __f__						f]
[def __f_type__					F]
[def __object__					obj]
[def __range__					r]
[def __range_type__				R]
[def __array__					ar]
[def __array_type__				Ar]

[def __kwd_fun__				_fun]
[def __kwd_std__				_std]
[def __kwd_nil__				_nil]
[def __param__					p]
[def __kwd_param__				_p]
[def __param___					[tpl_typeof __param__]]
[def __param_type__				P]
[def __param_index__			l]
[def __param_count__			m]

[def __kwd_push_back__			_push_back]
[def __kwd_push_front__			_push_front]
[def __kwd_push__				_push]
[def __kwd_insert__				_insert]

[def __kwd_repeat__				_repeat]
[def __kwd_iterate__			_iterate]
[def __kwd_lookup__				_lookup]

[def __kwd_get__				_get]

[def __kwd_chain__				_chain]

[/Ranges]
[def __r1__						r1]
[def __r1_type__				R1]
[def __r2__						r2]
[def __r2_type__				R2]

[def __1st_value__				x]
[def __2nd_value__				y]
[def __3rd_value__				z]
[def __i__						i] 
[def __n__						n]

[def __arg__ 					arg]
[def __1st_of_arg__ 			a]
[def __2nd_of_arg__ 			b]
[def __3rd_of_arg__ 			c]
[def __j__						j]
[def __k__						k]

[section:intro Introduction]

This library has grown out of __url_boost_assign_v1__ but is functionally independent of it. It can be broadly characterized as providing a compact interface
for carrying out operations involving containers, which would ordinarily require repetitive statements. This facilitates the integration of client code with 
[tpl_range_algo range algorithms]. Throughout, `as2` is an alias for `__ns_as2__`.

Header [link boost_assign_v2.put [^[*boost/assign/v2/put.hpp]]] revolves around putting a set of values in a container. For example,
[import ../test/put/container/functor.cpp]
[#cal]
[put_cont_functor_cal]
A variation on `__put__()`, termed ['piping], allows for modidying the container in place. For example, in a different context,
[import ../test/other.cpp]
[#csv_put_pipe]
[other_put_pipe_csv]
An optional mechanism, expressed by [link boost_assign_v2.put.modulo operator modulo],
`operator%()`, parameterizes the implementation.  For instance, replacing `__kwd_csv_put__` in the above snippet by
``
	(as2::__kwd_csv_put__ % as2::__kwd_push_front__)
`` 
results in calling ['modifier] `push_front()`, rather than `push_back()`. Such modifiers range from [link boost_assign_v2.put.std simple] to
[link boost_assign_v2.put.ext complex]. In addition, there is a lot of leeway for the client to customize a parameter-invoked 
implementation. To simplify that process, it is systematized by a series of steps to follow and expanding a [link ext_macro macro]
that takes care of the overhead. 

Header [link boost_assign_v2.ref [^[*boost/assign/v2/ref.hpp]]] pertains to treating a set of references as a [tpl_concept_range range-like] interface. Continuing the code 
snippet involving a stable partition,
[other_ref_csv_array]
Note that framework ['put] has a function, [link boost_assign_v2.put.deque `deque()`], that shares a similar interface and purpose, but keeps copies, 
rather than references. 

Header [link boost_assign_v2.utility [^[*boost/assign/v2/utility.hpp]]] contains functionality that is adjunct to either of the ['put] and ['ref] frameworks. 

[endsect]

[section:conv Convention]

[def __new_conv__ The notation below is, from now on, added to our [link boost_assign_v2.conv conventions]]

Here are conventions used in this documentation. They are hopefully intuitive so the impatient reader can skip them. 

[heading Notation]

[*Symbol]

[table
	[[Symbol][Description]]
	[
		[`__cont__`]
		[ A container] 
	]
	[
		[`__value__`]
		[ A value ] 
	]
	[	
		[`__arg__`]
		[ Arguments to a function ]
	]
]

Identifier `__value_type__` represents the type of `__value__`, and `__cont_type__` that of `__cont__`.

[*Index]

[table
	[ 
		[ Expression ] 
		[ Description] 
	]
	[ 
		[ [^[tpl_seq [^__i__]..0..[^__n__]-1]] ] 
		[Indexes a sequence of `__value__`'s] 
	]
	[ 
		[ [^[tpl_seq [^__j__]..0..[^__k__]-1]] ] 
		[Indexes arguments of a [^__k__]-ary function] 
	]
	
]

In the [link cal example] involving a calendar, [^n = 3] and [^k = 2] for [^i = 0, 1 ,2], corresponding the months of January, February and March, respectively. In the [link csv_put_pipe example] 
involving a stable partition, [^__n__ = 6] and [^k = 1]. 

[*Bracket]

[table
	[ 
		[ Expression ] 
		[ Description] 
	]
	[ 
		[ [tpl_sub [^__value__]..[^__i__]] ] 
		[ [^__i__]th value ]
	]
	[ 
		[ [tpl_sub [^__arg__]..[^__j__]] ] 
		[ [^__j__]th argument at unspecified [^__i__] ]
	]
	[ 
		[ [tpl_sub_sub [^__arg__]..[^__i__]..[^__j__]] ] 
		[ [^__j__]th argument at [^__i__] ]
	]
]

[*Alias]

[table
	[ 
		[ Expression ] 
		[ Description] 
	]
	[ 
		[ [^__1st_value__], [^__2nd_value__], [^__3rd_value__] ] 
		[ [tpl_sub [^__value__]..[^0]], [tpl_sub [^__value__]..[^1]], [tpl_sub [^__value__]..[^2]] ]
	]
]

[heading Code block]

[*Feature]

Code that ['describes] a feature, such as under heading [*Synopsis] or [*Semantics], is expressed in terms of the preceding symbols and indexes, 
never actual data-types (such as `int`). Any declaration appearing within [*Synopsis] is assumed to be enclosed in `__ns_as2__`. Accordingly,
symbols appearing in [*Semantics] are not ['not] fully qualified. Another way to say this, is to assume that the code is preceded by 
``
	using namespace __ns_as2__;
``
[*Example]

Code that ['illustrates] a feature, such as under heading [*Example], is assumed to be preceded by the include statement under heading 
[*Header] appearing in the nearest enclosing section (if not the current one, that of the top level etc.). Furthermore, the following 
aliases are assumed:
``
	namespace as2 = __ns_as2__;
	namespace lambda = boost::lambda;
``

Include statement of headers from other libraries (such as `#include <vector>`) are ommitted. However, each example is taken from 
a file in the [tpl_test test directory] where the complete code can be found.

[heading Feature layout]

A typical feature in this library is an ['adapter] i.e. a [tpl_class_tpl template class] that wraps around an object, or a ['container]. We 
call this an ['implementation] because client code never actually has to state its identifier. Indeed, construction is more conveniently
achieved by invoking a function that deduces the appropriate type of the implementation at compile time and its state at 
runtime, from its arguments. Associated types are provided by meta-functions. Accordingly, a possible layout is as follows:

* [*Header] : An `#include` directive for the relevant header.
* [*Syntax] : Code block declaring a the ['implementation]'s interface. 
* [*Semantics] : Gives meaning to the implementation's interface shown in [*Syntax]
* [*Meta] : Meta-expressions
* [*Make] : A function returning an instance of the implementation
* [*Example] : Code block illustrating the above.

Either of [*Meta] or [*Make] may be sub-divided into [*Syntax] and [*Semantics]. 

Alternatively, we may omit [*Syntax], place [*Meta] before [*Semantics] and express object types in the latter in terms of values of 
meta-functions listed in the former, such that the implementation's identifier is never mentioned. This alternative layout is preferred,
for example, if the interesting part of the implementation's interface is provided by a base `class` that is documented in a different section.

A non-typical feature is either a meta function or a function, usually referring to an implementation in a different section. In that case,
the layout is a subset of the above that does not include [*Make]. 

[endsect][/ conv]
[section:put Put]

[heading Header]

[def __header_put__ [@../../../../../boost/assign/v2/put.hpp boost/assign/v2/put.hpp]]

``
	#include <__header_put__>
``

[heading Overview]

[def __describe_frame__ A framework for modifying a container through a functor interface.]
[def __describe_deduce__ Components of the implementation, statically deduced from the input, usually taken as the default ones]
[def __describe_modulo__ Interface for overriding the components of the implementation.]
[def __describe_cont__ Interface for modifying a container.]
[def __describe_deque__ Interface for in place construction of a [tpl_stl_deque `std::deque<>`]-like container.]
[def __describe_std__ Standard modifiers, e.g. `push_back()`.]
[def __describe_ext__ Extended modifiers i.e. perform more complex tasks than, say, `push_back()`.]

[table
	[[Section][Description]]
	[[ [link boost_assign_v2.put.frame Frame] ][ __describe_frame__ ]]
	[[ [link boost_assign_v2.put.deduce Deduce] ][ __describe_deduce__ ]]
	[[ [link boost_assign_v2.put.modulo Modulo] ][ __describe_modulo__ ]]
	[[ [link boost_assign_v2.put.cont Container] ][ __describe_cont__ ]]
	[[ [link boost_assign_v2.put.deque Deque] ][ __describe_deque__ ]]
	[[ [link boost_assign_v2.put.std Std] ][ __describe_std__ ]]
	[[ [link boost_assign_v2.put.ext Ext] ][ __describe_ext__ ]]
]

[section:frame Frame]

[heading Header]

[def __header_put_frame__ [@../../../../../boost/assign/v2/put/frame.hpp boost/assign/v2/put/frame.hpp]]
``
	#include <__header_put_frame__>
``

[heading Description]

__describe_frame__

[section:modifier Modifier]

[heading Header]

[def __header_put_modifier__ [@../../../../../boost/assign/v2/put/frame/modifier.hpp boost/assign/v2/put/frame/modifier.hpp]]
``
	#include <__header_put_modifier__>
``

[heading Synopsis]

[import ../../../../boost/assign/v2/put/frame/modifier.hpp]
[frame_modifier]

[def __link_tpl_modifier__ [link boost_assign_v2.put.frame.modifier `put_aux::modifier<>`]]
[def __link_modifier__ [link boost_assign_v2.put.frame.modifier `put_aux::modifier<__custom_modifier_tag__>`]]

[heading Models]

See sections [link boost_assign_v2.put.std Std] and  [link boost_assign_v2.put.ext Ext].

[endsect][/ modifier]
[section:crtp Crtp]

[heading Header]

[def __header_put_crtp__ [@../../../../../boost/assign/v2/put/frame/crtp.hpp boost/assign/v2/put/frame/crtp.hpp]]
``
	#include <__header_put_crtp__>
``

[heading Syntax]
``
namespace put_aux{

    template<typename C, typename F, typename Tag, typename D>
    class crtp 
    {

        public:

        typedef D const& result_type;

        crtp(){}
        explicit crtp( F const& f );
        explicit crtp( F const& f, modifier<Tag> const& m );
        template<typename...Args>
        result_type operator()( Args&&...args )const;
        C& container()const;

    };

}// put_aux

``

[*Parameters]

[table 
	[[ Parameter ][ Description ]]
	[[`C`][ Container ]]
	[[`__f_type__`][ Functor ]]
	[[`Tag`][ A template argument to `template` `class` __link_tpl_modifier__ ]]
	[[`D`][Derived type]]
]

[heading Semantics]

[*Notation]

[table 
	[[ Symbol ][ Description ]]
	[
		[`__put_modifier__`]
		[ Instance of __link_modifier__  ]
	]
	[
		[`__f__`]
		[ Instance of `__f_type__`]
	]
	[
		[`__put_implem__`]
		[ Instance of `D`]
	]
]

[*Expressions]

[table
	[[Expression][Result][Side effect]]
	[	
		[`__put_implem__( __arg__[0], ..., __arg__[__k__ - 1] ) `]
		[ A reference to `__put_implem__`]
		[ `__put_modifier__.impl(__cont__, __f__( __arg__[0], ..., __arg__[__k__ - 1] ) )` ]
	]
]

Since the result is a reference to itself, `__put_implem__` can be called successively:
``
	__put_implem__( __arg__[0][0], ..., __arg__[__k__[0] - 1] )...( __arg__[0][__n__ - 1], ..., __arg__[__k__[__n__ - 1] - 1] )
``
Notice that the number of arguments is allowed to vary throughout the [^i = 0, ..., __n__ - 1] sequence of calls. Due to this functor 
property, any file defining a `class` that derives from `put_aux::crtp<>` is named [^functor.hpp], and similarly for directories.

[heading Derived classes]

[table
	[[`template` `class`][Section]]
	[[`result_of::put<>`][[link boost_assign_v2.put.cont.functor Container::Functor]]]
	[[`result_of::deque<>`][[link boost_assign_v2.put.deque Deque]]]
]

[endsect][/ crtp]

[endsect][/ frame]

[section:deduce Deduce]

[heading Header]

[def __header_put_deduce__ [@../../../../../boost/assign/v2/put/deduce.hpp boost/assign/v2/put/deduce.hpp]]
``
	#include <__header_put_deduce__>
``

[heading Description]

__describe_deduce__ 

[section Fun]

[heading Header]

[def __header_put_deduce_fun__ [@../../../../../boost/assign/v2/put/deduce/fun.hpp boost/assign/v2/put/deduce/fun.hpp]]
``
	#include <__header_put_deduce_fun__>
``

[heading Syntax]
``
namespace put_aux{
	template<typename __cont_type__> struct deduce_fun{ typedef __unspecified__ type; };
}// put_aux
``

[heading Semantics]

[def __deduce_fun__  [link boost_assign_v2.put.deduce `put_aux::deduce_fun<__cont_type__>::type`]]

[table 
	[ [`__cont_type__`] [Value]]
	[
		[[tpl_stl_cont By value]]
		[[link boost_assign_v2.detail.functor.constructor `funtor_aux::constructor<C::value_type>`]]
	]
	[
		[[tpl_ptr_container Pointer]]
		[[link boost_assign_v2.detail.functor.new `funtor_aux::new_<C::value_type>`]]
	]
]

[tip If the input is unary, and storage is by value, it might be more efficient to [link boost_assign_v2.put.modulo override] the default with
the [link boost_assign_v2.detail.functor.identity identity] functor.]

[endsect][/ fun]

[section Modifier_tag]

[heading Header]

[def __header_put_deduce_modifier_tag__ [@../../../../../boost/assign/v2/put/deduce/modifier_tag.hpp boost/assign/v2/put/deduce/modifier_tag.hpp]]
``
	#include <__header_put_deduce_modifier_tag__>
``

[heading Syntax]
``
namespace put_aux{
	template<typename __cont_type__>
	struct deduce_modifier_tag{ typedef __unspecified__ type; };
}
``


[def __deduce_modifier_tag__  [link boost_assign_v2.put.deduce `put_aux::deduce_modifier_tag<__cont_type__>::type`]]

[heading Semantics]

[*Return type]

A tag on which __link_tpl_modifier__ is specialized

[*Value-container]

[table 
	[ 
		[ Container category ]
		[ [link boost_assign_v2.put.frame.modifier Value] ]
		[ Section ] 
	]
	[ 
		[ [tpl_stl_assoc Associative] ]
		[ `modifier_tag::insert`] 
		[ [link boost_assign_v2.put.ext Ext] ]
	]
	[ 
		[ [tpl_boost_array Static arrays] ]
		[`modifier_tag::iterate`]
		[ [link boost_assign_v2.put.std Std] ]
	]
	[ 
		[ [tpl_stl_adapter Adapters] ] 
		[`modifier_tag::push`] 
		[ [link boost_assign_v2.put.std Std] ]
	]
	[ 
		[ [tpl_stl_seq Sequence] ] 
		[`modifier_tag::push_back`]
		[ [link boost_assign_v2.put.std Std] ]
	]
]

[*Pointer-container]

The tag associated with `C` is the same as that of its value counterpart.

[note Associative pointer-containers are not dealt with at present. ]

[endsect][/ modifier_tag]
[endsect][/ deduce]
[section:cont Container]

[heading Header]

[def __header_put_cont__ [@../../../../../boost/assign/v2/put/container.hpp boost/assign/v2/put/container.hpp]]
``
	#include <__header_put_cont__>
``

[heading Description]

__describe_cont__

[section:functor Functor]

[heading Header]

[def __header_put_cont_functor__ [@../../../../../boost/assign/v2/put/container/functor.hpp boost/assign/v2/put/container/functor.hpp]]
``
	#include <__header_put_cont_functor__>
``

[heading Syntax]
``
namespace put_aux{

    template<typename C, typename F, typename Tag>
    class adapter : public put_aux::crtp< C, F, Tag, adapter >
    {
        public:

        typedef __unspecified__ result_type;

        public:

        adapter();
        explicit adapter( C& );
        explicit adapter( C&, F const& );
        explicit adapter( C& , F const& , modifier_ const&  );
        C& container()const; /* reference to external container */

    };

}// put_aux
``

[heading Meta]
[*Syntax]
``
namespace result_of{
	
	template<typename __cont_type__>
	struct put{ typedef __unspecified__ type; };

}
``

[*Semantics]

[table 
	[[Expression][Value]]
	[
		[`result_of::put<__cont_type__>::type`]
		[`put_aux::adapter<__cont_type__, __deduce_fun__, __deduce_modifier_tag__>`]
	]
]


[heading Make]
[*Syntax]
``
    template<typename C> typename result_of::put<C>::type put( C& cont );
``

[heading Example]

[put_cont_functor_tuple]

[endsect][/ functor]
[section:range Range]

[heading Header]
[def __header_put_range__ [@../../../../../boost/assign/v2/put/container/range.hpp boost/assign/v2/put/container/range.hpp]]
``
	#include <__header_put_range__>
``

[heading Syntax]
``
    template<typename __cont_type__, typename __range_type__> __cont_type__& put_range(__cont_type__& cont, __range_type__ const& __range__);
    template<typename __cont_type__, typename __range_type__> __cont_type__ put_range( __range_type__ const& __range__ );
``

[*Parameters]
[table
	[[Symbol][Description]]
	[[`__cont_type__`][Container to modify (first oveload) or return (second overload)]]
	[[`__range_type__`][Input range]]
]

[heading Semantics]

[*Notation]

[table
	[[Symbol][Description]]
	[[`__n__`][`boost::size( __range__ )`]]
	[[`__value__[__i__]`][`*boost::next(boost::begin( __range__ ), __i__ )`]]
]

[*Expressions]

[table
	[[Expression][ Result ][Side effect]]
	[
		[``
			__put_range__( __cont__, __range__ );
		``]
		[
			A reference to `__cont__`
		]
		[``
			__put__( __cont__ )( __value__[0] )...( __value__[__n__] )
		``]
	]
	[
		[``
			__put_range__<__cont_type__>( __range__ );
		``]
		[
			A container of type `__cont_type__`
		]
		[
			Calls `__put_range__( __cont__, __range__ )`, with `__cont__` as the container to be returned
		]
	]
]

[heading Example]

[import ../test/put/container/range.cpp]
[put_cont_range_stack]

[endsect][/ range]
[endsect][/ cont]
[section:deque Deque]

[heading Header]

[def __header_put_deque__ [@../../../../../boost/assign/v2/put/deque.hpp boost/assign/v2/put/deque.hpp]]

``
	#include <__header_put_deque__>
``

[heading Description]

__describe_deque__

[heading Syntax]
``
namespace put_deque_aux{

    template<typename T>
    struct impl{ typedef std::deque<T> type; }; /* Internal implementation */

    template<typename T, typename F, typename Tag>
    class cont :
        public put_aux::crtp<__unspecified__, F, Tag, cont<T, F, Tag> >
    {

        public:

        typedef T value_type;
        typedef __unspecified__ size_type;
        typedef __unspecified__ iterator;
        typedef __unspecified__ const_iterator;

        cont(){}
        explicit cont(const F& f);
        explicit cont(__unspecified__ const& v, F const& f);
        explicit cont(__unspecified__ const& v, F const& f, modifier<Tag> const& m );

        iterator begin();
        iterator end();
        const_iterator begin()const;
        const_iterator end()const;

        typedef __unspecified__ reference;
        typedef __unspecified__ const_reference;
        typedef __unspecified__ difference_type;

        size_type size()const;
        size_type max_size()const;
        bool empty()const;
        reference operator[](size_type n);
        const_reference operator[](size_type n)const;
        reference front();
        const_reference front()const;
        reference back();
        const_reference back()const;
        void pop_front();
        void pop_back();
        void swap(cont& that);
        __unspecified__& container()const;

    };

}// put_deque_aux

``

[heading Meta]

[*Notation]

[table
	[[Symbol][Value]]
	[[`__cont_type__`][`put_deque_aux::impl<__value_type__>::type`]]
]

[*Expressions]

[table 
	[[Expression][Value]]
	[
		[`result_of::deque<__value_type__>::type`]
		[`put_deque_aux::cont<T, __deduce_fun__, __deduce_modifier_tag__>`]
	]
]

[heading Make]

[*Syntax]
``
    template<typename T>
    typename result_of::deque<T>::type
    deque( keyword_aux::nil );

    template<typename T, typename...Args>
    typename result_of::deque<T>::type
    deque(Args&&...args);
``

[*Semantics]

[table 
	[ [Expression][ Result ] ]
	[
		[``
			deque<__value_type__>( __kwd_nil__ )
		``]
		[
			Empty instance of `result_of::deque<__value_type__>::type`
		]
	]
	[
		[``
			deque<__value_type__>( __arg__[0], ..., __arg__[__k__ - 1] )
		``]
		[
			Equivalent to `deque<__value_type__>( __kwd_nil__ )( __arg__[0], ..., __arg__[__k__ - 1] )`
		]
	]
]

[heading Example]

[import ../test/put/deque/functor.cpp]
[put_deque_functor]

[endsect][/deque]
[section:modulo Modulo]

[heading Header]

[def __header_put_modulo__ [@../../../../../boost/assign/v2/put/modulo.hpp boost/assign/v2/put/modulo.hpp]]
``
	#include <__header_put_modulo__>
``

[heading Description]

__describe_modulo__ 

[heading Semantics]

[*Notation]

[table 
	[[Symbol][Description]]
	[[`__custom_param__`][A user-specified parameter as rhs of `operator%()`]]
]

[*Expressions]

[table 
	[ [Expression][ Result ] ]
	[
		[`__put_implem__ % __custom_param__`]
		[ An implementation with a new type or state  ]
	]
]

[def __modulo_compose__ This extends without difficulty to an arbitrary number of [link boost_assign_v2.put.modulo modulo] parameters. In other words, the mechanism is composable.]

__modulo_compose__

There are two pre-defined values for `__custom_param__`,  the type of `__kwd_fun__` and that of `__kwd_std__`, which are described in the 
following sections.

[section:ext Ext]

[heading Header]
[def __header_put_modulo_ext__ [@../../../../../boost/assign/v2/put/modulo/ext.hpp boost/assign/v2/put/modulo/ext.hpp]]
``
	#include <__header_put_modulo_ext__>
``

[heading Frame]

[*Syntax]
``
namespace put_parameter{

    template<typename F, typename Tag>
    struct traits{
        typedef F fun_type;
        typedef Tag modifier_tag;
        typedef traits<F, Tag> type;
    };

}// put_parameter
namespace result_of_modulo{

    template<typename D>
    struct ext{

        template<typename FParameter>
        struct apply{
            typedef __unspecified__ type;
        };

    };

}// result_of_modulo
``

[#ext_macro]

[heading Macro]

[*Syntax]
``
	#define BOOST_ASSIGN_V2_PUT_MODIFIER_EXT_XXX(__custom_param__)\
		__unspecified__\
	/**/
``

[*Parameters]

[table
	[[Parameter][Description]]
	[[__custom_param__][A name identifying a custom implementation]]
]

[*Requirements]

In each step below, the user is required to write a piece of code ['within] `namespace` `__ns_as2__`. The notation `typename...`, 
here, is not a variadic template parameter. It means that the choice of template parameters are unspecified.

# Define
``
	namespace put_aux{

    	template<typename Arg>
    	struct __custom_param__
    	{
    		// Constructor
        	__unspecified__ arg()const; 
    	};

	}// put_aux
``

# Define
``
	namespace put_aux{

    	struct __custom_param_kwd__
    	{
    		template<typename Arg>
        	__custom_param__<Arg> operator=(Arg const&); 
    	};

	}// put_aux
``
where `Arg` is the type of [^__param_arg__].

# Define
``
	namespace modifier_tag{

    	template<typename ...> struct __custom_param__{};

	}
``

# Define
``
	namespace put_parameter{

    	template<typename Arg>
    	struct __custom_param__{

            template<typename OldFun, typename OldTag>
            struct apply; // must derive from put_parameter::traits<>

    	};

	}
``

# Specialize the [link boost_assign_v2.put.frame.modifier frame component]
``
namespace put_aux{
	
	template<typename ...>
	struct modifier<modifier_tag::__custom_param__<...> >;
	
}
``
such that its constructor takes as argument the result of  `( __kwd_custom_param__ = __param_arg__ ).arg()`. 

[note The template parameter `Arg` may be unnecessary. Refer to the examples below, to learn how to do away with it]

[*Semantics]
``
	BOOST_ASSIGN_V2_PUT_MODIFIER_EXT_XXX(__custom_param__)
``

Expands to
``
namespace result_of_modulo{
    template<typename D, typename Arg>
    struct __custom_param__
        : ::boost::mpl::apply1<
            result_of_modulo::ext<D>
            , put_parameter::__custom_param__<Arg>
        >
    {};
}
namespace put_aux{

    template<typename C, typename F, typename Tag, typename D, typename Arg>
    typename result_of_modulo::__custom_param__<D, Arg>::type
    operator%(crtp<C, F, Tag, D> const& lhs, put_aux::__custom_param__<Arg> const& rhs);

}// put_aux
namespace{
    put_aux::__custom_param_kwd__ const __kwd_custom_param__;
}
``

such that

[table
	[[Expression]]
	[[`__put_implem__ % (__kwd_custom_param__ = __param_arg__)`]]
]

are valid expressions.

[heading Intances]

[link boost_assign_v2.put.ext Put::Ext]

[endsect][/ ext]
[section:fun Fun]

[heading Header]

[def __header_put_modulo_fun__ [@../../../../../boost/assign/v2/put/modulo/fun.hpp boost/assign/v2/put/modulo/fun.hpp]]
``
	#include <__header_put_modulo_fun__>
``

[heading Syntax]
``
namespace result_of_modulo{

    template<typename D> struct fun/* Specialize on D(erived) */{
        template<typename F> struct apply;
    };
    
}
namespace put_aux{

    template<typename F>
    struct modulo_fun;

    template<typename C, typename F, typename Tag, typename D, typename F1>
    typename ::boost::mpl::apply1<result_of_modulo::fun<D>, F1>::type
    operator%(
        crtp<C, F, Tag, D> const& lhs,
        modulo_fun<F1> const& rhs
    );
    
}// put_aux

__unspecified__ __kwd_fun__;

``

[heading Semantics]

[table 
	[ [Expression][ Result ] ]
	[
		[`__kwd_fun__ = __f__`]
		[Instance of `put_modulo_aux::fun<F>`]
	]
	[
		[`__put_implem__ % (__kwd_fun__ = __f__)`]
		[Replaces the internal functor of `__put_implem__` by `__f__` ]
	]
]

[note Common candidates for `__f__` are in section [link boost_assign_v2.detail.functor Detail::Functor]]

[heading Example]
[import ../test/put/modulo/fun.cpp]
[put_cont_modulo_fun]

[endsect][/ fun]
[section:modifier Modifier]

[heading Header]

[def __header_put_modulo_modifier__ [@../../../../../boost/assign/v2/put/modulo/modifier.hpp boost/assign/v2/put/modulo/modifier.hpp]]
``
	#include <__header_put_modulo_modifier__>
``

[heading Syntax]
``
namespace result_of_modulo{

    template<typename D> struct modifier /* Specialize on D(erived) */{
        template<typename Tag> struct apply;
    };

}// result_of_modulo
``

[endsect][/ modifier]
[section:std Std]

[heading Header]

[def __header_put_modulo_std__ [@../../../../../boost/assign/v2/put/modulo/std.hpp boost/assign/v2/put/modulo/std.hpp]]
``
	#include <__header_put_modulo_std__>
``

[heading Syntax]
``
namespace put_aux{

    template<typename Tag> struct modulo_std;

    template<typename C, typename F, typename Tag, typename D, typename Tag1>
    typename ::boost::mpl::apply1<result_of_modulo::modifier<D>, Tag1>::type
    operator%(crtp<C, F, Tag, D> const& lhs, modulo_std<Tag1> const& rhs);

}
``

[*Semantics]

[table 
	[ [Expression][ Result ] ]
	[
		[`(__kwd_std__ = __custom_modifier_tag__() )`]
		[Instance of `put_aux::modulo_std<__custom_modifier_tag__>`]
	]
	[
		[`__put_implem__ % (__kwd_std__ = __custom_modifier_tag__() )`]
		[Replaces the internal modifier of `__put_implem__` by an instance of [link boost_assign_v2.put.frame.modifier `put_aux::modifier<__custom_modifier_tag__>`] ]
	]
]

[#concept_std]

[heading Concept]

[*Semantics]

A `class` `__custom_modifier_tag__` models concept [^Std] if `class` 
[link boost_assign_v2.put.frame.modifier `put_aux::modifier<__custom_modifier_tag__>`] satisfies:

[table 
	[[Overloads of `impl()`][Implementation][Invariant]]
    [
    	[``
    		void impl(__cont_type__& __cont__, __value_type__&& __value__)const;
    	``]
    	[
    		Passes `std::move( t )` to `__cont__`'s interface.
    	]
    	[
    		`__cont__.size()` is increased by one.
    	]
    ]
    [
    	[``
    		void impl(__cont_type__& __cont__, __value_type__& __value__)const;
    	``]
    	[
    		Passes `__value__` (by reference) to `__cont__`'s interface.
    	]
    	[
    		`__cont__.size()` is increased by one.
    	]
    ]
]

[#std_macro]

[heading Macro]

[*Syntax]
``
#define BOOST_ASSIGN_V2_PUT_STD_XXX( __custom_modifier_tag__ ) \
	__unspecified__
/**/
``

[*Semantics]
``
	BOOST_ASSIGN_V2_PUT_STD_XXX( __custom_modifier_tag__ )
``

expands to
``
namespace modifier_tag{ struct  __custom_modifier_tag__{}; }
namespace put_aux{

    template<>
    class modifier<modifier_tag:: __custom_modifier_tag__>
    {
        __unspecified__
    };

}

put_aux::modulo_std<modifier_tag::__custom_modifier_tag__> const __custom_modifier_keyword__;

``

such that `__custom_modifier_tag__` models concept [^Std], and

[table 
	[[Expression][Description]]
	[[`__custom_modifier_keyword__`][ An instance of [link boost_assign_v2.put.modulo.modifier `_modifier = modifier_tag::__custom_modifier_tag__()`]]]
]


[*Example]
``
	#include <boost/assign/v2/put/std/xxx.hpp>
	BOOST_ASSIGN_V2_PUT_STD_XXX(push_back)
``

[heading Models]

[link boost_assign_v2.put.std Put::Std]

[endsect][/ std]
[endsect][/ modulo]

[section:std Std]

[heading Header]

[def __header_put_std__ [@../../../../../boost/assign/v2/put/std.hpp boost/assign/v2/put/std.hpp]]
``
	#include <__header_put_std__>
``

[heading Description]

__describe_modulo__

[heading Semantics]

Model [link concept_std concept [^Std]]

[import ../test/put/modulo/std.cpp]

[section:insert Insert]

[heading Header]

[def __header_put_std_insert__ [@../../../../../boost/assign/v2/put/std/insert.hpp boost/assign/v2/put/std/insert.hpp]]
``
	#include <__header_put_std_insert__>
``

[heading Implementation]

[table 
	[ 
		[ Tag ]
		[ Modulo keyword ]
		[ Implementation ] 
	]
	[ 
		[`modifier_tag::insert`]
		[ `__kwd_insert__` ]
		[ `__cont__.insert( __value__ )` ]  
	]

]

[heading Example]

[put_std_insert]

[endsect][/insert]
[section:push Push]

[heading Header]

[def __header_put_std_push__ [@../../../../../boost/assign/v2/put/std/push.hpp boost/assign/v2/put/std/push.hpp]]
``
	#include <__header_put_std_push__>
``

[heading Implementation]

[table 
	[ 
		[ Tag ]
		[ Modulo keyword ]
		[ Implementation ] 
	]
	[ 
		[`modifier_tag::push`]
		[ `__kwd_push__` ]
		[ `__cont__.push( __value__ )` ]  
	]

]

[heading Example]

[put_std_push]

[endsect][/push]
[section:push_back Push back]
[heading Header]

[def __header_put_std_push_back__ [@../../../../../boost/assign/v2/put/std/push_back.hpp boost/assign/v2/put/std/push_back.hpp]]
``
	#include <__header_put_std_push_back__>
``

[heading Implementation]

[table 
	[ 
		[ Tag ]
		[ Modulo keyword ]
		[ Implementation ] 
	]
	[ 
		[`modifier_tag::push_back`]
		[ `__kwd_push_back__` ]
		[ `__cont__.push_back( __value__ )` ]  
	]

]
[heading Example]

[put_std_push_back]

[endsect][/push_back]
[section:push_front Push front]
[heading Header]

[def __header_put_std_push_front__ [@../../../../../boost/assign/v2/put/std/push_front.hpp boost/assign/v2/put/std/push_front.hpp]]
``
	#include <__header_put_std_push_front__>
``

[heading Implementation]

[table 
	[ 
		[ Tag ]
		[ Modulo keyword ]
		[ Implementation ] 
	]
	[ 
		[`modifier_tag::push_front`]
		[ `__kwd_push_front__` ]
		[ `__cont__.push_front( __value__ )` ]  
	]

]

[heading Example]

[put_std_push_front]

[endsect][/push_front]
[endsect][/ std]

[section:ext Ext]

[heading Header]

[def __header_put_ext__ [@../../../../../boost/assign/v2/put/ext.hpp boost/assign/v2/put/ext.hpp]]
``
	#include <__header_put_ext__>
``

[heading Description]

__describe_ext__

[import ../test/put/modulo/ext.cpp]

[section:iterate Iterate ]

[heading Header]

[def __header_put_ext_iterate__ [@../../../../../boost/assign/v2/put/ext/iterate.hpp boost/assign/v2/put/ext/iterate.hpp]]

``
	#include <__header_put_ext_iterate__>
``

[heading Syntax]
``
namespace modifier_tag{ struct iterate; }
namespace put_aux{

    template<> class modifier<modifier_tag::iterate>;

}// put_aux

__unspecified__ __kwd_iterate__;
``

[heading Semantics]

[table 
	[ [ Expression ][ Implementation ] ]
	[ [ `__kwd_iterate__ = __n__` ][ `__cont__[ __i__++ ] = __value__` ] ]
]
where `__i__` is initialized to `__n__`, if specified, zero otherwise.

[heading Example]
[put_ext_iterate]

[endsect]

[section:repeat Repeat]

[heading Header]

[def __header_put_ext_repeat__ [@../../../../../boost/assign/v2/put/ext/repeat.hpp boost/assign/v2/put/ext/repeat.hpp]]

``
	#include <__header_put_ext_repeat__>
``

[heading Syntax]
``
namespace modifier_tag{ template<typename OldTag> struct repeat{}; }
namespace put_aux{

    template<typename OldTag> class modifier< modifier_tag::repeat<OldTag> >;

}// put_aux

__unspecified__ __kwd_repeat__;
``

[heading Semantics]

[table 
	[ [ Expression ][ Implementation ] ]
	[ [ `_repeat = n` ][ `m = n; while(--m) __put_implem__` ] ]
]
where `__put_implem__` is the implementation prior to passing the parameter.

[heading Example]

[put_ext_repeat]

[endsect]
[section:lookup Lookup ]

[heading Header]

[def __header_put_ext_lookup__ [@../../../../../boost/assign/v2/put/ext/lookup.hpp boost/assign/v2/put/ext/lookup.hpp]]

``
	#include <__header_put_ext_lookup__>
``

[heading Syntax]
``
namespace modifier_tag{ template<typename Arg> struct lookup{}; }
namespace put_aux{

    template<typename Arg> struct modifier<modifier_tag::lookup<Arg> >;
    
}//put_aux

__unspecified__ __kwd_lookup__;
``

[heading Semantics]

[*Notation]

[table
	[[Symbol][]]
	[[`key`][ Instance of an [tpl_stl_assoc Associative] container's key]]
]

[*Expressions]

[table 
	[ [ Expression ][ Implementation ] ]
	[ [ `__kwd_lookup__ = __f__` ][ `__cont__[ key ] = __f__( __cont__[ key ] )` ] ]
]

[heading Example]

[put_ext_lookup]

[endsect][/ lookup]
[endsect][/ ext]

[section:pipe Pipe]

[heading Header]

[def __header_put_pipe__ [@../../../../../boost/assign/v2/put/pipe.hpp boost/assign/v2/put/pipe.hpp]]

``
	#include <__header_put_pipe__>
``

[heading Description]

A variant of the [link boost_assign_v2.put.cont Container] that allows for modying a container in place. 

[section:csv Csv]

[heading Header]

[def __header_put_pipe_csv__ [@../../../../../boost/assign/v2/put/pipe/csv.hpp boost/assign/v2/put/pipe/csv.hpp]]

``
	#include <__header_put_pipe_csv__>
``

[heading Syntax]
``
	__unspecified__  __kwd_csv_put__;
``

[heading Semantics]

[*Default]

[table 
	[[Expression][Result][Side effect]]
	[
		[``
			__cont__ | __kwd_csv_put__( __value__[0], ..., __value__[__n__ - 1] ) 
		``]
		[Reference to `__cont__`]
		[``
			__put__( __cont__ )( __value__[0] ) ...( __value__[__n__ - 1] )
		``]
	]
]

[*Modulo]

[table
	[
		[``
			__cont__ | ( __kwd_csv_put__ % __param__ )( __value__[0], ..., __value__[__n__ - 1] ) 
		``]
		[Reference to `__cont__`]
		[``
			( __put__( __cont__ ) % __param__ )( __value__[0] ) ...( __value__[__n__ - 1] )
		``]
	]
]

__modulo_compose__

[heading Example]
[import ../test/put/pipe/modulo/fun.cpp]
[put_pipe_csv_fun]

[endsect][/ csv]
[section:functor Functor]

[heading Header]

[def __header_put_pipe_functor__ [@../../../../../boost/assign/v2/put/pipe/functor.hpp boost/assign/v2/put/pipe/functor.hpp]]

``
	#include <__header_put_pipe_functor__>
``

[heading Syntax]
``
	__unspecified__  __kwd_put__;
``

[heading Semantics]

[*Default] 

[table 
	[[Expression][Result][Side effect]]
	[
		[``
			__cont__ | __kwd_put__( arg[0], ..., arg[__k__ - 1] ) 
		``]
		[Reference to `__cont__`]
		[``
			__put__( __cont__ )( arg[0], ..., arg[__k__ - 1] )
		``]
	]
]

In terms of our [link boost_assign_v2.conv conventions], the above assumes [^n = 1], but it extends without difficulty to abitrary [^__n__].

[*Modulo]

[table 
	[[Expression][Result][Side effect]]
	[
		[``
			__cont__ | ( __kwd_put__ % __param__ )( arg[0], ..., arg[__k__ - 1] ) 
		``]
		[Reference to `__cont__`]
		[``
			( __put__( __cont__ ) % __param__ )( arg[0], ..., arg[__k__ - 1] )
		``]
	]
]

__modulo_compose__ 

[heading Example]
[import ../test/put/pipe/container.cpp]
[put_pipe_functor_set]

[endsect][/ functor]
[section:range Range]

[heading Header]

[def __header_put_pipe_range__ [@../../../../../boost/assign/v2/put/pipe/range.hpp boost/assign/v2/put/pipe/range.hpp]]

``
	#include <__header_put_pipe_range__>
``

[heading Syntax]
``
namespace put_range_aux
{
    template<typename R>
    class helper1;

    template<typename C,typename R>
    C& operator|(C& cont, put_range_aux::helper1<R> const& h);

    template<typename C, typename R>
    C operator|( ::boost::type<C>, put_range_aux::helper1<R> const& h);

}// put_range_aux

__unspecified__ const _put_range;

``

[heading Semantics]

[table
	[[Expression][Result]]
	[
		[``
			__cont__ | __kwd_put_range__( __range__ );
		``]
		[``
			__put_range__( __cont__, __range__ )
		``]
	]
	[
		[``
			__boost_type__<__cont_type__>() | __kwd_put_range__( __range__ );
		``]
		[``
			__put_range__<__cont_type__>( __range__ )
		``]
	]
]

[heading Example]

[import ../test/put/pipe/range.cpp]
[put_pipe_range_stack]

[endsect][/ range]
[endsect][/ pipe]
[endsect][/ put]

[section:ref Ref]

[heading Header]

[def __header_ref__ [@../../../../../boost/assign/v2/ref.hpp boost/assign/v2/ref.hpp]]

``
	#include <__header_ref__>
``

[heading Overview]

[def __describe_ref_wrapper__ Reference-wrapper that is default-constructible]
[def __describe_ref_array__ In place constructible array of reference ]

[table
	[ [Section][Description] ]
	[ [[link boost_assign_v2.ref.wrapper Wrapper]][__describe_ref_wrapper__] ]
	[ [[link boost_assign_v2.ref.array Array]][__describe_ref_array__] ]
]

[section:wrapper Wrapper]

__dev_only__

[heading Description]

__describe_ref_wrapper__

[section:crtp Crtp]

[def __header_ref_wrapper_crtp__ [@../../../../../boost/assign/v2/ref/wrapper/crtp.hpp boost/assign/v2/ref/wrapper/crtp.hpp]]

``
	#include <__header_ref_wrapper_crtp__>
``

[heading Syntax]
``
namespace ref{

    template<typename D, typename T>
    class wrapper_crtp
    {
        public:

        void operator=(__unspecified__& t );
        void swap( wrapper_crtp& that );
        operator T&() const;

        bool operator==( const wrapper_crtp& that )const;
        bool operator<( const wrapper_crtp& that )const;
        bool operator==( typename boost::call_traits<T>::param_type t )const;
        bool operator<( typename boost::call_traits<T>::param_type t )const;
        bool operator>( typename boost::call_traits<T>::param_type t );

        template<class CharT, class Traits>
        friend std::basic_ostream<CharT,Traits>&
        operator<<(std::basic_ostream<CharT,Traits>& os, const wrapper_crtp& w);

    };

    template<typename D,typename T> void rebind( wrapper_crtp<D,T>& a, T& t );
    template<typename D,typename T> void swap( wrapper_crtp<D,T>& l, wrapper_crtp<D,T>& r );

	template<typename Tag, typename T> struct ref::wrapper /* : wrapper_crtp<wrapper, T> */{};

	namespace assign_tag{/*Tags for specialiazation of ref::wrapper<>*/}
	
}// ref
``

The remaining comparison operators are defined using [tpl_operators Boost.Operators].

[endsect][/ crtp]
[section:copy Copy] 

[def __header_ref_wrapper_copy__ [@../../../../../boost/assign/v2/ref/wrapper/copy.hpp boost/assign/v2/ref/wrapper/copy.hpp]]

``
	#include <__header_ref_wrapper_copy__>
``

[heading Syntax]
``
namespace assign_tag{ struct copy{}; }

    template< class T >
    struct wrapper<ref::assign_tag::copy, T> : public ref::wrapper_crtp< wrapper, T>
    {
        typedef T type;
		static bool is_const;
        wrapper();
        explicit wrapper( T& r );
        void rebind(T& r );
        T& get() const;
        T* get_pointer() const;
        void assign(__unspecified__);

    };

    template<typename T> struct copy_wrapper;

}// ref
``

[heading Meta]

[table
	[[Expression][Value]]
	[[`ref::copy_wrapper<T>::type`][`ref::wrapper<ref::assign_tag::copy,T>`]]
]

[heading Semantics]

[*Notation]

[table
	[[Symbol][Description]]
	[/[`W`][`ref::copy_wrapper<T>::type`]]
	[[`w`][instance of `ref::copy_wrapper<T>::type`]]
]

[*Expressions]

[table 
    	[[Expression][Description]]
    	[/[`W w;`][`w.get_pointer()`]]
		[[`w.assign( __value__ )`][Same as `*w.get_pointer() = __value__`]]
]

[endsect][/copy]
[section:range_get Range_get]

[heading Header]

[def __header_ref_wrapper_range_get__ [@../../../../../boost/assign/v2/ref/wrapper/range_get.hpp boost/assign/v2/ref/wrapper/range_get.hpp]]

``
	#include <__header_ref_wrapper_range_get__>
``


[heading Meta]
[*Syntax]
``
namespace result_of{

    template<typename __range_type__>
    struct range_get{
		typedef __unspecified__ type;
    };

}// result_of
``

[*Parameters]

[table
	[[Parameter][Description]]
	[ [__range_type__][Models a [tpl_concept_range range] of reference-wrappers whose reference is accessible by member function `get()`.  ]]
]

[heading Syntax]
``
namespace range_aux{

    struct get_adaptor{};

    template<typename R>
    typename result_of::range_get<R>::type operator|(R& r, get_adaptor);

    template<typename R>
    typename result_of::range_get<R const>::type operator|(R const& r, get_adaptor);

}// range_aux

range_aux::get_adaptor const __kwd_get__;
``

[heading Semantics]

[*Notation]

[table
	[[Symbol][Description]]
	[[`__range__`][An instance of  `__range_type__`]]
]

[*Expressions]

[table
	[[Expression][Description]]
	[[`__range__ | __kwd_get__ `][Transforms `__range__` by member function `get()`]]
]

[heading Example]

[import ../test/ref/array/csv.cpp]

[ref_array_csv_w]

[endsect][/range_get]
[endsect][/wrapper]
[section:array Array]

[/ Only relevant if C++03, but since the C++0x syntax is shown, probably not needed:

def __determination_of_type__ U = {`__value__[__i__]` is rvalue or const-lvalue for either of __i__ = 0, ..., __n__ - 1 } ? `__value_type__` `const` : `__value_type__`

]

[def __write_mode__ To be able to alter the bound references using a write algorithm, the reference-wrappers have to be mapped to references. This transformation can achieved
using the [link boost_assign_v2.ref.wrapper.range_get `range_get()`] functionality]
[def __copy_wrapper__ [link boost_assign_v2.ref.wrapper.copy ref::copy_wrapper<U>::type]]

[heading Header]

[def __header_ref_array__ [@../../../../../boost/assign/v2/ref/array.hpp boost/assign/v2/ref/array.hpp]]

``
	#include <__header_ref_array__>
``

[heading Description]

__describe_ref_array__

[section:if Interface]

[heading Header]

[def __header_ref_array_if__ [@../../../../../boost/assign/v2/ref/array/interface.hpp boost/assign/v2/ref/array/interface.hpp]]

``
	#include <__header_ref_array_if__>
``

[heading Syntax]
``
namespace ref{	
namespace array_aux{

    template<typename Impl, typename D>
    class interface
    {
        public:

        typedef __unspecified__ wrapper_type;
        typedef __unspecified__ inner_type;
        typedef __unspecified__ value_type;
        typedef __unspecified__ iterator;
        typedef __unspecified__ const_iterator;
        typedef __unspecified__ size_type;
        typedef __unspecified__ difference_type;
        typedef __unspecified__ reference;
        typedef __unspecified__ const_reference;
        static size_type static_size;

        iterator begin();
        iterator end();
        const_iterator begin()const;
        const_iterator end()const;
        size_type size() const;
        bool empty() const;
        void rebind(size_type i, __unspecified__ t);
        reference operator[](size_type i);
        const_reference operator[](size_type i)const;
        reference front();
        const_reference front() const;
        reference back();
        const_reference back() const;
        void assign(param_type val);
        __unspecified__& wrappers();
        __unspecified__& wrappers()const;

    };
	
}// array_aux
}// ref
``
[*Parameters]

[table
	[[Parameter][Description]]
	[
		[Impl]
		[Instance of `template` `class` [tpl_boost_array `boost::array<>`] whose value-type is a [link boost_assign_v2.ref.wrapper reference-wrapper] ]
	]
	[
		[D]
		[Derived `class` defining `impl()` returning a reference to an instance of `Impl` ] 
	]
]

[heading Semantics]

[*Notation]

[table
	[[Symbol][Description]]
	[
		[`__array__`]
		[Instance of `D`]
	]
]

[*Expresions]

For all but `rebind()` forwards to `__array__.impl()`. 

[table 
	[[Expression][Description]]
	[
		[`__array__.rebind( __i__, __value__ )`]
		[ Rebinds the `__i__`th reference-wrapper to `&__value__`]
	]
]

[endsect][/ if]
[section:csv Csv]

[heading Header]

[def __header_ref_array_csv__ [@../../../../../boost/assign/v2/ref/array/csv.hpp boost/assign/v2/ref/array/csv.hpp]]

``
	#include <__header_ref_array_csv__>
``

[heading Meta]
[*Syntax]
``
namespace ref{

	typedef __unspecified__ size_type;

namespace nth_result_of{

	template<size_type N, typename U> struct csv_array;

}// nth_result_of
}// ref
``

[*Parameters]

[table
	[[Parameter][Description]]
	[[N][ Size ]]
	[[U][ Type that is bound to ]]
]

[heading Semantics]

[*Notation]

[table
	[[Symbol][]]
	[[`__array__`][Instance of `ref::nth_result_of::csv_array<N, U>::type]]
]

[*Inherits]

[table
	[[Base]]
	[[`ref::array_aux::interface<>`]]
]

[heading Make]
[*Syntax]
``
namespace ref{

    template<typename T>
    typename nth_result_of::csv_array<0, T>::type 
    csv_array( keyword_aux::nil );

    template<typename T, typename...TArgs>
    typename boost::lazy_disable_if<
        __unspecified__/* { Either of TArgs... is const } */,
        nth_result_of::csv_array<1 + sizeof...(TArgs)>
    >::type
    csv_array( T& t, TArgs&...args );

    template<typename T, typename...TArgs>
    typename csv_array_aux::result<T const, TArgs const...>::type
    csv_array( T const& t, TArgs const&...args );

}// ref
``

[#ref_csv_array_write_mode]
[note __write_mode__ ]

[heading Example]

[ref_array_csv]

[endsect][/ csv]
[section:functor Functor]

[heading Header]

[def __header_ref_array_functor__ [@../../../../../boost/assign/v2/ref/array/functor.hpp boost/assign/v2/ref/array/functor.hpp]]

``
	#include <__header_ref_array_functor__>
``

[heading Meta]
[*Syntax]
``
namespace ref{

	typedef __unspecified__ size_type;

namespace nth_result_of{

	template<size_type N, typename U> struct array;

}// nth_result_of
}// ref
``

[*Parameters]

[table
	[[Parameter][Description]]
	[[N][ Size ]]
	[[U][ Type that is bound to ]]
]

[*Semantics]

[table
	[[Expression][Inherits]]
	[[`ref::nth_result_of::array<N, U>::type`][`ref::array_aux::interface<>`]]
]

[heading Semantics]

[*Notation]

[table
	[[Symbol][]]
	[[`__array__`][Instance of `ref::nth_result_of::array<N, U>::type]]
]

[*Expressions]

[table
	[[Expression][Description]]
	[[`__array__( __value__ ) `][Instance of `ref::nth_result_of::array<N + 1, U>::type]]
]

[heading Make]
[*Syntax]
``
    template<typename T> typename nth_result_of::array<0, T>::type array( keyword_aux::nil const& );
    template<typename T> typename nth_result_of::array<1, T>::type array(T& t);
    template<typename T> typename nth_result_of::array<1, T const>::type array(T const & t);
``

[#ref_array_write_mode]
[note __write_mode__ ]

[heading Example]

[import ../test/ref/array/functor.cpp]
[ref_array_functor_as]

[endsect][/ functor]
[endsect][/ array]
[endsect][/ref]

[section:utility Utility]

[heading Overview]

[def __csv_descrip__ Maps a functor and a sequence of values to unary functor calls over these values]
[def __chain_descrip__ Concatenates two ranges, without copying their elements, and with a desirable property if either is a [link boost_assign_v2.ref.array reference-array]] 
[def __convert_descrip__ A container-conversion facility  ]

[table 
	[[Section][Description]]
	[[ [link boost_assign_v2.utility.chain Chain] ][__chain_descrip__]]
	[[ [link boost_assign_v2.utility.convert Convert] ][__convert_descrip__]]
	[[ [link boost_assign_v2.utility.csv Csv] ][__csv_descrip__]]
]

[section:chain Chain]

[heading Header]

[def __header_chain__ [@../../../../../boost/assign/v2/utility/chain.hpp boost/assign/v2/utility/chain.hpp]]

``
	#include <__header_chain__>
``

[heading Description]

__chain_descrip__

[heading Parameters]

__pervasive_parameters__

[table
	[ [Parameter][Description] ]
	[ [`__r1_type__`][A [tpl_concept_range range]] ]
	[ [`__r2_type__`][A [tpl_concept_range range]] ]
]

[table
	[[Symbol][Decription]]
	[[`__r1__`][Instance of `__r1_type__`]]
	[[`__r2__`][Instance of `__r1_type__`]]
]

[section:use_const Use const]

[heading Header]

[def __header_chain_use_const__ [@../../../../../boost/assign/v2/utility/chain/use_const.hpp boost/assign/v2/utility/chain/use_const.hpp]]
``
	#include <__header_chain_use_const__>
``

[heading Description]

Meta-function that determines whether or not to preserve lvalue-ness of a chained range.

[heading Syntax]
``
namespace chain_aux{

    template<typename __r1_type__, typename __r2_type__, typename Tag = use_default> struct use_const;

}
``

[heading Semantics]

[*Notation]

[table 
	[[Symbol][Value]]
	[[`U1`][`range_reference<__r1_type__>::type`]]
	[[`T`][`remove_reference<T>::type`]]
	[[`U2`][`range_reference<__r2_type__>::type`]]
]

[*Expressions]

[table
	[[Expression][Value]]
	[[`chain_aux::use_const<__r1_type__, __r2_type__>::value`][[^not{] `is_reference<U1>::value` &&  `!is_const<T>::value` && `(U2 == U1)` [^}] ]]
]

[heading Comment]

This meta-function is particularly relevant if either of the input ranges is returned by [link boost_assign_v2.ref.array.functor `__ref_array__()`]. Since the container is 
constructed in place, it is rvalue, and therefore binds to `const`-`lvalue` reference. Yet, the dereferenced values are convertible to lvalues, provided
that the references passed to `__ref_array__()` are themselves `lvalues`. 

[endsect][/ use_lvalue]
[section:pipe Pipe]

[heading Header]

[def __header_chain_pipe__ [@../../../../../boost/assign/v2/utility/chain/pipe.hpp boost/assign/v2/utility/chain/pipe.hpp]]

``
	#include <__header_chain_pipe__>
``

[heading Description]

A variant of [tpl_range_join join()].

[heading Meta]

[*Syntax]
``
namespace result_of{

	template<typename __r1_type__, typename __r2_type__> struct chain{

		typedef __unspecified__ type;

	};

}
``

[heading Semantics]

[*Notation]

[table 
	[[Symbol][Value]]
	[[`__range_type__`][`result_of::chain<__r1_type__, __r2_type__>::type`]]
]

[*Expressions]

[table
	[[Expression][Value]]
	[[`boost::is_const<range_value<__range_type__>::type>::value`][`chain_aux::use_const<__r1_type__, __r2_type__>::value`]]
	[[`*next( begin( __r1__ ), __n__ )`][ [^__n__ < ] `size( __r1__ )` ? `*next( begin( __r1__ ), __n__ )` : `*next( begin( __r2__ ), __n__ - size( __r1__ ) )` ]]
]

[heading Make]

[*Semantics]
[table 
	[ [Expression][ Description ] ]
	[
		[`__r1__ | __kwd_chain__( __r2__ )`]
		[Instance of `result_of::chain<__r1_type__, __r2_type__>::type`]
	]
]

[note In view of our previous [link boost_assign_v2.utility.chain.use_const comment] about [link boost_assign_v2.ref.array.functor `__ref_array__()`], also
recall our [link ref_array_write_mode note] regarding its use in write mode.]

[heading Example]

[import ../test/utility/chain.cpp]
[chain_r]

[endsect][/pipe]
[section:alias Alias]

[heading header]

[def __header_chain_alias__ [@../../../../../boost/assign/v2/utility/chain/alias.hpp boost/assign/v2/utility/chain/alias.hpp]]

``
	#include <__header_chain_alias__>
``

[note __explicit_header__ ]

[heading Semantics]

[table 
	[ [Expression][ Result ] ]
	[
		[`__r1__ && __r2__ `]
		[`__r1__ | __kwd_chain__( __r2__ ) `]
	]
]

[heading Example]
[other_chain_write]

[endsect][/ alias]
[endsect][/ chain]
[section:convert Convert]

[heading Header]

[def __header_convert__ [@../../../../../boost/assign/v2/utility/convert.hpp boost/assign/v2/utility/convert.hpp]]

``
	#include <__header_convert__>
``

[heading Description]

__convert_descrip__

[section:deduce_tag Deduce tag]

[heading Header]

[def __header_convert_deduce_tag__ [@../../../../../boost/assign/v2/utility/convert/deduce_tag.hpp boost/assign/v2/utility/convert/deduce_tag.hpp]]

``
	#include <__header_convert_deduce_tag__>
``

[heading Syntax]
``
namespace convert_tag{

    struct put{};
    struct copy{};

}// convert_tag
namespace convert_aux{

    template<typename __cont_type__, typename __range_type__>
    struct deduce_tag
    {
        typedef __unspecified__ type;
    };

}
``

[*Parameters]

[table
	[ [Parameter][Description] ]
	[ [`__cont_type__`][Type to convert to] ]
	[ [`__range_type__`][Input [tpl_concept_range range] ] ]
]

[heading Semantics]

[table 
	[ [ `__cont_type__` ][ Value ] ]
	[ [ [tpl_stl_adapter adapter] or [tpl_boost_array `boost_array<>`] ][ `convert_aux::use_put` ] ]
	[ [ Otherwise ][ `convert_aux::use_copy` ] ]
]

[endsect][/deduce_tag]
[section:dispatch Dispatch]

[heading Header]

[def __header_convert_dispatch__ [@../../../../../boost/assign/v2/utility/convert/dispatch.hpp boost/assign/v2/utility/convert/dispatch.hpp]]

``
	#include <__header_convert_dispatch__>
``

[heading Syntax]
``
namespace convert_aux{

    template<typename __cont_type__, typename __range_type__> __cont_type__ dispatch(__range_type__ const& r, convert_tag::put);
    template<typename __cont_type__, typename __range_type__> __cont_type__ dispatch(__range_type__ const& r, convert_tag::copy);

}// convert_aux
``

[heading Semantics]

[table 
	[[Expression][Description]]
	[	
		[
			`dispatch<__cont_type__>( __range__, convert_tag::put() )`
		]
		[
			Default constructs `__cont__` and modifies it through [link boost_assign_v2.put.cont.range `__put_range__( __cont__, __range__ );`]
		]
	]
	[	
		[
			`dispatch<__cont_type__>( __range__, convert_tag::copy() )`
		]
		[
			Constructs `__cont__` by taking the begin and end iterators of `__range__`
		]
	]
	[	
		[
			`dispatch<__cont_type__>( __range__ )`
		]
		[
			Forwards to the binary counterpart with [link boost_assign_v2.utility.convert.deduce_tag `convert_aux::deduce_tag<__cont_type__, __range_type__>::type`] 
			as second argument
		]
	]
]

[endsect][/ dispatch]
[section:converter Converter]

[heading Header]

[def __header_convert_converter__ [@../../../../../boost/assign/v2/utility/convert/converter.hpp boost/assign/v2/utility/convert/converter.hpp]]

``
	#include <__header_convert_converter__>
``

[heading Syntax]
``
namespace convert_aux{

    template<typename __range_type__>
    class converter
    {
        public:

        explicit converter(__unspecified__& __range__);
        template<typename __cont_type__> operator __cont_type__ ();
        template<typename __cont_type__> __cont_type__ type()const;

    };

}// convert_aux
``

[heading Semantics]

[*Notation]

[table 
	[[Symbol][Description]]
	[[`__converter__`][Instance of `convert_aux::converter<__range_type__>`]]
	[[`__range__`][Range stored by `__converter__`]]
]

[*Expressions]

[table 
	[[Expression][Description]]
	[
		[`__converter__.type<__cont_type__>()`]
		[
			Forwards to [link boost_assign_v2.utility.convert.dispatch `dispatch<__cont_type__>( __range__ )`]
		]
	]
	[
		[`__cont_type__ __cont__ = __converter__;`]
		[
			Forwards to `__converter__.type<__cont_type__>()`;
		]
	]
]

[heading Meta]
[*Syntax]
``
namespace result_of{

	template<typename __range_type__>
	struct converter{
		typedef __unspecified__ type;	
	};

}
``

[*Semantics]

[table 
	[[Expression][Value]]
	[[`result_of::converter<__range_type__>::type`][`convert_aux::converter<__range_type__>`]]
]
	
[heading Make ]
[*Syntax]
``
    template<typename R>
    typename result_of::converter<R>::type
    converter(R const& r);
``

[*Semantics]
[table
	[[Expression][Description]]
	[[`converter( __range__ )`][Instance of `result_of::converter<__range_type__>::type`]]
]

[heading Name-lookup]

[*Description]

A macro for bringing `converter()` within a user-specified namespace, such as to invoke name lookup.

[*Syntax]
``
	BOOST_ASSIGN_V2_CONVERTER( U, Seq )
``

[*Parameters]

[table 
	[[Symbol][Description]]
	[[U][ A name such as `__cont__<A, B, C>` ]]
	[[Seq][ A sequence of template arguments such as `(A)(B)(C)` ]]
]

[heading Example]

[import ../test/utility/convert.cpp]
[convert_inpl]
[convert_copy]

[endsect][/ converter]
[endsect][/ convert]
[section:csv Csv]

[heading Header]

[def __header_csv__ [@../../../../../boost/assign/v2/utility/csv.hpp boost/assign/v2/utility/csv.hpp]]

``
	#include <__header_csv__>
``

[heading Description]

__csv_descrip__

[heading Meta]
[*Syntax]
``
namespace result_of{
	template<typename __f_type__, typename V> struct csv;
}
``

[*Parameters]

[table 
	[[Parameter][Description]]
	[[`__f_type__`][A functor type (or reference thereof)]]
	[[`V`][ An mpl-vector of arguments, each suitable in a unary-invocation of `__f_type__` ]]
]

[*Semantics]

[table
	[[Expression][Value]]
	[
		[`result_of::csv<F, mpl::vector<__value_type__[0],..., __value_type__[__n__ - 1]>`]
		[Type of[footnote By recursive application of [tpl_boost_typeof `BOOST_TYPEOF_TPL`]] `__f__( __value__[0] ) ... ( __value__[__n__ - 1] ) `]
	]
]


[heading Make]
[*Syntax]
``
	template<typename F, typename Args>
    typename result_of::csv<F const&, mpl::vector<Args...> >::type
    csv( F const& functor, Args&&... args );
``

[*Semantics]

[table
	[[Expression][Returns]]
	[[`csv( __f__, __value__[0], ..., __value__[__n__ - 1] )`][` __f__( __value__[0] ) ... ( __value__[__n__ - 1] ) `]]

]

[heading Example]
[other_csv_put]

[endsect][/ csv]
[endsect][/ utility]

[section:detail Detail]

[def __header_detail__ 	[@../../../../../boost/assign/v2/detail.hpp boost/assign/v2/detail.hpp]]
``
	#include <__header_detail__>
``

[section:functor Functor]

[def __header_functor__ [@../../../../../boost/assign/v2/detail/functor.hpp boost/assign/v2/detail/detail/functor.hpp]]
``
	#include <__header_functor__>
``

[section:constructor Constructor]

[def __header_constructor__ [@../../../../../boost/assign/v2/detail/functor/constructor.hpp boost/assign/v2/detail/detail/functor/constructor.hpp]]
``
	#include <__header_constructor__>
``

[heading Syntax/Semantics]
``
namespace functor_aux{

    template<typename T>
    class constructor
    {
        public:

        constructor(){}

        template<typename... Args>
        T operator()(Args&&...args)const
        {
            return T( std::forward<Args>(args)... );
        }

    };

}
``

[heading Make]

[*Semantics]

[table
	[[Expression][Returns]]
	[[`constructor<T>()`][Instance of `functor_aux::constructor<T>`]]
]

[endsect][/ constructor]
[section:identity Identity]

[def __header_identity__ [@../../../../../boost/assign/v2/detail/functor/identity.hpp boost/assign/v2/detail/detail/functor/identity.hpp]]
``
	#include <__header_identity__>
``

[heading Syntax/Semantics]
``
namespace functor_aux{

    struct identity
    {
        identity(){}

        template<typename T>
        T&& operator()(T&& t)const{ return std::forward<T>( t ); }
    };

}
``

[heading Make]

[*Semantics]
[table
	[[Expression][Returns]]
	[[`_identity`][Instance of `functor_aux::identity`]]
]

[endsect][/ identity]
[section New]

[def __header_new__ [@../../../../../boost/assign/v2/detail/functor/new.hpp boost/assign/v2/detail/detail/functor/new.hpp]]
``
	#include <__header_new__>
``

[heading Syntax/Semantics]

``
namespace functor_aux{

    template<typename T>
    class new_
    {
        public:

        typedef T* result_type;

        new_(){}

        result_type operator()()const{ return new T(); }

        template<typename... Args>
        result_type operator()(Args&&...args)const
        {
            return new T(std::forward<Args>(args)...);
        }

    };

}
``

[heading Make]

[*Semantics]
[table
	[[Expression][Returns]]
	[[`new_<T>()`][Instance of `functor_aux::new_<T>`]]
]

[endsect][/ new_]
[endsect][/ functor]
[section Keyword]

[heading Header]

[def __header_keyword__ [@../../../../../boost/assign/v2/detail/keyword.hpp boost/assign/v2/detail/detail/keyword.hpp]]
``
	#include <__header_keyword__>
``

[section:nil Nil]

[heading Header]

[def __header_nil__ [@../../../../../boost/assign/v2/detail/keyword/nil.hpp boost/assign/v2/detail/detail/keyword/nil.hpp]]
``
	#include <__header_nil__>
``

[heading Description]

Keyword used throughout the library, usually for requesting an empty container.

[heading Syntax]
``
namespace keyword_aux{
	struct nil;
}

keyword_aux const __kwd_nil__;
``

[endsect][/ nil]
[endsect][/ keyword]
[section:config Config]

[heading Header]

Does not have a header.

[def __only_cpp03__ Applies to __url_cpp03__, not __url_cpp0x__]

[section:arity Limit arity]

[heading Header]
[def __header_limit_arity__			[@../../../../../boost/assign/v2/detail/config/limit_arity.hpp boost/assign/v2/detail/config/limit_arity.hpp]]
``
	#include <__header_limit_arity__>
``

[note __explicit_header__]

[heading Syntax]
``
	#define BOOST_ASSIGN_V2_LIMIT_ARITY __unspecified__
``

[heading Semantics]

[table
	[[ Constant ][ Default ][ Description ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_ARITY`][`BOOST_MPL_LIMIT_METAFUNCTION_ARITY`][ A functor's max # of arguments ([link boost_assign_v2.conv `__k__`]) ]]
]

[endsect][/ arity]
[section:lconst_arity Limit lvalue-const arity]

[heading Header]
[def __header_limit_lvalue_const_arity__			[@../../../../../boost/assign/v2/detail/config/limit_lvalue_const_arity.hpp boost/assign/v2/detail/config/limit_lvalue_const_arity.hpp]]
``
	#include <__header_limit_arity__>
``

[note __explicit_header__]

[heading Syntax]
``
	#define BOOST_ASSIGN_V2_LIMIT_LVALUE_CONST_ARITY __unspecified__
``

[heading Semantics]

[table
	[[ Constant ][ Default ][ Description ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_LVALUE_CONST_ARITY`][2][ A functor's max # of arguments ([link boost_assign_v2.conv `__k__`]) for which any mixture of lvalue and const-lvalues is preserved ]]
]

Beyond this limit, arguments are treated as either all lvalues or all const-lvalues.

[note  __only_cpp03__ ]

[endsect][/ lconst_arity]
[section:csv_arity Limit csv-arity]

[heading Header]
[def __header_limit_csv_arity__			[@../../../../../boost/assign/v2/detail/config/limit_csv_arity.hpp boost/assign/v2/detail/config/limit_csv_arity.hpp]]
``
	#include <__header_limit_csv_arity__>
``

[heading Syntax]
``
	#define BOOST_ASSIGN_V2_LIMIT_CSV_ARITY __unspecified__
``

[heading Semantics]

[table
	[[ Constant ][ Default ][ Description ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_CSV_ARITY`][20][ Limits a csv-function's max # of arguments ([link boost_assign_v2.conv `__n__`]) ]]
]

[note  __only_cpp03__ ]

[endsect][/ csv-arity]
[endsect][/ config]
[endsect][/ detail]

[section:portability Portability]

[def __ubuntu__ [@http://releases.ubuntu.com/lucid/ Ubuntu 10.04]]
[def __osx__	[@http://support.apple.com/kb/HT4250 Mac OS X 10.6.5]]
[def __ms__     [@http://www.microsoft.com/windowsxp/pro/default.mspx Windows XP ]]
[def __msvc__	[@http://www.microsoft.com/express/Downloads/#2010-Visual-CPP MSVC 10.0]]
[def __llvm_15__ [@http://llvm.org/releases/1.5/docs/ReleaseNotes.html LLVM compiler 1.5]]
[def __llvm_42  [@http://developer.apple.com/library/ios/#releasenotes/DeveloperTools/RN-llvm-gcc/ LLVM GCC 4.2]]

[def __na__						Not available]
[def __ok__						passed]
[def __osx_trunk_rev__			[^66823]]
[def __ubu_trunk_rev__			__na__]
[def __ms_trunk_rev__			__na__]
[def __osx_rev__				[^69568]]
[def __unix_rev__				[^69568]]
[def __ubu_rev__				[^69085]]
[def __ms_rev__					__na__]

[tpl_test Here] is the test suite. 

[/
OSX
 sudo bjam darwin-4.0 variant=debug,release -a
 sudo bjam darwin-4.2 variant=debug,release -a
Unix
 sudo bjam darwin-4.4 variant=debug,release -a
 sudo bjam darwin-4.4 variant=debug,release cxxflags=-std=c++0x -a
Ubuntu
 sudo bjam gcc variant=debug,release -a
 sudo bjam gcc variant=debug,release cxxflags=-std=c++0x -a
]

[table
	[
		[ OS]
		[ Compiler ]
		[ Option(s) ]
		[[^__boost_trunk__] [br] revision #]
		[ Test ]
		[ __boost_assign_v2__ [br] revision # ]
	]
	[
		[ __osx__]
		[ gcc-4.0 ]
		[ ]
		[ __osx_trunk_rev__ ]
		[ __ok__ ]
		[ __osx_rev__ ] 
	]
	[
		[ __osx__]
		[ gcc-4.2 ]
		[ ]
		[ __osx_trunk_rev__ ]
		[ __ok__ ]
		[ __osx_rev__ ] 
	]
	[
		[ Unix (__url_fink__) ]
		[ gcc-4.4 ]
		[  ]
		[ __osx_trunk_rev__ ]
		[ __ok__ ]
		[ __unix_rev__ ] 
	]
	[
		[ Unix (__url_fink__) ]
		[ gcc-4.4 ]
		[ __cpp0x__ ]
		[ __osx_trunk_rev__ ]
		[ __ok__ ]
		[ __unix_rev__ ] 
	]
	[
		[ __osx__]
		[ __llvm_15__ ]
		[ ]
		[ __osx_trunk_rev__ ]
		[ Errors (find [^BUG] in test files) ]
		[ 69575 ] 
	]
	[/
		[ __ubuntu__ ]
		[ gcc4.4 ]
		[ ]
		[ __osx_trunk_rev__ ]
		[ __ok__ ]
		[ __ubu_rev__ ] 
		[/
			VAR=`date "+%D"`
			echo $VAR> log_ubuntu_gcc44
	    	sudo bjam "toolset=gcc" variant=debug [release] >> log_ubuntu_gcc44
		]	
	]
	[
		[ __ms__ ]
		[ __msvc__ ]
		[ ]
		[ __ms_trunk_rev__ ]
		[ __na__ ]
		[ __ms_rev__ ] 
		[/	
			bjam toolset=msvc-10.0 variant=debug cflags=-D_SCL_SECURE_NO_WARNINGS
		]
	]
]

[endsect][/Portability]

[section:change_log Change log]

[section:v2 \[Proposal for\] Upgrading from __boost__ v1.4x : __boost_assign_v2__]

[heading Organization]

[/
	For backward compatibility and to permit a smooth transition for users that are familiar with __url_boost_assign_v1__, 
	the latter will continue to be supported. 
]

To form an impression about the upgrade, please read section [link boost_assign_v2.intro Introduction]. To compare (non-exhaustively) the
last version and the upgrade, see section [link boost_assign_v2.run_eff Runtime efficiency]. Note that the two verions' interface don't clash, 
even though they serve a very similar purpose.

[heading Ref-framework]

A revision to the generating function `ref_list_of<>()` and the addition of a tool for [link boost_assign_v2.utility.chain chaining] were the subject of 
a __url_boost_assign_v2_mini_review__, and they carry through to __url_boost_assign_v2__. 

The first of these proposed changes was to eliminate the size template parameter of `ref_list_of<>()`, as it is redundant with the number of arguments. 
It also fitted the returned container with [tpl_boost_array boost::array<>]'s richer functionality. Finally, a type of 
function, termed ['csv], was introduced, as a more elegant alternative (but not a replacement) to multiple calls to a functor. The second feature, chaining, 
was initially aimed as an alternative to a container-of-references' member function `range()`.  

Since the __url_boost_assign_v2_mini_review__, the proposal has been further improved. For instance, the dual interface, `ref_list_of()` and `cref_list_of()` is 
replaced by a single function, [link boost_assign_v2.ref.array.functor `__ref_array__()`], that resolves lvalue/const-ness automatically, and likewise for 
[link boost_assign_v2.utility.chain chaining]. Also, the latter now preserves the lvalue-ness of the chained ranges' elements, as becomes relevant in
conjunction if either of the input ranges is returned by [link boost_assign_v2.ref.array.functor `__ref_array__()`].

[heading Miscellanea]

During the same __url_boost_assign_v2_mini_review__, it became apparent that the existing and proposed features lacked homogeneity in their interface, 
and that the relevance of the proposed one was insufficiently outlined in the documentation. Conversely, some newly introduced features, such as the already 
mentioned ['csv] functions, had received enough interest to warrant their generalization throughout the rest of the library. __url_boost_assign_v2__ adresses 
these requests with a completly revised interface. 

Another consensus was the request for exploiting __url_cpp0x__'s features. In __url_boost_assign_v2__, functions are variadic. Front end functions' typically
declare `T&&` arguments and forward to back-end function using `std::forward<T>()`. Under __url_cpp03__, these aspects are emulated, to some degrees that are 
controled by [link boost_assign_v2.detail.config overridable constants] (macros). Back-end functions are overloaded, in __url_cpp0x__, on whether an argument
is lvalue and rvalue, respectively. In the latter case, `std::move` is used, wherever it is appropriate.

Some confusion was voiced as to whether a nullary call to some container generator, `__f__()`, is supposed to return a container
that is empty or one that contains a default constructed value. The latter is the actual convention in __url_boost_assign_v1__ and carries through 
to __url_boost_assign_v2__, but a keyword, [link boost_assign_v2.detail.keyword.nil __kwd_nil__ ], is to be used to request an empty container.

[heading Put-framework]

The inception of this framework began after the __url_boost_assign_v2_mini_review__.

A new feature of the interface is the ability to modify a container in place through [link boost_assign_v2.put.pipe piping]. The key to efficiency, here, is to 
hold arguments on the right hand side of `operator|` as references, a spillover from the work done in the [link boost_assign_v2.ref ref-framework]. The other major
addition is [link boost_assign_v2.put.modulo `operator%`], for selectively overriding the default implementation. 

In terms of code-reuse, while `list_of()` and the ['list inserters] (e.g. `push_back()`) are, under __url_boost_assign_v1__, independently implemented, their 
counterparts, under __url_boost_assign_v2__, [link boost_assign_v2.put.deque `deque()`][footnote The analog __url_boost_assign_v1__'s `list_of()` is, 
in __url_boost_assign_v2__, renamed `deque()`. This is because  `list_of` evokes a particular data-structure  (forward traversal) that is different from the actual
underlying one, [tpl_stl_deque `std::deque<>`] (random access).] and [link boost_assign_v2.put `__kwd_put__`], respectively, share a common 
[link boost_assign_v2.put.frame framework]. Thanks to this integrated approach, containers such as `std::map<>` fit in seamlessly into the framewor.
The library is open to customization, a task that is facilitated by [link ext_macro macros]. 

Finally member function `range<>()`, in __url_boost_assign_v1__, is replaced, in  __url_boost_assign_v2__, by a free-function 
[link boost_assign_v2.put.cont.range `put_range()`].  

[heading Utility]

This [link boost_assign_v2.utility section] of __url_boost_assign_v2__ extends the library's core with functionality that surrounds containers or ranges. 
Whereas this used to be embedded in the objects returned by in __url_boost_assign_v1__, it is in in __url_boost_assign_v2__ supplied by free-functions,
which perhaps improves modularity and ease of maintenance.

Relational operators, were dropped as we thought that this could be better supplied by an idenpendent library (e.g. 
[@http://svn.boost.org/svn/boost/trunk/boost/range/iterator_range_core.hpp `make_iterator_range()`]).

Member functions `to_array()`, `to_adapter()`, and `to_container()`, and the implicit conversion operator, in __url_boost_assign_v1__, are captured, 
in __url_boost_assign_v2__, by a unique free-function [link boost_assign_v2.utility.convert.converter `converter()`].  

[endsect][/ v2 ]
[endsect][/log]

[section:support Support]

To get help or make a suggestion, post to the __user_mailing_list__, but also make sure to notify 
__TO__ and __ER__ by cc-ing them.

[endsect][/support]

[section:hist History and acknowledgement]

[heading __boost_assign_v1__]

The idea for an assignment/initialization library is not new. The  functionality of this library 
resembles Leor Zolman's STL Container Initialization Library a great deal, but it does not rely on 
string parsing to achieve its goals. 

Special thanks go to 

* Leor Zolman for our many discussion that eventually led to this library.
* Tom Brinkman for being review manager.
* Joaqun Muoz for vc6/vc7 portability.
* Pavel Vozenilek for his countless suggestions, improvements and  portability fixes. 
* Rene Rivera for Code Warrior portability.     

[heading __boost_assign_v2__ ]

* Manuel Peinado Gallego identified the need for a (revised) [link boost_assign_v2.ref ref-framework], and provided
  valuable advice throughout the early development of __boost_assign_v2__, such as proposing a [@http://gist.github.com/287791 design] 
  that laid the foundation for [link boost_assign_v2.utility.chain chaining].
* __TO__ and John Bytheway have shaped this new version of the library and its documentation, through their feedback as review managers of 
__url_boost_assign_v2_mini_review__, and the main review, respectively. 

[endsect] [/Ackowledgement]

[section:bibl Bibliography]

* Scott. Meyers, "More Effective C++", Item 7, Addison Wesley, 1996       
* K. Czarnecki and U.W. Eisenecker, "Generative programming", Addison-Wesley, 2000        
* [@http://www.oonumerics.org/blitz/ Blitz]
* Gabriel Dos Reis and Bjarne Stroustrup, 
 [@http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1509.pdf Generalized Initializer Lists], 2003
* Abrahams, David and Gurtovoy, Aleksey,
 [@http://portal.acm.org/citation.cfm?id=1044941# C++ Template Metaprogramming]: Concepts, Tools, and Techniques from Boost and Beyond (C++ in Depth Series),
 2004, Addison-Wesley Professional.

[endsect][/ Bibliography]

[/xinclude ref.xml]
