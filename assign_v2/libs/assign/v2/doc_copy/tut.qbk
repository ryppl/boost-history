[heading Requisites]

As shown in section [link full_include Organization], we assume in this tutorial that all the header files are included, and, in
addition,
``
	using namespace boost::assign::v2;
``

Headers from other libraries will not be shown in the code snippets of this tutorial, but they can be found in the tutorial's 
actual [@../../tutorial.cpp source file].

[heading Assigning]

In the [link boost_assign_v2.intro introduction]'s example we encountered the operation which gives this library
its name, assign-ment, in this case, of an [tpl_boost_array array]'s elements. Throughout this library, we call 
[link boost_assign_v2.reference.interpreter ['interpreter]] the object returned by [link boost_assign_v2.reference.put `__fun_put__( __cont__ )`]. 
In this example, it was invoked over one set of values (`"+"`, `"-"`, etc.), each specified individually, and another set passed as a 
[tpl_concept_range range] with a special wrapper around it, `__fun_as_arg_list__( numeric )`. The wrapper tells the interpreter to process each of
its elements as individual arguments.

[heading Pointer-containers]

The rule for assigning a pointer container is to do so as for its value-couterparts. 
[tutorial_ptr_container]

[heading Csv]

The call to `csv` that just precedes [footnote ['csv] stands for comma separated values] is equivalent to `__fun_put__( assoc )( x )( y )( z )`. 
Similarly, where ['csv] is the prefix of a generating function's identifier, it indicates that a unary functor, whose identifier is a namesake
of the suffix, is evaluated successively for each of the arguments. For example, container generating function `__fun_csv_deque__` is 
paired to `__fun_deque__`.

[heading Piping]

Here, we'd like to put a set of values in a container, and in the same statement, pass it through a mutating [tpl_range_algo algorithm]:
[tutorial_piping]

It is the vertical bar, `|`, which expresses the on-the-fly modification we were looking for. Such an expression is referred to as 
[link boost_assign_v2.reference.pipe ['piping]] throughout this library, after the related [tpl_pipe idiom] by the same name
[footnote Also see [tpl_range_adaptor Boost.Range ]'s version ]. What it does is equivalent to invoking `csv( __fun_put__( __cont__ ), 0, 1, 2, 3, 4, 5 )` but,
in addition, returns `__cont__`.

[heading Container generation]

Having, in the same statement, assigned `cont` and passed it through a [@http://www.boost.org/doc/libs/1_46_0/libs/range/doc/html/range/reference/algorithms/mutating/stable_partition.html stable partition algorithm], 
let's verify that what was intended matches the state of the container:
[tutorial_container_generation]

[heading Reference arrays]

The other container generating function is [link boost_assign_v2.reference.ref  `__fun_ref_csv_array__`][footnote For consistency,
there exists a functor form, [link boost_assign_v2.reference.ref `__fun_ref_array__`] but, since it is slow, we don't advertize it.]. The returned 
container is, more specifically, an array of reference wrappers,  which we designate as ['reference array] in this library. In the example that precedes,
either could be substituted for `__fun_csv_deque__`. The reciprocal is not true, in general. A reference array is preferable if the values are expensive
to copy, and necessary for working specifically with references, such as as follows:

[tutorial_ref_array]

[heading Chaining]

Chaining ranges is already provided as [tpl_range_join `join`] in __url_boost__. Here's a variant that caters in special way to reference arrays:
[tutorial_chain]

The odd thing to notice is that this algorithm modifies `six`, `seven` and `eight` even though the array returned by `ref::csv_array` is 
an rvalue. The keyword `ref::_get` is necessary in conjunction with a reference array whose references are to be modified (in read mode, instead, 
implicit conversion takes care of it). 

[heading Conversion]

Even a not so standard container, such as a [tpl_stl_adapter container adapter], can be copy constructed from a container of the
same type. Combining a container generating function with a conversion tool gives us the recipe, therefore, for initializing such 
(and more versatile) containers:
[tutorial_conversion]

The conversion, here, is implicit, and is made possible by a conversion operator fitted to the object returned by `__fun_converter__`. See the 
relevant [link boost_assign_v2.reference.conversion section] about explicit conversion.

[heading Data-member generation]

The capabalities of `__fun_put__` and `__fun_deque__` vs their csv counterparts become apparent when we need to forward arguments to the  `__cont__`'s 
value-type (a.k.a data member), or, in the case of maps, to the mapped type. For example,  [tutorial_data_gen]

[heading Automatic deduction]

We have seen that `__fun_put__` was applied to different containers, whether [tpl_boost_array arrays], [tpl_stl_assoc Associative] containers, etc.
This follows from an internal mechanism that deduces from the container's type appropriate

* Data-generation.  The rules are [link data_gen_rules here]
* Modifier. The rules are [link modifier_rules here].

[heading Options]

Either of the implementation components just mentioned can be overriden. Operator `%` is reserved for this kind of task and can be composed. The
relevant section is __link_option__. 

In addition to the [link boost_assign_v2.reference.option  standard modifiers] such as `__kwd_push_back__`,  the library caters to more complex needs
e.g.
[tutorial_option]

[heading Custom options]

[link option_modifier Extending] the library with new modifiers is fairly easy. We briefly summarize how:

* Create a class template, called a ['tag], that identifies the new class of modifiers. The template parameter specifies a variable aspect of the implementation.
* Specialize a library declared [link interpreter_modifier modifier] on ['tag] to model a concept, with the desired semantics.
* Register the above by expanding two macros taking as input the desired option name and some meta-information.

