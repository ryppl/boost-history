[#org]

[heading Headers]

[#org_headers]

Using a given feature of this library requires no more than including the corresponding header file. To find it, one can look inside 
either the organization by module or the one by identifier :

* In directory [@../../../../../boost/assign/v2 `boost/assign/v2`], headers 
and directories (except [^include]) are organized according to the modular structure of this library. The following statement  
[#full_include]:
``
	#include <boost/assign/v2.hpp>
``
includes all the modules [footnote A few headers are not included in that of their enclosing module. Where applicable, 
this will be mentioned].

* In directory [@../../../../../boost/assign/v2/include `boost/assign/v2/include`] headers are named after an identifier that they define[footnote
Excepted [^option.hpp], which includes ['all] the options. Creating, instead, a header for each option would have obfuscated the organization]. The 
following statement 
``
	#include <boost/assign/v2/include.hpp>
``
defines all the identifiers, and is equivalent to the previous include statement.

* The content of the library prior to upgrade 2.0 (above) is included in a project as follows:
``
	#include <boost/assign.hpp>
``

This prior [tpl_boost_assign_v1 library], whose version we (retrospectively) label 1.0, is a separate entity from that versioned 2.0. 
Consequently, it's possible to use both in the same projet without risking a clash, but it's probably more coherent to stick to just one version.

[heading Namespaces]

The `namespace` organization is summed up below:
``
namespace boost{
namespace assign{

    // Boost.Assign (1.0) identifiers

namespace v2{

    // Boost.Assign 2.0 identifiers

namespace ref{

    // Features pertaining to references
	
}// ref
}// assign
}// v2
}// boost
``