[library boost.sandbox.numeric.odeint
     [quickbook 1.3]
     [authors [Ahnert, Karsten], [Mulansky, Mario]]
     [copyright 2009 Karsten Ahnert and Mario Mulansky]
     [category math]
     [id odeint]
     [dirname odeint]
     [purpose 
        Numerical integration of ordinary differential equations.
     ]
     [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
     ]
]

[section Overview]
Odeint is a library for solving  initial value problems (IVP) of ordinary 
differential equations.
Mathematically, these problems are formulated as follows: [*x'(t) = f(x,t)], 
[*x(0) = x0]. [*x] and [*f] can
be vectors and the solution is some function [*x(t)] fullfilling both equations
above.
Numerical approximations for the solution x(t) are calculated iteratively.
The easiest algorithm is the /Euler-Scheme/, where starting at x(0) one 
finds x(dt) = x(0) + dt*f(x(0),0).
Now one can use x(dt) and obtain x(2dt) in a similar way and so on.
The Euler method is of order 1, that means the error at each step is ~ dt[superscript 2].
This is, of course, not very satisfying, which is why the Euler method is 
merely used for real life problems and serves just as illustrative example.
In [*odeint], the following algorithms are implemented:

[table Stepper Algorithms
  [[Method] [Class] [Order] [Error Estimation]]
  [[Euler]  [stepper_euler] [1] [No]]
  [[Runge-Kutta 4] [stepper_rk4] [4] [No]]
  [[Runge-Kutta Cash-Karp] [stepper_rk5_ck] [5] [Yes (Order 4)]]
  [[Runge-Kutta Fehlberg] [stepper_rk78_fehlberg] [7] [Yes (Order 8)]]
  [[Midpoint] [stepper_midpoint] [variable] [No]]
  [[Bulirsch-Stoer] [controlled_stepper_bs] [variable] [Controlled]]
]

[endsect]

[section Short Example]
This section gives a quick introduction to the most important features of the 
library using a number of instructive examples.
Image, for example, you want to numerically integrate a harmonic oscillator 
with friction. The equations of motion are given by x'' = -x + gamma x'.
This can be transformed to a system of two first-order differential equations 
with new variables x and p=x'. To apply numerical integration one first has to 
design the right hand side of the equation w' = f(w) where in this case 
w = (x,p):

[import ../examples/doc_harm_osc.cpp]
[rhs_function]

Here we chose [*vector<double>] as the state type, but others are also possible,
for example [*tr1/array<double,2>]. Odeint is designed in such a way that it 
works with basically any container that can be accessed via iterators.
The parameter structure of the function is crucial: the integration methods will
always call them in the form [*f(x, dxdt, t)]. So even if there is no explicit
time dependence, one has to define [*t] as a function parameter.

Now, we have to define the initial state from which the integration should start:

[state_initialization]

For the integration itself we'll use the 
[funcref boost::numeric::odeint::integrate integrate] function, which is a 
convenient way to get quick results. It is based on the error-controlled
[classref boost::numeric::odeint::runge_kutta_rk5_ck runge_kutta_rk5_ck] stepper
(5th order) and uses adaptive stepsize.
The results are stored into two InsertIterators (time and state) that must be 
provided.

[integration]

The integrate function expects as parameters the rhs of the ode as defined 
above, the initial state x, the start- and end-time of the integration and two
InsertIterators for the times and states where the current time and the current
state after each timestep is stored.
Note, that [funcref boost::numeric::odeint::integrate integrate] uses an 
adaptive stepsize during the integration steps so the time points will not be
equally spaced.
The integration returns the number of steps that were applied.
Note, that in total steps+1 elements will be inserted into times and x_t_vec as 
the initial time and state are inserted before the first step.

It is, of course, also possible to implement the ode system as a class. The rhs
must then be defined as the ()-operator:

[rhs_class]

[endsect]

[section Tutorial]

[section Define the ODE]
First of all, you have to specify the datatype that represents a state of your
system [*x]. Mathematically, this usually is an n-dimensional vector with 
real numbers or complex numbers as scalar objects. For odeint the most natural
way is to use `vector< double >` or `vector< complex< double > >` to represent
the system state. However, odeint can deal with other container types than 
vector as well, e.g. `tr1/array< double , N >` as long as it is able to obtain
a ForwardIterator going through all of the container's elements. The scalar type
must have several operators ( +, -, +=, -= ) and the `abs()`-fcuntion defined . 
Furthermore, one can choose the datatype of the time (that is, the parameter to 
which respect the differentiation is done). The standard type for this is 
`double`, but one might be able to choose, for example, `complex< double >` as
well (untested). It must be possible to multiply the time type and the scalar 
type of the vector. For the most cases `vector< double >` as state type and the
standard `double` for the time type should be sufficient.

To integrate a differential equation numerically, one has to define the rhs of
the equation ['x' = f(x)]. In odeint you supply this function in terms of
an object that implements the ()-operator with a certain parameter structure.
Hence, the straight forward way would be to just define a function, e.g:
[rhs_function]
The parameters of the function must follow the example above where [*x] is the
current state, [*dxdt] is the derivative ['x'] and should be filled by the 
function with ['f(x)] and [*t] is the current time.

A more sophisticated approach is to implement the system as a class where the
rhs function is defined as the ()-operator of the class with the same parameter
structure as above:
[rhs_class]
odeint can deal with instances of such classes instead of pure functions which
allows for cleaner code.

[endsect]

[section Stepper Types]
Numerical integration works iteratevly, that means you start at a state ['x(t)] 
and performs a timestep of length ['dt] to obtain the approximate state 
['x(t+dt)]. There exist many different methods to perform such a timestep each 
of which has a certain order ['q]. If the order of a method is ['q] than it is 
accurate up to term ['~dt^q] that means the error in ['x] made by such a step 
is ['~dt^(q+1)]. odeint provides several steppers of different orders from which
you can choose. There are three types of steppers: [*Stepper], [*ErrorStepper]
and [*ControlledStepper]. 

[table Stepper Algorithms
  [[Method] [Class] [Order] [Error Estimation]]
  [[Euler]  [stepper_euler] [1] [No]]
  [[Runge-Kutta 4] [stepper_rk4] [4] [No]]
  [[Runge-Kutta Cash-Karp] [stepper_rk5_ck] [5] [Yes (Order 4)]]
  [[Runge-Kutta Fehlberg] [stepper_rk78_fehlberg] [7] [Yes (Order 8)]]
  [[Midpoint] [stepper_midpoint] [variable] [No]]
  [[Bulirsch-Stoer] [controlled_stepper_bs] [variable] [Controlled]]
]

[endsect]

[section Integration with Constant Stepsize]
[import ../examples/doc_integrate_const.cpp]
The basic stepper just performs one timestep and doesn't give you any 
information about the error that was made (except that you know it is of order 
q). Such steppers are used with constant stepsize that should be chosen small
enough to have reasonable small errors. However, you should apply some sort of
validity check of your results (such as observing conserved quantities) becasue
you have no other control of the error. The following example defines basic 
stepper based on the classical Runge-Kutta scheme of 4th order.

[define_stepper]

The declaration of the stepper requires the state type as template parameter. 
The integration can now be done by using the `integrate_const( Stepper, System,
 start_time, step_size, state, end_time)` function from odeint:

[integrate]

This call integrates the system defined by `harmonic_oscillator` using the rk4
method from t=0 to 10 with a stepsize dt=0.01 with the initial condition given
in `x`. The result, ['x(t=10)] is stored in `x` (in-place).

[endsect]

[section Integration with Adaptive Stepsize]

[endsect]

[endsect]