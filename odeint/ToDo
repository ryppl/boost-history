= Features and Coding issues: =

Karsten:
* Resizer functionality should be called explicitly and not in every call of do_step or try_step
* Add new order function (because we need three orders for rk78)
  suggestion: * order_step()
              * order_error_step()
              * order_error()
* deriv every stepper from stepper_base< stepper >, because do_step( system , x , t , dt ) is only implemented once ( and calls the special do_step( system , x , dxdt , t , dt ) 
* In all steppers:
  * const unsigned short -> short - DONE
  * typedef typename traits_type::container_type container_type statt typedef Container container_type  - DONE
* in iterator algebra die funktionen welche maximas suchen durch die entsprechenden boost funktionen ersetzen
* Concept checks, f端r vern端nftige Fehlermeldungen
  * auch f端r checks ob abs() vorhanden ist
* check in all steppers the order
* rk78 die fehler implementieren
* references entfernen



Mario:
* code cleanup:
  * error_checker in controlled_stepper_standard - DONE
  * all iterator functionality in iterator_algebra - DONE (where I found it)
  * cleanup iterator algebra - DONE
  * add scale_sum_inplace for different iterators numbers

* all std::vector should given explictly the allocator - that requires 4 additional template parameters in stepper_rk_generic?

* numeric_traits or something similar for pow, abs, norm, sqrt ...

Karsten: check
* hamiltonian solvers with input std::pair< container_type , container_type >, than it can be used in integrate_const.

Mario: check
* change integrate_const to use number of steps instead of end_time and remove integrate_const_step 
* same order of parameters in the integration functions
* Observer the observer should be able to tell the integrate function at which times it wants to analyze the state and the integrator should adapt (decrease) the stepsize accordingly to exactly hit these times - at least for adaptive methods - for constant stepsize integration the observers can remain as is. 

Mario:
* state_copy_observer : statt der inserter die container direkt uebergeben


= container_traits for =

* boost::ublas  / funktioniert
* mtl4, implementing real iterators  / funktioniert so gehackt, nicht submitten
* blitz++ / nicht submitten -- BUGGY, da copy constructor nur referenz erzeugt!
* boost::multi_array / muss gemacht werden


= Unit testing =

Karsten:
* aufsetzen des Frameworks

= Documentation =

* eventuell ein graph typ f端rs tutorial


= Examples and perforance testing =

* cleanup examples directory, only one example per system
* create performance directory/project 
* one example with complex types, cgle, mit spiral waves und multi_array (grisha)


= Headers =

* header cleanup, every header should include all header it needs
* <tr1/array> ist not always present, on many systems it is <array> 










= Wish list =

* dense output
* replacable iterator algebra, with specialized algebras for parallelized calculations / cuda ...
* implicit methods
* Dormand Prince methods 54 und 8
* error methods for symplectic integrators












= Some issues =

* zip iterator is slow, hence writing the iterator algebra with zip iterators is not an option
