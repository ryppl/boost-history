<html>
<head>
<title>The MaybeBoost Hash Library</title>
<body>

<P STYLE="float:right"><A HREF="../..">Back to Index</A></P>

<H2>The MaybeBoost Hash Library: Functions</H2>

<H3 ID="compute_digest">The <tt>compute_digest</tt> Family</H3>

<P>Defined in <tt>&lt;boost/hash/compute_digest.hpp&gt;</tt>

<P>These are convenience functions for calculating the message digest of a single range of data.  All versions take a <A HREF="concepts.html#hashalgorithm"><tt><i>HashAlgorithm</i></tt></A> model as an explicit template parameter and return the corresponding <tt><i>HashAlgorithm</i>::digest_type</tt>.  All the bits in the input range values are used (including the sign bit, if present).

<P>There are multiple ways to provide the range:

<UL>
<LI>As a pair of input iterators
    <UL>
    <LI><tt>compute_digest&lt;<i>HashAlgorithm</i>&gt;(<i>InIter</i> b, <i>InIter</i> e)</tt>
    </UL>
<LI>As an input iterator and a length
    <UL>
    <LI><tt>compute_digest_n&lt;<i>HashAlgorithm</i>&gt;(<i>InIter</i> b, size_t n)</tt>
    </UL>
<LI>As a <A HREF="http://www.boost.org/libs/range/doc/html/range/concepts/single_pass_range.html">single-pass range</A> of <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#readable-iterators-lib-readable-iterators">readable iterators</A>
    <UL>
    <LI><tt>compute_digest&lt;<i>HashAlgorithm</i>&gt;(<i>Range</i> const &r)</tt><BR>
        equivalent to <tt>compute_digest&lt;<i>HashAlgorithm</i>&gt;(boost::begin(r), boost::end(r))</tt>
    </UL>
    (When the <tt>Range</tt> is a <tt>std::basic_string</tt>, <tt>compute_digest</tt> and <tt>compute_digest_n</tt> delegate to <tt>compute_digest_data</tt> to allow pointer-dependant optimizations.)
<LI>As an object providing <tt>begin()</tt> and <tt>size()</tt> member functions
    <UL>
    <LI><tt>compute_digest_n&lt;<i>HashAlgorithm</i>&gt;(<i>T</i> const &x)</tt><BR>
        equivalent to <tt>compute_digest_n&lt;<i>HashAlgorithm</i>&gt;(x.begin(), x.size())</tt>
    </UL>
<LI>As an object providing <tt>data()</tt> and <tt>size()</tt> member functions
    <UL>
    <LI><tt>compute_digest_data&lt;<i>HashAlgorithm</i>&gt;(<i>T</i> const &x)</tt><BR>
        equivalent to <tt>compute_digest_n&lt;<i>HashAlgorithm</i>&gt;(x.data(), x.size())</tt>
    </UL>
</UL>

<P><B>Portability Note:</B> Hashing values with <tt>compute_digest</tt> is portable if you ensure that the size in bits of the range iterator's value_type is the same on all machines.  It's expected that most users will be hashing bytes on POSIX-compatible machines (where bytes are always 8 bits), and thus will have no portability issues.

<P><B>Limitation:</B> It is not possible to explicitly specify the number of bits to use from each value in the range when using <tt>compute_digest</tt>.  The alternative is to use the <A HREF="concepts.html#streamhash"><i><tt>StreamHash</tt></i></A> directly.  This can still be done as an expression using code along the lines of the following:
<BLOCKQUOTE><tt>typedef <i>HashAlgorithm</i>::stream_hash&lt;<i>N</i>&gt;::type shn;<BR>
shn::digest_type d = shn().update(<i>b</i>, <i>e</i>).end_message();</tt></BLOCKQUOTE>

<P><TABLE WIDTH="100%">
<TR>
<TD>Previous: <A HREF="classes.html">Classes</A></TD>
<TD ALIGN="RIGHT">Next: <A HREF="concepts.html">Concepts</A></TD>
</TR>
</TABLE>

<HR>

<P>Copyright Scott McMurray 2010</P>
<P>Distributed under the Boost Software License, Version 1.0. (See accompanying file <A href="/LICENSE_1_0.txt">LICENSE_1_0.txt</A> or copy at <A href="/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>).</P>

</body>
</html>

