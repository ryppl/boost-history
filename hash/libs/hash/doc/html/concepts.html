<html>
<head>
<title>The MaybeBoost Hash Library</title>
<body>

<P STYLE="float:right"><A HREF="../..">Back to Index</A></P>

<H2>The MaybeBoost Hash Library: Concepts</H2>

<H3 id="hashpolicy"><tt>HashPolicy</tt> Concept</H3>

<P>A type <tt>T</tt> modelling the <tt>HashPolicy</tt> concept must support the following:
    <DL style="margin-left: 1em">
    <DT><tt>T::stream_hash&lt;<i>ValueBits</i>&gt;::type</tt>
    <DD>must model the <tt>StreamHash&lt;<i>ValueBits</i>&gt;</tt> concept.
    <DD>Not all possible values of <i>ValueBits</i> need be accepted.  Typically, small powers of 2 (1, 2, 4, 8, 16, 32, 64) are accepted.
    <DT><tt>T::digest_type</tt>
    <DD>must model the <tt>MessageDigest</tt> concept
    <DD>must match the <tt>digest_type</tt> of the <tt>StreamHash&lt;<i>ValueBits</i>&gt;</tt> policies mentioned above for any allowed choice of <i>ValueBits</i>.
    </DL>

<P>Provided models:
    <UL>
    <LI>cubehash&lt;<i>h</i>&gt;, cubehash&lt;<i>r</i>, <i>b</i>, <i>h</i>&gt;, with <i>h</i> in {8, 16, 24, ..., 512}, <i>r</i> in {1, 2, 3, ...} (default 16), <i>b</i> in {4, 8, 12, ..., 128} (default 32)
    <LI>md4, md5
    <LI>sha (or sha0), sha1
    <li>sha2&lt;<i>h</i>&gt;, with <i>h</i> in {224, 256, 384, 512}
    </UL>

<H3 id="streamhash"><tt>StreamHash&lt;<i>ValueBits</i>&gt;</tt> Concept</H3>

<P>A type <tt>T</tt> modelling the <tt>StreamHash&lt;<i>ValueBits</i>&gt;</tt> concept must support the following (<tt>h</tt> is an object of type <tt>T</tt>, <tt>hc</tt> is an object of type <tt>T const</tt>):

    <DL style="margin-left: 1em">
    <DT><tt>T::digest_type</tt>
    <DD>models the <tt>MessageDigest</tt> concept
    <DT><tt>T::value_type</tt>
    <DD>an unsigned fundamental integral type that can hold least <i>ValueBits</i> bits
    <DT><tt>T x;</tt>
    <DD>default-constructible
    <DT><tt>T x = h;</tt>
    <DD>copy-constructible
    <DT><tt>T x; x = h;</tt>
    <DD>copy-assignable
    <DT><tt>h.reset();</tt>
    <DD>equivalent to <tt>h = T();</tt>
    <DT><tt>T::digest_type d = h.end_message();</tt>
    <DD>returns the digest of all input provided since the last reset, then resets
    <DD>(equivalent to <tt>digest_type d = h.digest(); h.reset();</tt>, though typically more efficient if the hash involves padding or finalization)
    <DT><tt>T::digest_type d = hc.digest();</tt>
    <DD>returns the digest of all input provided since the last reset
    <DD>(equivalent to <tt>digest_type d = T(hc).end_message();</tt>, though typically more efficient if the hash involves neither padding nor finalization)
    <DT><tt>value_type x; h.update_one(x);</tt>
    <DD>Feeds the low <i>ValueBits</i> bits of x as input to the hash algorithm
    <DT><tt>InputIterator b, e; h.update(b, e);</tt>
    <DD>Equivalent to <tt>for (InputIterator i = b; i != e; ++i) h.update_one(*i);</tt>
    <DT><tt>InputIterator b; size_t n; h.update_n(b, n);</tt>
    <DD>Equivalent to <tt>{ InputIterator i = b; for (size_t j = 0; j != n; ++j) h.update_one(*i++); }</tt>
    </DL>

<P>Provided models are accessible through HashPolicy models.

<HR>

<P>Copyright Scott McMurray 2010</P>
<P>Distributed under the Boost Software License, Version 1.0. (See accompanying file <A href="/LICENSE_1_0.txt">LICENSE_1_0.txt</A> or copy at <A href="/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>).</P>

</body>
</html>

