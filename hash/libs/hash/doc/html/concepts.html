<html>
<head>
<title>The MaybeBoost Hash Library</title>
<body>

<P STYLE="float:right"><A HREF="../..">Back to Index</A></P>

<H2>The MaybeBoost Hash Library: Concepts</H2>

<H3 id="hashalgorithm"><tt>HashAlgorithm</tt> Concept</H3>

<P>Models of the <tt>HashAlgorithm</tt> concept are policies to be provided as template arguments to other templates.  They provide access to the set of types needed to generically compute and store digests with a particular algorithm.  (For example, the <A HREF="functions.html#compute_digest"><tt>compute_digest</tt></A> function templates are parametrized by a <tt>HashAlgorithm</tt>, as would a future <A HREF="http://en.wikipedia.org/wiki/HMAC">HMAC</A>-computing function template.)

<P>A type <tt>T</tt> modelling the <tt>HashAlgorithm</tt> concept must support the following:
    <DL style="margin-left: 1em">
    <DT><tt>T::stream_hash&lt;<i>ValueBits</i>&gt;::type</tt>
    <DD>must model the <A HREF="concepts.html#streamhash"><tt>StreamHash&lt;<i>ValueBits</i>&gt;</tt> concept</A>.
    <DD>Not all possible values of <i>ValueBits</i> need be accepted.  Typically, small powers of 2 (1, 2, 4, 8, 16, 32, 64) are accepted.
    <DT><tt>T::digest_type</tt>
    <DD>an instantiation of the <A HREF="classes.html#digest"><tt>digest</tt> class template</A>.
    <DD>must match the <tt>digest_type</tt> of the <tt>StreamHash&lt;<i>ValueBits</i>&gt;</tt> policies mentioned above for any allowed choice of <i>ValueBits</i>.
    </DL>

<P>Provided models:
    <TABLE BORDER=1>
    <TR>
    <TH>Header</TH>
    <TH>Type</TH>
    <TH><tt>digest_type</tt></TH>
    </TR>
    <TR>
    <TD>&lt;boost/hash/adler.hpp&gt;</TD>
    <TD><tt>adler&lt;<i>h</i>&gt;</tt>, with <i>h</i> in {8, 16, 24, ..., 64}</TD>
    <TD>digest&lt;<i>h</i>&gt;</TD>
    </TR>
    <TR>
    <TD>&lt;boost/hash/crc.hpp&gt;</TD>
    <TD><tt>crc&lt;<i>h</i>, ...&gt;</tt>, with template arguments as for <A HREF="http://www.boost.org/doc/libs/1_43_0/libs/crc/crc.html#crc_optimal">Boost.CRC's <tt>crc_optimal</tt></A></TD>
    <TD>digest&lt;<i>h</i>&gt;</TD>
    </TR>
    <TR>
    <TD>&lt;boost/hash/cubehash.hpp&gt;</TD>
    <TD><tt>cubehash&lt;<i>h</i>&gt;</tt>, <tt>cubehash&lt;<i>r</i>, <i>b</i>, <i>h</i>&gt;</tt>, with <i>h</i> in {8, 16, 24, ..., 512}, <i>r</i> in {1, 2, 3, ...} (default 16), <i>b</i> in {4, 8, 12, ..., 128} (default 32)</TD>
    <TD>digest&lt;<i>h</i>&gt;</TD>
    </TR>
    <TR>
    <TD>&lt;boost/hash/md4.hpp&gt;</TD>
    <TD><tt>md4</tt></TD>
    <TD>digest&lt;128&gt;</TD>
    </TR>
    <TR>
    <TD>&lt;boost/hash/md5.hpp&gt;</TD>
    <TD><tt>md5</tt></TD>
    <TD>digest&lt;128&gt;</TD>
    </TR>
    <TR>
    <TD>&lt;boost/hash/sha.hpp&gt;</TD>
    <TD><tt>sha</tt>, <tt>sha0</tt></TD>
    <TD>digest&lt;128&gt;</TD>
    </TR>
    <TR>
    <TD>&lt;boost/hash/sha1.hpp&gt;</TD>
    <TD><tt>sha1</tt></TD>
    <TD>digest&lt;160&gt;</TD>
    </TR>
    <TR>
    <TD>&lt;boost/hash/sha2.hpp&gt;</TD>
    <TD><tt>sha2&lt;<i>h</i>&gt;</tt>, with <i>h</i> in {224, 256, 384, 512}</TD>
    <TD>digest&lt;<i>h</i>&gt;</TD>
    </TR>
    </TABLE>

<H3 id="streamhash"><tt>StreamHash&lt;<i>ValueBits</i>&gt;</tt> Concept</H3>

<P>A type <tt>T</tt> modelling the <tt>StreamHash&lt;<i>ValueBits</i>&gt;</tt> concept must be default-constructible, copy-constructible, and copy-assignable, as well as support the following (<tt>h</tt> is an object of type <tt>T</tt>, <tt>hc</tt> is an object of type <tt>T const</tt>):

    <DL style="margin-left: 1em">
    <DT><tt>T::digest_type</tt>
    <DD>an instantiation of the <A HREF="classes.html#digest"><tt>digest</tt> class template</A>.
    <DT><tt>T::value_type</tt>
    <DD>an unsigned fundamental integral type that can hold least <i>ValueBits</i> bits
    <DT><tt>h.reset();</tt>
    <DD>(equivalent to <tt>h = T();</tt>)
    <DT><tt>T::digest_type d = h.end_message();</tt>
    <DD>returns the digest of all input provided since the last reset, then resets
    <DD>(equivalent to <tt>digest_type d = h.digest(); h.reset();</tt>, though typically more efficient if the hash involves padding or finalization)
    <DT><tt>T::digest_type d = hc.digest();</tt>
    <DD>returns the digest of all input provided since the last reset
    <DD>(equivalent to <tt>digest_type d = T(hc).end_message();</tt>, though typically more efficient if the hash involves neither padding nor finalization)
    <DT><tt>value_type x; h.update_one(x);</tt>
    <DD>Feeds the low <i>ValueBits</i> bits of x as input to the hash algorithm
    <DT><tt>InputIterator b, e; h.update(b, e);</tt>
    <DD>Equivalent to <tt>for (InputIterator i = b; i != e; ++i) h.update_one(*i);</tt>
    <DT><tt>InputIterator b; size_t n; h.update_n(b, n);</tt>
    <DD>Equivalent to <tt>{ InputIterator i = b; for (size_t j = 0; j != n; ++j) h.update_one(*i++); }</tt>
    </DL>

<P>Each <A HREF="#hashalgorithm">HashAlgorithm</a> model provides access to all its associated StreamHash models; Those StreamHash models are generally not accessible in other ways.

<P><TABLE WIDTH="100%">
<TR>
<TD>Previous: <A HREF="functions.html">Functions</A></TD>
<TD ALIGN="RIGHT">Next: <A HREF="performance.html">Performance</A></TD>
</TR>
</TABLE>

<HR>

<P>Copyright Scott McMurray 2010</P>
<P>Distributed under the Boost Software License, Version 1.0. (See accompanying file <A href="/LICENSE_1_0.txt">LICENSE_1_0.txt</A> or copy at <A href="/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>).</P>

</body>
</html>

