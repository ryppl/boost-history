[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:handle Handle] 

__handle__ represents an __act__. It will be returned by [link_async __fn_async__] and is associated with the submitted __task__.


[heading Asynchronous completion token interface]

__handle__ implements an interface in order to check the state of computation and to transfer the result.

* __fn_is_ready__: test if result is set

* __fn_has_value__: test if value-result is set

* __fn_has_exception__: test if exception-result is set

* __fn_get__: return value-result or throw the exception-result

* __fn_wait__: wait until result is set

* __fn_wait_for__: wait until result is set or time-duration has elapsed

* __fn_wait_until__: wait until result ist set or time-point has elapsed

``
	long fibonacci( long n)
	{
		if ( n == 0) return 0;
		if ( n == 1) return 1;
		long k1( 1), k2( 0);
		for ( int i( 2); i <= n; ++i)
		{
			long tmp( k1);
			k1 = k1 + k2;
			k2 = tmp;
		}
		return k1;
	}

	void main()
	{
		// create task
		boost::task::task< long > t( fibonacci, 10);

		// move task ownership to executor
		boost::task::handle< long > h(
			boost::task::async(
				boost::move( t),
				boost::task::new_thread() ) );

		std::cout << "is ready == " << std::boolalpha << h.is_ready() << "\n";

		// wait for task completion
		h.wait();

		std::cout << "has value == " << std::boolalpha << h.has_value() << "\n";
		std::cout << "has exception == " << std::boolalpha << h.has_exception() << "\n";

		// return result
		std::cout << "fibonacci(10) == " << h.get() << std::endl;
	}
``


[heading Task interruption]

Each invokation of __fn_async__ returns an __handle__ which allows to control the associated __task__ (passed to __fn_async__). This includes
the ability to interrupt an __task__ if it is cooperative. Cooperative means that the __task__ contains __interruption_points__ or checks for
interruption requests [footnote see [@http://www.ddj.com/architect/207100682 'Interrupt Politely'], Herb Sutter].

* __fn_interrupt__: interrupt __task__ and return immediately

* __fn_interrupt_and_wait__: interrupt and wait until __task__ was removed from __worker_thread__

* __fn_interrupt_and_wait_for__: interrupt and wait until __task__ was removed from __worker_thread__ or time duration has elapsed

* __fn_interrupt_and_wait_until__: interrupt and wait until __task__ was removed from __worker_thread__ or time point has reached

* __fn_interruption_requested__: return bool if interruption was requested

``
	long cooperative( long n)
	{
		boost::this_thread::interruption_point(); // interruption point

		if ( n == 0) return 0;
		if ( n == 1) return 1;
		long k1( 1), k2( 0);
		for ( int i( 2); i <= n; ++i)
		{
			if ( boost::this_thread::interruption_requested() )	// check if interruption was requested
				return;

			long tmp( k1);
			k1 = k1 + k2;
			k2 = tmp;
		}

		boost::this_thread::interruption_point();  // interruption point

		return k1;
	}

	void main()
	{
		// task, to be executed asynchronously
		boost::task::task< long > t( cooperative, 10);

		// move task to async. executor
		boost::task::handle< long > h(
			boost::task::async(
				boost::move( t),
				boost::task::new_thread() ) );

		// interrupt task and wait until task is removed by worker-thread
		h.interrupt_and_wait();

		std::cout << "is ready == " << std::boolalpha << h.is_ready() << "\n";
		std::cout << "has value == " << std::boolalpha << h.has_value() << "\n";
		std::cout << "has exception == " << std::boolalpha << h.has_exception() << "\n";

		// access result
		// throws boost::task::task_interrupted
		std::cout << h.get() << std::endl;
	}
``

[note If the task is still pending (not executed yet) when an interruption is requested - the task is not removed from the queue, it is marked to be interrupted instead.]


[heading Waiting for handles]

__boost_task__ provides function __waitfor_all__ waits for all handles passed to this function to become ready


``
	void main()
	{
		std::vector handles< boost::task::handle< long > > results;
		results.reserve( 10);

		for ( int i = 0; i < 10; ++i)
		{
			boost::task::task< long > t( fibonacci, i);

			results.push_back(
				boost::task::async(
					boost::move( t) ) );
		}

		// wait until all tasks are ready
		boost::task::waitfor_all( results.begin(), results.end() );

		int k = 0;
		std::vector< boost::task::handle< long > >::iterator e( results.end() );
		for (
			std::vector< boost::task::handle< long > >::iterator i( results.begin() );
			i != e;
			++i)
			std::cout << "fibonacci(" << k++ << ") == " << i->get() << std::endl;
	}
``


and __waitfor_any__ which returns if at least one of the passed handles becomes ready.


``
	void main()
	{
		boost::task::task< long > t1( cooperative, 10);
		boost::task::task< long > t2( cooperative, 7);
		 boost::task::task< long > t3( cooperative, 5);

		boost::task::handle< long > h1(
			boost::task::async(
				boost::move( t1) ) );
		boost::task::handle< long > h2(
			boost::task::async(
				boost::move( t2) ) );
		boost::task::handle< long > h3(
			boost::task::async(
				boost::move( t3) ) );

		// wait for any task becomes ready
		boost::task::waitfor_any( h1, h2, h3);

		if ( h1.is_ready() )
			std::cout << "fibonacci(10) == " << h1.get() << std::endl;
		if ( h2.is_ready() )
			std::cout << "fibonacci(7) == " << h2.get() << std::endl;
		if ( h3.is_ready() )
			std::cout << "fibonacci(5) == " << h3.get() << std::endl;
	}
``


[endsect]
