[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:static_pool Class template `static_pool`]

``
	#include <boost/task/static_pool.hpp>

	template< typename Channel >
	class static_pool : private noncopyable
	{
	public:
		explicit pool(
			poolsize const& psize,
			posix_time::time_duration const& asleep = posix_time::microseconds( 10),
			scanns const& scns = scanns( 20) );

		explicit pool(
			poolsize const& psize,
			high_watermark const& hwm,
			low_watermark const& lwm,
			posix_time::time_duration const& asleep = posix_time::milliseconds( 100),
			scanns const& scns = scanns( 20) );


		explicit pool(
			posix_time::time_duration const& asleep = posix_time::microseconds( 10),
			scanns const& scns = scanns( 20) );

		explicit pool(
			high_watermark const& hwm,
			low_watermark const& lwm,
			posix_time::time_duration const& asleep = posix_time::milliseconds( 100),
			scanns const& scns = scanns( 20) );

		~static_pool();

		std::size_t size();
		std::size_t active();
		std::size_t idle();

		void shutdown();
		void shutdown_now();

		bool closed();
		void clear();
		bool empty();
		std::size_t pending();

		const std::size_t upper_bound();
		void upper_bound( high_watermark const& hwm);
		const std::size_t lower_bound();
		void lower_bound( low_watermark const& lwm);

		template< typename R >
		handle< R > submit( task< R > t);

		template< typename R, typename Attr >
		handle< R > submit( task< R > t, Attr const& attr);
	};
``

[section:constructor_unbounded_channel_hw Constructor (unbounded channel)]

	explicit static_pool(
		posix_time::time_duration const& asleep = posix_time::microseconds( 10),
		scanns const& scns = scanns( 20) )

[variablelist
[[Preconditions:] [operating system provides functionality for processor pining]]
[[Effects:] [constructs a pool - for each processor a worker-thread is created and bound to one processor - global-queue can queue an unlimited number of tasks]]
[[Throws:] [`boost::task::invalid_scanns`, `boost::task::invalid_timeduration`]]
[[Notes:] [constructor has to be called if a unbounded-channel is used]]
]
[endsect]


[section:constructor_unbounded_channel Constructor (unbounded channel)]

	explicit static_pool(
		poolsize const& psize,
		posix_time::time_duration const& asleep = posix_time::microseconds( 10),
		scanns const& scns = scanns( 20) )

[variablelist
[[Effects:] [constructs a pool containing psize worker-threads - global-queue can queue an unlimited number of tasks]]
[[Throws:] [`boost::task::invalid_scanns`, `boost::task::invalid_timeduration`]]
[[Notes:] [constructor has to be called if a unbounded-channel is used]]
]
[endsect]


[section:constructor_bounded_channel_hw Constructor (bounded channel)]

	explicit static_pool(
		high_watermark const& hwm,
		low_watermark const& lwm,
		posix_time::time_duration const& asleep = posix_time::milliseconds( 100),
		scanns const& scns = scanns( 20) )

[variablelist
[[Preconditions:] [operating system provides functionality for processor pining]]
[[Effects:] [constructs a pool - for each processor a worker-thread is created and bound to one processor - global-queue can only queue a limited number of tasks]]
[[Throws:] [`boost::task::invalid_scanns`, `boost::task::invalid_timeduration`, `boost::task::invalid_watermark`]]
[[Notes:] [Constructor has to be called if a bounded-channel is used.]]
]
[endsect]


[section:constructor_bounded_channel Constructor (bounded channel)]

	explicit static_pool(
		poolsize const& psize,
		high_watermark const& hwm,
		low_watermark const& lwm,
		posix_time::time_duration const& asleep = posix_time::milliseconds( 100),
		scanns const& scns = scanns( 20) )

[variablelist
[[Effects:] [constructs a pool containing psize worker-threads - global-queue can only queue a limited number of tasks]]
[[Throws:] [`boost::task::invalid_scanns`, `boost::task::invalid_timeduration`, `boost::task::invalid_watermark`]]
[[Notes:] [constructor has to be called if a bounded-channel is used]]
]
[endsect]


[section:destructor Destructor]

	~static_pool()

[variablelist
[[Effects:] [calls `:shutdown()` if not already called]]
[[Throws:] [Nothing]]
]
[endsect]


[section:size Member function `size()`]

	std::size_t size()

[variablelist
[[Effects:] [returns how many worker-threads are running in the pool]]
[[Throws:] [Nothing]]
]
[endsect]


[section:active Member function `active()`]

	std::size_t active()

[variablelist
[[Effects:] [returns how many worker-threads are active (executing an task)]]
[[Throws:] [Nothing]]
]
[endsect]


[section:idle Member function `idle()`]

	std::size_t idle()

[variablelist
[[Effects:] [returns how many worker-threads are idle (not executing an task).]]
[[Throws:] [Nothing]]
[[Notes:] [The value is the difference of `size()` and `active()`]]
]
[endsect]


[section:shutdown Member function `shutdown()`]

	void shutdown()

[variablelist
[[Effects:] [deactivates the channel and joins all worker-threads - the pool is closed]]
[[Throws:] [Nothing]]
[[Notes:] [all pending tasks are processed]]
]
[endsect]


[section:shutdown_now Member function `shutdown_now()`]

	void shutdown_now()

[variablelist
[[Effects:] [deactivates the channel, send interruption request to all worker-threads and joins them - the pool is closed]]
[[Throws:] [Nothing]]
[[Notes:] [pending tasks are not processed but returned]]
]
[endsect]


[section:losed Member function `closed()`]

	bool closed()

[variablelist
[[Effects:] [queries if the pool is closed (pool is shutdown)]]
[[Throws:] [Nothing]]
]
[endsect]


[section:clear Member function `clear()`]

	void clear()

[variablelist
[[Effects:] [removes all pending tasks from the channel]]
[[Throws:] [Nothing]]
]
[endsect]


[section:empty Member function `empty()`]

	bool empty()

[variablelist
[[Effects:] [queries if the channel is empty]]
[[Throws:] [Nothing]]
]
[endsect]


[section:pending Member function `pending()`]

	std::size_t pending()

[variablelist
[[Effects:] [queries how many tasks are pending (still unprocessed) in the global-queue (channel)]]
[[Throws:] [Nothing]]
]
[endsect]


[section:get_upper_bound Member function `upper_bound()`]

	std::size_t upper_bound()

[variablelist
[[Preconditions:] [channel is of type bounded-channel]]
[[Effects:] [returns the upper bound of the bounded-channel]]
[[Throws:] [Nothing]]
[[Notes:] [can only be used if a bounded-channel is used]]
]
[endsect]


[section:set_upper_bound Member function `upper_bound( high_watermark const& hwm)`]

	void upper_bound( high_watermark const& hwm)

[variablelist
[[Preconditions:] [channel is of type bounded-channel]]
[[Effects:] [sets the upper bound of the bounded-channel]]
[[Postconditions:] [`this->upper_bound() == hwm`]]
[[Throws:] [`boost::task::invalid_watermark`]]
[[Notes:] [can only be used if a bounded-channel is used]]
]
[endsect]


[section:get_lower_bound Member function `lower_bound()`]

	std::size_t lower_bound();

[variablelist
[[Preconditions:] [channel is of type bounded-channel]]
[[Effects:] [returns the lower bound of the bounded-channel]]
[[Throws:] [Nothing]]
[[Notes:] [can only be used if a bounded-channel is used]]
]
[endsect]


[section:set_lower_bound Member function `lower_bound( low_watermark const& lwm)`]

	void lower_bound( low_watermark const& lwm)

[variablelist
[[Preconditions:] [channel is of type bounded-channel]]
[[Effects:] [sets the lower bound of the bounded-channel]]
[[Postconditions:] [`this->lower_bound() == lwm`]]
[[Throws:] [`boost::task::invalid_watermark`]]
[[Notes:] [can only be used if a bounded-channel is used]]
]
[endsect]


[section:submit Member function `submit( Act const& act)`]

	template< typename R >
	handle< R > submit( task< R > const& t)

[variablelist
[[Preconditions:] [has_attribute< pool >::value == false && ! closed()]]
[[Effects:] [submits an task to the pool and returns an associated handle]]
[[Throws:] [`boost::task::task_rejected`]]
]
[endsect]


[section:submit_attr Member function `submit( Act const& act, Attr const& attr)`]

	template< typename R, typename Attr >
	handle< R > submit( task< R > const& t, Attr const& attr)

[variablelist
[[Preconditions:] [has_attribute< pool >::value == true && ! closed()]]
[[Effects:] [submits an task to the pool and returns an associated handle - task is scheduled by the attribute]]
[[Throws:] [`boost::task::task_rejected`]]
]
[endsect]


[endsect]
