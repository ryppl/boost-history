[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:motivation Motivation]

To speed-up computer-bound work and/or increase the computation-throughput is a common motivation for parallelizing a program.
Especially for interactive applications that have to process user input while performing some background tasks responsivness is
very important.
Parallelizing a program requires partitioning the program into smaller chunks that can run in parallel. The code can scale as the
hardware gets better without changing the code.

The evolution from one-core to many-core architectures and the usage of threads (of course processes fit too) support this paradigm.

[note
  ["You can have multithreading on a single core machine, but you can only have parallelism on a multi core machine ... .] -- Daniel Moth
  [footnote more to read at Daniel's [@http://www.danielmoth.com/Blog/2008/11/threadingconcurrency-vs-parallelism.html blog]]
]

__boost_task__ provides a framework to utilize the available hardware and provide a way for efficient asynchronous processing of
time consuming operations.
The framework provides some __eps__, like __new_thread__, in order to execute the task asynchronously in another execution
context (__boost_task__ uses preemptible threads for this purpose).

``
	void print( std::string const& msg)
	{ printf("%s\n", msg.c_str() ); }

	void main()
	{
		// execute task in newly-created thread
		// move task ownership to executor
		boost::task::async(
			boost::task::make_task( print, "Hello World!"),
			boost::task::new_thread() ) );
	}
``

In order to manage the task __fn_async__ returns a __handle__ (associated with the submitted task). It functions as a __act__ -
that means it transfers the result of the execution back to the caller thread.

``
	std::string echo( std::string const& msg)
	{ return msg; }

	void main()
	{
		// execute task in newly-created thread
		// move task ownership to executor
		boost::task::handle< std::string > h(
			boost::task::async(
				boost::task::make_task( echo, "Hello World!"),
				boost::task::new_thread() ) );

		// wait until task has finished and return the result
		std::cout << h.get() << std::endl;
	}
``

The task can also be interrupted via __handle__ if it is a so-called [link_task __coop_task__].

``
	void long_running(  boost::posix_time::time_duration const& rel_time)
	{ boost::this_thread::sleep( rel_time);

	void main()
	{
		// execute task in newly-created thread
		// move task ownership to executor
		boost::task::handle< std::string > h(
			boost::task::async(
				boost::task::make_task(
					long_running,
					boost::posix_time::millisec( 500) ),
				boost::task::new_thread() ) );

		// requests interruption of task
		// returns immediately
		h.interrupt();

		// access the result
		// task_interrupted exeception will be thrown
		std::cout << h.get() << std::endl;		
	}
``

Beside __new_thread__ (which creates a new task for each submitted task - the thread will be joined by __handle__) __boost_task__ provides [link_pool __thread_pools__]
to prevent the overhead of thread creation and destruction of threads for each task (__thread_pools__ can be customized).

``
	long serial_fib( long n)
	{
		if( n < 2) return n;
		else return serial_fib( n - 1) + serial_fib( n - 2);
	}

	long parallel_fib( long n, long cutof)
	{
		if ( n < cutof) return serial_fib( n);
		else
		{
			// fork sub-task calculating fibonacci(n-1)
			boost::task::handle< long > h1(
				boost::task::async(
					boost::task::make_task(
						parallel_fib,
						n - 1,
						cutof),
					boost::this_task::get_pool() ) );

			// fork sub-task calculating fibonacci(n-2)
			boost::task::handle< long > h2(
				boost::task::async(
					boost::task::make_task(
						parallel_fib,
						n - 2,
						cutof),
					boost::this_task::get_pool() ) );

			// join the results of both sub-tasks
			return h1.get() + h2.get();
		}
	}

	void main()
	{
		// create a thread-pool with five worker-threads
		boost::task::static_pool<
			boost::task::unbounded_channel<
				boost::task::fifo
			>
		> pool( boost::task::poolsize( 5) );

		// execute task in a thread-pool
		// move task ownership to executor
		boost::task::handle< long > h(
			boost::task::async(
				boost::task::make_task(
					parallel_fib,
					10,
					5),
				pool) );

		// access the result
		std::cout << "fibonacci(10) == " << h.get() << std::endl;
	}
``

With function __fn_runs_in_pool__ a task can detect if it is executed inside a __thread_pool__.
__sub_tasks__ arecreated by __as_sub_task__. Where the __sub_task__ is executed by a new thread if the parent task is not
executed inside a __thread_pool__. In the other case the __sub_task__ is put into the local __worker_queue__ which enables
[link_work_stealing __work_stealing__] and [link_forkjoin inline execution] of tasks.

``
	// create a long runing task
	boost::task::task< long > t(
		parallel_fib,
		10,
		5);

	// move task ownership to executor
	// sub-task executed in a new thread or inside the thread-pool
	boost::task::async(
		boost::move( t),
		boost::task::as_sub_task() );
``


[endsect]
