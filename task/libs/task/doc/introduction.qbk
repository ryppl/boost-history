[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:motivation Motivation]

To speed-up computer-bound work and/or increase the computation-throughput is a common motivation for parallelizing a program.
Especially for interactive applications that have to process user input while performing some background tasks responsivness is
very important.
Parallelizing a program requires partitioning the program into smaller chunks that can run in parallel. The code can scale as the
hardware gets better without changing the code.

The evolution from one-core to many-core architectures and the usage of threads (of course processes fit too) support this paradigm.

[note
  ["You can have multithreading on a single core machine, but you can only have parallelism on a multi core machine ... .] -- Daniel Moth
  [footnote more to read at Daniel's [@http://www.danielmoth.com/Blog/2008/11/threadingconcurrency-vs-parallelism.html blog]]
]

__boost_task__ provides a framework to utilize the available hardware and provide a way for efficient asynchronous processing of
time consuming operations.
The framework provides some __eps__, like __new_thread__, in order to execute the task asynchronously in another execution
context (__boost_task__ uses preemptible threads for this purpose).

``
	void print( std::string const& msg)
	{ printf("%s\n", msg.c_str() ); }

	void main()
	{
		boost::task::async(                     // dispatchs task
			boost::task::make_task(         // task, to be executed asynchronously
				print,
				"Hello World!"),
			boost::task::new_thread() ) );	// execution-policy
	}
``

In order to manage the task __fn_async__ returns a handle __handle__ (associated with the submitted task). It functions as a __act__ -
that means it transfers the result of the execution back to the caller thread.

``
	std::string echo( std::string const& msg)
	{ return msg; }

	void main()
	{
		boost::task::handle< std::string > h(		// get handle associated with the task
			boost::task::async(			
				boost::task::make_task(		// task, to be executed asynchronously
					echo,
					"Hello World!"),
				boost::task::new_thread() ) );	// execution-policy
		std::cout << h.get() << std::endl;		// wait until task is finished and return the result
	}
``

The task can also be interrupted via __handle__ if it is a so-called [link_task __coop_task__].

``
	void long_running(  boost::posix_time::time_duration const& rel_time)
	{ boost::this_thread::sleep( rel_time);

	void main()
	{
		boost::task::handle< std::string > h(		// get handle associated with the task
			boost::task::async(
				boost::task::make_task(		// long runing task, to be executed asynchronously
					long_running,
					boost::posix_time::millisec( 500) ),
					boost::task::new_thread() ) );	// execution-policy
		h.interrupt();					// interrupt execution of task
		std::cout << h.get() << std::endl;		// wait until task is finished, will throw an exeception
	}
``

Beside __new_thread__ (which creates a new task for each submitted task) __boost_task__ provides [link_pool __thread_pools__]
to prevent the overhead of thread creation and destruction for each task. __default_pool__ submitts the tasks to the default
__thread_pool__  which contains a fixed number of pre-spawned __worker_threads__ (custom __thread_pools__ are supported too).

``
	long serial_fib( long n)
	{
		if( n < 2) return n;
		else return serial_fib( n - 1) + serial_fib( n - 2);
	}

	long parallel_fib( long n, long cutof)
	{
		if ( n < cutof) return serial_fib( n);
		else
		{
			// fork a sub-task calculating fibonacci(n-1)
			h1 = boost::task::async(
				boost::task::make_task(
					parallel_fib,
					n - 1,
					cutof),
					boost::this_task::get_pool() );

			// fork a sub-task calculating fibonacci(n-2)
			h2 = boost::task::async(
				boost::task::make_task(
					parallel_fib,
					n - 2,
					cutof),
				boost::this_task::get_pool() );

			// join the results of both sub-tasks
			return h1.get() + h2.get();
		}
	}

	void main()
	{
		boost::task::handle< long > h(				// handle for fibonacci calculation
			boost::task::async(
				boost::task::make_task(			// calculate fibonacci number 10
					parallel_fib,			// for numbers < 5 do inline recursive calculation
					10,
					5),
				boost::task::default_pool() ) );	// access the default thread-pool
		std::cout << h.get() << std::endl;
	}
``

With function __fn_runs_in_pool__ a task can detect if it is executed inside a __thread_pool__.
__sub_tasks__ arecreated by __as_sub_task__. Where the __sub_task__ is executed by a new thread if the parent task is not
executed inside a __thread_pool__. In the other case the __sub_task__ is put into the local __worker_queue__ which enables
[link_work_stealing __work_stealing__] and [link_forkjoin inline execution] of tasks.

``
	boost::task::async(
		boost::task::make_task(		// the thread-pool depending upon the parent
			parallel_fib,		// task is executed inside a thread-pool or not
			10,
			5),
		boost::task::as_sub_task() ) );	// sub-task executed in a new thread or inside
``

[endsect]
