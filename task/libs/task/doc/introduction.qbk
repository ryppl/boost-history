[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:motivation Motivation]

In order to take advantage of the technological evolution from single-core to many-core architectures multi-core machines,
partitioning the compute bound work into smaller chunks that can run in parallel is required.
The code can scale as the hardware gets better without changing the code (achieving desired load balancing).

[note Equating multithreading to parallelism is not accurate. You can have multithreading on a single-core machine,
but you can only have parallelism on a multi-core machine (portions of your code that can truly run at the same time).]

__boost_task__ provides a framework to utilize the available hardware and provide a way for efficient asynchronous processing of time consuming operations in the same process.

The framework provides some __aes__, like __new_thread__, in order to launch __task__ in a new thread:

	std::string echo( std::string const& msg)
	{ return msg; }

	void main()
	{
		boost::task::handle< std::string > h(
			boost::task::async(
				boost::task::new_thread(),
				boost::task::make_task(
					echo,
					"Hello World!") ) );
		std::cout << h.get() << std::endl;
	}

__handle__ manages the __task__ and allows to transfer the result to the caller thread.

With __runs_in_pool__ the task can detect if it is running inside a __thread_pool__ (executed by a __worker_thread__) at runtime.

	long serial_fib( long n)
	{
		if( n < 2) return n;
		else return serial_fib( n - 1) + serial_fib( n - 2);
	}

	long parallel_fib( long n, long cutof)
	{
		if ( n < cutof) return serial_fib( n);
		else
		{
			boost::task::handle< long > h1, h2;
			if ( boost::this_task::runs_in_pool() )
			{
				// task is executed inside a thread-pool
				// the sub-tasks are submitted to the thread-local
				// worker-queue for speed improvments
				h1 = boost::task::async(
					boost::this_task::as_sub_task(),
					boost::task::make_task(
						parallel_fib,
						n - 1,
						cutof) );
				h2 = boost::task::async(
					boost::this_task::as_sub_task(),
					boost::task::make_task(
						parallel_fib,
						n - 2,
						cutof) );
			}
			else
			{
				// task is not running inside a thread-pool
				// the sub-tasks are executed in new threads
				h1 = boost::task::async(
					boost::this_task::new_thread(),
					tsk::make_task(
						parallel_fib,
						n - 1,
						cutof) );
				h2 = boost::task::async(
					boost::this_task::new_thread(),
					boost::task::make_task(
						parallel_fib,
						n - 2,
						cutof) );
			}
			return h1.get() + h2.get();
		}
	}

	void main()
	{
		boost::task::handle< long > h(
			boost::task::async(
				// boost::task::new_thread(),
				boost::task::default_pool(),
				boost::task::make_task(
					parallel_fib,
					10,
					5) ) );
		std::cout << h.get() << std::endl;
	}
};


[endsect]
