[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:motivation Motivation]

To speed-up computer-bound work and/or increase the computation-throughput is a common motivation for parallelizing a program.
Especially for interactive applications that have to process user input while performing some background tasks responsivness is
very important.
Parallelizing a program requires partitioning the program into smaller chunks that can run in parallel. The code can scale as the
hardware gets better without changing the code.

The evolution from one-core to many-core architectures and the usage of threads (of course processes fit too) support this paradigm.

[note
  ["You can have multithreading on a single core machine, but you can only have parallelism on a multi core machine ... .] -- Daniel Moth
  [footnote more to read at Daniel's [@http://www.danielmoth.com/Blog/2008/11/threadingconcurrency-vs-parallelism.html blog]]
]

__boost_task__ provides a framework to utilize the available hardware and provide a way for efficient asynchronous processing of
time consuming operations.
The framework provides some __eps__, like __new_thread__, in order to execute the task asynchronously in another execution
context (__boost_task__ uses preemptible threads for this purpose).

``
	void print( std::string const& msg)
	{ printf("%s\n", msg.c_str() ); }

	void main()
	{
		// task, to be executed asynchronously
		boost::task::task< void > t( print, "Hello World!");

		boost::task::async(                     // dispatchs task,
			boost::move( t),		// move task ownership to executor
			boost::task::new_thread() ) );	// execution-policy
	}
``

In order to manage the task __fn_async__ returns a __handle__ (associated with the submitted task). It functions as a __act__ -
that means it transfers the result of the execution back to the caller thread.

``
	std::string echo( std::string const& msg)
	{ return msg; }

	void main()
	{
		// task returning the submitted string
		boost::task::task< std::string > t( echo, "Hello World!");

		boost::task::handle< std::string > h(
			boost::task::async(
				boost::move( t),		// move task ownership to executor
				boost::task::new_thread() ) );	// execute task in a new thread

		std::cout << h.get() << std::endl;		// wait until task is finished and return the result
	}
``

The task can also be interrupted via __handle__ if it is a so-called [link_task __coop_task__].

``
	void long_running(  boost::posix_time::time_duration const& rel_time)
	{ boost::this_thread::sleep( rel_time);

	void main()
	{
		// long runing task
		boost::task::task< void > t( long_running, boost::posix_time::millisec( 500) );

		boost::task::handle< std::string > h(
			boost::task::async(
				boost::move( t),		// move task ownership to executor
				boost::task::new_thread() ) );	// execute task in a new thread

		h.interrupt();					// interrupt execution of task

		std::cout << h.get() << std::endl;		// wait until task is finished, will throw an task_interrupted exeception
	}
``

Beside __new_thread__ (which creates a new task for each submitted task - the thread will be joined by __handle__) __boost_task__ provides [link_pool __thread_pools__]
to prevent the overhead of thread creation and destruction of threads for each task (__thread_pools__ can be customized).

``
	long serial_fib( long n)
	{
		if( n < 2) return n;
		else return serial_fib( n - 1) + serial_fib( n - 2);
	}

	long parallel_fib( long n, long cutof)
	{
		if ( n < cutof) return serial_fib( n);
		else
		{
			// fork a sub-task calculating fibonacci(n-1)
			boost::task::task< long > t1(
				parallel_fib,
				n - 1,
				cutof);
			// fork a sub-task calculating fibonacci(n-2)
			boost::task::task< long > t2(
				parallel_fib,
				n - 2,
				cutof);

			boost::task::handle< long > h1(
				boost::task::async(
					boost::move( t1),
					boost::this_task::get_pool() ) );
			boost::task::handle< long > h2(
				boost::task::async(
					boost::move( t2),
					boost::this_task::get_pool() ) );

			// join the results of both sub-tasks
			return h1.get() + h2.get();
		}
	}

	void main()
	{
		boost::task::static_pool<
			boost::task::unbounded_channel<
				boost::task::fifo
			>
		> pool( boost::task::poolsize( 5) );

		// task calculates fibonacci-number for 10
		boost::task::task< long > t(
			parallel_fib,
			10,
			5);

		boost::task::handle< long > h(
			boost::task::async(
				boost::move( t),			// move task ownership to thread-pool
				boost::task::default_pool() ) );	// execution-policy == thread-pool

		std::cout << h.get() << std::endl;
	}
``

With function __fn_runs_in_pool__ a task can detect if it is executed inside a __thread_pool__.
__sub_tasks__ arecreated by __as_sub_task__. Where the __sub_task__ is executed by a new thread if the parent task is not
executed inside a __thread_pool__. In the other case the __sub_task__ is put into the local __worker_queue__ which enables
[link_work_stealing __work_stealing__] and [link_forkjoin inline execution] of tasks.

``
	boost::task::task< long > t(
		parallel_fib,
		10,
		5);

	boost::task::async(
		boost::move( t),
		boost::task::as_sub_task() );	// sub-task executed in a new thread or inside a thread-pool
``


[endsect]
