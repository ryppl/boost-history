[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:static_pool __static_pool__]

The first template argument specifies the channel type and the scheduling policy.

    boost::tp::pool<
      boost::tp::unbounded_channel< boost::tp::fifo >
    > pool(
      boost::tp::poolsize( 6),
      boost::posix_time::posix_time::milliseconds( 50),
      boost::tp::scanns(10) );

In the example above a __threadpool__ is created with a __unbounded_channel__, scheduling __actions__ in ['FIFO] order. The pool contains six __worker_threads__ going to sleep for 50 millisec after 10 iterations without geting an __action__ from the __global_queue__, from its local __worker_queue__ or local queues of other __worker_threads__.

    boost::tp::pool<
      boost::tp::bounded_channel< boost::tp::priority < int > >
    > pool(
      boost::tp::poolsize( 10),
      boost::tp::high_watermark( 10),
      boost::tp::low_watermark( 5) );

This pool uses a __bounded_channel__ which schedules __actions__ by integer atrributes. A maximum of 10 __actions__ can be queued in the __global_queue__ without blocking the inserting thread.


[heading Shutdown]

If `boost::tp::pool< Channel >::shutdown()` is called - the the pool is set closed and all __worker_threads__ are joined until all pending __actions__ are processed. No futher __actions__ can be submitted by application threads.

[note The deconstructor calls `boost::tp::pool< Channel >::shutdown()` if the pool was not shutdown yet.]

    boost::tp::pool<
      boost::tp::unbounded_channel< boost::tp::fifo >
    > pool( boost::tp::poolsize( 1) );

    boost::tp::task< int > t1(
      pool.submit(
      boost::bind(
        fibonacci_fn,
        10) ) );
    boost::tp::task< int > t2(
      pool.submit(
        boost::bind(
          fibonacci_fn,
          10) ) );

    pool.shutdown();

    std::cout << t1.result().get() << std::endl; // 55
    std::cout << t2.result().get() << std::endl; // 55

[heading Shutdown immediatly]
The function `boost::tp::pool< Channel >::shutdown_now()` closes the pool, interrupts and then joins all __worker_threads__. All pending (unprocessed) __actions__ will be returned.

[important Pending __actions__ in the local __worker_queues__ are not returned if `boost::tp::pool< Channel >::shutdown_now()` was called.]


[heading Default pool]

The free function `boost::tp::get_default_pool()` returns a reference to the default __threadpool__ instance. The default __threadpool__ is
of type `boost::tp::pool< boost::tp::unbounded_channel< boost::tp::fifo > >` and will contain as many __worker_threads__ as 
`boost::thread::hardware_concurrency()` returns. 


[heading Processor binding]

For some applications it is convenient to bind the worker threads of the pool to processors of the system. For this purpose BOOST_BIND_WORKER_TO_PROCESSORS must be defined. Without the poolsize in the construtor the __threadpool__ will contain as many
__worker_threads__ as processors (== __hardware_concurrency__) are available and each __worker_thread__ is bound to one processor.

	boost::tp::pool<
      boost::tp::unbounded_channel< boost::tp::fifo >
    > pool;

The code above will create a pool with two __worker_threads__ on a dual core system (each bound to one core).


[endsect]

