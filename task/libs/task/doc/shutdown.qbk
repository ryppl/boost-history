[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:pool_shutdown Pool shutdown]

__boost_task__ allows to shutdown a __thread_pool__ explicitly via functions __fn_shutdown__ and __fn_shutdown_now__.
The destructor of the pool calls __fn_shutdown__ if not already done so that all __worker_threads__ are joined and the topic of 
[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html N2802] should be addressed.

[heading Shutdown]

If __fn_shutdown__ is called - the the pool is set the closed state and all __worker_threads__ are joined until all pending __tasks__ are processed.
No futher __tasks__ can be submitted.

[note The deconstructor calls __fn_shutdown__ if the pool was not shutdown yet.]


``
	long fibonacci_fn( long n)
	{
		if ( n == 0) return 0;
		if ( n == 1) return 1;
		long k1( 1), k2( 0);
		for ( int i( 2); i <= n; ++i)
		{
			long tmp( k1);
			k1 = k1 + k2;
			k2 = tmp;
		}
		return k1;
	}

	typedef boost::task::static_pool<
		boost::task::unbounded_channel<
			boost::task::fifo
		>
	> pool_type;

	void main()
	{
		pool_type pool( boost::task::poolsize( 1) );

		...

		boost::task::handle< long > h1(
			boost::task::async(
				pool,	// asynchronous executor
				boost::task::make_task( fibonacci_fn, 10) ) );

		boost::task::handle< long > h2(
			boost::task::async(
				pool,	// asynchronous executor
				boost::task::make_task( fibonacci_fn, 5) ) );

		pool.shutdown();

		std::cout << "fibonacci(10) == " << h1.get() << "\n";
		std::cout << "fibonacci(5) == " << h2.get() << std::endl;
	}
``


[heading Shutdown immediatly]

The function __fn_shutdown_now__ closes the pool, interrupts and then joins all __worker_threads__. Pending __tasks__ are unprocessed.


``
	long fibonacci_fn( long n)
	{
		if ( n == 0) return 0;
		if ( n == 1) return 1;
		long k1( 1), k2( 0);
		for ( int i( 2); i <= n; ++i)
		{
			long tmp( k1);
			k1 = k1 + k2;
			k2 = tmp;
		}
		return k1;
	}

	typedef boost::task::static_pool<
		boost::task::unbounded_channel<
			boost::task::fifo
		>
	> pool_type;

	void main()
	{
		pool_type pool( boost::task::poolsize( 1) );

		...

		boost::task::handle< long > h1(
			boost::task::async(
				pool,	// asynchronous executor
				boost::task::make_task( fibonacci_fn, 10) ) );

		boost::task::handle< long > h2(
			boost::task::async(
				pool,	// asynchronous executor
				boost::task::make_task( fibonacci_fn, 5) ) );

		pool.shutdown_now();

		std::cout << "fibonacci(10) == " << h1.get() << "\n";		// may throw broken_task or task_interrupted
		std::cout << "fibonacci(5) == " << h2.get() << std::endl;	// may throw broken_task or task_interrupted
	}
``


[endsect]

