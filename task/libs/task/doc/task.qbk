[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:task Task]

A task is a chunk of code that can be executed independently.

__task__ represents a __callable__ (provides __fn_operator__) object containing the unit of code to be execute by a __ep__.
Function __fn_get_future__ returns a __act__ allowing to wait for the completion of the computation of the task, for
getting the result of a computation or for transfering exceptions. __task__ supports move semantics (moving ownership).

[/
[heading Creation]

__tasks__ are created by passing free-functions or member-functions of objects and its arguments to the task-constructor.

* create task from free-function with arguments:

``
	boost::task::task< int > t( parallel_fib, 10);
``

* create task from member-function with arguments:

``
	struct X
	{
		void f( int i);
	};

	X x;
	boost::task::task< int > t(
		& X::f,
		x,
		10);
``

It is possible to create __task__ from a __callable__ too:

``
	struct Y
	{
		std::string operator()();
	};
    
	Y y;
	boost::task::task< std::string > t( y);
``
]

[heading Cooperative task and interruption]

Sometimes it is desired to stop a running task if it is no longer needed. In this case the thread is not killed - it stops
only at well-defined points (__interruption_points__) its execution.
In the context of task-interruption a task is known as cooperative if it checks for an interruption request between two
__interruption_points__ via __fn_interruption_requested__ [footnote see [@http://www.ddj.com/architect/207100682
'Interrupt Politely'], Herb Sutter].

__interruption_points__ are:

* `boost::thread::join()`
* `boost::thread::timed_join()`
* `boost::condition_variable::wait()`
* `boost::condition_variable::timed_wait()`
* `boost::condition_variable_any::wait()`
* `boost::condition_variable_any::timed_wait()`
* `boost::thread::sleep()`
* `boost::this_thread::sleep()`
* `boost::this_thread::interruption_point()`

A __interruption_point__ throws __task_interrupted__ if an interruption was requested.

``
	long cooperative( long n)
	{
		boost::this_thread::interruption_point(); // interruption point
		
		if ( n == 0) return 0;
		if ( n == 1) return 1;
		long k1( 1), k2( 0);
		for ( int i( 2); i <= n; ++i)
		{
			if ( boost::this_thread::interruption_requested() )	// check if interruption was requested
				return;
				
			long tmp( k1);
			k1 = k1 + k2;
			k2 = tmp;
		}
		
		boost::this_thread::interruption_point();  // interruption point
		
		return k1;
	}

	void main()
	{
		// task for calculating fibonacci number
		boost::task::task< long > t( cooperative, 10) );

		// execute task in new thread
		boost::task::handle< long > h(
			boost::task::async(
				boost::move( t),
				boost::task::new_thread() ) );

		// interrupt task an wait until it is removed by the worker-thread
		h.interrupt_and_wait();

		// throws boost::task::task_interrupted
		std::cout << h.get() << std::endl;
	}
``


[heading Exceptions]

Exceptions thrown by __task__ are transported by the __act__.

``
	void throwing()
	{
		...
		throw std::domain_error("domain error");
		...
	}

	void main()
	{
		// task will throw std::domain_error
		boost::task::task void > t( throwing);

		// execute task asynchron
		boost::task::handle< void > h(
			boost::task::async(
				boost::move( t),
				boost::task::new_thread() ) );

		// throws std::domain_error
		std::cout << h.wait() << std::endl;
	}
``

Exceptions rethrown by type are:

*  `std::bad_alloc`
*  `std::bad_cast`
*  `std::bad_exception`
*  `std::bad_typeid`
*  `std::domain_error`
*  `std::invalid_argument`
*  `std::ios_base::failure`
*  `std::length_error`
*  `std::logic_error`
*  `std::out_of_range`
*  `std::overflow_error`
*  `std::range_error`
*  `std::runtime_error`
*  `std::underflow_error`
*  `boost::exception`
*  `boost::future_already_set`
*  `boost::future_cancel`
*  `boost::invalid_thread_argument`
*  `boost::lock_error`
*  `boost::broken_task`
*  `boost::pool_moved`
*  `boost::task_already_executed`
*  `boost::task_interrupted`
*  `boost::task_moved`
*  `boost::task::task_interrupted`
*  `boost::task_task_rejected`
*  `boost::task_unitialized`


[heading Parent task]

Top-level tasks have no parent. A parent task can create child tasks when it creates another task by using __as_sub_task__ as __ep__.  These children are implicitly treated as __sub_tasks__ of the larger task.  It is assumed that that __sub_tasks__ can be executed in any order because only overall operation
speed matters (enabling strategies for fast execution of unordered __work_items__ as [link_work_stealing __work_stealing__]).

``
	long serial_fib( long n)
	{
		if( n < 2) return n;
		else return serial_fib( n - 1) + serial_fib( n - 2);
	}

	long parallel_fib( long n, long cutof)
	{
		if ( n < cutof) return serial_fib( n);
		else
		{
			// sub-task for calculating fibonacci(n-1)
			boost::task::task< long > t1(
				parallel_fib,
				n - 1,
				cutof);
			// sub-task for calculating fibonacci(n-2)
			boost::task::task< long > t2(
				parallel_fib,
				n - 2,
				cutof);

			// submit a sub-task to pool calculating fibonacci(n-1)
			boost::task::handle< long > h1(
				boost::task::async(
					boost::move( t1) );
			// submit a sub-task to pool calculating fibonacci(n-2)
			boost::task::handle< long > h2(
				boost::task::async(
					boost::move( t2) );

			// calculate fibonacci(n) by joining results of both sub-tasks
			return h1.get() + h2.get();
		}
	}

	void main()
	{
		// create thread-pool
		boost::task::static_pool<
			boost::task::unbounded_channel<
				boost::task::fifo
			>
		> pool( boost::task::poolsize( 5) );

		// task calculates recursivly fibonacci-numberof 10
		boost::task::task< long > t(
			parallel_fib,
			10,
			5);

		// execute task asynchron in thread-pool
		boost::task::handle< long > h(
			boost::task::async(
				boost::move( t),
				pool) );

		// get result
		std::cout << h.get() << std::endl;
	}
``

[endsect]
