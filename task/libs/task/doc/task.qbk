[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:task Task]

A task is a chunk of code that can be executed independently.

__task__ represents a __callable__ (provides __fn_operator__) object containing the unit of code to be execute by a link_ae[__ae__]. Function __fn_get_future__ returns a link_act[__act__] allowing to wait for the completion of the computation of the task, for getting the result of a computation or for transfering exceptions.
Each __task__ has a unique identifier 


[heading:create Creation]

__fn_make_task__ can be used to create __task__ by passing free-functions or member-functions of objects and its arguments: __fn_make_task__ accepts up to ten
arguments per default (can be overriden by defining BOOST_TASK_MAKE_TASK_MAX_ARITY with the new value).

* create task from free-function with arguments:

``
	boost::task::task< int > t(
		boost::task::make_task(
			parallel_fib,
			10) );
``

* create task from member-function with arguments:

``
	struct X
	{
		void f( int i);
	};

	X x;
	boost::task::task< int > t(
		boost::task::make_task(
			& X::f,
			x,
			10) );
``

It is possible to create __task__ from a __callable__ too:

``
	struct Y
	{
		std::string operator()();
	};
    
	Y y;
	boost::task::task< std::string > t( y);
``

[heading:cooperative Cooperative task amd interruption]

Sometimes it is desired to stop a running task if it is no longer needed. In this case the thread is not killed -
it stops only at well-defined points (__interruption__points__) its execution.
In the context of task-interruption a task is known as cooperative if it checks for an interruption request between 
two __interruption__points__ via __fn__interruption_requested__
[footnote see [@http://www.ddj.com/architect/207100682 'Interrupt Politely'], Herb Sutter].

__interruption__points__ are:

* `boost::thread::join()`
* `boost::thread::timed_join()`
* `boost::condition_variable::wait()`
* `boost::condition_variable::timed_wait()`
* `boost::condition_variable_any::wait()`
* `boost::condition_variable_any::timed_wait()`
* `boost::thread::sleep()`
* `boost::this_thread::sleep()`
* `boost::this_thread::interruption_point()`

A __interruption__point__ throws __task_interrupted__ if an interruption was requested.

``
	long cooperative( long n)
	{
		boost::this_thread::interruption_point(); // interruption point
		
		if ( n == 0) return 0;
		if ( n == 1) return 1;
		long k1( 1), k2( 0);
		for ( int i( 2); i <= n; ++i)
		{
			if ( boost::this_thread::interruption_requested() )	// check if interruption was requested
				return;
				
			long tmp( k1);
			k1 = k1 + k2;
			k2 = tmp;
		}
		
		boost::this_thread::interruption_point();  // interruption point
		
		return k1;
	}

	void main()
	{
		boost::task::handle< long > h(			// get handle associated with the task
			boost::task::async(			
				boost::task::new_thread(),	// asynchronous executor
				boost::task::make_task(		// task, to be executed asynchronously
					cooperative,
					10) ) );
		std::cout << h.get() << std::endl;		// throws boost::task::task_interrupted
	}
``

[heading:exceptions Exceptions]

Exceptions thrown by __task__ are transported by the __act__.

``
	void throwing()
	{
		...
		throw std::domain_error("domain error");
		...
	}

	void main()
	{
		boost::task::handle< void > h(			// get handle associated with the task
			boost::task::async(			
				boost::task::new_thread(),	// asynchronous executor
				boost::task::make_task(		// task, to be executed asynchronously
					throwing) ) );
		std::cout << h.wait() << std::endl;		// throws std::domain_error
	}
``

Exceptions rethrown by type are:

*  `std::bad_alloc`
*  `std::bad_cast`
*  `std::bad_exception`
*  `std::bad_typeid`
*  `std::domain_error`
*  `std::invalid_argument`
*  `std::ios_base::failure`
*  `std::length_error`
*  `std::logic_error`
*  `std::out_of_range`
*  `std::overflow_error`
*  `std::range_error`
*  `std::runtime_error`
*  `std::underflow_error`
*  `boost::future_already_set`
*  `boost::future_cancel`
*  `boost::exception`
*  `boost::invalid_thread_argument`
*  `boost::lock_error`
*  `boost::task::task_interrupted`
*  `boost::broken_task`


[heading:parent Parent-tasks]

Top-level tasks have no parent. A parent task can create child tasks when it creates another task by using __as_sub_task__ as __ae__.  These children are implicitly treated as __sub_tasks__ of the larger task.  It is assumed that that __sub_tasks__ can be executed in any order because only overall operation
speed matters (enabling strategies for fast execution of unordered work-items as link_work_stealing[__work_stealing__]).

``
	long serial_fib( long n)
	{
		if( n < 2) return n;
		else return serial_fib( n - 1) + serial_fib( n - 2);
	}

	long parallel_fib( long n, long cutof)
	{
		if ( n < cutof) return serial_fib( n);
		else
		{
			// submit a sub-task to pool calculating fibonacci(n-1)
			h1 = boost::task::async(
				boost::task::as_sub_task(),	// execute a sub-task
				boost::task::make_task(
					parallel_fib,
					n - 1,
					cutof) );
			// submit a sub-task to pool calculating fibonacci(n-2)
			h2 = boost::task::async(
				boost::task::as_sub_task(),	// execute a sub-task
				boost::task::make_task(
					parallel_fib,
					n - 2,
					cutof) );
			// calculate fibonacci(n) from the results of both sub-tasks
			return h1.get() + h2.get();
		}
	}

	void main()
	{
		boost::task::handle< long > h(			// handle for fibonacci calculation
			boost::task::async(
				boost::task::default_pool(),	// access the default thread-pool
				boost::task::make_task(		// calculate fibonacci number 10
					parallel_fib,		// for numbers < 5 do inline recursive calculation
					10,
					5) ) );  
		std::cout << h.get() << std::endl;
	}
``

[endsect]
