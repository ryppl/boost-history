[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:task Task]

A task is a chunk of code that can be executed independently.

__task__ represents a __callable__ object containing the unit of code to be execute by a link_ae[__ae__]. It returns a link_act[__act__] allowing to wait for the completion of the computation of the task, for getting the result of a computation or for transfering exceptions.


[heading:create_task Creation]

__fn_make_task__ can be used to create __task__.
The __task__ object acts as a proxy for a result that is initially not known and gets evaluated later by a __worker_thread__. It transports the result (value or exception) of the __action__ back to the caller.

    boost::task::task< int > t1(
      boost::task::make_task(
	  parallel_fib,
	  10) );    

[heading:cooperative_task Interruption]

__task__ object provides the possiblity to interrupt an __action__ if it is cooperative.
An __action__ is known as cooperative if it includes interruption points in its code:

* `boost::thread::join()`
* `boost::thread::timed_join()`
* `boost::condition_variable::wait()`
* `boost::condition_variable::timed_wait()`
* `boost::condition_variable_any::wait()`
* `boost::condition_variable_any::timed_wait()`
* `boost::thread::sleep()`
* `boost::this_thread::sleep()`
* `boost::this_thread::interruption_point()`

[important Interruption must not be disabled for the __worker_thread__ (class ['boost::this_thread::disable_interruption]).]

The __action__ will be interrupted even if it is pending (interruption is remembered).
A ['boost::thread_interrupted] exception will be thrown by `boost::tp::task< T >::get()` if the __action__ was interrupted.
``
    boost::tp::pool<
      boost::tp::unbounded_channel< boost::tp::fifo >
    > pool( boost::tp::poolsize( 10) );

    // submit a long running task
    boost::tp::task< int > t(
      pool.submit(
        boost::bind(
          long_running_fn) ) );

    // interrupt task
    t.interrupt();

    // throws boost::thread_interrupted exception
    std::cout << t.get() << std::endl;
``

    boost::tp::pool<
      boost::tp::unbounded_channel< boost::tp::fifo >
    > pool( boost::tp::poolsize( 10) );

    // submit a long running task
    boost::tp::task< int > t(
      pool.submit(
        boost::bind(
          long_running_fn) ) );

    // interrupt task and wait for its termination
    t.interrupt_and_wait();

    // throws boost::thread_interrupted exception
    std::cout << t.get() << std::endl;


[heading:task_exceptions Exceptions]

Exceptions thrown inside an __action__ are transported by the associated task object.
Exceptions rethrown by type:

*  `std::bad_alloc`
*  `std::bad_cast`
*  `std::bad_exception`
*  `std::bad_typeid`
*  `std::domain_error`
*  `std::invalid_argument`
*  `std::ios_base::failure`
*  `std::length_error`
*  `std::logic_error`
*  `std::out_of_range`
*  `std::overflow_error`
*  `std::range_error`
*  `std::runtime_error`
*  `std::underflow_error`
*  `boost::broken_promise`
*  `boost::future_already_set`
*  `boost::future_cancel`
*  `boost::exception`
*  `boost::invalid_thread_argument`
*  `boost::lock_error`
*  `boost::thread_exception`
*  `boost::thread_interrupted`
*  `boost::thread_permission_error`
*  `boost::thread_resource_error`
*  `boost::unsupported_thread_option`

Exceptions derived from `std::exception` will be rethrown as `std::runtime_error` in all other cases a `std::bad_exception` is thrown.

    boost::tp::pool<
      boost::tp::unbounded_channel< boost::tp::fifo >
    > pool( boost::tp::poolsize( 10) );

    // task will throw an exception derived from std::exception
    boost::tp::task< int > t(
      pool.submit(
        boost::bind(
          throwing_fn) ) );

    std::cout << t.get() << std::endl; // will rethrow an std::runtime_error

[heading:parent_tasks Parent-tasks]

Top-level Tasks have no parent.  These are Tasks created by non-thread-pool threads, or with certain options specified at Task-creation time.  These tasks are queued to the same FIFO queue we use for QUWI, and thus benefit from the improvements we’ve made there – but they are also subject to the same limitations.  Tasks queued in this way are simply a better QUWI – but now the fun starts:  A parent task can create child tasks.  This happens whenever a Task creates another Task (unless it overrides this behavior).  These children are implicitly treated as sub-tasks of the larger task.  We assume that sub-tasks can be executed in any order – fairness is not necessary – because all that matters is that the overall operation be completed as fast as possible.  This lets us throw those FIFO restrictions out the window, and opens up the possibility for much more efficient work scheduling strategies.

Since a child task is just a piece of a larger task, we don’t need to worry about execution order.  We just need to execute these things quickly.  One well-known strategy for fast execution of unordered work items is link_work_stealing[__work_stealing__].


[endsect]
