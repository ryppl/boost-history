[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:handle Class template `handle`]

``
	#include <boost/task/handle.hpp>

	template< typename R >
	class handle
	{
		handle();
		handle( shared_future< R >, context const&);

		void interrupt();
		void interrupt_and_wait();
		void interrupt_and_wait_until( system_time const& abs_time);
		template< typename TimeDuration >
		void interrupt_and_wait_for( Duration const& rel_time);
		bool interruption_requested();

		R get();
		bool is_ready() const;
		bool has_value() const;
		bool has_exception() const;
		void wait() const;

		shared_future< R > & get_future();

		void swap( handle< R > & other);
	};

	template< typename Iterator >
	friend void waitfor_all( Iterator begin, Iterator end);

	template< typename T1, typename T2 >
	friend void waitfor_all( T1 & t1, T2 & t2);
	...
	template< typename T1, typename T2, typename T3, typename T4, typename T5 >
	friend void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5);

	template< typename Iterator >
	friend Iterator waitfor_any( Iterator begin, Iterator end);

	template< typename T1, typename T2 >
	friend unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2);
	...
	template< typename T1, typename T2, typename T3, typename T4, typename T5 >
	friend unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5);
``

[heading Constructor `handle()`]

	handle()

[variablelist
[[Effects:] [constructs an empty (invalid) handle]]
[[Throws:] [Nothing]]
]


[heading Constructor `handle( shared_future< R >, context const&)`]

	handle( shared_future< R >, context const&);

[variablelist
[[Effects:] [constructs an handle associated with anfuture and an context]]
[[Throws:] [Nothing]]
]


[heading Member function `interruption_requested()`]

	bool interruption_requested()

[variablelist
[[Effects:] [checks if interruption is already requested]]
[[Throws:] [Nothing]]
]


[heading Member function `interrupt()`]

	void interrupt()

[variablelist
[[Effects:] [requests task interruption; doesn not block (immediatly returns)]]
[[Throws:] [Nothing]]
]


[heading Member function `interrupt_and_wait()`]

	void interrupt_and_wait()

[variablelist
[[Effects:] [requests task interruption and blocks until worker-thread stops task]]
[[Throws:] [`boost::thread_resource_error`]]
]


[heading Member function `interrupt_and_wait_until()`]

	bool interrupt_and_wait_until( system_time const& abs_time)

[variablelist
[[Effects:] [requests task interruption and blocks until worker-thread stops task or time-point elapsed]]
[[Returns:] [false if the the time specified by abs_time was reached, true otherwise]]
[[Throws:] [`boost::thread_resource_error`]]
]


[heading Member function `interrupt_and_wait_for()`]

	template< typename TimeDuration >
	bool interrupt_and_wait_for( Duration const& rel_time)

[variablelist
[[Effects:] [requests task interruption and blocks until worker-thread stops task or time-duration elapsed]]
[[Returns:] [false if the the time specified by rel_time was reached, true otherwise]]
[[Throws:] [`boost::thread_resource_error`]]
]


[heading Member function `get()`]

	R get()

[variablelist
[[Effects:] [requests the result]]
[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_uninialized`, `boost::task::task_rejected`, `boost::task::broken_task`]]
]


[heading Member function `wait()`]

	void wait()

[variablelist
[[Effects:] [blocks caller until task is done]]
[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_uninialized`, `boost::task::task_rejected`, `boost::task::broken_task`]]
]


[heading Member function `wait_for()`]

	template< typename TimeDuration >
	bool wait_for( Duration const& rel_time) const

[variablelist
[[Effects:] [blocks caller until task is done]]
[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_uninialized`, `boost::task::task_rejected`, `boost::task::broken_task`]]
]


[heading Member function `wait_until()`]

	bool wait_until( system_time const& abs_time) const

[variablelist
[[Effects:] [blocks caller until task is done]]
[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_uninialized`, `boost::task::task_rejected`, `boost::task::broken_task`]]
]


[heading Member function `is_ready()`]

	bool is_ready()

[variablelist
[[Effects:] [checks if task is done]]
[[Throws:] [Nothing]]
]


[heading Member function `has_value()`]

	bool has_value()

[variablelist
[[Effects:] [checks if task is done and a result value is set]]
[[Throws:] [Nothing]]
]


[heading Member function `has_exception()`]

	bool has_exception()

[variablelist
[[Effects:] [checks if task is done and an exception is set]]
[[Throws:] [Nothing]]
]


[heading Member function `get_future()`]

	shared_future< R > & get_future()

[variablelist
[[Effects:] [returns a reference to the internal shared_future< R >]]
[[Throws:] [Nothing]]
]


[heading Member function `swap()`]

	void swap( handle< R > & other)

[variablelist
[[Effects:] [swapps handle]]
[[Throws:] [Nothing]]
]


[heading Non-member function `wait_for_all()`]

	template< typename Iterator >
	void waitfor_all( Iterator begin, Iterator end);

	template< typename T1, typename T2 >
	void waitfor_all( T1 & t1, T2 & t2);

	template< typename T1, typename T2, typename T3 >
	void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3);

	template< typename T1, typename T2, typename T3, typename T4 >
	void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4);

	template< typename T1, typename T2, typename T3, typename T4, typename T5 >
	void waitfor_all( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5);

[variablelist
[[Effects:] [waits for all handles to become ready]]
[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_rejected`]]
]


[heading Non-member function `wait_for_any()`]

	template< typename Iterator >
	Iterator waitfor_any( Iterator begin, Iterator end);

	template< typename T1, typename T2 >
	unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2);

	template< typename T1, typename T2, typename T3 >
	unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3);

	template< typename T1, typename T2, typename T3, typename T4 >
	unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4);

	template< typename T1, typename T2, typename T3, typename T4, typename T5 >
	unsigned int waitfor_any( handle< T1 > & t1, handle< T2 > & t2, handle< T3 > & t3, handle< T4 > & t4, handle< T5 > & t5);

[variablelist
[[Effects:] [waits for any handle to become ready]]
[[Throws:] [`boost::task::task_interrupted`, `boost::task::task_rejected`, `std::bad_alloc`]]
]


[endsect]
