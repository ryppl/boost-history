[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:overview Overview]

__boost_task__ provides an framework for parallel execution of tasks (a task is a small unit of code that can be executed independently).

* __task__, __callable__ representing a fine-grained work-item:
	* __fn_operator__ to execute the fine-grained work-item
	* __fn_get_future__ providing an __act__ in order to pass the result (values, exceptions) back to initiator

* __handle__, __act__ of the asynchronously executed task:
	* __fn_interrupt__, __fn_interrupt_and_wait__, ... allow to cancel an cooperative task
	* interface of __act__:
		* __fn_get__ retrieve value or exception of task execution
		* __fn_is_ready__ test if task was executed
		* __fn_wait__, __fn_wait_for__ and __fn_wait_until__ block until task is executed and the result is set
	* __fn_get_future__ returns reference to internal future
	* functions __waitfor_all__/__waitfor_any__ to wait for all or any handles

* __fn_async__, executes a task on behalf of __eps__ asynchronously

* __ep__ models:
	* __own_thread__: executes task in current thread.
	* __new_thread__: executes task in a newly created thread (thread will be destroyed after)
	* __as_sub_task__: executes task in newly created thread or in a pool of __worker_threads__ depending on whether current task is already executed in a pool
	* __thread_pool__: task gets executed by a __worker_thread__ of a custom __thread_pool__ (for instance with priority or smart scheduling)

* __thread_pools__ with work-stealing algorithm and for/join semantics

* support of forking and joining sub-tasks
	* better performance
	* no deadlock because of inline-execution of sub-tasks
	* automatically detects if code runs in a __thread_pool__ so the appropriate mechanism for executing the sub-tasks is choosen


In order to use the classes and functions described here, you can either include the specific headers specified by the descriptions of each class or function,
or include the master library header:

``
    #include <boost/task.hpp>
``

which includes all the other headers in turn.

Used namespaces are:

``
    namespace boost::task
    namespace boost::this_task
``


[heading Example]

``
	long fibonacci( long n)
	{
		if ( n == 0) return 0;
		if ( n == 1) return 1;
		long k1( 1), k2( 0);
		for ( int i( 2); i <= n; ++i)
		{
			long tmp( k1);
			k1 = k1 + k2;
			k2 = tmp;
		}
		return k1;
	}

	void main()
	{
		boost::task< long > t1(
			boost::bind(
				fibonacci,
				10) );
		boost::task< long > t2(
			boost::bind(
				fibonacci,
				5) );

		boost::task::handle< long > h1(
			boost::task::async(
				boost::move( t1), tsk::new_thread() );
		boost::task::handle< long > h2(
			boost::task::async(
				boost::move( t2), tsk::new_thread() );

		std::cout << "h1: is ready == " << std::boolalpha << h1.is_ready() << "\n";
		std::cout << "h2: is ready == " << std::boolalpha << h2.is_ready() << "\n";
		boost::task::waitfor_all( h1, h2);
		std::cout << "h1: is ready == " << std::boolalpha << h1.is_ready() << "\n";
		std::cout << "h2: is ready == " << std::boolalpha << h2.is_ready() << "\n";
		std::cout << "h1: has value == " << std::boolalpha << h1.has_value() << "\n";
		std::cout << "h2: has value == " << std::boolalpha << h2.has_value() << "\n";
		std::cout << "h1: has exception == " << std::boolalpha << h1.has_exception() << "\n";
		std::cout << "h2: has exception == " << std::boolalpha << h2.has_exception() << "\n";
		std::cout << "fibonacci(10) == " << h1.get() << std::endl;
		std::cout << "fibonacci(5) == " << h2.get() << std::endl;
	}
``


[heading References]

* N2185: Proposed Text for Parallel Task Execution [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2185.html] written by Peter Dimov.

* N2276: Thread Pools and Futures [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2276.html] written by Anthony Williams.

* N2802: A plea to reconsider detach-on-destruction for thread objects [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html] written by Hans-J. Boehm.

* N2880: C++ object lifetime interactions with the threads API [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2880.html] written by Hans-J. Boehm and Lawrence Crowl.

* [@http://herbsutter.wordpress.com 'Sutterâ€™s Mill'] by Herb Sutter

* mailing list of C++ standard committee's Library Working Group

[note __boost_task__ uses __boost_future__ from Anthony Williams (will be integrated in some of the next releases of __boost_thread__).]


[heading Tested Platforms]

__boost_task__ has been tested on the following platforms and compilers:

*  Debian GNU/Linux 2.6.29.2 (x86_64), GCC 4.3.3
*  Ubuntu GNU/Linux 2.6.28.11 (x86), GCC 4.3.3
*  FreeBSD 7.2 (x86), GCC 4.2.1
*  OpenSolaris 2009.06 (x86_64), GCC 4.3.2
*  Windows XP Professional (x86), MSVC 9.0


[heading How to build and install]

* download the sources form [@http://www.boostpro.com/vault/index.php boost-vault] (section ['Concurrent Programing]) or the latest development version from 
[@https://svn.boost.org/svn/boost/sandbox/task/ boost-sandbox]
* extract the archive into the boost-source directory
* call `bjam toolset=<compiler-name> --with-task install` in order to install __boost_task__


[endsect]
