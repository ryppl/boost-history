[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]


[section:overview Overview]

__boost_task__ provides a framework for parallel execution of tasks (a task is a small unit of code that can be executed independently).

* __task__, a __callable__ representing a fine-grained work-item:
	* __fn_operator__ to execute the fine-grained work-item
	* __fn_get_future__ providing an __act__ in order to pass the result (values, exceptions) back to initiator

* __handle__, works as a __act__ of executed task:
	* __fn_interrupt__, __fn_interrupt_and_wait__, ... allow to cancel an cooperative task
	* interface of the __act__:
		* __fn_get__ retrieve value or exception of task execution
		* __fn_is_ready__ test if task was executed
		* __fn_wait__, __fn_wait_for__ and __fn_wait_until__ block until task is executed and the result is set
	* __fn_get_future__ returns reference to internal __shared_future__
	* functions __waitfor_all__/__waitfor_any__ to wait for all or any handles

* __fn_async__, executes a task by means of __eps__

* __ep__ models:
	* __own_thread__: executes task in current thread
	* __new_thread__: executes task in a newly-created thread (thread will be destroyed after completion)
	* __as_sub_task__: executes task in newly-created thread or in a pool of __worker_threads__ depending on whether the parent-task is already executed in a __thread_pool__
	* __thread_pool__: task gets executed by a __worker_thread__ of a custom __thread_pool__ (for instance with priority or smart scheduling)

* __thread_pools__ with work-stealing algorithm and for/join semantics

* support of forking and joining sub-tasks
	* better performance
	* no deadlock because of inline-execution of sub-tasks
	* detects if parent-task runs in a __thread_pool__ - the appropriate mechanism for executing the sub-tasks is choosen


In order to use the classes and functions described here, you can either include the specific headers specified by the descriptions of each class or function,
or include the master library header:

``
    #include <boost/task.hpp>
``

which includes all the other headers in turn.

Used namespaces are:

``
    namespace boost::task
    namespace boost::this_task
``


[heading Example]

``
	long fibonacci( long n)
	{
		if ( n == 0) return 0;
		if ( n == 1) return 1;
		long k1( 1), k2( 0);
		for ( int i( 2); i <= n; ++i)
		{
			long tmp( k1);
			k1 = k1 + k2;
			k2 = tmp;
		}
		return k1;
	}

	void main()
	{
		// create a thread-pool
		boost::task::static_pool<
			boost::task::unbounded_channel<
				boost::task::fifo
			>
		> pool( boost::task::poolsize( 5) );

		// create two tasks, computing fibonacci numbers
		boost::task< long > t1( fibonacci, 10);
		boost::task< long > t2( fibonacci, 5);

		// execute tasks in thread-pool
		// move tasks ownership to executor
		boost::task::handle< long > h1(
			boost::task::async(
				boost::move( t1),
				pool);
		boost::task::handle< long > h2(
			boost::task::async(
				boost::move( t2),
				pool);

		std::cout << "h1: is ready == " << std::boolalpha << h1.is_ready() << "\n";
		std::cout << "h2: is ready == " << std::boolalpha << h2.is_ready() << "\n";

		// wait for completion of both tasks
		boost::task::waitfor_all( h1, h2);

		std::cout << "h1: is ready == " << std::boolalpha << h1.is_ready() << "\n";
		std::cout << "h2: is ready == " << std::boolalpha << h2.is_ready() << "\n";
		std::cout << "h1: has value == " << std::boolalpha << h1.has_value() << "\n";
		std::cout << "h2: has value == " << std::boolalpha << h2.has_value() << "\n";
		std::cout << "h1: has exception == " << std::boolalpha << h1.has_exception() << "\n";
		std::cout << "h2: has exception == " << std::boolalpha << h2.has_exception() << "\n";

		// get results
		std::cout << "fibonacci(10) == " << h1.get() << std::endl;
		std::cout << "fibonacci(5) == " << h2.get() << std::endl;
	}
``


[heading References]

* N2185: Proposed Text for Parallel Task Execution [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2185.html] written by Peter Dimov.

* N2276: Thread Pools and Futures [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2276.html] written by Anthony Williams.

* N2802: A plea to reconsider detach-on-destruction for thread objects [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2802.html] written by Hans-J. Boehm.

* N2880: C++ object lifetime interactions with the threads API [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2880.html] written by Hans-J. Boehm and Lawrence Crowl.

* [@http://herbsutter.wordpress.com 'Sutterâ€™s Mill'] by Herb Sutter

* mailing list of C++ standard committee's Library Working Group

[note __boost_task__ uses __boost_future__ from Anthony Williams (will be integrated in some of the next releases of __boost_thread__).]

[warning This library is NOT an official Boost library]

[note Please note that __boost_task__ is not optimized yet.]


[heading Tested Platforms]

__boost_task__ has been tested on the following platforms and compilers:

*  Debian GNU/Linux 2.6.29.2 (x86_64), GCC 4.3.3
*  Ubuntu GNU/Linux 2.6.28.11 (x86), GCC 4.3.3
*  FreeBSD 7.2 (x86), GCC 4.2.1
*  OpenSolaris 2009.06 (x86_64), GCC 4.3.2
*  Windows XP Professional (x86), MSVC 9.0


[heading How to build and install]

* download the sources form [@http://www.boost-consulting.com/vault/index.php?directory=Concurrent%20Programming Boost Vault] or the latest
development version from [@https://svn.boost.org/svn/boost/sandbox/task/ boost-sandbox]
* extract the archive into the boost-source directory
* call [''bjam toolset=<compiler-name> --with-task install'] in order to build and install __boost_task__


[endsect]
