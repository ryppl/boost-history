[/
  (C) Copyright 2008-20009 Vicente J Botet Escriba.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[/==========================]
[section:reference Reference]
[/==========================]

[/==========================================================================================]
[section Header `<boost/interthreads/fork.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
        namespace result_of {
            template <typename AE, typename F, typename A1, ..., typename An>
            struct fork;
                typedef typename AE::handle<typename result_of<F(A1, ..., An)> >::type type;
            };
        }

        template< typename AE, typename F > 
        typename result_of::fork<AE,F>::type
        fork( AE& ae, F fn );

        template< typename AE, typename F, typename A1 > 
        typename result_of::fork<AE,F, mpl::vector<A1> >::type> >::type
        fork( AE& ae, F fn, A1 a1 );

        template< typename F > 
        typename result_of::fork<default_asynchronous_executor,F>::type
        fork( F fn );

        template< typename F, typename A1 > 
        typename result_of::forkT<default_asynchronous_executor,typename result_of<F(A1)>::type >::type
        fork( F fn, A1 a1 );

    }
    }



[section Metafunction `result_of::fork<AE,F> `] 
[/==========================================================================================]

A metafunction returning the result type of applying fork to an asynchronous executor and a Nullary functor.

        namespace result_of {
            template <typename AE, typename F, typename A1, ..., typename An>
            struct fork;
                typedef typename AE::handle<typename result_of<F(A1, ..., An)> >::type type;
            };
        }

[table fork Parameters
    [
        [[*Parameter]]
        [[*Requirement]]
        [[*Description]]
    ]
    [
        [`AE`]
        [A model of `AsynchrousExecutor`]
        [Operation's argument ]
    ]
    [
        [`F`]
        [A model of n-ary function]
        [Operation's argument ]
    ]
    [
        [`Ak`]
        [A model of n-ary function]
        [n-ary function argument type for argument k]
    ]
]

[variablelist
[[Expression:] [result_of::fork<AE,F,A1,...,An>::type]]
[[Return type:] [AE::handle<typename result_of<F(A1,...,An)> >::type]]
]

[endsect]

[section Non member function `fork()`] 
[/==========================================================================================]

        template< typename AE, typename F, typename A1 , ... typename An > 
        typename result_of::fork<AE,F, A1, An> >::type> >::type
        fork( AE& ae, F fn, A1 a1 , ..., An an );

[table fork Parameters
    [
        [[*Parameter]]
        [[*Requirement]]
        [[*Description]]
    ]
    [
        [`AE`]
        [A model of `AsynchrousExecutor`]
        [Operation's argument ]
    ]
    [
        [`F`]
        [A model of n-ary function]
        [Operation's argument ]
    ]
]

[variablelist
[[Requires:] [The expression fn(a1, ..., an) must be valid and 
have a type convertible to R, where R is typename result_of<Fn()>::type..]]
[[Efect:] [Request the `AE` to creates a thread of execution for the function `fn`
Request the asynchronous evaluation the expression `fn()` with respect to the calling thread to the 
asynchronous executor `ae` and 
places its result in an object h of type AE::handle<R>::type as if by using h.set_value( fn() ). 
If the expression fn() throws an exception e, places e into h as if by using 
h.set_exception( current_exception() ).]]
]
[[Returns:] [the AE handle h.]]

[endsect]
[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/act_traits.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        template <typename ACT>
        struct act_value;

        template <typename ACT>
        struct is_movable;

        template <typename ACT>
        struct has_future_if;

        template <typename ACT>
        struct has_thread_if;

        template <typename AE, typename T>
        struct asynchronous_completion_token;    

        template <typename AE>
        struct get_future;

}
}
[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/asynchronous_executor.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
    
        template <typename AE, template <class> class Decorator>
        struct asynchronous_executor_decorator : AE {
            template <typename T>
            struct handle {
                typedef typename AE::template handle<T>::type type;
            };
        
            template <typename F>
            typename AE::template handle< typename boost::result_of<F()>::type >::type 
            fork( F fn );

            asynchronous_executor_decorator();

            template <typename Nullary> 
            asynchronous_executor_decorator(thread::native_handle_attr_type& attr, Nullary f);

            asynchronous_executor_decorator(Nullary f);

            asynchronous_executor_decorator(boost::detail::thread_move_t<asynchronous_executor_decorator> x);
            
            asynchronous_executor_decorator& operator=(boost::detail::thread_move_t<asynchronous_executor_decorator> x);

            operator boost::detail::thread_move_t<asynchronous_executor_decorator>();

            boost::detail::thread_move_t<asynchronous_executor_decorator> move();
        };

        template <typename AE, template <class> class Decorator>
        struct get_future<asynchronous_executor_decorator<AE, Decorator> > {
            template <typename T>
            struct future_type {
                typedef typename AE::template get_future<AE>::type type;
            };
            template <typename T>
            typename future_type<T>::type& operator()(typename AE::template handle<T>::type & j);
        };
    }
    }

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/asynchronous_adapter.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
    
        template <typename AE, template <class> class Decorator>
        struct asynchronous_executor_decorator : AE {
            template <typename T>
            struct handle {
                typedef typename AE::template handle<T>::type type;
            };
        
            template <typename F>
            typename AE::template handle< typename boost::result_of<F()>::type >::type 
            fork( F fn );

            asynchronous_executor_decorator();

            template <typename Nullary> 
            asynchronous_executor_decorator(thread::native_handle_attr_type& attr, Nullary f);
            asynchronous_executor_decorator(Nullary f);

            asynchronous_executor_decorator(boost::detail::thread_move_t<asynchronous_executor_decorator> x);
            
            asynchronous_executor_decorator& operator=(boost::detail::thread_move_t<asynchronous_executor_decorator> x);

            operator boost::detail::thread_move_t<asynchronous_executor_decorator>();

            boost::detail::thread_move_t<asynchronous_executor_decorator> move();            
        };

        template <typename AE, template <class> class Decorator>
        struct get_future<asynchronous_executor_decorator<AE, Decorator> > {
            template <typename T>
            struct future_type {
                typedef typename AE::template get_future<AE>::type type;
            };
            template <typename T>
            typename future_type<T>::type& operator()(typename AE::template handle<T>::type & j);
        };
    }
    }


[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/basic_threader.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        class basic_threader {
        public:
            thread::native_handle_attr_type& attr();

            template <typename T>
            struct handle {
                typedef thread type;
            };

            template <typename F> thread fork(F f);
        };

        template <>
        struct act_value<thread> {
            typedef void type;
        };
    }
    }

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/basic_threader_decorator.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {   

        typedef asynchronous_executor_decorator<basic_threader,thread_decorator> basic_threader_decorator;
        
    }
    }
    
[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/fork_after.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        template <typename ACT>
        struct act_wrapper {
            act_wrapper();
            void wait_initialized();
            void set(ACT& other);
            void set(boost::detail::thread_move_t<ACT> other);
            void wait();
            typename act_value<ACT>::type get();
            void join();
        };

        template <typename ACT>
        struct act_value<act_wrapper<ACT> > {
            typedef typename act_value<ACT>::type type;
        };

        template <typename ACT>
        struct is_movable<act_wrapper<ACT> > : is_movable<ACT>{};

        template <typename ACT>
        struct has_future_if<act_wrapper<ACT> > : has_future_if<ACT> {};

        template <typename ACT>
        struct has_thread_if<act_wrapper<ACT> > : has_thread_if<ACT>{};


        namespace result_of { 
            template <typename AE,typename F>
            struct fork_after {
                typedef typename boost::result_of<F()>::type result_type;
                typedef typename asynchronous_completion_token<AE, result_type>::type act_type;
                typedef act_wrapper<act_type> type;
            };
        }

        namespace partial_specialization_workaround {
            template< typename AE, typename F, typename D > 
            struct fork_after {
                static typename result_of::fork_after<AE,F>::type
                apply(AE& ae, F fn, D& d);
            };
        }
        template< typename AE, typename F, typename D> 
        typename result_of::fork_after<AE,F>::type 
        fork_after( AE& ae, F fn, D& d);


    }
    }

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/scheduler.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
   
        template <typename C>
        class scheduler {
            explicit scheduler(
                tp::poolsize const& psize
            );
            template <typename T>
            struct handle {
                typedef tp::task<T> type;
            };
            template <typename F>
            tp::task<typename boost::result_of<F()>::type> 
            fork(F f);
        };

        template <typename Channel>
        struct get_future<scheduler<Channel> > {
            template <typename T>
            struct future_type {
                typedef shared_future<T> type;
            };
            template <typename T>
            shared_future<T>& operator()(tp::task<T>& act);
        };

        template <typename Channel, typename T>
        struct asynchronous_completion_token<boost::tp::pool<Channel>,T> {
            typedef boost::tp::task<T> type;
        };    

        namespace partial_specialization_workaround {
            template< typename Channel, typename F > 
            struct fork<boost::tp::pool<Channel>,F> {
                static typename result_of::fork<boost::tp::pool<Channel>, F>::type  
                apply( boost::tp::pool<Channel>& ae, F fn );
            };
        }
        template <typename C>
        struct get_future<tp::pool<C> > {
            template <typename T>
            shared_future<T>& operator()(tp::task<T>& act);
        };

        template <typename ResultType>
        struct act_value<tp::task<ResultType> > {
            typedef ResultType type;
        };

        template <typename R>
        struct is_movable<tp::task<R> > : mpl::false_{};

        template <typename R>
        struct has_future_if<tp::task<R> > : mpl::true_{};

        template <typename R>
        struct has_thread_if<tp::task<R> > : mpl::false_{};

    }
    }


[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/fork_all.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
        namespace result_of {
            template <typename AE, typename T>
            struct fork_all;
            template <typename AE, typename F1, ..., typename Fn>
            struct fork_all <AE,fusion::tuple<F1, ..., Fn> >{
                typedef  fusion::tuple<
                    typename result_of::fork<AE,F1>::type,
                    ...
                    typename result_of::fork<AE,Fn>::type
                > type;
            };
        }

        template< typename AE, typename F1, ...,  typename Fn> 
        typename result_of::fork_all<AE, mpl::tuple<F1, ..., Fn> >::type
        fork_all( AE& ae, F1 f1, ..., Fn fn );

        template< typename F1, ...,  typename Fn> 
        typename result_of::fork_all<default_asynchronous_executor, F1, ..., Fn>::type
        fork_all( F1 f1, ..., Fn fn );

    }
    }

[section Metafunction `result_of::fork_all<AE,F1, ..., Fn> `] 
[/==========================================================================================]

A metafunction returning the result type of applying fork_all to an asynchronous executor and n Nullary functors.

        namespace result_of {
            template <typename AE, typename T>
            struct fork_all;
            template <typename AE, typename F1, ..., typename Fn>
            struct fork_all <AE,fusion::tuple<F1, ..., Fn> >{
                typedef  fusion::tuple<
                    typename result_of::fork<AE,F1>::type,
                    ...
                    typename result_of::fork<AE,Fn>::type
                > type;
            };
        }

[table fork_all Parameters
    [
        [[*Parameter]]
        [[*Requirement]]
        [[*Description]]
    ]
    [
        [`AE`]
        [A model of `AsynchrousExecutor`]
        [Operation's argument ]
    ]
    [
        [`Fk`]
        [A model of nullary function]
        [Operation's argument ]
    ]
]

[variablelist
[[Expression:] [`result_of::fork_all<AE,F1,...,Fn>::type`]]
[[Return type:] [a fusion tuple of the result of forking each `Fk` by the `AE`]]
]

[endsect]

[section Non member function `fork_all()`] 
[/==========================================================================================]

        template< typename AE, typename F1, ...,  typename Fn> 
        typename result_of::fork_all<AE, mpl::tuple<F1, ..., Fn> >::type
        fork_all( AE& ae, F1 f1, ..., Fn fn );

        template< typename F1, ...,  typename Fn> 
        typename result_of::fork_all<default_asynchronous_executor, F1, ..., Fn>::type
        fork_all( F1 f1, ..., Fn fn );

[table fork Parameters
    [
        [[*Parameter]]
        [[*Requirement]]
        [[*Description]]
    ]
    [
        [`AE`]
        [A model of `AsynchrousExecutor`]
        [Operation's argument ]
    ]
    [
        [`Fk`]
        [A model of nullary function]
        [Operation's argument ]
    ]
]

[variablelist
[[Returns:] [a fusion tuple of the result of forking each `fk` by the `ae`]]
[[Efect:] [Request the `AE` to creates a n thread of execution one for the function `fk`.]]
]

[endsect]


[endsect]


[/==========================================================================================]
[section Header `<boost/interthreads/algorithm.hpp>`]
[/==========================================================================================]

    #include <boost/interthreads/algorithm/join_all.hpp>
    #include <boost/interthreads/algorithm/join_all_until.hpp>
    #include <boost/interthreads/algorithm/wait_all.hpp>
    #include <boost/interthreads/algorithm/wait_all_until.hpp>
    #include <boost/interthreads/algorithm/get_all.hpp>
    #include <boost/interthreads/algorithm/get_all_until.hpp>
    #include <boost/interthreads/algorithm/detach_all.hpp>
    #include <boost/interthreads/algorithm/interrupt_all.hpp>
    #include <boost/interthreads/algorithm/interruption_requested_on_all.hpp>

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/algorithm/get_all.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
        namespace fct {
            struct get {
                template<typename T>
                typename T::result_type operator()(T& t);
            };
        }
        namespace result_of {
            template <typename Sequence>
            struct get_all {
                typedef typename result_of::transform<Sequence, fct::get>::type type;
            };
        }
        namespace algo {
            template <typename Sequence>
            typename result_of::get_all<Sequence>::type
            get_all(Sequence& mt);
        }
    }
    }

[section Functor `fct::get<>`] 
[/==========================================================================================]

        namespace fct {
            struct get {
               template<typename AE>
               typename AE::result_type operator()(AE& ae);
            };
        }


[variablelist
[[Returns:] [The result of the AE::get().]]
[[Throws:] [if AE::get() throws.]]
]

[endsect]

[section Metafunction `result_of::get_all<AE,F1, ..., Fn> `] 
[/==========================================================================================]

A metafunction returning the result type of applying get_all to a Sequence of asynchronous executor.

        namespace result_of {
            template <typename Sequence>
            struct get_all {
                typedef typename result_of::transform<Sequence, fct::get>::type type;
            };
        }

[table fork_all Parameters
    [
        [[*Parameter]]
        [[*Requirement]]
        [[*Description]]
    ]
    [
        [`Sequence`]
        [A sequence of of `AsynchrousExecutor`s]
        [Operation's argument ]
    ]
]

[variablelist
[[Expression:] [`result_of::get_all<S>::type`]]
[[Return type:] [a fusion tuple of the result of applying get to each one of the asynchronous executors in the sequence]]
]

[endsect]

[section Non member function `get_all`] 
[/==========================================================================================]

        namespace algo {
            template <typename Sequence>
            typename result_of::get_all<Sequence>::type
            get_all(Sequence& mt);
        }


[variablelist
[[Returns:] [a fusion tuple of the result of applying `get` to each one of the asynchronous completion token handles in the sequence.]]
[[Effect:] [Blocks until all the ACT  handles in the Sequence are ready.]]
[[Throws:] [if some of the  ACT::get operation throws]]
]

[endsect]

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/algorithm/detach_all.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        namespace fct {
            struct detach {
                typedef void result_type;
                template<typename ACT>
                void operator()(ACT& act) const;
            };
        }

        namespace result_of {
            template <typename Sequence>
            struct detach_all {
                typedef typename fusion::result_of::for_each<Sequence, fct::detach>::type type;
            };
        }
        
        template <typename Sequence>
        void detach_all(Sequence& t);
        

    }    
    }   // namespace boost
    
[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/algorithm/join_all.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        namespace fct {
            struct join {
                typedef void result_type;
                template<typename ACT>
                void operator()(ACT& act) const;
            };
        }

        namespace result_of {
            template <typename Sequence>
            struct join_all {
                typedef typename fusion::result_of::for_each<Sequence, fct::join>::type type;
            };
        }

        template <typename Sequence>
        typename result_of::join_all<Sequence>::type
        join_all(Sequence& t);

    }    
    }

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/algorithm/join_all_until.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        namespace fct {
            struct join_until {
                join_until(const system_time& abs_time);
                template<typename ACT>
                bool operator()(ACT& act) const;
            };
            
            struct join_for {
                template <typename Duration>
                join_for(const Duration& rel_time);
                template<typename ACT>
                bool operator()(ACT& act) const;
        }

        namespace result_of {
            template <typename Sequence>
            struct join_all_until {
                typedef bool type;
            };

            template <typename Sequence>
            struct join_all_for {
                typedef bool type;
            };
        }

        template <typename Sequence>
        typename result_of::join_all_until<Sequence> 
        join_all_until(Sequence& t, const system_time& abs_time);

        template <typename Sequence, typename Duration>
        typename result_of::join_all_for<Sequence> 
        join_all_for(Sequence& t, const Duration& rel_time);

    }    
    }   // namespace boost

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/algorithm/interrupt_all.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
      
        namespace fct {
            struct interrupt {
                template<typename ACT>
                void operator()(ACT& act) const;
            };
        }
        
        namespace result_of {
            template <typename Sequence>
            struct interrupt_all {
                typedef typename fusion::result_of::for_each<Sequence, fct::interrupt>::type type;
            };
        }

        template <typename Sequence>
        void interrupt_all(Sequence& t);

    }    
    }


[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/algorithm/interruption_requested_all.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
      
        namespace fct {
            struct interruption_requested {
                typedef bool result_type;

                template<typename ACT>
                bool operator()(ACT& act) const;
            };
        }

        namespace result_of {
            template <typename Sequence>
            struct interruption_requested_on_all {
                typedef typename fusion::result_of::all<Sequence, fct::interruption_requested>::type type;
            };
        }

        template <typename Sequence>
        bool interruption_requested_on_all(Sequence& t);

    }    
    }

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/algorithm/wait_all.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        namespace fct {
            struct wait {
                typedef void result_type;
                template<typename ACT>
                void operator()(ACT& act) const;
            };
        }

        namespace result_of {
            template <typename Sequence>
            struct wait_all {
                typedef typename fusion::result_of::for_each<Sequence, fct::wait>::type type;
            };
        }

        template <typename Sequence>
        typename result_of::wait_all<Sequence>::type
        wait_all(Sequence& t);

    }    
    }   // namespace boost


[endsect]
[/==========================================================================================]
[section Header `<boost/interthreads/algorithm/wait_all_until.hpp>`]
[/==========================================================================================]

namespace boost {
namespace interthreads {

    namespace fct {
        struct wait_until {
            wait_until(const system_time& abs_time);
            template<typename ACT>
            bool operator()(ACT& act) const;

        struct wait_for {
            template <typename Duration>
            wait_for(const Duration& rel_time);
            template<typename ACT>
            bool operator()(ACT& act) const;
    }

    namespace result_of {
        template <typename Sequence>
        struct wait_all_until {
            typedef bool type;
        };

        template <typename Sequence>
        struct wait_all_for {
            typedef bool type;
        };
    }
    
    template <typename Sequence>
    typename result_of::wait_all_until<Sequence const> 
    wait_all_until(Sequence const& t, const system_time& abs_time);

    template <typename Sequence, typename Duration>
    typename result_of::wait_all_for<Sequence> 
    wait_all_for(Sequence& t, const Duration& rel_time);

}    
}   // namespace boost

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/wait_for_all.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
        namespace result_of {
            template <typename AE, typename F1, ..., typename Fn>
            struct wait_for_all {
                typedef  fusion::tuple<
                    typename result_of<F1()>::type,
                    ...
                    typename result_of<Fn()>::type,
                > type;
            };
        }

        template< typename AE, typename F1, ...,  typename Fn> 
        typename result_of::wait_for_all<AE, F1, ..., Fn>::type
        wait_for_all( AE& ae, F1 f1, ..., Fn fn );
    }
    }

[section Metafunction `result_of::wait_for_all<AE,F1, ..., Fn> `] 
[/==========================================================================================]

A metafunction returning the result type of applying get_all to a Sequence of asynchronous executor handles.

        namespace result_of {
            template <typename AE, typename F1, ..., typename Fn>
            struct wait_for_all {
                typedef  fusion::tuple<
                    typename result_of<F1()>::type,
                    ...
                    typename result_of<Fn()>::type,
                > type;
            };
        }

[table wait_for_all Parameters
    [
        [[*Parameter]]
        [[*Requirement]]
        [[*Description]]
    ]
    [
        [`AE`]
        [A model of `AsynchrousExecutor`]
        [Operation's argument ]
    ]
    [
        [`Fk`]
        [A model of nullary function]
        [Operation's argument ]
    ]
]

[variablelist
[[Expression:] [`result_of::wait_for_all<AE, F1, ..., Fn>::type`]]
[[Return type:] [a fusion tuple of the result of applying get to each one of the asynchronous executors handles resulting of forking each function `Fk` by `AE`]]
]

[endsect]

[section Non member function `wait_for_all`] 
[/==========================================================================================]

        template< typename AE, typename F1, ...,  typename Fn> 
        typename result_of::wait_for_all<AE, F1, ..., Fn>::type
        wait_for_all( AE& ae, F1 f1, ..., Fn fn );


[variablelist
[[Returns:] [a fusion tuple of the result of applying get to each one of the asynchronous executors handles resulting of forking each function `fk` by `ae`.]]
[[Effect:] [Request the `AE` to creates a n thread of execution one for the function `fk` and 
blocks until all the AE handles are ready.]]

]

[endsect]
[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/wait_for_any.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
        namespace result_of {
            template <typename AE, typename F1, ..., typename Fn>
            struct wait_for_any {
                // requires typename result_of<F1()>::type == typename result_of<Fk()>::type
                typedef  std::pair<unsigned,typename result_of<F1()>::type> type;
            };
        }

        template< typename AE, typename F1, ...,  typename Fn> 
        typename result_of::wait_for_any<AE, F1, ..., Fn>::type
        wait_for_any( AE& ae, F1 f1, ..., Fn fn );
    }
    }

[section Metafunction `result_of::wait_for_all<AE,F1, ..., Fn> `] 
[/==========================================================================================]

A metafunction returning the a pair: the index of the first function executed by the AE and the result type 
of applying get on an asynchronous executor handles.

        namespace result_of {
            template <typename AE, typename F1, ..., typename Fn>
            struct wait_for_any {
                // requires typename result_of<F1()>::type == typename result_of<Fk()>::type
                typedef  std::pair<unsigned,typename result_of<F1()>::type> type;
            };
        }

[table wait_for_all Parameters
    [
        [[*Parameter]]
        [[*Requirement]]
        [[*Description]]
    ]
    [
        [`AE`]
        [A model of `AsynchrousExecutor`]
        [Operation's argument ]
    ]
    [
        [`Fk`]
        [A model of nullary function]
        [Operation's argument ]
    ]
]

[variablelist
[[Expression:] [`result_of::wait_for_any<AE, F1, ..., Fn>::type`]]
[[Return type:] [a pair: the index of the first function executed by the AE and the result type 
of applying get on an asynchronous executor handles created by `ae` to fork each `fk`]]
]

[endsect]

[section Non member function `wait_for_any`] 
[/==========================================================================================]

        template< typename AE, typename F1, ...,  typename Fn> 
        typename result_of::wait_for_any<AE, F1, ..., Fn>::type
        wait_for_any( AE& ae, F1 f1, ..., Fn fn );


[variablelist
[[Returns:] [a fusion tuple of the result of applying get to each one of the asynchronous executors handles resulting of forking each function `fk` by `ae`.]]
[[Effect:] [Request the `AE` to creates a n thread of execution one for the function `fk` and 
blocks until all the AE handles are ready.]]

]

[endsect]

[endsect]


[/==========================================================================================]
[section Header `<boost/interthreads/launcher.hpp>`]
[/==========================================================================================]

    #include <boost/interthreads/fork.hpp>
    namespace boost {
    namespace interthreads {
        class launcher;
        class shared_launcher;
    }
    }

[section Class `launcher `] 
[/==========================================================================================]

Thread launcher using a common configuration managed with the thread attributes and 
returning on the fork operation a unique_future to the resulting type of the call to the threaded function.

    class launcher {
    public: 
        thread::native_handle_attr_type& attr();
        
        template <typename T>
        struct handle {
            typedef unique_future<T> > type;
        };

        template <typename F>
        unique_future<typename result_of<F()>::type> 
        fork(F f);
    };

[section Member function `launcher::attributes`] 
[/==========================================================================================]

Reference to the thread attributes accesor.

        thread::native_handle_attr_type& attributes();

[variablelist
[[Returns:] [A reference to the thread attributes.]]
[[Complexity:] [constant.]]
]


[endsect]
[section Metafunction `launcher::handle<>`] 
[/==========================================================================================]

Metafunction that returns the result type of the fork function applied to a launcher and the value type.

    template <typename T>
    struct handle {
        typedef unique_future<T> > type;
    };

[variablelist
[[Expression:] [L::handle<T>::type]]
[[Return type:] [A unique_future<T>.]]
[[Complexity:] [constant.]]

]

[endsect]

[section Member function `lancher::fork`] 
[/==========================================================================================]

        template <typename F>
        unique_future<typename result_of<F()>::type> 
        fork(F f);

[variablelist
[[Returns:] [A unique_future to the result of calling a function F.]]
[[Effects:] [create a thread executing the function f. 
		 The result of the function will be stored on the resulting future.]]

]


[endsect]


[endsect]

[section Class `shared_launcher `] 
[/==========================================================================================]

Thread shared_launcher using a common configuration managed with the thread attributes and 
returning on the fork operation a unique_future to the resulting type of the call to the threaded function.

    class shared_launcher {
    public: 
        thread::native_handle_attr_type& attr();
        
        template <typename T>
        struct handle {
            typedef unique_future<T> > type;
        };

        template <typename F>
        unique_future<typename result_of<F()>::type> 
        fork(F f);
    };

[section Member function `shared_launcher::attributes`] 
[/==========================================================================================]

Reference to the thread attributes accesor.

        thread::native_handle_attr_type& attributes();

[variablelist
[[Returns:] [A reference to the thread attributes.]]
[[Complexity:] [constant.]]
]


[endsect]
[section Metafunction `shared_launcher::handle<>`] 
[/==========================================================================================]

Metafunction that returns the result type of the fork function applied to a shared_launcher and the value type.

    template <typename T>
    struct handle {
        typedef unique_future<T> > type;
    };

[variablelist
[[Expression:] [L::handle<T>::type]]
[[Return type:] [A unique_future<T>.]]
[[Complexity:] [constant.]]

]

[endsect]

[section Member function `lancher::fork`] 
[/==========================================================================================]

        template <typename F>
        unique_future<typename result_of<F()>::type> 
        fork(F f);

[variablelist
[[Returns:] [A unique_future to the result of calling a function F.]]
[[Effects:] [create a thread executing the function f. 
		 The result of the function will be stored on the resulting future.]]

]


[endsect]


[endsect]


[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/threader.hpp>`]
[/==========================================================================================]

    #include <boost/interthreads/fork.hpp>
    namespace boost {
    namespace interthreads {
        template <typename ResultType>
        class unique_joiner;

        template <typename ResultType>
        void swap(unique_joiner<ResultType>& lhs, unique_joiner<ResultType>& rhs);

        class unique_threader;
        
        template <typename ResultType>
        class shared_joiner;

        template <typename ResultType>
        void swap(shared_joiner<ResultType>& lhs, shared_joiner<ResultType>& rhs);

        class shared_threader;
    }
    }

[/==================================================]
[section Template Class `unique_joiner<>`] 
[/==========================================================================================]


template <typename ResultType>
class unique_joiner {
    typedef unique_joiner this_type;
public:
    unique_joiner(const unique_joiner& rhs) = delete;
    unique_joiner& operator=(const unique_joiner& rhs) = delete;

    typedef ResultType result_type;

    template <typename Nullary> 
    unique_joiner(thread::native_handle_attr_type& attr, Nullary f);
    template <typename Nullary> 
    unique_joiner(Nullary f);

    unique_joiner(boost::detail::thread_move_t<unique_joiner> x);
    unique_joiner& operator=(boost::detail::thread_move_t<unique_joiner> x);
    operator boost::detail::thread_move_t<unique_joiner>();
    boost::detail::thread_move_t<unique_joiner> move();
       
    void swap(this_type& x);
        
    bool joinable() const;
    void join();
    bool join_until(const system_time& abs_time);
    template<typename TimeDuration>
    inline bool join_for(TimeDuration const& rel_time);

    result_type get();
    result_type operator()();

    bool is_ready() const;
    bool has_exception() const;
    bool has_value() const;

    void wait() const;
    bool wait_until(const system_time& abs_time) const;
    template<typename TimeDuration>
    inline bool wait_for(TimeDuration const& rel_time) const;

    thread::id get_id() const;
    void detach();
    void interrupt();
    bool interruption_requested() const;
    
    typedef platform-specific-type native_handle_type;
    native_handle_type native_handle();
    
    unique_future<result_type> get_future();   

};


[section:destructor unique_joiner Destructor]
[/==========================================================================================]

    ~unique_joiner();

[variablelist
[[Effects:] [If `*this` has an associated thread of execution, calls __detach__. Destroys `*this`.]]
[[Throws:] [Nothing.]]
]

[endsect]

[section:swap Member function `swap()`]

    void swap(unique_joiner& other);

[variablelist
[[Effects:] [Exchanges the threads of execution associated with `*this` and `other`, so `*this` is associated with the thread of
execution associated with `other` prior to the call, and vice-versa.]]
[[Postconditions:] [`this->get_id()` returns the same value as `other.get_id()` prior to the call. `other.get_id()` returns the same
value as `this->get_id()` prior to the call.]]
[[Throws:] [Nothing.]]

]

[endsect]


[section Member Function `get()|operator()()`]
[/==========================================================================================]

    result_type get();
    result_type operator()();

[variablelist
[[Effects:] [Retrieves the value returned by the Nullary function.]]
[[Sychronization:][The completion of the call to the operator()() the Nullary function happens before get() returns.]]
[[Returns:] [If the result type R is a reference, returns the stored reference. 
If R is void, there is no return value. 
Otherwise, returns an rvalue-reference to the value stored in the asynchronous result.]]
[[Throws:] [the stored exception, if an exception was stored and not retrieved before.]]
[[Postconditions:] [It is unspecified what happens when get() is called a second time on the same unique_joiner.]]
[[Thread safety:][unsafe]]
]
[endsect]


[section Member Function `is_ready()`]
[/==========================================================================================]

    bool is_ready() const;

[variablelist
[[Returns:] [true only if the associated state holds a value or an exception ready for retrieval.]]
[[Remark:] [the return value is unspecified after a call to get().]]
]
[endsect]

[section Member Function `has_exception()`]
[/==========================================================================================]

    bool has_exception() const;

[variablelist
[[Returns:] [true only if is_ready() == true and the associated state contains an exception.]]
]
[endsect]

[section Member Function `has_value()`]
[/==========================================================================================]

    bool has_value() const;

[variablelist
[[Returns:] [true only if is_ready() == true and the associated state contains a value.]]
]
[endsect]

[section Member Function `wait()`]
[/==========================================================================================]

    void wait();

[variablelist
[[Effects:] [Blocks until the Nullariry function ends.]]
[[Sychronization:][The completion of the call to the operator()() the Nullary function happens before wait() returns.]]
[[Throws:] [the stored exception, if an exception was stored and not retrieved before.]]
[[Postconditions:] [is_ready() == true.]]
[[Thread safety:][unsafe]]
]
[endsect]

[section Member Function `wait_until()|wait_for()`]
[/==========================================================================================]

    bool wait_until(const system_time& abs_time);
    template<typename TimeDuration>
    bool wait_for(TimeDuration const& rel_time);


[variablelist
[[Effects:] [Blocks until the Nullariry function ends.]]
[[Sychronization:][The completion of the call to the operator()() the Nullary function happens before wait() returns.]]
[[Returns:] [If the result type R is a reference, returns the stored reference. 
If R is void, there is no return value. 
Otherwise, returns an rvalue-reference to the value stored in the asynchronous result.]]
[[Throws:] [the stored exception, if an exception was stored and not retrieved before.]]
[[Postconditions:] [is_ready() == true.]]
[[Thread safety:][unsafe]]
]
[endsect]



[section:joinable Member function `joinable()`]
[/==========================================================================================]

    bool joinable() const;

[variablelist
[[Returns:] [`true` if `*this` refers to a thread of execution, `false` otherwise.]]
[[Throws:] [Nothing]]
]

[endsect]

[section:join Member function `join()`]
[/==========================================================================================]

    void join();

[variablelist
[[Preconditions:] [`this->get_id()!=boost::this_thread::get_id()`]]
[[Effects:] [If `*this` refers to a thread of execution, waits for that thread of execution to complete.]]
[[Postconditions:] [If `*this` refers to a thread of execution on entry, that thread of execution has completed. `*this` no longer refers to any thread of execution.]]
[[Throws:] [__thread_interrupted__ if the current thread of execution is interrupted.]]
[[Notes:] [`join()` is one of the predefined __interruption_points__.]]
]

[endsect]

[section Member function `join_until()|join_for()`]
[/==========================================================================================]

    bool join_until(const system_time& wait_until);

    template<typename TimeDuration>
    bool join_for(TimeDuration const& rel_time);

[variablelist
[[Preconditions:] [`this->get_id()!=boost::this_thread::get_id()`]]
[[Effects:] [If `*this` refers to a thread of execution, waits for that thread of execution to complete, the time `wait_until` has
been reach or the specified duration `rel_time` has elapsed. If `*this` doesn't refer to a thread of execution, returns immediately.]]
[[Returns:] [`true` if `*this` refers to a thread of execution on entry, and that thread of execution has completed before the call
times out, `false` otherwise.]]
[[Postconditions:] [If `*this` refers to a thread of execution on entry, and `timed_join` returns `true`, that thread of execution
has completed, and `*this` no longer refers to any thread of execution. If this call to `timed_join` returns `false`, `*this` is
unchanged.]]
[[Throws:] [__thread_interrupted__ if the current thread of execution is interrupted.]]
[[Notes:] [`timed_join()` is one of the predefined __interruption_points__.]]
]

[endsect]

[section:detach Member function `detach()`]
[/==========================================================================================]

    void detach();

[variablelist
[[Effects:] [If `*this` refers to a thread of execution, that thread of execution becomes detached, and no longer has an associated __thread__ object.]]
[[Postconditions:] [`*this` no longer refers to any thread of execution.]]
[[Throws:] [Nothing]]
]

[endsect]


[section:get_id Member function `get_id()`]
[/==========================================================================================]

    thread::id get_id() const;

[variablelist
[[Returns:] [If `*this` refers to a thread of execution, an instance of __thread_id__ that represents that thread. Otherwise returns
a default-constructed __thread_id__.]]
[[Throws:] [Nothing]]
]

[endsect]

[section:interrupt Member function `interrupt()`]
[/==========================================================================================]

    void interrupt();

[variablelist
[[Effects:] [If `*this` refers to a thread of execution, request that the thread will be interrupted the next time it enters one of
the predefined __interruption_points__ with interruption enabled, or if it is currently __blocked__ in a call to one of the
predefined __interruption_points__ with interruption enabled .]]
[[Throws:] [Nothing]]
]
        

[endsect]


[section:nativehandle Member function `native_handle()`]
[/==========================================================================================]

    typedef platform-specific-type native_handle_type;
    native_handle_type native_handle();

[variablelist
[[Effects:] [Returns an instance of `native_handle_type` that can be used with platform-specific APIs to manipulate the underlying
implementation. If no such instance exists, `native_handle()` and `native_handle_type` are not present.]]
[[Throws:] [Nothing.]]
]

[endsect]



[endsect]
[section:non_member_swap Non-member function `swap()`]

    void swap(unique_joiner& lhs,unique_joiner& rhs);

[variablelist

[[Effects:] [[link thread.thread_management.thread.swap `lhs.swap(rhs)`].]]

]

[endsect]

[/==================================================]
[section Template Class `unique_threader`] 
[/==========================================================================================]

    class unique_threader {
    public: 
        thread::native_handle_attr_type& attributes();

        template <typename T>
        struct handle {
            typedef unique_joiner<T> type;
        };

        template <typename F>
        unique_joiner<typename result_of<F()>::type> 
        fork(F f);

    };

[section Member function `unique_threader::attributes()`] 
[/==========================================================================================]

Reference to the thread attributes accesor.

        thread::native_handle_attr_type& attributes();

[variablelist
[[Returns:] [A reference to the thread attributes.]]
[[Complexity:] [constant.]]
]


[endsect]
[section Metafunction `unique_threader::handle<>`] 
[/==========================================================================================]

Metafunction that returns the result type of the fork function applied to a unique_threader and the value type.

        template <typename T>
        struct handle {
            typedef unique_joiner<T> type;
        };


[variablelist
[[Expression:] [L::handle<T>::type]]
[[Return type:] [A unique_joiner<T>.]]
[[Complexity:] [constant.]]

]

[endsect]

[section Member function `unique_threader::fork`] 
[/==========================================================================================]

        template <typename F>
        unique_joiner<typename result_of<F()>::type> 
        fork(F f);

[variablelist
[[Returns:] [A unique_joiner to the result of calling a function F.]]
[[Effects:] [create a thread executing the function f. 
		 The result of the function will be stored on the resulting unique_joiner.]]

]


[endsect]

[endsect]

[/==================================================]
[section Template Class `shared_joiner<>`] 
[/==========================================================================================]


template <typename ResultType>
class shared_joiner {
    typedef shared_joiner this_type;
public:
    shared_joiner(const shared_joiner& rhs);
    shared_joiner& operator=(const shared_joiner& rhs);

    typedef ResultType result_type;

    template <typename Nullary> 
    shared_joiner(thread::native_handle_attr_type& attr, Nullary f);
    template <typename Nullary> 
    shared_joiner(Nullary f);

    shared_joiner(boost::detail::thread_move_t<shared_joiner> x);
    shared_joiner& operator=(boost::detail::thread_move_t<shared_joiner> x);
    operator boost::detail::thread_move_t<shared_joiner>();
    boost::detail::thread_move_t<shared_joiner> move();
       
    void swap(this_type& x);
        
    bool joinable() const;
    void join();
    bool join_until(const system_time& abs_time);
    template<typename TimeDuration>
    inline bool join_for(TimeDuration const& rel_time);

    result_type get();
    result_type operator()();

    bool is_ready() const;
    bool has_exception() const;
    bool has_value() const;

    void wait() const;
    bool wait_until(const system_time& abs_time) const;
    template<typename TimeDuration>
    inline bool wait_for(TimeDuration const& rel_time) const;

    thread::id get_id() const;
    void detach();
    void interrupt();
    bool interruption_requested() const;
    
    typedef platform-specific-type native_handle_type;
    native_handle_type native_handle();

    shared_future<result_type> get_future();
};


[section:destructor shared_joiner Destructor]
[/==========================================================================================]

    ~shared_joiner();

[variablelist
[[Effects:] [If `*this` has an associated thread of execution, calls __detach__. Destroys `*this`.]]
[[Throws:] [Nothing.]]
]

[endsect]

[section:swap2 Member function `swap()`]

    void swap(shared_joiner& other);

[variablelist
[[Effects:] [Exchanges the threads of execution associated with `*this` and `other`, so `*this` is associated with the thread of
execution associated with `other` prior to the call, and vice-versa.]]
[[Postconditions:] [`this->get_id()` returns the same value as `other.get_id()` prior to the call. `other.get_id()` returns the same
value as `this->get_id()` prior to the call.]]
[[Throws:] [Nothing.]]

]

[endsect]


[section Member Function `get()|operator()()`]
[/==========================================================================================]

    result_type get();
    result_type operator()();

[variablelist
[[Effects:] [Retrieves the value returned by the Nullary function.]]
[[Sychronization:][The completion of the call to the operator()() the Nullary function happens before get() returns.]]
[[Returns:] [If the result type R is a reference, returns the stored reference. 
If R is void, there is no return value. 
Otherwise, returns an rvalue-reference to the value stored in the asynchronous result.]]
[[Throws:] [the stored exception, if an exception was stored and not retrieved before.]]
[[Postconditions:] [It is unspecified what happens when get() is called a second time on the same shared_joiner.]]
[[Thread safety:][unsafe]]
]
[endsect]


[section Member Function `is_ready()`]
[/==========================================================================================]

    bool is_ready() const;

[variablelist
[[Returns:] [true only if the associated state holds a value or an exception ready for retrieval.]]
[[Remark:] [the return value is unspecified after a call to get().]]
]
[endsect]

[section Member Function `has_exception()`]
[/==========================================================================================]

    bool has_exception() const;

[variablelist
[[Returns:] [true only if is_ready() == true and the associated state contains an exception.]]
]
[endsect]

[section Member Function `has_value()`]
[/==========================================================================================]

    bool has_value() const;

[variablelist
[[Returns:] [true only if is_ready() == true and the associated state contains a value.]]
]
[endsect]

[section Member Function `wait()`]
[/==========================================================================================]

    void wait();

[variablelist
[[Effects:] [Blocks until the Nullariry function ends.]]
[[Sychronization:][The completion of the call to the operator()() the Nullary function happens before wait() returns.]]
[[Throws:] [the stored exception, if an exception was stored and not retrieved before.]]
[[Postconditions:] [is_ready() == true.]]
[[Thread safety:][unsafe]]
]
[endsect]

[section Member Function `wait_until()|wait_for()`]
[/==========================================================================================]

    bool wait_until(const system_time& abs_time);
    template<typename TimeDuration>
    bool wait_for(TimeDuration const& rel_time);


[variablelist
[[Effects:] [Blocks until the Nullariry function ends.]]
[[Sychronization:][The completion of the call to the operator()() the Nullary function happens before wait() returns.]]
[[Returns:] [If the result type R is a reference, returns the stored reference. 
If R is void, there is no return value. 
Otherwise, returns an rvalue-reference to the value stored in the asynchronous result.]]
[[Throws:] [the stored exception, if an exception was stored and not retrieved before.]]
[[Postconditions:] [is_ready() == true.]]
[[Thread safety:][unsafe]]
]
[endsect]



[section:joinable2 Member function `joinable()`]
[/==========================================================================================]

    bool joinable() const;

[variablelist
[[Returns:] [`true` if `*this` refers to a thread of execution, `false` otherwise.]]
[[Throws:] [Nothing]]
]

[endsect]

[section:join2 Member function `join()`]
[/==========================================================================================]

    void join();

[variablelist
[[Preconditions:] [`this->get_id()!=boost::this_thread::get_id()`]]
[[Effects:] [If `*this` refers to a thread of execution, waits for that thread of execution to complete.]]
[[Postconditions:] [If `*this` refers to a thread of execution on entry, that thread of execution has completed. `*this` no longer refers to any thread of execution.]]
[[Throws:] [__thread_interrupted__ if the current thread of execution is interrupted.]]
[[Notes:] [`join()` is one of the predefined __interruption_points__.]]
]

[endsect]

[section Member function `join_until()|join_for()`]
[/==========================================================================================]

    bool join_until(const system_time& wait_until);

    template<typename TimeDuration>
    bool join_for(TimeDuration const& rel_time);

[variablelist
[[Preconditions:] [`this->get_id()!=boost::this_thread::get_id()`]]
[[Effects:] [If `*this` refers to a thread of execution, waits for that thread of execution to complete, the time `wait_until` has
been reach or the specified duration `rel_time` has elapsed. If `*this` doesn't refer to a thread of execution, returns immediately.]]
[[Returns:] [`true` if `*this` refers to a thread of execution on entry, and that thread of execution has completed before the call
times out, `false` otherwise.]]
[[Postconditions:] [If `*this` refers to a thread of execution on entry, and `timed_join` returns `true`, that thread of execution
has completed, and `*this` no longer refers to any thread of execution. If this call to `timed_join` returns `false`, `*this` is
unchanged.]]
[[Throws:] [__thread_interrupted__ if the current thread of execution is interrupted.]]
[[Notes:] [`timed_join()` is one of the predefined __interruption_points__.]]
]

[endsect]

[section:detach3 Member function `detach()`]
[/==========================================================================================]

    void detach();

[variablelist
[[Effects:] [If `*this` refers to a thread of execution, that thread of execution becomes detached, and no longer has an associated __thread__ object.]]
[[Postconditions:] [`*this` no longer refers to any thread of execution.]]
[[Throws:] [Nothing]]
]

[endsect]


[section:get_id2 Member function `get_id()`]
[/==========================================================================================]

    thread::id get_id() const;

[variablelist
[[Returns:] [If `*this` refers to a thread of execution, an instance of __thread_id__ that represents that thread. Otherwise returns
a default-constructed __thread_id__.]]
[[Throws:] [Nothing]]
]

[endsect]

[section:interrupt2 Member function `interrupt()`]
[/==========================================================================================]

    void interrupt();

[variablelist
[[Effects:] [If `*this` refers to a thread of execution, request that the thread will be interrupted the next time it enters one of
the predefined __interruption_points__ with interruption enabled, or if it is currently __blocked__ in a call to one of the
predefined __interruption_points__ with interruption enabled .]]
[[Throws:] [Nothing]]
]
        

[endsect]


[section:nativehandle2 Member function `native_handle()`]
[/==========================================================================================]

    typedef platform-specific-type native_handle_type;
    native_handle_type native_handle();

[variablelist
[[Effects:] [Returns an instance of `native_handle_type` that can be used with platform-specific APIs to manipulate the underlying
implementation. If no such instance exists, `native_handle()` and `native_handle_type` are not present.]]
[[Throws:] [Nothing.]]
]

[endsect]



[endsect]
[section:non_member_swap2 Non-member function `swap()`]

    void swap(shared_joiner& lhs,shared_joiner& rhs);

[variablelist

[[Effects:] [[link thread.thread_management.thread.swap `lhs.swap(rhs)`].]]

]

[endsect]

[/==================================================]
[section Template Class `shared_threader`] 
[/==========================================================================================]

    class shared_threader {
    public: 
        thread::native_handle_attr_type& attributes();

        template <typename T>
        struct handle {
            typedef shared_joiner<T> type;
        };

        template <typename F>
        shared_joiner<typename result_of<F()>::type> 
        fork(F f);

    };

[section Member function `shared_threader::attributes()`] 
[/==========================================================================================]

Reference to the thread attributes accesor.

        thread::native_handle_attr_type& attributes();

[variablelist
[[Returns:] [A reference to the thread attributes.]]
[[Complexity:] [constant.]]
]


[endsect]
[section Metafunction `shared_threader::handle<>`] 
[/==========================================================================================]

Metafunction that returns the result type of the fork function applied to a shared_threader and the value type.

        template <typename T>
        struct handle {
            typedef shared_joiner<T> type;
        };


[variablelist
[[Expression:] [L::handle<T>::type]]
[[Return type:] [A shared_joiner<T>.]]
[[Complexity:] [constant.]]

]

[endsect]

[section Member function `shared_threader::fork`] 
[/==========================================================================================]

        template <typename F>
        shared_joiner<typename result_of<F()>::type> 
        fork(F f);

[variablelist
[[Returns:] [A shared_joiner to the result of calling a function F.]]
[[Effects:] [create a thread executing the function f. 
		 The result of the function will be stored on the resulting shared_joiner.]]

]


[endsect]

[endsect]

[endsect]


[/==========================================================================================]
[section Header `<boost/interthreads/typeof/future.hpp>`]
[/==========================================================================================]

    BOOST_TYPEOF_REGISTER_TEMPLATE(boost::interthreads::unique_future, 1)
    BOOST_TYPEOF_REGISTER_TEMPLATE(boost::interthreads::shared_future, 1)
    BOOST_TYPEOF_REGISTER_TEMPLATE(boost::interthreads::promise, 1)
    BOOST_TYPEOF_REGISTER_TEMPLATE(boost::interthreads::packaged_task, 1)

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/typeof/launcher.hpp>`]
[/==========================================================================================]

    BOOST_TYPEOF_REGISTER_TYPE(boost::interthreads::launcher)
    BOOST_TYPEOF_REGISTER_TYPE(boost::interthreads::shared_launcher)

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/typeof/threader.hpp>`]
[/==========================================================================================]

    BOOST_TYPEOF_REGISTER_TYPE(boost::interthreads::unique_threader)
    BOOST_TYPEOF_REGISTER_TEMPLATE(boost::interthreads::unique_joiner, 1)

    BOOST_TYPEOF_REGISTER_TYPE(boost::interthreads::shared_threader)
    BOOST_TYPEOF_REGISTER_TEMPLATE(boost::interthreads::shared_joiner, 1)

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/typeof/basic_threader.hpp>`]
[/==========================================================================================]

    BOOST_TYPEOF_REGISTER_TYPE(boost::interthreads::basic_threader)

[endsect]

[/==========================================================================================]
[section Header `<boost/interthreads/typeof/scheduler.hpp>`]
[/==========================================================================================]
[endsect]

    BOOST_TYPEOF_REGISTER_TEMPLATE(boost::tp::task, 1)


[/==========================================================================================]
[section:decorator_thread_decoration_file Header `<boost/interthreads/thread_decoration.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
        class thread_decoration;
    }
    }

[/==================================================]
[section:thread_decoration Class `thread_decoration`] 
[/==========================================================================================]

`thread_decoration` defines a couple of setup/cleanup functions chained to the last constructed decoration, i.e. decorations are chained between them.

    class thread_decoration {
    public:
        template<typename Callable1>
        thread_decoration(Callable1 setup);
        
        template<typename Callable1,typename Callable2>
        thread_decoration(Callable1 setup, Callable2 cleanup);
        
        ~thread_decoration() {
    };

[section:thread_decoration_class_constructor_setup Constructor with setup]
[/==========================================================================================]

    template<typename Callable>
    thread_decoration(Callable func);

[variablelist

[[Requires:] [`Callable` is `CopyConstructible`. Copying `setup` shall have no side effects, and the effect of calling the copy shall
be equivalent to calling the original. ]]

[[Effects:] [`setup` is copied into storage managed internally by the library, and that copy is invoked by the 
__thread_decorator_decorate__ function.]]

[[Postconditions:] [`*this` refers to a decoration.]]

[[Throws:] [Nothing]]

[[Thread safety:][unsafe]]

]

[note The library do not ensures any order of decorations.]

[endsect]

[section Constructor with setup & cleanup]
[/==========================================================================================]

    template<typename Callable1,typename Callable2>
    thread_decoration(Callable1 setup, Callable2 cleanup);


[variablelist

[[Requires:] [`Callable1` & `Callable1` are `CopyConstructible`. Copying `setup`  or `cleanup` shall have no side effects, and the effect of calling the copy shall
be equivalent to calling the original. ]]

[[Effects:] [`setup` and `cleanup` are copied into storage managed internally by the library, and the `setup` copy is invoked by the 
__thread_decorator_decorate__ function. If successful the cleanup function is registered to the to the thread exit handler.]]

[[Postconditions:] [`*this` refers to a decoration.]]

[[Throws:] [Nothing]]

[[Thread safety:][unsafe]]

]

[note The library do not ensures any order of setup decorations neither of cleanup decorations.]

[endsect]
[endsect]

[endsect]



[/==========================================================================================]
[section:decorator_thread_decorator_file Header `<boost/interthreads/thread_decorator.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
        class thread_decorator;
        void decorate();
    }
    }


[section:thread_decorator Class `thread_decorator`]
[/==========================================================================================]

`thread_decorator` is a functor wrapping a function with the setup and the cleanup of chained decorations which will be called only once by thread: 
decoration's setup are called before the thread function and decoration's cleanup at thread exit. 

    class thread_decorator {
    public:    

        template <class Callable>
        explicit thread_decorator(Callable&& f);
        template <class Callable>
        explicit thread_decorator(detail::thread_move_t<Callable> f):
        template<typename Callable>
        thread_decorator(Callable f, 
            typename disable_if<boost::is_convertible<F&,detail::thread_move_t<F> >
                               , detail::dummy* >::type=0);        

        template <typename Callable, typename A1, typename A2, ...>
        thread_decorator(Callable f, A1 a1, A2 a2, ...)

        thread_decorator(thread_decorator&& other);
        
        thread_decorator& operator=(thread_decorator&& other);

        thread_decorator&& move();
        
        void swap(thread_decorator& x);

        void operator ()();

    };

Functor wrapping the user function thread to ensure that all the decorations are called.

Objects of type `thread_decorator` are movable, so they can be stored in move-aware containers, and returned from functions. 
This allows the details of thread decoration to be wrapped in a function.

thread_decorator make_decorator();

void f()
{
    boot::thread some_thread(make_decorator());
    some_thread.join();
}

[note On compilers that support rvalue references, `thread_decorator` provides a proper move constructor and move-assignment operator, 
and therefore meets the C++0x `MoveConstructible` and `MoveAssignable` concepts. With such compilers, `thread_decorator` can therefore 
be used with containers that support those concepts.

For other compilers, move support is provided with a move emulation layer, so containers must explicitly detect that move emulation 
layer. See `<boost/thread/detail/move.hpp>` for details.] 

[section:decorator_thread_decoration_decorate_constructor Constructor]
[/==========================================================================================]

        template <class Callable>
        thread_decorator(Callable&& func);
        template<typename Callable>
        thread_decorator(Callable func);        
        
[variablelist

[[Template parameters:] [`Callable` must by `CopyConstructible`.]]

[[Effects:] [`func` is copied into storage managed internally by the library, and that copy will be invoked after the operator() function when the decorate is used as Callable of a newly-created
thread of execution.]]

[[Throws:] [`std::bad_alloc` when resources unavailable.]]

[[Thread safety:][safe]]

]

[endsect]

[section:decorator_thread_decoration_decorate_constructorn Constructor]
[/==========================================================================================]

        template <typename Callable, typename A1, typename A2, ...>
        thread_decorator(Callable func, A1 a1, A2 a2, ...)

[variablelist

[[Template parameters:] [`Callable` must by `CopyConstructible`.]]

[[Effects:] [`func` is copied into storage managed internally by the library, and that copy will be invoked after the operator() function when the decorate is used as Callable of a newly-created
thread of execution.]]

[[Throws:] [`std::bad_alloc` when resources unavailable.]]

[[Thread safety:][safe]]

]

[endsect]

[section:decorator_thread_decoration_decorate_copy_move_constructor Copy Move Constructor]
[/==========================================================================================]

        thread_decorator(thread_decorator&& other);
        thread_decorator(detail::thread_move_t<thread_decorator> other) {

[variablelist

[[Template parameters:] [`Callable` must by `CopyConstructible`.]]

[[Effects:] [`func` is copied into storage managed internally by the library, and that copy will be invoked after the operator() function when the decorate is used as Callable of a newly-created
thread of execution.]]

[[Throws:] [`std::bad_alloc` when resources unavailable.]]

[[Thread safety:][safe]]

]

[endsect]


[section:decorator_thread_decoration_decorate_copy_constructor Assign Move Constructor]
[/==========================================================================================]

        thread_decorator& operator=(thread_decorator&& other);
        thread_decorator& operator=(detail::thread_move_t<thread_decorator> x) {
        

[variablelist

[[Requires:] [`Callable` must by `CopyConstructible`.]]


[[Effects:] [`func` is copied into storage managed internally by the library, and that copy will be invoked after the operator() function when the decorate is used as Callable of a newly-created
thread of execution.]]

[[Returns:] [a reference to `*this`.]]

[[Throws:] [Nothing.]]

[[Thread safety:][neutral]]

]

[endsect]

[section:decorator_thread_decoration_conversion Member Function `operator detail::thread_move_t<thread_decorator>()`]
[/==========================================================================================]

        operator detail::thread_move_t<thread_decorator>();


[variablelist

[[Effects:] [helper for move semantics emulation.]]

[[Returns:] [the move form `*this`.]]

[[Throws:] [Nothing.]]

[[Thread safety:][neutral]]

]

[endsect]

[section:decorator_thread_decoration_move Member Function `move()`]
[/==========================================================================================]

        detail::thread_move_t<thread_decorator> move() {
        thread_decorator&& move();


[variablelist

[[Effects:] [Move *this to the caller.]]

[[Returns:] [the move form `*this`.]]

[[Throws:] [Nothing.]]

[[Thread safety:][neutral]]

]

[endsect]

[section:decorator_thread_decoration_swap Member Function `swap()`]
[/==========================================================================================]

        void swap(thread_decorator& x);


[variablelist

[[Effects:] []]

[[Throws:] [Nothing.]]

[[Thread safety:][neutral]]

]

[endsect]

[section:decorator_thread_decoration_operator_f Member Function `operator()()`]
[/==========================================================================================]

    void operator()();


[variablelist

[[Effects:] [Functor operator]]

[[Throws:] [Any exception thrown by the decorations or the user function.]]

[[Thread safety:][unsafe - depends on the decorations constructio/destruction.]]

]

[endsect]
[endsect]

[section:decorate Non Member Function `decorate()`]
[/==========================================================================================]

    void decorate();


[variablelist

[[Requires:] [`Callable` is `CopyConstructible`. Copying `f` shall have no side effects, and the effect of calling the copy shall
be equivalent to calling the original. ]]

[[Effects:] [Calls every declared decoration using the thread_decoration class. 
]]

[[Postconditions:] [All the decorations have been called.]]

[[Throws:] [Any exception thrown by the decorations.]]

[[Thread safety:][unsafe - depends on the decorations constructio/destruction.]]

]

[endsect]


[endsect]


[section:thread_specific_shared_ptr_reference_Header Header `<boost/interthreads/thread_specific_shared_ptr.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
    
        template <typename T>
        class thread_specific_shared_ptr;
    
    }
    }
    

[section:thread_specific_shared_ptr_reference_thread_specific_shared_ptr Template Class `thread_specific_shared_ptr<>`]
[/==========================================================================================]

`bith::thread_specific_shared_ptr<>` is an extension of the thread_specific_ptr providing access 
to this thread specific context from other threads.

    template <typename T>
    class thread_specific_shared_ptr : private noncopyable
    {
    public:
        typedef shared_ptr<T>               shared_ptr_type;
        typedef 'implementation defined'    map_type;
        typedef 'implementation defined'    mutex_type;
        typedef 'implementation defined'    lock_type;

        thread_specific_shared_ptr();
        explicit thread_specific_shared_ptr(void (*cleanup_)(shared_ptr_type));
        ~thread_specific_shared_ptr();

        T*                      get() const;
        T*                      operator->() const;        
        T&                      operator*() const;
        void                    reset();
        template<class Y> 
        void                    reset(Y * p);
        template<class Y, class D> 
        void                    reset(Y * p, D d);
        template<class Y, class D, class A> 
        void                    reset(Y * p, D d, A a);
        
        mutex_type&             get_mutex();
        const map_type&         get_map(lock_type&) const;
        shared_ptr_type   operator[](thread::id id) const;
        shared_ptr_type   wait_and_get(thread::id id) const;
    private:        
        shared_ptr_type         get_shared_ptr() const;
    };

[section:thread_specific_shared_ptr_reference_parameters Template parameters]
[/==========================================================================================]

`thread_specific_shared_ptr<>` is instantiated with the following types:

* T The type of the pointeed object

[endsect]

[section:thread_specific_shared_ptr_reference_types  Public types]
[/==========================================================================================]

`thread_specific_shared_ptr<>` defines the following types:

* [*`shared_ptr_type`] The shared pointed type.
* [*`map_type`] The mapping type from `thread::id` to `shared_ptr_type`
* [*`mutex_type`] The protecting mutext type follwing the Lockable Concept
* [*`lock_type`] The lock used to get the map follwing the unique_lock subjacent Concept

[endsect]

[section:thread_specific_shared_ptr_default_constructor Constructor]
[/==========================================================================================]

    thread_specific_shared_ptr();

[variablelist

[[Effects:] [Construct a `thread_specific_shared_ptr<>` object for storing a pointer to an object of type `T` specific to each thread.]]

[[Throws:] [`std::bad_alloc` when resources unavailable.]]

[[Thread safety:][safe.]]

]

[endsect]

[section:thread_specific_shared_ptr_constructor_with_custom_cleanup Cleanup Constructor]
[/==========================================================================================]

    explicit thread_specific_shared_ptr(void (*cleanup_)(shared_ptr_type));

[variablelist

[[Requires:] [`cleanup_function(this->get())` does not throw any exceptions.]]

[[Effects:] [Construct a `thread_specific_shared_ptr<>` object for storing a pointer to an object of type `T` specific to each thread. The
supplied `cleanup_function` will be called at thread exit.]]

[[Throws:] [`std::bad_alloc` when resources unavailable.]]

[[Thread safety:][safe.]]

]

[endsect]

[section:thread_specific_shared_ptr_destructor Destructor]
[/==========================================================================================]

    ~thread_specific_shared_ptr();

[variablelist

[[Effects:] [Remove from the map the current thread::id and destroys `*this`.]]

[[Throws:] [Nothing.]]

[[Thread safety:][safe.]]

]

[note Care needs to be taken to ensure that any threads still running after an instance of `boost::thread_specific_shared_ptr<>` has been
destroyed do not call any member functions on that instance. Is for this raison that usualy instance of this class are static.]

[endsect]


[section:thread_specific_shared_ptr_get Member Function `get()`]
[/==========================================================================================]

    shared_ptr_type get() const;

[variablelist

[[Returns:] [The pointer associated with the current thread.]]

[[Throws:] [Nothing.]]

[[Thread safety:][safe.]]

]

[note The initial value associated with an instance of `boost::thread_specific_shared_ptr<>` is `NULL` for each thread.]

[endsect]

[section:thread_specific_shared_ptr_operator_arrow Member Function `operator->()`]
[/==========================================================================================]

    T* operator->() const;        

[variablelist

[[Requires:] [`this->get()` is not `NULL`.]]

[[Returns:] [`this->get()`]]

[[Throws:] [Nothing.]]

[[Thread safety:][safe.]]

]

[endsect]

[section:thread_specific_shared_ptr_operator_star Member Function `operator*()`]
[/==========================================================================================]

    T& operator*() const;

[variablelist

[[Requires:] [`this->get()` is not `NULL`.]]

[[Returns:] [`*(this->get())`]]

[[Throws:] [Nothing.]]

[[Thread safety:][safe.]]

]

[endsect]

[section:thread_specific_shared_ptr_reset Member Function `reset()`]
[/==========================================================================================]

    void reset();

[variablelist
[[Effects:] [Equivalent to `shared_ptr().swap(this->get_shared_ptr())`. Update the mapping.]]
[[Postcondition:] [`this->get()==0`]]
[[Throws:] [`std::bad_alloc` when resources unavailable.]]
[[Thread safety:][safe.]]

]

    template<class Y> void reset(Y * new_value);

[variablelist
[[Effects:] [Equivalent to `shared_ptr(new_value).swap(this->get_shared_ptr())`. Update the mapping.]]
[[Postcondition:] [`this->get()==new_value`]]
[[Throws:] [`std::bad_alloc` when resources unavailable.]]
[[Thread safety:][safe.]]
]

    template<class Y, class D> void reset(Y * new_value, D deleter);

[variablelist
[[Effects:] [Equivalent to `shared_ptr(new_value, deleter).swap(this->get_shared_ptr())`. Update the mapping.]]
[[Postcondition:] [`this->get()==new_value`]]
[[Throws:] [`std::bad_alloc` when resources unavailable.]]
[[Thread safety:][safe.]]
]

    template<class Y, class D, class A> void reset(Y * new_value, D deleter, A a);

[variablelist
[[Effects:] [Equivalent to `shared_ptr(new_value, deleter, a).swap(this->get_shared_ptr())`. Update the mapping.]]
[[Postcondition:] [`this->get()==new_value`]]
[[Throws:] [`std::bad_alloc` when resources unavailable.]]
[[Thread safety:][safe.]]
]

[variablelist

[[Effects:] [If `this->get()!=new_value` and `this->get()` is non-`NULL`, invoke `delete this->get()` or
`deleter(this->get())` as appropriate. Store `new_value` as the pointer associated with the current thread.]]

[[Throws:] [`std::bad_alloc` when resources unavailable.]]

]

[endsect]

[section:thread_specific_shared_ptr_wait_and_get Member Function `wait_and_get()`]
[/==========================================================================================]
        
    shared_ptr_type wait_and_get(thread::id id) const;

[variablelist

[[Effects:] [Waits until the specific shared pointer has been set and returns a shared pointer to this context.]]

[[Throws:] [`boost::thread_interrupted` if the current thread of execution is interrupted.]]

]

[endsect]

[section:thread_specific_shared_ptr_operatora Member Function `operator[]()`]
[/==========================================================================================]

    shared_ptr_type operator[](thread::id id) const;

[variablelist

[[Effects:] [Returns a copy of the specific shared_ptr of the thread of execution identified by the `thread::id`.]]

[[Throws:] [Nothing.]]

]

[endsect]


[section:get_mutex Member Function `get_mutex()`]
[/==========================================================================================]
        
    mutex_type&             get_mutex();

[variablelist

[[Effects:] [Returns a reference to the protection mutex.]]

[[Throws:] [Nothing.]]

]

[endsect]

[section:get_map Member Function `get_map()`]
[/==========================================================================================]
        
    const map_type&         get_map(lock_type&) const;

[variablelist

[[Effects:] [Returns a reference to the mapping from `thread::id` to the specific pointers provided the user gives a lock on the motext get using `get_mutex()`.]]

[[Throws:] [Nothing.]]

]
[endsect]




[endsect]

[endsect]

[section:keep_alive_file Header `<boost/interthreads/thread_keep_alive.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
        namespace this_thread 	{
            class enable_keep_alive;
            class disable_keep_alive;

            void keep_alive_check_point();
            bool keep_alive_enabled();
            typedef void (*on_dead_thread_type)(thread::id);
            void set_on_dead_thread(on_dead_thread_type fct);
        }
    }
    }

[section:keep_alive_enable_keep_alive class `enable_keep_alive`]
[/==========================================================================================]

    class enable_keep_alive : private noncopyable{
    public:
        enable_keep_alive(std::size_t threshold=2, std::size_t tap=1);
        ~enable_keep_alive();
    };

[section:keep_alive_enable_keep_alive_Constructor Constructor]
[/==========================================================================================]

        enable_keep_alive(std::size_t threshold=2, std::size_t tap=1);

[variablelist

[[Effects:] [Enable the keep alive mechanism on this thread of execution.]]

[[Throws:] [Nothing]]

]

[endsect]

[section:keep_alive_enable_keep_alive_Destructor Destructor]
[/==========================================================================================]

        ~enable_keep_alive();

[variablelist

[[Effects:] [Restore the keep alive mechanism as it was before the constructor.]]

[[Throws:] [Nothing]]

]

[endsect]
[endsect]

[section:keep_alive_disable_keep_alive class `disable_keep_alive`]
[/==========================================================================================]

    class disable_keep_alive private noncopyable {
    public:
        disable_keep_alive();
        ~disable_keep_alive();
    };

[section:keep_alive_disable_keep_alive_Constructor Constructor]
[/==========================================================================================]

    disable_keep_alive();

[variablelist

[[Effects:] [Disable the keep alive mechanism on this thread of execution.]]

[[Throws:] [Nothing]]

]

[endsect]

[section:keep_alive_disable_keep_alive_Destructor Destructor]
[/==========================================================================================]

    ~disable_keep_alive();

[variablelist

[[Effects:] [Restore the keep alive mechanism as it was before the constructor.]]

[[Throws:] [Nothing]]

]

[endsect]
[endsect]

[section:keep_alive_keep_alive_check_point Non Member Function `keep_alive_check_point()`]
[/==========================================================================================]

    void keep_alive_check_point();

[variablelist

[[Effects:] [States that the current thread is alive.]]
[[Postconditions:] [The thread is alive.]]
[[Throws:] [Nothing]]

]

[endsect]

[section:keep_alive_keep_alive_enabled Non Member Function `keep_alive_enabled()`]
[/==========================================================================================]

    bool keep_alive_enabled();

[variablelist

[[Effects:] [States if the keep alive mechanism is enabled on this thread.]]
[[Throws:] [Nothing]]

]

[endsect]

[section:keep_alive_keep_alive_set_on_dead_thread Non Member Function `set_on_dead_thread()`]
[/==========================================================================================]

    void set_on_dead_thread(on_dead_thread_type fct);

[variablelist

[[Effects:] [Modifies the action to be done when a this thread is declared dead.]]

[[Throws:] [Nothing]]

]

[endsect]

[endsect]

[section:thread_tuple_thread_tuple_hpp Header `<boost/interthreads/thread_tuple.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        template <std::size_t  N>
        class thread_tuple;

        template<typename F0, ..., typename Fn-1>
        thread_tuple<n> make_thread_tuple(F0 f0, ..., Fn fn-1);

    }
    }


[section:thread_tuple_class Template Class `thread_tuple<>`]
[/==========================================================================================]

`thread_tuple<>` defines a thread groupe where the number of threads is know statically and the threads are 
created at construction time. 

    template <std::size_t  n>
    class thread_tuple {
    public:
        template<typename F0, ..., typename Fn-1>
    	thread_tuple(F0 f0, ..., Fn-1 fn-1);
        
        template <class F>
        thread_tuple(boost::move_t<F> f);
        ~thread_tuple();

        // move support
        thread_tuple(boost::move_t<thread_tuple<n>> x);
        thread_tuple& operator=(boost::move_t<thread_tuple<n>> x);
        operator boost::move_t<thread_tuple<n>>();
        boost::move_t<thread_tuple<n>> move();

        void swap(thread_tuple<n>& x);

        bool joinable() const;
        void join_all();
        bool join_all_until(const system_time& wait_until);
        template<typename TimeDuration>
        bool join_all_for(TimeDuration const& rel_time);

        void detach();
        void detach_all();

        void interrupt();
        void interrupt_all();
        bool interruption_requested() const;

        size_t size();
        
        const thread& operator[](std::size_t i);
    };    
    }
    }


The __thread_tuple__ class is responsible for launching and managing a static collection of threads that are related in some fashion. 
No new threads can be added to the tuple once constructed.

[section Template parameters]
[/==========================================================================================]

`thread_tuple<>` is instantiated with the following value:

* n is the size of the tuple.

[endsect]

[section:thread_tuple_callable_constructor Constructor]
[/==========================================================================================]

    template<typename F0, ..., typename Fn-1>
    thread_tuple(F0 func_0, ..., Fn-1 func_n-1);

[variablelist

[[Preconditions:] [`Fk` must by copyable.]]

[[Effects:] [`func_k` is copied into storage managed internally by the library, and that copy is invoked on a newly-created
thread of execution. If this invocation results in an exception being propagated into the internals of the library that is
not of type __thread_interrupted__, then `std::terminate()` will be called.]]

[[Postconditions:] [`*this` refers to the newly created tuple of threads of execution.]]

[[Throws:] [__thread_resource_error__ if an error occurs.]]

[[Note:] [Currently up to ten arguments `func_0` to `funct_9` can be specified.]]

]

[endsect]


[section:thread_tuple_destructor Destructor]
[/==========================================================================================]

    ~thread_tuple();

[variablelist

[[Effects:] [If *this  have associateds thread of execution, calls detach() on them. Destroys *this.]]

]

[endsect]

[section:thread_tuple_joinable Member function `joinable()`]
[/==========================================================================================]

    bool joinable() const;

[variablelist

[[Returns:] [`true` if `*this` refers to threads of execution, `false` otherwise.]]

[[Throws:] [Nothing]]

]

[endsect]

[section:thread_tuple_join Member function `join_all()`]
[/==========================================================================================]

    void join();
    void join_all();

[variablelist

[[Effects:] [Call `join()` on each __thread__ object in the tuple.]]

[[Postcondition:] [Every thread in the tuple has terminated.]]

[[Throws:] [Nothing]]

[[Note:] [Since `boost::thread::join` is one of the predefined interruption points, `thread_tuple<>::join_all()` is also an interruption point.]]

]

[endsect]

[section Member function `join_all_until()`]
[/==========================================================================================]

    bool join_all_until(const system_time& wait_until);

[variablelist

[[Effects:] [Call `timed_join()` on each __thread__ object in the tuple.]]

[[Postcondition:] [Every thread in the tuple has terminated.]]

[[Returns:] [true if joined.]]

[[Throws:] [Nothing]]

[[Note:] [Since `boost::thread::timed_join` is one of the predefined interruption points, `thread_tuple<>::join_all_until()` is also an interruption point.]]

]

[endsect]

[section Member function `join_all_for()`]
[/==========================================================================================]

    template<typename TimeDuration>
    bool join_for(TimeDuration const& rel_time);

[variablelist

[[Effects:] [As `join_all_until(now()+rel_time)`.]]

[[Postcondition:] [Every thread in the tuple has terminated.]]

[[Returns:] [true if joined.]]

[[Throws:] [Nothing]]

[[Note:] [Since `boost::thread::timed_join` is one of the predefined interruption points, `thread_tuple<>::join_all_for()` is also an interruption point.]]

]

[endsect]

[section:join_first_then_interrupt Member function `join_any()`]
[/==========================================================================================]

    std::size_t conc_join_any();

[variablelist

[[Effects:] [Call `join_any()` on a temporary thread_tuple and the `interrup_all()`.]]

[[Postcondition:] [Every thread in the tuple has terminated.]]

[[Throws:] [Nothing]]

[[Note:] [Since `join_any()` is one of the predefined interruption points, `conc_join_any()` is also an interruption point.]]

]

[endsect]

[section Member function `join_any_until()`]
[/==========================================================================================]

    std::pair<bool,std::size_t> conc_join_any_until(
            const system_time& wait_until);
    template<typename TimeDuration>
    std::pair<bool,std::size_t> join_any_for(
            TimeDuration const& rel_time);

[variablelist

[[Effects:] [Call `join_any_until()` on a temporary thread_tuple and the `interrup_all()`.]]

[[Postcondition:] [Every thread in the tuple has terminated.]]

[[Returns:] [true if joined.]]

[[Throws:] [Nothing]]

[[Note:] [Since `join_any_until()` is one of the predefined interruption points, `conc_join_any_until()` is also an interruption point.]]

]

[endsect]

[section:detach_all Member function `detach_all()`]
[/==========================================================================================]

    void detach_all();

[variablelist

[[Effects:] [Call `detach()` on each __thread__ object in the tuple.]]

]

[endsect]

[section:thread_tuple_interrupt_all Member function `interrupt_all()`]
[/==========================================================================================]

    void interrupt_all();

[variablelist

[[Effects:] [Call `thread::interrupt()` on each __thread__ object in the tuple.]]

]

[endsect]

[section:thread_tuple_size Member function `size()`]
[/==========================================================================================]

    int size();

[variablelist

[[Returns:] [The number of threads in the tuple.]]

[[Throws:] [Nothing.]]

]

[endsect]

[endsect]

[section:thread_tuple_make_thread_tuple Non Member Function `make_thread_tuple()`]
[/==========================================================================================]

    template<typename F0, ..., typename Fn-1>
    thread_tuple make_thread_tuple(F0 f0, ..., Fn fn-1);

[variablelist

[[Effects:] [makes a new thread_tuple<>.]]
[[Returns:] [the created thread tuple.]]


]

[endsect]

[endsect]

[section:set_once_hpp Header `<boost/interthreads/set_once.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {
        template <typename T>
        class set_once;
    }    
    }


[section:set_onceclass Template Class `set_once<>`]
[/==========================================================================================]

`set_once_once<>` is a synchonizer that allows to set a variable only once, notifying 
to the variable value to whatever is waiting for that.


    template <typename T>
    class set_once {
    public:
        typedef T value_type;
        
        set_once();
        void wait();
        bool wait_until(const system_time& abs_time);
        template<typename TimeDuration>
        bool wait_for(const TimeDuration& rel_time);
        
        value_type get();       
        std::pair<bool,value_type> get_until(const system_time& abs_time);
        template<typename TimeDuration>
        std::pair<bool,value_type> get_for(const TimeDuration& rel_time);

        bool set_if_unassigned(value_type id);
        
        template<typename F>
        static void decorator(this_type& once, T value, F fct);
        template<typename F>
        static boost::detail::thread_move_t<thread> make_thread(this_type& once, T value, F fct);
    };

[endsect]

[endsect]

[section:thread_tuple_once_hpp Header `<boost/interthreads/thread_tuple_once.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        template <std::size_t  N>
        class thread_tuple_once;

        template<typename F0, ..., typename Fn-1>
        thread_tuple make_thread_tuple_once(F0 f0, ..., Fn fn-1);

    }
    }


[section:thread_tuple_once_class Template Class `thread_tuple_once<>`]
[/==========================================================================================]

`biththread_tuple_once` is an extension of the `bith::thread_tuple` which allows to join the thread finishing 
the first, using for that the `bith::set_once` synchronizer.

    template <std::size_t  n>
    class thread_tuple_once {
    public:
        template<typename F0, ..., typename Fn-1>
    	thread_tuple_once(F0 f0, ..., Fn-1 fn-1);
        
        template <class F>
        thread_tuple_once(boost::move_t<F> f);
        ~thread_tuple_once();

        // move support
        thread_tuple_once(boost::move_t<thread_tuple_once<n>> x);
        thread_tuple_once& operator=(boost::move_t<thread_tuple_once<n>> x);
        operator boost::move_t<thread_tuple_once<n>>();
        boost::move_t<thread_tuple_once<n>> move();

        void swap(thread_tuple_once<n>& x);

        bool joinables() const;
        void join_all();
        bool join_all_until(const system_time& wait_until);
        template<typename TimeDuration>
        bool join_all_for(TimeDuration const& rel_time);

        std::size_t join_any();
        std::pair<bool,std::size_t> join_any_until(
            const system_time& wait_until);
        template<typename TimeDuration>
        std::pair<bool,std::size_t> join_any_for(
            TimeDuration const& rel_time);

        void detach_all();

        void interrupt_all();
        bool interruption_requested() const;

        size_t size();
        
        const thread& operator[](std::size_t i);
    };    
    }
    }


The __thread_tuple_once__ class is responsible for launching and managing a static collection of threads that are related in some fashion. 
No new threads can be added to the tuple once constructed.

[section Template parameters]
[/==========================================================================================]

`thread_tuple_once<>` is instantiated with the following value:

* n is the size of the tuple.

[endsect]

[section:thread_tuple_once_callable_constructor Constructor]
[/==========================================================================================]

    template<typename F0, ..., typename Fn-1>
    thread_tuple_once(F0 func_0, ..., Fn-1 func_n-1);

[variablelist

[[Preconditions:] [`Fk` must by copyable.]]

[[Effects:] [`func_k` is copied into storage managed internally by the library, and that copy is invoked on a newly-created
thread of execution. If this invocation results in an exception being propagated into the internals of the library that is
not of type __thread_interrupted__, then `std::terminate()` will be called.]]

[[Postconditions:] [`*this` refers to the newly created tuple of threads of execution.]]

[[Throws:] [__thread_resource_error__ if an error occurs.]]

[[Note:] [Currently up to ten arguments `func_0` to `funct_9` can be specified.]]

]

[endsect]


[section:thread_tuple_once_destructor Destructor]
[/==========================================================================================]

    ~thread_tuple_once();

[variablelist

[[Effects:] [If *this  have associateds thread of execution, calls detach() on them. Destroys *this.]]

]

[endsect]

[section:thread_tuple_once_joinable Member function `joinables()`]
[/==========================================================================================]

    bool joinables() const;

[variablelist

[[Returns:] [`true` if `*this` refers to threads of execution, `false` otherwise.]]

[[Throws:] [Nothing]]

]

[endsect]

[section:thread_tuple_once_join Member function `join_all()`]
[/==========================================================================================]

    void join_all();

[variablelist

[[Effects:] [Call `join()` on each __thread__ object in the tuple.]]

[[Postcondition:] [Every thread in the tuple has terminated.]]

[[Throws:] [Nothing]]

[[Note:] [Since `boost::thread::join` is one of the predefined interruption points, `thread_tuple_once<>::join_all()` is also an interruption point.]]

]

[endsect]

[section Member function `join_all_until()`]
[/==========================================================================================]

    bool join_all_until(const system_time& wait_until);
    template<typename TimeDuration>
    bool join_all_for(TimeDuration const& rel_time);

[variablelist

[[Effects:] [Call `timed_join()` on each __thread__ object in the tuple.]]

[[Postcondition:] [Every thread in the tuple has terminated.]]

[[Returns:] [true if joined.]]

[[Throws:] [Nothing]]

[[Note:] [Since `boost::thread::timed_join` is one of the predefined interruption points, `thread_tuple_once<>::timed_join_all()` is also an interruption point.]]

]

[endsect]

[section Member function `join_any()`]
[/==========================================================================================]

    std::size_t join_any();

[variablelist

[[Effects:] [Call `join_first()` and the `interrup_all()`.]]

[[Postcondition:] [Every thread in the tuple has terminated.]]

[[Throws:] [Nothing]]

[[Note:] [Since `boost::thread::join` is one of the predefined interruption points, `thread_tuple_once<>::join_all()` is also an interruption point.]]

]

[endsect]

[section:timed_join_first_then_interrupt Member function `timed_join_first_then_interrupt()`]
[/==========================================================================================]

    std::pair<bool,std::size_t> timed_join_first_then_interrupt(
            const system_time& wait_until);
    template<typename TimeDuration>
    std::pair<bool,std::size_t> timed_join_first_then_interrupt(
            TimeDuration const& rel_time);

[variablelist

[[Effects:] [Call `timed_join_first()` and the `interrup_all()`.]]

[[Postcondition:] [Every thread in the tuple has terminated.]]

[[Returns:] [true if joined.]]

[[Throws:] [Nothing]]

[[Note:] [Since `boost::thread::timed_join` is one of the predefined interruption points, `thread_tuple_once<>::timed_join_all()` is also an interruption point.]]

]

[endsect]

[section:detach_all Member function `detach_all()`]
[/==========================================================================================]

    void detach_all();

[variablelist

[[Effects:] [Call `detach()` on each __thread__ object in the tuple.]]

]

[endsect]

[section:thread_tuple_once_interrupt_all Member function `interrupt_all()`]
[/==========================================================================================]

    void interrupt_all();

[variablelist

[[Effects:] [Call `thread::interrupt()` on each __thread__ object in the tuple.]]

]

[endsect]

[section:thread_tuple_once_size Member function `size()`]
[/==========================================================================================]

    int size();

[variablelist

[[Returns:] [The number of threads in the tuple.]]

[[Throws:] [Nothing.]]

]

[endsect]

[endsect]

[section:thread_tuple_once_make_thread_tuple_once Non Member Function `make_thread_tuple_once()`]
[/==========================================================================================]

    template<typename F0, ..., typename Fn-1>
    thread_tuple_once make_thread_tuple_once(F0 f0, ..., Fn fn-1);

[variablelist

[[Effects:] [makes a new thread_tuple_once<>.]]
[[Returns:] [the created thread tuple.]]


]

[endsect]

[endsect]


[section:thread_and_join_hpp Header `<boost/interthreads/thread_and_join.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        template<typename F0, ..., typename Fn-1>
        void conc_join_all(F0 f0, ..., Fn fn-1);
        template<typename F0, ..., typename Fn-1>
        bool conc_join_all_until(const system_time& wait_until, F0 f0, ..., Fn fn-1);
        template<typename TimeDuration, typename F0, ..., typename Fn-1>
        bool conc_join_all_for(TimeDuration wait_for, F0 f0, ..., Fn fn-1);

        template<typename F0, ..., typename Fn-1>
        std::size_t conc_join_any(F0 f0, ..., Fn fn-1);
        template<typename F0, ..., typename Fn-1>
        std::pair<bool,std::size_t> conc_join_any_until(
                const system_time& wait_until, F0 f0, ..., Fn fn-1);
        template<typename TimeDuration, typename F0, ..., typename Fn-1>
        std::pair<bool,std::size_t> conc_join_all_for(
                TimeDuration wait_for, F0 f0, ..., Fn fn-1);
    }
    }



[section:conc_join_all Non Member Function `conc_join_all()`]
[/==========================================================================================]

    template<typename F0, ..., typename Fn-1>
    void conc_join_all(F0 f0, ..., Fn fn-1);

[variablelist

[[Effects:] [launch in each function on a thread of execution and join all.]]

]

[endsect]

[section:conc_join_all_until Non Member Function `conc_join_all_until()`]
[/==========================================================================================]

    template<typename F0, ..., typename Fn-1>
    bool conc_join_all_until(const system_time& wait_until, F0 f0, ..., Fn fn-1);

[variablelist

[[Effects:] [launch each function on a thread of execution and join all until a given time or duration if not interrup all.]]
[[Returns:] [true if joined.]]

]

[endsect]

[section:conc_join_all_for Non Member Function `conc_join_all_for()`]
[/==========================================================================================]

    template<typename TimeDuration, typename F0, ..., typename Fn-1>
    bool conc_join_all_for(TimeDuration wait_for, F0 f0, ..., Fn fn-1);

[variablelist

[[Effects:] [launch each function on a thread of execution and join all until a given time or duration if not interrup all.]]
[[Returns:] [true if joined.]]

]

[endsect]

        template<typename F0, ..., typename Fn-1>
        std::size_t conc_join_any(F0 f0, ..., Fn fn-1);
        template<typename F0, ..., typename Fn-1>
        std::pair<bool,std::size_t> conc_join_any_until(
                const system_time& wait_until, F0 f0, ..., Fn fn-1);
        template<typename TimeDuration, typename F0, ..., typename Fn-1>
        std::pair<bool,std::size_t> conc_join_all_for(
                TimeDuration wait_for, F0 f0, ..., Fn fn-1);

[section:conc_join_any Non Member Function `conc_join_any()`]
[/==========================================================================================]

    template<typename F0, ..., typename Fn-1>
    std::size_t conc_join_any(F0 f0, ..., Fn fn-1);

[variablelist

[[Effects:] [launch in each function on a thread of execution, join the first and then interrupt the others.]]
[[Returns:] [the index on the tuple of the first thread joined.]]

]

[endsect]

[section:conc_join_any_until Non Member Function `conc_join_any_until()`]
[/==========================================================================================]

    template<typename F0, ..., typename Fn-1>
    std::pair<bool,std::size_t> conc_join_any_until(
            const system_time& wait_until, F0 f0, ..., Fn fn-1);

[variablelist

[[Effects:] [launch in each function on a thread of execution, join the first and then interrupt the others or interrup all.]]
[[Returns:] [a pair consisting of a boolean stating if the a thread has been joined before the given time and the index on the tuple of the first thread joined.]]

]

[endsect]

[section:conc_join_any_for Non Member Function `conc_join_any_for()`]
[/==========================================================================================]

    template<typename TimeDuration, typename F0, ..., typename Fn-1>
    std::pair<bool,std::size_t> conc_join_any_for(
            TimeDuration wait_for, F0 f0, ..., Fn fn-1);

[variablelist

[[Effects:] [launch in each function on a thread of execution, join the first and then interrupt the others or interrup all.]]
[[Returns:] [a pair consisting of a boolean stating if the a thread has been joined before the given time and the index on the tuple of the first thread joined.]]

]

[endsect]


[endsect]

[section:thread_group_once_hpp Header `<boost/interthreads/thread_group_once.hpp>`]
[/==========================================================================================]

    namespace boost {
    namespace interthreads {

        template <std::size_t  N>
        class thread_group;

    }
    }


[section:thread_group_once_class Template Class `thread_group_once<>`]
[/==========================================================================================]

`thread_group_once<>` is an extension of the boost::thread_group which allows to join the thread finishing 
the first, using for that the set_once synchronizer.

    template <std::size_t  n>
    class thread_group_once {
    public:
    	thread_group_once();
        ~thread_group_once();
        
        template<typename F>
        thread* create_thread(F threadfunc);
        void remove_thread(thread* thrd);

        // move support
        thread_group_once(boost::move_t<thread_group_once<n>> x);
        thread_group_once& operator=(boost::move_t<thread_group_once<n>> x);
        operator boost::move_t<thread_group_once<n>>();
        boost::move_t<thread_group_once<n>> move();

        void swap(thread_group_once<n>& x);

        bool joinables() const;
        
        void join_all();
        bool join_all_until(const system_time& wait_until);
        template<typename TimeDuration>
        bool join_all_for(TimeDuration const& rel_time);

        std::size_t join_any();
        std::pair<bool,std::size_t> join_any_until(
            const system_time& wait_until);
        template<typename TimeDuration>
        std::pair<bool,std::size_t> join_any_for(
            TimeDuration const& rel_time);

        void detach_all();

        void interrupt_all();
        bool interruption_requested() const;

        size_t size();
        
        const thread& operator[](std::size_t i);
    };    
    }
    }


[section:thread_group_once_callable_constructor Constructor]
[/==========================================================================================]

    thread_group_once();

[variablelist


[[Effects:] [creates a thread group.]]

[[Postconditions:] [`*this` refers to the newly created group of threads of execution.]]

[[Throws:] [__thread_resource_error__ if an error occurs.]]

]

[endsect]


[section:thread_group_once_destructor Destructor]
[/==========================================================================================]

    ~thread_group_once();

[variablelist

[[Effects:] [If *this  have associateds thread of execution, calls detach() on them. Destroys *this.]]

]

[endsect]

[section:thread_group_once_joinable Member function `joinables()`]
[/==========================================================================================]

    bool joinables() const;

[variablelist

[[Returns:] [`true` if `*this` refers to threads of execution, `false` otherwise.]]

[[Throws:] [Nothing]]

]

[endsect]

[section:thread_group_once_join Member function `join_all()`]
[/==========================================================================================]

    void join_all();

[variablelist

[[Effects:] [Call `join()` on each __thread__ object in the group.]]

[[Postcondition:] [Every thread in the group has terminated.]]

[[Throws:] [Nothing]]

[[Note:] [Since `boost::thread::join` is one of the predefined interruption points, `thread_group_once<>::join_all()` is also an interruption point.]]

]

[endsect]

[section:thread_group_once_timed_join Member function `join_all_until()`]
[/==========================================================================================]

    bool join_all_until(const system_time& wait_until);
    template<typename TimeDuration>
    bool join_all_for(TimeDuration const& rel_time);

[variablelist

[[Effects:] [Call `timed_join()` on each __thread__ object in the group.]]

[[Postcondition:] [Every thread in the group has terminated.]]

[[Returns:] [true if joined.]]

[[Throws:] [Nothing]]

[[Note:] [Since `boost::thread::timed_join` is one of the predefined interruption points, `thread_group_once<>::timed_join_all()` is also an interruption point.]]

]

[endsect]

[section:join_first_then_interrupt Member function `join_any()`]
[/==========================================================================================]

    std::size_t join_any();

[variablelist

[[Effects:] [Call `join_any()` and the `interrup_all()`.]]

[[Postcondition:] [Every thread in the group has terminated.]]

[[Throws:] [Nothing]]

[[Note:] [Since `join_any` is one of the predefined interruption points, `thread_group_once<>::join_any()` is also an interruption point.]]

]

[endsect]

[section:timed_join_first_then_interrupt Member function `join_any_until()`]
[/==========================================================================================]

    std::pair<bool,std::size_t> join_any_until(
            const system_time& wait_until);
    template<typename TimeDuration>
    std::pair<bool,std::size_t> join_any_for(
            TimeDuration const& rel_time);

[variablelist

[[Effects:] [Call `get_until()` and the `interrup_all()`.]]

[[Postcondition:] [Every thread in the group has terminated.]]

[[Returns:] [true if joined.]]

[[Throws:] [Nothing]]

[[Note:] [Since `boost::thread::timed_join` is one of the predefined interruption points, `thread_group_once<>::timed_join_all()` is also an interruption point.]]

]

[endsect]

[section:detach_all Member function `detach_all()`]
[/==========================================================================================]

    void detach_all();

[variablelist

[[Effects:] [Call `detach()` on each __thread__ object in the group.]]

]

[endsect]

[section Member function `interrupt_all()`]
[/==========================================================================================]

    void interrupt_all();

[variablelist

[[Effects:] [Call `thread::interrupt()` on each __thread__ object in the group.]]

]

[endsect]

[section:thread_group_once_size Member function `size()`]
[/==========================================================================================]

    int size();

[variablelist

[[Returns:] [The number of threads in the group.]]

[[Throws:] [Nothing.]]

]

[endsect]

[endsect]

[section:thread_group_once_make_thread_group_once Non Member Function `make_thread_group_once()`]
[/==========================================================================================]

    template<typename F0, ..., typename Fn-1>
    thread_group_once make_thread_group_once(F0 f0, ..., Fn fn-1);

[variablelist

[[Effects:] [makes a new thread_group_once<>.]]
[[Returns:] [the created thread group.]]


]

[endsect]

[endsect]


[endsect]
