[/
  (C) Copyright 2008-2009 Vicente J. Botet Escriba
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[/==========================================================================================]
[section:has_exception_hpp Header `<boost/interthreads/algorithm/has_exception.hpp>`]
[/==========================================================================================]

Defines a free function __has_exception__ which states if __ACT__ passed as parameter has an exception.
The default implementation applies the __has_exception__ member function to the __ACT__. A user adapting another __ACT__ could need 
to specialize the __has_exception__ free function if the __ACT__ do not provides a has_exception function with the same prototype.

As for the moment we can not partially specialize a function a trick is used: instead of calling directly to the __has_exception__ 
member function __has_exception__ calls to the static operation __apply__ on a class with the same name in the namespace __partial_specialization_workaround__. 
So the user can specialize partially this class.

The template parameter ACT must be a model of __FutureBasedACT__.

    namespace boost { namespace interthreads {
      
    namespace fct {
        struct has_exception {
            typedef bool result_type;
            template<typename ACT> bool operator()(ACT& act) const;
        };
    }

    namespace result_of {
        template <typename Sequence> struct have_all_exception {
            typedef typename fusion::result_of::all<Sequence, fct::has_exception>::type type;
        };
    }

    template <typename Sequence> bool have_all_exception(Sequence& t);

    }}

[endsect]

