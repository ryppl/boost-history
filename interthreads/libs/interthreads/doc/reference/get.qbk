[/
  (C) Copyright 2008-2009 Vicente J. Botet Escriba
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[/==========================================================================================]
[section:get_hpp Header `<boost/interthreads/algorithm/get.hpp>`]
[/==========================================================================================]

Defines a free function __get__ which obtain the stored value on the __ACT__ passed as parameter.
The default implementation applies the __get__ member function to the __ACT__. A user adapting another __ACT__ could need 
to specialize the __get__ free function if the __ACT__ do not provides a get function with the same prototype.
As for the moment we can not partially specialize a function a trick is used: instead of calling directly to the __get__ 
member function __get__ calls to the static operation __apply__ on a class with the same name in the namespace __partial_specialization_workaround__. 
So the user can specialize partially this class.

The template parameter ACT must be a model of __FutureBasedACT__.


    namespace boost { namespace interthreads {
        namespace result_of {
            template <typename ACT> struct get {
                typedef typename act_traits<ACT>::move_dest_type type;
            };
        }

        namespace partial_specialization_workaround {
            template <typename ACT> struct get {
                static typename result_of::get<ACT>::type apply( ACT& act );
            };
        }

        template <typename ACT>
        typename boost::enable_if<has_future_if<ACT>,
            typename result_of::template get<ACT>::type
        >::type
        get(ACT& act);
    }}

[section Metafunction `result_of::get<ACT> `]
[/==========================================================================================]

A metafunction returning the result type of applying get to an __ACT__.

        namespace result_of {
            template <typename ACT> struct get {
                typedef typename act_traits<ACT>::move_dest_type type;
            };
        }

[table get Parameters
    [
        [[*Parameter]]
        [[*Requirement]]
        [[*Description]]
    ]
    [
        [`ACT`]
        [An __ACT__]
        [Operation's argument ]
    ]
]

[variablelist
[[Expression:] [`result_of::get<S>::type`]]
[[Returns:] [Depending on the nature of the ACT returns a `act_traits<ACT>::move_dest_type`.]]
]

[endsect]

[section Static Member Function `partial_specialization_workaround::get<>::apply()`]
[/==========================================================================================]

The default implementation applies the 'get()' member function on the __ACT__.

        namespace partial_specialization_workaround {
            template <typename ACT> struct get {
                static typename result_of::get<ACT>::type apply( ACT& act );
            };
        }

[endsect]

[section Non member function `get()`]
[/==========================================================================================]

        template <typename ACT>
        typename boost::enable_if<has_future_if<ACT>,
            typename result_of::template get<ACT>::type
        >::type
        get(ACT& act);


[variablelist
[[Returns:] [a fusion tuple of the result of applying `get` to each one of the asynchronous completion token handles in the sequence.]]
[[Effect:] [Blocks until all the ACT  handles in the Sequence are ready.]]
[[Throws:] [if some of the  ACT::get operation throws]]
]

[endsect]

[endsect]

