<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pool: boost::pool&lt; UserAllocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Pool</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>boost</b>      </li>
      <li class="navelem"><a class="el" href="classboost_1_1pool.html">pool</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<h1>boost::pool&lt; UserAllocator &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="boost::pool" --><!-- doxytag: inherits="simple_segregated_storage&lt; UserAllocator::size_type &gt;" -->
<p>A fast memory allocator that guarantees proper alignment of all allocated chunks.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pool_8hpp_source.html">pool.hpp</a>&gt;</code></p>

<p>Inherits <a class="el" href="classboost_1_1simple__segregated__storage.html">simple_segregated_storage&lt; UserAllocator::size_type &gt;</a>.</p>

<p>Inherited by <a class="el" href="classboost_1_1object__pool.html">boost::object_pool&lt; T, UserAllocator &gt;</a><code> [protected]</code>.</p>

<p><a href="classboost_1_1pool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace00756a399746d2a8469bb0e322ae3b"></a><!-- doxytag: member="boost::pool::user_allocator" ref="ace00756a399746d2a8469bb0e322ae3b" args="" -->
typedef UserAllocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#ace00756a399746d2a8469bb0e322ae3b">user_allocator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">User allocator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bbc458e2cf4cd4c69a2f9ac41966096"></a><!-- doxytag: member="boost::pool::size_type" ref="a8bbc458e2cf4cd4c69a2f9ac41966096" args="" -->
typedef UserAllocator::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integral type that can represent the size of the largest object to be allocated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a03aa4f147ed0e91134909fc8f999cb"></a><!-- doxytag: member="boost::pool::difference_type" ref="a4a03aa4f147ed0e91134909fc8f999cb" args="" -->
typedef <br class="typebreak"/>
UserAllocator::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a4a03aa4f147ed0e91134909fc8f999cb">difference_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integral type that can represent the difference of any two pointers. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#ad7c9846bf121da66fffed34983b4768c">pool</a> (const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> nrequested_size, const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> nnext_size=32, const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> nmax_size=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a60752fe8cccb8fe989abe2e72c91c311">~pool</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a1132035ce513c0ff2659d1b7c7575c17">release_memory</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a0ce9152982cbc7708f67448f8bd65fb4">purge_memory</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a0f4fc7516624b32462381671364ff96b">get_next_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a848bb66044817b4a4ee0fd80a5cc5d6e">set_next_size</a> (const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> nnext_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#ae4b98e9cd5cde8246ee2c6f71b4b015d">get_max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a6fa26b3d49451c16d2235d56430aef50">set_max_size</a> (const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> nmax_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a91b5165b6aff376368ca2705760d0099">get_requested_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *malloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#ae5b00b2735c05de4351a00a055de152f">BOOST_PREVENT_MACRO_SUBSTITUTION</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a8abcdbbf3c757e1505f90f7d971b227a">ordered_malloc</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a5944c78bdc6847943051466b1545d1f3">ordered_malloc</a> (<a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void free&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a58f304bdcfb8de726b0fcf2fe8cbb6ef">BOOST_PREVENT_MACRO_SUBSTITUTION</a> (void *const chunk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#aca402414a3920eb67d800b2c38581533">ordered_free</a> (void *const chunk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void free&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a24de1cdb6d19e23a7ed04fd9d926d685">BOOST_PREVENT_MACRO_SUBSTITUTION</a> (void *const chunks, const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a3afd0962c8693316db536fd817918105">ordered_free</a> (void *const chunks, const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#ad9bf6f7d3b6d51af571406d3ec88d6a7">is_from</a> (void *const chunk) const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1simple__segregated__storage.html">simple_segregated_storage</a><br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#ad72819c9c7be56b774cd9cc149a466ea">store</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <br class="typebreak"/>
<a class="el" href="classboost_1_1simple__segregated__storage.html">simple_segregated_storage</a><br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a476403a52a6901ac59e9e6c955563911">store</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1details_1_1_p_o_dptr.html">details::PODptr</a>&lt; <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#adefaf328f441bbcb66569515261608dd">find_POD</a> (void *const chunk) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">finds which POD in the list 'chunk' was allocated from.  <a href="#adefaf328f441bbcb66569515261608dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#add482dea75ef2a2719927497188ac2f1">alloc_size</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a9742ecb2b7c3e2d3a6037b7885515be1">is_from</a> (void *const chunk, char *const i, const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> sizeof_i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#ad7136ea79d9dcaecaf46ecddb15ac04a">nextof</a> (void *const ptr)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1details_1_1_p_o_dptr.html">details::PODptr</a>&lt; <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a0938006ac5341b1df8fbc15a43fc415c">list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called if ordered_malloc needs to resize the free list.  <a href="#a0938006ac5341b1df8fbc15a43fc415c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad72793b1d256fdd1ef69eda8bac01c3d"></a><!-- doxytag: member="boost::pool::requested_size" ref="ad72793b1d256fdd1ef69eda8bac01c3d" args="" -->
const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>requested_size</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afccfe7c5e7d62175809bff1cf34b3ca6"></a><!-- doxytag: member="boost::pool::next_size" ref="afccfe7c5e7d62175809bff1cf34b3ca6" args="" -->
<a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>next_size</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d9516aac4995c3d7b90af4fe68c1726"></a><!-- doxytag: member="boost::pool::start_size" ref="a6d9516aac4995c3d7b90af4fe68c1726" args="" -->
<a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>start_size</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af04c3db2aad11a6b68fccfcdfbcca62d"></a><!-- doxytag: member="boost::pool::max_size" ref="af04c3db2aad11a6b68fccfcdfbcca62d" args="" -->
<a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51ea0593517e3a6f0259dc98834c1d21"></a><!-- doxytag: member="boost::pool::BOOST_STATIC_CONSTANT" ref="a51ea0593517e3a6f0259dc98834c1d21" args="(unsigned, min_alloc_size=(::boost::details::pool::ct_lcm&lt; sizeof(void *), sizeof(size_type)&gt;::value))" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_STATIC_CONSTANT</b> (unsigned, min_alloc_size=(::boost::details::pool::ct_lcm&lt; sizeof(void *), sizeof(<a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>)&gt;::value))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8741825fa2a144416d4fa9f30e1cd570"></a><!-- doxytag: member="boost::pool::BOOST_STATIC_CONSTANT" ref="a8741825fa2a144416d4fa9f30e1cd570" args="(unsigned, min_align=(::boost::details::pool::ct_lcm&lt; ::boost::alignment_of&lt; void * &gt;::value,::boost::alignment_of&lt; size_type &gt;::value &gt;::value))" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_STATIC_CONSTANT</b> (unsigned, min_align=(::boost::details::pool::ct_lcm&lt; ::boost::alignment_of&lt; void * &gt;::value,::boost::alignment_of&lt; <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> &gt;::value &gt;::value))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#aa28e378d455b528da508198c9bbb46fd">malloc_need_resize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1pool.html#a4126578d7378dd66ff35928748d9cc2a">ordered_malloc_need_resize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called if malloc needs to resize the free list.  <a href="#a4126578d7378dd66ff35928748d9cc2a"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename UserAllocator&gt;<br/>
 class boost::pool&lt; UserAllocator &gt;</h3>

<p>A fast memory allocator that guarantees proper alignment of all allocated chunks. </p>
<p>Whenever an object of type pool needs memory from the system, it will request it from its UserAllocator template parameter. The amount requested is determined using a doubling algorithm; that is, each time more system memory is allocated, the amount of system memory requested is doubled.</p>
<p>Users may control the doubling algorithm by using the following extensions.</p>
<p>Users may pass an additional constructor parameter to pool. This parameter is of type size_type, and is the number of chunks to request from the system the first time that object needs to allocate system memory. The default is 32. This parameter may not be 0.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">UserAllocator</td><td>type - the method that the Pool will use to allocate memory from the system. </td></tr>
  </table>
  </dd>
</dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad7c9846bf121da66fffed34983b4768c"></a><!-- doxytag: member="boost::pool::pool" ref="ad7c9846bf121da66fffed34983b4768c" args="(const size_type nrequested_size, const size_type nnext_size=32, const size_type nmax_size=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::<a class="el" href="classboost_1_1pool.html">pool</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td>
          <td class="paramname"><em>nrequested_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td>
          <td class="paramname"><em>nnext_size</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td>
          <td class="paramname"><em>nmax_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Constructs a new empty Pool that can be used to allocate chunks of size RequestedSize. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nrequested_size</td><td>Requested chunk size </td></tr>
    <tr><td class="paramname">nnext_size</td><td>parameter is of type size_type, is the number of chunks to request from the system the first time that object needs to allocate system memory. The default is 32. This parameter may not be 0. </td></tr>
    <tr><td class="paramname">nmax_size</td><td>is the maximum size of ? </td></tr>
  </table>
  </dd>
</dl>
</p>

</div>
</div>
<a class="anchor" id="a60752fe8cccb8fe989abe2e72c91c311"></a><!-- doxytag: member="boost::pool::~pool" ref="a60752fe8cccb8fe989abe2e72c91c311" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::~<a class="el" href="classboost_1_1pool.html">pool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Destructs the Pool, freeing its list of memory blocks. </p>
</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="add482dea75ef2a2719927497188ac2f1"></a><!-- doxytag: member="boost::pool::alloc_size" ref="add482dea75ef2a2719927497188ac2f1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::alloc_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Calculated size of the memory chunks that will be allocated by this Pool. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>allocated size. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ae5b00b2735c05de4351a00a055de152f"></a><!-- doxytag: member="boost::pool::BOOST_PREVENT_MACRO_SUBSTITUTION" ref="ae5b00b2735c05de4351a00a055de152f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* malloc <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::BOOST_PREVENT_MACRO_SUBSTITUTION </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Allocates a chunk of memory. Searches in the list of memory blocks for a block that has a free chunk, and returns that free chunk if found. Otherwise, creates a new memory block, adds its free list to pool's free list, </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a free chunk from that block. If a new memory block cannot be allocated, returns 0. Amortized O(1). </dd></dl>
</p>

<p>Reimplemented from <a class="el" href="classboost_1_1simple__segregated__storage.html#a5a5b9008fd096766c637b8c4d26b8196">boost::simple_segregated_storage&lt; UserAllocator::size_type &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classboost_1_1object__pool.html#af3dc86af829e49737654ed01e5431be8">boost::object_pool&lt; T, UserAllocator &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a58f304bdcfb8de726b0fcf2fe8cbb6ef"></a><!-- doxytag: member="boost::pool::BOOST_PREVENT_MACRO_SUBSTITUTION" ref="a58f304bdcfb8de726b0fcf2fe8cbb6ef" args="(void *const chunk)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void free <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::BOOST_PREVENT_MACRO_SUBSTITUTION </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as malloc, only allocates enough contiguous chunks to cover n * requested_size bytes. Amortized O(n). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a free chunk from that block. If a new memory block cannot be allocated, returns 0. Amortized O(1). </dd></dl>

<p><p>Deallocates a chunk of memory. Note that chunk may not be 0. O(1). chunk must have been previously returned by t.malloc() or t.ordered_malloc(). Assumes that chunk actually refers to a block of chunks spanning n * partition_sz bytes. deallocates each chunk in that block. Note that chunk may not be 0. O(n). </p>
</p>

<p>Reimplemented from <a class="el" href="classboost_1_1simple__segregated__storage.html#acacb4cda590af9877b8ecaa96ca1f51f">boost::simple_segregated_storage&lt; UserAllocator::size_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a24de1cdb6d19e23a7ed04fd9d926d685"></a><!-- doxytag: member="boost::pool::BOOST_PREVENT_MACRO_SUBSTITUTION" ref="a24de1cdb6d19e23a7ed04fd9d926d685" args="(void *const chunks, const size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void free <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::BOOST_PREVENT_MACRO_SUBSTITUTION </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Assumes that chunk actually refers to a block of chunks. chunk must have been previously returned by t.ordered_malloc(n) spanning n * partition_sz bytes. Deallocates each chunk in that block. Note that chunk may not be 0. O(n). </p>
</p>

</div>
</div>
<a class="anchor" id="adefaf328f441bbcb66569515261608dd"></a><!-- doxytag: member="boost::pool::find_POD" ref="adefaf328f441bbcb66569515261608dd" args="(void *const chunk) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1details_1_1_p_o_dptr.html">details::PODptr</a>&lt; typename <a class="el" href="classboost_1_1pool.html">pool</a>&lt; UserAllocator &gt;::<a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> &gt; <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::find_POD </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>finds which POD in the list 'chunk' was allocated from. </p>

<p><p>find which PODptr storage memory that this chunk is from. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the PODptr that holds this chunk. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ae4b98e9cd5cde8246ee2c6f71b4b015d"></a><!-- doxytag: member="boost::pool::get_max_size" ref="ae4b98e9cd5cde8246ee2c6f71b4b015d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::get_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><dl class="return"><dt><b>Returns:</b></dt><dd>max_size. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="a0f4fc7516624b32462381671364ff96b"></a><!-- doxytag: member="boost::pool::get_next_size" ref="a0f4fc7516624b32462381671364ff96b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::get_next_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Number of chunks to request from the system the next time that object needs to allocate system memory. This value should never be 0. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>next_size; </dd></dl>
</p>

<p>Reimplemented in <a class="el" href="classboost_1_1object__pool.html#a8d81465e9a16c867eb391af95dd46a73">boost::object_pool&lt; T, UserAllocator &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a91b5165b6aff376368ca2705760d0099"></a><!-- doxytag: member="boost::pool::get_requested_size" ref="a91b5165b6aff376368ca2705760d0099" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a> <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::get_requested_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><dl class="return"><dt><b>Returns:</b></dt><dd>the requested size passed into the constructor. (This value will not change during the lifetime of a Pool object). </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="a9742ecb2b7c3e2d3a6037b7885515be1"></a><!-- doxytag: member="boost::pool::is_from" ref="a9742ecb2b7c3e2d3a6037b7885515be1" args="(void *const chunk, char *const i, const size_type sizeof_i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::is_from </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td>
          <td class="paramname"><em>sizeof_i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>to check if is from this pool. </td></tr>
    <tr><td class="paramname">i</td><td>memory chunk at i with element sizeof_i. </td></tr>
    <tr><td class="paramname">sizeof_i</td><td>element size (size of the chunk area of that block, not the total size of that block). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if chunk was allocated or may be returned as the result of a future allocation. Returns false if chunk was allocated from some other pool, or may be returned as the result of a future allocation from some other pool. Otherwise, the return value is meaningless. Note that this function may NOT be used to reliably test random pointer values.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>We use std::less_equal and std::less to test 'chunk' against the array bounds because standard operators may return unspecified results. This is to ensure portability.<br/>
 The operators &lt; &lt;= &gt; &gt;= are only defined for pointers to objects that are 1) in the same array, or 2) subobjects of the same object [5.9/2]. The functor objects guarantee a total order for any pointer [20.3.3/8]</dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ad9bf6f7d3b6d51af571406d3ec88d6a7"></a><!-- doxytag: member="boost::pool::is_from" ref="ad9bf6f7d3b6d51af571406d3ec88d6a7" args="(void *const chunk) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::is_from </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if chunk was allocated from u or may be returned as the result of a future allocation from u. Returns false if chunk was allocated from some other pool or may be returned as the result of a future allocation from some other pool. Otherwise, the return value is meaningless. Note that this function may not be used to reliably test random pointer values. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="aa28e378d455b528da508198c9bbb46fd"></a><!-- doxytag: member="boost::pool::malloc_need_resize" ref="aa28e378d455b528da508198c9bbb46fd" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::malloc_need_resize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if out-of-memory. Called if malloc/ordered_malloc needs to resize the free list.</dd></dl>
<p>No memory in any of our storages; make a new storage. Allocate chunk in newly malloc memory after resize. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to just allocated chunk. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7136ea79d9dcaecaf46ecddb15ac04a"></a><!-- doxytag: member="boost::pool::nextof" ref="ad7136ea79d9dcaecaf46ecddb15ac04a" args="(void *const ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void* &amp; <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::nextof </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td><code> [inline, static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><dl class="return"><dt><b>Returns:</b></dt><dd>Pointer dereferenced. (Provided and used for the sake of code readability :) </dd></dl>
</p>

<p>Reimplemented from <a class="el" href="classboost_1_1simple__segregated__storage.html#a4b9d0bcd52bafc1193a605276e68099f">boost::simple_segregated_storage&lt; UserAllocator::size_type &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classboost_1_1object__pool.html#a996dd86fc643d5ca45067283945ccbb8">boost::object_pool&lt; T, UserAllocator &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aca402414a3920eb67d800b2c38581533"></a><!-- doxytag: member="boost::pool::ordered_free" ref="aca402414a3920eb67d800b2c38581533" args="(void *const chunk)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::ordered_free </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Same as above, but is order-preserving. Note that chunk may not be 0. O(N) with respect to the size of the free list. chunk must have been previously returned by t.malloc() or t.ordered_malloc(). </p>
</p>

<p>Reimplemented from <a class="el" href="classboost_1_1simple__segregated__storage.html#a33fac301f6a81b169d5bc70ebd7827f6">boost::simple_segregated_storage&lt; UserAllocator::size_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3afd0962c8693316db536fd817918105"></a><!-- doxytag: member="boost::pool::ordered_free" ref="a3afd0962c8693316db536fd817918105" args="(void *const chunks, const size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::ordered_free </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Assumes that chunk actually refers to a block of chunks spanning n * partition_sz bytes; deallocates each chunk in that block. Note that chunk may not be 0. Order-preserving. O(N + n) where N is the size of the free list. chunk must have been previously returned by t.malloc() or t.ordered_malloc(). </p>
</p>

</div>
</div>
<a class="anchor" id="a5944c78bdc6847943051466b1545d1f3"></a><!-- doxytag: member="boost::pool::ordered_malloc" ref="a5944c78bdc6847943051466b1545d1f3" args="(size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::ordered_malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Gets address of a chunk n, allocating new memory if not already available. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Address of chunk n if allocated ok. </dd>
<dd>
0 if not enough memory for n chunks. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="a8abcdbbf3c757e1505f90f7d971b227a"></a><!-- doxytag: member="boost::pool::ordered_malloc" ref="a8abcdbbf3c757e1505f90f7d971b227a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::ordered_malloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Same as malloc, only merges the free lists, to preserve order. Amortized O(1). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a free chunk from that block. If a new memory block cannot be allocated, returns 0. Amortized O(1). </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="a4126578d7378dd66ff35928748d9cc2a"></a><!-- doxytag: member="boost::pool::ordered_malloc_need_resize" ref="a4126578d7378dd66ff35928748d9cc2a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::ordered_malloc_need_resize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called if malloc needs to resize the free list. </p>

<p><p>No memory in any of our storages; make a new storage. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to new chunk. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="a0ce9152982cbc7708f67448f8bd65fb4"></a><!-- doxytag: member="boost::pool::purge_memory" ref="a0ce9152982cbc7708f67448f8bd65fb4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::purge_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>pool must be ordered. Frees every memory block. This function invalidates any pointers previously returned by allocation functions of t. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least one memory block was freed. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="a1132035ce513c0ff2659d1b7c7575c17"></a><!-- doxytag: member="boost::pool::release_memory" ref="a1132035ce513c0ff2659d1b7c7575c17" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::release_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>pool must be ordered. Frees every memory block that doesn't have any allocated chunks. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least one memory block was freed. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="a6fa26b3d49451c16d2235d56430aef50"></a><!-- doxytag: member="boost::pool::set_max_size" ref="a6fa26b3d49451c16d2235d56430aef50" args="(const size_type nmax_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::set_max_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td>
          <td class="paramname"><em>nmax_size</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Set max_size. </p>
</p>

</div>
</div>
<a class="anchor" id="a848bb66044817b4a4ee0fd80a5cc5d6e"></a><!-- doxytag: member="boost::pool::set_next_size" ref="a848bb66044817b4a4ee0fd80a5cc5d6e" args="(const size_type nnext_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::set_next_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&#160;</td>
          <td class="paramname"><em>nnext_size</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>Set number of chunks to request from the system the next time that object needs to allocate system memory. This value should never be set to 0. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>nnext_size. </dd></dl>
</p>

<p>Reimplemented in <a class="el" href="classboost_1_1object__pool.html#a74a501bb377ec5ccc18da2b39ed233f7">boost::object_pool&lt; T, UserAllocator &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad72819c9c7be56b774cd9cc149a466ea"></a><!-- doxytag: member="boost::pool::store" ref="ad72819c9c7be56b774cd9cc149a466ea" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1simple__segregated__storage.html">simple_segregated_storage</a>&lt;<a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&gt;&amp; <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::store </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><dl class="return"><dt><b>Returns:</b></dt><dd>pointer to store. </dd></dl>
</p>

<p>Reimplemented in <a class="el" href="classboost_1_1object__pool.html#a428836e73952898736c6e6e018e361a5">boost::object_pool&lt; T, UserAllocator &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a476403a52a6901ac59e9e6c955563911"></a><!-- doxytag: member="boost::pool::store" ref="a476403a52a6901ac59e9e6c955563911" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1simple__segregated__storage.html">simple_segregated_storage</a>&lt;<a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&gt;&amp; <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::store </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><dl class="return"><dt><b>Returns:</b></dt><dd>pointer to store. </dd></dl>
</p>

<p>Reimplemented in <a class="el" href="classboost_1_1object__pool.html#a830377f43088fcaab8e307a9f220b3f2">boost::object_pool&lt; T, UserAllocator &gt;</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a0938006ac5341b1df8fbc15a43fc415c"></a><!-- doxytag: member="boost::pool::list" ref="a0938006ac5341b1df8fbc15a43fc415c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserAllocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1details_1_1_p_o_dptr.html">details::PODptr</a>&lt;<a class="el" href="classboost_1_1pool.html#a8bbc458e2cf4cd4c69a2f9ac41966096">size_type</a>&gt; <a class="el" href="classboost_1_1pool.html">boost::pool</a>&lt; UserAllocator &gt;::<a class="el" href="classboost_1_1pool.html#a0938006ac5341b1df8fbc15a43fc415c">list</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called if ordered_malloc needs to resize the free list. </p>
<p>List structure holding ordered blocks. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>I:/boost-sandbox/guild/pool/boost/pool/<a class="el" href="pool_8hpp_source.html">pool.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Feb 25 2011 15:44:50 for Pool by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
