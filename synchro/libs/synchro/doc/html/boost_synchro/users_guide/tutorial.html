<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title> Tutorial</title>
<link rel="stylesheet" href="../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="../../index.html" title="Chapter 1. Boost.Synchro">
<link rel="up" href="../users_guide.html" title=" Users'Guide">
<link rel="prev" href="getting_started.html" title=" Getting Started">
<link rel="next" href="ext_references.html" title=" References">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="getting_started.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../users_guide.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="ext_references.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_synchro.users_guide.tutorial"></a><a href="tutorial.html" title=" Tutorial"> Tutorial</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.lockables">Lockables</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.internal_locking__monitors">Internal
        Locking--Monitors</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.internal_locking__monitors.concurrent_threads_of_execution">Concurrent
          threads of execution</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.internal_locking__monitors.monitors">Monitors</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_"><code class="computeroutput"><span class="keyword">volatile</span> </code> and <code class="computeroutput"><span class="identifier">locking_ptr</span></code></a></span></dt>
<dd><dl>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.just_a_little_keyword">Just
          a Little Keyword</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.using__volatile__with_user_defined_types">Using
          <code class="computeroutput"><span class="keyword">volatile</span></code> with User-Defined
          Types</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._volatile___critical_sections__and_race_conditions"><code class="computeroutput"><span class="keyword">volatile</span></code>, Critical Sections, and Race Conditions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._locking_ptr_"><code class="computeroutput"><span class="identifier">locking_ptr</span></code></a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.back_to_primitive_types">Back
          to Primitive Types</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._volatile__member_functions"><code class="computeroutput"><span class="keyword">volatile</span></code> Member Functions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.generic__locking_ptr_">Generic
          <code class="computeroutput"><span class="identifier">locking_ptr</span></code></a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.specific__locking_ptr__for_lockable_value_types">Specific
          <code class="computeroutput"><span class="identifier">locking_ptr</span></code> for lockable
          value types</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes">External
        Locking -- <code class="computeroutput"><span class="identifier">strict_locker</span></code>
        and <code class="computeroutput"><span class="identifier">externally_locked</span></code> classes</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.locks_as_permits">Locks
          as Permits</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.improving_external_locking">Improving
          External Locking</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.allowing_other_strict_lockers">Allowing
          other strict lockers</a></span></dt>
</dl></dd>
</dl></div>
<p>
        [info The contents of this tutorial is an adaptation of the papers of Andrei
        Alexandrescu, Kevlin Henney and the concurrent part of the BETA Programming
        Language.]
      </p>
<p>
        Concurrent components may interact in different ways: they may access the
        same shared objects by, for example, executing functions of these objects;
        or they may communicate directly by executing functions of each other.
      </p>
<p>
        Concurrent execution of objects requires a mechanism for synchronizing the
        access to shared objects, just as direct communication between objects may
        require synchronization. The basic mechanism for synchronization in Boost.Threads
        and Boost.Interprocess are the well known mutex and condition_variables.
        Mutexes and condition variables are, however, only useful for very simple
        synchronization problems. The Synchro Library therefore introduce high-level
        abstractions for handling more complicated synchronization problems, including
        monitor for guaranteeing exclusive access to an object, controlling external
        locking and last a so-called rendezvous mechanism for handling direct communication
        between objects. All the concurrency abstractions being introduced are defined
        by means of mutexes an conditions.
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_synchro.users_guide.tutorial.lockables"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial.lockables" title="Lockables">Lockables</a>
</h4></div></div></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            The following is an adaptation of the article "C++ Threading - A
            Generic-Programming Approach" by Kevin Henney.
          </p></td></tr>
</table></div>
<p>
          <span class="bold"><strong>Lock substitutability</strong></span>
        </p>
<p>
          The Boost (C++0x) mutexes have associated a category which form a sub-typing
          hierarchy: ExclusiveLock &lt;- SharableLock &lt;- UpgradableLock
        </p>
<pre class="programlisting"><span class="identifier">exclusive_lock</span> <span class="special">&lt;-</span> <span class="identifier">sharable_lock</span> <span class="special">&lt;-</span> <span class="identifier">upgradable_lock</span>
</pre>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">exclusive_lock_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">sharable_lock_tag</span> <span class="special">:</span> <span class="identifier">exclusive_lock_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">upgradable_lock_tag</span> <span class="special">:</span> <span class="identifier">sharable_lock_tag</span>  <span class="special">{};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Locking behavior can be further categorized as:
        </p>
<div class="itemizedlist"><ul type="disc"><li>
            Re-entrancy: recursive or not
          </li></ul></div>
<pre class="programlisting"><span class="identifier">non_recursive</span> <span class="special">&lt;-</span> <span class="identifier">recursive</span>
</pre>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">non_recursive_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">recursive_tag</span> <span class="special">:</span> <span class="identifier">non_recursive_tag</span> <span class="special">{};</span>
</pre>
<p>
          </p>
<p>
        </p>
<div class="itemizedlist"><ul type="disc"><li>
            Scope: whether the lock is usable with a mono-threaded, multi-threaded
            or multi-process context
          </li></ul></div>
<pre class="programlisting"><span class="identifier">mono_threaded</span> <span class="special">&lt;-</span> <span class="identifier">multi_threaded</span> <span class="special">&lt;-</span> <span class="identifier">multi_process</span>
</pre>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">mono_threaded_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">multi_threaded_tag</span> <span class="special">:</span> <span class="identifier">mono_threaded_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">multi_process_tag</span> <span class="special">:</span> <span class="identifier">multi_threaded_tag</span>  <span class="special">{};</span>
</pre>
<p>
          </p>
<p>
        </p>
<div class="itemizedlist"><ul type="disc"><li>
            Lifetime: The lifetime of a lock could be associated to the process,
            the kernel or the file-system
          </li></ul></div>
<pre class="programlisting"><span class="identifier">process_lifetime</span> <span class="special">&lt;-</span> <span class="identifier">kernel_lifetime</span> <span class="special">&lt;-</span> <span class="identifier">filesystem_lifetime</span>
</pre>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">process_lifetime_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">kernel_lifetime_tag</span> <span class="special">:</span> <span class="identifier">process_lifetime_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">filesystem_lifetime_tag</span> <span class="special">:</span> <span class="identifier">kernel_lifetime_tag</span> <span class="special">{};</span>
</pre>
<p>
          </p>
<p>
        </p>
<div class="itemizedlist"><ul type="disc"><li>
            Timed interface: has or not a timed interfaces
          </li></ul></div>
<pre class="programlisting"><span class="identifier">hasnt_timed_interface</span> <span class="special">&lt;-</span> <span class="identifier">has_timed_interface</span>
</pre>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">hasnt_timed_interface_tag</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">has_timed_interface_tag</span> <span class="special">:</span> <span class="identifier">hasnt_timed_interface_tag</span> <span class="special">{};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          Substitutability applies both to the degree of syntactic support and to
          the locking semantics
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            A recursive mutex and binary semaphore are substitutable in code written
            against a exclusive mutex
          </li>
<li>
            A null mutex is substitutable for all others in a single-threaded environment
          </li>
</ul></div>
<p>
          We can see these axes of variation expressed against some Boost synchronization
          mechanisms (from now bip stands for boost::interprocess):
        </p>
<div class="itemizedlist"><ul type="disc">
<li>
            boost::mutex: ExclusiveLock, non-recursive, has-not-timed-interface,
            multi-threaded
          </li>
<li>
            boost::shared_mutex: UpgradableLock, non-recursive, has-timed-interface,
            multi-threaded
          </li>
<li>
            bip::sync::null_mutex: UpgradableLock, recursive, has-timed-interface,
            mono-threaded
          </li>
<li>
            bip::sync::interprocess_recursive_mutex ExclusiveLock, recursive, has-timed-interface,
            multi_process.
          </li>
</ul></div>
<p>
          <span class="bold"><strong>Lock traits</strong></span>
        </p>
<p>
          Generic programming (writing code which works with any data type meeting
          a set of requirements) has become the method of choice for providing reusable
          code.
        </p>
<p>
          However, there are times in generic programming when "generic"
          just isn't good enough - sometimes the differences between types are too
          large for an efficient generic implementation. This is when the traits
          technique becomes important - by encapsulating those properties that need
          to be considered on a type by type basis inside a traits class, we can
          minimize the amount of code that has to differ from one type to another,
          and maximize the amount of generic code.
        </p>
<p>
          Consider an example:
        </p>
<p>
          Boost.Synchro follow the design of Boost.TypeTraits, and contains a set
          of very specific traits classes, each of which encapsulate a single trait
          from the Lockable or Locker concepts; for example, is the lock recursive?
          Or does the lock have a timed interface?
        </p>
<p>
          The Boost.Synchro traits classes share a unified design: each class inherits
          from a the type true_type if the type has the specified property and inherits
          from false_type otherwise. As we will show, these classes can be used in
          generic programming to determine the properties of a given lock type and
          introduce optimizations that are appropriate for that case.
        </p>
<p>
          The type-traits library also contains a set of classes that perform a specific
          transformation on a type; for example, they can remove a top-level const
          or volatile qualifier from a type. Each class that performs a transformation
          defines a single typedef-member type that is the result of the transformation.
          All of the type-traits classes are defined inside namespace boost; for
          brevity, namespace-qualification is omitted in most of the code samples
          given.
        </p>
<p>
          <span class="bold"><strong>Implementation</strong></span>
        </p>
<p>
          Most of the implementation is fairly repetitive anyway, so here we will
          just give you a flavor for how some of the classes are implemented. See
          the reference section for the full details.
        </p>
<p>
          A lockable implementer must specialize the scope_tag template class. By
          default the scope_tag forward to a nested type scope.
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">scope_tag</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">::</span><span class="identifier">scope</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          So the implementer can either have a nested type scope or inherit from
          the helper lock_traits_base.
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">Scope</span><span class="special">,</span>
    <span class="keyword">typename</span> <span class="identifier">Category</span><span class="special">,</span>
    <span class="keyword">typename</span> <span class="identifier">Reentrancy</span><span class="special">,</span>
    <span class="keyword">typename</span> <span class="identifier">TimedInterface</span><span class="special">,</span>
    <span class="keyword">typename</span> <span class="identifier">Lifetime</span><span class="special">,</span>
    <span class="keyword">typename</span> <span class="identifier">Naming</span><span class="special">,</span>
    <span class="keyword">typename</span> <span class="identifier">Base</span>
<span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">lock_traits_base</span> <span class="special">:</span> <span class="identifier">Base</span> <span class="special">{</span>
    <span class="comment">// TODO add constraints on typenames
</span>    <span class="keyword">typedef</span> <span class="identifier">Scope</span> <span class="identifier">scope</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">Category</span> <span class="identifier">category</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">Reentrancy</span> <span class="identifier">reentrancy</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">TimedInterface</span> <span class="identifier">timed_interface</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">Lifetime</span> <span class="identifier">lifetime</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">Naming</span> <span class="identifier">naming</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          which defines the correct types. The lock_traits_base has a lot of parameters,
          and the defaults are the ones from boost::mutex. So Boost.Thread could
          use it as follows
        </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">mutex</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">lock_traits_base</span><span class="special">&lt;&gt;</span> <span class="special">{</span>
    <span class="comment">// ...
</span><span class="special">};</span>
</pre>
<p>
          Waiting for that Boost.Synchro specialize the scope_tag in the synchro/thread/mutex.hpp
          file.
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">multi_threaded_tag</span> <span class="identifier">type</span><span class="special">;</span> 
<span class="special">};</span>
</pre>
<p>
          So the user must include this file to make boost::mutex a model of Lockable
          for Boost.Synchro.
        </p>
<p>
          For example the trait is_multi_threaded is defined as : If Lockable has
          a scope_tag that inherits from multi_threaded_tag then inherits from true_type,
          otherwise inherits from false_type.
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_multi_threaded</span>
    <span class="special">:</span> <span class="identifier">is_same_or_is_base_and_derived</span><span class="special">&lt;</span>
        <span class="identifier">multi_threaded_tag</span><span class="special">,</span>
        <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;</span>
<span class="special">{};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          <span class="bold"><strong>Finding the best lock</strong></span>
        </p>
<p>
          Inverse traits can match a lockable type based on specific traits, for
          a given family of lock types.
        </p>
<p>
          It is also possible to specify characteristics to perform a reverse lookup
          to find a primitive lock type, either by exact match or by substitutable
          match.
        </p>
<pre class="programlisting"><span class="identifier">find_best_lock</span><span class="special">&lt;&gt;::</span><span class="identifier">type</span> <span class="special">==</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span>
<span class="identifier">find_best_lock</span><span class="special">&lt;</span><span class="identifier">mono_threaded_tag</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">==</span> <span class="identifier">bsync</span><span class="special">::</span><span class="identifier">null_mutex</span>
<span class="identifier">find_best_lock</span><span class="special">&lt;</span><span class="identifier">multi_threaded_tag</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">==</span> <span class="identifier">bsync</span><span class="special">::</span><span class="identifier">thread_mutex</span>
<span class="identifier">find_best_lock</span><span class="special">&lt;</span><span class="identifier">multi_process_tag</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">==</span> <span class="identifier">bsync</span><span class="special">::</span><span class="identifier">interprocess_mutex</span>
</pre>
<p>
          The user can also find a lock using mpl constraints as follows
        </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">find_best_lock_between</span><span class="special">&lt;</span><span class="identifier">Lockables</span><span class="special">,</span> 
        <span class="identifier">mpl</span><span class="special">::</span><span class="keyword">and</span><span class="special">&lt;</span><span class="identifier">is_multi_threaded</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;,</span> <span class="identifier">is_recursive</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">best</span><span class="special">;</span>
</pre>
<p>
          <span class="bold"><strong>Synchronization family</strong></span>
        </p>
<p>
          A class that will do internal locking can be parameterized by the type
          of synchronization familly needed to achieve the desired level of concurrency
          control. This could depends of the usage scope of this class, and this
          can be mono_threaded, multi_threaded, multi_process.
        </p>
<p>
          For example the thread_synchronization_family can be used to instantiate
          a message_queue class in a multi_threaded environment, all public methods
          will be thread-safe, with the corresponding overhead that implies. In contrast,
          if a null_synchronization_policy class is used to instantiate message_queue,
          all public methods will not be thread-safe, and there will be no additional
          overhead. A synchronization family must define typedef as for example
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">synchronization_family</span><span class="special">&lt;</span><span class="identifier">multi_threaded_tag</span><span class="special">&gt;</span> <span class="special">{</span>
   <span class="keyword">typedef</span> <span class="identifier">thread_mutex</span>                     <span class="identifier">mutex_type</span><span class="special">;</span>
   <span class="keyword">typedef</span> <span class="identifier">thread_recursive_mutex</span>           <span class="identifier">recursive_mutex_type</span><span class="special">;</span>
   <span class="keyword">typedef</span> <span class="identifier">thread_timed_mutex</span>               <span class="identifier">timed_mutex_type</span><span class="special">;</span>
   <span class="keyword">typedef</span> <span class="identifier">thread_recursive_timed_mutex</span>     <span class="identifier">recursive_timed_mutex_type</span><span class="special">;</span>
   <span class="keyword">typedef</span> <span class="identifier">thread_shared_mutex</span>              <span class="identifier">shared_mutex_type</span><span class="special">;</span>
   <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable</span>        <span class="identifier">condition_type</span><span class="special">;</span>
   <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable_any</span>    <span class="identifier">condition_type_any</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          <span class="bold"><strong>Lockable concept</strong></span>
        </p>
<p>
          For the main category clasification, the library provides concept classes
          that can be used with Boost.ConceptCheck. For example LockableConcept object
          supports the basic features required to delimit a critical region. Supports
          the basic lock, unlock and try_lock functions and defines the lock traits.
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">LockableConcept</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">category_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">category</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">timed_interface_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">timed_interface</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">reentrancy_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">reentrancy</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span>  <span class="identifier">scope</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lifetime_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span>  <span class="identifier">lifetime</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">naming_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span>  <span class="identifier">naming</span><span class="special">;</span>

    <span class="identifier">BOOST_CONCEPT_USAGE</span><span class="special">(</span><span class="identifier">LockableConcept</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">lockable</span><span class="special">::</span><span class="identifier">lock</span><span class="special">(</span><span class="identifier">l</span><span class="special">);</span>
        <span class="identifier">lockable</span><span class="special">::</span><span class="identifier">unlock</span><span class="special">(</span><span class="identifier">l</span><span class="special">);</span>
        <span class="identifier">lockable</span><span class="special">::</span><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">l</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">l</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          The user can now check staticaly that the template parameter is a model
          of Locable as follows
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="string">"boost/synchro/lockable_concepts.hpp"</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span> 
<span class="keyword">class</span> <span class="identifier">my_class</span> <span class="special">{</span>
  <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">LockableConcept</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;));</span>    
    <span class="comment">// ...
</span><span class="special">};</span>
</pre>
<p>
          The same can be done for TimedLockableConcept, ShareLockableConcept and
          UpgradeLockableConcept (See the reference section for more details).
        </p>
<p>
          <span class="bold"><strong>Syntactic lock traits</strong></span>
        </p>
<p>
          The locks on Boost.Thread and Boost::Interprocess do not follow the same
          interface. Most of the differences can be handled through traits, but other
          are better handled by adapting the interface.
        </p>
<p>
          The * The scoped locks live in a different namespace and some have different
          names with the same semantic.
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">scoped_lock_type</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">scoped_lock</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">unique_lock_type</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">unique_lock</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">shared_lock_type</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">shared_lock</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">upgrade_lock_type</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">upgrade_lock</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">upgrade_to_unique_locker_type</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">upgrade_to_unique_locker</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

</pre>
<p>
          </p>
<p>
        </p>
<p>
          So instead of using directly the locker of the respective libraries, use
          these traits.
        </p>
<pre class="programlisting"><span class="identifier">bsync</span><span class="special">::</span><span class="identifier">shared_lock_type</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mutex_</span><span class="special">);</span>
</pre>
<div class="itemizedlist"><ul type="disc"><li>
            The exception thrown lives in a different name space and different names
            with the same semantic.
          </li></ul></div>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">lock_error_type</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
        <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span>
    <span class="special">&gt;::</span><span class="identifier">lock_error</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          So instead of using directly the exception type of the respective libraries,
          use these traits.
        </p>
<pre class="programlisting"><span class="keyword">try</span> <span class="special">{</span>
    <span class="comment">// ...
</span><span class="special">}</span> <span class="keyword">catch</span> <span class="special">(</span><span class="identifier">bsync</span><span class="special">::</span><span class="identifier">lock_error_type</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&amp;</span> <span class="identifier">ex</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// ...
</span><span class="special">}</span>
</pre>
<div class="itemizedlist"><ul type="disc"><li>
            The move semantics (&amp;&amp;) are expressed with a class named differently.
          </li></ul></div>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">move_object_type</span> <span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">moved_object</span> <span class="special">:</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="keyword">template</span> <span class="identifier">moved_object</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">{</span>
        <span class="identifier">moved_object</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">t_</span><span class="special">):</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="keyword">template</span> <span class="identifier">moved_object</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">t_</span><span class="special">)</span> <span class="special">{}</span>
    <span class="special">};</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
        </p>
<div class="itemizedlist"><ul type="disc"><li>
            The scoped locks can be initialized with static const variables in order
            to overload the constructor for lock adoption, lock deferral or try to
            lock. Even if the name of these variables is the same, these variables
            live in different namespace.
          </li></ul></div>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">defer_lock_type</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">defer_lock_t</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="identifier">type</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">()</span> <span class="special">{</span><span class="keyword">return</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">defer_lock</span><span class="special">();}</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">adopt_lock_type</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">adopt_lock_t</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="identifier">type</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">(){</span><span class="keyword">return</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">adopt_lock</span><span class="special">();}</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">try_to_lock_type</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">try_to_lock_t</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="identifier">type</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">(){</span><span class="keyword">return</span> <span class="identifier">lockable_scope_traits</span><span class="special">&lt;</span>
                <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">try_to_lock</span><span class="special">();}</span>
<span class="special">};</span>

</pre>
<p>
          </p>
<p>
        </p>
<p>
          So instead of using directly the variables of the respective libraries,
          use these traits.
        </p>
<pre class="programlisting"><span class="identifier">bsync</span><span class="special">::</span><span class="identifier">shared_lock_type</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mutex_</span><span class="special">,</span> <span class="identifier">bsync</span><span class="special">::</span><span class="identifier">try_to_lock_type</span><span class="special">::</span><span class="identifier">value</span><span class="special">());</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_synchro.users_guide.tutorial.internal_locking__monitors"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial.internal_locking__monitors" title="Internal
        Locking--Monitors">Internal
        Locking--Monitors</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.internal_locking__monitors.concurrent_threads_of_execution">Concurrent
          threads of execution</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.internal_locking__monitors.monitors">Monitors</a></span></dt>
</dl></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This tutorial is an adaptation of chapter Concurrency of the Object-Oriented
            Programming in the BETA Programming Language and of the paper of Andrei
            Alexandrescu "Multithreading and the C++ Type System" to the
            Boost library.
          </p></td></tr>
</table></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial.internal_locking__monitors.concurrent_threads_of_execution"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial.internal_locking__monitors.concurrent_threads_of_execution" title="Concurrent
          threads of execution">Concurrent
          threads of execution</a>
</h5></div></div></div>
<p>
            Consider, for example, modeling a bank account class that supports simultaneous
            deposits and withdrawals from multiple locations (arguably the "Hello,
            World" of multithreaded programming).
          </p>
<p>
            From here a component is a model of the <code class="computeroutput"><span class="identifier">Callable</span></code>
            concept.
          </p>
<p>
            On C++0X (Boost) concurrent execution of a component is obtained by means
            of the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span></code>(<code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code>):
          </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread1</span><span class="special">(</span><span class="identifier">S</span><span class="special">);</span>
</pre>
<p>
            where <code class="computeroutput"><span class="identifier">S</span></code> is a model of
            <code class="computeroutput"><span class="identifier">Callable</span></code>. The meaning
            of this expression is that execution of <code class="computeroutput"><span class="identifier">S</span><span class="special">()</span></code> will take place concurrently with the
            current thread of execution executing the expression.
          </p>
<p>
            The following example includes a bank account of a person (Joe) and two
            components, one corresponding to a bank agent depositing money in Joe's
            account, and one representing Joe. Joe will only be withdrawing money
            from the account:
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span><span class="special">;</span>

<span class="identifier">BankAccount</span> <span class="identifier">JoesAccount</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">bankAgent</span><span class="special">()</span>
<span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span><span class="number">10</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&gt;</span><span class="number">0</span><span class="special">;</span> <span class="special">--</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">//...
</span>        <span class="identifier">JoesAccount</span><span class="special">.</span><span class="identifier">Deposit</span><span class="special">(</span><span class="number">500</span><span class="special">);</span>
        <span class="comment">//...
</span>    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">Joe</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span><span class="number">10</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&gt;</span><span class="number">0</span><span class="special">;</span> <span class="special">--</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">//...
</span>        <span class="keyword">int</span> <span class="identifier">myPocket</span> <span class="special">=</span> <span class="identifier">JoesAccount</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">100</span><span class="special">);</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">myPocket</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="comment">//...
</span>    <span class="special">}</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">//...
</span>    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread1</span><span class="special">(</span><span class="identifier">bankAgent</span><span class="special">);</span> <span class="comment">// start concurrent execution of bankAgent
</span>    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">thread2</span><span class="special">(</span><span class="identifier">Joe</span><span class="special">);</span> <span class="comment">// start concurrent execution of Joe
</span>    <span class="identifier">thread1</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
    <span class="identifier">thread2</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
          </p>
<p>
            From time to time, the <code class="computeroutput"><span class="identifier">bankAgent</span></code>
            will deposit $500 in <code class="computeroutput"><span class="identifier">JoesAccount</span></code>.
            Joe will similarly withdraw $100 from his account. These sentences describe
            that the bankAgent and Joe are executed concurrently.
          </p>
<p>
            The above example works well as long as the bankAgent and Joe do not
            access JoesAccount at the same time. There is, however, no guarantee
            that this will not happen. We may use a mutex to guarantee exclusive
            access to each bank.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
        <span class="keyword">int</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">balance_</span><span class="special">;</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
        <span class="keyword">return</span> <span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
          </p>
<p>
            Execution of the Deposit and Withdraw operations will no longer be able
            to make simultaneous access to balance.
          </p>
<p>
            Mutex is a simple and basic mechanism for obtaining synchronization.
            In the above example it is relatively easy to be convinced that the synchronization
            works correctly (in the absence of exception). In a system with several
            concurrent objects and several shared objects, it may be difficult to
            describe synchronization by means of mutexes. Programs that make heavy
            use of mutexes may be difficult to read and write. Instead, we shall
            introduce a number of generic classes for handling more complicated forms
            of synchronization and communication.
          </p>
<p>
            With the RAII idiom we can simplify a lot this using the scoped locks.
            In the code below, guard's constructor locks the passed-in object this,
            and guard's destructor unlocks this.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span> <span class="callout_bug"><a name="boost.synchro92co" href="tutorial.html#boost.synchro92"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list"><tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro92"></a><a href="#boost.synchro92co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> explicit mutex declaration </p></td>
</tr></table></div>
<p>
            </p>
<p>
          </p>
<p>
            The object-level locking idiom doesn't cover the entire richness of a
            threading model. For example, the model above is quite deadlock-prone
            when you try to coordinate multi-object transactions. Nonetheless, object-level
            locking is useful in many cases, and in combination with other mechanisms
            can provide a satisfactory solution to many threaded access problems
            in object-oriented programs.
          </p>
<p>
            The BankAccount class above uses internal locking. Basically, a class
            that uses internal locking guarantees that any concurrent calls to its
            public member functions don't corrupt an instance of that class. This
            is typically ensured by having each public member function acquire a
            lock on the object upon entry. This way, for any given object of that
            class, there can be only one member function call active at any moment,
            so the operations are nicely serialized.
          </p>
<p>
            This approach is reasonably easy to implement and has an attractive simplicity.
            Unfortunately, "simple" might sometimes morph into "simplistic."
          </p>
<p>
            Internal locking is insufficient for many real-world synchronization
            tasks. Imagine that you want to implement an ATM withdrawal transaction
            with the BankAccount class. The requirements are simple. The ATM transaction
            consists of two withdrawals-one for the actual money and one for the
            $2 commission. The two withdrawals must appear in strict sequence; that
            is, no other transaction can exist between them.
          </p>
<p>
            The obvious implementation is erratic:
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="callout_bug"><a name="boost.synchro93co" href="tutorial.html#boost.synchro93"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list"><tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro93"></a><a href="#boost.synchro93co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p>preemption possible</p></td>
</tr></table></div>
<p>
            </p>
<p>
          </p>
<p>
            The problem is that between the two calls above, another thread can perform
            another operation on the account, thus breaking the second design requirement.
          </p>
<p>
            In an attempt to solve this problem, let's lock the account from the
            outside during the two operations:
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">.</span><span class="identifier">mtx_</span><span class="special">);</span> <span class="callout_bug"><a name="boost.synchro94co" href="tutorial.html#boost.synchro94"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list"><tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro94"></a><a href="#boost.synchro94co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p>mtx_ field is private</p></td>
</tr></table></div>
<p>
            </p>
<p>
          </p>
<p>
            Notice that the code above do not compiles, the <code class="computeroutput"><span class="identifier">mtx_</span></code>
            field is private. We have two possibilities:
          </p>
<div class="itemizedlist"><ul type="disc">
<li>
              make <code class="computeroutput"><span class="identifier">mtx_</span></code> public which
              seams odd
            </li>
<li>
              make the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
              lockable by adding the lock/unlock functions
            </li>
</ul></div>
<p>
            We can add these functions explicitly
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
          </p>
<p>
            or inheriting from a class which add these lockable functions.
          </p>
<p>
            The <code class="computeroutput"><span class="identifier">exclusive_lockable_adapter</span></code>
            class
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">exclusive_lockable_adapter</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">lockable_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">scope</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">category_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">category</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">reentrancy_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">reentrancy</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">timed_interface_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">timed_interface</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lifetime_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">lifetime</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">naming_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">naming</span><span class="special">;</span>

    <span class="identifier">BOOST_COPY_CONSTRUCTOR_DELETE</span><span class="special">(</span><span class="identifier">exclusive_lockable_adapter</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro0co" href="tutorial.html#boost.synchro0"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
    <span class="identifier">BOOST_COPY_ASSIGNEMENT_DELETE</span><span class="special">(</span><span class="identifier">exclusive_lockable_adapter</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro1co" href="tutorial.html#boost.synchro1"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>   
    <span class="identifier">exclusive_lockable_adapter</span><span class="special">()</span> <span class="special">{}</span>
    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">()</span> <span class="special">{</span><span class="identifier">lock_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();}</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">()</span> <span class="special">{</span><span class="identifier">lock_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();}</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">lock_</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">();}</span>

<span class="keyword">protected</span><span class="special">:</span>
    <span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="special">&amp;</span><span class="identifier">lock_</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">mutable</span> <span class="identifier">Lockable</span> <span class="identifier">lock_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro0"></a><a href="#boost.synchro0co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro1"></a><a href="#boost.synchro1co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy asignement </p></td>
</tr>
</table></div>
<p>
            </p>
<p>
          </p>
<p>
            The <code class="computeroutput"><span class="identifier">BankAccount</span></code> class
            result now in
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">exclusive_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">thread_mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
<span class="comment">//        boost::lock_guard&lt;boost::mutex&gt; guard(*this-&gt;mutex());
</span>        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
<span class="comment">//        boost::lock_guard&lt;boost::mutex&gt; guard(*this-&gt;mutex());
</span>        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
<span class="comment">//        boost::lock_guard&lt;boost::mutex&gt; guard(*this-&gt;mutex());
</span>        <span class="keyword">return</span> <span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
          </p>
<p>
            and the code that do not comiles becomes
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
<span class="comment">//    boost::lock_guard&lt;boost::mutex&gt; guard(*acct.mutex());
</span>    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
          </p>
<p>
            Notice that now acct is being locked by Withdraw after it has already
            been locked by guard. When running such code, one of two things happens.
          </p>
<div class="itemizedlist"><ul type="disc">
<li>
              Your mutex implementation might support the so-called recursive mutex
              semantics. This means that the same thread can lock the same mutex
              several times successfully. In this case, the implementation works
              but has a performance overhead due to unnecessary locking. (The locking/unlocking
              sequence in the two Withdraw calls is not needed but performed anyway-and
              that costs time.)
            </li>
<li>
              Your mutex implementation might not support recursive locking, which
              means that as soon as you try to acquire it the second time, it blocks-so
              the ATMWithdrawal function enters the dreaded deadlock.
            </li>
</ul></div>
<p>
            As <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code> is not recursive, we need to
            use its recursive version <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code>.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">exclusive_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">thread_recursive_mutex</span><span class="special">&gt;</span>
<span class="special">{</span>

    <span class="comment">// ...
</span><span class="special">};</span>
</pre>
<p>
            </p>
<p>
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial.internal_locking__monitors.monitors"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial.internal_locking__monitors.monitors" title="Monitors">Monitors</a>
</h5></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.internal_locking__monitors.monitors.monitor_conditions">Monitor
            Conditions</a></span></dt></dl></div>
<p>
            The use of <code class="computeroutput"><span class="identifier">mutex</span></code> and
            <code class="computeroutput"><span class="identifier">lockers</span></code>, as in <code class="computeroutput"><span class="identifier">BankAccount</span></code>, is a common way of defining
            objects shared by two or more concurrent components. The exclusive_lockable_adapter
            class was a first step. We shall therefore introduce an abstraction that
            makes it easier to define such objects. The following class describes
            a so-called monitor pattern.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">=</span><span class="identifier">thread_mutex</span>
<span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">exclusive_monitor</span> <span class="special">:</span> <span class="keyword">protected</span> <span class="identifier">exclusive_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">{</span> <span class="callout_bug"><a name="boost.synchro2co" href="tutorial.html#boost.synchro2"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
<span class="keyword">protected</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span> <span class="identifier">synchronizer</span><span class="special">;</span> <span class="callout_bug"><a name="boost.synchro3co" href="tutorial.html#boost.synchro3"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro2"></a><a href="#boost.synchro2co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> behaves like an ExclusiveLockable for the derived classes </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro3"></a><a href="#boost.synchro3co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> is an strict
              lock guard </p></td>
</tr>
</table></div>
<p>
            </p>
<p>
          </p>
<p>
            A monitor object behaves like a <code class="computeroutput"><span class="identifier">ExclusiveLockable</span></code>
            object but only for the inheriting classes. Protected inheritance from
            exclusive_lockable_adapter provide to all the derived classes all ExclusiveLockable
            operations. In addition has a protected nested class, synchronizer, used
            when defining the monitor operations to synchronize the access critical
            regions. The BankAccount may be described using Monitor in the following
            way:
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">:</span> <span class="keyword">protected</span> <span class="identifier">exclusive_monitor</span><span class="special">&lt;&gt;</span>
<span class="special">{</span>
<span class="keyword">protected</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">BankAccount</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">balance_</span><span class="special">(</span><span class="number">0</span><span class="special">)</span> <span class="special">{}</span>
    <span class="identifier">BankAccount</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">BankAccount</span> <span class="special">&amp;</span><span class="identifier">rhs</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">synchronizer</span> <span class="identifier">_</span><span class="special">(*</span><span class="identifier">rhs</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">());</span>
        <span class="identifier">balance_</span><span class="special">=</span><span class="identifier">rhs</span><span class="special">.</span><span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">BankAccount</span> <span class="special">&amp;</span><span class="identifier">rhs</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">if</span><span class="special">(&amp;</span><span class="identifier">rhs</span> <span class="special">==</span> <span class="keyword">this</span><span class="special">)</span> <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>

        <span class="keyword">int</span> <span class="identifier">balance</span><span class="special">=</span><span class="number">0</span><span class="special">;</span>
        <span class="special">{</span>
            <span class="identifier">synchronizer</span> <span class="identifier">_</span><span class="special">(*</span><span class="identifier">rhs</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">());</span>
            <span class="identifier">balance</span><span class="special">=</span><span class="identifier">rhs</span><span class="special">.</span><span class="identifier">balance_</span><span class="special">;</span>
        <span class="special">}</span>
        <span class="identifier">synchronizer</span> <span class="identifier">_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">());</span>
        <span class="identifier">balance_</span><span class="special">=</span><span class="identifier">balance</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>
<span class="preprocessor">#if</span> <span class="number">0</span>
    <span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">BankAccount</span> <span class="special">&amp;</span><span class="identifier">rhs</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">if</span><span class="special">(&amp;</span><span class="identifier">rhs</span> <span class="special">==</span> <span class="keyword">this</span><span class="special">)</span> <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
        <span class="keyword">int</span> <span class="identifier">balance</span><span class="special">=</span><span class="number">0</span><span class="special">;</span>
        <span class="identifier">synchronize</span> <span class="special">(*</span><span class="identifier">rhs</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">())</span> <span class="identifier">balance</span><span class="special">=</span><span class="identifier">rhs</span><span class="special">.</span><span class="identifier">balance_</span><span class="special">;</span>
        <span class="identifier">synchronize</span> <span class="special">(*</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">())</span> <span class="identifier">balance_</span><span class="special">=</span><span class="identifier">balance</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>
<span class="preprocessor">#endif</span>

    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">synchronizer</span> <span class="identifier">_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">());</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">synchronizer</span> <span class="identifier">_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">());</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">GetBalance</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">synchronizer</span> <span class="identifier">_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">());</span>
        <span class="keyword">return</span> <span class="identifier">balance_</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
          </p>
<p>
            In the following, a monitor means some sub-class of monitor. A synchroronized
            operation means an operation using the synchronizer guard defined within
            some monitor. Monitor is one example of a high-level concurrency abstraction
            that can be defined by means of mutexes.
          </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h6 class="title">
<a name="boost_synchro.users_guide.tutorial.internal_locking__monitors.monitors.monitor_conditions"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial.internal_locking__monitors.monitors.monitor_conditions" title="Monitor
            Conditions">Monitor
            Conditions</a>
</h6></div></div></div>
<p>
              It may happen that a component executing an entry operation of a monitor
              is unable to continue execution due to some condition not being fulfilled.
              Consider, for instance, a bounded buffer of characters. Such a buffer
              may be implemented as a monitor with two operations Push and Pull:
              the Puss operation cannot be executed if the buffer is full, and the
              Pull operation cannot be executed if the buffer is empty. A sketch
              of such a buffer monitor may look as follows:
            </p>
<p>
              </p>
<p>
                
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">sync_buffer</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span> <span class="callout_bug"><a name="boost.synchro70co" href="tutorial.html#boost.synchro70"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="special">...</span>
    <span class="keyword">bool</span> <span class="identifier">full</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">in_</span><span class="special">==</span><span class="identifier">out_</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">empty</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">in_</span><span class="special">==(</span><span class="identifier">out_</span><span class="special">%</span><span class="identifier">size</span><span class="special">)+</span><span class="number">1</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">push</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// wait if buffer is full
</span>        <span class="identifier">data_</span><span class="special">[</span><span class="identifier">in_</span><span class="special">]=</span><span class="identifier">v</span><span class="special">;</span>
        <span class="identifier">in_</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">in_</span><span class="special">%</span> <span class="identifier">size</span><span class="special">)+</span><span class="number">1</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">T</span> <span class="identifier">pull</span><span class="special">()</span> <span class="special">{</span>
        <span class="comment">// wait if buffer is empty
</span>        <span class="identifier">out_</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">out_</span><span class="special">%</span> <span class="identifier">size</span><span class="special">)+</span><span class="number">1</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">data_</span><span class="special">[</span><span class="identifier">out_</span><span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
              </p>
<p>
              </p>
<p>
                </p>
<div class="calloutlist"><table border="0" summary="Callout list"><tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro70"></a><a href="#boost.synchro70co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> explicit mutex declaration </p></td>
</tr></table></div>
<p>
              </p>
<p>
            </p>
<p>
              The meaning of a wait is that the calling component is delayed until
              the condition becomes true. We can do that using Boost.Thread condition
              variables like:
            </p>
<p>
              </p>
<p>
                
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">size</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">sync_buffer</span>
<span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mutex_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable</span> <span class="identifier">condition_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex_type</span><span class="special">&gt;</span> <span class="identifier">unique_lock_type</span><span class="special">;</span>
    <span class="identifier">mutex_type</span> <span class="identifier">mtx_</span><span class="special">;</span>
    <span class="identifier">condition_type</span> <span class="identifier">not_full_</span><span class="special">;</span>
    <span class="identifier">condition_type</span> <span class="identifier">not_empty_</span><span class="special">;</span>

    <span class="identifier">T</span> <span class="identifier">data_</span><span class="special">[</span><span class="identifier">size</span><span class="special">+</span><span class="number">1</span><span class="special">];</span>
    <span class="keyword">unsigned</span> <span class="identifier">in_</span><span class="special">,</span> <span class="identifier">out_</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">sync_buffer</span><span class="special">():</span><span class="identifier">in_</span><span class="special">(</span><span class="number">0</span><span class="special">),</span> <span class="identifier">out_</span><span class="special">(</span><span class="number">0</span><span class="special">)</span> <span class="special">{}</span>

    <span class="keyword">bool</span> <span class="identifier">full</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">out_</span><span class="special">==(</span><span class="identifier">in_</span><span class="special">+</span><span class="number">1</span><span class="special">)%(</span><span class="identifier">size</span><span class="special">+</span><span class="number">1</span><span class="special">);</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">empty</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">out_</span><span class="special">==</span><span class="identifier">in_</span><span class="special">;</span> <span class="special">}</span>

    <span class="keyword">unsigned</span> <span class="identifier">get_in</span><span class="special">()</span> <span class="special">{</span><span class="keyword">return</span> <span class="identifier">in_</span><span class="special">;}</span>
    <span class="keyword">unsigned</span> <span class="identifier">get_out</span><span class="special">()</span> <span class="special">{</span><span class="keyword">return</span> <span class="identifier">out_</span><span class="special">;}</span>
    <span class="keyword">void</span> <span class="identifier">push</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">unique_lock_type</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span> <span class="callout_bug"><a name="boost.synchro77co" href="tutorial.html#boost.synchro77"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
        <span class="keyword">while</span> <span class="special">(</span><span class="identifier">full</span><span class="special">())</span> <span class="special">{</span> <span class="callout_bug"><a name="boost.synchro78co" href="tutorial.html#boost.synchro78"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>
            <span class="identifier">not_full_</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span><span class="identifier">guard</span><span class="special">);</span>
        <span class="special">}</span>
        <span class="identifier">data_</span><span class="special">[</span><span class="identifier">in_</span><span class="special">]=</span><span class="identifier">v</span><span class="special">;</span>
        <span class="identifier">in_</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">in_</span><span class="special">+</span><span class="number">1</span><span class="special">)%</span> <span class="special">(</span><span class="identifier">size</span><span class="special">+</span><span class="number">1</span><span class="special">);</span>
        <span class="identifier">not_empty_</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span> <span class="callout_bug"><a name="boost.synchro79co" href="tutorial.html#boost.synchro79"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a></span>
    <span class="special">}</span>

    <span class="identifier">T</span> <span class="identifier">pull</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">unique_lock_type</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">mtx_</span><span class="special">);</span> <span class="callout_bug"><a name="boost.synchro80co" href="tutorial.html#boost.synchro80"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a></span>
        <span class="keyword">while</span> <span class="special">(</span><span class="identifier">empty</span><span class="special">())</span> <span class="special">{</span> <span class="callout_bug"><a name="boost.synchro81co" href="tutorial.html#boost.synchro81"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a></span>
            <span class="identifier">not_empty_</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span><span class="identifier">guard</span><span class="special">);</span>
        <span class="special">}</span>
        <span class="keyword">unsigned</span> <span class="identifier">idx</span> <span class="special">=</span> <span class="identifier">out_</span><span class="special">;</span>
        <span class="identifier">out_</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">out_</span><span class="special">+</span><span class="number">1</span><span class="special">)%</span> <span class="special">(</span><span class="identifier">size</span><span class="special">+</span><span class="number">1</span><span class="special">);</span>
        <span class="identifier">not_full_</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span> <span class="callout_bug"><a name="boost.synchro82co" href="tutorial.html#boost.synchro82"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a></span>
        <span class="keyword">return</span> <span class="identifier">data_</span><span class="special">[</span><span class="identifier">idx</span><span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>

</pre>
<p>
              </p>
<p>
              </p>
<p>
                </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro77"></a><a href="#boost.synchro77co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> ensure the mutex is locked!!! </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro78"></a><a href="#boost.synchro78co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> loop until not full!!! </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro79"></a><a href="#boost.synchro79co"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> notifies a not_empty
                condition </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro80"></a><a href="#boost.synchro80co"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </td>
<td valign="top" align="left"><p> ensure the mutex is locked!!! </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro81"></a><a href="#boost.synchro81co"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a> </td>
<td valign="top" align="left"><p> loop until not full!!! </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro82"></a><a href="#boost.synchro82co"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a> </td>
<td valign="top" align="left"><p> notifies
                a not_full condition </p></td>
</tr>
</table></div>
<p>
              </p>
<p>
            </p>
<p>
              The Monitor class replace the nested synchronizer unique_lock with
              the class <code class="computeroutput"><span class="identifier">condition_locker</span></code>
              for this purpose:
            </p>
<p>
              </p>
<p>
                
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">,</span>
    <span class="keyword">class</span> <span class="identifier">Condition</span><span class="special">=</span><span class="identifier">condition_safe</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">best_condition</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span>
    <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">ScopeTag</span><span class="special">=</span><span class="keyword">typename</span> <span class="identifier">scope_tag</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">type</span>
<span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">condition_unique_locker</span>
    <span class="special">:</span> <span class="keyword">protected</span> <span class="identifier">unique_locker</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">,</span><span class="identifier">ScopeTag</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">LockableConcept</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;));</span>
    <span class="keyword">typedef</span> <span class="identifier">unique_locker</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">,</span> <span class="identifier">ScopeTag</span><span class="special">&gt;</span> <span class="identifier">super_type</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">lockable_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">Condition</span> <span class="identifier">condition</span><span class="special">;</span>

    <span class="keyword">explicit</span> <span class="identifier">condition_unique_locker</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">);</span> <span class="callout_bug"><a name="boost.synchro4co" href="tutorial.html#boost.synchro4"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
    <span class="identifier">condition_unique_locker</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">condition</span> <span class="special">&amp;</span><span class="identifier">cond</span><span class="special">);</span> <span class="callout_bug"><a name="boost.synchro5co" href="tutorial.html#boost.synchro5"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
    <span class="identifier">condition_unique_locker</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">condition</span> <span class="special">&amp;</span><span class="identifier">cond</span><span class="special">,</span> <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span> <span class="callout_bug"><a name="boost.synchro6co" href="tutorial.html#boost.synchro6"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a></span>
    <span class="special">~</span><span class="identifier">condition_unique_locker</span><span class="special">()</span> <span class="callout_bug"><a name="boost.synchro7co" href="tutorial.html#boost.synchro7"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a></span>

    <span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="special">(</span><span class="identifier">condition_unique_locker</span><span class="special">::*</span><span class="identifier">bool_type</span><span class="special">)()</span> <span class="keyword">const</span><span class="special">;</span> <span class="callout_bug"><a name="boost.synchro8co" href="tutorial.html#boost.synchro8"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a></span>
    <span class="keyword">operator</span> <span class="identifier">bool_type</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span> <span class="callout_bug"><a name="boost.synchro9co" href="tutorial.html#boost.synchro9"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a></span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span> <span class="special">}</span> <span class="callout_bug"><a name="boost.synchro10co" href="tutorial.html#boost.synchro10"><img src="../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a></span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span> <span class="special">}</span> <span class="callout_bug"><a name="boost.synchro11co" href="tutorial.html#boost.synchro11"><img src="../../../../../../doc/src/images/callouts/8.png" alt="8" border="0"></a></span>
    <span class="keyword">bool</span> <span class="identifier">is_locking</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="callout_bug"><a name="boost.synchro12co" href="tutorial.html#boost.synchro12"><img src="../../../../../../doc/src/images/callouts/9.png" alt="9" border="0"></a></span>

    <span class="keyword">void</span> <span class="identifier">relock_on</span><span class="special">(</span><span class="identifier">condition</span> <span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">relock_until</span><span class="special">(</span><span class="identifier">condition</span> <span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">relock_on_for</span><span class="special">(</span><span class="identifier">condition</span> <span class="special">&amp;</span> <span class="identifier">cond</span><span class="special">,</span> <span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">relock_when</span><span class="special">(</span><span class="identifier">condition</span> <span class="special">&amp;</span><span class="identifier">cond</span><span class="special">,</span> <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">&gt;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">relock_when_until</span><span class="special">(</span><span class="identifier">condition</span> <span class="special">&amp;</span><span class="identifier">cond</span><span class="special">,</span> <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">,</span>
            <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Predicate</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">relock_when_for</span><span class="special">(</span><span class="identifier">condition</span> <span class="special">&amp;</span><span class="identifier">cond</span><span class="special">,</span> <span class="identifier">Predicate</span> <span class="identifier">pred</span><span class="special">,</span>
            <span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>

    <span class="callout_bug"><a name="boost.synchro13co" href="tutorial.html#boost.synchro13"><img src="../../../../../../doc/src/images/callouts/10.png" alt="10" border="0"></a></span>
<span class="special">};</span>
</pre>
<p>
              </p>
<p>
              </p>
<p>
                </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro4"></a><a href="#boost.synchro4co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> locks on construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro5"></a><a href="#boost.synchro5co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> relock on condition </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro6"></a><a href="#boost.synchro6co"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> relock condition when predicate
                satisfaied</p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro7"></a><a href="#boost.synchro7co"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </td>
<td valign="top" align="left"><p> unlocks on destruction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro8"></a><a href="#boost.synchro8co"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a> </td>
<td valign="top" align="left"><p> safe bool idiom </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro9"></a><a href="#boost.synchro9co"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a> </td>
<td valign="top" align="left"><p> always owned </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro10"></a><a href="#boost.synchro10co"><img src="../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a> </td>
<td valign="top" align="left"><p> always
                owned </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro11"></a><a href="#boost.synchro11co"><img src="../../../../../../doc/src/images/callouts/8.png" alt="8" border="0"></a> </td>
<td valign="top" align="left"><p> always owned </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro12"></a><a href="#boost.synchro12co"><img src="../../../../../../doc/src/images/callouts/9.png" alt="9" border="0"></a> </td>
<td valign="top" align="left"><p> strict lockers specific function </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro13"></a><a href="#boost.synchro13co"><img src="../../../../../../doc/src/images/callouts/10.png" alt="10" border="0"></a> </td>
<td valign="top" align="left"><p> no possibility
                to unlock without blocking on wait... </p></td>
</tr>
</table></div>
<p>
              </p>
<p>
            </p>
<p>
              We may now give the complete version of the buffer class. The content
              of the buffer is: <code class="computeroutput"><span class="identifier">data_</span><span class="special">[</span><span class="identifier">out_</span><span class="special">+</span><span class="number">1</span><span class="special">],</span>
              <span class="identifier">data_</span><span class="special">[</span><span class="identifier">out_</span><span class="special">+</span><span class="number">2</span><span class="special">],</span> <span class="special">...</span> <span class="identifier">data_R</span><span class="special">[</span><span class="identifier">in_</span><span class="special">-</span><span class="number">1</span><span class="special">]</span></code>
              where all the indexes are modulo size. The buffer is full if <code class="computeroutput"><span class="identifier">in_</span><span class="special">=</span><span class="identifier">out_</span></code> and it is empty if <code class="computeroutput"><span class="identifier">in_</span><span class="special">=(</span><span class="identifier">out_</span><span class="special">+</span><span class="number">1</span><span class="special">)%</span><span class="identifier">size</span></code>.
            </p>
<p>
              </p>
<p>
                
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">size</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">sync_buffer</span> <span class="special">:</span> <span class="keyword">protected</span> <span class="identifier">exclusive_monitor</span><span class="special">&lt;&gt;</span>
<span class="special">{</span>
    <span class="identifier">condition</span> <span class="identifier">not_full_</span><span class="special">;</span>
    <span class="identifier">condition</span> <span class="identifier">not_empty_</span><span class="special">;</span>

    <span class="identifier">T</span> <span class="identifier">data_</span><span class="special">[</span><span class="identifier">size</span><span class="special">+</span><span class="number">1</span><span class="special">];</span>
    <span class="keyword">unsigned</span> <span class="identifier">in_</span><span class="special">,</span> <span class="identifier">out_</span><span class="special">;</span>

    <span class="keyword">struct</span>  <span class="identifier">not_full</span> <span class="special">{</span>
        <span class="keyword">explicit</span> <span class="identifier">not_full</span><span class="special">(</span><span class="identifier">sync_buffer</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">):</span><span class="identifier">that_</span><span class="special">(</span><span class="identifier">b</span><span class="special">){};</span>
        <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="special">!</span><span class="identifier">that_</span><span class="special">.</span><span class="identifier">full</span><span class="special">();</span> <span class="special">}</span>
        <span class="identifier">sync_buffer</span> <span class="special">&amp;</span><span class="identifier">that_</span><span class="special">;</span>
    <span class="special">};</span>
    <span class="keyword">struct</span>  <span class="identifier">not_empty</span> <span class="special">{</span>
        <span class="keyword">explicit</span> <span class="identifier">not_empty</span><span class="special">(</span><span class="identifier">sync_buffer</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">):</span><span class="identifier">that_</span><span class="special">(</span><span class="identifier">b</span><span class="special">){};</span>
        <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="special">!</span><span class="identifier">that_</span><span class="special">.</span><span class="identifier">empty</span><span class="special">();</span> <span class="special">}</span>
        <span class="identifier">sync_buffer</span> <span class="special">&amp;</span><span class="identifier">that_</span><span class="special">;</span>
    <span class="special">};</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">BOOST_COPY_CONSTRUCTOR_DELETE</span><span class="special">(</span><span class="identifier">sync_buffer</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro71co" href="tutorial.html#boost.synchro71"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
    <span class="identifier">BOOST_COPY_ASSIGNEMENT_DELETE</span><span class="special">(</span><span class="identifier">sync_buffer</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro72co" href="tutorial.html#boost.synchro72"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>
    <span class="identifier">sync_buffer</span><span class="special">():</span><span class="identifier">in_</span><span class="special">(</span><span class="number">0</span><span class="special">),</span> <span class="identifier">out_</span><span class="special">(</span><span class="number">0</span><span class="special">)</span> <span class="special">{}</span>

    <span class="keyword">bool</span> <span class="identifier">full</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">out_</span><span class="special">==(</span><span class="identifier">in_</span><span class="special">+</span><span class="number">1</span><span class="special">)%(</span><span class="identifier">size</span><span class="special">+</span><span class="number">1</span><span class="special">);</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">empty</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">out_</span><span class="special">==</span><span class="identifier">in_</span><span class="special">;</span> <span class="special">}</span>

    <span class="keyword">unsigned</span> <span class="identifier">get_in</span><span class="special">()</span> <span class="special">{</span><span class="keyword">return</span> <span class="identifier">in_</span><span class="special">;}</span>
    <span class="keyword">unsigned</span> <span class="identifier">get_out</span><span class="special">()</span> <span class="special">{</span><span class="keyword">return</span> <span class="identifier">out_</span><span class="special">;}</span>

    <span class="keyword">void</span> <span class="identifier">push</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">synchronizer</span> <span class="identifier">_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">(),</span> <span class="identifier">not_full_</span><span class="special">,</span> <span class="identifier">not_full</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span> <span class="callout_bug"><a name="boost.synchro73co" href="tutorial.html#boost.synchro73"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a></span>
        <span class="identifier">data_</span><span class="special">[</span><span class="identifier">in_</span><span class="special">]=</span><span class="identifier">v</span><span class="special">;</span>
        <span class="identifier">in_</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">in_</span><span class="special">+</span><span class="number">1</span><span class="special">)%</span> <span class="special">(</span><span class="identifier">size</span><span class="special">+</span><span class="number">1</span><span class="special">);</span>
        <span class="identifier">not_empty_</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span> <span class="callout_bug"><a name="boost.synchro74co" href="tutorial.html#boost.synchro74"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a></span>
    <span class="special">}</span>

    <span class="identifier">T</span> <span class="identifier">pull</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">synchronizer</span> <span class="identifier">_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">(),</span> <span class="identifier">not_empty_</span><span class="special">,</span> <span class="identifier">not_empty</span><span class="special">(*</span><span class="keyword">this</span><span class="special">));</span> <span class="callout_bug"><a name="boost.synchro75co" href="tutorial.html#boost.synchro75"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a></span>
        <span class="keyword">unsigned</span> <span class="identifier">idx</span> <span class="special">=</span> <span class="identifier">out_</span><span class="special">;</span>
        <span class="identifier">out_</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">out_</span><span class="special">+</span><span class="number">1</span><span class="special">)%</span> <span class="special">(</span><span class="identifier">size</span><span class="special">+</span><span class="number">1</span><span class="special">);</span>
        <span class="identifier">not_full_</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span> <span class="callout_bug"><a name="boost.synchro76co" href="tutorial.html#boost.synchro76"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a></span>
        <span class="keyword">return</span> <span class="identifier">data_</span><span class="special">[</span><span class="identifier">idx</span><span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
              </p>
<p>
              </p>
<p>
                </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro71"></a><a href="#boost.synchro71co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro72"></a><a href="#boost.synchro72co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy asignement </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro73"></a><a href="#boost.synchro73co"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> waits until the
                condition not_full is satisfyed </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro74"></a><a href="#boost.synchro74co"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </td>
<td valign="top" align="left"><p> notifies a not_empty condition </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro75"></a><a href="#boost.synchro75co"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a> </td>
<td valign="top" align="left"><p> waits
                until the condition not_empty is satisfyed </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro76"></a><a href="#boost.synchro76co"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a> </td>
<td valign="top" align="left"><p> notifies a not_full condition
                </p></td>
</tr>
</table></div>
<p>
              </p>
<p>
            </p>
<p>
              Monitors and conditions are useful for describing simple cases of shared
              objects (by simple we mean a limited use of conditions). If the conditions
              for delaying a calling component become complicated, the monitor may
              similarly become difficult to program and read.
            </p>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_" title="volatile  and locking_ptr"><code class="computeroutput"><span class="keyword">volatile</span> </code> and <code class="computeroutput"><span class="identifier">locking_ptr</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.just_a_little_keyword">Just
          a Little Keyword</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.using__volatile__with_user_defined_types">Using
          <code class="computeroutput"><span class="keyword">volatile</span></code> with User-Defined
          Types</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._volatile___critical_sections__and_race_conditions"><code class="computeroutput"><span class="keyword">volatile</span></code>, Critical Sections, and Race Conditions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._locking_ptr_"><code class="computeroutput"><span class="identifier">locking_ptr</span></code></a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.back_to_primitive_types">Back
          to Primitive Types</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._volatile__member_functions"><code class="computeroutput"><span class="keyword">volatile</span></code> Member Functions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.generic__locking_ptr_">Generic
          <code class="computeroutput"><span class="identifier">locking_ptr</span></code></a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.specific__locking_ptr__for_lockable_value_types">Specific
          <code class="computeroutput"><span class="identifier">locking_ptr</span></code> for lockable
          value types</a></span></dt>
</dl></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This tutorial is an adaptation of the article of Andrei Alexandrescu
            "<code class="computeroutput"><span class="keyword">volatile</span></code> - Multithreaded
            Programmer's Best Friend" to the Boost library.
          </p></td></tr>
</table></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.just_a_little_keyword"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.just_a_little_keyword" title="Just
          a Little Keyword">Just
          a Little Keyword</a>
</h5></div></div></div>
<p>
            Although both C and C++ Standards are conspicuously silent when it comes
            to threads, they do make a little concession to multi-threading, in the
            form of the volatile keyword.
          </p>
<p>
            Just like its better-known counterpart const, volatile is a type modifier.
            It's intended to be used in conjunction with variables that are accessed
            and modified in different threads. Basically, without volatile, either
            writing multi-threaded programs becomes impossible, or the compiler wastes
            vast optimization opportunities. An explanation is in order.
          </p>
<p>
            Consider the following code:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Gadget</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Wait</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="keyword">while</span> <span class="special">(!</span><span class="identifier">flag_</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">sleep</span><span class="special">(</span><span class="number">1000</span><span class="special">);</span> <span class="comment">// sleeps for 1000 milliseconds
</span>        <span class="special">}</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Wakeup</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">flag_</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="special">...</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">bool</span> <span class="identifier">flag_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            The purpose of <code class="computeroutput"><span class="identifier">Gadget</span><span class="special">::</span><span class="identifier">Wait</span></code>
            above is to check the <code class="computeroutput"><span class="identifier">flag_</span></code>
            member variable every second and return when that variable has been set
            to true by another thread. At least that's what its programmer intended,
            but, alas, Wait is incorrect. Suppose the compiler figures out that
            <code class="computeroutput"><span class="identifier">sleep</span><span class="special">(</span><span class="number">1000</span><span class="special">)</span></code> is
            a call into an external library that cannot possibly modify the member
            variable <code class="computeroutput"><span class="identifier">flag_</span></code>. Then
            the compiler concludes that it can cache <code class="computeroutput"><span class="identifier">flag_</span></code>
            in a register and use that register instead of accessing the slower on-board
            memory. This is an excellent optimization for single-threaded code, but
            in this case, it harms correctness: after you call Wait for some <code class="computeroutput"><span class="identifier">Gadget</span></code> object, although another thread
            calls Wakeup, Wait will loop forever. This is because the change of
            <code class="computeroutput"><span class="identifier">flag_</span></code> will not be reflected
            in the register that caches <code class="computeroutput"><span class="identifier">flag_</span></code>.
            The optimization is too ... optimistic. Caching variables in registers
            is a very valuable optimization that applies most of the time, so it
            would be a pity to waste it. C and C++ give you the chance to explicitly
            disable such caching. If you use the volatile modifier on a variable,
            the compiler won't cache that variable in registers -- each access will
            hit the actual memory location of that variable. So all you have to do
            to make Gadget's Wait/Wakeup combo work is to qualify <code class="computeroutput"><span class="identifier">flag_</span></code>
            appropriately:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Gadget</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="special">...</span> <span class="identifier">as</span> <span class="identifier">above</span> <span class="special">...</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">volatile</span> <span class="keyword">bool</span> <span class="identifier">flag_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            Most explanations of the rationale and usage of <code class="computeroutput"><span class="keyword">volatile</span></code>
            stop here and advise you to volatile-qualify the primitive types that
            you use in multiple threads. However, there is much more you can do with
            <code class="computeroutput"><span class="keyword">volatile</span></code>, because it is
            part of C++'s wonderful type system.
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.using__volatile__with_user_defined_types"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.using__volatile__with_user_defined_types" title="Using
          volatile with User-Defined
          Types">Using
          <code class="computeroutput"><span class="keyword">volatile</span></code> with User-Defined
          Types</a>
</h5></div></div></div>
<p>
            You can volatile-qualify not only primitive types, but also user-defined
            types. In that case, <code class="computeroutput"><span class="keyword">volatile</span></code>
            modifies the type in a way similar to const. (You can also apply const
            and <code class="computeroutput"><span class="keyword">volatile</span></code> to the same
            type simultaneously.) Unlike <code class="computeroutput"><span class="keyword">const</span></code>,
            <code class="computeroutput"><span class="keyword">volatile</span></code> discriminates between
            primitive types and user-defined types. Namely, unlike classes, primitive
            types still support all of their operations (addition, multiplication,
            assignment, etc.) when volatile-qualified. For example, you can assign
            a non-volatile <code class="computeroutput"><span class="keyword">int</span></code> to a
            <code class="computeroutput"><span class="keyword">volatile</span></code> <code class="computeroutput"><span class="keyword">int</span></code>,
            but you cannot assign a non-volatile object to a <code class="computeroutput"><span class="keyword">volatile</span></code>
            object. Let's illustrate how <code class="computeroutput"><span class="keyword">volatile</span></code>
            works on user-defined types on an example.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Gadget</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Foo</span><span class="special">()</span> <span class="keyword">volatile</span><span class="special">;</span>
    <span class="keyword">void</span> <span class="identifier">Bar</span><span class="special">();</span>
    <span class="special">...</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">tring</span> <span class="identifier">name_</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">state_</span><span class="special">;</span>
<span class="special">};</span>
<span class="special">...</span>
<span class="identifier">Gadget</span> <span class="identifier">regularGadget</span><span class="special">;</span>
<span class="keyword">volatile</span> <span class="identifier">Gadget</span> <span class="identifier">volatileGadget</span><span class="special">;</span>
</pre>
<p>
            If you think <code class="computeroutput"><span class="keyword">volatile</span></code> is
            not that useful with objects, prepare for some surprise.
          </p>
<pre class="programlisting"><span class="identifier">volatileGadget</span><span class="special">.</span><span class="identifier">Foo</span><span class="special">();</span>   <span class="comment">// ok, volatile fun called for
</span>                        <span class="comment">// volatile object
</span>

<span class="identifier">regularGadget</span><span class="special">.</span><span class="identifier">Foo</span><span class="special">();</span>    <span class="comment">// ok, volatile fun called for
</span>                        <span class="comment">// non-volatile object
</span><span class="identifier">volatileGadget</span><span class="special">.</span><span class="identifier">Bar</span><span class="special">();</span>   <span class="comment">// error! Non-volatile function called for
</span>                        <span class="comment">// volatile object!
</span></pre>
<p>
            The conversion from a non-qualified type to its <code class="computeroutput"><span class="keyword">volatile</span></code>
            counterpart is trivial. However, just as with const, you cannot make
            the trip back from <code class="computeroutput"><span class="keyword">volatile</span></code>
            to non-qualified. You must use a cast:
          </p>
<pre class="programlisting"><span class="identifier">Gadget</span><span class="special">&amp;</span> <span class="identifier">ref</span> <span class="special">=</span> <span class="keyword">const_cast</span><span class="special">&lt;</span><span class="identifier">Gadget</span><span class="special">&amp;&gt;(</span><span class="identifier">volatileGadget</span><span class="special">);</span>
<span class="identifier">ref</span><span class="special">.</span><span class="identifier">Bar</span><span class="special">();</span> <span class="comment">// ok
</span></pre>
<p>
            A volatile-qualified class gives access only to a subset of its interface,
            a subset that is under the control of the class implementer. Users can
            gain full access to that type's interface only by using a <code class="computeroutput"><span class="keyword">const_cast</span></code>. In addition, just like constness,
            volatileness propagates from the class to its members (for example,
            <code class="computeroutput"><span class="identifier">volatileGadget</span><span class="special">.</span><span class="identifier">name_</span></code> and <code class="computeroutput"><span class="identifier">volatileGadget</span><span class="special">.</span><span class="identifier">state_</span></code>
            are <code class="computeroutput"><span class="keyword">volatile</span></code> variables).
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._volatile___critical_sections__and_race_conditions"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._volatile___critical_sections__and_race_conditions" title="volatile, Critical Sections, and Race Conditions"><code class="computeroutput"><span class="keyword">volatile</span></code>, Critical Sections, and Race Conditions</a>
</h5></div></div></div>
<p>
            The simplest and the most often-used synchronization device in multi-threaded
            programs is the mutex.
          </p>
<p>
            Mutexes are used to protect data against race conditions. By definition,
            a race condition occurs when the effect of more threads on data depends
            on how threads are scheduled. Race conditions appear when two or more
            threads compete for using the same data. Because threads can interrupt
            each other at arbitrary moments in time, data can be corrupted or misinterpreted.
            Consequently, changes and sometimes accesses to data must be carefully
            protected with critical sections. In object-oriented programming, this
            usually means that you store a mutex in a class as a member variable
            and use it whenever you access that class' state. Experienced multi-threaded
            programmers might have yawned reading the two paragraphs above, but their
            purpose is to provide an intellectual workout, because now we will link
            with the <code class="computeroutput"><span class="keyword">volatile</span></code> connection.
            We do this by drawing a parallel between the C++ types' world and the
            threading semantics world.
          </p>
<div class="itemizedlist"><ul type="disc">
<li>
              Outside a critical section, any thread might interrupt any other at
              any time; there is no control, so consequently variables accessible
              from multiple threads are <code class="computeroutput"><span class="keyword">volatile</span></code>.
              This is in keeping with the original intent of <code class="computeroutput"><span class="keyword">volatile</span></code>
              -- that of preventing the compiler from unwittingly caching values
              used by multiple threads at once.
            </li>
<li>
              Inside a critical section defined by a mutex, only one thread has access.
              Consequently, inside a critical section, the executing code has single-threaded
              semantics. The controlled variable is not <code class="computeroutput"><span class="keyword">volatile</span></code>
              anymore -- you can remove the <code class="computeroutput"><span class="keyword">volatile</span></code>
              qualifier.
            </li>
</ul></div>
<p>
            In short, data shared between threads is conceptually <code class="computeroutput"><span class="keyword">volatile</span></code>
            outside a critical section, and non-volatile inside a critical section.
            You enter a critical section by locking a mutex. You remove the <code class="computeroutput"><span class="keyword">volatile</span></code> qualifier from a type by applying
            a <code class="computeroutput"><span class="keyword">const_cast</span></code>. If we manage
            to put these two operations together, we create a connection between
            C++'s type system and an application's threading semantics. We can make
            the compiler check race conditions for us.
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._locking_ptr_"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._locking_ptr_" title="locking_ptr"><code class="computeroutput"><span class="identifier">locking_ptr</span></code></a>
</h5></div></div></div>
<p>
            We need a tool that collects a mutex acquisition and a <code class="computeroutput"><span class="keyword">const_cast</span></code>. Let's develop a <code class="computeroutput"><span class="identifier">locking_ptr</span></code> class template that you
            initialize with a volatile object obj and a mutex mtx. During its lifetime,
            a <code class="computeroutput"><span class="identifier">locking_ptr</span></code> keeps
            <code class="computeroutput"><span class="identifier">mtx</span></code> acquired. Also,
            <code class="computeroutput"><span class="identifier">locking_ptr</span></code> offers access
            to the volatile-stripped obj. The access is offered in a smart pointer
            fashion, through operator-&gt; and operator*. The <code class="computeroutput"><span class="keyword">const_cast</span></code>
            is performed inside <code class="computeroutput"><span class="identifier">locking_ptr</span></code>.
            The cast is semantically valid because <code class="computeroutput"><span class="identifier">locking_ptr</span></code>
            keeps the mutex acquired for its lifetime. First, let's define the skeleton
            of a class <code class="computeroutput"><span class="identifier">mutex</span></code> with
            which <code class="computeroutput"><span class="identifier">locking_ptr</span></code> will
            work:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">mutex</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
            <code class="computeroutput"><span class="identifier">locking_ptr</span></code> is templated
            with the type of the controlled variable and the exclusive lockable type.
            For example, if you want to control a Widget, you use a <code class="computeroutput"><span class="identifier">locking_ptr</span><span class="special">&lt;</span><span class="identifier">Widget</span><span class="special">&gt;</span>
            <span class="identifier">that</span> <span class="identifier">you</span>
            <span class="identifier">initialize</span> <span class="identifier">with</span>
            <span class="identifier">a</span> <span class="identifier">variable</span>
            <span class="identifier">of</span> <span class="identifier">type</span>
            </code>volatile<code class="computeroutput"> <span class="identifier">Widget</span><span class="special">.</span> </code>locking_ptr<code class="computeroutput"> <span class="identifier">is</span>
            <span class="identifier">very</span> <span class="identifier">simple</span><span class="special">.</span> </code>locking_ptr<code class="computeroutput"> <span class="identifier">implements</span>
            <span class="identifier">an</span> <span class="identifier">unsophisticated</span>
            <span class="identifier">smart</span> <span class="identifier">pointer</span><span class="special">.</span> <span class="identifier">It</span> <span class="identifier">focuses</span> <span class="identifier">solely</span>
            <span class="identifier">on</span> <span class="identifier">collecting</span>
            <span class="identifier">a</span> </code>const_cast` and a critical
            section.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">locking_ptr</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Constructors/destructors
</span>    <span class="identifier">locking_ptr</span><span class="special">(</span><span class="keyword">volatile</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">mutex</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">obj_</span><span class="special">(*</span><span class="keyword">const_cast</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">*&gt;(&amp;</span><span class="identifier">obj</span><span class="special">)),</span>
            <span class="identifier">mtx_</span><span class="special">(</span><span class="identifier">mtx</span><span class="special">)</span>
    <span class="special">{</span>    <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>    <span class="special">}</span>
    <span class="special">~</span><span class="identifier">locking_ptr</span><span class="special">()</span>
    <span class="special">{</span>    <span class="identifier">mtx_</span><span class="special">-&gt;</span><span class="identifier">unlock</span><span class="special">();</span>    <span class="special">}</span>
    <span class="comment">// Pointer behavior
</span>    <span class="identifier">T</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">*()</span>
    <span class="special">{</span>    <span class="keyword">return</span> <span class="identifier">obj_</span><span class="special">;</span>    <span class="special">}</span>
    <span class="identifier">T</span><span class="special">*</span> <span class="keyword">operator</span><span class="special">-&gt;()</span>
    <span class="special">{</span>   <span class="keyword">return</span> <span class="special">&amp;</span><span class="identifier">obj_</span><span class="special">;</span>   <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="identifier">mutex</span><span class="special">&amp;</span> <span class="identifier">mtx_</span><span class="special">;</span>
    <span class="identifier">locking_ptr</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">locking_ptr</span><span class="special">&amp;);</span>
    <span class="identifier">locking_ptr</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <span class="identifier">locking_ptr</span><span class="special">&amp;);</span>
<span class="special">};</span>
</pre>
<p>
            In spite of its simplicity, <code class="computeroutput"><span class="identifier">locking_ptr</span></code>
            is a very useful aid in writing correct multi-threaded code. You should
            define objects that are shared between threads as volatile and never
            use <code class="computeroutput"><span class="keyword">const_cast</span></code> with them
            -- always use <code class="computeroutput"><span class="identifier">locking_ptr</span></code>
            automatic objects. Let's illustrate this with an example. Say you have
            two threads that share a vector&lt;char&gt; object:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">SynchroBuf</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Thread1</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">Thread2</span><span class="special">();</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">BufT</span><span class="special">;</span>
    <span class="keyword">volatile</span> <span class="identifier">BufT</span> <span class="identifier">buffer_</span><span class="special">;</span>
    <span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span> <span class="comment">// controls access to buffer_
</span><span class="special">};</span>
</pre>
<p>
            Inside a thread function, you simply use a <code class="computeroutput"><span class="identifier">locking_ptr</span><span class="special">&lt;</span><span class="identifier">BufT</span><span class="special">&gt;</span></code> to get controlled access to the
            <code class="computeroutput"><span class="identifier">buffer_</span></code> member variable:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">SynchroBuf</span><span class="special">::</span><span class="identifier">Thread1</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">locking_ptr</span><span class="special">&lt;</span><span class="identifier">BufT</span><span class="special">&gt;</span> <span class="identifier">lpBuf</span><span class="special">(</span><span class="identifier">buffer_</span><span class="special">,</span> <span class="identifier">mtx_</span><span class="special">);</span>
    <span class="identifier">BufT</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">lpBuf</span><span class="special">-&gt;</span><span class="identifier">begin</span><span class="special">();</span>
    <span class="keyword">for</span> <span class="special">(;</span> <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">lpBuf</span><span class="special">-&gt;</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="special">...</span> <span class="identifier">use</span> <span class="special">*</span><span class="identifier">i</span> <span class="special">...</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            The code is very easy to write and understand -- whenever you need to
            use <code class="computeroutput"><span class="identifier">buffer_</span></code>, you must
            create a <code class="computeroutput"><span class="identifier">locking_ptr</span><span class="special">&lt;</span><span class="identifier">BufT</span><span class="special">&gt;</span></code> pointing to it. Once you do that,
            you have access to vector's entire interface. The nice part is that if
            you make a mistake, the compiler will point it out:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">SynchroBuf</span><span class="special">::</span><span class="identifier">Thread2</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">// Error! Cannot access 'begin' for a volatile object
</span>    <span class="identifier">BufT</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">buffer_</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
    <span class="comment">// Error! Cannot access 'end' for a volatile object
</span>    <span class="keyword">for</span> <span class="special">(;</span> <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">lpBuf</span><span class="special">-&gt;</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="special">...</span> <span class="identifier">use</span> <span class="special">*</span><span class="identifier">i</span> <span class="special">...</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
            You cannot access any function of <code class="computeroutput"><span class="identifier">buffer_</span></code>
            until you either apply a <code class="computeroutput"><span class="keyword">const_cast</span></code>
            or use <code class="computeroutput"><span class="identifier">locking_ptr</span></code>. The
            difference is that <code class="computeroutput"><span class="identifier">locking_ptr</span></code>
            offers an ordered way of applying <code class="computeroutput"><span class="keyword">const_cast</span></code>
            to volatile variables. <code class="computeroutput"><span class="identifier">locking_ptr</span></code>
            is remarkably expressive. If you only need to call one function, you
            can create an unnamed temporary <code class="computeroutput"><span class="identifier">locking_ptr</span></code>
            object and use it directly:
          </p>
<pre class="programlisting"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">SynchroBuf</span><span class="special">::</span><span class="identifier">Size</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">locking_ptr</span><span class="special">&lt;</span><span class="identifier">BufT</span><span class="special">&gt;(</span><span class="identifier">buffer_</span><span class="special">,</span> <span class="identifier">mtx_</span><span class="special">)-&gt;</span><span class="identifier">size</span><span class="special">();</span>
<span class="special">}</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.back_to_primitive_types"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.back_to_primitive_types" title="Back
          to Primitive Types">Back
          to Primitive Types</a>
</h5></div></div></div>
<p>
            We saw how nicely <code class="computeroutput"><span class="keyword">volatile</span></code>
            protects objects against uncontrolled access and how <code class="computeroutput"><span class="identifier">locking_ptr</span></code>
            provides a simple and effective way of writing thread-safe code. Let's
            now return to primitive types, which are treated differently by <code class="computeroutput"><span class="keyword">volatile</span></code>. Let's consider an example where
            multiple threads share a variable of type int.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Counter</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="special">...</span>
    <span class="keyword">void</span> <span class="identifier">Increment</span><span class="special">()</span> <span class="special">{</span> <span class="special">++</span><span class="identifier">ctr_</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Decrement</span><span class="special">()</span> <span class="special">{</span> <span class="special">--</span><span class="identifier">ctr_</span><span class="special">;</span> <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">ctr_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            If Increment and Decrement are to be called from different threads, the
            fragment above is buggy. First, <code class="computeroutput"><span class="identifier">ctr_</span></code>
            must be volatile. Second, even a seemingly atomic operation such as
            <code class="computeroutput"><span class="special">++</span><span class="identifier">ctr_</span></code>
            is actually a three-stage operation. Memory itself has no arithmetic
            capabilities. When incrementing a variable, the processor:
          </p>
<div class="itemizedlist"><ul type="disc">
<li>
              Reads that variable in a register
            </li>
<li>
              Increments the value in the register
            </li>
<li>
              Writes the result back to memory
            </li>
</ul></div>
<p>
            This three-step operation is called RMW (Read-Modify-Write). During the
            Modify part of an RMW operation, most processors free the memory bus
            in order to give other processors access to the memory. If at that time
            another processor performs a RMW operation on the same variable, we have
            a race condition: the second write overwrites the effect of the first.
            To avoid that, you can rely, again, on <code class="computeroutput"><span class="identifier">locking_ptr</span></code>:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Counter</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="special">...</span>
    <span class="keyword">void</span> <span class="identifier">Increment</span><span class="special">()</span> <span class="special">{</span> <span class="special">++*</span><span class="identifier">locking_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;(</span><span class="identifier">ctr_</span><span class="special">,</span> <span class="identifier">mtx_</span><span class="special">);</span> <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Decrement</span><span class="special">()</span> <span class="special">{</span> <span class="special">--*</span><span class="identifier">locking_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;(</span><span class="identifier">ctr_</span><span class="special">,</span> <span class="identifier">mtx_</span><span class="special">);</span> <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="identifier">ctr_</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            Now the code is correct, but its quality is inferior when compared to
            SynchroBuf's code. Why? Because with Counter, the compiler will not warn
            you if you mistakenly access <code class="computeroutput"><span class="identifier">ctr_</span></code>
            directly (without locking it). The compiler compiles <code class="computeroutput"><span class="special">++</span><span class="identifier">ctr_</span></code> if <code class="computeroutput"><span class="identifier">ctr_</span></code>
            is volatile, although the generated code is simply incorrect. The compiler
            is not your ally anymore, and only your attention can help you avoid
            race conditions. What should you do then? Simply encapsulate the primitive
            data that you use in higher-level structures and use <code class="computeroutput"><span class="keyword">volatile</span></code>
            with those structures. Paradoxically, it's worse to use <code class="computeroutput"><span class="keyword">volatile</span></code> directly with built-ins, in spite
            of the fact that initially this was the usage intent of <code class="computeroutput"><span class="keyword">volatile</span></code>!
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._volatile__member_functions"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_._volatile__member_functions" title="volatile Member Functions"><code class="computeroutput"><span class="keyword">volatile</span></code> Member Functions</a>
</h5></div></div></div>
<p>
            So far, we've had classes that aggregate <code class="computeroutput"><span class="keyword">volatile</span></code>
            data members; now let's think of designing classes that in turn will
            be part of larger objects and shared between threads. Here is where
            <code class="computeroutput"><span class="keyword">volatile</span></code> member functions
            can be of great help. When designing your class, you volatile-qualify
            only those member functions that are thread safe. You must assume that
            code from the outside will call the volatile functions from any code
            at any time. Don't forget: <code class="computeroutput"><span class="keyword">volatile</span></code>
            equals free multi-threaded code and no critical section; non-volatile
            equals single-threaded scenario or inside a critical section. For example,
            you define a class Widget that implements an operation in two variants
            -- a thread-safe one and a fast, unprotected one.
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Widget</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Operation</span><span class="special">()</span> <span class="keyword">volatile</span><span class="special">;</span>
    <span class="keyword">void</span> <span class="identifier">Operation</span><span class="special">();</span>
    <span class="special">...</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            Notice the use of overloading. Now Widget's user can invoke Operation
            using a uniform syntax either for volatile objects and get thread safety,
            or for regular objects and get speed. The user must be careful about
            defining the shared Widget objects as <code class="computeroutput"><span class="keyword">volatile</span></code>.
            When implementing a <code class="computeroutput"><span class="keyword">volatile</span></code>
            member function, the first operation is usually to lock this with a
            <code class="computeroutput"><span class="identifier">locking_ptr</span></code>. Then the
            work is done by using the non-volatile sibling:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">Widget</span><span class="special">::</span><span class="identifier">Operation</span><span class="special">()</span> <span class="keyword">volatile</span>
<span class="special">{</span>
    <span class="identifier">locking_ptr</span><span class="special">&lt;</span><span class="identifier">Widget</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lpThis</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">mtx_</span><span class="special">);</span>
    <span class="identifier">lpThis</span><span class="special">-&gt;</span><span class="identifier">Operation</span><span class="special">();</span> <span class="comment">// invokes the non-volatile function
</span><span class="special">}</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.generic__locking_ptr_"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.generic__locking_ptr_" title="Generic
          locking_ptr">Generic
          <code class="computeroutput"><span class="identifier">locking_ptr</span></code></a>
</h5></div></div></div>
<p>
            The <code class="computeroutput"><span class="identifier">locking_ptr</span></code> works
            with a mutex class. How to use it with other mutexes? We can make a more
            generic <code class="computeroutput"><span class="identifier">locking_ptr</span></code> adding
            a Lockable template parameter.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">=</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">locking_ptr</span>  <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">value_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">lockable_type</span><span class="special">;</span>

    <span class="identifier">locking_ptr</span><span class="special">(</span><span class="keyword">volatile</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">mtx</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro31co" href="tutorial.html#boost.synchro31"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
        <span class="special">:</span> <span class="identifier">ptr_</span><span class="special">(</span><span class="keyword">const_cast</span><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">*&gt;(&amp;</span><span class="identifier">obj</span><span class="special">))</span> <span class="callout_bug"><a name="boost.synchro32co" href="tutorial.html#boost.synchro32"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>
        <span class="special">,</span> <span class="identifier">mtx_</span><span class="special">(</span><span class="identifier">mtx</span><span class="special">)</span>
    <span class="special">{</span>    <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>    <span class="special">}</span> <span class="callout_bug"><a name="boost.synchro33co" href="tutorial.html#boost.synchro33"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a></span>
    <span class="special">~</span><span class="identifier">locking_ptr</span><span class="special">()</span>
    <span class="special">{</span>    <span class="identifier">mtx_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>    <span class="special">}</span> <span class="callout_bug"><a name="boost.synchro34co" href="tutorial.html#boost.synchro34"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a></span>

    <span class="callout_bug"><a name="boost.synchro35co" href="tutorial.html#boost.synchro35"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a></span>
    <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">*()</span>
    <span class="special">{</span>    <span class="keyword">return</span> <span class="special">*</span><span class="identifier">ptr_</span><span class="special">;</span>    <span class="special">}</span>
    <span class="identifier">value_type</span><span class="special">*</span> <span class="keyword">operator</span><span class="special">-&gt;()</span>
    <span class="special">{</span>   <span class="keyword">return</span> <span class="identifier">ptr_</span><span class="special">;</span>   <span class="special">}</span>

    <span class="identifier">BOOST_DEFAULT_CONSTRUCTOR_DELETE</span><span class="special">(</span><span class="identifier">locking_ptr</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro36co" href="tutorial.html#boost.synchro36"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a></span>
    <span class="identifier">BOOST_COPY_CONSTRUCTOR_DELETE</span><span class="special">(</span><span class="identifier">locking_ptr</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro37co" href="tutorial.html#boost.synchro37"><img src="../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a></span>
    <span class="identifier">BOOST_COPY_ASSIGNEMENT_DELETE</span><span class="special">(</span><span class="identifier">locking_ptr</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro38co" href="tutorial.html#boost.synchro38"><img src="../../../../../../doc/src/images/callouts/8.png" alt="8" border="0"></a></span>
    
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">value_type</span><span class="special">*</span> <span class="identifier">ptr_</span><span class="special">;</span>
    <span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">mtx_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro31"></a><a href="#boost.synchro31co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> volatile </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro32"></a><a href="#boost.synchro32co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> const_cast </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro33"></a><a href="#boost.synchro33co"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> locks on construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro34"></a><a href="#boost.synchro34co"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </td>
<td valign="top" align="left"><p> unlocks on destruction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro35"></a><a href="#boost.synchro35co"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a> </td>
<td valign="top" align="left"><p> smart
              pointer related operations </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro36"></a><a href="#boost.synchro36co"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a> </td>
<td valign="top" align="left"><p> disable default construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro37"></a><a href="#boost.synchro37co"><img src="../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy
              construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro38"></a><a href="#boost.synchro38co"><img src="../../../../../../doc/src/images/callouts/8.png" alt="8" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy asignement </p></td>
</tr>
</table></div>
<p>
            </p>
<p>
          </p>
<p>
            Every model of the ExclusiveLockable concept can be used as parameter.
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.specific__locking_ptr__for_lockable_value_types"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial._volatile___and__locking_ptr_.specific__locking_ptr__for_lockable_value_types" title="Specific
          locking_ptr for lockable
          value types">Specific
          <code class="computeroutput"><span class="identifier">locking_ptr</span></code> for lockable
          value types</a>
</h5></div></div></div>
<p>
            When the value type is itself lockable we can simplify the <code class="computeroutput"><span class="identifier">locking_ptr</span></code> as follows:
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">locking_ptr_1</span>  <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">value_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">mutex_type</span><span class="special">;</span>

    <span class="identifier">locking_ptr_1</span><span class="special">(</span><span class="keyword">volatile</span> <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">)</span>
       <span class="special">:</span> <span class="identifier">ptr_</span><span class="special">(</span><span class="keyword">const_cast</span><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">*&gt;(&amp;</span><span class="identifier">obj</span><span class="special">))</span>
    <span class="special">{</span>    <span class="identifier">ptr_</span><span class="special">-&gt;</span><span class="identifier">lock</span><span class="special">();</span>    <span class="special">}</span>
    <span class="special">~</span><span class="identifier">locking_ptr_1</span><span class="special">()</span>
    <span class="special">{</span>    <span class="identifier">ptr_</span><span class="special">-&gt;</span><span class="identifier">unlock</span><span class="special">();</span>    <span class="special">}</span>

    <span class="identifier">value_type</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">*()</span>
    <span class="special">{</span>    <span class="keyword">return</span> <span class="special">*</span><span class="identifier">ptr_</span><span class="special">;</span>    <span class="special">}</span>
    <span class="identifier">value_type</span><span class="special">*</span> <span class="keyword">operator</span><span class="special">-&gt;()</span>
    <span class="special">{</span>   <span class="keyword">return</span> <span class="identifier">ptr_</span><span class="special">;</span>   <span class="special">}</span>

    <span class="identifier">BOOST_DEFAULT_CONSTRUCTOR_DELETE</span><span class="special">(</span><span class="identifier">locking_ptr_1</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro39co" href="tutorial.html#boost.synchro39"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
    <span class="identifier">BOOST_COPY_CONSTRUCTOR_DELETE</span><span class="special">(</span><span class="identifier">locking_ptr_1</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro40co" href="tutorial.html#boost.synchro40"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>
    <span class="identifier">BOOST_COPY_ASSIGNEMENT_DELETE</span><span class="special">(</span><span class="identifier">locking_ptr_1</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro41co" href="tutorial.html#boost.synchro41"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a></span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">value_type</span><span class="special">*</span> <span class="identifier">ptr_</span><span class="special">;</span> <span class="callout_bug"><a name="boost.synchro42co" href="tutorial.html#boost.synchro42"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a></span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro39"></a><a href="#boost.synchro39co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> disable default construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro40"></a><a href="#boost.synchro40co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro41"></a><a href="#boost.synchro41co"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy
              asignement </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro42"></a><a href="#boost.synchro42co"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </td>
<td valign="top" align="left"><p> only one pointer needed </p></td>
</tr>
</table></div>
<p>
            </p>
<p>
          </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes" title="External
        Locking -- strict_locker
        and externally_locked classes">External
        Locking -- <code class="computeroutput"><span class="identifier">strict_locker</span></code>
        and <code class="computeroutput"><span class="identifier">externally_locked</span></code> classes</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.locks_as_permits">Locks
          as Permits</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.improving_external_locking">Improving
          External Locking</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.allowing_other_strict_lockers">Allowing
          other strict lockers</a></span></dt>
</dl></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            This tutorial is an adaptation of the paper of Andrei Alexandrescu "Multithreading
            and the C++ Type System" to the Boost library.
          </p></td></tr>
</table></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.locks_as_permits"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.locks_as_permits" title="Locks
          as Permits">Locks
          as Permits</a>
</h5></div></div></div>
<p>
            So what to do? Ideally, the BankAccount class should do the following:
          </p>
<div class="itemizedlist"><ul type="disc">
<li>
              Support both locking models (internal and external).
            </li>
<li>
              Be efficient; that is, use no unnecessary locking.
            </li>
<li>
              Be safe; that is, BankAccount objects cannot be manipulated without
              appropriate locking.
            </li>
</ul></div>
<p>
            Let's make a worthwhile observation: Whenever you lock a BankAccount,
            you do so by using a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object. Turning this statement around,
            wherever there's a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>, there's also a locked <code class="computeroutput"><span class="identifier">BankAccount</span></code> somewhere. Thus, you can
            think of-and use-a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object as a permit. Owning a <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            gives you rights to do certain things. The <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> object should not be copied or aliased
            (it's not a transmissible permit).
          </p>
<div class="orderedlist"><ol type="1">
<li>
              As long as a permit is still alive, the <code class="computeroutput"><span class="identifier">BankAccount</span></code>
              object stays locked.
            </li>
<li>
              When the <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> is destroyed, the <code class="computeroutput"><span class="identifier">BankAccount</span></code>'s mutex is released.
            </li>
</ol></div>
<p>
            The net effect is that at any point in your code, having access to a
            <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            object guarantees that a <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            is locked. (You don't know exactly which <code class="computeroutput"><span class="identifier">BankAccount</span></code>
            is locked, however-an issue that we'll address soon.)
          </p>
<p>
            For now, let's make a couple of enhancements to the <code class="computeroutput"><span class="identifier">lock_guard</span></code>
            class template defined in Boost.Thread. We'll call the enhanced version
            <code class="computeroutput"><span class="identifier">strict_locker</span></code>. Essentially,
            a <code class="computeroutput"><span class="identifier">strict_locker</span></code>'s role
            is only to live on the stack as an automatic variable. <code class="computeroutput"><span class="identifier">strict_locker</span></code> must adhere to a non-copy
            and non-alias policy. <code class="computeroutput"><span class="identifier">strict_locker</span></code>
            disables copying by making the copy constructor and the assignment operator
            private. While we're at it, let's disable operator new and operator delete;
            <code class="computeroutput"><span class="identifier">strict_locker</span></code> are not
            intended to be allocated on the heap. <code class="computeroutput"><span class="identifier">strict_locker</span></code>
            avoids aliasing by using a slightly less orthodox and less well-known
            technique: disable address taking.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">strict_locker</span>
<span class="special">{</span>

      <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">LockableConcept</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;));</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">Lockable</span> <span class="identifier">lockable_type</span><span class="special">;</span>
    <span class="keyword">explicit</span> <span class="identifier">strict_locker</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">obj_</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">obj</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span> <span class="special">}</span> <span class="callout_bug"><a name="boost.synchro49co" href="tutorial.html#boost.synchro49"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
    <span class="special">~</span><span class="identifier">strict_locker</span><span class="special">()</span> <span class="special">{</span> <span class="identifier">obj_</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span> <span class="special">}</span> <span class="callout_bug"><a name="boost.synchro50co" href="tutorial.html#boost.synchro50"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>

    <span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="special">(</span><span class="identifier">strict_locker</span><span class="special">::*</span><span class="identifier">bool_type</span><span class="special">)()</span> <span class="keyword">const</span><span class="special">;</span> <span class="callout_bug"><a name="boost.synchro51co" href="tutorial.html#boost.synchro51"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a></span>
    <span class="keyword">operator</span> <span class="identifier">bool_type</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="special">&amp;</span><span class="identifier">strict_locker</span><span class="special">::</span><span class="identifier">owns_lock</span><span class="special">;</span>  <span class="special">}</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span> <span class="special">}</span> <span class="callout_bug"><a name="boost.synchro52co" href="tutorial.html#boost.synchro52"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a></span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">const</span> <span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="special">&amp;</span><span class="identifier">obj_</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">is_locking</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">l</span><span class="special">==</span><span class="identifier">mutex</span><span class="special">();</span> <span class="special">}</span> <span class="callout_bug"><a name="boost.synchro53co" href="tutorial.html#boost.synchro53"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a></span>


    <span class="identifier">BOOST_ADRESS_OF_DELETE</span><span class="special">(</span><span class="identifier">strict_locker</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro54co" href="tutorial.html#boost.synchro54"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a></span>
    <span class="identifier">BOOST_HEAP_ALLOCATEION_DELETE</span><span class="special">(</span><span class="identifier">strict_locker</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro55co" href="tutorial.html#boost.synchro55"><img src="../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a></span>
    <span class="identifier">BOOST_DEFAULT_CONSTRUCTOR_DELETE</span><span class="special">(</span><span class="identifier">strict_locker</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro56co" href="tutorial.html#boost.synchro56"><img src="../../../../../../doc/src/images/callouts/8.png" alt="8" border="0"></a></span>
    <span class="identifier">BOOST_COPY_CONSTRUCTOR_DELETE</span><span class="special">(</span><span class="identifier">strict_locker</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro57co" href="tutorial.html#boost.synchro57"><img src="../../../../../../doc/src/images/callouts/9.png" alt="9" border="0"></a></span>
    <span class="identifier">BOOST_COPY_ASSIGNEMENT_DELETE</span><span class="special">(</span><span class="identifier">strict_locker</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro58co" href="tutorial.html#boost.synchro58"><img src="../../../../../../doc/src/images/callouts/10.png" alt="10" border="0"></a></span>

    <span class="callout_bug"><a name="boost.synchro59co" href="tutorial.html#boost.synchro59"><img src="../../../../../../doc/src/images/callouts/11.png" alt="11" border="0"></a></span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">lockable_type</span><span class="special">&amp;</span> <span class="identifier">obj_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro49"></a><a href="#boost.synchro49co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> locks on construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro50"></a><a href="#boost.synchro50co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> unlocks on destruction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro51"></a><a href="#boost.synchro51co"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> safe bool idiom </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro52"></a><a href="#boost.synchro52co"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </td>
<td valign="top" align="left"><p> always
              owned </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro53"></a><a href="#boost.synchro53co"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a> </td>
<td valign="top" align="left"><p> strict lockers specific function </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro54"></a><a href="#boost.synchro54co"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a> </td>
<td valign="top" align="left"><p> disable aliasing </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro55"></a><a href="#boost.synchro55co"><img src="../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a> </td>
<td valign="top" align="left"><p> disable heap
              allocation </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro56"></a><a href="#boost.synchro56co"><img src="../../../../../../doc/src/images/callouts/8.png" alt="8" border="0"></a> </td>
<td valign="top" align="left"><p> disable default construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro57"></a><a href="#boost.synchro57co"><img src="../../../../../../doc/src/images/callouts/9.png" alt="9" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro58"></a><a href="#boost.synchro58co"><img src="../../../../../../doc/src/images/callouts/10.png" alt="10" border="0"></a> </td>
<td valign="top" align="left"><p> disable
              copy asignement </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro59"></a><a href="#boost.synchro59co"><img src="../../../../../../doc/src/images/callouts/11.png" alt="11" border="0"></a> </td>
<td valign="top" align="left"><p> no possibility to unlock </p></td>
</tr>
</table></div>
<p>
            </p>
<p>
          </p>
<p>
            Silence can be sometimes louder than words-what's forbidden to do with
            a <code class="computeroutput"><span class="identifier">strict_locker</span></code> is as
            important as what you can do. Let's see what you can and what you cannot
            do with a <code class="computeroutput"><span class="identifier">strict_locker</span></code>
            instantiation:
          </p>
<div class="itemizedlist"><ul type="disc"><li>
              You can create a <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> only starting from a valid T object.
              Notice that there is no other way you can create a <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>.
            </li></ul></div>
<pre class="programlisting"><span class="identifier">BankAccount</span> <span class="identifier">myAccount</span><span class="special">(</span><span class="string">"John Doe"</span><span class="special">,</span> <span class="string">"123-45-6789"</span><span class="special">);</span>
<span class="identifier">strict_locerk</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">myLock</span><span class="special">(</span><span class="identifier">myAccount</span><span class="special">);</span> <span class="comment">// ok
</span></pre>
<div class="itemizedlist"><ul type="disc"><li>
              You cannot copy <code class="computeroutput"><span class="identifier">strict_locker</span></code>s
              to one another. In particular, you cannot pass <code class="computeroutput"><span class="identifier">strict_locker</span></code>s
              by value to functions or have them returned by functions:
            </li></ul></div>
<pre class="programlisting"><span class="keyword">extern</span> <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">Foo</span><span class="special">();</span> <span class="comment">// compile-time error
</span><span class="keyword">extern</span> <span class="keyword">void</span> <span class="identifier">Bar</span><span class="special">(</span><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;);</span> <span class="comment">// compile-time error
</span></pre>
<div class="itemizedlist"><ul type="disc"><li>
              However, you still can pass <code class="computeroutput"><span class="identifier">strict_locker</span></code>s
              by reference to and from functions:
            </li></ul></div>
<pre class="programlisting"><span class="comment">// ok, Foo returns a reference to strict_locker&lt;BankAccount&gt;
</span><span class="keyword">extern</span> <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;</span> <span class="identifier">Foo</span><span class="special">();</span>
<span class="comment">// ok, Bar takes a reference to strict_locker&lt;BankAccount&gt;
</span><span class="keyword">extern</span> <span class="keyword">void</span> <span class="identifier">Bar</span><span class="special">(</span><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;);</span>
</pre>
<div class="itemizedlist"><ul type="disc"><li>
              You cannot allocate a <code class="computeroutput"><span class="identifier">strict_locker</span></code>
              on the heap. However, you still can put <code class="computeroutput"><span class="identifier">strict_locker</span></code>s
              on the heap if they're members of a class.
            </li></ul></div>
<pre class="programlisting"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;*</span> <span class="identifier">pL</span> <span class="special">=</span>
    <span class="keyword">new</span> <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;(</span><span class="identifier">myAcount</span><span class="special">);</span> <span class="comment">//error!
</span>    <span class="comment">// operator new is not accessible
</span><span class="keyword">class</span> <span class="identifier">Wrapper</span> <span class="special">{</span>
    <span class="identifier">strict_locker</span> <span class="identifier">memberLock_</span><span class="special">;</span>
    <span class="special">...</span>
<span class="special">};</span>
<span class="identifier">Wrapper</span><span class="special">*</span> <span class="identifier">pW</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Wrapper</span><span class="special">;</span> <span class="comment">// ok
</span></pre>
<p>
            (Making <code class="computeroutput"><span class="identifier">strict_locker</span></code>
            a member variable of a class is not recommended. Fortunately, disabling
            copying and default construction makes <code class="computeroutput"><span class="identifier">strict_locker</span></code>
            quite an unfriendly member variable.)
          </p>
<div class="itemizedlist"><ul type="disc"><li>
              You cannot take the address of a <code class="computeroutput"><span class="identifier">strict_locker</span></code>
              object. This interesting feature, implemented by disabling unary operator&amp;,
              makes it very unlikely to alias a <code class="computeroutput"><span class="identifier">strict_locker</span></code>
              object. Aliasing is still possible by taking references to a <code class="computeroutput"><span class="identifier">strict_locker</span></code>:
            </li></ul></div>
<pre class="programlisting"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">myLock</span><span class="special">(</span><span class="identifier">myAccount</span><span class="special">);</span> <span class="comment">// ok
</span><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;*</span> <span class="identifier">pAlias</span> <span class="special">=</span> <span class="special">&amp;</span><span class="identifier">myLock</span><span class="special">;</span> <span class="comment">// error!
</span>    <span class="comment">// strict_locker&lt;BankAccount&gt;::operator&amp; is not accessible
</span><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;</span> <span class="identifier">rAlias</span> <span class="special">=</span> <span class="identifier">myLock</span><span class="special">;</span> <span class="comment">// ok
</span></pre>
<p>
            Fortunately, references don't engender as bad aliasing as pointers because
            they're much less versatile (references cannot be copied or reseated).
          </p>
<div class="itemizedlist"><ul type="disc"><li>
              You can even make <code class="computeroutput"><span class="identifier">strict_locker</span></code>
              final; that is, impossible to derive from. This task is left in the
              form of an exercise to the reader.
            </li></ul></div>
<p>
            All these rules were put in place with one purpose-enforcing that owning
            a <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
            is a reasonably strong guarantee that
          </p>
<div class="orderedlist"><ol type="1">
<li>
              you locked a T object, and
            </li>
<li>
              that object will be unlocked at a later point.
            </li>
</ol></div>
<p>
            Now that we have such a strict <code class="computeroutput"><span class="identifier">strict_locker</span></code>,
            how do we harness its power in defining a safe, flexible interface for
            BankAccount? The idea is as follows:
          </p>
<div class="itemizedlist"><ul type="disc">
<li>
              Each of BankAccount's interface functions (in our case, Deposit and
              Withdraw) comes in two overloaded variants.
            </li>
<li>
              One version keeps the same signature as before, and the other takes
              an additional argument of type <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>. The first version is internally
              locked; the second one requires external locking. External locking
              is enforced at compile time by requiring client code to create a <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
              object.
            </li>
<li>
              BankAccount avoids code bloating by having the internal locked functions
              forward to the external locked functions, which do the actual job.
            </li>
</ul></div>
<p>
            A little code is worth 1,000 words, a (hacked into) saying goes, so here's
            the new BankAccount class:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">exclusive_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">:</span><span class="identifier">recursive_mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span> <span class="special">{</span>
        <span class="comment">// Externally locked
</span>        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">:</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span> <span class="comment">// Internally locked
</span>        <span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span> <span class="special">{</span>
        <span class="comment">// Externally locked
</span>        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">:</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span> <span class="comment">// Internally locked
</span>        <span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Now, if you want the benefit of internal locking, you simply call Deposit(int)
            and Withdraw(int). If you want to use external locking, you lock the
            object by constructing a <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> and then you call <code class="computeroutput"><span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span>
            <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>
            and <code class="computeroutput"><span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>.
            For example, here's the <code class="computeroutput"><span class="identifier">ATMWithdrawal</span></code>
            function implemented correctly:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">acct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            This function has the best of both worlds-it's reasonably safe and efficient
            at the same time.
          </p>
<p>
            It's worth noting that <code class="computeroutput"><span class="identifier">strict_locker</span></code>
            being a template gives extra safety compared to a straight polymorphic
            approach. In such a design, BankAccount would derive from a Lockable
            interface. <code class="computeroutput"><span class="identifier">strict_locker</span></code>
            would manipulate Lockable references so there's no need for templates.
            This approach is sound; however, it provides fewer compile-time guarantees.
            Having a <code class="computeroutput"><span class="identifier">strict_locker</span></code>
            object would only tell that some object derived from Lockable is currently
            locked. In the templated approach, having a <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code> gives a stronger guarantee-it's a
            <code class="computeroutput"><span class="identifier">BankAccount</span></code> that stays
            locked.
          </p>
<p>
            There's a weasel word in there-I mentioned that ATMWithdrawal is reasonably
            safe. It's not really safe because there's no enforcement that the <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span></code>
            object locks the appropriate BankAccount object. The type system only
            ensures that some BankAccount object is locked. For example, consider
            the following phony implementation of ATMWithdrawal:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">ATMWithdrawal</span><span class="special">(</span><span class="identifier">BankAccount</span><span class="special">&amp;</span> <span class="identifier">acct</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">BankAccount</span> <span class="identifier">fakeAcct</span><span class="special">(</span><span class="string">"John Doe"</span><span class="special">,</span> <span class="string">"123-45-6789"</span><span class="special">);</span>
    <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">fakeAcct</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">sum</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
    <span class="identifier">acct</span><span class="special">.</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="number">2</span><span class="special">,</span> <span class="identifier">guard</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            This code compiles warning-free but obviously doesn't do the right thing-it
            locks one account and uses another.
          </p>
<p>
            It's important to understand what can be enforced within the realm of
            the C++ type system and what needs to be enforced at runtime. The mechanism
            we've put in place so far ensures that some BankAccount object is locked
            during the call to <code class="computeroutput"><span class="identifier">BankAccount</span><span class="special">::</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span>
            <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;)</span></code>.
            We must enforce at runtime exactly what object is locked.
          </p>
<p>
            If our scheme still needs runtime checks, how is it useful? An unwary
            or malicious programmer can easily lock the wrong object and manipulate
            any BankAccount without actually locking it.
          </p>
<p>
            First, let's get the malice issue out of the way. C is a language that
            requires a lot of attention and discipline from the programmer. C++ made
            some progress by asking a little less of those, while still fundamentally
            trusting the programmer. These languages are not concerned with malice
            (as Java is, for example). After all, you can break any C/C++ design
            simply by using casts "appropriately" (if appropriately is
            an, er, appropriate word in this context).
          </p>
<p>
            The scheme is useful because the likelihood of a programmer forgetting
            about any locking whatsoever is much greater than the likelihood of a
            programmer who does remember about locking, but locks the wrong object.
          </p>
<p>
            Using <code class="computeroutput"><span class="identifier">strict_locker</span></code> permits
            compile-time checking of the most common source of errors, and runtime
            checking of the less frequent problem.
          </p>
<p>
            Let's see how to enforce that the appropriate BankAccount object is locked.
            First, we need to add a member function to the <code class="computeroutput"><span class="identifier">strict_locker</span></code>
            class template. The <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">get_lockable</span></code>
            function returns a reference to the locked object.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">class</span> <span class="identifier">strict_locker</span> <span class="special">{</span>
    <span class="special">...</span> <span class="identifier">as</span> <span class="identifier">before</span> <span class="special">...</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">T</span><span class="special">*</span> <span class="identifier">get_lockable</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="special">&amp;</span><span class="identifier">obj_</span><span class="special">;</span> <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Second, BankAccount needs to compare the locked object against this:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">exclusive_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span><span class="special">&gt;</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">,</span> <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">&gt;&amp;</span> <span class="identifier">guard</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Externally locked
</span>        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">guard</span><span class="special">.</span><span class="identifier">is_locking</span><span class="special">(*</span><span class="keyword">this</span><span class="special">))</span>
            <span class="keyword">throw</span> <span class="string">"Locking Error: Wrong Object Locked"</span><span class="special">;</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
            The overhead incurred by the test above is much lower than locking a
            recursive mutex for the second time.
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.improving_external_locking"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.improving_external_locking" title="Improving
          External Locking">Improving
          External Locking</a>
</h5></div></div></div>
<p>
            Now let's assume that BankAccount doesn't use its own locking at all,
            and has only a thread-neutral implementation:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">BankAccount</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">balance_</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">Deposit</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">+=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">Withdraw</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">balance_</span> <span class="special">-=</span> <span class="identifier">amount</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
            Now you can use BankAccount in single-threaded and multi-threaded applications
            alike, but you need to provide your own synchronization in the latter
            case.
          </p>
<p>
            Say we have an AccountManager class that holds and manipulates a BankAccount
            object:
          </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">AccountManager</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">exclusive_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="identifier">BankAccount</span> <span class="identifier">checkingAcct_</span><span class="special">;</span>
    <span class="identifier">BankAccount</span> <span class="identifier">savingsAcct_</span><span class="special">;</span>
    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
            Let's also assume that, by design, AccountManager must stay locked while
            accessing its BankAccount members. The question is, how can we express
            this design constraint using the C++ type system? How can we state "You
            have access to this BankAccount object only after locking its parent
            AccountManager object"?
          </p>
<p>
            The solution is to use a little bridge template <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            that controls access to a BankAccount.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span>  <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked</span> <span class="special">{</span>
    <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">LockableConcept</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;));</span>

<span class="comment">//    
</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">syntactic_lock_traits</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;::</span><span class="identifier">lock_error</span> <span class="identifier">lock_error</span><span class="special">;</span> <span class="callout_bug"><a name="boost.synchro24co" href="tutorial.html#boost.synchro24"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">obj_</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span>
        <span class="special">,</span> <span class="identifier">lockable_</span><span class="special">(</span><span class="identifier">lockable</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="identifier">externally_locked</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">obj_</span><span class="special">()</span>
        <span class="special">,</span> <span class="identifier">lockable_</span><span class="special">(</span><span class="identifier">lockable</span><span class="special">)</span>
    <span class="special">{}</span>

    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;</span> <span class="identifier">locker</span><span class="special">)</span> <span class="special">{</span>

<span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_SYNCHRO_EXTERNALLY_LOCKED_DONT_CHECK_SAME</span>  <span class="callout_bug"><a name="boost.synchro25co" href="tutorial.html#boost.synchro25"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">locker</span><span class="special">.</span><span class="identifier">is_locking</span><span class="special">(&amp;</span><span class="identifier">lockable_</span><span class="special">))</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span> <span class="callout_bug"><a name="boost.synchro26co" href="tutorial.html#boost.synchro26"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a></span>
<span class="preprocessor">#endif</span>
        <span class="keyword">return</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">void</span> <span class="identifier">set</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">obj_</span> <span class="special">=</span> <span class="identifier">obj</span><span class="special">;</span>
        <span class="identifier">lockable_</span><span class="special">=</span><span class="identifier">lockable</span><span class="special">;</span>
    <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">T</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">lockable_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro24"></a><a href="#boost.synchro24co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> needed until Boost Thread and Interprocess unify the exceptions </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro25"></a><a href="#boost.synchro25co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> define
              BOOST_SYNCHRO_EXTERNALLY_LOCKED_DONT_CHECK_SAME if you don't want to
              check locker check the same lockable </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro26"></a><a href="#boost.synchro26co"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> run time check throw if not locks
              the same </p></td>
</tr>
</table></div>
<p>
            </p>
<p>
          </p>
<p>
            <code class="computeroutput"><span class="identifier">externally_locked</span></code> cloaks
            an object of type T, and actually provides full access to that object
            through the get and set member functions, provided you pass a reference
            to a <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">Owner</span><span class="special">&gt;</span></code>
            object.
          </p>
<p>
            Instead of making <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>
            and <code class="computeroutput"><span class="identifier">savingsAcct_</span></code> of type
            <code class="computeroutput"><span class="identifier">BankAccount</span></code>, <code class="computeroutput"><span class="identifier">AccountManager</span></code> holds objects of type
            <code class="computeroutput"><span class="identifier">externally_locked</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span>
            <span class="identifier">AccountManager</span><span class="special">&gt;</span></code>:
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">AccountManager</span>
    <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">exclusive_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">thread_mutex</span><span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">exclusive_lockable_adapter</span><span class="special">&lt;</span><span class="identifier">thread_mutex</span><span class="special">&gt;</span> <span class="identifier">lockable_base_type</span><span class="special">;</span>
    <span class="identifier">AccountManager</span><span class="special">()</span>
        <span class="special">:</span> <span class="identifier">checkingAcct_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span>
        <span class="special">,</span> <span class="identifier">savingsAcct_</span><span class="special">(*</span><span class="keyword">this</span><span class="special">)</span>
    <span class="special">{}</span>
    <span class="keyword">void</span> <span class="identifier">Checking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">);</span>
<span class="keyword">private</span><span class="special">:</span>
    
    <span class="identifier">externally_locked_any</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span> <span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">checkingAcct_</span><span class="special">;</span>
    <span class="identifier">externally_locked_any</span><span class="special">&lt;</span><span class="identifier">BankAccount</span><span class="special">,</span> <span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">savingsAcct_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
          </p>
<p>
            The pattern is the same as before-to access the BankAccount object cloaked
            by <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>, you
            need to call <code class="computeroutput"><span class="identifier">get</span></code>. To
            call <code class="computeroutput"><span class="identifier">get</span></code>, you need to
            pass it a <code class="computeroutput"><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span></code>. The one thing you have to take care
            of is to not hold pointers or references you obtained by calling <code class="computeroutput"><span class="identifier">get</span></code>. If you do that, make sure that
            you don't use them after the strict_locker has been destroyed. That is,
            if you alias the cloaked objects, you're back from "the compiler
            takes care of that" mode to "you must pay attention" mode.
          </p>
<p>
            Typically, you use <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            as shown below. Suppose you want to execute an atomic transfer from your
            checking account to your savings account:
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">Checking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
          </p>
<p>
            We achieved two important goals. First, the declaration of <code class="computeroutput"><span class="identifier">checkingAcct_</span></code> and <code class="computeroutput"><span class="identifier">savingsAcct_</span></code>
            makes it clear to the code reader that that variable is protected by
            a lock on an AccountManager. Second, the design makes it impossible to
            manipulate the two accounts without actually locking a BankAccount.
            <code class="computeroutput"><span class="identifier">externally_locked</span></code> is
            what could be called active documentation.
          </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.allowing_other_strict_lockers"></a><a href="tutorial.html#boost_synchro.users_guide.tutorial.external_locking_____strict_locker__and__externally_locked__classes.allowing_other_strict_lockers" title="Allowing
          other strict lockers">Allowing
          other strict lockers</a>
</h5></div></div></div>
<p>
            Now imagine that the AccountManager function needs to take a <code class="computeroutput"><span class="identifier">unique_lock</span></code> in order to reduce the
            critical regions. And at some time it needs to access to the <code class="computeroutput"><span class="identifier">checkingAcct_</span></code>. As <code class="computeroutput"><span class="identifier">unique_lock</span></code>
            is not a strict lock the following code do not compiles:
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
          </p>
<p>
            We need a way to transfer the ownership from the <code class="computeroutput"><span class="identifier">unique_lock</span></code>
            to a <code class="computeroutput"><span class="identifier">strict_locker</span></code> the
            time we are working with <code class="computeroutput"><span class="identifier">savingsAcct_</span></code>
            and then restore the ownership on <code class="computeroutput"><span class="identifier">unique_lock</span></code>.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard1</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="special">{</span>
        <span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">guard1</span><span class="special">);</span>
        <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
        <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
          </p>
<p>
            In order to make this code compilable we need to store either a Lockable
            or a <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span></code>
            reference depending on the constructor. Store which kind of reference
            we have stored,and in the destructor call either to the Lockable <code class="computeroutput"><span class="identifier">unlock</span></code> or restore the ownership.
          </p>
<p>
            This seams too complicated to me. Another possibility is to define a
            nested strict locker class. The drawback is that instead of having only
            one strict locker we have two and we need either to duplicate every function
            taking a <code class="computeroutput"><span class="identifier">strict</span><span class="special">\</span><span class="identifier">_lock</span></code> or make these function templates
            functions. The problem with template functions is that we don't profit
            anymore of the C++ type system. We must add some static metafunction
            that check that the Locker parameter is a strict locker. The problem
            is that we can not really check this or can we?. The <code class="computeroutput"><span class="identifier">is_strict_locker</span></code>
            metafunction must be specialized by the strict locker developer. We need
            to belive it "sur parolle". The advantage is that now we can
            manage with more than two strict lockers without changing our code. Ths
            is really nice.
          </p>
<p>
            Now we need to state that both classes are <code class="computeroutput"><span class="identifier">strict_locker</span></code>s.
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_locker</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">false_</span> <span class="special">{};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_locker</span><span class="special">&lt;</span><span class="identifier">strict_locker</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span> <span class="special">{}</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_strict_locker</span><span class="special">&lt;</span><span class="identifier">nested_strict_locker</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">true_</span> <span class="special">{}</span>
</pre>
<p>
            Well let me show how this <code class="computeroutput"><span class="identifier">nested_strict_locker</span></code>
            class looks like and the impacts on the <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            class and the <code class="computeroutput"><span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedFunction</span></code>
            function.
          </p>
<p>
            First <code class="computeroutput"><span class="identifier">nested_strict_locker</span></code>
            class will store on a temporary lock the <code class="computeroutput"><span class="identifier">Locker</span></code>,
            and transfer the lock ownership on the constructor. On destruction he
            will restore the ownership. Note also that the Locker needs to have already
            a reference to the mutex otherwise an exception is thrown and the use
            of the <code class="computeroutput"><span class="identifier">locker_traits</span></code>.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Locker</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">nested_strict_locker</span>
    <span class="special">{</span>
      <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">MovableLockerConcept</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;));</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">lockable_type</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">lockable_type</span><span class="special">;</span> <span class="callout_bug"><a name="boost.synchro60co" href="tutorial.html#boost.synchro60"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">syntactic_lock_traits</span><span class="special">&lt;</span><span class="identifier">lockable_type</span><span class="special">&gt;::</span><span class="identifier">lock_error</span> <span class="identifier">lock_error</span><span class="special">;</span>

    <span class="identifier">nested_strict_locker</span><span class="special">(</span><span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">locker</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">locker_</span><span class="special">(</span><span class="identifier">locker</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro61co" href="tutorial.html#boost.synchro61"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>
        <span class="special">,</span> <span class="identifier">tmp_locker_</span><span class="special">(</span><span class="identifier">locker</span><span class="special">.</span><span class="identifier">move</span><span class="special">())</span> <span class="callout_bug"><a name="boost.synchro62co" href="tutorial.html#boost.synchro62"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a></span>
    <span class="special">{</span>
        <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_SYNCHRO_STRCIT_LOCKER_DONT_CHECK_OWNERSHIP</span>  <span class="callout_bug"><a name="boost.synchro63co" href="tutorial.html#boost.synchro63"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a></span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">tmp_locker_</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()==</span><span class="number">0</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">locker_</span><span class="special">=</span><span class="identifier">tmp_locker_</span><span class="special">.</span><span class="identifier">move</span><span class="special">();</span> <span class="callout_bug"><a name="boost.synchro64co" href="tutorial.html#boost.synchro64"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a></span>
            <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span>
        <span class="special">}</span>
        <span class="preprocessor">#endif</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">tmp_locker_</span><span class="special">)</span> <span class="identifier">tmp_locker_</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span> <span class="callout_bug"><a name="boost.synchro65co" href="tutorial.html#boost.synchro65"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a></span>
    <span class="special">}</span>
    <span class="special">~</span><span class="identifier">nested_strict_locker</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">locker_</span><span class="special">=</span><span class="identifier">tmp_locker_</span><span class="special">.</span><span class="identifier">move</span><span class="special">();</span> <span class="callout_bug"><a name="boost.synchro66co" href="tutorial.html#boost.synchro66"><img src="../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a></span>
    <span class="special">}</span>
    <span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="special">(</span><span class="identifier">nested_strict_locker</span><span class="special">::*</span><span class="identifier">bool_type</span><span class="special">)()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">operator</span> <span class="identifier">bool_type</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="special">&amp;</span><span class="identifier">nested_strict_locker</span><span class="special">::</span><span class="identifier">owns_lock</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">false</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">const</span> <span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">tmp_locker_</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">();</span> <span class="special">}</span>
    <span class="keyword">bool</span> <span class="identifier">is_locking</span><span class="special">(</span><span class="identifier">lockable_type</span><span class="special">*</span> <span class="identifier">l</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">l</span><span class="special">==</span><span class="identifier">mutex</span><span class="special">();</span> <span class="special">}</span>

    <span class="identifier">BOOST_ADRESS_OF_DELETE</span><span class="special">(</span><span class="identifier">nested_strict_locker</span><span class="special">)</span>
    <span class="identifier">BOOST_HEAP_ALLOCATEION_DELETE</span><span class="special">(</span><span class="identifier">nested_strict_locker</span><span class="special">)</span>
    <span class="identifier">BOOST_DEFAULT_CONSTRUCTOR_DELETE</span><span class="special">(</span><span class="identifier">nested_strict_locker</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro67co" href="tutorial.html#boost.synchro67"><img src="../../../../../../doc/src/images/callouts/8.png" alt="8" border="0"></a></span>
    <span class="identifier">BOOST_COPY_CONSTRUCTOR_DELETE</span><span class="special">(</span><span class="identifier">nested_strict_locker</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro68co" href="tutorial.html#boost.synchro68"><img src="../../../../../../doc/src/images/callouts/9.png" alt="9" border="0"></a></span>
    <span class="identifier">BOOST_COPY_ASSIGNEMENT_DELETE</span><span class="special">(</span><span class="identifier">nested_strict_locker</span><span class="special">)</span> <span class="callout_bug"><a name="boost.synchro69co" href="tutorial.html#boost.synchro69"><img src="../../../../../../doc/src/images/callouts/10.png" alt="10" border="0"></a></span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">locker_</span><span class="special">;</span>
    <span class="identifier">Locker</span> <span class="identifier">tmp_locker_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro60"></a><a href="#boost.synchro60co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> Name the lockable type locked by Locker </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro61"></a><a href="#boost.synchro61co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> Store reference to locker </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro62"></a><a href="#boost.synchro62co"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> Move
              ownership to temporaty locker </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro63"></a><a href="#boost.synchro63co"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </td>
<td valign="top" align="left"><p> Define BOOST_SYNCHRO_EXTERNALLY_LOCKED_DONT_CHECK_OWNERSHIP
              if you don't want to check locker ownership </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro64"></a><a href="#boost.synchro64co"><img src="../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a> </td>
<td valign="top" align="left"><p> Rollback for coherency
              purposes </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro65"></a><a href="#boost.synchro65co"><img src="../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a> </td>
<td valign="top" align="left"><p> ensures it is locked </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro66"></a><a href="#boost.synchro66co"><img src="../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a> </td>
<td valign="top" align="left"><p> Move ownership to nesting locker </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro67"></a><a href="#boost.synchro67co"><img src="../../../../../../doc/src/images/callouts/8.png" alt="8" border="0"></a> </td>
<td valign="top" align="left"><p> disable
              default construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro68"></a><a href="#boost.synchro68co"><img src="../../../../../../doc/src/images/callouts/9.png" alt="9" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy construction </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro69"></a><a href="#boost.synchro69co"><img src="../../../../../../doc/src/images/callouts/10.png" alt="10" border="0"></a> </td>
<td valign="top" align="left"><p> disable copy asignement
              </p></td>
</tr>
</table></div>
<p>
            </p>
<p>
          </p>
<p>
            The <code class="computeroutput"><span class="identifier">externally_locked</span></code>
            get function is now a template function taking a Locker as parameters
            instead of a <code class="computeroutput"><span class="identifier">strict_locker</span></code>.
            We can add test in debug mode that ensure that the Lockable object is
            locked.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span>  <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">externally_locked_any</span> <span class="special">{</span>
    
<span class="comment">//    
</span><span class="keyword">public</span><span class="special">:</span>

    <span class="comment">// ... as before
</span>    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Locker</span><span class="special">&gt;</span>
    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">Locker</span><span class="special">&amp;</span> <span class="identifier">locker</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONCEPT_ASSERT</span><span class="special">((</span><span class="identifier">StrictLockerConcept</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;));</span>

        <span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span><span class="identifier">is_strict_locker</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">));</span> <span class="callout_bug"><a name="boost.synchro27co" href="tutorial.html#boost.synchro27"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a></span>
        <span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span><span class="identifier">is_same</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">,</span>
                <span class="keyword">typename</span> <span class="identifier">lockable_type</span><span class="special">&lt;</span><span class="identifier">Locker</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">));</span> <span class="callout_bug"><a name="boost.synchro28co" href="tutorial.html#boost.synchro28"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a></span>
<span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_SYNCHRO_EXTERNALLY_LOCKED_DONT_CHECK_OWNERSHIP</span>  <span class="callout_bug"><a name="boost.synchro29co" href="tutorial.html#boost.synchro29"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a></span>
        <span class="keyword">if</span> <span class="special">(!</span> <span class="identifier">locker</span> <span class="special">)</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span> <span class="callout_bug"><a name="boost.synchro30co" href="tutorial.html#boost.synchro30"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a></span>
<span class="preprocessor">#endif</span>
<span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_SYNCHRO_EXTERNALLY_LOCKED_DONT_CHECK_SAME</span>
        <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">locker</span><span class="special">.</span><span class="identifier">is_locking</span><span class="special">(&amp;</span><span class="identifier">lockable_</span><span class="special">))</span> <span class="keyword">throw</span> <span class="identifier">lock_error</span><span class="special">();</span>
<span class="preprocessor">#endif</span>
        <span class="keyword">return</span> <span class="identifier">obj_</span><span class="special">;</span>
    <span class="special">}</span>

<span class="special">};</span>
</pre>
<p>
            </p>
<p>
            </p>
<p>
              </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro27"></a><a href="#boost.synchro27co"><img src="../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </td>
<td valign="top" align="left"><p> locker is a strict locker "sur parolle" </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro28"></a><a href="#boost.synchro28co"><img src="../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </td>
<td valign="top" align="left"><p> that locks the same
              type </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro29"></a><a href="#boost.synchro29co"><img src="../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </td>
<td valign="top" align="left"><p> define BOOST_SYNCHRO_EXTERNALLY_LOCKED_NO_CHECK_OWNERSHIP if you
              don't want to check locker ownership </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left">
<a name="boost.synchro30"></a><a href="#boost.synchro30co"><img src="../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </td>
<td valign="top" align="left"><p> run time check throw if no locked
              </p></td>
</tr>
</table></div>
<p>
            </p>
<p>
          </p>
<p>
            The <code class="computeroutput"><span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedFunction</span></code> function needs
            only to replace the <code class="computeroutput"><span class="identifier">strict_locker</span></code>
            by a <code class="computeroutput"><span class="identifier">nested_strict_locker</span></code>.
          </p>
<p>
            </p>
<p>
              
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">AccountManager</span><span class="special">::</span><span class="identifier">AMoreComplicatedChecking2Savings</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">amount</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="identifier">guard1</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">some_condition</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">lock</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="special">{</span>
        <span class="identifier">nested_strict_locker</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">AccountManager</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">guard</span><span class="special">(</span><span class="identifier">guard1</span><span class="special">);</span>
        <span class="identifier">checkingAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Withdraw</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
        <span class="identifier">savingsAcct_</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="identifier">guard</span><span class="special">).</span><span class="identifier">Deposit</span><span class="special">(</span><span class="identifier">amount</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">guard1</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
            </p>
<p>
          </p>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2008 Vicente J. Botet Escriba<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="getting_started.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../users_guide.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="ext_references.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
