<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class template meta_namespace</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../../index.html" title="The Mirror library documentation">
<link rel="up" href="../../mirror/reference.html#header.boost.mirror.meta_namespace.hpp" title="Header &lt;boost/mirror/meta_namespace.hpp&gt;">
<link rel="prev" href="../../mirror/reference.html" title="Mirror Reference">
<link rel="next" href="../../BOOST_MIRROR_REG_NAMESPACE.html" title="Macro BOOST_MIRROR_REG_NAMESPACE">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../../mirror/reference.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../mirror/reference.html#header.boost.mirror.meta_namespace.hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../../BOOST_MIRROR_REG_NAMESPACE.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.mirror.meta_namespace"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template meta_namespace</span></h2>
<p>boost::mirror::meta_namespace &#8212; 
		This class template provides meta-data
		about the reflected namespace, especially allows to get the 
		base and full namespace name and to 
		get information about the scope inside of which this namespace
		has been defined.
		
		To obtain a <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code> for a particular
		namespace (with the exception of the global scope) use the reflection
		macro <code class="computeroutput"><a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(FULL_NAMESPACE_NAME)</code>. To
		get the <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code> specialization for
		the global scope use the <code class="computeroutput"><a class="link" href="../../BOOST_MIRRORED_GLOBAL_SCOPE.html" title="Macro BOOST_MIRRORED_GLOBAL_SCOPE">BOOST_MIRRORED_GLOBAL_SCOPE</a>()</code>
		macro.
		</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> NamespacePlaceholder&gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// <a class="link" href="meta_namespace.html#id2433792-bbtypes">types</a></em></span>
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span> <a class="link" href="meta_namespace.html#boost.mirror.meta_namespace.scope">scope</a>;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span> <a class="link" href="meta_namespace.html#boost.mirror.meta_namespace.ancestors">ancestors</a>;
  <span class="type"><span class="bold"><strong>const</strong></span> cts::bstring&amp;</span> <a class="link" href="meta_namespace.html#id2430685-bb">base_name</a>();
  <span class="type"><span class="bold"><strong>const</strong></span> cts::bstring&amp;</span> <a class="link" href="meta_namespace.html#id2475115-bb">full_name</a>();
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>bool</strong></span> FullName, <span class="bold"><strong>typename</strong></span> CharT&gt; 
    <span class="type"><span class="bold"><strong>const</strong></span> ::std::basic_string&lt;CharT&gt;&amp;</span> 
    <a class="link" href="meta_namespace.html#id2519793-bb">get_name</a>(::boost::mpl::bool_&lt;FullName&gt;, ::std::char_traits&lt;CharT&gt;);
};</pre></div>
<div class="refsect1" lang="en">
<a name="id2632469"></a><h2>Description</h2>
<p>The specializations of <code class="computeroutput"><a class="link" href="meta_type.html" title="Class template meta_type">meta_type</a></code> can 
		be used to get meta-information about the reflected types, some at compile-time and some at run-time.
		The following examples show type reflection and basic 
		<code class="computeroutput"><a class="link" href="meta_type.html" title="Class template meta_type">meta_type</a></code> usage. Mirror works with the native C++ types
		and some of the very common types like <code class="computeroutput">::std::string</code>, etc. out of the box.
		Meta-types for many other types from the standard library and Boost
		are also provided and can be <code class="computeroutput">#include</code>d when necessary.
		</p>
<div class="section" lang="en">
<div class="titlepage"></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h6 class="title">
<a name="mirror.meta_namespace.reference.sample01"></a>Example - Basic usage</h6></div></div></div>
<p>This sample code shows how to reflect a namespace and how to get its 
			base and full name. 
			</p>
<a name="mirror.reference.sample.meta_namespace.usage01"></a><pre class="programlisting">
#include &lt;boost/char_type_switch/iostream.hpp&gt;
#include &lt;boost/mirror/meta_namespace.hpp&gt;

int main(void)
{
	using namespace ::std;
	using namespace ::boost;
	using namespace ::boost::mirror;
	cts::bostream&amp; bcout = cts::bcout();

	// several namespaces are pre-registered
	bcout &lt;&lt; <a class="link" href="../../BOOST_MIRRORED_GLOBAL_SCOPE.html" title="Macro BOOST_MIRRORED_GLOBAL_SCOPE">BOOST_MIRRORED_GLOBAL_SCOPE</a>() ::base_name() &lt;&lt; endl;
	bcout &lt;&lt; <a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::std) ::base_name() &lt;&lt; endl;
	bcout &lt;&lt; <a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::boost) ::base_name() &lt;&lt; endl;
	bcout &lt;&lt; <a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::boost::mirror) ::base_name() &lt;&lt; endl;
	//
	bcout &lt;&lt; <a class="link" href="../../BOOST_MIRRORED_GLOBAL_SCOPE.html" title="Macro BOOST_MIRRORED_GLOBAL_SCOPE">BOOST_MIRRORED_GLOBAL_SCOPE</a>() ::full_name() &lt;&lt; endl;
	bcout &lt;&lt; <a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::std) ::full_name() &lt;&lt; endl;
	bcout &lt;&lt; <a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::boost) ::full_name() &lt;&lt; endl;
	bcout &lt;&lt; <a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::boost::mirror) ::full_name() &lt;&lt; endl;

	return 0;
}
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h6 class="title">
<a name="mirror.meta_namespace.reference.sample02"></a>Example - Scope and ancestors</h6></div></div></div>
<p>The following example shows what can be done with the 
			<code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code>s <code class="computeroutput">scope</code> and
			<code class="computeroutput">ancestors</code> <code class="computeroutput">typedef</code>s. It also shows the usage
			of the <code class="computeroutput"><a class="link" href="reflects_global_scope.html" title="Class template reflects_global_scope">reflects_global_scope</a></code> trait
			template.
			</p>
<a name="mirror.reference.sample.meta_namespace.usage02"></a><pre class="programlisting">
#include &lt;boost/mpl/for_each.hpp&gt;
#include &lt;boost/char_type_switch/iostream.hpp&gt;
#include &lt;boost/mirror/meta_namespace.hpp&gt;
#include &lt;boost/mirror/traits/reflects_global_scope.hpp&gt;

class printer
{
public:
	template &lt;class MetaNamespace&gt;
	void operator()(MetaNamespace mn)
	{
		using namespace ::std;
		using namespace ::boost;
		cts::bostream&amp; bcout = cts::bcout();
		bcout &lt;&lt; 
			BOOST_CTS_LIT("ancestor ") &lt;&lt;
			ctr++ &lt;&lt;
			BOOST_CTS_LIT(": '") &lt;&lt;
			MetaNamespace::base_name() &lt;&lt;
			BOOST_CTS_LIT("'") &lt;&lt;
		endl;
	}

	printer(void):ctr(0){ }
private:
	int ctr;
};

int main(void)
{
	using namespace ::std;
	using namespace ::boost;
	using namespace ::boost::mirror;
	cts::bostream&amp; bcout = cts::bcout();
	//
	typedef <a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::boost::mirror) meta_boost_mirror;
	//
	// get the full name of the parent scope of the reflected namespace
	bcout &lt;&lt; meta_boost_mirror::scope::full_name() &lt;&lt; endl;
	//
	// check whether the grandparent namespace is the global scope
	if(<a class="link" href="reflects_global_scope.html" title="Class template reflects_global_scope">reflects_global_scope</a>&lt;meta_boost_mirror::scope::scope&gt; :: value)
		bcout &lt;&lt; BOOST_CTS_LIT("OK") &lt;&lt; endl;
	else 
		bcout &lt;&lt; BOOST_CTS_LIT("Error") &lt;&lt; endl;

	// the ancestors typedef is an mpl vector of meta_namespaces
	printer p;
	mpl::for_each&lt;meta_boost_mirror::ancestors&gt;(p);

	return 0;
}
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h6 class="title">
<a name="mirror.meta_namespace.reference.sample03"></a>Example - Generic namespace name getter</h6></div></div></div>
<p>The <code class="computeroutput"><a class="link" href="meta_namespace.html#id2430685-bb">base_name</a></code> and the 
			<code class="computeroutput"><a class="link" href="meta_namespace.html#id2475115-bb">full_name</a></code> methods
			are convenient but not very generic. The <code class="computeroutput"><a class="link" href="meta_namespace.html#id2519793-bb">get_name</a></code> 
			member function allows to specify the character type of the returned string and 
			to specify whether a full or just the base namespace name should be returned, based
			on compile time arguments.
			</p>
<p>The first argument must be either <code class="computeroutput">mpl::true_</code> for full type name
			or <code class="computeroutput">mpl::false_</code> for base type name and the second argument must be
			an instance of the <code class="computeroutput">::std::char_traits</code> template with <code class="computeroutput">char</code>
			for <code class="computeroutput">::std::string</code> return value type or <code class="computeroutput">wchar_t</code> for
			<code class="computeroutput">::std::wstring</code> return value type.
			</p>
<a name="mirror.reference.sample.meta_namespace.usage03"></a><pre class="programlisting">
#include &lt;iostream&gt;
#include &lt;boost/mirror/meta_namespace.hpp&gt;


template &lt; typename CharT, typename NsPlaceholder &gt;
::std::basic_ostream&lt; CharT, ::std::char_traits&lt; CharT &gt; &gt;&amp;
operator &lt;&lt; (
	::std::basic_ostream&lt; CharT, ::std::char_traits&lt; CharT &gt; &gt;&amp; _s, 
	::boost::mirror::<a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a>&lt; NsPlaceholder &gt; _mn
)
{
	return _s &lt;&lt;_mn.get_name(
		::boost::mpl::true_(), 
		::std::char_traits&lt; CharT &gt;()
	); 
}


int main(void)
{
	using namespace ::std;
	//
	typedef <a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::boost::mirror) meta_Ns;
	meta_Ns mns;
	//
	cout &lt;&lt; mns &lt;&lt; endl;
	wcout &lt;&lt; mns &lt;&lt; endl;

	return 0;
}
</pre>
</div>
</div>
<div class="refsect2" lang="en">
<a name="id2632892"></a><h3>
<a name="id2433792-bbtypes"></a><code class="computeroutput">meta_namespace</code> public types</h3>
<div class="orderedlist"><ol type="1">
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span> <a name="boost.mirror.meta_namespace.scope"></a>scope;</p>
<p>A meta-object describing the scope in which the reflected namespace
			is defined. It is a specialization of <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code>
			with the exception of the meta-namespace reflecting the global scope where
			this type is not defined.
			</p>
<p>To find out whether a meta-namespace reflects the global scope
			use the <code class="computeroutput"><a class="link" href="reflects_global_scope.html" title="Class template reflects_global_scope">reflects_global_scope</a></code> template meta-function.
			</p>
</li>
<li>
<p>
<span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span> <a name="boost.mirror.meta_namespace.ancestors"></a>ancestors;</p>
<p>An <code class="computeroutput">mpl::vector</code> containing the <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code>
			specializations for all the namespaces in which the reflected namespace is
			directly or indirectly nested (not-containing the <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code>
			for the reflected namespace). The elements of this <code class="computeroutput">mpl::vector</code> are
			ordered from the <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code> reflecting
			the global scope to the <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code>
			reflecting the parent namespace. The following holds 
			for <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code>s
			reflecting any namespace with the exception of the global scope:
			</p>
<a name="mirror.reference.sample.meta_namespace.ancestors01"></a><pre class="programlisting">
using namespace ::boost;
using namespace ::boost::mirror;

BOOST_MPL_ASSERT((
	<a class="link" href="reflects_global_scope.html" title="Class template reflects_global_scope">reflects_global_scope</a> &lt; 
		mpl::front &lt; 
			<a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::std)::ancestors 
		&gt;
	&gt;
));

BOOST_MPL_ASSERT((
	<a class="link" href="reflects_global_scope.html" title="Class template reflects_global_scope">reflects_global_scope</a> &lt; 
		mpl::front &lt; 
			<a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::boost::mirror)::ancestors
		&gt;
	&gt;
));

BOOST_MPL_ASSERT((
	is_same &lt;
		mpl::back &lt; 
			<a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::boost::mirror)::ancestors 
		&gt;,
		<a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a>(::boost::mirror)::scope 
	&gt;
));
</pre>
<p>For the <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code>
			reflecting the global scope the following holds true.
			</p>
<a name="mirror.reference.sample.meta_namespace.ancestors02"></a><pre class="programlisting">
BOOST_MPL_ASSERT((
	mpl::empty &lt;
		<a class="link" href="../../BOOST_MIRRORED_GLOBAL_SCOPE.html" title="Macro BOOST_MIRRORED_GLOBAL_SCOPE">BOOST_MIRRORED_GLOBAL_SCOPE</a>()::ancestors
	&gt;
));

</pre>
<p>To find out whether a meta-namespace reflects the global scope
			use the <code class="computeroutput"><a class="link" href="reflects_global_scope.html" title="Class template reflects_global_scope">reflects_global_scope</a></code> template meta-function.
			</p>
</li>
</ol></div>
</div>
<pre class="literallayout"><span class="type"><span class="bold"><strong>const</strong></span> cts::bstring&amp;</span> <a name="id2430685-bb"></a>base_name();</pre>
<p>This static member function returns the base name of the 
			namespace reflected by a <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code>.
			For example the base namespace name "returned" by the invocation of 
			</p>
<pre class="programlisting"><code class="computeroutput"><a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a></code>(::boost::mirror) :: base_name()
			</pre>
<p>
			is <code class="computeroutput">"mirror"</code>. When a full namespace name 
			<span class="bold"><strong>with</strong></span> the nested name specifier
			is needed use the <code class="computeroutput"><a class="link" href="meta_namespace.html#id2475115-bb">full_name</a></code> member function
			instead.</p>
<pre class="literallayout"><span class="type"><span class="bold"><strong>const</strong></span> cts::bstring&amp;</span> <a name="id2475115-bb"></a>full_name();</pre>
<p>This static member function returns the full name of the 
			namespace reflected by a <code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code>
			with the nested name specifier. For example:
			</p>
<pre class="programlisting"><code class="computeroutput"><a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a></code>(::boost::mirror) :: full_name()
			</pre>
<p>
			returns <code class="computeroutput">"::boost::mirror"</code>. When the base namespace name 
			<span class="bold"><strong>without</strong></span> the nested name specifier
			is needed use the <code class="computeroutput"><a class="link" href="meta_namespace.html#id2430685-bb">base_name</a></code> member function
			instead.</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Notes:</span></p></td>
<td><p>The first call to this function can be expensive 
			for deeply nested namespaces, because the name needs to be properly composed from 
			the base namespace names, which may 
			lead to multiple string concatenations. Subsequent calls to this member function
			for a concrete specialization of <a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a>
			are usually much faster.
			</p></td>
</tr></tbody>
</table></div>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>bool</strong></span> FullName, <span class="bold"><strong>typename</strong></span> CharT&gt; 
  <span class="type"><span class="bold"><strong>const</strong></span> ::std::basic_string&lt;CharT&gt;&amp;</span> 
  <a name="id2519793-bb"></a>get_name(::boost::mpl::bool_&lt;FullName&gt; full, ::std::char_traits&lt;CharT&gt; cht);</pre>
<p>This static member template function returns either the base name 
			<span class="bold"><strong>without</strong></span> the nested name specifier 
			or the full name <span class="bold"><strong>with</strong></span> the 
			nested name specifier of the namespace reflected by this
			<code class="computeroutput"><a class="link" href="meta_namespace.html" title="Class template meta_namespace">meta_namespace</a></code>,
			depending on the value of the template argument <code class="computeroutput">FullName</code>.
			Furthermore it allows to choose whether the return value type is 
			<code class="computeroutput">::std::string</code> or <code class="computeroutput">::std::wstring</code> based
			on the type of the second argument.
			For example:
			</p>
<pre class="programlisting"><code class="computeroutput"><a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a></code>(::boost::mirror) :: get_name(::boost::mpl::false_(), ::std::char_traits&lt;char&gt;())
			</pre>
<p> is equivalent to calling the 
			<code class="computeroutput"><a class="link" href="meta_namespace.html#id2430685-bb">base_name</a></code> member function with the 
			<code class="computeroutput">BOOST_CTS_USE_WIDE_CHARS</code> symbol undefined, 
			which returns a <code class="computeroutput">::std::string</code> holding the string <code class="computeroutput">"mirror"</code> and calling
			</p>
<pre class="programlisting"><code class="computeroutput"><a class="link" href="../../BOOST_MIRRORED_NAMESPACE.html" title="Macro BOOST_MIRRORED_NAMESPACE">BOOST_MIRRORED_NAMESPACE</a></code>(::boost::mirror) :: get_name(::boost::mpl::true_(), ::std::char_traits&lt;wchar_t&gt;())
			</pre>
<p> is equivalent to calling the 
			<code class="computeroutput"><a class="link" href="meta_namespace.html#id2475115-bb">full_name</a></code> method with the 
			<code class="computeroutput">BOOST_CTS_USE_WIDE_CHARS</code> symbol defined, 
			which returns a <code class="computeroutput">::std::wstring</code> holding this string <code class="computeroutput">L"::boost::mirror"</code>.
			</p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2008 Matú&#353; Chochlík<p>Use, modification and distribution is subject to the Boost
			Software License, Version 1.0. (See accompanying file
			<code class="filename">LICENSE_1_0.txt</code> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
			</p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../../mirror/reference.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../mirror/reference.html#header.boost.mirror.meta_namespace.hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../../BOOST_MIRROR_REG_NAMESPACE.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
