<?xml version="1.0" encoding="utf-8"?>
<concept_ontology>
	<!-- this file defines the relationships between various
	   - reflection-related concepts.
	 -->
	<concept name="String">
		<model namespace="cts" name="bstring"/>
		<model url="http://www.sgi.com/tech/stl/basic_string.html" name="::std::basic_string"/>
	</concept>

	<concept name="AccessSpecifier">
		<model name="private_"/>
		<model name="protected_"/>
		<model name="public_"/>
	</concept>

	<concept name="InheritanceSpecifier">
		<model name="virtual_base_"/>
		<model name="nonvirtual_base_"/>
	</concept>

	<concept name="Traversal">
		<member_function concept="void" name="accept">
			<fn_param concept="TraversalVisitor" name="_visitor"/>
			<desc>Accepts the given visitor for traversal of the class' structure only.</desc>
		</member_function>
		<member_function concept="void" name="accept">
			<fn_param concept="TraversalVisitor" name="_visitor"/>
			<fn_param concept="Pointer" name="_ptr_to_instance"/>
			<desc>Accepts the given visitor for traversal of the class and of its instance.</desc>
		</member_function>

		<model name="flat_traversal_of"/>
		<model name="deep_traversal_of"/>
	</concept>

	<concept name="ContextNodeSet">
		<metafunction concept="MplIntegralConstant" subnamespace="meta_path" name="size">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns the count of MetaObjects in the ContextNodeSet.</desc>
		</metafunction>
		<metafunction concept="MetaObject" subnamespace="meta_path" name="at">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param name="Position">
			</metafn_param>
			<desc>Returns the MetaObject at the given Position in the ContextNodeSet. Position should be a model of the MPL's IntegralConstant concept.</desc>
		</metafunction>

		<free_function concept="UnaryFunctor" subnamespace="meta_path" name="for_each">
			<template_param placeholder="true"/>
			<template_param name="UnaryFunctor"/>
			<fn_param concept="UnaryFunctor" name="funct"/>
			<desc>Executes the runtime functor on an temporary instance of every MetaObject in the ContextNodeSet.</desc>
		</free_function>
		<free_function concept="UnaryFunctor" subnamespace="meta_path" name="for_each">
			<template_param placeholder="true"/>
			<template_param name="TransformOp"/>
			<template_param name="UnaryFunctor"/>
			<fn_param concept="TransformOp" name="transform"/>
			<fn_param concept="UnaryFunctor" name="funct"/>
			<desc>Executes the runtime functor on a temporary instance of the result of the TransformOp on every MetaObject in the ContextNodeSet.</desc>
		</free_function>
	</concept>

	<concept name="TraversalContext">
		<metafunction concept="ContextNodeSet" subnamespace="meta_path" name="self">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns a ContextNodeSet containing only the contextual MetaObject.</desc>
		</metafunction>
		<metafunction concept="ContextNodeSet" subnamespace="meta_path" name="parent">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns a ContextNodeSet containing only the parent MetaObject of the contextual MetaObject. For example a MetaClass is a parent of MetaBaseClasses or MetaClassAttributes, MetaClassAttributes is a parent of MetaClassAttribute, etc.</desc>
		</metafunction>
		<metafunction concept="ContextNodeSet" subnamespace="meta_path" name="ancestors">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns a ContextNodeSet containing the MetaObjects which are ancestors of the contextual MetaObject.</desc>
		</metafunction>
		<metafunction concept="ContextNodeSet" subnamespace="meta_path" name="ancestors_and_self">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns a ContextNodeSet containing the MetaObjects which are ancestors of the contextual MetaObject and the contextual MetaObject itself.</desc>
		</metafunction>
		<metafunction concept="ContextNodeSet" subnamespace="meta_path" name="siblings">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns a ContextNodeSet containing the MetaObjects which are siblings of the contextual MetaObject.</desc>
		</metafunction>
		<metafunction concept="ContextNodeSet" subnamespace="meta_path" name="siblings_and_self">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns a ContextNodeSet containing the MetaObjects which are siblings of the contextual MetaObject and the contextual MetaObject itself.</desc>
		</metafunction>
		<metafunction concept="ContextNodeSet" subnamespace="meta_path" name="prior">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns a ContextNodeSet containing the single MetaObject which is directly preceding the contextual MetaObject.</desc>
		</metafunction>
		<metafunction concept="ContextNodeSet" subnamespace="meta_path" name="next">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns a ContextNodeSet containing the single MetaObject which is directly following the contextual MetaObject.</desc>
		</metafunction>
	</concept>

	<concept name="TraversalVisitor">
		<member_typedef concept="MplBooleanIntegralConstant" name="works_on_instances">
			<desc>Indicates whether the visitor works on instances or just on the structure of the visited type.</desc>
		</member_typedef>

		<member_function concept="void" name="enter_type">
			<fn_param concept="MetaClass" name="_meta_class"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<desc>The visitor enters a type reflected by _meta_class in the context indicated by _context.</desc>
		</member_function>
		<member_function concept="void" name="leave_type">
			<fn_param concept="MetaClass" name="_meta_class"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<desc>The visitor leaves a type reflected by _meta_class in the context indicated by _context.</desc>
		</member_function>
		<member_function concept="void" name="enter_base_classes">
			<fn_param concept="MetaClass" name="_meta_class"/>
			<fn_param concept="MetaBaseClasses" name="_meta_base_classes"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<desc>The visitor enters the list of base classes reflected by _meta_base_classes, of a class reflected by _meta_class in the context indicated by _context.</desc>
		</member_function>
		<member_function concept="void" name="leave_base_classes">
			<fn_param concept="MetaClass" name="_meta_class"/>
			<fn_param concept="MetaBaseClasses" name="_meta_base_classes"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<desc>The visitor leaves the list of base classes reflected by _meta_base_classes, of a class reflected by _meta_class in the context indicated by _context.</desc>
		</member_function>
		<member_function concept="void" name="enter_base_class">
			<fn_param concept="MetaInheritance" name="_meta_inheritance"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<desc>The visitor enters a concrete base class reflected by _meta_inheritance in the context indicated by _context.</desc>
		</member_function>
		<member_function concept="void" name="leave_base_class">
			<fn_param concept="MetaInheritance" name="_meta_inheritance"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<desc>The visitor leaves a concrete base class reflected by _meta_inheritance in the context indicated by _context.</desc>
		</member_function>
		<member_function concept="void" name="enter_attributes">
			<fn_param concept="MetaClass" name="_meta_class"/>
			<fn_param concept="MetaClassAttributes" name="_meta_class_attributes"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<desc>The visitor enters the list of member attributes reflected by _meta_class_attributes, of a class reflected by _meta_class in the context indicated by _context.</desc>
		</member_function>
		<member_function concept="void" name="leave_attributes">
			<fn_param concept="MetaClass" name="_meta_class"/>
			<fn_param concept="MetaClassAttributes" name="_meta_class_attributes"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<desc>The visitor leaves the list of member attributes reflected by _meta_class_attributes, of a class reflected by _meta_class in the context indicated by _context.</desc>
		</member_function>
		<member_function concept="void" name="enter_base_class">
			<fn_param concept="MetaClassAttribute" name="_meta_attribute"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<desc>The visitor enters a concrete member attribute reflected by _meta_attribute in the context indicated by _context.</desc>
		</member_function>
		<member_function concept="void" name="leave_base_class">
			<fn_param concept="MetaClassAttribute" name="_meta_attribute"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<desc>The visitor leaves a concrete member attribute reflected by _meta_attribute in the context indicated by _context.</desc>
		</member_function>
		<member_function concept="void" name="visit_instance">
			<fn_param concept="MetaClass" name="_meta_class"/>
			<fn_param concept="TraversalContext" name="_context"/>
			<fn_param concept="Pointer" name="_ptr_to_inst"/>
			<desc>The visitor visits an instance, pointed to by _ptr_to_inst, of the class or type reflected by _meta_class in the context indicated by _context.</desc>
		</member_function>
	</concept>

	<concept name="Iterator">
		<free_function concept="UnaryFunctor" name="for_each">
			<template_param placeholder="true"/>
			<template_param placeholder="true"/>
			<template_param name="UnaryFunctor"/>
			<fn_param concept="UnaryFunctor" name="funct"/>
			<desc>Executes the functor on an temporary instance of every element in the range specified by the passed iterators.</desc>
		</free_function>
		<free_function concept="UnaryFunctor" name="for_each">
			<template_param placeholder="true"/>
			<template_param placeholder="true"/>
			<template_param name="TransformOp"/>
			<template_param name="UnaryFunctor"/>
			<fn_param concept="TransformOp" name="transform"/>
			<fn_param concept="UnaryFunctor" name="funct"/>
			<desc>Executes the runtime functor on a temporary instance of the result of the TransformOp on every element in the range specified by the passed iterators.</desc>
		</free_function>
		<free_function concept="UnaryFunctor" name="reverse_for_each">
			<template_param placeholder="true"/>
			<template_param placeholder="true"/>
			<template_param name="UnaryFunctor"/>
			<fn_param concept="UnaryFunctor" name="funct"/>
			<desc>Executes the functor on an temporary instance of every element in the reversed range specified by the passed iterators.</desc>
		</free_function>
		<free_function concept="UnaryFunctor" name="reverse_for_each">
			<template_param placeholder="true"/>
			<template_param placeholder="true"/>
			<template_param name="TransformOp"/>
			<template_param name="UnaryFunctor"/>
			<fn_param concept="TransformOp" name="transform"/>
			<fn_param concept="UnaryFunctor" name="funct"/>
			<desc>Executes the runtime functor on a temporary instance of the result of the TransformOp on every element in the reverse range specified by the passed iterators.</desc>
		</free_function>
			
		<metafunction concept="MplBooleanIntegralConstant" name="is_valid">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns mpl::true_ if the passed iterator is valid, returns mpl::false_ otherwise. A valid iterator can be dereferenced.</desc>
		</metafunction>
		<metafunction concept="MetaObjectSequenceElement" name="deref">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Dereferences the passed iterator. The result is the MetaObjectSequenceElement, that the iterator points to.</desc>
		</metafunction>
		<metafunction concept="Iterator" name="prior">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns an Iterator pointing to the previous element in the MetaObjectSequence.</desc>
		</metafunction>
		<metafunction concept="Iterator" name="next">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns an Iterator pointing to the next element in the MetaObjectSequence.</desc>
		</metafunction>

		<metafunction concept="MplBooleanIntegralConstant" name="iterator_equal">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Iterator equality comparison.</desc>
		</metafunction>
		<metafunction concept="MplBooleanIntegralConstant" name="iterator_not_equal">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Iterator non-equality comparison.</desc>
		</metafunction>
		<metafunction concept="MplBooleanIntegralConstant" name="iterator_less">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Iterator less than comparison.</desc>
		</metafunction>
		<metafunction concept="MplBooleanIntegralConstant" name="iterator_less_equal">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Iterator less than or equal comparison.</desc>
		</metafunction>
		<metafunction concept="MplBooleanIntegralConstant" name="iterator_greater">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Iterator greater than comparison.</desc>
		</metafunction>
		<metafunction concept="MplBooleanIntegralConstant" name="iterator_greater_equal">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Iterator greater than or equal comparison.</desc>
		</metafunction>
	</concept>


	<concept name="ReverseIterator">
	</concept>

	<!-- ReverseITerator is Iterator -->
	<role 
		subject="Iterator" 
		type="Specialization" 
		object="ReverseIterator"
	>
	</role>

	<concept name="MetaObject">
	</concept>

	<concept name="MetaNamedObject">
		<member_function concept="String" name="base_name">
			<desc>Returns the base name of the reflected entity, <em>without</em> the nested name specifier.</desc>
		</member_function>
		<member_function concept="String" name="get_name">
			<desc>Generic name getter. Returns the base name of the type and allows to select the character type of the returned string, via the type of the char_traits parameter.</desc>
			<fn_param concept="FalseType" name="full_name"/>
			<fn_param concept="CharTraits" name="char_traits"/>
		</member_function>
	</concept>
	
	<concept name="MetaScopedObject">
		<member_typedef concept="MetaScope" name="scope">
			<desc>The MetaScope reflecting the scope of the scoped object, reflected by the MetaScopedObject.</desc>
		</member_typedef>
	</concept>
	
	<concept name="MetaNamedScopedObject">
		<member_function name="full_name" concept="String" >
			<desc>Returns the full name of the reflected entity, <em>with</em> the nested name specifier.</desc>
		</member_function>

		<member_function concept="String" name="get_name" >
			<desc>Generic name getter. Returns the base or the full name of the type based on the type of the full_name parameter and allows to select the character type of the returned string, (from the supported options) via the type of the char_traits parameter.</desc>
			<fn_param concept="TrueOrFalseType" name="full_name"/>
			<fn_param concept="CharTraits" name="char_traits"/>
		</member_function>
	</concept>
	
	<concept name="MetaScope">
	</concept>

	<!-- -->
	<relation_type 
		name="Generalization" 
		inverse="Specialization"
	>
	</relation_type>
	<!-- -->
	<relation_type 
		name="Specialization" 
		inverse="Generalization"
	>
	</relation_type>

	<!-- MetaNamedObject is MetaObject  -->
	<role 
		subject="MetaObject" 
		type="Specialization" 
		object="MetaNamedObject"
	>
	</role>

	<!-- MetaScope is MetaNamedObject  -->
	<role 
		subject="MetaNamedObject" 
		type="Specialization" 
		object="MetaScope"
	>
	</role>

	<!-- MetaScopedObject is MetaObject  -->
	<role 
		subject="MetaObject" 
		type="Specialization" 
		object="MetaScopedObject"
	>
	</role>

	<!-- MetaNamedScopedObject is MetaNamedObject -->
	<role 
		subject="MetaNamedObject" 
		type="Specialization" 
		object="MetaNamedScopedObject"
	>
	</role>

	<!-- MetaNamedScopedObject is MetaScopedObject -->
	<role 
		subject="MetaScopedObject" 
		type="Specialization" 
		object="MetaNamedScopedObject"
	>
	</role>




	<concept name="MetaNamespace">
		<model name="meta_namespace"/>
		<member_typedef concept="MetaNamespace" name="scope">
			<desc>The MetaNamespace reflecting the parent namespace in which the namespace reflected by this MetaNamespace is directly nested.</desc>
		</member_typedef>
		<member_typedef concept="MplSequence" name="ancestors">
			<desc>An mpl::Sequence containing the MetaNamespaces for all the namespaces in which the reflected namespace is directly or indirectly nested.</desc>
		</member_typedef>
	</concept>

	<!-- MetaNamespace is MetaNamedScopedObject -->
	<role 
		subject="MetaNamedScopedObject" 
		type="Specialization" 
		object="MetaNamespace"
	>
	</role>

	<!-- MetaNamespace is MetaScope -->
	<role 
		subject="MetaScope" 
		type="Specialization" 
		object="MetaNamespace"
	>
	</role>

	<concept name="MetaType">
		<model name="meta_type"/>
		<member_typedef concept="Type" name="reflected_type">
			<desc>The type reflected by this MetaType.</desc>
		</member_typedef>
	</concept>

	<!-- MetaType is MetaNamedScopedObject -->
	<role 
		subject="MetaNamedScopedObject" 
		type="Specialization" 
		object="MetaType"
	>
	</role>

	<concept name="MetaTypedef">
		<model name="meta_type"/>
	</concept>

	<!-- MetaTypedef is MetaType -->
	<role 
		subject="MetaType" 
		type="Specialization" 
		object="MetaTypedef"
	>
	</role>

	<concept name="MetaTemplate">
	</concept>

	<!-- MetaTemplate is MetaObject -->
	<role 
		subject="MetaObject" 
		type="Specialization" 
		object="MetaTemplate"
	>
	</role>

	<concept name="MetaClass">
		<model name="meta_class"/>
		<member_typedef concept="MetaBaseClasses" name="base_classes">
			<desc>The sequence of MetaBaseClasses reflecting the inheritance of the base classes.</desc>
		</member_typedef>
		<member_typedef concept="MetaClassAttributes" name="attributes">
			<desc>The sequence of MetaClassAttribute(s) reflecting the "own" attributes of a class. These are the attributes that are defined directly in the class reflected by this MetaClass, not including the attributes inherited from the base classes.</desc>
		</member_typedef>
		<member_typedef concept="MetaClassAttributes" name="all_attributes">
			<desc>The sequence of MetaClassAttribute(s) reflecting all attributes of a class including the ones inherited from base classes.</desc>
		</member_typedef>
		<member_typedef concept="Class" name="reflected_type">
			<desc>The class reflected by this MetaClass.</desc>
		</member_typedef>
	</concept>

	<!-- MetaClass is MetaType -->
	<role 
		subject="MetaType" 
		type="Specialization" 
		object="MetaClass"
	>
	</role>

	<!-- MetaClass is MetaScope -->
	<role 
		subject="MetaScope" 
		type="Specialization" 
		object="MetaClass"
	>
	</role>

	<!-- MetaClass is MetaTemplate -->
	<role 
		subject="MetaTemplate" 
		type="Specialization" 
		object="MetaClass"
	>
	</role>

	<concept name="MetaVariable">
	</concept>

	<!-- MetaVariable is MetaNamedScopedObject -->
	<role 
		subject="MetaNamedScopedObject" 
		type="Specialization" 
		object="MetaVariable"
	>
	</role>

	<concept name="MetaFunction">
	</concept>

	<!-- MetaFunction is MetaTemplate -->
	<role 
		subject="MetaTemplate" 
		type="Specialization" 
		object="MetaFunction"
	>
	</role>

	<!-- MetaFunction is MetaScope -->
	<role 
		subject="MetaScope" 
		type="Specialization" 
		object="MetaFunction"
	>
	</role>

	<!-- MetaFunction is MetaNamedScopedObject -->
	<role 
		subject="MetaNamedScopedObject" 
		type="Specialization" 
		object="MetaFunction"
	>
	</role>

	<concept name="MetaFreeFunction">
	</concept>

	<!-- MetaFreeFunction is MetaFunction -->
	<role 
		subject="MetaFunction" 
		type="Specialization" 
		object="MetaFreeFunction"
	>
	</role>

	<concept name="MetaClassMember">
		<member_typedef concept="MetaClass" name="scope">
			<desc>A MetaClass reflecting the class that the class member, reflected by this MetaClassMember, belongs to.</desc>
		</member_typedef>
	</concept>

	<!-- MetaClassMember is MetaNamedScopedObject -->
	<role 
		subject="MetaNamedScopedObject" 
		type="Specialization" 
		object="MetaClassMember"
	>
	</role>

	<concept name="MetaInheritance">
		<model name="meta_inheritance"/>
		<member_typedef concept="MetaBaseClasses" name="container">
			<desc>The list of MetaBaseClasses that this MetaInheritance belongs to.</desc>
		</member_typedef>
		<member_typedef concept="InheritanceSpecifier" name="inheritance">
			<desc>The inheritance specifier.</desc>
		</member_typedef>
		<member_typedef concept="AccessSpecifier" name="access">
			<desc>The access specifier.</desc>
		</member_typedef>
		<member_typedef concept="MetaClass" name="base_class">
			<desc>MetaClass reflecting the type of the base class.</desc>
		</member_typedef>
	</concept>
	
	<!-- MetaInheritance is MetaScopedObject -->
	<role 
		subject="MetaScopedObject" 
		type="Specialization" 
		object="MetaInheritance"
	>
	</role>

	<!-- MetaInheritance is MetaObjectSequenceElement -->
	<role 
		subject="MetaObjectSequenceElement" 
		type="Specialization" 
		object="MetaInheritance"
	>
	</role>

	<concept name="MetaClassAttribute">
		<model name="meta_class_attribute"/>
		<member_typedef concept="MetaClassAttributes" name="container">
			<desc>The sequence of MetaClassAttribute(s) that this MetaClassAttribute belongs to.</desc>
		</member_typedef>
		<member_typedef concept="MetaType" name="type">
			<desc>The MetaType reflecting the type of the attribute.</desc>
		</member_typedef>
		<member_function concept="Type" name="get">
			<desc>Generic attribute value getter. Returns the value of the reflected class attribute when given an instance of the class that the attribute belongs to.</desc>
			<fn_param concept="Class" name="instance"/>
		</member_function>
		<member_function concept="TypeReference" name="query">
			<desc>Generic attribute value query. Stores the value of the reflected class attribute into the instance referred to by dest_ref, when given an instance of the class that the attribute belongs to.</desc>
			<fn_param concept="Class" name="instance"/>
			<fn_param concept="TypeReference" name="dest_ref"/>
		</member_function>
		<member_function concept="TypeReference" name="query">
			<desc>Generic attribute value setter. Assigns the new_value to the reflected class attribute, when given an instance of the class that the attribute belongs to.</desc>
			<fn_param concept="Class" name="instance"/>
			<fn_param concept="Type" name="new_value"/>
		</member_function>
	</concept>

	<!-- MetaClassAttribute is MetaClassMember -->
	<role 
		subject="MetaClassMember" 
		type="Specialization" 
		object="MetaClassAttribute"
	>
	</role>

	<!-- MetaClassAttribute is MetaVariable -->
	<role 
		subject="MetaVariable" 
		type="Specialization" 
		object="MetaClassAttribute"
	>
	</role>

	<!-- MetaClassAttribute is MetaObjectSequenceElement -->
	<role 
		subject="MetaObjectSequenceElement" 
		type="Specialization" 
		object="MetaClassAttribute"
	>
	</role>

	<concept name="MetaClassAttributeTraits">
		<member_typedef concept="MplBooleanIntegralConstant" name="is_static">
			<desc>Type that indicates whether the class member attribute is static.</desc>
		</member_typedef>
		<member_typedef concept="MplBooleanIntegralConstant" name="is_mutable">
			<desc>Type that indicates whether the class member attribute is mutable.</desc>
		</member_typedef>
		<member_typedef concept="TypedefOrTypeSelector" name="meta_type_selector">
			<desc>A type that can be reflected to obtain the proper MetaType for the attribute's type. This selector allows to distinguish typedefined types.</desc>
		</member_typedef>
	</concept>

	<!-- MetaClassAttributeTraits is MetaObject -->
	<role 
		subject="MetaObject" 
		type="Specialization" 
		object="MetaClassAttributeTraits"
	>
	</role>

	<concept name="MetaMemberFunction">
	</concept>

	<!-- MetaMemberFunction is MetaClassMember -->
	<role 
		subject="MetaClassMember" 
		type="Specialization" 
		object="MetaMemberFunction"
	>
	</role>

	<!-- MetaMemberFunction is MetaFunction -->
	<role 
		subject="MetaFunction" 
		type="Specialization" 
		object="MetaMemberFunction"
	>
	</role>


	<concept name="MetaFunctionParameter">
	</concept>

	<!-- MetaFunctionParameter is MetaVariable -->
	<role 
		subject="MetaVariable" 
		type="Specialization" 
		object="MetaFunctionParameter"
	>
	</role>

	<concept name="MetaObjectSequence">
		<free_function concept="UnaryFunctor" name="for_each">
			<template_param placeholder="true"/>
			<template_param name="UnaryFunctor"/>
			<fn_param concept="UnaryFunctor" name="funct"/>
			<desc>Executes the functor on an temporary instance of every element in the MetaObjectSequence.</desc>
		</free_function>
		<free_function concept="UnaryFunctor" name="for_each">
			<template_param placeholder="true"/>
			<template_param name="TransformOp"/>
			<template_param name="UnaryFunctor"/>
			<fn_param concept="TransformOp" name="transform"/>
			<fn_param concept="UnaryFunctor" name="funct"/>
			<desc>Executes the runtime functor on a temporary instance of the result of the TransformOp on every element in the MetaObjectSequence.</desc>
		</free_function>
		<free_function concept="UnaryFunctor" name="reverse_for_each">
			<template_param placeholder="true"/>
			<template_param name="UnaryFunctor"/>
			<fn_param concept="UnaryFunctor" name="funct"/>
			<desc>Executes the functor on an temporary instance of every element in the reversed reversed MetaObjectSequence.</desc>
		</free_function>
		<free_function concept="UnaryFunctor" name="reverse_for_each">
			<template_param placeholder="true"/>
			<template_param name="TransformOp"/>
			<template_param name="UnaryFunctor"/>
			<fn_param concept="TransformOp" name="transform"/>
			<fn_param concept="UnaryFunctor" name="funct"/>
			<desc>Executes the runtime functor on a temporary instance of the result of the TransformOp on every element in the reversed MetaObjectSequence.</desc>
		</free_function>
	<metafunction concept="MetaObjectSequenceElement" name="at">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param name="Position">
			</metafn_param>
			<desc>The result is the element from the MetaObjectSequence at the given Position. The type used as the Position parameter must conform to MPL Integral Constant concept.</desc>
		</metafunction>
		<metafunction concept="MplIntegralConstant" name="size">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>The result is the count of elements in the MetaObjectSequence.</desc>
		</metafunction>
		<metafunction concept="Iterator" name="begin">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns an Iterator pointing at the beginning of the MetaObjectSequence.</desc>
		</metafunction>
		<metafunction concept="Iterator" name="end">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns an Iterator pointing past the end of the MetaObjectSequence.</desc>
		</metafunction>
		<metafunction concept="ReverseIterator" name="rbegin">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns a Reverse Iterator pointing at the beginning of the reversed MetaObjectSequence.</desc>
		</metafunction>
		<metafunction concept="ReverseIterator" name="rend">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns a Reverse Iterator pointing past the end of the reversed MetaObjectSequence.</desc>
		</metafunction>
		<metafunction concept="Iterator" name="point_to">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>Returns an Iterator pointing to the element at the given Position in the MetaObjectSequence.</desc>
		</metafunction>
		<metafunction concept="Iterator" name="find_if">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param name="Predicate">
			</metafn_param>
			<desc>Returns an Iterator pointing to the first element in the MetaObjectSequence satisfying the given Predicate.</desc>
		</metafunction>
		<metafunction concept="ReverseIterator" name="reverse_find_if">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param name="Predicate">
			</metafn_param>
			<desc>Returns a Reverse Iterator pointing to the first element in the reversed MetaObjectSequence satisfying the given Predicate.</desc>
		</metafunction>
		<metafunction concept="unspecified" name="accumulate">
			<metafn_param placeholder="true">
			</metafn_param>
			<metafn_param name="InitialState">
			</metafn_param>
			<metafn_param name="ForwardOp">
			</metafn_param>
			<desc>Returns the result of sequential application of the ForwardOp on the intermediate State and the individual elements of the MetaObjectSequence.</desc>
		</metafunction>
	</concept>
	
	<!-- MetaObjectSequence is MetaObject -->
	<role 
		subject="MetaObject" 
		type="Specialization" 
		object="MetaObjectSequence"
	>
	</role>

	<concept name="MetaObjectSequenceElement">
		<member_typedef concept="MetaObjectSequence" name="container">
			<desc>The sequence that this element belongs to.</desc>
		</member_typedef>
		<member_typedef concept="MplIntegralConstant" name="position">
			<desc>An MPL Integral Constant indicating the position of the reflected element in the container.</desc>
		</member_typedef>
	</concept>
	
	<!-- MetaObjectSequenceElement is MetaObject -->
	<role 
		subject="MetaObject" 
		type="Specialization" 
		object="MetaObjectSequenceElement"
	>
	</role>

	<concept name="MetaBaseClasses">
		<model name="meta_base_classes"/>
		<metafunction concept="MplSequence" name="get_type_list">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>The result is an MPL Sequence of the base classes of derived_class.</desc>
		</metafunction>
	</concept>

	
	<!-- MetaBaseClasses is MetaObjectSequence -->
	<role 
		subject="MetaObjectSequence" 
		type="Specialization" 
		object="MetaBaseClasses"
	>
	</role>

	<!-- MetaBaseClasses is MetaScopedObject -->
	<role 
		subject="MetaScopedObject" 
		type="Specialization" 
		object="MetaBaseClasses"
	>
	</role>

	<concept name="MetaClassAttributes">
		<model name="meta_class_attributes"/>
		<model name="meta_class_all_attributes"/>
		<metafunction concept="MplSequence" name="get_type_list">
			<metafn_param placeholder="true">
			</metafn_param>
			<desc>The result is an MPL Sequence of the types of the class' member attributes.</desc>
		</metafunction>
	</concept>
	
	<!-- MetaClassAttributes is MetaObjectSequence -->
	<role 
		subject="MetaObjectSequence" 
		type="Specialization" 
		object="MetaClassAttributes"
	>
	</role>

	<!-- MetaClassAttributes is MetaScopedObject -->
	<role 
		subject="MetaScopedObject" 
		type="Specialization" 
		object="MetaClassAttributes"
	>
	</role>

	
</concept_ontology>
