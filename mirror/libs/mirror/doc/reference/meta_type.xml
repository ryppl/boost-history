<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
	"http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<header name="boost/mirror/meta_type.hpp">
	<namespace name="boost">
	<namespace name="mirror">
		<class name="meta_type">
			<template>
				<template-type-parameter name="Type"/>
			</template>
			<purpose>
				<para>The purpose of this class template is to provide meta-data
				about the reflected type, especially to allow to get the 
				base and full type name of the reflected type and to 
				get information about the scope inside of which this type
				has been declared.
				</para>
				<para>Although the specializations of <code><classname>meta_type</classname></code> 
				template can be used directly to get the meta data about a particular type, 
				it is recomended to use the reflection macros like 
				<code><macroname>BOOST_MIRRORED_TYPE</macroname>(TYPE)</code> or
				<code><macroname>BOOST_MIRRORED_TYPEOF</macroname>(EXPR)</code>
				instead, to get the proper specializations of 
				<code><classname>meta_type</classname></code>.
				</para>
			</purpose>
			<description>
				<para>The specializations of <code><classname>meta_type</classname></code> can 
				be used to get meta-information about the reflected types, some at compile-time and some at run-time.
				The following examples show type reflection and basic 
				<code><classname>meta_type</classname></code> usage. Mirror works with the native C++ types
				and some of the very common types like <code>::std::string</code>, etc. out of the box.
				Meta-types for many other types from the standard library and <libraryname>Boost</libraryname>
			       	are also provided and can be <code>#include</code>d when necessary.
				</para>
				<section id="mirror.meta_type.reference.samples">
				<section id="mirror.meta_type.reference.sample01">
					<title>Example - Basic usage</title>
					<para>This sample code shows how to reflect a type and how to get its full type name.
					Since various specializations of <code>::std::pair</code> are reflected,
					the <code><classname>meta_type</classname></code>s for this template need to be 
					included.
					</para>
					<xi:include href="../samples/usage_meta_type_01.xml"/>
				</section>
				<section id="mirror.meta_type.reference.sample02">
					<title>Example - Using with typeof and getting scope-related information</title>
					<para>The following example shows cooperation with the <libraryname>Typeof</libraryname>
					library and scope-related operations.
					</para>
					<xi:include href="../samples/usage_meta_type_02.xml"/>
				</section>
				<section id="mirror.meta_type.reference.sample03">
					<title>Example - Reflection of <code>typedef</code>-ined types</title>
					<para>The next example shows how to reflect <code>typedef</code>-ined
					types. This is useful when the info about the name and the scope of the <code>typedef</code>
					is required instead of the meta-information about the "source" type.
					However, the usage shown in this example is not very common. The full utility becomes obvious 
					only when the <code><classname>meta_type</classname></code> is part of 
					some other meta-structure like for example with <code>typedef</code>'d class member attributes.
					</para>
					<para>Mirror comes with several pre-registered <code>typedef</code>s. If user-defined
					<code>typedef</code>s are to be reflected they need to be registered first.
					</para>
					<xi:include href="../samples/usage_meta_type_03.xml"/>
				</section>
				<section id="mirror.meta_type.reference.sample04">
					<title>Example - Generic typename getter</title>
					<para>The <code><methodname>base_name</methodname></code> and the 
					<code><methodname>full_name</methodname></code> member functions
					are convenient but not very generic. The <code><methodname>get_name</methodname></code> 
					method allows to specify the character type of the returned string and 
					to specify wheter a full or just the base name should be returned, based
					on compile time arguments.
					</para>
					<para>The first argument must be either <code>mpl::true_</code> for full type name
					or <code>mpl::false_</code> for base type name and the second argument must be
					a specialization of the <code>::std::char_traits</code> template with <code>char</code>
					for <code>::std::string</code> return value type or <code>wchar_t</code> for
					<code>::std::wstring</code> return value type.
					</para>
					<xi:include href="../samples/usage_meta_type_04.xml"/>
				</section>
				</section>
			</description>

			<access name="public">
			<typedef name="reflected_type">
				<type>Type</type>
				<purpose>The reflected type</purpose>
				<description>
					<para>The type reflected by this overload of <code><classname>meta_type</classname></code>.
					</para>
				</description>
			</typedef>
			<typedef name="scope">
				<type><emphasis>unspecified</emphasis></type>
				<purpose>Meta-object describing the scope where Type is defined</purpose>
				<description>
					<para>A meta-object describing the scope in which the reflected type
					is defined. Depending on where the type has been defined <code>scope</code>
					can be either a specialization of <code><classname>meta_namespace</classname></code>
					or a specialization of <code><classname>meta_class</classname></code>.
					</para>
				</description>
			</typedef>
			<method name="base_name">
				<type>const <classname>cts::bstring</classname>&amp;</type>
				<purpose>
					<para>This static member function returns the base name of the 
					type reflected by <code><classname>meta_type</classname></code>
					without the nested name specifier. For example:
					<programlisting><macroname>BOOST_MIRRORED_TYPE</macroname>(::std::string) :: base_name()
					</programlisting> or 
					<programlisting><classname>meta_type</classname> &lt; ::std::string &gt; :: base_name()
					</programlisting>
					returns simply <code>"string"</code>. When a full type name 
					<emphasis role="bold">with</emphasis> the nested name specifier
					is needed use the <methodname>full_name</methodname> member function
			       		instead.</para>
				</purpose>
				<notes>
					<para>The first call to this function can be expensive 
					for derived types like pointers, references, cv-qualified 
					types, arrays etc. because the type name needs to be properly composed from 
					the base type name, which may depending on the complexity of the type
					lead to multiple string concatenations. Subsequent calls to this member function
					for a concrete specialization of <classname>meta_type</classname>
					are usually much faster.
					</para>
				</notes>
			</method>
			<method name="full_name">
				<type>const <classname>cts::bstring</classname>&amp;</type>
				<purpose>
					<para>This static member function returns the full name of the 
					type reflected by <code><classname>meta_type</classname></code>
					with the nested name specifier. For example:
					<programlisting><macroname>BOOST_MIRRORED_TYPE</macroname>(::std::string) :: full_name()
					</programlisting> or 
					<programlisting><classname>meta_type</classname> &lt; ::std::string &gt; :: full_name()
					</programlisting> 
					returns <code>"::std::string"</code>. When the base type name 
					<emphasis role="bold">without</emphasis> the nested name specifier
					is needed use the <methodname>base_name</methodname> member function
			       		instead.</para>
				</purpose>
				<notes>
					<para>The first call to this function can be expensive 
					for derived types like pointers, references, cv-qualified 
					types, arrays etc. because the type name needs to be properly composed from 
					the base type name, which may depending on the complexity of the type
					lead to multiple string concatenations. Subsequent calls to this member function
					for a concrete specialization of <classname>meta_type</classname>
					are usually much faster.
					</para>
				</notes>
			</method>
			<method name="get_name">
				<template>
					<template-nontype-parameter name="FullName">
						<type>bool</type>
					</template-nontype-parameter>
					<template-type-parameter name="CharT"/>
				</template>
				<type>const <classname>::std::basic_string&lt;CharT&gt;</classname>&amp;</type>
				<parameter name="full">
					<paramtype>::boost::mpl::bool_&lt;FullName&gt;</paramtype>
				</parameter>
				<parameter name="cht">
					<paramtype>::std::char_traits&lt;CharT&gt;</paramtype>
				</parameter>
				<purpose>
					<para>This static member template function returns either the base name 
					<emphasis role="bold">without</emphasis> the nested name specifier 
					or the full name <emphasis role="bold">with</emphasis> the 
					nested name specifier of the type reflected by this
					<code><classname>meta_type</classname></code>,
					depending on the value of the template argument <code>FullName</code>.
					Furthermore it allows to choose whether the return value type is 
					<code>::std::string</code> or <code>::std::wstring</code> based
					on the type of the second argument.
					For example:
					<programlisting><macroname>BOOST_MIRRORED_TYPE</macroname>(::std::string) :: get_name(::boost::mpl::false_(), ::std::char_traits&lt;char&gt;())</programlisting> or 
					<programlisting><classname>meta_type</classname> &lt; ::std::string &gt; :: get_name(::boost::mpl::false_(), ::std::char_traits&lt;char&gt;())</programlisting> 
					is equivalent to calling the 
					<code><methodname>base_name</methodname></code> member function with the
					<code><macroname>BOOST_CTS_USE_WIDE_CHARS</macroname></code> symbol undefined, 
					which returns a <code>::std::string</code> containing <code>"string"</code> and calling
					<programlisting><macroname>BOOST_MIRRORED_TYPE</macroname>(::std::string) :: get_name(::boost::mpl::true_(), ::std::char_traits&lt;wchar_t&gt;())</programlisting> or 
					<programlisting><classname>meta_type</classname> &lt; ::std::string &gt; :: get_name( ::boost::mpl::true_(), ::std::char_traits&lt;wchar_t&gt;())</programlisting> is equivalent to calling the 
					<code><methodname>full_name</methodname></code> method with the 
					<code><macroname>BOOST_CTS_USE_WIDE_CHARS</macroname></code> symbol defined, 
					which returns a <code>::std::wstring</code> containing <code>L"::std::string"</code>.
					</para>
				</purpose>
			</method>
			</access>
		</class>
	</namespace><!-- mirror -->
	</namespace><!-- boost -->
</header>
