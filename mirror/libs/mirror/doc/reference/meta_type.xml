<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
	"http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<header name="boost/mirror/meta_type.hpp">
	<namespace name="boost">
	<namespace name="mirror">
		<class name="meta_type">
			<template>
				<template-type-parameter name="Type"/>
			</template>
			<purpose>
				<para>The purpose of this class template is to provide meta-data
				about the reflected type, especially to allow to get the 
				base and full type name, of the reflected type and to 
				get information about the scope inside of which this type
				has been declared.
				</para>
				<para>Although the specializations of <code><classname>meta_type</classname></code> 
				template can be used directly to get the meta data about a particular type, 
				it is recomended to use the reflection macros like 
				<code><macroname>BOOST_MIRRORED_TYPE</macroname>(TYPE)</code> or
				<code><macroname>BOOST_MIRRORED_TYPEOF</macroname>(EXPR)</code>
				instead, to get the proper specializations of 
				<code><classname>meta_type</classname></code>.
				</para>
			</purpose>
			<description>
				<para>The specializations of <code><classname>meta_type</classname></code> can 
				be used to get meta-information about the reflected types at both compile-time and run-time.
				The following examples show type reflection and basic 
				<code><classname>meta_type</classname></code> usage. Mirror works with the native C++ types
				and some of the very common types like <code>::std::string</code>, etc. out of the box.
				Meta-types for many other types from the standard library and <libraryname>Boost</libraryname>
			       	are also provided and can be <code>#include</code>d when necessary.
				</para>
				<section id="mirror.meta_type.reference.samples">
				<section id="mirror.meta_type.reference.sample01">
					<title>Example - Basic usage</title>
					<para>This sample code shows how to reflect a type and how to get its full type name.
					Since various specializations of <code>::std::pair</code> are reflected,
					the <code><classname>meta_type</classname></code>s for this template need to be 
					included.
					</para>
					<xi:include href="../samples/usage_meta_type_01.xml"/>
				</section>
				<section id="mirror.meta_type.reference.sample02">
					<title>Example - Using with typeof and getting scope-related information</title>
					<para>The following example shows cooperation with the <libraryname>Typeof</libraryname>
					library and scope-related operations.
					</para>
					<xi:include href="../samples/usage_meta_type_02.xml"/>
				</section>
				</section>
			</description>

			<access name="public">
			<typedef name="reflected_type">
				<type>Type</type>
				<purpose>The reflected type</purpose>
				<description>
					<para>The type reflected by this overload of <code><classname>meta_type</classname></code>.
					</para>
				</description>
			</typedef>
			<typedef name="scope">
				<type><emphasis>unspecified</emphasis></type>
				<purpose>Meta-object describing the scope where Type is defined</purpose>
				<description>
					<para>A meta-object describing the scope in which the reflected type
					is defined. Depending on where the type has been defined <code>scope</code>
					can be either a specialization of <code><classname>meta_namespace</classname></code>
					or a specialization of <code><classname>meta_class</classname></code>.
					</para>
				</description>
			</typedef>
			<method name="base_name">
				<type>const <classname>bstring</classname>&amp;</type>
				<purpose>
					<para>This static member function returns the base name of the 
					type reflected by <code><classname>meta_type</classname></code>
					without the nested name specifier. For example:
					<programlisting><macroname>BOOST_MIRRORED_TYPE</macroname>(::std::string) :: base_name()
					</programlisting> or 
					<programlisting><classname>meta_type</classname> &lt; ::std::string &gt; :: base_name()
					</programlisting>
					returns simply <code>"string"</code>. When a full type name 
					<emphasis role="bold">with</emphasis> the nested name specifier
					is needed use the <methodname>full_name</methodname> member function
			       		instead.</para>
				</purpose>
				<notes>
					<para>The first call to this function can be expensive 
					for derived types like pointers, references, cv-qualified 
					types, arrays etc. because the type name needs to be properly composed from 
					the base type name, which may depending on the complexity of the type
					lead to multiple string concatenations. Subsequent calls to this member function
					for a concrete specialization of <classname>meta_type</classname>
					are usually much faster.
					</para>
				</notes>
			</method>
			<method name="full_name">
				<type>const <classname>bstring</classname>&amp;</type>
				<purpose>
					<para>This static member function returns the full name of the 
					type reflected by <code><classname>meta_type</classname></code>
					with the nested name specifier. For example:
					<programlisting><macroname>BOOST_MIRRORED_TYPE</macroname>(::std::string) :: full_name()
					</programlisting> or 
					<programlisting><classname>meta_type</classname> &lt; ::std::string &gt; :: full_name()
					</programlisting> 
					returns <code>"::std::string"</code>. When the base type name 
					<emphasis role="bold">without</emphasis> the nested name specifier
					is needed use the <methodname>base_name</methodname> member function
			       		instead.</para>
				</purpose>
				<notes>
					<para>The first call to this function can be expensive 
					for derived types like pointers, references, cv-qualified 
					types, arrays etc. because the type name needs to be properly composed from 
					the base type name, which may depending on the complexity of the type
					lead to multiple string concatenations. Subsequent calls to this member function
					for a concrete specialization of <classname>meta_type</classname>
					are usually much faster.
					</para>
				</notes>
			</method>
			<method name="get_name">
				<template>
					<template-nontype-parameter name="FullName">
						<type>bool</type>
					</template-nontype-parameter>
				</template>
				<type>const <classname>bstring</classname>&amp;</type>
				<parameter name="full">
					<paramtype>::boost::mpl::bool_&lt;FullName&gt;</paramtype>
				</parameter>
				<purpose>
					<para>This static member template function returns either the base name 
					<emphasis role="bold">without</emphasis> the nested name specifier 
					or the full name <emphasis role="bold">with</emphasis> the 
					nested name specifier of the type reflected by this
					<code><classname>meta_type</classname></code>,
					depending on the value of the template argument <code>FullName</code>.
					For example:
					<programlisting><macroname>meta_type</macroname>(::std::string) :: get_name(::boost::mpl::false_())</programlisting> or 
					<programlisting><classname>meta_type</classname> &lt; ::std::string &gt; :: get_name(::boost::mpl::false_())</programlisting> 
					is equivalent to calling the 
					<code><methodname>base_name</methodname></code> member function and 
					returns simply <code>"string"</code> and
					<programlisting><macroname>meta_type</macroname>(::std::string) :: get_name(::boost::mpl::true_())</programlisting> or 
					<programlisting><classname>meta_type</classname> &lt; ::std::string &gt; :: get_name( ::boost::mpl::true_())</programlisting> is equivalent to calling the 
					<code><methodname>full_name</methodname></code> method which 
					returns <code>"::std::string"</code>.
					</para>
				</purpose>
			</method>
			</access>
		</class>
	</namespace><!-- mirror -->
	</namespace><!-- boost -->
</header>
