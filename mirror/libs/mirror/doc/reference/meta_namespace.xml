<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
	"http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<header name="boost/mirror/meta_namespace.hpp">
	<namespace name="boost">
	<namespace name="mirror">
		<class name="meta_namespace">
			<template>
				<template-type-parameter name="NamespacePlaceholder"/>
			</template>
			<purpose>
				<para>
				This class template provides meta-data
				about the reflected namespace, especially allows to get the 
				base and full namespace name and to 
				get information about the scope inside of which this namespace
				has been defined.
				</para>
				<para>
				To obtain a <code><classname>meta_namespace</classname></code> for a particular
				namespace (with the exception of the global scope) use the reflection
				macro <code><macroname>BOOST_MIRRORED_NAMESPACE</macroname>(FULL_NAMESPACE_NAME)</code>. To
				get the <code><classname>meta_namespace</classname></code> specialization for
				the global scope use the <code><macroname>BOOST_MIRRORED_NAMESPACE</macroname>()</code>
				macro.
				</para>
			</purpose>

			<access name="public">
			<typedef name="scope">
				<type><emphasis>unspecified</emphasis></type>
				<purpose>Meta-namespace describing the scope where the reflected namespace is defined</purpose>
				<description>
					<para>A meta-object describing the scope in which the reflected namespace
					is defined. It is a specialization of <code><classname>meta_namespace</classname></code>
					with the exception of the meta-namespace reflecting the global scope where
					this type is not defined.
					</para>
					<para>To find out whether a meta-namespace reflects the global scope
					use the <code><classname>reflects_global_scope</classname></code> template meta-function.
					</para>
				</description>
			</typedef>
			<typedef name="ancestors">
				<type><emphasis>unspecified</emphasis></type>
				<purpose>mpl::vector containing the whole path to the reflected namespace</purpose>
				<description>
					<para>An <code>mpl::vector</code> containing the <code><classname>meta_namespace</classname></code>
					specializations for all the namespaces in which the reflected namespace is
					directly or indirectly nested (not-containing the <code><classname>meta_namespace</classname></code>
					for the reflected namespace). The elements of this <code>mpl::vector</code> are
					ordered from the <code><classname>meta_namespace</classname></code> reflecting
					the global scope to the <code><classname>meta_namespace</classname></code>
					reflecting the parent namespace. The following holds 
					for <code><classname>meta_namespace</classname></code>s
					reflecting any namespace with the exception of the global scope:
					</para>
					<programlisting>
using namespace ::boost;
using namespace ::boost::mirror;

BOOST_MPL_ASSERT((
	reflects_global_scope &lt; 
		mpl::front &lt; 
			BOOST_MIRRORED_NAMESPACE(::std)::ancestors 
		&gt;
	&gt;
));

BOOST_MPL_ASSERT((
	reflects_global_scope &lt; 
		mpl::front &lt; 
			BOOST_MIRRORED_NAMESPACE(::boost::mirror)::ancestors
		&gt;
	&gt;
));

BOOST_MPL_ASSERT((
	is_same &lt;
		mpl::back &lt; 
			BOOST_MIRRORED_NAMESPACE(::boost::mirror)::ancestors 
		&gt;,
		BOOST_MIRRORED_NAMESPACE(::boost::mirror)::scope 
	&gt;
));
					</programlisting>
					<para>For the <code><classname>meta_namespace</classname></code>
					reflecting the global scope the following holds true.
					</para>

					<programlisting>
BOOST_MPL_ASSERT((
	mpl::empty &lt;
		BOOST_MIRRORED_GLOBAL_SCOPE()::ancestors
	&gt;
));
					</programlisting>
					<para>To find out whether a meta-namespace reflects the global scope
					use the <code><classname>reflects_global_scope</classname></code> template meta-function.
					</para>
				</description>
			</typedef>
			<method name="base_name">
				<type>const <classname>cts::bstring</classname>&amp;</type>
				<purpose>
					<para>This static member function returns the base name of the 
					namespace reflected by a <code><classname>meta_namespace</classname></code>.
					For example the base namespace name "returned" by the invocation of 
					<programlisting><macroname>BOOST_MIRRORED_NAMESPACE</macroname>(::boost::mirror) :: base_name()
					</programlisting>
					is <code>"mirror"</code>. When a full namespace name 
					<emphasis role="bold">with</emphasis> the nested name specifier
					is needed use the <methodname>full_name</methodname> member function
			       		instead.</para>
				</purpose>
			</method>
			<method name="full_name">
				<type>const <classname>cts::bstring</classname>&amp;</type>
				<purpose>
					<para>This static member function returns the full name of the 
					namespace reflected by a <code><classname>meta_namespace</classname></code>
					with the nested name specifier. For example:
					<programlisting><classname>BOOST_MIRRORED_NAMESPACE</classname>(::boost::mirror) :: full_name()
					</programlisting>
					returns <code>"::boost::mirror"</code>. When the base namespace name 
					<emphasis role="bold">without</emphasis> the nested name specifier
					is needed use the <methodname>base_name</methodname> member function
			       		instead.</para>
				</purpose>
				<notes>
					<para>The first call to this function can be expensive 
					for deeply nested namespaces, because the name needs to be properly composed from 
					the base namespace names, which may 
					lead to multiple string concatenations. Subsequent calls to this member function
					for a concrete specialization of <classname>meta_namespace</classname>
					are usually much faster.
					</para>
				</notes>
			</method>
			<method name="get_name">
				<template>
					<template-nontype-parameter name="FullName">
						<type>bool</type>
					</template-nontype-parameter>
				</template>
				<type>const <classname>cts::bstring</classname>&amp;</type>
				<parameter name="full">
					<paramtype>::boost::mpl::bool_&lt;FullName&gt;</paramtype>
				</parameter>
				<purpose>
					<para>This static member template function returns either the base name 
					<emphasis role="bold">without</emphasis> the nested name specifier 
					or the full name <emphasis role="bold">with</emphasis> the 
					nested name specifier of the namespace reflected by this
					<code><classname>meta_namespace</classname></code>,
					depending on the value of the template argument <code>FullName</code>.
					For example:
					<programlisting><classname>BOOST_MIRRORED_NAMESPACE</classname>(::boost::mirror) :: get_name(::boost::mpl::false_())
					</programlisting> is equivalent to calling the 
					<code><methodname>base_name</methodname></code> member function and 
					returns simply <code>"mirror"</code> and calling
					<programlisting><classname>BOOST_MIRRORED_NAMESPACE</classname>(::boost::mirror) :: get_name(::boost::mpl::true_())
					</programlisting> is equivalent to calling the 
					<code><methodname>full_name</methodname></code> method which 
					returns <code>"::boost::mirror"</code>.
					</para>
				</purpose>
			</method>
			</access>
		</class>
	</namespace><!-- mirror -->
	</namespace><!-- boost -->
</header>
