<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
	"http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<macro name="BOOST_MIRROR_REG_TYPE_EMB" 
	kind="functionlike"
	xmlns:xi="http://www.w3.org/2001/XInclude"
>
	<macro-parameter name="WRAPPER">
	</macro-parameter>
	<macro-parameter name="TYPE">
	</macro-parameter>
	<purpose>
		<para>This macro is used to register a type, that is defined inside of a class.
		After successful registration the type can be reflected. This macro is equivalent to the 
		<code><macroname>BOOST_MIRROR_REG_TYPE_GLOBAL_SCOPE</macroname></code> macro. 
		</para>
	</purpose>
	<description>
		<para>The <code><macroname>BOOST_MIRROR_REG_TYPE_EMB</macroname></code> macro registers a type nested inside of a class with 
		the <libraryname>Mirror</libraryname> library. 
		</para>
		<para>
		To register a type defined in a named namespace
		use the <code><macroname>BOOST_MIRROR_REG_TYPE</macroname></code>.
		To register a <code>typedef</code>ined
		type, use one of the <code><macroname>BOOST_MIRROR_REG_TYPEDEF_GLOBAL_SCOPE</macroname></code>, 
		<code><macroname>BOOST_MIRROR_REG_TYPEDEF_GS</macroname></code> or <code><macroname>BOOST_MIRROR_REG_TYPEDEF</macroname></code>
		macros. To register a type which is defined inside of a class use either the 
		<code><macroname>BOOST_MIRROR_REG_TYPE_EMBEDDED</macroname></code> or the <code><macroname>BOOST_MIRROR_REG_TYPE_EMB</macroname></code>
		macro.
		</para>
		<note>The registering must be done in the <code>::boost::mirror</code> namespace.</note>
		<para>
		The first argument <code>WRAPPER</code> is the fully qualified name of the class inside of which 
		the registered type is nested. The second argument <code>TYPE</code> is the typename of the type
		being registered.
		</para>
		<para>
		The following code listings show how to register types "embedded" inside of other classes:
		</para>
<programlisting>

// type (struct) bar is defined in the class foo
// that is defined in the global scope
struct foo 
{
  struct bar { };
};

// here the wrapping class foo is defined 
// in the namespace baz
namespace baz {
  struct foo 
  {
    struct bar { };
  };
} // namespace baz

// note that the registering must be done
// in the boost::mirror namespace

namespace boost {
namespace mirror {

// register the namespace first
<macroname>BOOST_MIRROR_REG_NAMESPACE</macroname>((baz))
// register the wrapping classes
<macroname>BOOST_MIRROR_REG_TYPE_GLOBAL_SCOPE</macroname>(foo)
<macroname>BOOST_MIRROR_REG_TYPE</macroname>(::baz, foo)
// register the embedded types (structs)
<macroname>BOOST_MIRROR_REG_TYPE_EMB</macroname>(::foo, bar)
// use the longer version on the second 
<macroname>BOOST_MIRROR_REG_TYPE_EMBEDDED</macroname>(::baz::foo, bar)

} //namespace mirror
} //namespace boost
</programlisting>
	<para>
	Afterwards the types can be reflected with the 
	<code><macroname>BOOST_MIRRORED_TYPE</macroname></code> macro:</para>
<programlisting>
BOOST_MPL_ASSERT((
  <classname>reflects_type</classname>&lt; <macroname>BOOST_MIRRORED_TYPE</macroname>(foo::bar) &gt;
));
BOOST_MPL_ASSERT((
  <classname>reflects_type</classname>&lt; <macroname>BOOST_MIRRORED_TYPE</macroname>(baz::foo::bar) &gt;
));
BOOST_MPL_ASSERT((
  <classname>reflects_class</classname>&lt; <macroname>BOOST_MIRRORED_TYPE</macroname>(foo::bar)::scope &gt;
));
BOOST_MPL_ASSERT((
  <classname>reflects_namespace</classname>&lt; <macroname>BOOST_MIRRORED_TYPE</macroname>(foo::bar)::scope::scope &gt;
));
BOOST_MPL_ASSERT((
  <classname>reflects_global_scope</classname>&lt; <macroname>BOOST_MIRRORED_TYPE</macroname>(foo::bar)::scope::scope &gt;
));
BOOST_MPL_ASSERT((
  <classname>reflects_class</classname>&lt; <macroname>BOOST_MIRRORED_TYPE</macroname>(bar::foo::bar)::scope &gt;
));
BOOST_MPL_ASSERT((
  <classname>reflects_namespace</classname>&lt; <macroname>BOOST_MIRRORED_TYPE</macroname>(bar::foo::bar)::scope::scope &gt;
));
BOOST_MPL_ASSERT_NOT((
  <classname>reflects_global_scope</classname>&lt; <macroname>BOOST_MIRRORED_TYPE</macroname>(bar::foo::bar)::scope::scope &gt;
));
BOOST_MPL_ASSERT((
  <classname>reflects_global_scope</classname>&lt; 
    <macroname>BOOST_MIRRORED_TYPE</macroname>(bar::foo::bar)::scope::scope::scope 
  &gt;
));
</programlisting>
	</description>
</macro>
