<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
	"http://www.boost.org/tools/boostbook/dtd/boostbook.dtd"
>
<section id="mirror.intro"
	xmlns:xi="http://www.w3.org/2001/XInclude"
>
	<title>Introduction</title>
	<using-namespace name="boost"/>
	<using-namespace name="boost::mirror"/>

<section id="mirror.abstract">
	<title>Abstract</title>


<para>
	The aim of the <libraryname>Mirror</libraryname> library is to provide 
	useful meta-data at both compile-time and run-time about common 
	C++ constructs like namespaces, types
	(and as an important special case <code>typedef</code>-ined types), 
	classes and their base classes and member attributes, instances, etc. and to 
	provide uniform and generic interfaces for their introspection.
</para>
<para>
	Because standard C++ provides only a very limited set of meta-information
	to build upon, the main drawback of this library is, that namespace, types, classes, etc.
	need to be registered before they can be reflected. 
	However <libraryname>Mirror</libraryname> tries to make the process of 
	registering simple by providing a set of user-friendly registering macros
	and has the native and many of the other common types, classes, templates and 
	namespaces pre-registered.
</para>
<para>
	<libraryname>Mirror</libraryname> is designed with the principle of stratification
	in mind and tries to be as less intrusive as possible. New or existing classes do not need
	to be designed to directly support <libraryname>Mirror</libraryname>
       	and no <libraryname>Mirror</libraryname> related code is necessary
	in the class' definition, as far as some general guidelines are followed
	(the exceptions to this are explained here).
</para>
<para>
	Most important features of the <libraryname>Mirror</libraryname> library
	that are currently implemented include:
</para>

<itemizedlist>
	<listitem>
		Namespace-name inspection. Both the base and fully qualified namespace
		names are supported.
	</listitem>
	<listitem>
		Inspection of the whole scope in which a namespace is defined (global
		scope or nested in another namespace).
	</listitem>
	<listitem>
		Type-name querying, with the support for <code>typedef</code>-ined
		typenames and typenames of derived types like pointers, references,
		cv-qualified types, arrays, functions and template names. Names
		with or without nested-name-specifiers can be queried.
	</listitem>
	<listitem>
		Inspection of the scope in which a type has been defined (global-scope,
		in a namespace, inside of a class)
	</listitem>

	<listitem>
		Unform and generic inspection of class' base classes. One can inspect 
		traits of the base classes for example their types, whether they are inherited
		virtually or not and the access specifier (<code>private</code>, <code>protected</code>,
		<code>public</code>).
	</listitem>
	<listitem>
		Unform and generic inspection of class' member attributes either just those defined
		directly in the reflected class or inherited from it's base-classes. 
		At compile-time the count of class' attributes and their types, storage class
		specifiers (<code>static</code>, <code>mutable</code>) and some other traits
		can be queried.
		At run-time one can uniformly query the names and/or values (when given 
		an instance of the reflected class) of the member attributes and 
		sequentially execute a custom functor on every attribute of a class.
	</listitem>
	<listitem>
		Traversals of a class' (or generally type's) structure with user defined visitors,
		which are optionally working on an provided instance of the type
		or just on it's structure without any run-time data.
		These visitors are guided by <libraryname>Mirror</libraryname> through
		the structure of the class and optionally provided with contextual 
		information about the current position in the traversal.
	</listitem>
</itemizedlist>

<para>
	Most important <emphasis role="bold">planned</emphasis> features include:
</para>

<itemizedlist>
	<listitem>
		Reflection of class' member functions and constructors.
	</listitem>
	<listitem>
		Facility for generating customizable object factories with a uniform interface.
	</listitem>
	<listitem>
		Facility for generating customizable class method dispatchers, allowing
		to construct the arguments and call any member function on an instance 
		of a class registered with <libraryname>Mirror</libraryname>, through
		a uniform interface.
	</listitem>
</itemizedlist>

</section>


<section id="mirror.motivation">
	<title>Motivation</title>
<para>
	Here are described some of the recurring situations where the facilities 
	provided by <libraryname>Mirror</libraryname> are helpful.
</para>

<section id="mirror.motivation.problem.typenames">
	<title>Problem - Querying typenames</title>

	<para>
		There are applications which need to get and then somehow process 
		the name of a given type. One example is a logging facility where 
		some of the messages may contain names of types. This is very helpful 
		for example if one wants to log something in a template function and wants 
		to distinguish between various instantiations in the logs. In this case 
		it is very useful if the type name that goes into the log is human-readable 
		and preferrably corresponding to the typename used in the source code. 
		A rather naive implementation could look as follows:
	</para>
	<xi:include href="samples/typenames_naive.xml"/>
	<para>
		Another application might want to store its data in a format where the typenames 
		are included (for example as attributes of an XML element) to be able to do 
		additional checking when loading the data. In this case the type name must be unique 
		and usually also portable. In addition if the data files are user-editable, 
		the names of the types should be human-readable.
	</para>
	<para>
		Yet another example is a generic application that does some C++ source code generation. 
		In this case the typenames in the output need to correspond to C++ typenames.
	</para>
	<para>
		Maybe the first, obvious choice if one needs to find out what the name of a given type is is to 
		use the <code>typeid</code> operator and call the <code>name()</code> function 
		on the returned reference to <code>type_info</code>. The implementation of our
		<code>get_typename&lt;T&gt;()</code> function from the previous sample code 
		could be following:
	</para>
	<xi:include href="samples/typenames_naive_typeid.xml"/>
	<para>
		There are however, several problems with is approach.
		The notoriously known issue of <code>type_info::name()</code> is that the string 
		returned by this function is implementation-defined and compilers are free 
		to return anything from an empty string, through a mangled typename to a correctly 
		formatted typename and many of them enjoy this freedom to its full extent.
		Thus the returned name is not guarenteed to be unique nor human readable or 
		easily understandable, nor is it portable. 
		Some compilers provide functions that demangle the names returned by 
		<code>type_info::name()</code>, but again this is not very portable.
	</para>
	<para>
		One possible solution is the standardisation of the result of <code>typeid(T).name()</code>
		or introduction of a new standard member function to the <code>type_info</code> structure
		for example <code>type_info::std_name()</code>,
		that would return human-readable, unique, portable typenames preferrably corresponding
		to the C++ typenames.
		Obviously, until that happens we need to stick to another solution.
	</para>
	<para>
		To complicate things even more, we might want to get the base name of the type
		without the nested-name-specifier (<code>basic_string</code> vs. 
		<code>::std::basic_string</code>) and to get the nested-name-specifier
		or even the individual names of the enclosing namespaces or classes 
		separatelly. 
	</para>
	<para>
		This is when <libraryname>Mirror</libraryname> comes in handy. One of the basic
		facilities is the <code><classname>boost::mirror::meta_type</classname></code> class template. 
		Among other things this template has two member functions - <code>base_name</code>
		and <code>full_name</code> that return the base type name without the nested
		name specifier and the full type name with the nested name specifier respectively.
		The names returned by these functions correspond to the C++ typenames, thus
		are human-readable, unique (if using the <code>full_name</code> member function)
		and portable.
	</para>
	<para>
		Using <code><classname>meta_type</classname></code> the <code>get_typename&lt;T&gt;()</code> 
		function could look like this:
	</para>
	<xi:include href="samples/typenames_naive_mirror.xml"/>
	<para>
		With native C++ types and some common types from the <libraryname>STL</libraryname>
		and from <libraryname>Boost</libraryname> the <code><classname>meta_type</classname></code>
		works out of the box.
	</para>
</section>
<section id="mirror.motivation.problem.uniformmemattaccess">
	<title>Problem - Uniform access to member attributes of a class' instance</title>


</section>

</section>

</section>
