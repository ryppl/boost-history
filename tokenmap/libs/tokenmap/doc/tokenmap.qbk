[library Boost.Tokenmap
    [quickbook 1.4]
    [authors [Lisznianski, Slawomir]]
    [copyright 2006-2007 Slawomir Lisznianski]
    [category container]
    [id tokenmap]
    [dirname tokenmap]
    [purpose
        Perfect hashmap with auto-generated pseudo-random keys.
    ]
    [source-mode c++]
    [license
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
[@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ QuickBook Document version 1.4 ]

[/ Logos ]

[def __BOOST_TOKENMAP_LOGO__ [$images/tokenmap/boost.tokenmap.logo.png]]
[def __GOOGLE_SOC_2006__ [$images/extern/googlesoc.png]]

[/ Helpers ]

[/ People ]

[def __SLAWOMIR_PHOTO__ [$images/people/slawomir.png]]

[/ Icons ]

[def __NOTE__ [$images/note.png]]
[def __ALERT__ [$images/caution.png]]
[def __DETAIL__ [$images/note.png]]
[def __TIP__ [$images/tip.png]]
[def __QUESTION_MARK__ [$images/question.png]]


[/ Boost Libraries ]

[def __BOOST_MULTI_INDEX__ [@http://www.boost.org/libs/multi_index/doc/index.html [*Boost.MultiIndex]]]
[def __BOOST_MPL__ [@http://www.boost.org/libs/mpl/doc/index.html [*Boost.MPL]]]
[def __BOOST_TYPE_TRAITS__ [@http://www.boost.org/doc/html/boost_typetraits.html [*Boost.TypeTraits]]]
[def __BOOST_ENABLE_IF__ [@http://www.boost.org/libs/utility/enable_if.html [*Boost.enable_if]]]
[def __BOOST_ITERATORS__ [@http://www.boost.org/libs/iterator/doc/index.html [*Boost.Iterators]]]
[def __BOOST_CALL_TRAITS__ [@http://www.boost.org/libs/utility/call_traits.htm [*Boost.call_traits]]]
[def __BOOST_STATIC_ASSERT__ [@http://www.boost.org/doc/html/boost_staticassert.html [*Boost.StaticAssert]]]

[def __BOOST_SERIALIZATION__ [@http://www.boost.org/libs/serialization/doc/index.html [*Boost.Serialization]]]
[def __BOOST_HASH__ [@http://www.boost.org/doc/html/hash.html [*Boost.Hash]]]
[def __BOOST_ASSIGN__ [@http://www.boost.org/libs/assign/doc/index.html [*Boost.Assign]]]
[def __BOOST_LAMBDA__ [@http://www.boost.org/doc/html/lambda.html [*Boost.Lambda]]]
[def __BOOST_PROPERTY_MAP__ [@http://www.boost.org/doc/html/property_map.html [*Boost.PropertyMap]]]
[def __BOOST_RANGE__ [@http://www.boost.org/doc/html/range.html [*Boost.Range]]]
[def __BOOST_FOREACH__ [@http://www.boost.org/doc/html/foreach.html [*Boost.Foreach]]]
[def __BOOST_TEST__ [@http://www.boost.org/libs/test/doc/index.html [*Boost.Test]]]
[def __BOOST_TYPEOF__ [@http://www.boost.org/libs/typeof/doc/index.html [*Boost.Typeof]]]
[def __BOOST_XPRESSIVE__ [@http://www.boost.org/libs/xpressive/doc/index.html [*Boost.Xpressive]]]


[/ Extern Links ]

[def __CPP_STANDARD_LIBRARY_TECHNICAL_REPORT__ [@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf C++ Standard Library Technical Report]]
[def __CPP_DEFECT_REPORT_130__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130 Defect Report 130]]
[def __TR1_ISSUES_LIST__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1837.pdf Issues List]]

[def __BOOST_HASH_FUNCTION__ [@http://www.boost.org/regression-logs/cs-win32_metacomm/doc/html/hash.html boost::hash]]

[def __BOOST_PERMUTATION_ITERATOR__ [@http://www.boost.org/libs/iterator/doc/permutation_iterator.html `permutation_iterator`]]

[def __BOOST_ASSERT_MACRO__ [@where_it_is `BOOST_ASSERT`]]
[def __BOOST_MPL_FORWARD_SEQUENCE__ [@http://www.boost.org/libs/mpl/doc/refmanual/forward-sequence.html MPL Forward Sequence]]
[def __BOOST_MPL_RANDOM_ACCESS_SEQUENCE__ [@http://www.boost.org/libs/mpl/doc/refmanual/random-access-sequence.html MPL Random Access Sequence]]
[def __BOOST_MPL_EXTENSIBLE_SEQUENCE__ [@http://www.boost.org/libs/mpl/doc/refmanual/extensible-sequence.html MPL Extensible Sequence]]

[def __SGI_UNARY_FUNCTION__ [@http://www.sgi.com/tech/stl/UnaryFunction.html Unary Function]]
[def __SGI_BINARY_FUNCTION__ [@http://www.sgi.com/tech/stl/BinaryFunction.html Binary Function]]

[def __SGI_ASSIGNABLE__ [@http://www.sgi.com/tech/stl/Assignable.html Assignable]]
[def __SGI_DEFAULT_CONSTRUCTIBLE__ [@http://www.sgi.com/tech/stl/DefaultConstructible.html Default Constructible]]
[def __SGI_BINARY_PREDICATE__ [@http://www.sgi.com/tech/stl/BinaryPredicate.html Binary Predicate]]
[def __SGI_CONTAINER__ [@http://www.sgi.com/tech/stl/Container.html Container]]
[def __SGI_SORTED_ASSOCIATIVE_CONTAINER__ [@http://www.sgi.com/tech/stl/SortedAssociativeContainer.html Sorted Associative Container]]
[def __SGI_UNIQUE_ASSOCIATIVE_CONTAINER__ [@http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html Unique Associative Container]]
[def __SGI_REVERSIBLE_CONTAINER__ [@http://www.sgi.com/tech/stl/ReversibleContainer.html Reversible Container]]
[def __SGI_RANDOM_ACCESS_CONTAINER__ [@http://www.sgi.com/tech/stl/RandomAccessContainer.html Random Access Container]]
[def __SGI_FRONT_INSERTION_SEQUENCE__ [@http://www.sgi.com/tech/stl/FrontInsertionSequence.html Front Insertion Sequence]]
[def __SGI_BACK_INSERTION_SEQUENCE__ [@http://www.sgi.com/tech/stl/BackInsertionSequence.html Back Insertion Sequence]]
[def __SGI_INPUT_ITERATOR__ [@http://www.sgi.com/tech/stl/InputIterator.html Input Iterator]]
[def __SGI_FORWARD_ITERATOR__ [@http://www.sgi.com/tech/stl/ForwardIterator.o Forward Iterator]]
[def __SGI_STRICT_WEAK_ORDERING__ [@http://www.sgi.com/tech/stl/StrictWeakOrdering.html   Strict Weak Ordering]]

[def __EIFFEL__ [@http://www.eiffel.com/ Eiffel]]
[def __SAFE_STL__ [@http://www.horstmann.com/safestl.html Safe STL]]
[def __STL_PORT_DEBUG_MODE__ [@http://www.stlport.com/doc/debug_mode.html STLport Debug Mode]]

[def __CGAL__ [@http://www.cgal.org/ CGAL]]
[def __MYSQLPP__ [@http://tangentsoft.net/mysql++/ MySQL++]]


[def __STL_TREE_H__ [@http://www.sgi.com/tech/stl/stl_tree.h stl_tree.h]]
[def __ORDER_STATISTICS_TREE__ [@http://pine.cs.yale.edu/pinewiki/OrderStatisticsTree ['order-statistics trees]]]

[def __GENERIC_PROGRAMMING_MOVE_CONSTRUCTORS__ [@http://www.ddj.com/dept/cpp/184403855 "Generic<Programming>: Move Constructors]]
[def __CLARIFICATION_OF_INITIALIZATION__ [@http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2004/n1610.html "Clarification of Initialization of Class Objects by rvalues"]]


[/ Code snippets ]

[import ../example/simple_tokenmap.cpp]

[section Preface]

[heading Description]

In summary, a tokenmap is a data structure that maps auto-generated tokens with 
elements of the collection. 

Boost.Tokenmap is a (perfect) hash container library for C++. The library provides
a tokenmap, a data structure that maps auto-generated tokens with elements of 
the collection. An important distinction between tokenmap and other dictionary-like
containers (such as std::map or boost::unordered) is that tokenmap generates the 
keys internally (referred to as "tokens") rather than relying on users to provide 
them. Specifically, when a new element is inserted into the tokenmap, an apparently
random token is returned back to the caller. The returned token can later be used 
for very efficient lookups.

[heading Influences and Related Work]

The design of Boost.Tokenmap interface follows the standard template library.

[endsect]

[section Quick tutorial]

A convenience header is avaiable in the boost directory:

    #include <boost/tokenmap.hpp>

Lets define a token map for strings. The following code creates an empty tokenamp 
container with initial capacity set to 10000, load factor set to 0.7 and current 
time as seed for pseudo-number generator:

typedef tokenmap<std::string, unsigned int> tokenmap_type;
tokenmap_type names( 10000, 0.7, time(NULL) );

Next, to insert elements into the container we do:

tokenamp_type::value_type rob = 
    names.insert( "Robert DeNiro" );
tokenamp_type::value_type mart = 
    names.insert( "Martin Scorsese" );

The returned from insert `tokenamp_type::value_type' is a pair, defined as 
std::pair<unsigned int, std::string*>.  The first element of the pair is an 
auto-generated token, whereas the second element is a pointer to the stored 
element that maps to it.

With the returned token we can perform efficient lookups within the container,
example:

tokenamp_type::mapped_type * name = names.find( rob.first ); 

We can also check if an element exists:

bool found = names.exists( rob.first );

Finally, we can remove the element:

std::auto_ptr<map_type::mapped_type> take_over 
  = names.pop( rob.first );

[endsect]

[section Reference]

[section Headers]

* "boost/tokenmap.hpp" ['(includes "boost/tokenmap/tokenmap.hpp" and imports the tokenmap class to boost namespace)]

[endsect]

[section Header "boost/tokenmap/tokenmap.hpp" synopsis]

    namespace boost {
    namespace tokenmaps {

    template <typename value__, typename key__ = uint32_t>
    class tokenmap
    {
      public:

      // Metadata

      typedef uint64_t                           hash_type;
      typedef key__                              key_type;
      typedef value__                            mapped_type;
      typedef std::pair<key_type, mapped_type*>  value_type;

      // Constructor 

      tokenmap(size_t capacity, float load_factor, hash_type seed);

      // Destructor 

      ~tokenmap();

      // Modifiers

      value_type insert(mapped_type const & value);

      value_type insert(std::auto_ptr<mapped_type> value);

      std::auto_ptr<mapped_type> pop(key_type key);

      // Accessors

      mapped_type * find(key_type key) const;

      bool exists(key_type key) const;

      key_type size() const;
    };

    } // namespace tokenmap
    } // namespace boost

[endsect]

[section Class template tokenmap]
[endsect]

[section Nested types]
[endsect]

[section Constructors, copy and assignment]
      tokenmap(size_t capacity, float load_factor, hash_type seed);

* [*Effects:] Constructs an empty `tokenmap`.
* [*Complexity:] Constant.

[endsect]

[section Performance ]
[endsect]

[section Examples ]
[endsect]

[section Rationale ]
[endsect]

[section Future Work ]
[endsect]

[section Acknowledgements ]
[endsect]
