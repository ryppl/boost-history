[/ Copyright 2009 Slawomir Lisznianski
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) ]

[library Boost.Tokenmap
    [quickbook 1.4]
    [authors [Lisznianski, Slawomir]]
    [copyright 2009 Slawomir Lisznianski]
    [category container]
    [id tokenmap]
    [dirname tokenmap]
    [purpose
        Perfect hashmap with auto-generated pseudo-random keys.
    ]
    [source-mode c++]
    [license
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
[@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ QuickBook Document version 1.4 ]

[/ Logos ]

[def __BOOST_TOKENMAP_LOGO__ [$images/tokenmap/boost.tokenmap.logo.png]]
[def __GOOGLE_SOC_2006__ [$images/extern/googlesoc.png]]

[/ Helpers ]

[/ People ]

[def __SLAWOMIR_PHOTO__ [$images/people/slawomir.png]]

[/ Icons ]

[def __NOTE__ [$images/note.png]]
[def __ALERT__ [$images/caution.png]]
[def __DETAIL__ [$images/note.png]]
[def __TIP__ [$images/tip.png]]
[def __QUESTION_MARK__ [$images/question.png]]


[/ Boost Libraries ]

[def _boost_unordered_  [@../../libs/unordered/doc/html/unordered.html [*Boost.Unordered]]] 

[/ Extern Links ]

[def __CPP_STANDARD_LIBRARY_TECHNICAL_REPORT__ [@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf C++ Standard Library Technical Report]]
[def __CPP_DEFECT_REPORT_130__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130 Defect Report 130]]
[def __TR1_ISSUES_LIST__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1837.pdf Issues List]]

[def __BOOST_HASH_FUNCTION__ [@http://www.boost.org/regression-logs/cs-win32_metacomm/doc/html/hash.html boost::hash]]

[def __BOOST_PERMUTATION_ITERATOR__ [@http://www.boost.org/libs/iterator/doc/permutation_iterator.html `permutation_iterator`]]

[def __BOOST_ASSERT_MACRO__ [@where_it_is `BOOST_ASSERT`]]
[def __BOOST_MPL_FORWARD_SEQUENCE__ [@http://www.boost.org/libs/mpl/doc/refmanual/forward-sequence.html MPL Forward Sequence]]
[def __BOOST_MPL_RANDOM_ACCESS_SEQUENCE__ [@http://www.boost.org/libs/mpl/doc/refmanual/random-access-sequence.html MPL Random Access Sequence]]
[def __BOOST_MPL_EXTENSIBLE_SEQUENCE__ [@http://www.boost.org/libs/mpl/doc/refmanual/extensible-sequence.html MPL Extensible Sequence]]

[def __SGI_UNARY_FUNCTION__ [@http://www.sgi.com/tech/stl/UnaryFunction.html Unary Function]]
[def __SGI_BINARY_FUNCTION__ [@http://www.sgi.com/tech/stl/BinaryFunction.html Binary Function]]

[def __SGI_ASSIGNABLE__ [@http://www.sgi.com/tech/stl/Assignable.html Assignable]]
[def __SGI_DEFAULT_CONSTRUCTIBLE__ [@http://www.sgi.com/tech/stl/DefaultConstructible.html Default Constructible]]
[def __SGI_BINARY_PREDICATE__ [@http://www.sgi.com/tech/stl/BinaryPredicate.html Binary Predicate]]
[def __SGI_CONTAINER__ [@http://www.sgi.com/tech/stl/Container.html Container]]
[def __SGI_SORTED_ASSOCIATIVE_CONTAINER__ [@http://www.sgi.com/tech/stl/SortedAssociativeContainer.html Sorted Associative Container]]
[def __SGI_UNIQUE_ASSOCIATIVE_CONTAINER__ [@http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html Unique Associative Container]]
[def __SGI_REVERSIBLE_CONTAINER__ [@http://www.sgi.com/tech/stl/ReversibleContainer.html Reversible Container]]
[def __SGI_RANDOM_ACCESS_CONTAINER__ [@http://www.sgi.com/tech/stl/RandomAccessContainer.html Random Access Container]]
[def __SGI_FRONT_INSERTION_SEQUENCE__ [@http://www.sgi.com/tech/stl/FrontInsertionSequence.html Front Insertion Sequence]]
[def __SGI_BACK_INSERTION_SEQUENCE__ [@http://www.sgi.com/tech/stl/BackInsertionSequence.html Back Insertion Sequence]]
[def __SGI_INPUT_ITERATOR__ [@http://www.sgi.com/tech/stl/InputIterator.html Input Iterator]]
[def __SGI_FORWARD_ITERATOR__ [@http://www.sgi.com/tech/stl/ForwardIterator.o Forward Iterator]]
[def __SGI_STRICT_WEAK_ORDERING__ [@http://www.sgi.com/tech/stl/StrictWeakOrdering.html   Strict Weak Ordering]]

[def __EIFFEL__ [@http://www.eiffel.com/ Eiffel]]
[def __SAFE_STL__ [@http://www.horstmann.com/safestl.html Safe STL]]
[def __STL_PORT_DEBUG_MODE__ [@http://www.stlport.com/doc/debug_mode.html STLport Debug Mode]]

[def __CGAL__ [@http://www.cgal.org/ CGAL]]
[def __MYSQLPP__ [@http://tangentsoft.net/mysql++/ MySQL++]]


[def __STL_TREE_H__ [@http://www.sgi.com/tech/stl/stl_tree.h stl_tree.h]]
[def __ORDER_STATISTICS_TREE__ [@http://pine.cs.yale.edu/pinewiki/OrderStatisticsTree ['order-statistics trees]]]

[def __GENERIC_PROGRAMMING_MOVE_CONSTRUCTORS__ [@http://www.ddj.com/dept/cpp/184403855 "Generic<Programming>: Move Constructors]]
[def __CLARIFICATION_OF_INITIALIZATION__ [@http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2004/n1610.html "Clarification of Initialization of Class Objects by rvalues"]]


[/ Code snippets ]

[import ../example/simple_tokenmap.cpp]

[section Description]

A `tokenmap` is a data structure that uniquely maps pseudo-random integer keys to values.

Unlike other dictionary-like containers such as `std::map` or _boost_unordered_, a `tokenmap` generates the keys (also called ["tokens]) for values by an internal, pseudo-random algorithm rather than relying on the user to provide them; that is, when a new value is inserted into a `tokenmap`, the `tokenmap` generates a key for the value in some unspecified way and returns this key to the caller. Returned keys, which uniquely map to values, can later be used to retrieve the corresponding value in a very efficient lookup.

[^tokenmap]s have the following properties:

# No two tokens map to the same value (`tokenmap` differs from `std::multimap` in this respect)
# The returned tokens are /stable/ (a token will always map to the corresponding value regardless of how the `tokenmap` was modified since the token was generated)
# Lookups are much faster - sometimes 30 times faster - than `std::map` lookups

The second property, also called the /perfect hashing property/, requires special support from the container, as described on the [link tokenmap.background Background] page.

[endsect]

[section:background Background]

[:['This section was contributed by Daniel Trebbien.]]

The main design goal of `tokenmap` was to make an associative container that uses random keys and which has extremely fast lookup operations (i.e. given a key, the operation to find the associated value should be as fast as possible). Array accesses are known to be among the fastest operations performable on today's computing equipment, so the question in developing `tokenmap` was whether it would be possible to use a dynamic array as the backing storage and still implement a dictionary-like container that allows random keys.

There are many conceivable mapping strategies (the way that tokens are mapped to indices in the array), but it's not always obvious which particular strategy yields an associative container with all of the following properties:

# The container can grow in size to accommodate more elements.
# Tokens will always map to their corresponding values regardless of the container's growth.
# The tokens are random.

One simple strategy is to take a token `t` (an unsigned integer) and return the value `store[t % store_length]` where `store` is the name of the dynamic array and `store_length` is its length. Interestingly enough, this strategy /does/ allow the implementation of an associative container with those properties, and this is the strategy that is used by `tokenmap`.

[section:analysis_of_simple_strategy Analysis of the simple strategy]

One immediate consequence of using this simple strategy is that a user cannot provide her own tokens; they must be generated by the container. This is because the user might try to use tokens that, modulo the store length at the time of insert, are the same. For example, if the store length is 12, then a container that is based on the simple strategy cannot allow tokens `0x3af8cf08` and `0xc0d9a414` to map to different values because modulo 12, these numbers are both 8. Some applications require the ability to specify the token, so containers based on this simple strategy are not suitable for these applications. However, there are other applications where you just want to generate handles or IDs of resources that will always map to the resources. For these, the particular values of the handles or IDs are irrelevant (they just need to uniquely map to the resources), so a container that generates the tokens (the particular values of handles or IDs) is perfectly acceptable.

A container that is based on the described above strategy must implement a rehashing algorithm which is used whenever the container is expanded to accommodate more elements. An algorithm that works well with our strategy is:

# Create a new store `new_store` of length `new_store_length`.
# For each token `t` in the container, place the associated value at `new_store[t % new_store_length]`.
# Delete the old store and use `new_store` as the store.

If we say that the initial store length is ['s]'''<subscript>0</subscript>''' and subsequent store lengths are ['s]'''<subscript>1</subscript>''', ['s]'''<subscript>2</subscript>''', ..., ['s]'''<subscript><emphasis>k</emphasis></subscript>''', then careful choices of the sequence {['s]'''<subscript><emphasis>k</emphasis></subscript>'''} allow the container to have the property that tokens always map to their corresponding values regardless of the number of re-hashes that have occurred since they were generated (the perfect hashing property).

Some choices of the sequence {['s]'''<subscript><emphasis>k</emphasis></subscript>'''} will not work. For example, suppose ['s]'''<subscript>0</subscript>''' were 2 and ['s]'''<subscript>1</subscript>''' were 3. Then, tokens `0x25b786ef` and `0x0010b86c` can be generated while the store length is 2 (because modulo 2, they are 1 and 0, respectively), but once the store length becomes 3, they hash to the same location (they are both 2 modulo 3).

In the following sections, it will be proven that whenever `new_store_length` is a multiple of the old `store_length`, then the perfect hashing property is preserved.

[heading Modular arithmetic notation]

We denote the set of integers {..., -4, -3, -2, -1, 0, 1, 2, 3, ...} as [*['Z]] and the set of sets of integers that are congruent modulo /s/ as [*['Z]]'''<subscript><emphasis>s</emphasis></subscript>'''. The elements of [*['Z]]'''<subscript><emphasis>s</emphasis></subscript>''' are denoted by so-called /class notation/: \[['x]\]'''<subscript><emphasis>s</emphasis></subscript>''' is the set of integers that have the same remainder as /x/ when divided by /s/; in other words, for /x/ an integer, \[['x]\]'''<subscript><emphasis>s</emphasis></subscript>''' is the set of all integers that are congruent modulo /s/.

[heading Proposition 1: Perfect hashing is preserved with multiples of the old store length]

In order for the token-generating strategy to remain perfect after a single rehash, the crucial property of store lengths /s/'''<subscript><emphasis>k</emphasis></subscript>''' and /s/'''<subscript><emphasis>k</emphasis>+1</subscript>''' is:
[:[$images/latex1.png][footnote Read: If /x/ and /y/ are incongruent modulo /s/'''<subscript><emphasis>k</emphasis></subscript>''', then they are incongruent modulo /s/'''<subscript><emphasis>k</emphasis>+1</subscript>'''.]]

One choice of /s/'''<subscript><emphasis>k</emphasis>+1</subscript>''' that always works is when /s/'''<subscript><emphasis>k</emphasis>+1</subscript>''' is a multiple of /s/'''<subscript><emphasis>k</emphasis></subscript>'''; when /s/'''<subscript><emphasis>k</emphasis>+1</subscript>''' = ['c]·/s/'''<subscript><emphasis>k</emphasis></subscript>''', then it is always true that:
[:[$images/latex2.png]]

[*Proof]

The statement is proved by way of the logically-equivalent [@http://en.wikipedia.org/wiki/Contrapositive contrapositive]:
[:[$images/latex3.png]]

If \[['x]\]'''<subscript><emphasis>c</emphasis>·<emphasis>s</emphasis><subscript><emphasis>k</emphasis></subscript></subscript>''' equals \[['y]\]'''<subscript><emphasis>c</emphasis>·<emphasis>s</emphasis><subscript><emphasis>k</emphasis></subscript></subscript>''' then ['c]·['s]'''<subscript><emphasis>k</emphasis></subscript>''' divides (['x] - ['y]) by definition. This implies that /s/'''<subscript><emphasis>k</emphasis></subscript>''' divides (['x] - ['y]), so \[['x]\]'''<subscript><emphasis>s</emphasis><subscript><emphasis>k</emphasis></subscript></subscript>''' equals \[['y]\]'''<subscript><emphasis>s</emphasis><subscript><emphasis>k</emphasis></subscript></subscript>'''. '''&#x220e;'''

[heading {['s]'''<subscript><emphasis>k</emphasis></subscript>'''} that preserves perfect hashing after arbitrary rehashes]

From Proposition 1, we know that to preserve the perfect property after a single rehash, one choice of /s/'''<subscript><emphasis>k</emphasis>+1</subscript>''' that always works is to make /s/'''<subscript><emphasis>k</emphasis>+1</subscript>''' a multiple of /s/'''<subscript><emphasis>k</emphasis></subscript>'''. Therefore, to preserve the perfect hashing property after arbitrary rehashes, we can pick /s/'''<subscript><emphasis>k</emphasis>+1</subscript>''' = /c/'''<subscript><emphasis>k</emphasis></subscript>'''·/s/'''<subscript><emphasis>k</emphasis></subscript>''' for any sequence of natural numbers {/c/'''<subscript><emphasis>k</emphasis></subscript>'''}. To make things simple, however, `tokenmap` uses 2 for every /c/'''<subscript><emphasis>k</emphasis></subscript>'''. Thus /s/'''<subscript><emphasis>k</emphasis></subscript>''' = 2'''<superscript><emphasis>k</emphasis></superscript>'''·/s/'''<subscript>0</subscript>'''.

[endsect]

[endsect]

[section Quick tutorial]

Start by including the convenience header available in the boost directory:

    #include <boost/tokenmap.hpp>

Next, we define a `tokenmap` for storing strings. The following code creates an empty `tokenmap` 
container with initial capacity set to 10000, load factor set to 0.7 and current 
time as seed for pseudo-number generator:

    typedef boost::tokenmap<std::string, unsigned int> tokenmap_type;
    tokenmap_type names( 10000, 0.7, time(NULL) );

To insert elements into the container we do:

    tokenmap_type::value_type rob = 
        names.insert( "Robert DeNiro" );
    tokenmap_type::value_type mart = 
        names.insert( "Martin Scorsese" );

The value returned from insert is a pair, defined as std::pair<unsigned int, std::string*>.
The first element of the pair is an auto-generated token, whereas the second element
is a pointer to the element that maps to it.

With the returned token, we can perform efficient lookups on the container, for example:

    tokenmap_type::mapped_type * name = names.find( rob.first ); 

We can also check if an element exists:

    bool found = names.exists( rob.first );

Finally, we can remove the element:

    std::auto_ptr<map_type::mapped_type> take_over = 
        names.pop( rob.first );

[endsect]

[section Reference]

[heading Headers]

"boost/tokenmap.hpp" includes "boost/tokenmap/tokenmap.hpp" and imports the `tokenmap` class to boost namespace.

[heading Synopsis]

    namespace boost {
    namespace tokenmaps {

    template <typename value__, typename key__ = uint32_t>
    class tokenmap
    {
      public:

      // Metadata

      typedef uint64_t                           hash_type;
      typedef key__                              key_type;
      typedef value__                            mapped_type;
      typedef std::pair<key_type, mapped_type*>  value_type;

      // Constructor 

      tokenmap(size_t capacity, float load_factor, hash_type seed);

      // Destructor 

      ~tokenmap();

      // Modifiers

      value_type insert(mapped_type const & value);

      value_type insert(std::auto_ptr<mapped_type> value);

      std::auto_ptr<mapped_type> pop(key_type key);

      // Accessors

      mapped_type * find(key_type key) const;

      bool exists(key_type key) const;

      key_type size() const;
    };

    } // namespace tokenmaps
    } // namespace boost

[heading Class template tokenmap]

[heading Nested types]

[heading Constructors, copy and assignment]

      tokenmap(size_t capacity, float load_factor, hash_type seed);

* [*Effects:] Constructs an empty `tokenmap`.
* [*Complexity:] Constant.

[endsect]

[section Performance ]

(this section requires far more work)

Below is a comparison of insertions and lookups, compiled with gcc 4.4.1: 

    typedef map<token, session*> map_type;
    typedef tokenmap<session, uint32_t> token_type;

    tokenmap insert: 0.107066 usecs per op
    stdmap insert: 0.693195 usecs per op

    tokenmap find: 0.011401 usecs per op
    stdmap find: 0.344964 usecs per op

[endsect]

[section Examples ]

In the folder [@../../example libs/tokenmap/example] you can find all the examples
used in tokenmap documentation. Here is a list of them:

[table Tutorial examples
[[Program                          ][Description                          ]]

[[[@../../example/simple_tokenmap.cpp
    simple_tokenmap.cpp                                                   ]]
    [Basic operations example                                             ]]
]

[endsect]

[section Rationale ]

Network applications based on various stateless protocols (UDP, HTTP) often require keeping 
track of sessions where a "session key" is exchanged between a server and a client. The server 
then maintains the client's state by having the session key mapped to an in-memory session object. 
Today, developers often use `std::map` for the purpose of such mapping, which has sub-optimal 
performance and requires users to come up with sufficiently hard to guess random keys.

Another example is that of a library API. Consider a shared library which internally manages
resources on behalf of its users. As an API author, you probably don't want to expose certain 
implementation details, such as pointers or iterators with your callers, yet you would
like to efficiently handle their calls. When you use `tokenmap`-generated keys, you are not sharing 
any implementation details, so it's harder for the users of the library to corrupt your internally
managed state. 

Additionally, unlike pointers, we're not dereferencing tokens, so it is perfectly OK for them 
to outlive the mapped-to-objects without the usual consequences of accessing stale pointers.

[endsect]

[section Acknowledgements]

[endsect]

