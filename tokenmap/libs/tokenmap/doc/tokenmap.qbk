[/ Copyright 2009 Slawomir Lisznianski
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) ]

[library Boost.Tokenmap
    [quickbook 1.4]
    [authors [Lisznianski, Slawomir]]
    [copyright 2009 Slawomir Lisznianski]
    [category container]
    [id tokenmap]
    [dirname tokenmap]
    [purpose
        Perfect hashmap with auto-generated pseudo-random keys.
    ]
    [source-mode c++]
    [license
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
[@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ QuickBook Document version 1.4 ]

[/ Logos ]

[def __BOOST_TOKENMAP_LOGO__ [$images/tokenmap/boost.tokenmap.logo.png]]
[def __GOOGLE_SOC_2006__ [$images/extern/googlesoc.png]]

[/ Helpers ]

[/ People ]

[def __SLAWOMIR_PHOTO__ [$images/people/slawomir.png]]

[/ Icons ]

[def __NOTE__ [$images/note.png]]
[def __ALERT__ [$images/caution.png]]
[def __DETAIL__ [$images/note.png]]
[def __TIP__ [$images/tip.png]]
[def __QUESTION_MARK__ [$images/question.png]]


[/ Boost Libraries ]

[def _boost_unordered_  [@../../libs/unordered/doc/html/unordered.html [*Boost.Unordered]]] 

[/ Extern Links ]

[def __CPP_STANDARD_LIBRARY_TECHNICAL_REPORT__ [@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf C++ Standard Library Technical Report]]
[def __CPP_DEFECT_REPORT_130__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130 Defect Report 130]]
[def __TR1_ISSUES_LIST__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1837.pdf Issues List]]

[def __BOOST_HASH_FUNCTION__ [@http://www.boost.org/regression-logs/cs-win32_metacomm/doc/html/hash.html boost::hash]]

[def __BOOST_PERMUTATION_ITERATOR__ [@http://www.boost.org/libs/iterator/doc/permutation_iterator.html `permutation_iterator`]]

[def __BOOST_ASSERT_MACRO__ [@where_it_is `BOOST_ASSERT`]]
[def __BOOST_MPL_FORWARD_SEQUENCE__ [@http://www.boost.org/libs/mpl/doc/refmanual/forward-sequence.html MPL Forward Sequence]]
[def __BOOST_MPL_RANDOM_ACCESS_SEQUENCE__ [@http://www.boost.org/libs/mpl/doc/refmanual/random-access-sequence.html MPL Random Access Sequence]]
[def __BOOST_MPL_EXTENSIBLE_SEQUENCE__ [@http://www.boost.org/libs/mpl/doc/refmanual/extensible-sequence.html MPL Extensible Sequence]]

[def __SGI_UNARY_FUNCTION__ [@http://www.sgi.com/tech/stl/UnaryFunction.html Unary Function]]
[def __SGI_BINARY_FUNCTION__ [@http://www.sgi.com/tech/stl/BinaryFunction.html Binary Function]]

[def __SGI_ASSIGNABLE__ [@http://www.sgi.com/tech/stl/Assignable.html Assignable]]
[def __SGI_DEFAULT_CONSTRUCTIBLE__ [@http://www.sgi.com/tech/stl/DefaultConstructible.html Default Constructible]]
[def __SGI_BINARY_PREDICATE__ [@http://www.sgi.com/tech/stl/BinaryPredicate.html Binary Predicate]]
[def __SGI_CONTAINER__ [@http://www.sgi.com/tech/stl/Container.html Container]]
[def __SGI_SORTED_ASSOCIATIVE_CONTAINER__ [@http://www.sgi.com/tech/stl/SortedAssociativeContainer.html Sorted Associative Container]]
[def __SGI_UNIQUE_ASSOCIATIVE_CONTAINER__ [@http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html Unique Associative Container]]
[def __SGI_REVERSIBLE_CONTAINER__ [@http://www.sgi.com/tech/stl/ReversibleContainer.html Reversible Container]]
[def __SGI_RANDOM_ACCESS_CONTAINER__ [@http://www.sgi.com/tech/stl/RandomAccessContainer.html Random Access Container]]
[def __SGI_FRONT_INSERTION_SEQUENCE__ [@http://www.sgi.com/tech/stl/FrontInsertionSequence.html Front Insertion Sequence]]
[def __SGI_BACK_INSERTION_SEQUENCE__ [@http://www.sgi.com/tech/stl/BackInsertionSequence.html Back Insertion Sequence]]
[def __SGI_INPUT_ITERATOR__ [@http://www.sgi.com/tech/stl/InputIterator.html Input Iterator]]
[def __SGI_FORWARD_ITERATOR__ [@http://www.sgi.com/tech/stl/ForwardIterator.o Forward Iterator]]
[def __SGI_STRICT_WEAK_ORDERING__ [@http://www.sgi.com/tech/stl/StrictWeakOrdering.html   Strict Weak Ordering]]

[def __EIFFEL__ [@http://www.eiffel.com/ Eiffel]]
[def __SAFE_STL__ [@http://www.horstmann.com/safestl.html Safe STL]]
[def __STL_PORT_DEBUG_MODE__ [@http://www.stlport.com/doc/debug_mode.html STLport Debug Mode]]

[def __CGAL__ [@http://www.cgal.org/ CGAL]]
[def __MYSQLPP__ [@http://tangentsoft.net/mysql++/ MySQL++]]


[def __STL_TREE_H__ [@http://www.sgi.com/tech/stl/stl_tree.h stl_tree.h]]
[def __ORDER_STATISTICS_TREE__ [@http://pine.cs.yale.edu/pinewiki/OrderStatisticsTree ['order-statistics trees]]]

[def __GENERIC_PROGRAMMING_MOVE_CONSTRUCTORS__ [@http://www.ddj.com/dept/cpp/184403855 "Generic<Programming>: Move Constructors]]
[def __CLARIFICATION_OF_INITIALIZATION__ [@http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2004/n1610.html "Clarification of Initialization of Class Objects by rvalues"]]


[/ Code snippets ]

[import ../example/simple_tokenmap.cpp]

[section Description]

A `tokenmap` is a data structure that uniquely maps pseudo-random generated keys with 
elements of the collection. 

Boost.Tokenmap is a (perfect) hash container library for C++. An important distinction 
between `tokenmap` and other dictionary-like containers, such as std::map or 
_boost_unordered_, is that `tokenmap` generates keys internally (referred to as 
"tokens") rather than relying on user to provide them. Specifically, when a new element
is inserted into the `tokenmap`, an apparently random key is returned back to the caller 
which uniquely maps to the stored element. The returned key can later be used in a very 
efficient lookup.

[endsect]

[section Quick tutorial]

Start by including the convenience header available in the boost directory:

    #include <boost/tokenmap.hpp>

Next, we define a `tokenmap` for storing strings. The following code creates an empty `tokenmap` 
container with initial capacity set to 10000, load factor set to 0.7 and current 
time as seed for pseudo-number generator:

    typedef boost::tokenmap<std::string, unsigned int> tokenmap_type;
    tokenmap_type names( 10000, 0.7, time(NULL) );

To insert elements into the container we do:

    tokenmap_type::value_type rob = 
        names.insert( "Robert DeNiro" );
    tokenmap_type::value_type mart = 
        names.insert( "Martin Scorsese" );

The value returned from insert is a pair, defined as std::pair<unsigned int, std::string*>.
The first element of the pair is an auto-generated token, whereas the second element
is a pointer to the element that maps to it.

With the returned token, we can perform efficient lookups on the container, for example:

    tokenmap_type::mapped_type * name = names.find( rob.first ); 

We can also check if an element exists:

    bool found = names.exists( rob.first );

Finally, we can remove the element:

    std::auto_ptr<map_type::mapped_type> take_over = 
        names.pop( rob.first );

[endsect]

[section Reference]

[heading Headers]

"boost/tokenmap.hpp" includes "boost/tokenmap/tokenmap.hpp" and imports the `tokenmap` class to boost namespace.

[heading Synopsis]

    namespace boost {
    namespace tokenmaps {

    template <typename value__, typename key__ = uint32_t>
    class tokenmap
    {
      public:

      // Metadata

      typedef uint64_t                           hash_type;
      typedef key__                              key_type;
      typedef value__                            mapped_type;
      typedef std::pair<key_type, mapped_type*>  value_type;

      // Constructor 

      tokenmap(size_t capacity, float load_factor, hash_type seed);

      // Destructor 

      ~tokenmap();

      // Modifiers

      value_type insert(mapped_type const & value);

      value_type insert(std::auto_ptr<mapped_type> value);

      std::auto_ptr<mapped_type> pop(key_type key);

      // Accessors

      mapped_type * find(key_type key) const;

      bool exists(key_type key) const;

      key_type size() const;
    };

    } // namespace tokenmaps
    } // namespace boost

[heading Class template tokenmap]

[heading Nested types]

[heading Constructors, copy and assignment]

      tokenmap(size_t capacity, float load_factor, hash_type seed);

* [*Effects:] Constructs an empty `tokenmap`.
* [*Complexity:] Constant.

[endsect]

[section Performance ]

(this section requires far more work)

Below is a comparison of insertions and lookups, compiled with gcc 4.4.1: 

    typedef map<token, session*> map_type;
    typedef tokenmap<session, uint32_t> token_type;

    tokenmap insert: 0.107066 usecs per op
    stdmap insert: 0.693195 usecs per op

    tokenmap find: 0.011401 usecs per op
    stdmap find: 0.344964 usecs per op

[endsect]

[section Examples ]

In the folder [@../../example libs/tokenmap/example] you can find all the examples
used in tokenmap documentation. Here is a list of them:

[table Tutorial examples
[[Program                          ][Description                          ]]

[[[@../../example/simple_tokenmap.cpp
    simple_tokenmap.cpp                                                   ]]
    [Basic operations example                                             ]]
]

[endsect]

[section Rationale ]

Network applications based on various stateless protocols (UDP, HTTP) often require keeping 
track of sessions where a "session key" is exchanged between a server and a client. The server 
then maintains the client's state by having the session key mapped to an in-memory session object. 
Today, developers often use `std::map` for the purpose of such mapping, which has sub-optimal 
performance and requires users to come up with sufficiently hard to guess random keys.

Another example is that of an API of a shared library. Consider a library which internally manages
resources on behave of its users. As an API author, you may wish not to share certain 
implementation details, such as pointers or iterators, with your users yet you would
like to efficiently dispatch API calls. When you use `tokenmap` generated keys, you are not sharing 
any such implementation details, ensuring users cannot corrupt your internally managed state. 

Additionally, since we're not dereferencing tokens, unlike pointers, it is perfectly OK for them 
to outlive the mapped-to-objects without the usual consequences of accessing stale pointers.

[endsect]

[section Acknowledgements ]
[endsect]

