<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>Boost I/O Manipulator Library</title>
</head>
<body>
<h1><img src="../../../c++boost.gif" alt="c++boost.gif (8819 bytes)"
align="middle" width="277" height="86">I/O Manipulator Library</h1>

<p>The header <cite><a
href="../../../boost/io/iomanip.hpp">boost/io/iomanip.hpp</a></cite>
covers C++ I/O stream-manipulating functions (possibly including
function templates and function-acting [template] classes).</p>

<h2><a name="contents">Contents</a></h2>

<ol>
	<li><a href="#contents">Contents</a></li>
	<li><a href="#rationale">Rationale</a></li>
	<li><a href="#g_header">Grouped Header</a>
		<ul>
			<li><a href="#gh_synopsis">Synopsis</a></li>
		</ul></li>
	<li><a href="#f_header">Form-based Manipulator Header</a>
		<ul>
			<li><a href="#fh_synopsis">Synopsis</a></li>
			<li><a href="#ios_form">Form-based Manipulator</a>
				<ul>
					<li><a href="#ios_form_types">Member Types &amp; Templates</a></li>
					<li><a href="#ios_form_ctr">Constructors</a></li>
					<li><a href="#ios_form_observe">Observer Member Functions</a></li>
					<li><a href="#ios_form_mutate">Mutating Member Functions</a></li>
					<li><a href="#ios_form_ops">Operators</a></li>
				</ul></li>
		</ul></li>
	<li><a href="#gn_header">General Manipulator Header</a>
		<ul>
			<li><a href="#gnh_synopsis">Synopsis</a></li>
			<li><a href="#resetios">Stream Formatting State-reset Manipulator</a></li>
		</ul></li>
	<li><a href="#r_header">Repeated-character Manipulator Header</a>
		<ul>
			<li><a href="#rh_synopsis">Synopsis</a></li>
			<li><a href="#repeatch">Repeated-character Manipulator</a></li>
			<li><a href="#repeatchar">Repeated-narrow-character Manipulator</a></li>
		</ul></li>
	<li><a href="#i_header">Input-oriented Manipulator Header</a>
		<ul>
			<li><a href="#ih_synopsis">Synopsis</a></li>
			<li><a href="#mskipl">Repeated-line-break Input Manipulator</a></li>
			<li><a href="#skipl">Line-skipping Input Manipulator</a></li>
		</ul></li>
	<li><a href="#o_header">Output-oriented Manipulator Header</a>
		<ul>
			<li><a href="#oh_synopsis">Synopsis</a></li>
			<li><a href="#mnewl">Repeated-line-break Output Manipulator</a></li>
			<li><a href="#newl">Non-flushing Line-break Output Manipulator</a></li>
		</ul></li>
	<li><a href="#e_header">Expected-input Manipulator Header</a>
		<ul>
			<li><a href="#eh_synopsis">Synopsis</a></li>
			<li><a href="#expect">Expected Character Sequence Input Manipulator</a></li>
			<li><a href="#expect_example">Example</a></li>
		</ul></li>
	<li><a href="#refer">References</a></li>
	<li><a href="#credits">Credits</a>
		<ul>
			<li><a href="#contributors">Contributors</a></li>
			<li><a href="#history">History</a></li>
		</ul></li>
</ol>

<h2><a name="rationale">Rationale</a></h2>

<p>There are several I/O manipulators that can be useful to a general
audience besides the ones given in the Standard library.  This header
supplies some of them.</p>

<h2><a name="g_header">Grouped Header</a></h2>

<p>The header <cite><a href="../../../boost/io/iomanip.hpp">boost/io/iomanip.hpp</a></cite> simply includes all the headers of the individual manipulator categories.</p>

<h3><a name="gh_synopsis">Synopsis</a></h3>

<blockquote><pre>
#include &lt;boost/io/iomanip_expect.hpp&gt;
#include &lt;boost/io/iomanip_form.hpp&gt;
#include &lt;boost/io/iomanip_general.hpp&gt;
#include &lt;boost/io/iomanip_in.hpp&gt;
#include &lt;boost/io/iomanip_out.hpp&gt;
#include &lt;boost/io/iomanip_repeat.hpp&gt;
</pre></blockquote>

<h2><a name="f_header">Form-based Manipulator Header</a></h2>

<p>The header <cite><a href="../../../boost/io/iomanip_form.hpp">boost/io/iomanip_form.hpp</a></cite> contains a class template for multiple manipulations.</p>

<h3><a name="fh_synopsis">Synopsis</a></h3>

<blockquote><pre>
#include &lt;iosfwd&gt;  <i>// for std::char_traits (declaration)</i>

namespace boost
{
namespace io
{

template &lt; typename Ch, class Tr = std::char_traits&lt;Ch&gt; &gt;
    class basic_ios_form;

typedef basic_ios_form&lt;char&gt;      ios_form;
typedef basic_ios_form&lt;wchar_t&gt;  wios_form;

}
}
</pre></blockquote>

<h3><a name="ios_form">Form-based Manipulator</a></h3>

<p>Objects from a <code>boost::io::basic_ios_form</code> template class represent manipulators that determine what and how to affect the standard I/O attributes via repeated calls to its member functions, then can change how a single insertion or extraction call happens for an streamable object.  Said manipulators can be temporarily created (in-line, without a name) or created conventionally in advance for multiple insertions/extractions.</p>

<blockquote><pre>
#include &lt;ios&gt;  <i>// for std::streamsize, std::ios_base, and std::basic_ios</i>

template &lt; typename Ch, class Tr &gt;
class boost::io::basic_ios_form
{
    template &lt; typename Obj &gt;  struct binder_out;
    template &lt; typename Obj &gt;  struct binder_inout;

public:
    // Template arguments
    typedef Ch  char_type;
    typedef Tr  traits_type;

    // Lifetime management (use automatic destructor and copy constructor)
              basic_ios_form();
    explicit  basic_ios_form( std::basic_ios&lt;Ch, Tr&gt; const &amp;i );

    // Accessors
    bool  override_fill() const;
    bool  override_precision() const;
    bool  override_width() const;

    std::ios_base::fmtflags  overridden_flags() const;
    bool                     override_flags() const;

    bool  override_adjustfield() const;
    bool  override_basefield() const;
    bool  override_floatfield() const;

    bool  override_boolalpha() const;
    bool  override_showbase() const;
    bool  override_showpoint() const;
    bool  override_showpos() const;
    bool  override_skipws() const;
    bool  override_unitbuf() const;
    bool  override_uppercase() const;

    char_type                fill() const;
    std::streamsize          precision() const;
    std::streamsize          width() const;
    std::ios_base::fmtflags  flags() const;

    // Mutators
    basic_ios_form &amp;  fill( char_type const &amp;c );

    basic_ios_form &amp;  precision( std::streamsize s );
    basic_ios_form &amp;  width( std::streamsize s );

    basic_ios_form &amp;    flag( std::ios_base::fmtflags f );
    basic_ios_form &amp;  unflag( std::ios_base::fmtflags f );
    basic_ios_form &amp;    flags( std::ios_base::fmtflags f, std::ios_base::fmtflags mask );

    basic_ios_form &amp;  boolalpha();
    basic_ios_form &amp;  noboolalpha();

    basic_ios_form &amp;  showbase();
    basic_ios_form &amp;  noshowbase();

    basic_ios_form &amp;  showpoint();
    basic_ios_form &amp;  noshowpoint();

    basic_ios_form &amp;  showpos();
    basic_ios_form &amp;  noshowpos();

    basic_ios_form &amp;  skipws();
    basic_ios_form &amp;  noskipws();

    basic_ios_form &amp;  unitbuf();
    basic_ios_form &amp;  nounitbuf();

    basic_ios_form &amp;  uppercase();
    basic_ios_form &amp;  nouppercase();

    basic_ios_form &amp;  internal();
    basic_ios_form &amp;  left();
    basic_ios_form &amp;  right();

    basic_ios_form &amp;  dec();
    basic_ios_form &amp;  hex();
    basic_ios_form &amp;  oct();

    basic_ios_form &amp;  fixed();
    basic_ios_form &amp;  scientific();

    // Operators
    template &lt; typename Obj &gt;
    binder_out&lt;Obj&gt;  operator ()( Obj const &amp;o ) const;

    template &lt; typename Obj &gt;
    binder_inout&lt;Obj&gt;  operator ()( Obj &amp;o ) const;

};
</pre></blockquote>

<p>The template parameters <var>Ch</var> and <var>Tr</var> represent the character and character traits types for the streams that can use this manipulator type.  The <code>char_type</code> and <code>traits_type</code> aliases reveals those types when the parameters of the manipulator type are hidden by a <code>typedef</code>.</p>

<h4><a name="ios_form_types">Member Types &amp; Templates</a></h4>

<dl>
	<dt><code>char_type</code>
	<dd>a synonym for the manipulator's character type

	<dt><code>traits_type</code>
	<dd>a synonym for the manipulator's character-traits type

	<dt><code>template &lt; typename Obj &gt;  struct binder_out;</code>
	<dd>type of temporary objects returned when using this manipulator type with a constant object; (output) streaming this object results in streaming the constant object with the attributes given by this manipulator type

	<dt><code>template &lt; typename Obj &gt;  struct binder_inout;</code>
	<dd>type of temporary objects returned when using this manipulator type with a mutable object; streaming this object results in streaming the mutable object with the attributes given by this manipulator type
</dl>

<h4><a name="ios_form_ctr">Constructors</a></h4>

<p><strong>Note:</strong> the automatically-defined destructor and copy constructor are used.</p>

<dl>
	<dt><code>basic_ios_form();</code>
	<dd>
		<strong>Effects:</strong> initializes all the usage flags to FALSE (<i>i.e.</i> no attributes will be overridden); sets the saved attributes to arbitrary values

	<dt><code>explicit  basic_ios_form( std::basic_ios&lt;Ch, Tr&gt; const &amp;i );</code>
	<dd>
		<strong>Effects:</strong> initializes all the usage flags to TRUE (<i>i.e.</i> all attributes will be overridden); sets the saved attributes to copies of the attributes in stream <var>i</var>
</dl>

<h4><a name="ios_form_observe">Observer Member Functions</a></h4>

<dl>
	<dt><code>bool  override_fill() const;</code><br>
	    <code>bool  override_precision() const;</code><br>
	    <code>bool  override_width() const;</code><br>
	    <code>bool  override_flags() const;</code>
	<dd>
		<strong>Returns:</strong> whether or not attribute <var>XX</var> of <code>override_<var>XX</var></code> has been overridden in this manipulator object<br>
		<strong>Rationale:</strong> status indicator of which attribute changes will be applied

	<dt><code>std::ios_base::fmtflags  overridden_flags() const;</code>
	<dd>
		<strong>Returns:</strong> which format flags have been overridden; returns the equivalent of zero if <code>this-&gt;override_flags()</code> returns FALSE<br>
		<strong>Rationale:</strong> status indicator of which specific format-flag attribute changes will be applied

	<dt><code>bool  override_adjustfield() const;</code><br>
	    <code>bool  override_basefield() const;</code><br>
	    <code>bool  override_floatfield() const;</code><br>
	    <code>bool  override_boolalpha() const;</code><br>
	    <code>bool  override_showbase() const;</code><br>
	    <code>bool  override_showpoint() const;</code><br>
	    <code>bool  override_showpos() const;</code><br>
	    <code>bool  override_skipws() const;</code><br>
	    <code>bool  override_unitbuf() const;</code><br>
	    <code>bool  override_uppercase() const;</code>
	<dd>
		<strong>Returns:</strong> for attribute <var>XX</var> of member function <code>override_<var>XX</var></code>, <code>0 != ( std::ios_base::<var>XX</var> &amp; this-&gt;overridden_flags() )</code><br>
		<strong>Rationale:</strong> status indicator of which subset of format-flag attribute changes will be applied

	<dt><code>char_type                fill() const;</code><br>
	    <code>std::streamsize          precision() const;</code><br>
	    <code>std::streamsize          width() const;</code><br>
	    <code>std::ios_base::fmtflags  flags() const;</code>
	<dd>
		<strong>Preconditions:</strong> for attribute <var>XX</var> of member function <code><var>XX</var></code>, <code>this-&gt;override_<var>XX</var>()</code> must return TRUE<br>
		<strong>Returns:</strong> the attribute value that will be applied to any streams using this manipulator object (for <code>flags</code>, only the flags masked by <code>this-&gt;overridden_flags()</code> will be changed in any applied stream)<br>
		<strong>Rationale:</strong> values of the actual changes to be applied
</dl>

<h4><a name="ios_form_mutate">Mutating Member Functions</a></h4>

<dl>
	<dt><code>basic_ios_form &amp;  fill( char_type const &amp;c );</code><br>
	    <code>basic_ios_form &amp;  precision( std::streamsize s );</code><br>
	    <code>basic_ios_form &amp;  width( std::streamsize s );</code>
	<dd>
		<strong>Effects:</strong> for attribute <var>XX</var> of member function <code><var>XX</var></code>, changes that attribute to the value of the given argument <var>c</var> or <var>s</var> (for <code>fill</code>, the copying routine from the character-traits type is used)<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_<var>XX</var>()</code> becomes TRUE<br>
		<strong>Rationale:</strong> setting the changes to be applied

	<dt><code>basic_ios_form &amp;  flag( std::ios_base::fmtflags f );</code>
	<dd>
		<strong>Effects:</strong> adds the flags selected in <var>f</var> to the replacement flag list in the active state and to the mask of overridden flags<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( <var>f</var> &amp; this-&gt;overridden_flags() )</code> and <code>( <var>f</var> &amp; this-&gt;flags() )</code> become <var>f</var><br>
		<strong>Rationale:</strong> setting the changes of specific active format flags to be applied

	<dt><code>basic_ios_form &amp;  unflag( std::ios_base::fmtflags f );</code>
	<dd>
		<strong>Effects:</strong> adds the flags selected in <var>f</var> to the replacement flag list in the inactive state and to the mask of overridden flags<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( <var>f</var> &amp; this-&gt;overridden_flags() )</code> becomes <var>f</var>; <code>( <var>f</var> &amp; this-&gt;flags() )</code> becomes zero<br>
		<strong>Rationale:</strong> setting the changes of specific inactive format flags to be applied

	<dt><code>basic_ios_form &amp;  flags( std::ios_base::fmtflags f, std::ios_base::fmtflags mask );</code>
	<dd>
		<strong>Effects:</strong> adds the flags selected in <var>mask</var> to the replacement flag list in the state given in <var>f</var> (restricted by <var>mask</var>);  adds the flags selected in <var>mask</var> to the mask of overridden flags<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( <var>mask</var> &amp; this-&gt;overridden_flags() )</code> becomes <var>mask</var>; <code>( <var>mask</var> &amp; this-&gt;flags() )</code> becomes <code>( <var>f</var> &amp; <var>mask</var> )</code><br>
		<strong>Rationale:</strong> setting the changes to be applied for a specific set of format flags and values

	<dt><code>basic_ios_form &amp;  boolalpha();</code><br>
	    <code>basic_ios_form &amp;  showbase();</code><br>
	    <code>basic_ios_form &amp;  showpoint();</code><br>
	    <code>basic_ios_form &amp;  showpos();</code><br>
	    <code>basic_ios_form &amp;  skipws();</code><br>
	    <code>basic_ios_form &amp;  unitbuf();</code><br>
	    <code>basic_ios_form &amp;  uppercase();</code>
	<dd>
		<strong>Effects:</strong> for attribute <var>XX</var> of member function <code><var>XX</var></code>, adds that format flag to the replacement flag list in the active state and to the mask of overriden flags<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( std::ios_base::<var>XX</var> &amp; this-&gt;overridden_flags() )</code> and <code>( std::ios_base::<var>XX</var> &amp; this-&gt;flags() )</code> become <code>std::ios_base::<var>XX</var></code><br>
		<strong>Rationale:</strong> setting the changes to be applied for a single active format flag

	<dt><code>basic_ios_form &amp;  noboolalpha();</code><br>
	    <code>basic_ios_form &amp;  noshowbase();</code><br>
	    <code>basic_ios_form &amp;  noshowpoint();</code><br>
	    <code>basic_ios_form &amp;  noshowpos();</code><br>
	    <code>basic_ios_form &amp;  noskipws();</code><br>
	    <code>basic_ios_form &amp;  nounitbuf();</code><br>
	    <code>basic_ios_form &amp;  nouppercase();</code>
	<dd>
		<strong>Effects:</strong> for attribute <var>XX</var> of member function <code>no<var>XX</var></code>, adds that format flag to the replacement flag list in the inactive state and to the mask of overriden flags<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( std::ios_base::<var>XX</var> &amp; this-&gt;overridden_flags() )</code> becomes <code>std::ios_base::<var>XX</var></code>; <code>( std::ios_base::<var>XX</var> &amp; this-&gt;flags() )</code> becomes zero<br>
		<strong>Rationale:</strong> setting the changes to be applied for a single inactive format flag

	<dt><code>basic_ios_form &amp;  internal();</code><br>
	    <code>basic_ios_form &amp;  left();</code><br>
	    <code>basic_ios_form &amp;  right();</code><br>
	    <code>basic_ios_form &amp;  dec();</code><br>
	    <code>basic_ios_form &amp;  hex();</code><br>
	    <code>basic_ios_form &amp;  oct();</code><br>
	    <code>basic_ios_form &amp;  fixed();</code><br>
	    <code>basic_ios_form &amp;  scientific();</code>
	<dd>
		<strong>Effects:</strong> for attribute <var>XX</var> of member function <code><var>XX</var></code> and matching mask attribute <var>YY</var>, adds the flags selected in <var>YY</var> to the replacement flags list in the state given by <var>XX</var>; adds the flags selected in <var>YY</var> to the mask of overridden flags (for <code>internal</code>, <code>left</code>, and <code>right</code>, <var>YY</var> is <code>adjustfield</code>; for <code>dec</code>, <code>hex</code>, and <code>oct</code>, <var>YY</var> is <code>basefield</code>; and for <code>fixed</code> and <code>scientific</code>, <var>YY</var> is <code>floatfield</code>)<br>
		<strong>Returns:</strong> <code>*this</code><br>
		<strong>Postconditions:</strong> <code>this-&gt;override_flags()</code> becomes TRUE; <code>( std::ios_base::<var>YY</var> &amp; this-&gt;overridden_flags() )</code> and <code>( std::ios_base::<var>YY</var> &amp; this-&gt;flags() )</code> become <code>std::ios_base::<var>XX</var></code><br>
		<strong>Rationale:</strong> setting the changes to be applied for a single state within a group of format flag values
</dl>

<h4><a name="ios_form_ops">Operators</a></h4>

<p><strong>Note:</strong> the automatically-defined assignment operator is used.</p>

<dl>
	<dt><code>template &lt; typename Obj &gt;  binder_out&lt;Obj&gt;  operator ()( Obj const &amp;o ) const;</code>
	<dd>
		<strong>Returns:</strong> an object <var>x</var>, that contains constant references to <code>*this</code> and <var>o</var>; when <code><var>s</var> &lt;&lt; <var>x</var></code> is applied, such that <var>s</var> is an output stream object, <code><var>s</var> &lt;&lt; <var>o</var></code> will occur, with <var>s</var>'s attributes temporarily set to the ones in <code>*this</code>, in effect only during this streaming call; specifically, if <code>this-&gt;override_flags()</code>, then <code><var>s</var>.flags() == ( (this-&gt;flags() &amp; this-&gt;overridden_flags()) | (<var>old_s_flags</var> &amp; ~this-&gt;overridden_flags()) )</code>, if <code>this-&gt;override_precision()</code>, then <code><var>s</var>.precision() == this-&gt;precision()</code>, if <code>this-&gt;override_width()</code>, then <code><var>s</var>.width() == this-&gt;width()</code>, and if <code>this-&gt;override_fill()</code>, then <code>traits_type::eq( <var>s</var>.fill(), this-&gt;fill() )</code><br>
		<strong>Rationale:</strong> lets this manipulator actually do its work for output

	<dt><code>template &lt; typename Obj &gt;  binder_inout&lt;Obj&gt;  operator ()( Obj &amp;o ) const;</code>
	<dd>
		<strong>Returns:</strong> an object <var>x</var>, that contains a constant reference to <code>*this</code> and a non-constant reference to <var>o</var>; when <code><var>s</var> &lt;&lt; <var>x</var></code> or <code><var>s</var> &gt;&gt; <var>x</var></code> is applied, such that <var>s</var> is a stream object, <code><var>s</var> &lt;&lt; <var>o</var></code> or <code><var>s</var> &gt;&gt; <var>o</var></code> will occur, with <var>s</var>'s attributes temporarily set to the ones in <code>*this</code>, in effect only during this streaming call; specifically, if <code>this-&gt;override_flags()</code>, then <code><var>s</var>.flags() == ( (this-&gt;flags() &amp; this-&gt;overridden_flags()) | (<var>old_s_flags</var> &amp; ~this-&gt;overridden_flags()) )</code>, if <code>this-&gt;override_precision()</code>, then <code><var>s</var>.precision() == this-&gt;precision()</code>, if <code>this-&gt;override_width()</code>, then <code><var>s</var>.width() == this-&gt;width()</code>, and if <code>this-&gt;override_fill()</code>, then <code>traits_type::eq( <var>s</var>.fill(), this-&gt;fill() )</code><br>
		<strong>Rationale:</strong> lets this manipulator actually do its work with non-constant objects (for input or output)
</dl>

<blockquote><pre>
template &lt; typename Ch, class Tr, typename Obj &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;os, boost::io::basic_ios_form&lt;Ch, Tr&gt;::binder_out&lt;Obj&gt; const &amp;b );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>os</var> &lt;&lt; <var>X</var></code>, where <var>X</var> is the streamable object held in reference by <var>b</var>; the stream <var>os</var> temporarily uses the stream attributes selected by the manipulator object held in reference by <var>b</var></p>

<p><strong>Returns:</strong> <var>os</var></p>

<p><strong>Rationale:</strong> enables <code>basic_ios_form&lt;&gt;</code> objects to be activated by output streaming for constant streamable objects</p>

<blockquote><pre>
template &lt; typename Ch, class Tr, typename Obj &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;os, boost::io::basic_ios_form&lt;Ch, Tr&gt;::binder_inout&lt;Obj&gt; const &amp;b );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>os</var> &lt;&lt; <var>X</var></code>, where <var>X</var> is the streamable object held in reference by <var>b</var>; the stream <var>os</var> temporarily uses the stream attributes selected by the manipulator object held in reference by <var>b</var></p>

<p><strong>Returns:</strong> <var>os</var></p>

<p><strong>Rationale:</strong> enables <code>basic_ios_form&lt;&gt;</code> objects to be activated by output streaming for mutable streamable objects</p>

<blockquote><pre>
template &lt; typename Ch, class Tr, typename Obj &gt;
std::basic_istream&lt;Ch, Tr&gt; &amp;
boost::io::operator &gt;&gt;( std::basic_istream&lt;Ch, Tr&gt; &amp;is, boost::io::basic_ios_form&lt;Ch, Tr&gt;::binder_inout&lt;Obj&gt; const &amp;b );
</pre></blockquote>

<p><strong>Effects:</strong> calls <code><var>is</var> &gt;&gt; <var>X</var></code>, where <var>X</var> is the streamable object held in reference by <var>b</var>; the stream <var>is</var> temporarily uses the stream attributes selected by the manipulator object held in reference by <var>b</var></p>

<p><strong>Returns:</strong> <var>is</var></p>

<p><strong>Rationale:</strong> enables <code>basic_ios_form&lt;&gt;</code> objects to be activated by input streaming for mutable streamable objects</p>

<h2><a name="gn_header">General Manipulator Header</a></h2>

<p>The header <cite><a href="../../../boost/io/iomanip_general.hpp">boost/io/iomanip_general.hpp</a></cite> contains the simple manipulators that can affect input- and output-oriented streams.</p>

<h3><a name="gnh_synopsis">Synopsis</a></h3>

<blockquote><pre>
#include &lt;iosfwd&gt;  <i>// for std::basic_ios (declaration)</i>

namespace boost
{
namespace io
{

template &lt; typename Ch, class Tr &gt;
    std::basic_ios&lt;Ch, Tr&gt; &amp;  resetios( std::basic_ios&lt;Ch, Tr&gt; &amp;s );

}
}
</pre></blockquote>

<h3><a name="resetios">Stream Formatting State-reset Manipulator</a></h3>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_ios&lt;Ch, Tr&gt; &amp;
boost::io::resetios( std::basic_ios&lt;Ch, Tr&gt; &amp;s );
</pre></blockquote>

<p><strong>Effects:</strong> resets the formatting attributes of stream
<var>s</var>, except locale, to their default values</p>

<p><strong>Returns:</strong> <var>s</var></p>

<p><strong>Postconditions:</strong> <code><var>s</var>.flags() == (
std::ios_base::skipws | std::ios_base::dec ) &amp;&amp; <var>s</var>.width()
== 0 &amp;&amp; <var>s</var>.precision() == 6 &amp;&amp; Tr::eq(
<var>s</var>.fill(), <var>s</var>.widen(' ') )</code></p>

<p><strong>Rationale:</strong> a quick method to reset all the formatting
attributes of a stream, especially after many attribute changes</p>

<h2><a name="r_header">Repeated-character Manipulator Header</a></h2>

<p>The header <cite><a href="../../../boost/io/iomanip_repeat.hpp">boost/io/iomanip_repeat.hpp</a></cite> contains manipulators that insert or extract a specific character value to/from a stream repeatedly.</p>

<h3><a name="rh_synopsis">Synopsis</a></h3>

<blockquote><pre>
#include &lt;iosfwd&gt;  <i>// for std::basic_istream and std::basic_ostream (declarations)</i>

namespace boost
{
namespace io
{

template &lt; typename Ch &gt;
    class repeat_ch;

template &lt; typename Ch, class Tr &gt;
    std::basic_istream&lt;Ch, Tr&gt; &amp;  operator &gt;&gt;( std::basic_istream&lt;Ch, Tr&gt; &amp;s, repeat_ch&lt;Ch> const &amp;r );

template &lt; typename Ch, class Tr &gt;
    std::basic_ostream&lt;Ch, Tr&gt; &amp;  operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;s, repeat_ch&lt;Ch> const &amp;r );

class repeat_char;

template &lt; typename Ch, class Tr &gt;
    std::basic_istream&lt;Ch, Tr&gt; &amp;  operator &gt;&gt;( std::basic_istream&lt;Ch, Tr&gt; &amp;s, repeat_char const &amp;r );

template &lt; typename Ch, class Tr &gt;
    std::basic_ostream&lt;Ch, Tr&gt; &amp;  operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;s, repeat_char const &amp;r );

}
}
</pre></blockquote>

<h3><a name="repeatch">Repeated-character Manipulator</a></h3>

<p>Objects from a <code>boost::io::repeat_ch</code> template class represent manipulators that have a given stream repeatedly process several copies of a particular character value.  Said manipulators can be temporarily created, in-line without a name, or created on the stack in advance for several uses.  Such uses can be through the conventional extraction or insertion operators, or through a function-call interface.</p>

<blockquote><pre>
#include &lt;ios&gt;      <i>// for std::streamsize</i>
#include &lt;istream&gt;  <i>// for std::basic_istream</i>
#include &lt;ostream&gt;  <i>// for std::basic_ostream</i>

template &lt; typename Ch &gt;
class boost::io::repeat_ch
{
public:
    // Template argument
    typedef Ch  char_type;

    // Lifetime management
    repeat_ch( char_type c, std::streamsize count, bool synchronize_afterwards = false );

    // Accessors
    char_type        repeated_char() const;
    std::streamsize  repeat_count() const;
    bool             will_synchronize_afterwards() const;

    // Operators
    template &lt; class Tr &gt;
    void  operator ()( std::basic_istream&lt;Ch, Tr&gt; &amp;is ) const;

    template &lt; class Tr &gt;
    void  operator ()( std::basic_ostream&lt;Ch, Tr&gt; &amp;os ) const;

};
</pre></blockquote>

<p>The template parameter <var>Ch</var> represents the type of the repeatedly extracted or inserted character value.  The <code>char_type</code> alias reveals that type in the interface (helpful if the template parameter is hidden by a <code>typedef</code>).</p>

<p>The first constructor argument is the character value <var>c</var> to be repeatedly processed.  The second constructor argument is the repeat <var>count</var> that will be performed per call.  The third constructor argument, <var>synchronize_afterwards</var>, flags whether or not a synchronization (a.k.a. &quot;flushing&quot;) will occur at the end of a call.  The third argument is optional and defaults to FALSE, meaning that the synchronization step is skipped.  The values of the three constructor arguments can be inspected with the <code>repeated_char</code>, <code>repeat_count</code>, and <code>will_synchronize_afterwards</code> member functions, respectively.</p>

<p>There are two function-call operator templates defined.  Each operator takes a single argument, a stream which must use the same character type as the manipulator but can have any character-traits type.  One operator takes only input streams, the other only output streams.  (A combined stream must first be cast to a reference to its input-stream base type or its output-stream base type, as appropiate.)</p>

<p>When an input stream <var>is</var> is applied to the manipulator, <code>this-&gt;repeat_count()</code> copies of the <code>this-&gt;repeated_char()</code> value will be read for and extracted from <var>is</var>.  Any intervening characters of other values are extracted and ignored.  If <code>this-&gt;will_synchronize_afterwards()</code> is TRUE, then <code><var>is</var>.sync()</code> is called.  The process shall stop at any point if <var>is</var> is in a bad state immediately before that point.</p>

<p>When an output stream <var>os</var> is applied to the manipulator, <code>this-&gt;repeat_count()</code> copies of the <code>this-&gt;repeated_char()</code> value will be inserted to <var>os</var>.  If <code>this-&gt;will_synchronize_afterwards()</code> is TRUE, then <code><var>os</var>.flush()</code> is called.  The process shall stop at any point if <var>os</var> is in a bad state immediately before that point.</p>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_istream&lt;Ch, Tr&gt; &amp;
boost::io::operator &gt;&gt;( std::basic_istream&lt;Ch, Tr&gt; &amp;s, boost::io::repeat_ch&lt;Ch&gt; const &amp;r );

template &lt; typename Ch, class Tr &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;s, boost::io::repeat_ch&lt;Ch&gt; const &amp;r );
</pre></blockquote>

<p><strong>Effects:</strong> call <code><var>r</var>( <var>s</var> )</code></p>

<p><strong>Returns:</strong> <var>s</var></p>

<p><strong>Rationale:</strong> enable <code>repeat_ch&lt;&gt;</code> objects to be activated by streaming</p>

<h3><a name="repeatchar">Repeated-narrow-character Manipulator</a></h3>

<p>Objects from the <code>boost::io::repeat_char</code> class represent manipulators that have a given stream repeatedly process several copies of a particular value of type <code>char</code>.  Said manipulators can be temporarily created, in-line without a name, or created on the stack in advance for several uses.  Such uses can be through the conventional extraction or insertion operators, or through a function-call interface.</p>

<blockquote><pre>
#include &lt;ios&gt;      <i>// for std::streamsize</i>
#include &lt;istream&gt;  <i>// for std::basic_istream</i>
#include &lt;ostream&gt;  <i>// for std::basic_ostream</i>

class boost::io::repeat_char
{
public:
    // Type
    typedef char  char_type;

    // Lifetime management
    repeat_char( char c, std::streamsize count, bool synchronize_afterwards = false );

    // Accessors
    char             repeated_char() const;
    std::streamsize  repeat_count() const;
    bool             will_synchronize_afterwards() const;

    // Operators
    template &lt; typename Ch, class Tr &gt;
    void  operator ()( std::basic_istream&lt;Ch, Tr&gt; &amp;is ) const;

    template &lt; typename Ch, class Tr &gt;
    void  operator ()( std::basic_ostream&lt;Ch, Tr&gt; &amp;os ) const;

};
</pre></blockquote>

<p>This class has an interface nearly identical to <code>repeat_ch&lt;char&gt;</code>.  Please see <a href="#repeatch">that class template</a> for more information.  The main difference is that the function-call operators can accept streams that vary on their character type in addition to varying on their character-traits type.  When a stream <var>s</var> is applied to a manipulator, first a widened character value is synthesized via <code><var>s</var>.widen( this-&gt;repeated_char() )</code>, then the semantics of the equivalent operator in <code>repeat_ch&lt;&gt;</code> take over.</p>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_istream&lt;Ch, Tr&gt; &amp;
boost::io::operator &gt;&gt;( std::basic_istream&lt;Ch, Tr&gt; &amp;s, boost::io::repeat_char const &amp;r );

template &lt; typename Ch, class Tr &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::operator &lt;&lt;( std::basic_ostream&lt;Ch, Tr&gt; &amp;s, boost::io::repeat_char const &amp;r );
</pre></blockquote>

<p><strong>Effects:</strong> call <code><var>r</var>( <var>s</var> )</code></p>

<p><strong>Returns:</strong> <var>s</var></p>

<p><strong>Rationale:</strong> enable <code>repeat_char</code> objects to be activated by streaming</p>

<h2><a name="i_header">Input-oriented Manipulator Header</a></h2>

<p>The header <cite><a href="../../../boost/io/iomanip_in.hpp">boost/io/iomanip_in.hpp</a></cite> contains the simple manipulators that can affect input-oriented streams.</p>

<h3><a name="ih_synopsis">Synopsis</a></h3>

<blockquote><pre>
#include &lt;iosfwd&gt;  <i>// for std::basic_istream (declaration)</i>
#include &lt;ios&gt;     <i>// for std::streamsize</i>

#include &lt;boost/io_fwd.hpp&gt;  <i>// for boost::io::repeat_char</i>

namespace boost
{
namespace io
{

repeat_char  skip_lines( std::streamsize count, bool final_sync = false );

template &lt; typename Ch, class Tr &gt;
    std::basic_istream&lt;Ch, Tr&gt; &amp;  skipl( std::basic_istream&lt;Ch, Tr&gt; &amp;is );

}
}
</pre></blockquote>

<h3><a name="mskipl">Repeated-line-break Input Manipulator</a></h3>

<blockquote><pre>
<em>smanip</em>
boost:io::skip_lines( std::streamsize count, bool final_sync = false );
</pre></blockquote>

<p><strong>Returns:</strong> an object <code>s</code> such that <code>is &gt;&gt; s</code>, when <code>is</code> is a <code>std::basic_istream&lt;&gt;</code>, extracts (unformatted) and ignores all characters until <var>count</var> instances of the line-break character have been encountered (or when the end-of-file is reached), followed by a synchronization to <code>is</code> if <var>final_sync</var> is TRUE</p>

<p><strong>Rationale:</strong> gives a method of removing several consecutive lines, with or without additional syncing behavior</p>

<h3><a name="skipl">Line-skipping Input Manipulator</a></h3>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_istream&lt;Ch, Tr&gt; &amp;
boost:io::skipl( std::basic_istream&lt;Ch, Tr&gt; &amp;is );
</pre></blockquote>

<p><strong>Effects:</strong> passes over all the characters in stream
<var>is</var> until the first encountered new-line character (sequence)
is passed, or the stream's end is reached</p>

<p><strong>Returns:</strong> <var>is</var></p>

<p><strong>Rationale:</strong> a counterpart to <a
href="#newl"><code>newl</code></a></p>

<h2><a name="o_header">Output-oriented Manipulator Header</a></h2>

<p>The header <cite><a href="../../../boost/io/iomanip_out.hpp">boost/io/iomanip_out.hpp</a></cite> contains the simple manipulators that can affect output-oriented streams.</p>

<h3><a name="oh_synopsis">Synopsis</a></h3>

<blockquote><pre>
#include &lt;iosfwd&gt;  <i>// for std::basic_ostream (declaration)</i>
#include &lt;ios&gt;     <i>// for std::streamsize</i>

#include &lt;boost/io_fwd.hpp&gt;  <i>// for boost::io::repeat_char</i>

namespace boost
{
namespace io
{

repeat_char  new_lines( std::streamsize count, bool final_flush = false );

template &lt; typename Ch, class Tr &gt;
    std::basic_ostream&lt;Ch, Tr&gt; &amp;  newl( std::basic_ostream&lt;Ch, Tr&gt; &amp;os );

}
}
</pre></blockquote>

<h3><a name="mnewl">Repeated-line-break Output Manipulator</a></h3>

<blockquote><pre>
<em>smanip</em>
boost::io::new_lines( std::streamsize count, bool final_flush = false );
</pre></blockquote>

<p><strong>Returns:</strong> an object <code>s</code> such that <code>os &lt;&lt; s</code>, when <code>os</code> is a <code>std::basic_ostream&lt;&gt;</code>, inserts (unformatted) <var>count</var> instances of the line-break character, followed by a flush to <code>os</code> if <var>final_flush</var> is TRUE</p>

<p><strong>Rationale:</strong> gives a method of inserting several newlines consecutively, with or without additional flushing behavior</p>

<h3><a name="newl">Non-flushing Line-break Output Manipulator</a></h3>

<blockquote><pre>
template &lt; typename Ch, class Tr &gt;
std::basic_ostream&lt;Ch, Tr&gt; &amp;
boost::io::newl( std::basic_ostream&lt;Ch, Tr&gt; &amp;os );
</pre></blockquote>

<p><strong>Effects:</strong> inserts a new-line character (sequence),
appropiate for the stream's character type and locale, into stream
<var>os</var></p>

<p><strong>Returns:</strong> <var>os</var></p>

<p><strong>Rationale:</strong> gives a method of inserting a newline
that looks object-based, without either the additional flushing behavior
of <code>std::endl</code>, or the background formatting adjustments of
using <code>'\n'</code> (or <code>&quot;\n&quot;</code>) directly with
<code>operator &lt;&lt;</code></p>

<h2><a name="e_header">Expected-input Manipulator Header</a></h2>

<p>The header <cite><a href="../../../boost/io/iomanip_expect.hpp">boost/io/iomanip_expect.hpp</a></cite> contains advanced manipulators for reading exact character patterns from input-oriented streams.</p>

<h3><a name="eh_synopsis">Synopsis</a></h3>

<blockquote><pre>
#include &lt;ios&gt;     <i>// for std::streamsize</i>
#include &lt;string&gt;  <i>// for std::basic_string</i>

namespace boost
{
namespace io
{

template &lt; typename Ch &gt;
    <em>smanip1</em>  expect( Ch const *s );

template &lt; typename Ch &gt;
    <em>smanip2</em>  expect( Ch c, std::streamsize count = 1 );

template &lt; typename Ch, class Tr, class Al &gt;
    <em>smanip3</em>  expect( std::basic_string&lt;Ch, Tr, Al&gt; const &amp;s );

}
}
</pre></blockquote>

<h3><a name="expect">Expected Character Sequence Input Manipulator</a></h3>

<blockquote><pre>
template &lt; typename Ch &gt;
<em>smanip1</em>
boost::io::expect( Ch const *s );

template &lt; typename Ch &gt;
<em>smanip2</em>
boost::io::expect( Ch c, std::streamsize count = 1 );

template &lt; typename Ch, class Tr, class Al &gt;
<em>smanip3</em>
boost::io::expect( std::basic_string&lt;Ch, Tr, Al&gt; const &amp;s );
</pre></blockquote>

<p><strong>Returns:</strong> an object <code>x</code> such that <code>is &gt;&gt; x</code>, when <code>is</code> is a <code>std::basic_istream&lt;&gt;</code>, extracts (unformatted) either <var>count</var> consecutive occurrences of the character <var>c</var> or a copy of the C-string or C<sup>++</sup>-string <var>s</var>.  Extraction will end early if the stream reaches its end-of-file or if the next character cannot match within the given pattern.  A non-matching character is not extracted.  Early terminations of extraction will set the stream's failure state, which may throw an exception.</p>

<p><strong>Note:</strong> there are restrictions on what kinds of input stream each type of <code>expect</code> expression will interoperate.  The stream must have the same character type as the given string or character.  For C<sup>++</sup>-strings, the character-traits type must also match with the stream's.  (The allocator type is never used for determinating interoperablity.)  There is a special case for single (repeated) characters and C-strings based on the <code>char</code> type, those <code>expect</code> expressions may work with any stream; the characters in the expression will be expanded with the stream's <code>widen</code> member function before matching.</p>

<p><strong>Rationale:</strong> exact-character matching is one of the few capabilities of the <code>std::scanf</code> function that hasn't yet been duplicated in C<sup>++</sup>-style I/O.</p>

<h3><a name="expect_example">Example</a></h3>

<blockquote><pre>
#include &lt;boost/io/iomanip.hpp&gt;  <i>// for boost::io::expect</i>
#include &lt;cassert&gt;               <i>// for assert</i>
#include &lt;sstream&gt;               <i>// for std::istringstream and std::wistringstream</i>
#include &lt;string&gt;                <i>// for std::string and std::wstring</i>

int  main()
{
    using namespace std;
    using boost::io::expect;

    istringstream   ss1( &quot;abcdefg&quot; );

    assert( ss1 &gt;&gt; expect('a') );
    assert( ss1 &gt;&gt; expect(&quot;bc&quot;) );
    assert( ss1 &gt;&gt; expect(string( &quot;defg&quot; )) );

    wistringstream  ss2( L&quot;aabcdefg&quot; );

    assert( ss1 &gt;&gt; expect(L'a', 2) );
    assert( ss1 &gt;&gt; expect(L&quot;bc&quot;) );
    assert( ss1 &gt;&gt; expect(wstring( L&quot;defg&quot; )) );

    wistringstream  ss3( L&quot;hijjjjkl&quot; );

    assert( ss3 &gt;&gt; expect('h') );
    assert( ss3 &gt;&gt; expect(&quot;ij&quot;) );
    assert( ss3 &gt;&gt; expect('j', 3) );

    // Can't use <u>std::string</u> here.
    assert( ss3 &gt;&gt; expect(wstring( L&quot;kl&quot; )) );
}
</pre></blockquote>

<h2><a name="refer">References</a></h2>

<ul>
	<li>The I/O manipulator library group header: <cite><a
		href="../../../boost/io/iomanip.hpp">boost/io/iomanip.hpp</a></cite></li>
	<li>The header for the form-based manipulator: <cite><a
		href="../../../boost/io/iomanip_form.hpp">boost/io/iomanip_form.hpp</a></cite></li>
	<li>The header for general manipulators: <cite><a
		href="../../../boost/io/iomanip_general.hpp">boost/io/iomanip_general.hpp</a></cite></li>
	<li>The header for repeated-character manipulators: <cite><a
		href="../../../boost/io/iomanip_repeat.hpp">boost/io/iomanip_repeat.hpp</a></cite></li>
	<li>The header for input-oriented manipulators: <cite><a
		href="../../../boost/io/iomanip_in.hpp">boost/io/iomanip_in.hpp</a></cite></li>
	<li>The header for output-oriented manipulators: <cite><a
		href="../../../boost/io/iomanip_out.hpp">boost/io/iomanip_out.hpp</a></cite></li>
	<li>The header for expected-input manipulators: <cite><a
		href="../../../boost/io/iomanip_expect.hpp">boost/io/iomanip_expect.hpp</a></cite></li>
	<li>Some test/example code: <cite><a
		href="../test/iomanip_test.cpp">iomanip_test.cpp</a></cite></li>
</ul>

<h2><a name="credits">Credits</a></h2>

<h3><a name="contributors">Contributors</a></h3>

<dl>
	<dt><a href="http://www.josuttis.com">Nicolai Josuttis</a>
	<dd>Section 13.6.2 of his <cite>The C++ Standard Library: A Tutorial
		and Reference</cite> book is the basis of <a
		href="#skipl"><code>skipl</code></a> (called
		<code>ignore_line</code> in the book).

	<dt><a href="../../../people/dietmar_kuehl.htm">Dietmar Kuehl</a>
	<dd><a href="news:94atsm$27u$6@news.BelWue.DE">Posted the idea</a>
		that led to <a href="#newl"><code>newl</code></a> on
		<a href="news:comp.lang.c++.moderated">comp.lang.c++.moderated</a>.
	<dd><a href="news:cgfmg8$sb6@odak26.prod.google.com">Posted the idea</a>
		that led to <a href="#expect"><code>expect</code></a> on
		<a href="news:comp.lang.c++">comp.lang.c++</a>.

	<dt><a href="http://www.langer.camelot.de/Welcome.html">Angelika Langer</a>
		and Klaus Kreft
	<dd>Section 3.2.2.1 of their <cite>Standard C++ IOStreams and Locales:
		Advanced Programmer's Guide and Reference</cite> book is the
		basis of <a href="#mnewl"><code>new_lines</code></a> (called
		<code>mendl</code> in the book).

	<dt><a href="http://www.research.att.com/~bs/homepage.html">Bjarne Stroustrup</a>
	<dd>Exercise 27 of Section 21.10 of his <cite>The C++ Programming Language,
		3<sup>rd</sup> edition</cite> book is the basis of <a
		href="#resetios"><code>resetios</code></a> (called
		<code>general</code> in the book).  Exercise 20 of the same section
		of the same book is the inspiration for <a
		href="#ios_form"><code>basic_ios_form</code></a>

	<dt><a href="../../../people/daryle_walker.html">Daryle Walker</a>
	<dd>Started the library.  Contributed the initial versions of <a
		href="#skipl"><code>skipl</code></a>, <a
		href="#newl"><code>newl</code></a>, <a
		href="#resetios"><code>resetios</code></a>, <a
		href="#repeatch"><code>repeat_ch</code></a>, <a
		href="#repeatchar"><code>repeat_char</code></a>, <a
		href="#mnewl"><code>new_lines</code></a>, <a
		href="#mskipl"><code>skip_lines</code></a>, <a
		href="#ios_form"><code>basic_ios_form</code></a>, and <a
		href="#expect"><code>expect</code></a>.  Contributed
		<cite><a href="../test/iomanip_test.cpp">iomanip_test.cpp</a></cite>.
</dl>

<h3><a name="history">History</a></h3>

<dl>
	<dt>20 Nov 2002, Daryle Walker
	<dd>Initial version
</dl>

<hr>

<p>Revised: 4 December 2004</p>

<p>Copyright 2003-2004 Daryle Walker.  Use, modification, and distribution
are subject to the Boost Software License, Version 1.0.  (See accompanying
file <a href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or a copy at
&lt;<a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>&gt;.)</p>
</body>
</html>
