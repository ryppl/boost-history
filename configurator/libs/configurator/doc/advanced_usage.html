<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
	<head>
  		<meta http-equiv="Content-Language" content="en-us">
  		<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
  		<link rel="stylesheet" type="text/css" href="own.css">
  		<title>Boost.Configurator</title>
	</head>
	
	<body>
		<table cellpadding="2" width="100%">
			<tr>
				<td valign="top"><a href="http://www.boost.org">
				<img style="border: 0pt none;" alt="Boost C++ Libraries" width="277" height="86" src="boost.png"></a></td>
				<td align="center"><a href="http://www.boost.org">Home</a></td>
				<td align="center"><a href="http://www.boost.org/doc/libs/">Libraries</a></td>
				<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
				<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
			</tr>
		</table>
		
		<hr/>
  
		<h2>Advanced usage</h2>

		<dl class="index">
			<dt><a href="#default_values">Option's default value</a></dt>
			<dt><a href="#necessity">Option's necessity</a></dt> 
			<dt><a href="#semantic">Semantic of option's value</a></dt> 
			<dt><a href="#multi_values">Multi values for option</a></dt> 
			<dt><a href="#case_sensitivity">Case sensitivity for names</a></dt> 
			<dt><a href="#values_obtaining">Non-string values obtating</a></dt> 
  		</dl>
		
		 
		<h3><a name="default_values"></a>Option's default value</h3>
		
		Very often useful to define some default value for option, especially for big configuration files. Let's do it:
<pre class="cpp">
    // ...
    conf.add< UdpHost >().set_default_value( "127.0.0.1" );
    conf.add< UdpPort >().set_default_value( 100 );
    // ...
</pre>
In this case user can skip these options in configuration file. Now write:
<pre class="cpp">
    // ...
    std::cout << "Udp host: " << conf.get_value_of< UdpHost >() << std::endl;
    std::cout << "Udp port: " << conf.get_value_of< UdpPort >() << std::endl;
    // ...
</pre>
If we have such config:
<pre class="config">
UdpHost = 12.34.56.78 
UdpPort = 103 
</pre>
console output:
<pre class="terminal">
Udp host: 12.34.56.78
Udp port: 103
</pre>
But if we comment out:
<pre class="config">
// UdpHost = 12.34.56.78 
// UdpPort = 103 
</pre>
console output changed:
<pre class="terminal">
Udp host: 127.0.0.1
Udp port: 100
</pre>

		<br/>
		<h3><a name="necessity"></a>Option's necessity</h3>
		
		No less frequently useful to define necessity of some options, because it can be mandatory for program. Let's do it:
<pre class="cpp">
    // ...
    conf.add< UdpHost >().set_necessity();
    // ...
</pre>
In this case user <strong><em>must</em></strong> inputs this option in configuration file. If not, he get error message like this:
<pre class="terminal">
[Configurator] Option 'UdpHost' is defined as necessary, but it missed!
</pre>

		<br/>
		<h3><a name="semantic"></a>Semantic of option's value</h3>
		
		Many options must be set to appropriate some semantics. Considering the fact that some values is "internationally known and unchanging essence", such check added in library, so possible errors will be detected already at the stage of parsing.
<br/><br/>
		For example, we may want that value of <strong>UdpHost</strong> will be valid IPv4.
<pre class="cpp">
    // ...
    conf.add< UdpHost >().check_semantic( boost::cf::ipv4 );
    // ...
</pre>
So:
<pre class="cpp">
    // ...
    std::cout << "Udp host: " << conf.get_value_of< UdpHost >() << std::endl;
    // ...
</pre>
If value in configuration file is incorrect:
<pre class="config">
UdpHost = 1233.34.56.78
</pre>
user get error message like this:
<pre class="terminal">
[Configurator] Semantic error: option 'UdpHost' has invalid 'IPv4' value '1233.34.56.78'!
</pre>
Supported semantic:


<br/>
<strong>IMPORTANT!</strong>
<br/>
If you use semantics check, you must compile your program with flag WITH_SEMANTIC_CHECK, for example:
<br/>
<strong>g++ -DWITH_SEMANTIC_CHECK -o test main.cpp -lboost_system -lboost_filesystem -lboost_regex</strong> 
<br/>
Note that only in this case you must link <strong>boost_system</strong> and <strong>boost_regex</strong> libraries. You only pay for what you use.





		<br/><br/>
		<h3><a name="multi_values"></a>Multi values for option</h3>
		
		
		<br/><br/>
		<h3><a name="case_sensitivity"></a>Case sensitivity for names</h3>
		
		
		<br/><br/>
		<h3><a name="values_obtaining"></a>Non-string values obtating</h3>






 


<a name="combine_options_settings"><h3>Combine settings</h3></a>
Of course, you can combine settings for option:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    conf.in( "Server" ).add_here( "Host" )
    				   .check_semantic( boost::cf::ip )
    				   .default_value( "34.67.56.89" )
    				   ;
    // ...
}
</pre>
But you can not use contradictory settings, for example:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    conf.in( "Server" ).add_here( "Host" )
                       .necessary()
                       .default_value( "34.67.56.89" ) // Default value for necessary option? Hm...
                       ;
    // ...
}
</pre>
In this case exception will be thrown:
<br/>
<strong>[Configurator] Option 'Server > Host' registered as necessary, so it cannot have default_value!</strong>

<a name="advanced_options_values_obtaining"><h3>Advanced obtaining option's value</h3></a>
You can obtain option's value different ways.
<br>
<br>
Simplest way is pure string obtaining:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    std::string host = conf.from( "Server" ).get_from_here( "Host" );
    // ...
}
</pre>

You can obtain value by passing:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    std::string host;
    conf.from( "Server" ).get_from_here( "Host", host );
    // ...
}
</pre>
It is useful when you want obtain many values from one section:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    std::string user;
    std::string password;
    conf.from( "Server" ).from( "Security" ).get_from_here( "User", user )
                                            .get_from_here( "Password", password )
                                            ;
    // ...
}
</pre>
Of course, you can obtain not only string values:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    std::string host;
    unsigned int port = 0;
    conf.from( "Server" ).get_from_here( "Host", host )
                         .get_from_here( "Port", port )
                         ;
    // ...
}
</pre>
In this case value oh "Port" must be correspond to <strong>unsigned int</strong> type. If not, exception will be thrown:
<br/>
<strong>[Configurator] Value 'asdfasdfasd' of option 'Server > Port' cannot be cast to &lt;unsigned int&gt;!</strong>
<br/>
<br/>
You can obtain values with explicitly defining type:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    unsigned int port = conf.from( "Server" ).get_from_here< unsigned int >( "Port" );
    // ...
}
</pre>
<a name="advanced_options_values_semantics"><h3>Advanced obtaining option's semantics</h3></a>
If you use semantics <strong>'size'</strong> and <strong>'time_period'</strong>, you can obtain such values
in minimal units (bytes and seconds respectively).
<br/>
Configuration file:
<br/>
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
some_period = 10h
some_file_size = 10Mb
</pre></div>
<br/>
Code:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    conf.add( "some_period" ).check_semantic( boost::cf::time_period );
    conf.add( "some_file_size" ).check_semantic( boost::cf::size );
    // ...
    unsigned long int period_in_sec = 0;
    unsigned long int size_in_bytes = 0;
    conf.get( "some_period", period_in_sec )
        .get( "some_file_size", size_in_bytes )
        ;
        
    std::cout << "period in sec: " << period_in_sec << std::endl;
    std::cout << "size in bytes: " << size_in_bytes << std::endl;
    
    // ...
}
</pre>
You will see:
<pre><strong>
period in sec: 36000
size in bytes: 10485760
</strong> </pre>
Supported time periods:
<ul>
	<li><strong>10</strong> (seconds)</li>
	<li><strong>10s</strong> (seconds)</li>
	<li><strong>10m</strong> (minutes)</li>
	<li><strong>10h</strong> (hours)</li>
	<li><strong>10d</strong> (days)</li>
</ul>
Supported sizes (size literals are case-insensitive):
<ul>
	<li><strong>10</strong> (bytes)</li>
	<li><strong>10b</strong> (bytes)</li>
	<li><strong>10K</strong> (Kbytes)</li>
	<li><strong>10Kb</strong> (Kbytes)</li>
	<li><strong>10M</strong> (Mbytes)</li>
	<li><strong>10Mb</strong> (Mbytes)</li>
	<li><strong>10G</strong> (Gbytes)</li>
	<li><strong>10Gb</strong> (Gbytes)</li>
</ul>
Between numbers and literals can be space(s), so "10MB" equal to "10 MB".

<a name="options_with_multi_values"><h3>Options with multi-values</h3></a>
By default option can't repeat in configuration file, so if you write:
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
DatabaseName = my_db
DatabaseName = my_db_2
</pre></div>
<br/>
exception will be thrown:
<br/>
<strong>[Configurator] Option 'Database' has multiple values, but it not allowed to have multiply values!</strong>
<br/>
<br/>
But you can use multiply values:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    conf.add( "DatabaseName" ).allow_multi_values();
    std::cout << "DatabaseName: " << conf.get( "DatabaseName" ) << std::endl;
    
    // ...
}
</pre>
In this case values of "DatabaseName" option will be accumulated, and you will see:
<br/>
<strong>DatabaseName = my_db my_db_2</strong>
<br/>
<br/>
This may be very useful for example, when you register some plugins:
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
Plugin = plug_a plug_b
Plugin = plug_c
Plugin = plug_d
Plugin = plug_e
</pre></div>
<br/>
In this case value of "Plugin" option will be <strong>plug_a plug_b plug_c plug_d plug_e</strong>.

<a name="case_sensitivity_for_names"><h3>Case sensitivity for names</h3></a>
You can set case sensitivity for names of options and sections. By default it is case insensitive.
<br/>
So if we have:
<br/>
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
DatabaseNAME = my_db
&lt;ServEr&gt;
    hosT = 127.0.0.1
&lt;/SERver&gt;
</pre></div>
by default it's okay:
<br/>
 
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
 
  
	<br/><br/>
	<hr/>
	Last revised 
  	<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->10
  	December, 2010<!--webbot bot="Timestamp" endspan i-checksum="38514" -->
	</body>
</html>
