<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
	<head>
  		<meta http-equiv="Content-Language" content="en-us">
  		<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
  		<link rel="stylesheet" type="text/css" href="own.css">
  		<title>Boost.Configurator</title>
	</head>
	
	<body>
		<table cellpadding="2" width="100%">
			<tr>
				<td valign="top"><a href="http://www.boost.org">
				<img style="border: 0pt none;" alt="Boost C++ Libraries" width="277" height="86" src="boost.png"></a></td>
				<td align="center"><a href="http://www.boost.org">Home</a></td>
				<td align="center"><a href="http://www.boost.org/doc/libs/">Libraries</a></td>
				<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
				<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
			</tr>
		</table>
		
		<hr/>
  
		<h2>Advanced usage</h2>














<h2><a name="topic2" id="topic2"></a>Advanced usage</h2>

  <p>
  <a name="options_necessity"><h3>How to set option's necessity</h3></a>
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    conf.in( "Server" ).add_here( "Host" ).necessary();
    // ...
}
</pre>
After this user must inputs "Host" option in configuration file. If not, exception will thrown:
<br/>
<strong>[Configurator] Option 'Server > Host' is defined as necessary, but it missed!</strong>
<br/>
<a name="options_default_value"><h3>How to set option's default value</h3></a>
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    conf.in( "Server" ).add_here( "Host" ).default_value( "127.0.0.1" );
    // ...
}
</pre>
After this user can skip "Host" option in configuration file.  
<br/>
<a name="options_semantics_check"><h3>How to set option's semantics check</h3></a>
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    conf.in( "Server" ).add_here( "Host" ).check_semantic( boost::cf::ip );
    // ...
}
</pre>
After this value of "Host" option must be valid IP address (IPv4 or IPv6). If not, exception will be thrown:
<br/>
<strong>[Configurator] Semantic error: option 'Server > Host' has invalid value 'asdfasdfasd' (not IPv4, not IPv6)!</strong>
<br/>
<br/>
<strong>IMPORTANT!</strong>
<br/>
If you use semantics check, you must compile your program with flag WITH_SEMANTIC_CHECK, for example:
<br/>
<strong>g++ -DWITH_SEMANTIC_CHECK -o test main.cpp -lboost_system -lboost_filesystem -lboost_regex</strong> 
<br/>
Note that in this case you must link <strong>boost_system</strong> and <strong>boost_regex</strong> libraries. You only pay for what you use.

<a name="combine_options_settings"><h3>Combine settings</h3></a>
Of course, you can combine settings for option:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    conf.in( "Server" ).add_here( "Host" )
    				   .check_semantic( boost::cf::ip )
    				   .default_value( "34.67.56.89" )
    				   ;
    // ...
}
</pre>
But you can not use contradictory settings, for example:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    conf.in( "Server" ).add_here( "Host" )
                       .necessary()
                       .default_value( "34.67.56.89" ) // Default value for necessary option? Hm...
                       ;
    // ...
}
</pre>
In this case exception will be thrown:
<br/>
<strong>[Configurator] Option 'Server > Host' registered as necessary, so it cannot have default_value!</strong>

<a name="advanced_options_values_obtaining"><h3>Advanced obtaining option's value</h3></a>
You can obtain option's value different ways.
<br>
<br>
Simplest way is pure string obtaining:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    std::string host = conf.from( "Server" ).get_from_here( "Host" );
    // ...
}
</pre>

You can obtain value by passing:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    std::string host;
    conf.from( "Server" ).get_from_here( "Host", host );
    // ...
}
</pre>
It is useful when you want obtain many values from one section:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    std::string user;
    std::string password;
    conf.from( "Server" ).from( "Security" ).get_from_here( "User", user )
                                            .get_from_here( "Password", password )
                                            ;
    // ...
}
</pre>
Of course, you can obtain not only string values:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    std::string host;
    unsigned int port = 0;
    conf.from( "Server" ).get_from_here( "Host", host )
                         .get_from_here( "Port", port )
                         ;
    // ...
}
</pre>
In this case value oh "Port" must be correspond to <strong>unsigned int</strong> type. If not, exception will be thrown:
<br/>
<strong>[Configurator] Value 'asdfasdfasd' of option 'Server > Port' cannot be cast to &lt;unsigned int&gt;!</strong>
<br/>
<br/>
You can obtain values with explicitly defining type:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    // ...
    unsigned int port = conf.from( "Server" ).get_from_here< unsigned int >( "Port" );
    // ...
}
</pre>
<a name="advanced_options_values_semantics"><h3>Advanced obtaining option's semantics</h3></a>
If you use semantics <strong>'size'</strong> and <strong>'time_period'</strong>, you can obtain such values
in minimal units (bytes and seconds respectively).
<br/>
Configuration file:
<br/>
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
some_period = 10h
some_file_size = 10Mb
</pre></div>
<br/>
Code:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    conf.add( "some_period" ).check_semantic( boost::cf::time_period );
    conf.add( "some_file_size" ).check_semantic( boost::cf::size );
    // ...
    unsigned long int period_in_sec = 0;
    unsigned long int size_in_bytes = 0;
    conf.get( "some_period", period_in_sec )
        .get( "some_file_size", size_in_bytes )
        ;
        
    std::cout << "period in sec: " << period_in_sec << std::endl;
    std::cout << "size in bytes: " << size_in_bytes << std::endl;
    
    // ...
}
</pre>
You will see:
<pre><strong>
period in sec: 36000
size in bytes: 10485760
</strong> </pre>
Supported time periods:
<ul>
	<li><strong>10</strong> (seconds)</li>
	<li><strong>10s</strong> (seconds)</li>
	<li><strong>10m</strong> (minutes)</li>
	<li><strong>10h</strong> (hours)</li>
	<li><strong>10d</strong> (days)</li>
</ul>
Supported sizes (size literals are case-insensitive):
<ul>
	<li><strong>10</strong> (bytes)</li>
	<li><strong>10b</strong> (bytes)</li>
	<li><strong>10K</strong> (Kbytes)</li>
	<li><strong>10Kb</strong> (Kbytes)</li>
	<li><strong>10M</strong> (Mbytes)</li>
	<li><strong>10Mb</strong> (Mbytes)</li>
	<li><strong>10G</strong> (Gbytes)</li>
	<li><strong>10Gb</strong> (Gbytes)</li>
</ul>
Between numbers and literals can be space(s), so "10MB" equal to "10 MB".

<a name="options_with_multi_values"><h3>Options with multi-values</h3></a>
By default option can't repeat in configuration file, so if you write:
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
DatabaseName = my_db
DatabaseName = my_db_2
</pre></div>
<br/>
exception will be thrown:
<br/>
<strong>[Configurator] Option 'Database' has multiple values, but it not allowed to have multiply values!</strong>
<br/>
<br/>
But you can use multiply values:
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    conf.add( "DatabaseName" ).allow_multi_values();
    std::cout << "DatabaseName: " << conf.get( "DatabaseName" ) << std::endl;
    
    // ...
}
</pre>
In this case values of "DatabaseName" option will be accumulated, and you will see:
<br/>
<strong>DatabaseName = my_db my_db_2</strong>
<br/>
<br/>
This may be very useful for example, when you register some plugins:
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
Plugin = plug_a plug_b
Plugin = plug_c
Plugin = plug_d
Plugin = plug_e
</pre></div>
<br/>
In this case value of "Plugin" option will be <strong>plug_a plug_b plug_c plug_d plug_e</strong>.

<a name="case_sensitivity_for_names"><h3>Case sensitivity for names</h3></a>
You can set case sensitivity for names of options and sections. By default it is case insensitive.
<br/>
So if we have:
<br/>
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
DatabaseNAME = my_db
&lt;ServEr&gt;
    hosT = 127.0.0.1
&lt;/SERver&gt;
</pre></div>
by default it's okay:
<br/>
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    conf.add( "DatabaseName" );
    conf.in( "Server" ).add_here( "Host" );
    // ...
    std::string db;
    std::string host;
    conf.get( "DatabaseName", db );
    conf.from( "Server" ).get_from_here( "Host", host );
    // ...
}
</pre>
But if we set case sensitivity:
<br/>
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    conf.set_case_sensitivity_for_names();
    // ...
}
</pre>
exception will be thrown, because Configurator will differentiate between names "DatabaseName" and "DatabaseNAME".

<a name="name_value_separator"><h3>How to set another name-value separator for options</h3></a>

By default name-value separator is '=' sign, but you can set another:
<br/>
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    conf.set_name_value_separator( ':' );
    // ...
}
</pre>
In this case you must use this sign:
<br/>
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
DatabaseName : my_db
</pre></div>
<br/>
You can use space sign: 
<br/>
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    conf.set_name_value_separator( ' ' );
    // ...
}
</pre>
and use it:
<br/>
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
DatabaseName 	my_db
</pre></div>

<a name="canonical_one_line_comments"><h3>How to use "canonical" one-line comments</h3></a>
By default Configurator use C++-style comments:
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
/*
 * My config.
 */
DatabaseName : my_db // this is comment for db
</pre></div>
<br/>
But you can use "canonical" one-line comment with sign '#':
<br/>
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::configurator conf;
    conf.use_canonical_one_line_comments();
    // ...
}
</pre>
In this case "//" will be just two slashes.
<div style="margin-left: 6px; margin-right: 6px; padding-left: 6px; padding-right: 6px; background: #F5F5DC; border: 1px solid #DEB887; font-family: monospace; font-size: 13px">
<pre>
/*
 * My config.
 */
DatabaseName : my_db # this is comment for db
Host = http://www.mysite.com # "//" after "http:" is NOT comments...
</pre></div>

<a name="singleton_configurator"><h3>Singleton-variant of boost::cf::configurator class</h3></a>
If you have many objects that need access to configurator, you can use it Singleton-variant:
<br/>
<pre>
int main( int argc, char* argv[] ) {
    boost::cf::single_configurator::inst().use_canonical_one_line_comments();
    // ...
}
</pre>
I use it. :-)
<br/>
<br/>
<strong>IMPORTANT!</strong>
<br/>
If you use Singleton-variant, you must compile your program with flag WITH_SINGLETON, for example:
<br/>
<strong>g++ -DWITH_SINGLETON -o test main.cpp -lboost_filesystem -lboost_thread</strong> 
<br/>
Note that in this case you must link <strong>boost_thread</strong> libraries. You only pay for what you use.

<a name="reparsing"><h3>Reparsing</h3></a>
You can reparse configuration file during program execution:
<br/>
<pre>
int main( int argc, char* argv[] ) {
    // 
    boost::cf::single_configurator::inst().reparse();
    // ...
}
</pre>
In this case "old" configuration file will be reparsed.
<br/>
<br/>
But you can use some "new" file:
<br/>
<pre>
int main( int argc, char* argv[] ) {
    // 
    boost::cf::single_configurator::inst().reparse( "/some/path/to/new/config" );
    // ...
}
</pre>





















		
	<br/><br/>
	<hr/>
	Last revised 
  	<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->10
  	December, 2010<!--webbot bot="Timestamp" endspan i-checksum="38514" -->
	</body>
</html>
