--- /local/include/c++/3.4.5/bits/stl_list.h	Wed Jan 18 11:06:54 2006
+++ stl_list.h	Tue Aug 12 02:58:50 2008
@@ -69,62 +69,82 @@
   // latter publicly inherits from the former in an effort to reduce code
   // duplication.  This results in some "needless" static_cast'ing later on,
   // but it's all safe downcasting.
 
   /// @if maint Common part of a node in the %list.  @endif
+  template<typename _Alloc>
   struct _List_node_base
   {
-    _List_node_base* _M_next;   ///< Self-explanatory
-    _List_node_base* _M_prev;   ///< Self-explanatory
+      typedef typename _Alloc::template rebind<_List_node_base<_Alloc> >::other _Node_Alloc_type;
+
+      typedef typename _Node_Alloc_type::value_type                value_type;
+      typedef typename _Node_Alloc_type::pointer                   pointer;
+      typedef typename _Node_Alloc_type::const_pointer             const_pointer;
+      typedef typename _Node_Alloc_type::reference                 reference;
+      typedef typename _Node_Alloc_type::const_reference           const_reference;
+
+      pointer _M_next;   ///< Self-explanatory
+      pointer _M_prev;   ///< Self-explanatory
 
     static void
     swap(_List_node_base& __x, _List_node_base& __y);
 
     void
-    transfer(_List_node_base * const __first,
-	     _List_node_base * const __last);
+      transfer(value_type * const __first,
+	       value_type * const __last);
 
     void
     reverse();
 
     void
-    hook(_List_node_base * const __position);
+      hook(value_type * const __position);
 
     void
     unhook();
   };
 
   /// @if maint An actual node in the %list.  @endif
-  template<typename _Tp>
-    struct _List_node : public _List_node_base
+  template<typename _Tp, typename _Alloc>
+    struct _List_node : public _List_node_base<_Alloc>
     {
+      typedef typename _Alloc::template rebind<_List_node<_Tp, _Alloc> >::other _Node_Alloc_type;
+
+      typedef typename _Node_Alloc_type::value_type                value_type;
+      typedef typename _Node_Alloc_type::pointer                   pointer;
+      typedef typename _Node_Alloc_type::const_pointer             const_pointer;
+      typedef typename _Node_Alloc_type::reference                 reference;
+      typedef typename _Node_Alloc_type::const_reference           const_reference;
+
       _Tp _M_data;                ///< User's data.
+
+      _List_node() : _M_data() {}
+      _List_node(const _Tp& __x) : _M_data(__x) {}
     };
 
   /**
    *  @brief A list::iterator.
    *
    *  @if maint
    *  All the functions are op overloads.
    *  @endif
   */
-  template<typename _Tp>
+  template<typename _Tp, typename _Alloc>
     struct _List_iterator
     {
-      typedef _List_iterator<_Tp>           _Self;
-      typedef _List_node<_Tp>               _Node;
+      typedef _List_iterator<_Tp, _Alloc>   _Self;
+      typedef _List_node<_Tp, _Alloc>       _Node;
 
       typedef ptrdiff_t                     difference_type;
       typedef bidirectional_iterator_tag    iterator_category;
       typedef _Tp                           value_type;
       typedef _Tp*                          pointer;
       typedef _Tp&                          reference;
 
       _List_iterator()
       : _M_node() { }
 
-      _List_iterator(_List_node_base* __x)
+      _List_iterator(_List_node_base<_Alloc>* __x)
       : _M_node(__x) { }
 
       // Must downcast from List_node_base to _List_node to get to _M_data.
       reference
       operator*() const
@@ -171,37 +191,37 @@
       bool
       operator!=(const _Self& __x) const
       { return _M_node != __x._M_node; }
 
       // The only member points to the %list element.
-      _List_node_base* _M_node;
+      _List_node_base<_Alloc>* _M_node;
     };
 
   /**
    *  @brief A list::const_iterator.
    *
    *  @if maint
    *  All the functions are op overloads.
    *  @endif
   */
-  template<typename _Tp>
+  template<typename _Tp, typename _Alloc>
     struct _List_const_iterator
     {
-      typedef _List_const_iterator<_Tp>     _Self;
-      typedef const _List_node<_Tp>         _Node;
-      typedef _List_iterator<_Tp>           iterator;
+      typedef _List_const_iterator<_Tp, _Alloc> _Self;
+      typedef const _List_node<_Tp, _Alloc>     _Node;
+      typedef _List_iterator<_Tp, _Alloc>       iterator;
 
       typedef ptrdiff_t                     difference_type;
       typedef bidirectional_iterator_tag    iterator_category;
       typedef _Tp                           value_type;
       typedef const _Tp*                    pointer;
       typedef const _Tp&                    reference;
 
       _List_const_iterator()
       : _M_node() { }
 
-      _List_const_iterator(const _List_node_base* __x)
+      _List_const_iterator(const _List_node_base<_Alloc>* __x)
       : _M_node(__x) { }
 
       _List_const_iterator(const iterator& __x)
       : _M_node(__x._M_node) { }
 
@@ -216,11 +236,11 @@
       { return &static_cast<_Node*>(_M_node)->_M_data; }
 
       _Self&
       operator++()
       {
-	_M_node = _M_node->_M_next;
+        _M_node = &*_M_node->_M_next;
 	return *this;
       }
 
       _Self
       operator++(int)
@@ -252,23 +272,23 @@
       bool
       operator!=(const _Self& __x) const
       { return _M_node != __x._M_node; }
 
       // The only member points to the %list element.
-      const _List_node_base* _M_node;
+      const _List_node_base<_Alloc>* _M_node;
     };
 
-  template<typename _Val>
+  template<typename _Val, typename _Alloc>
     inline bool
-    operator==(const _List_iterator<_Val>& __x,
-	       const _List_const_iterator<_Val>& __y)
+    operator==(const _List_iterator<_Val, _Alloc>& __x,
+	       const _List_const_iterator<_Val, _Alloc>& __y)
     { return __x._M_node == __y._M_node; }
 
-  template<typename _Val>
+  template<typename _Val, typename _Alloc>
     inline bool
-    operator!=(const _List_iterator<_Val>& __x,
-               const _List_const_iterator<_Val>& __y)
+    operator!=(const _List_iterator<_Val, _Alloc>& __x,
+               const _List_const_iterator<_Val, _Alloc>& __y)
     { return __x._M_node != __y._M_node; }
 
 
   /**
    *  @if maint
@@ -290,41 +310,43 @@
       //
       // We put this to the test in the constructors and in
       // get_allocator, where we use conversions between
       // allocator_type and _Node_Alloc_type. The conversion is
       // required by table 32 in [20.1.5].
-      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
-
-      _Node_Alloc_type;
+      typedef typename _Alloc::template rebind<_List_node<_Tp, _Alloc> >::other _Node_Alloc_type;
 
       struct _List_impl 
 	: public _Node_Alloc_type {
-	_List_node_base _M_node;
-	_List_impl (const _Node_Alloc_type& __a)
+        typename _Node_Alloc_type::pointer _M_node;
+        _List_impl (const _Node_Alloc_type& __a, _List_base& __b)
 	  : _Node_Alloc_type(__a)
-	{ }
+        { 
+            typename _Node_Alloc_type::value_type * __p = __b._M_get_node();
+            _Node_Alloc_type::construct(__p, _List_node<_Tp, _Alloc>());
+            _M_node = __p;
+        }
       };
 
       _List_impl _M_impl;
 
-      _List_node<_Tp>*
+      typename _Node_Alloc_type::value_type *
       _M_get_node()
       { return _M_impl._Node_Alloc_type::allocate(1); }
       
       void
-      _M_put_node(_List_node<_Tp>* __p)
+      _M_put_node(typename _Node_Alloc_type::pointer & __p)
       { _M_impl._Node_Alloc_type::deallocate(__p, 1); }
       
   public:
-      typedef _Alloc allocator_type;
+      typedef _Node_Alloc_type allocator_type;
 
       allocator_type
       get_allocator() const
       { return allocator_type(*static_cast<const _Node_Alloc_type*>(&this->_M_impl)); }
 
       _List_base(const allocator_type& __a)
-	: _M_impl(__a)
+	: _M_impl(__a, *this)
       { _M_init(); }
 
       // This is what actually destroys the list.
       ~_List_base()
       { _M_clear(); }
@@ -333,12 +355,12 @@
       _M_clear();
 
       void
       _M_init()
       {
-        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
-        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
+        this->_M_impl._M_node->_M_next = this->_M_impl._M_node;
+        this->_M_impl._M_node->_M_prev = this->_M_impl._M_node;
       }
     };
 
   /**
    *  @brief A standard container with linear time access to elements,
@@ -393,26 +415,26 @@
 
       typedef _List_base<_Tp, _Alloc>                   _Base;
 
     public:
       typedef _Tp                                        value_type;
-      typedef typename _Alloc::pointer                   pointer;
-      typedef typename _Alloc::const_pointer             const_pointer;
-      typedef typename _Alloc::reference                 reference;
-      typedef typename _Alloc::const_reference           const_reference;
-      typedef _List_iterator<_Tp>                        iterator;
-      typedef _List_const_iterator<_Tp>                  const_iterator;
+      typedef typename _List_node<_Tp, _Alloc>::pointer         pointer;
+      typedef typename _List_node<_Tp, _Alloc>::const_pointer   const_pointer;
+      typedef typename _List_node<_Tp, _Alloc>::reference       reference;
+      typedef typename _List_node<_Tp, _Alloc>::const_reference const_reference;
+      typedef _List_iterator<_Tp, _Alloc>                       iterator;
+      typedef _List_const_iterator<_Tp, _Alloc>                 const_iterator;
       typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;
       typedef std::reverse_iterator<iterator>            reverse_iterator;
       typedef size_t                                     size_type;
       typedef ptrdiff_t                                  difference_type;
       typedef typename _Base::allocator_type             allocator_type;
 
     protected:
       // Note that pointers-to-_Node's can be ctor-converted to
       // iterator types.
-      typedef _List_node<_Tp>				_Node;
+      typedef _List_node<_Tp, _Alloc>                           _Node;
 
       /** @if maint
        *  One data member plus two memory-handling functions.  If the
        *  _Alloc type requires separate instances, then one of those
        *  will also be included, accumulated from the topmost parent.
@@ -427,21 +449,21 @@
        *  @param  x  An instance of user data.
        *
        *  Allocates space for a new node and constructs a copy of @a x in it.
        *  @endif
        */
-      _Node*
+      typename _Base::_Node_Alloc_type::value_type*
       _M_create_node(const value_type& __x)
       {
-	_Node* __p = this->_M_get_node();
+        typename _Base::_Node_Alloc_type::value_type* __p = this->_M_get_node();
 	try
 	  {
-	    std::_Construct(&__p->_M_data, __x);
+            _M_impl._Base::_Node_Alloc_type::construct(__p, _Node(__x));
 	  }
 	catch(...)
 	  {
-	    _M_put_node(__p);
+            //_M_put_node(__p);
 	    __throw_exception_again;
 	  }
 	return __p;
       }
 
@@ -449,21 +471,21 @@
        *  @if maint
        *  Allocates space for a new node and default-constructs a new
        *  instance of @c value_type in it.
        *  @endif
        */
-      _Node*
+      typename _Base::_Node_Alloc_type::value_type*
       _M_create_node()
       {
-	_Node* __p = this->_M_get_node();
+        typename _Base::_Node_Alloc_type::value_type* __p = this->_M_get_node();
 	try
 	  {
-	    std::_Construct(&__p->_M_data);
+            _M_impl._Base::_Node_Alloc_type::construct(__p, _Node());
 	  }
 	catch(...)
 	  {
-	    _M_put_node(__p);
+            //_M_put_node(__p);
 	    __throw_exception_again;
 	  }
 	return __p;
       }
 
@@ -595,37 +617,37 @@
        *  Returns a read/write iterator that points to the first element in the
        *  %list.  Iteration is done in ordinary element order.
        */
       iterator
       begin()
-      { return this->_M_impl._M_node._M_next; }
+      { return iterator(&*this->_M_impl._M_node->_M_next); }
 
       /**
        *  Returns a read-only (constant) iterator that points to the
        *  first element in the %list.  Iteration is done in ordinary
        *  element order.
        */
       const_iterator
       begin() const
-      { return this->_M_impl._M_node._M_next; }
+      { return const_iterator(&*this->_M_impl._M_node->_M_next); }
 
       /**
        *  Returns a read/write iterator that points one past the last
        *  element in the %list.  Iteration is done in ordinary element
        *  order.
        */
       iterator
-      end() { return &this->_M_impl._M_node; }
+      end() { return &*this->_M_impl._M_node; }
 
       /**
        *  Returns a read-only (constant) iterator that points one past
        *  the last element in the %list.  Iteration is done in ordinary
        *  element order.
        */
       const_iterator
       end() const
-      { return &this->_M_impl._M_node; }
+      { return &*this->_M_impl._M_node; }
 
       /**
        *  Returns a read/write reverse iterator that points to the last
        *  element in the %list.  Iteration is done in reverse element
        *  order.
@@ -666,11 +688,11 @@
        *  Returns true if the %list is empty.  (Thus begin() would equal
        *  end().)
        */
       bool
       empty() const
-      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }
+      { return this->_M_impl._M_node->_M_next == this->_M_impl._M_node; }
 
       /**  Returns the number of elements in the %list.  */
       size_type
       size() const
       { return std::distance(begin(), end()); }
@@ -795,11 +817,11 @@
        *  Note that no data is returned, and if the last element's data
        *  is needed, it should be retrieved before pop_back() is called.
        */
       void
       pop_back()
-      { this->_M_erase(this->_M_impl._M_node._M_prev); }
+      { this->_M_erase(this->_M_impl._M_node->_M_prev); }
 
       /**
        *  @brief  Inserts given value into %list before specified iterator.
        *  @param  position  An iterator into the %list.
        *  @param  x  Data to be inserted.
@@ -908,11 +930,11 @@
        *  specialized such that std::swap(l1,l2) will feed to this
        *  function.
        */
       void
       swap(list& __x)
-      { _List_node_base::swap(this->_M_impl._M_node,__x._M_impl._M_node); }
+      { _List_node_base<_Alloc>::swap(this->_M_impl._M_node,__x._M_impl._M_node); }
 
       /**
        *  Erases all the elements.  Note that this function only erases
        *  the elements, and that if the elements themselves are
        *  pointers, the pointed-to memory is not touched in any way.
@@ -1071,11 +1093,11 @@
        *
        *  Reverse the order of elements in the list in linear time.
        */
       void
       reverse()
-      { this->_M_impl._M_node.reverse(); }
+      { this->_M_impl._M_node->reverse(); }
 
       /**
        *  @brief  Sort the elements.
        *
        *  Sorts the elements of this list in NlogN time.  Equivalent
@@ -1158,12 +1180,13 @@
 
       // Inserts new element at position given and with value given.
       void
       _M_insert(iterator __position, const value_type& __x)
       {
-        _Node* __tmp = _M_create_node(__x);
-        __tmp->hook(__position._M_node);
+        __position._M_node->hook(reinterpret_cast<typename _List_node_base<_Alloc>::value_type*>(_M_create_node(__x)));
+        //typename _Base::_Node_Alloc_type::value_type* __tmp = _M_create_node(__x);
+        //static_cast<_Node &>(*__tmp).hook(__position._M_node);
       }
 
       // Erases element at position given.
       void
       _M_erase(iterator __position)
