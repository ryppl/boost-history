--- /local/include/c++/3.4.5/bits/list.tcc	Wed Jan 18 11:06:46 2006
+++ list.tcc	Mon Aug  4 08:26:07 2008
@@ -51,35 +51,72 @@
  * in supporting documentation.  Silicon Graphics makes no
  * representations about the suitability of this software for any
  * purpose.  It is provided "as is" without express or implied warranty.
  */
 
+/**
+    Copyright (c) 2008 Phil Bouchard <phil@fornux.com>.
+
+    Distributed under the Boost Software License, Version 1.0.
+
+    See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt
+
+    See http://www.boost.org/libs/smart_ptr/doc/index.html for documentation.
+*/
+
 /** @file list.tcc
  *  This is an internal header file, included by other library headers.
  *  You should not attempt to use it directly.
  */
 
 #ifndef _LIST_TCC
 #define _LIST_TCC 1
 
 namespace _GLIBCXX_STD
 {
+  template<typename _Alloc>
+    void
+    _List_node_base<_Alloc>::hook(value_type * const __position)
+    {
+        static_cast<_List_node_base &>(*__position)._M_next = this->_M_next->_M_prev;
+        static_cast<_List_node_base &>(*__position)._M_prev = this->_M_prev;
+        this->_M_prev->_M_next = __position;
+        this->_M_prev = __position;
+
+//        this->_M_next = __position;
+//        this->_M_prev = __position->_M_prev;
+//        __position->_M_prev->_M_next = this;
+//        __position->_M_prev = this;
+    }
+
+  template<typename _Alloc>
+    void
+    _List_node_base<_Alloc>::unhook()
+    {
+        _List_node_base* __next_node = this->_M_next;
+        _List_node_base* __prev_node = this->_M_prev;
+        __prev_node->_M_next = __next_node;
+        __next_node->_M_prev = __prev_node;
+    }
+
   template<typename _Tp, typename _Alloc>
     void
     _List_base<_Tp,_Alloc>::
     _M_clear()
     {
-      typedef _List_node<_Tp>  _Node;
-      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
-      while (__cur != &this->_M_impl._M_node)
-      {
-        _Node* __tmp = __cur;
-        __cur = static_cast<_Node*>(__cur->_M_next);
-        std::_Destroy(&__tmp->_M_data);
-        _M_put_node(__tmp);
-      }
+/*      typedef _List_node<_Tp,_Alloc>  _Node;
+      typedef _List_node_base<_Alloc>  _Node_base;
+      typename _Node_base::pointer* __cur = & this->_M_impl._M_node->_M_next;
+      while (__cur != & this->_M_impl._M_node)
+      {
+        typename _Node_base::pointer* __tmp = __cur;
+        __cur = & (*__cur)->_M_next;
+        _M_impl._Node_Alloc_type::destroy(*(typename _Node::pointer*) __tmp);
+        _M_put_node(*(typename _Node::pointer*) __tmp);
     }
+*/    }
 
   template<typename _Tp, typename _Alloc>
     typename list<_Tp,_Alloc>::iterator
     list<_Tp,_Alloc>::
     insert(iterator __position, const value_type& __x)
@@ -235,12 +272,12 @@
     void
     list<_Tp,_Alloc>::
     sort()
     {
       // Do nothing if the list has length 0 or 1.
-      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
-	  && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
+      if (this->_M_impl._M_node->_M_next != this->_M_impl._M_node
+	  && this->_M_impl._M_node->_M_next->_M_next != this->_M_impl._M_node)
       {
         list __carry;
         list __tmp[64];
         list * __fill = &__tmp[0];
         list * __counter;
@@ -339,12 +376,12 @@
       void
       list<_Tp,_Alloc>::
       sort(_StrictWeakOrdering __comp)
       {
 	// Do nothing if the list has length 0 or 1.
-	if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
-	    && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
+	if (this->_M_impl._M_node->_M_next != this->_M_impl._M_node
+	    && this->_M_impl._M_node->_M_next->_M_next != this->_M_impl._M_node)
 	  {
 	    list __carry;
 	    list __tmp[64];
 	    list * __fill = &__tmp[0];
 	    list * __counter;
