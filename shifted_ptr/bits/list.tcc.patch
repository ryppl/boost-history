--- /local/include/c++/3.4.5/bits/list.tcc	Wed Jan 18 11:06:46 2006
+++ list.tcc	Thu Jul 31 02:28:37 2008
@@ -51,31 +51,63 @@
  * in supporting documentation.  Silicon Graphics makes no
  * representations about the suitability of this software for any
  * purpose.  It is provided "as is" without express or implied warranty.
  */
 
+/**
+    Copyright (c) 2008 Phil Bouchard <phil@fornux.com>.
+
+    Distributed under the Boost Software License, Version 1.0.
+
+    See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt
+
+    See http://www.boost.org/libs/smart_ptr/doc/index.html for documentation.
+*/
+
 /** @file list.tcc
  *  This is an internal header file, included by other library headers.
  *  You should not attempt to use it directly.
  */
 
 #ifndef _LIST_TCC
 #define _LIST_TCC 1
 
 namespace _GLIBCXX_STD
 {
+  template<typename _Alloc>
+    void
+    _List_node_base<_Alloc>::hook(_List_node_base * const __position)
+    {
+        this->_M_next = __position;
+        this->_M_prev = __position->_M_prev;
+        __position->_M_prev->_M_next = this;
+        __position->_M_prev = this;
+    }
+
+  template<typename _Alloc>
+    void
+    _List_node_base<_Alloc>::unhook()
+    {
+        _List_node_base* __next_node = this->_M_next;
+        _List_node_base* __prev_node = this->_M_prev;
+        __prev_node->_M_next = __next_node;
+        __next_node->_M_prev = __prev_node;
+    }
+
   template<typename _Tp, typename _Alloc>
     void
     _List_base<_Tp,_Alloc>::
     _M_clear()
     {
-      typedef _List_node<_Tp>  _Node;
-      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
-      while (__cur != &this->_M_impl._M_node)
+      typedef _List_node<_Tp,_Alloc>  _Node;
+      typedef _List_node_base<_Alloc>  _Node_base;
+      _Node* __cur = static_cast<_Node*>(static_cast<_Node_base*>(&*this->_M_impl._M_node->_M_next));
+      while (__cur != &*this->_M_impl._M_node)
       {
         _Node* __tmp = __cur;
-        __cur = static_cast<_Node*>(__cur->_M_next);
+        __cur = static_cast<_Node*>(static_cast<_Node_base*>(&*__cur->_M_next));
         std::_Destroy(&__tmp->_M_data);
         _M_put_node(__tmp);
       }
     }
 
@@ -235,12 +267,12 @@
     void
     list<_Tp,_Alloc>::
     sort()
     {
       // Do nothing if the list has length 0 or 1.
-      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
-	  && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
+      if (this->_M_impl._M_node->_M_next != this->_M_impl._M_node
+	  && this->_M_impl._M_node->_M_next->_M_next != this->_M_impl._M_node)
       {
         list __carry;
         list __tmp[64];
         list * __fill = &__tmp[0];
         list * __counter;
@@ -339,12 +371,12 @@
       void
       list<_Tp,_Alloc>::
       sort(_StrictWeakOrdering __comp)
       {
 	// Do nothing if the list has length 0 or 1.
-	if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
-	    && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
+	if (this->_M_impl._M_node->_M_next != this->_M_impl._M_node
+	    && this->_M_impl._M_node->_M_next->_M_next != this->_M_impl._M_node)
 	  {
 	    list __carry;
 	    list __tmp[64];
 	    list * __fill = &__tmp[0];
 	    list * __counter;
