--- /local/include/c++/3.4.5/bits/list.tcc	Wed Jan 18 11:06:46 2006
+++ list.tcc	Mon Jul 21 03:28:48 2008
@@ -51,42 +51,74 @@
  * in supporting documentation.  Silicon Graphics makes no
  * representations about the suitability of this software for any
  * purpose.  It is provided "as is" without express or implied warranty.
  */
 
+/**
+    Copyright (c) 2008 Phil Bouchard <phil@fornux.com>.
+
+    Distributed under the Boost Software License, Version 1.0.
+
+    See accompanying file LICENSE_1_0.txt or copy at
+    http://www.boost.org/LICENSE_1_0.txt
+
+    See http://www.boost.org/libs/smart_ptr/doc/index.html for documentation.
+*/
+
 /** @file list.tcc
  *  This is an internal header file, included by other library headers.
  *  You should not attempt to use it directly.
  */
 
 #ifndef _LIST_TCC
 #define _LIST_TCC 1
 
 namespace _GLIBCXX_STD
 {
+  template<typename _Alloc>
+    void
+    _List_node_base<_Alloc>::hook(pointer const & __position)
+    {
+        this->_M_next = __position;
+        this->_M_prev = __position->_M_prev;
+        __position->_M_prev->_M_next = this;
+        __position->_M_prev = this;
+    }
+
+  template<typename _Alloc>
+    void
+    _List_node_base<_Alloc>::unhook()
+    {
+        pointer const __next_node = this->_M_next;
+        pointer const __prev_node = this->_M_prev;
+        __prev_node->_M_next = __next_node;
+        __next_node->_M_prev = __prev_node;
+    }
+
   template<typename _Tp, typename _Alloc>
     void
     _List_base<_Tp,_Alloc>::
     _M_clear()
     {
-      typedef _List_node<_Tp>  _Node;
-      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
+      typedef _List_node<_Tp,_Alloc>  _Node;
+      typedef _List_node_base<_Alloc>  _Node_base;
+      _Node* __cur = static_cast<_Node*>(static_cast<_Node_base*>(this->_M_impl._M_node._M_next));
       while (__cur != &this->_M_impl._M_node)
       {
         _Node* __tmp = __cur;
-        __cur = static_cast<_Node*>(__cur->_M_next);
+        __cur = static_cast<_Node*>(static_cast<_Node_base*>(__cur->_M_next));
         std::_Destroy(&__tmp->_M_data);
         _M_put_node(__tmp);
       }
     }
 
   template<typename _Tp, typename _Alloc>
     typename list<_Tp,_Alloc>::iterator
     list<_Tp,_Alloc>::
     insert(iterator __position, const value_type& __x)
     {
-      _Node* __tmp = _M_create_node(__x);
+      typename _Node::pointer __tmp = _M_create_node(__x);
       __tmp->hook(__position._M_node);
       return __tmp;
     }
 
   template<typename _Tp, typename _Alloc>
