<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Motivation</title>
<link rel="stylesheet" href="../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="../../index.html" title="Toward Boost.Integer.Endian">
<link rel="up" href="../overview.html" title="Overview">
<link rel="prev" href="../overview.html" title="Overview">
<link rel="next" href="../users_guide.html" title=" Users'Guide">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../users_guide.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="toward_boost_integer_endian.overview.motivation"></a><a href="motivation.html" title="Motivation">Motivation</a>
</h3></div></div></div>
<p>
        The original Beman's version provided through the boost::integer::endian&lt;&gt;
        class an integer-like class that providing arithmetics operations on
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Big endian | little endian | native endian byte ordering.
        </li>
<li>
          Signed | unsigned
        </li>
<li>
          Unaligned | aligned
        </li>
<li>
          1-8 byte (unaligned) | 2, 4, 8 byte (aligned)
        </li>
<li>
          Choice of integer value type
        </li>
</ul></div>
<p>
        This endain aware design seems to be unappropiated to work with endian unaware
        types, but as we will see this is not completly true, as we can construct
        on top of the Beman's design endian unaware operation. Next follows some
        of the main critics that have been done recently.
      </p>
<a name="toward_boost_integer_endian.overview.motivation.intrusive_verus_non_intrusive"></a><h4>
<a name="id4803533"></a>
        <a href="motivation.html#toward_boost_integer_endian.overview.motivation.intrusive_verus_non_intrusive">Intrusive
        verus non-intrusive</a>
      </h4>
<p>
        Endian conversion must be possible to any type even if you can't modify the
        original source code. Many people think that originel Beman's library requires
        the data types which need to be converted to be coded using his endian types
        as members.
      </p>
<p>
        We will see that this is not true, as the user can always use casting to
        reinterpret a given structure on another one, as the proposed extension does
        with the endian_views.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">endian_unaware_structure</span> <span class="special">{</span>
    <span class="identifier">int32_t</span> <span class="identifier">a</span><span class="special">;</span> 
    <span class="identifier">int16_t</span> <span class="identifier">b</span><span class="special">;</span> 
<span class="special">};</span>
<span class="identifier">endian_unaware_structure</span> <span class="identifier">st_a</span><span class="special">;</span>

<span class="identifier">endian_unaware_structure</span> <span class="identifier">st_b</span><span class="special">;</span>
<span class="identifier">as_endian</span><span class="special">&lt;</span><span class="identifier">native</span><span class="special">&gt;(</span><span class="identifier">st_b</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">as_endian</span><span class="special">&lt;</span><span class="identifier">big</span><span class="special">&gt;(</span><span class="identifier">st_a</span><span class="special">);</span>
</pre>
<a name="toward_boost_integer_endian.overview.motivation.physical_versus_logical_data"></a><h4>
<a name="id4803723"></a>
        <a href="motivation.html#toward_boost_integer_endian.overview.motivation.physical_versus_logical_data">Physical
        versus Logical data</a>
      </h4>
<p>
        The typical use case is to use native endianness until ready to read/write
        using wire format. It is only when ready to do I/O that there is a need to
        account for endianness.
      </p>
<p>
        Beman's original library requires two types one to specify the physical data
        and the other representing the logical data. Many people think that this
        means that the user has to maintain two separate structs/classes when only
        one is needed. This could be sometimes the case, but in other cases, the
        user will store the information elements include in the message on local
        variables and specific contexts that don't follow the external format.
      </p>
<p>
        Applications that don't separate the physical and the logical data structures
        don't scale well as any change on the external format will mean a refactoring
        of the whole application. Also, the wire structures cannot maintain invariants,
        so having a separate class is often useful even if its contents are essentially
        identical to the wire version.
      </p>
<p>
        In addition a single and efficient view is only possible when the pysical
        view can be represented by native aligned integers. But when the physical
        view contains unaliged integers with sizes not supported by the platform,
        the need to separate both view becomes anavoidable. Here the Beman's design
        is the best adapted.
      </p>
<a name="toward_boost_integer_endian.overview.motivation.inherent_inefficient_arithmetic_operations"></a><h4>
<a name="id4803795"></a>
        <a href="motivation.html#toward_boost_integer_endian.overview.motivation.inherent_inefficient_arithmetic_operations">Inherent
        inefficient arithmetic operations</a>
      </h4>
<p>
        The fact that the endian types provide operators gives the impression that
        it's ok to operate on them, as these operations can potentially require two
        endian conversions when the endianness is different.
      </p>
<p>
        Some people don't agree with that design choice, as they think the operation
        of endian conversion and operating on the data should be divorced from each
        other. A less experienced user that you may end up not realizing what the
        hidden costs are and use the endian aware integer-like types throughout the
        application, paying unnecessary overheads. They prefer a library that makes
        hard to misuse in that way; borrowing a phrase from python, "explicit
        is better than implicit". They believe that forcing the user to do the
        explicit endian conversion leads to better separation of concerns for the
        application, but they don't propose any mean to force this conversion.
      </p>
<p>
        The extension proposal separates the endian aware byte-holder type from the
        one able to make arithmetic operations so the user will be forced to convert
        for one to/from the native type, and avoid unfortunate costly atithmetic
        operations.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">endian_aware_structure</span> <span class="special">{</span>
    <span class="identifier">endian_holder</span><span class="special">&lt;</span><span class="identifier">big</span><span class="special">,</span><span class="identifier">int32_t</span><span class="special">&gt;</span> <span class="identifier">a</span><span class="special">;</span>
    <span class="identifier">endian_holder</span><span class="special">&lt;</span><span class="identifier">big</span><span class="special">,</span><span class="identifier">int16_t</span><span class="special">&gt;</span> <span class="identifier">b</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
        Structure endian_aware_structure can not be used without converting to native
        types, as endian_holder don't provide other operations than conversion.
      </p>
<pre class="programlisting"><span class="identifier">endian_aware_structure</span> <span class="identifier">st</span><span class="special">;</span>
<span class="comment">// ...
</span><span class="identifier">st</span><span class="special">.</span><span class="identifier">a</span><span class="special">=</span><span class="identifier">i</span><span class="special">;</span>
<span class="identifier">st</span><span class="special">.</span><span class="identifier">b</span><span class="special">=</span><span class="identifier">j</span><span class="special">;</span>
</pre>
<p>
        But don't removes the inefficient and endian safe class, as less demanding
        applications would benefit from the safe and transparent approach.
      </p>
<a name="toward_boost_integer_endian.overview.motivation.in_place_conversion"></a><h4>
<a name="id4804044"></a>
        <a href="motivation.html#toward_boost_integer_endian.overview.motivation.in_place_conversion">In-place
        conversion</a>
      </h4>
<p>
        Other contexts force the user to make in place conversions. While this could
        be dangerous, there are context on which a funtional conversion is not possible,
        mainly because the duplicated space could not be an option. These in-place
        conversions are only possible for aligned endian unaware types.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">endian_unaware_structure</span> <span class="special">{</span>
    <span class="identifier">int32_t</span> <span class="identifier">a</span><span class="special">;</span> 
    <span class="identifier">int16_t</span> <span class="identifier">b</span><span class="special">;</span> 
<span class="special">};</span>
<span class="identifier">endian_unaware_structure</span> <span class="identifier">st</span><span class="special">;</span>

<span class="identifier">as_endian</span><span class="special">&lt;</span><span class="identifier">native</span><span class="special">&gt;(</span><span class="identifier">st</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">as_endian</span><span class="special">&lt;</span><span class="identifier">big</span><span class="special">&gt;(</span><span class="identifier">st</span><span class="special">);</span>
</pre>
<p>
        The fact that some context need this in-place conversion doesn't mean that
        every application should use this approach.
      </p>
<a name="toward_boost_integer_endian.overview.motivation.udt_endianness"></a><h4>
<a name="id4804216"></a>
        <a href="motivation.html#toward_boost_integer_endian.overview.motivation.udt_endianness">UDT
        endianness</a>
      </h4>
<p>
        It has been also arged that the boost::integer::endian class didn't accepts
        a UDT. This is true when the endian is unaligned, but not for aligned types.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">UserMessage</span> <span class="special">{</span>
  <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">system_clock</span><span class="special">::</span><span class="identifier">time_point</span> <span class="special">&gt;</span> <span class="identifier">timestamp</span><span class="special">;</span>
  <span class="identifier">ulittle32_pt</span> <span class="identifier">aircraft_id</span><span class="special">;</span>
  <span class="keyword">struct</span> <span class="identifier">Position</span> <span class="special">{</span>
     <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">length</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least32_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">x</span><span class="special">;</span>
     <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">length</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least32_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">y</span><span class="special">;</span>
     <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">length</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least32_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">z</span><span class="special">;</span>
  <span class="special">}</span> <span class="identifier">position</span><span class="special">;</span>
  <span class="keyword">struct</span> <span class="identifier">Attitude</span> <span class="special">{</span>
      <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">plane_angle</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least8_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">heading</span><span class="special">;</span>
      <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">plane_angle</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least8_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">pitch</span><span class="special">;</span>
      <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">plane_angle</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least8_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">roll</span><span class="special">;</span>
  <span class="special">}</span> <span class="identifier">attitude</span><span class="special">;</span>
<span class="special">};</span> <span class="comment">// UserMessage
</span></pre>
<a name="toward_boost_integer_endian.overview.motivation.mixed_endianness"></a><h4>
<a name="id4758939"></a>
        <a href="motivation.html#toward_boost_integer_endian.overview.motivation.mixed_endianness">Mixed
        endianness</a>
      </h4>
<p>
        Sometimes we need to deal with messages with mixed endianness. A functional
        approach means the programmer has to "know" which endianess the
        data he wants to convert has.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">UdpHeader</span> <span class="special">{</span>
  <span class="identifier">ubig16_pt</span> <span class="identifier">source_port</span><span class="special">;</span>
  <span class="identifier">ubig16_pt</span> <span class="identifier">destination_port</span><span class="special">;</span>
  <span class="identifier">ubig16_pt</span> <span class="identifier">length</span><span class="special">;</span>
  <span class="identifier">ubig16_pt</span> <span class="identifier">checksum</span><span class="special">;</span>
<span class="special">};</span> <span class="comment">// UdpHeader
</span>
<span class="keyword">struct</span> <span class="identifier">Packet</span> <span class="special">{</span>
  <span class="identifier">internet</span><span class="special">::</span><span class="identifier">UdpHeader</span> <span class="identifier">udpHeader</span><span class="special">;</span>
  <span class="identifier">UserMessage</span> <span class="identifier">userMessage</span><span class="special">;</span>
<span class="special">};</span> <span class="comment">// Packet
</span></pre>
<a name="toward_boost_integer_endian.overview.motivation.floating_point"></a><h4>
<a name="id4759130"></a>
        <a href="motivation.html#toward_boost_integer_endian.overview.motivation.floating_point">Floating
        point</a>
      </h4>
<p>
        From my understanding floating point types are not only concerned by endianness,
        but also by a multitude of standard on not standard formats.
      </p>
<a name="toward_boost_integer_endian.overview.motivation.conclusion"></a><h4>
<a name="id4759156"></a>
        <a href="motivation.html#toward_boost_integer_endian.overview.motivation.conclusion">Conclusion</a>
      </h4>
<p>
        The library must support applications needing to work safely with endian
        aware types and efficiently with in place endian conversions.
      </p>
<p>
        Conversions between native and big/little endian formats must be simple.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2006 -2009 Beman Dawes<br>Copyright &#169; 2010 Vicente J. Botet Escriba<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../users_guide.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
