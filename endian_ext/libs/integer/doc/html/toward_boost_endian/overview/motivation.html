<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Motivation</title>
<link rel="stylesheet" href="../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="../../index.html" title="Toward Boost.Endian">
<link rel="up" href="../overview.html" title="Overview">
<link rel="prev" href="../overview.html" title="Overview">
<link rel="next" href="../users_guide.html" title=" Users'Guide">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../users_guide.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="toward_boost_endian.overview.motivation"></a><a href="motivation.html" title="Motivation">Motivation</a>
</h3></div></div></div>
<p>
        The original Beman's version provided though the boost::integer::endian&lt;&gt;
        class an integer-like class that providing arithmetics operations on
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          Big endian | little endian | native endian byte ordering.
        </li>
<li>
          Signed | unsigned
        </li>
<li>
          Unaligned | aligned
        </li>
<li>
          1-8 byte (unaligned) | 2, 4, 8 byte (aligned)
        </li>
<li>
          Choice of integer value type
        </li>
</ul></div>
<p>
        This endain aware design seems to be unappropiated to work with endian unaware
        types, but as we will see this is not completly true, as we can construct
        on top of the Beman's design endian unaware operation. Next follows some
        of the main critics that have been done recently.
      </p>
<a name="toward_boost_endian.overview.motivation.intrusive_verus_non_intrusive"></a><h4>
<a name="id4803540"></a>
        <a href="motivation.html#toward_boost_endian.overview.motivation.intrusive_verus_non_intrusive">Intrusive
        verus non-intrusive</a>
      </h4>
<p>
        Endian conversion must be possible to any type even if you can't modify the
        original source code. Many people think that originel Beman's library requires
        the data types which need to be converted to be coded using his endian types
        as members. We will see that this is not true, as the user can always use
        casting to reinterpret a given structure on another one, as the proposed
        extension does with the endian_views.
      </p>
<a name="toward_boost_endian.overview.motivation.physical_versus_logical_data"></a><h4>
<a name="id4803572"></a>
        <a href="motivation.html#toward_boost_endian.overview.motivation.physical_versus_logical_data">Physical
        versus Logical data</a>
      </h4>
<p>
        The typical use case is to use native endianness until ready to read/write
        using wire format. It is only when ready to do I/O that there is a need to
        account for endianness.
      </p>
<p>
        Beman's original library requires two types one to specify the physical data
        and the other representing the logical data. Many people think that this
        means that the user has to maintain two separate structs/classes when only
        one is needed. This could be sometimes the case, but in other cases, the
        user will store the the information elements include in the message on local
        variables and specific contexts that don't follow the external format.
      </p>
<p>
        Application that don't separate the physical and the logical data structures
        don't scale well as any change on the external format will mean a refactoring
        of the whole application. Also, the wire structures cannot maintain invariants,
        so having a separate class is often useful even if its contents are essentially
        identical to the wire version.
      </p>
<p>
        In addition single and efficient view is only possible when the pysical view
        can be represented by native aligned integers. But when the physical view
        contains unaliged integers with sizes not supported by the platform, the
        need to separate both view becomes anavoidable. Here the Beman's design is
        the best adapted.
      </p>
<a name="toward_boost_endian.overview.motivation.inherent_inefficient_arithmetic_operations"></a><h4>
<a name="id4803634"></a>
        <a href="motivation.html#toward_boost_endian.overview.motivation.inherent_inefficient_arithmetic_operations">Inherent
        inefficient arithmetic operations</a>
      </h4>
<p>
        The fact that the endian types provide operators gives the impression that
        it's ok to operate on them, but these operations can potentially require
        two endian conversions when the endianness is different.
      </p>
<p>
        Some people don't agree with that design choice, as they think the operation
        of endian conversion and operating on the data should be divorced from each
        other. A less experienced user that you may end up not realizing what the
        hidden costs are and use the endian aware integer-like types throughout the
        application, paying unnecessary overheads. They prefer a library that makes
        hard to misuse in that way; borrowing a phrase from python, "explicit
        is better than implicit". They believe that forcing the user to do the
        explicit endian conversion leads to better separation of concerns for the
        application.
      </p>
<p>
        The extension proposal separates the endian aware type from the one able
        to make arithmetic operation so the user can be forced to convert for one
        to/from the native type, and avoid unfortunate costly atithmetic operations.
        But don't removes the inefficient and endian safe class, as less demanding
        applications would benefit from the safe approach.
      </p>
<a name="toward_boost_endian.overview.motivation.in_place_conversion"></a><h4>
<a name="id4803688"></a>
        <a href="motivation.html#toward_boost_endian.overview.motivation.in_place_conversion">In-place
        conversion</a>
      </h4>
<p>
        Other contexts force the user to make in place conversions. While this could
        be dangerous, there are context on which a pure conversion is not possible,
        mainly because the duplicated space could not be an option. These in-place
        conversions are only possible for aligned endian unaware types.
      </p>
<p>
        The fact that some context need this in-place conversion doesn't mean that
        every application should work with this approach.
      </p>
<a name="toward_boost_endian.overview.motivation.udt_endianness"></a><h4>
<a name="id4803722"></a>
        <a href="motivation.html#toward_boost_endian.overview.motivation.udt_endianness">UDT
        endianness</a>
      </h4>
<a name="toward_boost_endian.overview.motivation.mixed_endianness"></a><h4>
<a name="id4803742"></a>
        <a href="motivation.html#toward_boost_endian.overview.motivation.mixed_endianness">Mixed
        endianness</a>
      </h4>
<p>
        Sometimes we need to deal with messages with mixed endianness. A functional
        approach means the programmer has to "know" which endianess the
        data he wants to convert has.
      </p>
<a name="toward_boost_endian.overview.motivation.floating_point"></a><h4>
<a name="id4803768"></a>
        <a href="motivation.html#toward_boost_endian.overview.motivation.floating_point">Floating
        point</a>
      </h4>
<a name="toward_boost_endian.overview.motivation.conclusion"></a><h4>
<a name="id4803789"></a>
        <a href="motivation.html#toward_boost_endian.overview.motivation.conclusion">Conclusion</a>
      </h4>
<p>
        The library need to support applications needing to work safely with endian
        aware types and efficiently with in place endian conversion.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2006 -2009 Beman Dawes<br>Copyright &#169; 2010 Vicente J. Botet Escriba<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../users_guide.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
