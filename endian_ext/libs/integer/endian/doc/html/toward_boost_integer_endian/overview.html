<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Overview</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../index.html" title="Toward Boost.Integer.Endian 0.2.0">
<link rel="up" href="../index.html" title="Toward Boost.Integer.Endian 0.2.0">
<link rel="prev" href="../index.html" title="Toward Boost.Integer.Endian 0.2.0">
<link rel="next" href="users_guide.html" title="Users'Guide">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="users_guide.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="toward_boost_integer_endian.overview"></a><a class="link" href="overview.html" title="Overview">Overview</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="overview.html#toward_boost_integer_endian.overview.motivation">Motivation</a></span></dt>
<dt><span class="section"><a href="overview.html#toward_boost_integer_endian.overview.description">Description</a></span></dt>
</dl></div>
<a name="toward_boost_integer_endian.overview.how_to_use_this_documentation"></a><h4>
<a name="id2922582"></a>
      <a class="link" href="overview.html#toward_boost_integer_endian.overview.how_to_use_this_documentation">How
      to Use This Documentation</a>
    </h4>
<p>
      This documentation makes use of the following naming and formatting conventions.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          Code is in <code class="computeroutput"><span class="identifier">fixed</span> <span class="identifier">width</span>
          <span class="identifier">font</span></code> and is syntax-highlighted.
        </li>
<li class="listitem">
          Replaceable text that you will need to supply is in <em class="replaceable"><code>italics</code></em>.
        </li>
<li class="listitem">
          Free functions are rendered in the code font followed by (), as in <code class="computeroutput"><span class="identifier">free_function</span><span class="special">()</span></code>.
        </li>
<li class="listitem">
          If a name refers to a class template, it is specified like this: <code class="computeroutput"><span class="identifier">class_template</span><span class="special">&lt;&gt;</span></code>;
          that is, it is in code font and its name is followed by <code class="computeroutput"><span class="special">&lt;&gt;</span></code>
          to indicate that it is a class template.
        </li>
<li class="listitem">
          If a name refers to a function-like macro, it is specified like this:
          <code class="computeroutput"><span class="identifier">MACRO</span><span class="special">()</span></code>;
          that is, it is uppercase in code font and its name is followed by <code class="computeroutput"><span class="special">()</span></code> to indicate that it is a function-like
          macro. Object-like macros appear without the trailing <code class="computeroutput"><span class="special">()</span></code>.
        </li>
<li class="listitem">
          Names that refer to <span class="emphasis"><em>concepts</em></span> in the generic programming
          sense are specified in CamelCase.
        </li>
</ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        In addition, notes such as this one specify non-essential information that
        provides additional background or rationale.
      </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        In addition, notes such as this one specify non-essential information that
        provides additional background or rationale.
      </p></td></tr>
</table></div>
<p>
      Finally, you can mentally add the following to any code fragments in this document:
    </p>
<pre class="programlisting"><span class="comment">// Include all of endian files
</span><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">integer</span><span class="special">/</span><span class="identifier">endian</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">integer</span><span class="special">;</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="toward_boost_integer_endian.overview.motivation"></a><a class="link" href="overview.html#toward_boost_integer_endian.overview.motivation" title="Motivation">Motivation</a>
</h3></div></div></div>
<p>
        The original Beman's version provided through the boost::integer::endian&lt;&gt;
        class an integer-like class that providing arithmetics operations on
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Big endian | little endian | native endian byte ordering.
          </li>
<li class="listitem">
            Signed | unsigned
          </li>
<li class="listitem">
            Unaligned | aligned
          </li>
<li class="listitem">
            1-8 byte (unaligned) | 2, 4, 8 byte (aligned)
          </li>
<li class="listitem">
            Choice of integer value type
          </li>
</ul></div>
<p>
        This endian aware design seems to be unappropiated to work with endian unaware
        types, but as we will see this is not completly true, as we can construct
        on top of the Beman's design endian unaware operation. Next follows some
        of the main critics that have been done recently.
      </p>
<a name="toward_boost_integer_endian.overview.motivation.intrusive_verus_non_intrusive"></a><h5>
<a name="id2881294"></a>
        <a class="link" href="overview.html#toward_boost_integer_endian.overview.motivation.intrusive_verus_non_intrusive">Intrusive
        verus non-intrusive</a>
      </h5>
<p>
        Endian conversion must be possible to any type even if you can't modify the
        original source code. Many people think that originel Beman's library requires
        the data types which need to be converted to be coded using his endian types
        as members.
      </p>
<p>
        We will see that this is not true, as the user can always use casting to
        reinterpret a given structure on another one, as the proposed extension does
        with the endian_views.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">endian_unaware_structure</span> <span class="special">{</span>
    <span class="identifier">int32_t</span> <span class="identifier">a</span><span class="special">;</span> 
    <span class="identifier">int16_t</span> <span class="identifier">b</span><span class="special">;</span> 
<span class="special">};</span>
<span class="identifier">endian_unaware_structure</span> <span class="identifier">st_a</span><span class="special">;</span>

<span class="identifier">endian_unaware_structure</span> <span class="identifier">st_b</span><span class="special">;</span>
<span class="identifier">as_endian</span><span class="special">&lt;</span><span class="identifier">native</span><span class="special">&gt;(</span><span class="identifier">st_b</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">as_endian</span><span class="special">&lt;</span><span class="identifier">big</span><span class="special">&gt;(</span><span class="identifier">st_a</span><span class="special">);</span>
</pre>
<a name="toward_boost_integer_endian.overview.motivation.physical_versus_logical_data"></a><h5>
<a name="id2881488"></a>
        <a class="link" href="overview.html#toward_boost_integer_endian.overview.motivation.physical_versus_logical_data">Physical
        versus Logical data</a>
      </h5>
<p>
        The typical use case is to use native endianness until ready to read/write
        using wire format. It is only when ready to do I/O that there is a need to
        account for endianness.
      </p>
<p>
        Beman's original library requires two types one to specify the physical data
        and the other representing the logical data. Many people think that this
        means that the user has to maintain two separate structs/classes when only
        one is needed. This could be sometimes the case, but in other cases, the
        user will store the information elements include in the message on local
        variables and specific contexts that don't follow the external format.
      </p>
<p>
        Applications that don't separate the physical and the logical data structures
        don't scale well as any change on the external format will mean a refactoring
        of the whole application. Also, the wire structures cannot maintain invariants,
        so having a separate class is often useful even if its contents are essentially
        identical to the wire version.
      </p>
<p>
        In addition a single and efficient view is only possible when the pysical
        view can be represented by native aligned integers. But when the physical
        view contains unaliged integers with sizes not supported by the platform,
        the need to separate both view becomes anavoidable. Here the Beman's design
        is the best adapted.
      </p>
<a name="toward_boost_integer_endian.overview.motivation.inherent_inefficient_arithmetic_operations"></a><h5>
<a name="id2881548"></a>
        <a class="link" href="overview.html#toward_boost_integer_endian.overview.motivation.inherent_inefficient_arithmetic_operations">Inherent
        inefficient arithmetic operations</a>
      </h5>
<p>
        The fact that the endian types provide operators gives the impression that
        it's ok to operate on them, as these operations can potentially require two
        endian conversions when the endianness is different.
      </p>
<p>
        Some people don't agree with that design choice, as they think the operation
        of endian conversion and operating on the data should be divorced from each
        other. A less experienced user that you may end up not realizing what the
        hidden costs are and use the endian aware integer-like types throughout the
        application, paying unnecessary overheads. They prefer a library that makes
        hard to misuse in that way; borrowing a phrase from python, "explicit
        is better than implicit". They believe that forcing the user to do the
        explicit endian conversion leads to better separation of concerns for the
        application, but they don't propose any mean to force this conversion.
      </p>
<p>
        The extension proposal separates the endian aware byte-holder type from the
        one able to make arithmetic operations so the user will be forced to convert
        for one to/from the native type, and avoid unfortunate costly atithmetic
        operations.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">endian_aware_structure</span> <span class="special">{</span>
    <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">big</span><span class="special">,</span><span class="identifier">int32_t</span><span class="special">&gt;</span> <span class="identifier">a</span><span class="special">;</span>
    <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">big</span><span class="special">,</span><span class="identifier">int16_t</span><span class="special">&gt;</span> <span class="identifier">b</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
        Structure endian_aware_structure can not be used without converting to native
        types, as endian_pack don't provide other operations than conversion.
      </p>
<pre class="programlisting"><span class="identifier">endian_aware_structure</span> <span class="identifier">st</span><span class="special">;</span>
<span class="comment">// ...
</span><span class="identifier">st</span><span class="special">.</span><span class="identifier">a</span><span class="special">=</span><span class="identifier">i</span><span class="special">;</span>
<span class="identifier">st</span><span class="special">.</span><span class="identifier">b</span><span class="special">=</span><span class="identifier">j</span><span class="special">;</span>
</pre>
<p>
        But don't removes the inefficient and endian safe class, as less demanding
        applications would benefit from the safe and transparent approach.
      </p>
<a name="toward_boost_integer_endian.overview.motivation.in_place_conversion"></a><h5>
<a name="id2932442"></a>
        <a class="link" href="overview.html#toward_boost_integer_endian.overview.motivation.in_place_conversion">In-place
        conversion</a>
      </h5>
<p>
        Other contexts force the user to make in place conversions. While this could
        be dangerous, there are context on which a funtional conversion is not possible,
        mainly because the duplicated space could not be an option. These in-place
        conversions are only possible for aligned endian unaware types.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">endian_unaware_structure</span> <span class="special">{</span>
    <span class="identifier">int32_t</span> <span class="identifier">a</span><span class="special">;</span> 
    <span class="identifier">int16_t</span> <span class="identifier">b</span><span class="special">;</span> 
<span class="special">};</span>
<span class="identifier">endian_unaware_structure</span> <span class="identifier">st</span><span class="special">;</span>

<span class="identifier">as_endian</span><span class="special">&lt;</span><span class="identifier">native</span><span class="special">&gt;(</span><span class="identifier">st</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">as_endian</span><span class="special">&lt;</span><span class="identifier">big</span><span class="special">&gt;(</span><span class="identifier">st</span><span class="special">);</span>
</pre>
<p>
        The fact that some context need this in-place conversion doesn't mean that
        every application should use this approach.
      </p>
<a name="toward_boost_integer_endian.overview.motivation.udt_endianness"></a><h5>
<a name="id2932602"></a>
        <a class="link" href="overview.html#toward_boost_integer_endian.overview.motivation.udt_endianness">UDT
        endianness</a>
      </h5>
<p>
        boost::integer::endian class didn't accept a UDT. We have updated the library
        so now UDT can be used for endian aligned types.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">UserMessage</span> <span class="special">{</span>
  <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">system_clock</span><span class="special">::</span><span class="identifier">time_point</span> <span class="special">&gt;</span> <span class="identifier">timestamp</span><span class="special">;</span>
  <span class="identifier">ulittle32_pt</span> <span class="identifier">aircraft_id</span><span class="special">;</span>
  <span class="keyword">struct</span> <span class="identifier">Position</span> <span class="special">{</span>
     <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">length</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least32_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">x</span><span class="special">;</span>
     <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">length</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least32_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">y</span><span class="special">;</span>
     <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">length</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least32_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">z</span><span class="special">;</span>
  <span class="special">}</span> <span class="identifier">position</span><span class="special">;</span>
  <span class="keyword">struct</span> <span class="identifier">Attitude</span> <span class="special">{</span>
      <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">plane_angle</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least8_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">heading</span><span class="special">;</span>
      <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">plane_angle</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least8_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">pitch</span><span class="special">;</span>
      <span class="identifier">endian_pack</span><span class="special">&lt;</span><span class="identifier">little</span><span class="special">,</span> <span class="identifier">quantity</span><span class="special">&lt;</span><span class="identifier">si</span><span class="special">::</span><span class="identifier">plane_angle</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">int_least8_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">roll</span><span class="special">;</span>
  <span class="special">}</span> <span class="identifier">attitude</span><span class="special">;</span>
<span class="special">};</span> <span class="comment">// UserMessage
</span></pre>
<a name="toward_boost_integer_endian.overview.motivation.mixed_endianness"></a><h5>
<a name="id2933232"></a>
        <a class="link" href="overview.html#toward_boost_integer_endian.overview.motivation.mixed_endianness">Mixed
        endianness</a>
      </h5>
<p>
        Sometimes we need to deal with messages with mixed endianness. A functional
        approach means the programmer has to "know" which endianess the
        data he wants to convert has.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">UdpHeader</span> <span class="special">{</span>
  <span class="identifier">ubig16_pt</span> <span class="identifier">source_port</span><span class="special">;</span>
  <span class="identifier">ubig16_pt</span> <span class="identifier">destination_port</span><span class="special">;</span>
  <span class="identifier">ubig16_pt</span> <span class="identifier">length</span><span class="special">;</span>
  <span class="identifier">ubig16_pt</span> <span class="identifier">checksum</span><span class="special">;</span>
<span class="special">};</span> <span class="comment">// UdpHeader
</span>
<span class="keyword">struct</span> <span class="identifier">Packet</span> <span class="special">{</span>
  <span class="identifier">internet</span><span class="special">::</span><span class="identifier">UdpHeader</span> <span class="identifier">udpHeader</span><span class="special">;</span>
  <span class="identifier">UserMessage</span> <span class="identifier">userMessage</span><span class="special">;</span>
<span class="special">};</span> <span class="comment">// Packet
</span></pre>
<a name="toward_boost_integer_endian.overview.motivation.floating_point"></a><h5>
<a name="id2933409"></a>
        <a class="link" href="overview.html#toward_boost_integer_endian.overview.motivation.floating_point">Floating
        point</a>
      </h5>
<p>
        From my understanding floating point types are not only concerned by endianness,
        but also by a multitude of standard on not standard formats.
      </p>
<a name="toward_boost_integer_endian.overview.motivation.conclusion"></a><h5>
<a name="id2933434"></a>
        <a class="link" href="overview.html#toward_boost_integer_endian.overview.motivation.conclusion">Conclusion</a>
      </h5>
<p>
        The library must support applications needing to work safely with endian
        aware types and efficiently with in place endian conversions.
      </p>
<p>
        Conversions between native and big/little endian formats must be simple.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="toward_boost_integer_endian.overview.description"></a><a class="link" href="overview.html#toward_boost_integer_endian.overview.description" title="Description">Description</a>
</h3></div></div></div>
<p>
        This is an extension of the Beman's Boost.Integer.Endian, which was able
        to work with endian aware types, used to convert between types with different
        endian or even to carry on with arithmetic operations, by spliting the endian
        part from integer part and by adding support for aligned endian unaware types.
      </p>
<p>
        <span class="bold"><strong>Boost.Integer.Endian.Ext</strong></span> provides:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<p class="simpara">
            Endian packs
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem">
                Big endian | little endian | native endian byte ordering.
              </li>
<li class="listitem">
                Signed | unsigned
              </li>
<li class="listitem">
                Unaligned | aligned
              </li>
<li class="listitem">
                1-8 byte (unaligned) | 2, 4, 8 byte (aligned)
              </li>
<li class="listitem">
                Choice of integer value type
              </li>
</ul></div>
</li>
<li class="listitem">
            Endian integers with the whole set of arithmetics operators.
          </li>
<li class="listitem">
            Operators &lt;= and =&gt; for unformatted binary (as opposed to formatted
            character) stream insertion and extraction of built-in, std::string types
            and of endian types.
          </li>
<li class="listitem">
            Views of aligned endian unaware integer types as endian packs or endian
            integers so we can make endian conversion.
          </li>
<li class="listitem">
<p class="simpara">
            Generic in place conversion between different endian formats.
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem">
                Very simple interface: convert_to/from&lt;endiannes domain&gt;(),
              </li>
<li class="listitem">
                Support for built-in and user-defined data types view as fusion sequences.
              </li>
</ul></div>
</li>
</ul></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2006 -2009 Beman Dawes<br>Copyright &#169; 2010 Vicente J. Botet Escriba<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="users_guide.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
