[/
  (C) Copyright 2007-8 Anthony Williams.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:mutex_concepts Mutex Concepts]

A mutex object facilitates protection against data races and allows synchronization of data between fibers. A fiber
obtains ownership of a mutex object by calling one of the lock functions and relinquishes ownership by calling the
corresponding unlock function.

__boost_fiber__ supports one basic concept for lockable objects: __lockable_concept_type__.

[section:lockable `Lockable` Concept]

The __lockable_concept__ models exclusive ownership. A type that implements the __lockable_concept__ shall provide
the following member functions:

* [lock_ref_link `void lock();`]
* [try_lock_ref_link `bool try_lock();`]
* [unlock_ref_link `void unlock();`]

Lock ownership acquired through a call to __lock_ref__ or __try_lock_ref__ must be released through a call to 
__unlock_ref__.

[section:lock `void lock()`]
[variablelist
[[Effects:] [The current fiber blocks until ownership can be obtained for the current fiber.]]
[[Postcondition:] [The current fiber owns `*this`.]]
[[Throws:] [__lock_error__ if an error occurs.]]
]
[endsect]

[section:try_lock `bool try_lock()`]
[variablelist
[[Effects:] [Attempt to obtain ownership for the current fiber without blocking.]]
[[Returns:] [`true` if ownership was obtained for the current fiber, `false` otherwise.]]
[[Postcondition:] [If the call returns `true`, the current fiber owns the `*this`.]]
[[Throws:] [__lock_error__ if an error occurs.]]
]
[endsect]

[section:unlock `void unlock()`]
[variablelist
[[Precondition:] [The current fiber owns `*this`.]]
[[Effects:] [Releases ownership by the current fiber.]]
[[Postcondition:] [The current fiber no longer owns `*this`.]]
[[Throws:] [Nothing]]
]
[endsect]

[endsect]


[section:locks Lock Types]

[section:lock_guard Class template `lock_guard`]

    #include <boost/fiber/locks.hpp>

    template< typename Lockable >
    class lock_guard
    {
    public:
        explicit lock_guard( Lockable & m_);
        lock_guard( Lockable & m_, boost::adopt_lock_t);

        ~lock_guard();
    };

__lock_guard__ is very simple: on construction it
acquires ownership of the implementation of the __lockable_concept__ supplied as
the constructor parameter. On destruction, the ownership is released. This
provides simple RAII-style locking of a __lockable_concept_type__ object, to facilitate exception-safe
locking and unlocking. In addition, the [link
fiber.synchronization.locks.lock_guard.constructor_adopt `lock_guard( Lockable &
m, boost::adopt_lock_t)` constructor] allows the __lock_guard__ object to
take ownership of a lock already held by the current fiber.

[section:constructor `lock_guard( Lockable & m)`]
[variablelist
[[Effects:] [Stores a reference to `m`. Invokes [lock_ref_link `m.lock()`].]]
[[Throws:] [Any exception thrown by the call to [lock_ref_link `m.lock()`].]]
]
[endsect]

[section:constructor_adopt `lock_guard( Lockable & m, boost::adopt_lock_t)`]
[variablelist
[[Precondition:] [The current fiber owns a lock on `m` equivalent to one
obtained by a call to [lock_ref_link `m.lock()`].]]
[[Effects:] [Stores a reference to `m`. Takes ownership of the lock state of
`m`.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:destructor `~lock_guard()`]
[variablelist
[[Effects:] [Invokes [unlock_ref_link `m.unlock()`] on the __lockable_concept_type__
object passed to the constructor.]]
[[Throws:] [Nothing.]]
]
[endsect]

[endsect]


[section:unique_lock Class template `unique_lock`]

    #include <boost/fiber/locks.hpp>

    template< typename Lockable >
    class unique_lock
    {
    public:
        unique_lock();
        explicit unique_lock( Lockable & m_);
        unique_lock( Lockable & m_, adopt_lock_t);
        unique_lock( Lockable & m_, defer_lock_t);
        unique_lock( Lockable & m_, try_to_lock_t);
        unique_lock( Lockable & m_, system_time const& target_time);

        ~unique_lock();

        unique_lock( detail::fiber_move_t< unique_lock< Lockable > > other);
        unique_lock( detail::fiber_move_t< upgrade_lock< Lockable > > other);

        operator detail::fiber_move_t< unique_lock< Lockable > >();
        detail::fiber_move_t< unique_lock< Lockable > > move();
        unique_lock& operator=( detail::fiber_move_t< unique_lock< Lockable > > other);
        unique_lock& operator=( detail::fiber_move_t< upgrade_lock< Lockable > > other);

        void swap( unique_lock & other);
        void swap( detail::fiber_move_t< unique_lock< Lockable > > other);

        void lock();
        bool try_lock();

        void unlock();

        bool owns_lock() const;
        operator ``['unspecified-bool-type]``() const;
        bool operator!() const;

        Lockable * mutex() const;
        Lockable * release();
    };

__unique_lock__ is more complex than __lock_guard__: not only does it provide for RAII-style locking, it also allows
for deferring acquiring the lock until the __lock_ref__ member function is called explicitly, or trying to acquire
the lock in a non-blocking fashion, or with a timeout. Consequently, __unlock_ref__ is only called in the destructor
if the lock object has locked the __lockable_concept_type__ object, or otherwise adopted a lock on the
__lockable_concept_type__ object.

Specializations of __unique_lock__ model the __timed_lockable_concept__ if the supplied __lockable_concept_type__
type itself models __timed_lockable_concept__ (e.g. `boost::unique_lock<boost::timed_mutex>`), or the
__lockable_concept__ otherwise (e.g. `boost::unique_lock<boost::mutex>`). 

An instance of __unique_lock__ is said to ['own] the lock state of a __lockable_concept_type__ `m` if
__mutex_func_ref__ returns a pointer to `m` and __owns_lock_ref__ returns `true`. If an object that ['owns] the lock
state of a __lockable_concept_type__ object is destroyed, then the destructor will invoke [unlock_ref_link
`mutex()->unlock()`].

The member functions of __unique_lock__ are not fiber-safe. In particular, __unique_lock__ is intended to model the
ownership of a __lockable_concept_type__ object by a particular fiber, and the member functions that release
ownership of the lock state (including the destructor) must be called by the same fiber that acquired ownership of
the lock state.

[section:defaultconstructor `unique_lock()`]

[variablelist
[[Effects:] [Creates a lock object with no associated mutex.]]
[[Postcondition:] [__owns_lock_ref__ returns `false`. __mutex_func_ref__ returns `NULL`.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:constructor `unique_lock(Lockable & m)`]

[variablelist
[[Effects:] [Stores a reference to `m`. Invokes [lock_ref_link `m.lock()`].]]
[[Postcondition:] [__owns_lock_ref__ returns `true`. __mutex_func_ref__ returns `&m`.]]
[[Throws:] [Any exception thrown by the call to [lock_ref_link `m.lock()`].]]
]
[endsect]

[section:constructor_adopt `unique_lock(Lockable & m,boost::adopt_lock_t)`]

[variablelist
[[Precondition:] [The current fiber owns an exclusive lock on `m`.]]
[[Effects:] [Stores a reference to `m`. Takes ownership of the lock state of `m`.]]
[[Postcondition:] [__owns_lock_ref__ returns `true`. __mutex_func_ref__ returns `&m`.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:constructor_defer `unique_lock(Lockable & m,boost::defer_lock_t)`]

[variablelist
[[Effects:] [Stores a reference to `m`.]]
[[Postcondition:] [__owns_lock_ref__ returns `false`. __mutex_func_ref__ returns `&m`.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:constructor_try `unique_lock(Lockable & m,boost::try_to_lock_t)`]

[variablelist
[[Effects:] [Stores a reference to `m`. Invokes [try_lock_ref_link
`m.try_lock()`], and takes ownership of the lock state if the call returns
`true`.]]
[[Postcondition:] [__mutex_func_ref__ returns `&m`. If the call to __try_lock_ref__
returned `true`, then __owns_lock_ref__ returns `true`, otherwise __owns_lock_ref__
returns `false`.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:destructor `~unique_lock()`]

[variablelist
[[Effects:] [Invokes __mutex_func_ref__`->`[unlock_ref_link `unlock()`] if
__owns_lock_ref__ returns `true`.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:owns_lock `bool owns_lock() const`]

[variablelist
[[Returns:] [`true` if the `*this` owns the lock on the __lockable_concept_type__
object associated with `*this`.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:mutex `Lockable* mutex() const`]

[variablelist
[[Returns:] [A pointer to the __lockable_concept_type__ object associated with
`*this`, or `NULL` if there is no such object.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:bool_conversion `operator unspecified-bool-type() const`]

[variablelist
[[Returns:] [If __owns_lock_ref__ would return `true`, a value that evaluates to
`true` in boolean contexts, otherwise a value that evaluates to `false` in
boolean contexts.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:operator_not `bool operator!() const`]

[variablelist
[[Returns:] [`!` __owns_lock_ref__.]]
[[Throws:] [Nothing.]]
]
[endsect]

[section:release `Lockable* release()`]

[variablelist
[[Effects:] [The association between `*this` and the __lockable_concept_type__ object is removed, without affecting
the lock state of the __lockable_concept_type__ object. If __owns_lock_ref__ would have returned `true`, it is the
responsibility of the calling code to ensure that the __lockable_concept_type__ is correctly unlocked.]]
[[Returns:] [A pointer to the __lockable_concept_type__ object associated with `*this` at the point of the call, or
`NULL` if there is no such object.]]
[[Throws:] [Nothing.]]
[[Postcondition:] [`*this` is no longer associated with any __lockable_concept_type__ object. __mutex_func_ref__
returns `NULL` and __owns_lock_ref__ returns `false`.]]
]
[endsect]

[endsect]
