[library Boost.Assign
    [quickbook 1.5]
    [version 2.0]
    [authors [Thorsten, Ottosen],[Rogard, Erwann]]
    [copyright 2003-2004 Thorsten Ottosen, 2010 Erwann Rogard]
    [dirname /libs/assign/v2/doc/]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [id boost_assign_v2]
]

[/Support]

[def __TO__						[@http://www.boost.org/users/people/thorsten_ottosen.html TO]]
[def __ER__						[@mailto:erDOTciDOT2020ATgmailDOTcom ER]]

[template tpl_user_mailing_list[var]	[@http://www.boost.org/community/groups.html#users [var]]]
[def __user_mailing_list__      [tpl_user_mailing_list Boost Users Mailing List]]


[/ Standard ]

[template tpl_cpp03[var] [@http://en.wikipedia.org/wiki/C%2B%2B03 [var]]]
[template tpl_cpp0x[var] [@http://www2.research.att.com/~bs/C++0xFAQ.html [var]]]

[def __cpp0x__ [tpl_cpp0x C++0x]]
[def __cpp03__ [tpl_cpp03 C++03]]

[/ Platform]

[def __mac_os__ OS X 10.6.4]
[def __mac_default_compiler__ gcc4.2]
[def __mac_optim__ Release | x86_64]
[def __mac_processor__ 2.4 Ghz Intel Core 2 Duo]
[def __mac_mem__ 4GB 1067 Mhz DDR3]

[template tpl_fink[var] [@http://www.finkproject.org/ [var]]]
[def __fink__ [tpl_fink Fink]]

[/ Libraries ]

[def __boost_assign_v1__ Boost.Assign 1.0]
[def __boost_assign_v2_mini_review__ [@http://lists.boost.org/Archives/boost/2010/06/168028.php mini-review]]
[def __boost_assign_v2__ Boost.Assign 2.0]

[template tpl_boost[var] [@http://www.boost.org [var]]]
[def __boost__ [tpl_boost Boost]]

[template tpl_boost_array[var] [@http://www.boost.org/doc/libs/release/doc/html/array.html [var]]]

[template tpl_mpl[var] [@http://www.boost.org/libs/mpl/index.html [var]]]
[def __mpl__ [tpl_mpl MPL]]

[template tpl_stl[var] [@http://en.wikipedia.org/wiki/Standard_Template_Library [var]]]
[def __stl__ [tpl_stl STL]]

[template tpl_stl_associative_cont[var] [@http://www.sgi.com/tech/stl/AssociativeContainer.html [var]]]

[template tpl_stl_sequence_cont[var] [@http://www.sgi.com/tech/stl/Sequence.html [var]]]

[template tpl_lambda[var] [@http://www.boost.org/doc/libs/release/doc/html/lambda.html [var]]]
[def __lambda__	[tpl_lambda lambda]]

[template tpl_ptr_container[var] [@http://www.boost.org/doc/libs/release/libs/ptr_container/doc/ptr_container.html [var]]]

[template tpl_range[var] [@http://www.boost.org/doc/libs/release/libs/range/index.html [var]]]
[template tpl_range_adaptor[var] [@http://www.boost.org/doc/libs/1_44_0/libs/range/doc/html/range/reference/adaptors.html [var]]]
[template tpl_range_adaptor_composition[var] [@http://www.boost.org/doc/libs/1_44_0/libs/range/doc/html/range/reference/adaptors/introduction.html#range.reference.adaptors.introduction.composition_of_adaptors [var]]]
[template tpl_range_algorithm[var] 	[@http://www.boost.org/doc/libs/1_44_0/libs/range/doc/html/range/reference/algorithms.html [var]]]

[/Headers]

[def __local_boost_dir__ 		boost/assign/v2]
[def __local_libs_dir__ 		libs/assign/v2]

[/Files]

[template tpl_foo_cpp[var] [@file:///usr/local/trunk/libs/assign/v2/example/foo.cpp [var]] ] [/TODO relative]

[template tpl_unit_testing_log_mac_gcc42[var] [@file:///usr/local/trunk/libs/assign/v2/test/unit_testing/log_mac_gcc42 [var]] ] [/TODO relative]

[/Concepts]

[template tpl_concept_range[var] [@http://www.boost.org/doc/libs/1_43_0/libs/range/doc/html/range/concepts.html [var]]]

[template tpl_crtp[var] [@http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern [var]]]
[def __crtp__ [tpl_crtp crtp]]

[/Internal]

[/Sections]

[template tpl_sec_notation [var] 					[link boost_assign_v2.dummy.ug.notation [var]]]
[template tpl_sec_wa [var] 							[link boost_assign_v2.dummy.ug.wa [var]]]
[template tpl_sec_ref_anon [var] 					[link boost_assign_v2.dummy.ug.ref_anon [var]]]
[template tpl_sec_put [var] 						[link boost_assign_v2.dummy.ug.put [var]]]
[template tpl_sec_put_arg_forwarding [var] 			[link boost_assign_v2.dummy.ug.put.arg_forwarding [var]]]
[template tpl_sec_put_arg_forwarding_auto [var] 	[link boost_assign_v2.dummy.ug.put.arg_forwarding.auto [var]]]
[template tpl_sec_put_arg_forwarding_user [var] 	[link boost_assign_v2.dummy.ug.put.arg_forwarding.user [var]]]
[template tpl_sec_put_std_modifier [var] 			[link boost_assign_v2.dummy.ug.put.std_modifier [var]]]
[template tpl_sec_put_std_modifier_auto [var] 		[link boost_assign_v2.dummy.ug.put.std_modifier.auto [var]]]
[template tpl_sec_put_std_modifier_user [var] 		[link boost_assign_v2.dummy.ug.put.std_modifier.user [var]]]
[template tpl_sec_put_ext_func_repeat [var] 		[link boost_assign_v2.dummy.ug.put.ext_func.repeat [var]]]
[template tpl_sec_put_test_knowledge [var] 			[link boost_assign_v2.dummy.ug.put.test_knowledge [var]]]

[template tpl_sec_anon [var] 						[link boost_assign_v2.dummy.ug.anon [var]]]
[template tpl_sec_put_range [var] 					[link boost_assign_v2.dummy.ug.put_range [var]]]
[template tpl_sec_chain [var] 						[link boost_assign_v2.dummy.ug.chain [var]]]
[template tpl_sec_conversion [var] 					[link boost_assign_v2.dummy.ug.conversion [var]]]


[template tpl_sec_testing_platform [var] [link boost_assign_v2.dummy.testing_platform [var]]]


[/ Templates]

[def __type_ext__ _]
[template tpl_join[a b][a][b]]
[template tpl_typeof[object][tpl_join [object]..__type_ext__]]
[template tpl_seq[index first last] [index] = [first], ..., [last]]
[template tpl_sub[var index] [var]\[[index]\] ]
[template tpl_sub_sub[var index1 index2] [var]\[[index1],[index2]\]]

[/ Notation ]

[def __container__				cont]
[def __from__					from]
[def __from_type_				From]
[def __to__						to]
[def __to_type__				To]
[def __container_type__			Cont]
[def __container___				[tpl_typeof __container__]]
[def __key__					s]
[def __key_type__				S]
[def __value__					t]
[def __value___					[tpl_typeof __value__]]
[def __value_type__				T]
[def __key_data__				u]
[def __key_data_type__			U]
[def __f__						f]
[def __f___						[tpl_typeof __f__]]
[def __object__					obj]
[def __object___				[tpl_typeof __object__]]
[def __range__					r]
[def __range___					[tpl_typeof __range__]]

[def __param__					p]
[def __param___					[tpl_typeof __param__]]
[def __l__						l]
[def __m__						m]

[/Ranges]
[def __r1__						r1]
[def __r1_type__				R1]
[def __r2__						r2]
[def __r2_type__				R2]

[def __1st_value__				x]
[def __2nd_value__				y]
[def __3rd_value__				z]
[def __i__						i] 
[def __n__						n]

[def __arg__ 					arg]
[def __1st_of_arg__ 			a]
[def __2nd_of_arg__ 			b]
[def __3rd_of_arg__ 			c]
[def __j__						j]
[def __k__						k]

[/ Keywords ]

[def __nil__				_nil]

[section:dummy Help with qbk : without this enclosing section, the layout messes up! ]

[section Preface]

The __boost_assign_v2__ framework offers the following tools:

* Putting elements in a container with an interface that is uniform across container types.
* Assignment between containers of different categories, such as from a `std::vector<>`, which models [tpl_stl_sequence_cont Sequence],
to a `std::stack<>`, which is an [tpl_stl_sequence_cont adapter container]
* An anonymous container (i.e. constructed in place) of values, whose interface is akin to a `std::deque<>`.
* An anonymous container (i.e. constructed in place) of references, whose interface is akin to [tpl_boost_array `boost::array<>`]. 
* Forming the union of (chaining) ranges while preserving the properties of the underlying iterator types, which is non-trivial
if at least one range is that of an anonymous container (a temporary) of lvalue references.

These tools are for the most part available through adaptors, a concept borrowed from [tpl_range_adaptor range adaptors] so that they work
together nicely with [tpl_range_algorithm range algorithms]. 

[endsect][/Preface]

[/ ---------------------------------------------------------------------------------------------- ]
[/ ---------------------------------------------------------------------------------------------- ]


[section:ug User's guide]

This section describes the usage of the tools of this library. For specific details, check the reference section.

All the examples given therein are in the `/libs/assign/v2/example/` directory. 

[/ ---------------------------------------------------------------------------------------------- ]

[section Notation]

[table Symbols
	[[Symbol][Description]]
	[
		[`__container__`]
		[ A container] 
	]
	[
		[`__key__`]
		[ A key ] 
	]
	[
		[`__value__`]
		[ A data ] 
	]
	[
		[`__key_data__`]
		[ A key data pair ] 
	]
	[	
		[`__arg__`]
		[ An argument to a function ]
	]
	[	
		[`__object__`]
		[ An object defined in this library ]
	]
	[
		[`__param__`]
		[ A parameter for mutating an object ]
	]
]

To represent the types of the above, we typically use the a capital letter. For example `T` is the type of `t`.

[/
	[
		[`__f__`]
		[ A function ]
	]
]

[table Indexes
	[ 
		[ Expression ] 
		[ Description] 
	]
	[ 
		[ [^[tpl_seq [^__i__]..0..[^__n__]-1]] ] 
		[Indexes a sequences of `__value__`'s] 
	]
	[ 
		[ [^[tpl_seq [^__j__]..0..[^__k__]-1]] ] 
		[Indexes arguments associated with a `__value__` ] 
	]
	[ 
		[ [^[tpl_sub [^__k__]..[^__i__]]] ] 
		[Number of function arguments at [^__i__] ]
	]
	[ 
		[ [^[tpl_sub `__arg__`..[^__i__]]] ] 
		[ Set of arguments at [^__i__] ]
	]
	[ 
		[ [^[tpl_sub_sub `__arg__`..[^__i__]..[^__j__]]] ] 
		[[^__j__] th argument at [^__i__] ]
	]
	[ 
		[ [tpl_sub [^__1st_of_arg__]..[^__i__]], [tpl_sub [^__2nd_of_arg__]..[^__i__]], [tpl_sub [^__3rd_of_arg__]..[^__i__]] etc.] 
		[ Shorthand for [tpl_sub_sub [^__arg__]..[^__i__]..[^0]], [tpl_sub_sub [^__arg__]..[^__i__]..[^1]], [tpl_sub_sub [^__arg__]..[^__i__]..[^2]] etc.]
	]
	[ 
		[ [^[tpl_seq [^__l__]..0..[^__m__]-1]] ] 
		[Indexes a sequences of `__param__`'s] 
	]
]

[endsect][/Notation]

[/ ---------------------------------------------------------------------------------------------- ]

[section:wa Working assumptions]

Here we give some pieces of code that will be assumed throughout. The chosen
set up is such that, by appealing to deduction, a broad range of needs, including the basic ones,
are adressed. What we mean by a basic need, is filling a container with `int`s. What we mean by
a need that is at the complexity boundary of our set up, is working with a collection of `boost::tuple`s
of references. 

The first piece of code are include statements:
[import ../example/include.h]
[include_statements]

Next, we define a `struct`, `foo` : 
[import ../example/foo.h]
[foo]
The exact definition of `operator<<` can be found in the file [tpl_foo_cpp foo.cpp].

Then come some dependent types,
[foo_types]
and finally a set of constants :
[foo_constants]

In terms of our notation, by seeing `__1st_value__`, `__2nd_value__`, and `__3rd_value__` as forming
a sequence, `__n__ = 3`, `__k__[0] = 1`, `__k__[1] = 0`, and `__k__[2] = 2`. 

[endsect][/Working assumptions]

[/ ---------------------------------------------------------------------------------------------- ]

[section:ref_anon Anonymous container of references]

[section Synopsis]

[table 
	[ [Call][ Result ] ]
	[
		[`ref::assign_xxx::csv_anon( __nil__ )`]
		[`typename ref::assign_xxx::nth_result_of::csv_anon<0, U>::type`]
	]
	[
		[`ref::assign_xxx::csv_anon( __value__[0], ..., __value__[__n__-1] )`]
		[`typename ref::assign_xxx::nth_result_of::csv_anon<__n__, U>::type`]
	]
	[
		[`ref::assign_xxx::csv_anon( __nil__ )`]
		[`typename ref::assign_xxx::nth_result_of::anon<0, U>::type`]
	]
	[
		[`ref::assign_xxx::anon( __value__[0] )...( __value__[__n__-1] )`]
		[`typename ref::assign_xxx::nth_result_of::anon<__n__,U>::type`]
	]
]

[endsect][/Synopsis]
where `ref::assign_xxx` is either of `ref::assign_copy` or `ref::assign_rebind`, and `U` is `T const` if `__value__[__i__]` is `const` or an `rvalue`, for
at least one `__i__`, and `U` is `T` otherwise.

[section:copy Assign copy]

[import ../example/ref_anon.cpp]
To work with references, the relevant `namespace` is `ref`, but we also need a nested `namespace` that specifies an 
assignment policy. For example,
[assign_copy_read]

The result from `ns::csv_anon()` is more than just a range. It has much of the functionality of the 
static array, [tpl_boost_array `boost::array<>`], such as `assign()`, as we now illustrate,
[assign_copy_write]

[endsect][/ Assign copy]

[section:rebind Assign rebind]

We now turn to the rebind assignment policy. Here, it will be necessary to save the result:
[assign_rebind_read]
Thus far, the side effect would be the same under the `assign_copy` policy. The effect of assigning 
a new object to each element of our result, however, is different:
[assign_rebind_write]

[endsect][/ Assign rebind]

[section:functor The functor interface]

The functor interface works as follows: 
[anon_read_empty]
and `result1` has all the functionality of that resulting from `csv_anon(__1st_value__, __2nd_value__)`. Unlike the latter,
it's possible to append an element:
[anon_read_fill]
Internally, `result2` keeps a reference to `result1`, and not until the [tpl_boost_array `boost::array<>`] interface is called,
as in
[anon_read_print]
is a static array allocated, with reference wrappers, in this case, for `__1st_value__`, `__2nd_value__` and `__3rd_value__`, 

[endsect][/ Functor interface]

[endsect][/ Anonymous container of references]

[/ ---------------------------------------------------------------------------------------------- ]

[section:put Adaptors `_csv_put` and `_put` ]

[section Synopsis]

[table The put adaptor 
	[ [Call][ Result ] ]
	[
		[`__container__ | (adaptor::_csv_put % __param__[0] % ... % __param__[__m__] )( __value__[0], ....,__value__[__n__-1] )`]
		[`__container_type__&`]
	]
	[
		[`__container__ | (adaptor::_put % __param__[0] % ... % __param__[__m__] )(__arg__[0][0], ..., __arg__[0][__k__[0]])...( __arg__[__n__-1][0], ..., __arg__[__n__-1][__k__[__n__-1]])`]
		[`__container_type__&`]
	]
]

[endsect][/Synopsis]

[section:usage Basic usage ]

To put elements, `__1st_value__`, `__2nd_value__` and `__3rd_value__` into a container, 
[import ../example/put_adaptor.cpp]
[vector]

The workings and benefits of adaptors are developed in [tpl_range_adaptor range adaptors], so they
will not be repeated here. For our purpose, however, keep in mind that our adaptor modifies the state 
of a container before returning it. Specifically, the statement inside the first argument of 
`boost::for_each` is equivalent, for this particular container type, to
``
	__container__.push_back( __1st_value__ );
	__container__.push_back( __2nd_value__ );
	__container__.push_back( __3rd_value__ );
``
and returns a reference to `cont`.  The result from `_csv_put( __1st_value__, __2nd_value__ ,__3rd_value__ )` 
internally keeps references to `__1st_value__`, `__2nd_value__` , `__3rd_value__`, so as to avoid any storage overhead. 

[endsect][/ Passing values]

[section:std_modifier Standard modifier]

A container has one or more member functions to alter its state, and in the case that interests us, adding elements. For example,
`push_back()` is what we call, in this library, a standard modifier. 

[section:auto Automatic deduction]

We have just encountered one instance of a [tpl_stl_sequence_cont sequence container], `std::vector<>`. 
In fact, the same adaptor works  seamlessly with the other categories of __stl__ containers,
[tpl_stl_associative_cont associative], and [tpl_stl adapter] (`std::stack<>` and `std::queue<>`), and the static array [tpl_boost_array `boost::array<>`]. 
For example,
[map]
In this instance, instead of `push_back()`, as we had explained in the case of `std::vector<>`, 
`insert()` is the modifier that is called. This choice is made at compile time by the library, 
based on certain properties of the destination container (traits). 

The repetition of `key_data_()` in the code, though, is not very elegant. There is a better solution,
but it would be outside of the topic of this section and therefore it will be shown in a subsequent one. 

[endsect][/ Automatic deduction]

[section:user User specified]

We have seen that the library automatically chooses a modifier at compile time, such as `push_back()` 
and `insert()` in the cases of `std::vector<>`, and `std::map<>`, respectively. We can, however, 
choose the modifier explicitly. This makes sense, for example, for `std::list<>` because the default 
modifier is `push_back()`, whereas the user may in fact wish to call `push_front()`,
[list]

Here's a catalog of the different standard modifiers.
[table Standard modifier
	[ [ Parameter ][ Implementation ][ Default ] ]
	[ [ `_push_back` ][ `__container__.push_back( __value__ )` ][ [tpl_stl_sequence_cont Sequence] ] ]
	[ [ `_push_front` ][ `__container__.push_front( __value__ )` ][ ]  ]
	[ [ `_push` ][ `__container__.push( __value__ )` ][ [tpl_stl Adapters] ]  ]
	[ [ `_at_next` ][ `__container__[ __i__++ ] = __value__ ` ][ [tpl_boost_array Static arrays] ] ]
	[ [ `_insert` ][ `__container__.insert( __value__ )` ][ [tpl_stl_associative_cont Associative] ] ]
]
where index `__i__` is initialized to zero.

More generally, `operator%`, in conjunction with the adaptor generator `_csv_put` is used to pass a
parameter to the latter (not just a modifier) that determines the implementation of `operator|`.
Just as the latter, `operator%` is composable. Make sure to keep any statement involving `operator%`
and `_csv_put` in between brackets, as shown above.

[endsect][/ User specified ]

[section Custom ]

Imagine that the user has defined his/her own container, and that `baz()` is the member function by which
elements are inserted:
``
	struct bar{ void baz(int); };
``
By first expanding
``
	BOOST_ASSIGN_V2_PUT_MODIFIER_XXX(baz)
``
it's then possible to call, say
``
	bar __container__;
	__container__ | (_csv_put % _baz)( __1st_value__, __2nd_value__, __3rd_value__ );	
``

[endsect][/ Custom]

[endsect][/ Standard modifier ]

[section:arg_forwarding Argument forwarding]

[section:auto Automatic deduction]

The adaptor generator `_csv_put` which we have discussed so far is fine when the objects to be 
put into a container are already constructed. Otherwise, we have to construct them in place, e.g.
[in_place]
We can achieve the same result, but with code that is more compact, using a functor analog to `_csv_put`, 
`_put`, that takes care of forwarding to the constructor:
[forward_to_constructor]
The appropriate constructor is deduced at compile time, from the value type of the destination
container.

We are now able to show how to overcome the drawback that was pointed out when filling a `std::map<>`, 
i.e. that the constructor had to be called explicitly for each pair key-data arguments. Continuing that
[tpl_sec_put_std_modifier_auto example],
[map_proper]

[warning Using the adaptor `_put` may have greater compilation needs than `_csv_put`. For large [^__n__] and [^__k__],  it may be necessary to
construct objects in place, and pass them to `_csv_put`. As an indication, under the [tpl_sec_testing_platform default testing platform],
[^__n__ > 32] and [^__k__ = 1], `_put` becomes problematic.]

[endsect][/ Automatic deduction]

[section:user User specified]

As we have just seen, forwarding to the constructor is the default choice. We can override it with 
`operator%` in conjuction with `_fun`. Continuing from the previous example involving `std::vector<>`,
[forward_to_make_foo]

Users that are familiar with the __lambda__ library will have recognized that the repetition of 
`b` would be better avoided thanks to a binding functor:
[forward_to_bind]
Notice that since each argument in the sequence is now unary, we were able to revert to using `_csv_put`, 
and did so only because it's more elegant that way.

[endsect][/User specified]
[endsect][/Forwarding arguments]

[section:ptr_container Pointer container]

The same functionality as that for STL containers works for [tpl_ptr_container pointer containers], but the side effect is a bit different.
For example, consider,
[ptr_vector]
Copies of `__1st_value__`, `__2nd_value__` and `__3rd_value__` are allocated on the heap, and their pointers put into
`cont`, using `push_back`, in this case. Just as with other categories of containers, we can override both the modifier and the argument forwarding mechanism, by
passign the appropriate parameters with `operator%`.

[endsect][/Pointer containers]

[section:ext_func Extended functionality]

We have seen that there are two orthogonal parametrization: the standard modifier, e.g. `_push_back` and the forwarding functor, e.g. `_fun = make_foo()`.
Here, we discuss parametrization that is more complex. 

[section:repeat Repeating an argument]

[repeat_simple]

[endsect][/Repeating an argument]

[endsect][/Extending functionality]

[section:test_knowledge Test your knowledge]

Look at the piece of code below, and try to figure out what the output will be. Notice that shown in the comments are the outputs of the individual 
values, in the order in which they are passed to the adaptor generator. For example, the output of `std::cout << __1st_value__` is [^(1,0)]. 
[complex_ex1]

The right answer is:
[complex_ex1_answer]

[endsect][/Test your knowledge]

[endsect][/The put adaptor]

[/ ---------------------------------------------------------------------------------------------- ]

[section:anon Anonymous container of values]

[section Synopsis]

[table 
	[ [Call][ Result ] ]
	[
		[`csv_anon( __value__[0], ...,__value__[__n__-1] )`]
		[`typename result_of::anon<T>::type`]
	]
	[
		[`( anon<T>(_nil)  % __param__[0] % ... % __param__[__m__] )( __arg__[0][0], ..., __arg__[0][__k__[0]])...( __arg__[__n__-1][0], ..., __arg__[__n__-1][__k__[__n__-1]])`]
		[`typename result_of::anon<T>::type`]
	]
]

[endsect]

[section Usage]

An anonymous container of values is akin to a `std::deque<>` that can be constructed in place. 

[import ../example/anon.cpp]
Here's an example using the csv form:
[csv_anon]
Here's an example using the functor form, and a parameter passed with `operator%`
[anon]

The section is kept brief, because one can deduce the workings of the interface from that of the [tpl_sec_put `_put` adaptor], which is explained in detail.
Specifically, the `csv` vs argument forwarding (functor) dichotomy and the parameter passing mechanism, via `operator%`, are the same. 

[endsect]

[endsect][/Anonymous container of values]

[/ ---------------------------------------------------------------------------------------------- ]

[section:put_range Adaptor `_put_range`]

[section Synopsis]

[table 
	[ [Call][ Result ] ]
	[
		[`__to__ | adaptor::_put_range( __from__ )`]
		[`__to_type__&`]
	]
]

[endsect]

[section Usage]

[import ../example/put_range.cpp]
In this example we show how to put a `std::vector<>`'s element into a `std::queue<>`. 
[put_range_queue]

[note Reversing the roles `std::vector<>` and `std::queue<>` in the above operation will not compile, because the input 
container, `from`, must model a [tpl_concept_range forward range]. ] 

[endsect]

[endsect][/Adaptor _put_range]

[/ ---------------------------------------------------------------------------------------------- ]

[section:chain Adaptor `_chain`]

[table 
	[ [Call][ Result ] ]
	[
		[`__r1__ | adaptor::_chain( __r2__ )`]
		[`typename result_of::chain<__r1_type__,__r2_type__>::type`]
	]
]

[section Synopsis]

[endsect]

[section Usage]

[import ../example/chain.cpp]
Adaptor `_chain` is an outgrowth of a similar functionality that appeared in the beta version of [tpl_range Boost.RangeEx] that maps
two ranges into their union. It is composable, as illustrated below:
[chain_read]
Adaptor `_chain` has the special property that it is lvalue preserving. Let us explain. An anonymous container of references, 
by definition (anonymous means constructed in place), is an rvalue. The references themselves, however, may be lvalue. Two chained
ranges, either of which is passed as an rvalue, but both of which hold lvalues, is a range whose references are lvalues. Let us 
now illustrate this:
[chain_write]

[endsect]

Also see the section on conversion.

[endsect][/ Adaptor `_chain`]

[/ ---------------------------------------------------------------------------------------------- ]

[section:conversion Conversion]

[section Synopsis]

[table 
	[ [Call][ Result ] ]
	[
		[`from | convert<__to_type__>()`]
		[`__to_type__`]
	]
	[
		[`__object__.convert<__to_type__>()`]
		[`__to_type__`]
	]
	[
		[`__to__ = __object__`]
		[`__to_type__&`]
	]
]
where `__object__` is either an anonymous container, of values or references, or the result from the `_chain` adaptor.

[endsect]

[import ../example/conversion.cpp]

[section Anonymous containers]

Anonymous containers can be converted to an arbitray containers. Such as tool is particularly relevant when the destination container is an [tpl_stl adapter container] 
as they cannot be constructed from a pair of iterators.

It's possible to perform conversion in place, as is sometimes necessary for copy-constructing a container:
[convert_anon_explicit]
While we can use the same member function, `convert<>()`, to assign a container, implicit conversion suffices:
[convert_anon_auto]

[endsect]

[section `_chain` adaptor]

Here's a case where chaining takes places:
[convert_chain]

[endsect]

[section Inter-STL-categories]

The library also caters to inter STL categories conversion, with the help of the `_convert` adaptor. Here's an example:
[convert_explicit]

[endsect]

[endsect][/Conversion]

[/ ---------------------------------------------------------------------------------------------- ]

[section:arity Configuring arity]

Below are overridable constants. In the first column is the constant's identifier, it's default value, 
and the relevant [tpl_sec_notation index] that they control. 

[table
	[[ Constant ][ Default value ][ Index ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_CSV_ARITY`][20][ __n__ ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_LVALUE_CONST_ARITY`][2][ __k__ ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_ARITY`][ `BOOST_MPL_LIMIT_METAFUNCTION_ARITY`][ __k__ ]]
]

The first constant is the limit arity of a call such as
``
	_csv_put( __value__[0], ..., __value__[__n__-1]);
``
The second and third constants apply only to the functor form:
``
	_put( __arg__[0][0], ..., __arg__[0][__k__[0]])...( __arg__[__n__-1][0], ..., __arg__[__n__-1][__k__[__n__-1]]);
``
Specifically, the second constant is the limit for arity `__k__[__i__]` under which any combination of lvalue and rvalue arguments is preserved, 
for any given `__i__` in `[0,...,__n__)`. Beyond this limit, all arguments are treated as either lvalues or rvalues. This restriction only applies 
to __cpp03__, not __cpp0x__. The third constant is the total limit for arity `__k__[__i__]`.

[endsect][/Configuring arity]


[endsect][/Users' guide]

[/ ---------------------------------------------------------------------------------------------- ]

[section Runtime efficiency]

In this section, we compare the execution time of various ways to fill an STL container or creating an anonymous container.
[import ../speed/anon_put_ref.cpp]
Here are the types that are used:
[types]
And here are the simulation parameters:
[sim_param]

These are the results:

[table 
	[[Library][Call][ [^__n__ = 1] ][ [^__n__ = 2] ][ [^__n__ = 4] ][ [^__n__ = 8] ][ [^__n__ = 16] ][ [^__n__ = 32] ]]
	[
		[
			__stl__
		]
		[``
			__container__.push_back( __value__[0] );...__container__.push_back( __value__[__n__-1] );
		``]
		[[^0.094 s]][[^0.364 s]][[^0.756 s]][[^1.737 s]][[^3.852 s]][[^7.807 s]]
	]
	[
		[``
			__boost_assign_v1__	
		``]
		[``
			list_of( __value__[0] )...( __value__[__n__-1] )
		``]
		[[^1.211 s]][[^2.618 s]][[^4.219 s]][[^7.226 s]][[^13.125 s]][[^26.486 s]]
	]
	[
		[``
			__boost_assign_v1__	
		``]
		[``
			push_back( __container__ )( __value__[0] )...( __value__[__n__-1] )
		``]
		[[^0.251 s]][[^0.726 s]][[^1.709 s]][[^3.780 s]][[^7.869 s]][[^16.117 s]]
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			csv_anon( __value__[0], ...,__value__[__n__-1] )
		``]
		[[^1.252 s]][[^2.067 s]][[^ 3.562 s]][[^6.363 s]][[^12.365 s]][[^25.760 s]]
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			anon<T>(_nil)( __value__[0] )...( __value__[__n__-1] )
		``]
		[[^1.286 s]][[^2.160 s]][[^3.663 s]][[^6.570 s]][[^12.559 s]][[^25.841 s]]
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			ref::assign_copy::csv_anon( __value__[0], ..., __value__[__n__-1] )
		``]
		[[^1e-06 s]][[^0.003 s]][[^0.003 s]][[^0.008 s]][[^0.016 s]][[^0.030 s]]
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			ref::assign_copy::anon( __value__[0] )...( __value__[__n__-1] )
		``]
		[[^0.289 s]][[^0.289 s]][[^0.320 s]][[^0.367 s]][[^0.472 s]][[^0.778 s]]
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			csv_put( __container__ )( __value__[0], ....,__value__[__n__-1] )
		``]
		[[^0.257 s]][[^0.647 s]][[^1.692 s]][[^3.717 s]][[^7.913 s]][[^16.192 s]]
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			put( __container__ )( __value__[0] )...( __value__[__n__-1] )
		``]
		[[^0.260 s]][[^0.716 s]][[^1.748 s]][[^3.856 s]][[^8.040 s]][[^16.462 s]]
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			__container__ | csv_put( __value__[0], ....,__value__[__n__-1] )
		``]
		[[^0.280 s]][[^0.723 s]][[^1.716 s]][[^3.712 s]][[^7.969 s]][[^16.241 s]]
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			__container__ | _put( __value__[0] )...( __value__[__n__-1] )
		``]
		[[^0.266 s]][[^0.718 s]][[^1.729 s]][[^3.810 s]][[^8.129 s]][[^16.949 s]]
	]
]

See the [tpl_sec_testing_platform testing platform] under which these results were obtained.

[/
-> Runtime efficiency 
Each value, t, is a std::vector<int> of max size 100
Number of loops over which execution time is summed : 1000000 
N = 1 . . . N = 2 . . . N = 4 . . . N = 8 . . . N = 16 . . . N = 32 . . . 
n = [1 2 4 8 16 32 ]
vec.push_back( t0 ); ... vec.push_back( tN-1 );[0.09474 s 0.364069 s 0.756583 s 1.73736 s 3.85251 s 7.80783 s ]
list_of( t0 )...( tN-1 )[1.21162 s 2.61857 s 4.21912 s 7.22663 s 13.1252 s 26.4862 s ]
push_back( vec )( t0 )...( tN-1 )[0.251143 s 0.726118 s 1.70959 s 3.78038 s 7.86995 s 16.1174 s ]
csv_anon(t0, ...,tN-1)[1.25213 s 2.06734 s 3.56238 s 6.36345 s 12.3659 s 25.7607 s ]
anon<T>( _nil )( t0 )...( tN-1 )[1.28602 s 2.16045 s 3.66355 s 6.57027 s 12.5592 s 25.8411 s ]
ref::assign_copy::csv_anon(t0, ...,tN-1)[1e-06 s 0.003894 s 0.00378 s 0.008088 s 0.016149 s 0.030065 s ]
ref::assign_copy::anon( t0 )...( tN-1 )[0.289133 s 0.289451 s 0.320333 s 0.367231 s 0.47232 s 0.77807 s ]
csv_put( vec )(t0, ...,tN-1)[0.257457 s 0.647526 s 1.69284 s 3.71717 s 7.91357 s 16.1927 s ]
put( vec )( t0 )...( tN-1 )[0.260559 s 0.716297 s 1.74887 s 3.8568 s 8.04035 s 16.4621 s ]
vec | _csv_put(t0, ...,tN-1)[0.280242 s 0.723652 s 1.71606 s 3.71251 s 7.96936 s 16.2413 s ]
vec | _put( t0 )...( tN-1 )[0.266304 s 0.718539 s 1.72965 s 3.81051 s 8.12922 s 16.949 s ]
<- 

]

[note The call `csv_put( __container__ )( __value__[0], ....,__value__[__n__-1] )` and its `_put` analog, 
are part of the implementation of `_csv_put` and `_put`, respectively.  They are given here only to gauge
the overhead between these two layers of code. ]

[endsect][/Runtime efficiency]

[/ ---------------------------------------------------------------------------------------------- ]

[section:testing_platform Testing platform]

By default, the testing plaform used for efficiency tests is

[variablelist
	[[Processor][__mac_processor__]]
	[[Memory][__mac_mem__]]
	[[OS][__mac_os__]]
	[[Compiler][__mac_default_compiler__]]
	[[Optimization][__mac_optim__]]
]

[endsect][/Testing platform]

[section Portability]

[table
	[
		[ OS]
		[ Compiler ]
		[ Option(s) ]
		[__boost__ version(s)]
		[Result]
		[Log file]
	]
	[
		[ __mac_os__]
		[ __mac_default_compiler__ ]
		[  ]
		[ [^1.41] ]
		[ OK ]
		[ [tpl_unit_testing_log_mac_gcc42 log_mac_gcc42] ]
	][/sudo bjam \"toolset=darwin\" debug release > log_mac_gcc42]
	[
		[ __mac_os__ ]
		[ gcc4.4 (__fink__ ) ]
		[ __cpp0x__ ]
		[ [^1.41] ]
		[ NA ]
		[ NA ]
	][/sudo bjam \"toolset=darwin\" debug release > log_mac_gcc42]
	[
		[ Ubuntu 9.10 ]
		[ gcc4.4 ]
		[ __cpp0x__ ]
		[ [^1.43] ]
		[ NA ]
		[ NA ]
	][/sudo sudo bjam \"toolset=gcc\" debug release ]
]

[endsect][/Portability]

[section Dependencies]

These must be in the search path:

* This [@http://svn.boost.org/svn/boost/sandbox/statistics/support/boost/range/ directory], which contains
copies of files that were previously in the Vault, for chaining, by [tpl_range RangeEx]
* This [@http://svn.boost.org/svn/boost/sandbox/statistics/support/boost/mpl/ directory] containing <boost/mpl/detail/variadic.vector.hpp>

[endsect] [/ Dependencies]

[section Change log]

[section \[Proposal for\] Upgrading from __boost__ v1.4x : __boost_assign_v2__]

[section The new organization]

The new library lives in __local_boost_dir__ and its functionality is defined in this namespace:

``
	using namespace boost::assign::v2;
``

The latest version prior to __boost_assign_v2__ will continue to be supported in __boost__ to allow backward compatibility.

[endsect][/ The new organization]

[section Rationale]

There are two parts to this upgrade:

# Entirely new features, notably [tpl_sec_ref_anon anonymous container of references], and extended (RangeEx) methods for [tpl_sec_chain chaining ranges],
were already the subject of a __boost_assign_v2_mini_review__.
# A complete overhaul of the existing features.

The initial motivation for the overhaul is that thanks to the __boost_assign_v2_mini_review__, it was apparent
that the new and old features lacked homogeneity in their interface and that some newly introduced features, such as `csv` functions (see below), had received sufficient
interest to warrant their generalization throughout the rest of the library. 

Part of the overhaul is simply a repackaging of the old code with an emphasis on code-reuse and decoupling, but a fairly different interface has emerged as a 
result (see below). The other part comes about by exploiting spillovers from some of the new features, [tpl_sec_ref_anon anynomous container of references], to 
the ones we took on to revamp, resulting, notably, in the [tpl_sec_put `_put` adaptor]. In this case, the container of references serves as a cost-efficient buffer on the right
hand side of `operator|`.

[endsect][/ Rationale]

[section The new interface]

We can break down the new structure into at least two components:

# Whereas the user interacted with __boost_assign_v1__ through idiomatic operators (say `+=`), __boost_assign_v2__ only uses two, `operator|` and `operator%`, 
in a way that is consistent across different tools:
	
	* `operator|` expresses composable adaptors, an idea originating with [tpl_range_adaptor range adaptors]. Here, the result is either a 
		(also) different type of range or the container passed as an input, but in a new state. See, for example, the synopsis of [tpl_sec_put_range _put_range]
	* Traits take care of making certain decisions about the implementation. These choices, 
		however, can be overriden by passing parameters with `operator%`. See, for example, the synopsis of the [tpl_sec_put `_put` adaptor]

# Many tools come in two flavors : as a functor that forwards, say, to a constructor, or as functions, identified by suffix `csv`, oveloaded on the number of arguments.
This dichotomy should be quite obvious from looking at the synopsis of, for example, of [tpl_sec_anon anonymous container of values] 

An issue that was touched upon during the __boost_assign_v2_mini_review__ is that of creating an empty container. The custom in 
__boost_assign_v1__ was to reserve the nullary `operator()()` for default constructing a value, for example, `list_of<__value_type__>( __1st_value__ )()( __3rd_value__ )`. 
Some felt, however, that `list_of<__value_type__>()` should return an empty container. To resolve this dilemma,  __boost_assign_v2__ keeps the old convention, 
but creates a new one for expressing the initialization of an empty container. Since `list_of()` is now `anon()`, it is,
``
	anon<__value_type__>( _nil );
``
The same applies to the `csv` form, and [tpl_sec_ref_anon anonymous container of references].

Note that the function `list_of()` was renamed to `anon()` for the following reasons: a) `list_of` evoques a particular data-structure that, in fact, is not the underlying one, 
which is a `std::deque<>`.b) In the previous documentation the result of `list_of` was referred to as an anon-ymous container. The new name is therefore consistent with this practice.


[endsect] [/ The new interface]

[section Code reuse]

The structure of __boost_assign_v1__ is similar to that of __boost_assign_v2__ if one looks at low level. At the high level,
explaining the evolution from one to the other is arduous task so we will only touch on a few items.  

['List inserters] in __boost_assign_v1__, such as the free functions `push_back()`, and `list_of()` now have counterparts, the [tpl_sec_put `put` adaptor] and
`anon()`, respectively, that now share a significant proportion of common code expressed by a __crtp__ class. Already, `anon()` can now work with 
any [tpl_sec_put_std_modifier modifier], whereas previously `push_back()` was the default and only implementation. 

Moreover, modifiers are now defined outside the __crtp__ class, the latter only keeping a (compile time) tag specifying which modifier to forward to. 
This makes it easy to develop new ones, besides the standard ones (e.g. `push_back()`), of course, as they are already defined. One example of a non-standard 
modifier is the modifier [tpl_sec_put_ext_func_repeat `_repeat`].

The second dimension of the new framework is [tpl_sec_put_arg_forwarding argument forwarding], which was already present, for example, as part of `list_of()`. 
What is entirely new, is that a traits mecanism takes care of deciding which modifier-functor pair to use.  As a result, passing a key and data as two arguments 
(as opposed to pairing them first with `std::pair<>`) to a `std::map<>` works seamlessly, as illustrated [tpl_sec_put_arg_forwarding_auto here], 
whereas previously, a dedicated function was needed, `map_list_of()`.

Again, we can override the default choices by passing as many parameters as necessary with `operator%`. A complex example is given [tpl_sec_put_test_knowledge here].

Pointer containers required three seperated implementations, `ptr_list_of()`, `ptr_map_insert()`, and `ptr_map_list_of()` whereas now they are integrated in the new framewok, 
requiring few lines of extra-code to accomodate them, and work seamlessly with the same interface. TODO make sure the old functionality is covered by the new one.

On the topic of [tpl_sec_conversion conversion], the functionality that allowed to convert the result of `list_of()` to an arbitrary container is now a free function. Using it as a standalone is, 
in itself, an advantage, but also, it is now integrated into several objects defined in this library. 

[endsect][/ Code reuse]
	
[endsect][/ Upgrading from __boost__ v1.4x ]

[endsect][/Change log]

[section Support]

For support, post to the __user_mailing_list__, and CC __TO__ and __ER__.

[endsect][/Support]

[section History and acknowledgement]

[section __boost_assign_v1__]

The idea for an assignment/initialization library is not new. The  functionality of this library 
resembles Leor Zolman's STL Container Initialization Library a great deal, but it does not rely on 
string parsing to achieve its goals. 

Special thanks go to 

* Leor Zolman for our many discussion that eventually led to this library.
* Tom Brinkman for being review manager.
* Joaquín Muñoz for vc6/vc7 portability.
* Pavel Vozenilek for his countless suggestions, improvements and  portability fixes. 
* Rene Rivera for Code Warrior portability.     

[endsect]

[section __boost_assign_v2__ ]

* Manuel Peinado Gallego identified the need for an anonymous container of references, and provided
  valuable advice throughout the early development of __boost_assign_v2__, such as proposing a [@http://gist.github.com/287791 design] 
  that laid the foundation for [tpl_sec_chain chaining].

[endsect]

[endsect] [/Ackowledgement]
[section Bibliography]

* Scott. Meyers, "More Effective C++", Item 7, Addison Wesley, 1996       
* K. Czarnecki and U.W. Eisenecker, "Generative programming", Addison-Wesley, 2000        
* [@http://www.oonumerics.org/blitz/ Blitz]
* Gabriel Dos Reis and Bjarne Stroustrup, 
 [@http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1509.pdf Generalized Initializer Lists], 2003
* Abrahams, David and Gurtovoy, Aleksey,
 [@http://portal.acm.org/citation.cfm?id=1044941# 
 C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond (C++ in Depth Series)],
 2004, Addison-Wesley Professional.

[endsect] [/ Bibliography]

[/ ---------------------------------------------------------------------------------------------- ]

[section Reference]

[/xinclude /usr/local/trunk/libs/assign/v2/doc/doxygen/xml/index.xml]
[/xinclude ./doxygen/xml/index.xml]

[endsect]


[endsect][/Dummy]