[library Boost.Assign
    [quickbook 1.5]
    [version 2.0]
    [authors [Thorsten, Ottosen],[Rogard, Erwann]]
    [copyright 2003-2004 Thorsten Ottosen, 2010 Erwann Rogard]
    [dirname /libs/assign/v2/doc/]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [id boost_assign_v2]
]

[/Support]

[def __TO__						[@http://www.boost.org/users/people/thorsten_ottosen.html TO]]
[def __ER__						[@mailto:erDOTciDOT2020ATgmailDOTcom ER]]

[template tpl_user_mailing_list[var]		[@http://www.boost.org/community/groups.html#users [var]]]
[def __user_mailing_list__      			[tpl_user_mailing_list Boost Users Mailing List]]
[def __url_boost_assign_v2_mini_review__ 	[@http://lists.boost.org/Archives/boost/2010/06/168028.php mini-review]]


[/ C++ Standard ]

[def __cpp03__ C++03]
[def __cpp0x__ C++0x]
[template tpl_cpp03[var] [@http://en.wikipedia.org/wiki/C%2B%2B03 [var]]]
[template tpl_cpp0x[var] [@http://www2.research.att.com/~bs/C++0xFAQ.html [var]]]
[def __url_cpp03__ [tpl_cpp03 __cpp03__]]
[def __url_cpp0x__ [tpl_cpp0x __cpp0x__]]

[/ Platform]

[def __mac_os__ OS X 10.6.5]
[def __mac_default_compiler__ gcc4.2]
[def __mac_processor__ 2.4 Ghz Intel Core 2 Duo]
[def __mac_mem__ 4GB 1067 Mhz DDR3]

[def __fink__ Fink]
[template tpl_fink[var] [@http://www.finkproject.org/ [var]]]
[def __url_fink__ [tpl_fink __fink__]]

[/ Libraries ]

[def __boost_assign_v1__ 								Boost.Assign 1.0]
[template tpl_boost_assign_v1[var] 						[@../../../../../libs/assign/doc/index.html [var]]]
[def __url_boost_assign_v1__ 							[tpl_boost_assign_v1 __boost_assign_v1__]]

[def __boost_assign_v2__ 								Boost.Assign 2.0]
[template tpl_boost_assign_v2[var] 						[@./index.html [var]]]
[def __url_boost_assign_v2__ 							[tpl_boost_assign_v2 __boost_assign_v2__]]

[def __boost__											Boost]
[template tpl_boost[var] 								[@http://www.boost.org [var]]]
[def __url_boost__ 										[tpl_boost __boost__]]

[template tpl_boost_array[var] 							[@http://www.boost.org/doc/libs/release/doc/html/array.html [var]]]

[template tpl_mpl[var] 									[@http://www.boost.org/libs/mpl/index.html [var]]]
[def __mpl__ 											[tpl_mpl MPL]]

[template tpl_stl[var] 									[@http://en.wikipedia.org/wiki/Standard_Template_Library [var]]]
[def __stl__ 											[tpl_stl STL]]

[template tpl_stl_assoc[var] 				[@http://www.sgi.com/tech/stl/AssociativeContainer.html [var]]]

[template tpl_stl_seq[var] 					[@http://www.sgi.com/tech/stl/Sequence.html [var]]]

[template tpl_stl_adapter[var]							[@http://flylib.com/books/en/2.674.1.106/1/ [var]]]

[template tpl_lambda[var] 								[@http://www.boost.org/doc/libs/release/doc/html/lambda.html [var]]]
[def __lambda__											[tpl_lambda lambda]]

[template tpl_ptr_container[var] 						[@http://www.boost.org/doc/libs/release/libs/ptr_container/doc/ptr_container.html [var]]]

[template tpl_range[var] 								[@http://www.boost.org/doc/libs/release/libs/range/index.html [var]]]
[template tpl_range_adaptor[var] 						[@http://www.boost.org/doc/libs/1_44_0/libs/range/doc/html/range/reference/adaptors.html [var]]]
[template tpl_range_adaptor_compose[var] 				[@http://www.boost.org/doc/libs/1_44_0/libs/range/doc/html/range/reference/adaptors/introduction.html#range.reference.adaptors.introduction.composition_of_adaptors [var]]]
[template tpl_range_algorithm[var] 						[@http://www.boost.org/doc/libs/1_44_0/libs/range/doc/html/range/reference/algorithms.html [var]]]

[/Concepts]

[template tpl_meta_fun[var] 					[@http://www.boost.org/doc/libs/1_45_0/libs/mpl/doc/refmanual/metafunction.html [var]]]
[template tpl_meta_fun_class[var]				[@http://www.boost.org/doc/libs/1_45_0/libs/mpl/doc/refmanual/metafunction-class.html[var]]]

[/Headers]

[template tpl_boost_trunk [var]										[@http://svn.boost.org/svn/boost/trunk [var]]]
[def __boost_trunk__												[tpl_boost_trunk [^boost-trunk]]]

[template tpl_dir_boost_assign_v2[var] 								[@../../../../../boost/assign/v2 [var]]]
[def __dir_boost_assign_v2__ 										[tpl_dir_boost_assign_v2 boost/assign/v2]]


[template tpl_dir_libs_assign_v2[var] 								[@../../ [var]]]
[def __dir_libs_assign_v2__ 										[tpl_dir_libs_assign_v2 libs/assign/v2]]

[template tpl_dir_libs_assign_v2_example [var] 						[@../../example [var]]]
[def __dir_libs_assign_v2_example__ 								[tpl_dir_libs_assign_v2_example libs/assign/v2/example]]

[/Files]

[template tpl_foo_h[var] [@../../example/foo.h [var]] ] 
[template tpl_foo_cpp[var] [@../../example/foo.cpp [var]] ] 
[template tpl_ex[var] [@../../example/ [var]] ] 

[/Concepts]

[template tpl_concept_range[var] [@http://www.boost.org/doc/libs/1_43_0/libs/range/doc/html/range/concepts.html [var]]]

[template tpl_crtp[var] [@http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern [var]]]
[def __crtp__ [tpl_crtp crtp]]


[/ CodeLinks]

[def __put_param_pair__		pair]
[def __put_modifier__		modifier]

[def __kwd_csv_put__		_csv_put]
[def __kwd_put__			_put]
[def __kwd_lookup__			_lookup]
[def __kwd_repeat__			_repeat]

[def __put_range__			put_range]
[def __put_convert__		put_convert]

[def __foo__				foo]
[def __foo_type__			Foo]

[/ Templates]

[def __type_ext__ _]
[template tpl_join[a b][a][b]]
[template tpl_typeof[object][tpl_join [object]..__type_ext__]]
[template tpl_seq[index first last] [index] = [first], ..., [last]]
[template tpl_sub[var index] [var]\[[index]\] ]
[template tpl_sub_sub[var index1 index2] [var]\[[index1],[index2]\]]

[/ Notation ]

[def __implem_defined__ 		'''<replaceable>implementation-defined</replaceable>''']
[def __put_implem__ 			'''<replaceable>put-implementation</replaceable>''']
[def __custom_par__				'''<replaceable>param</replaceable>''']
[def __custom_par_kwd__			'''<replaceable>param_keyword</replaceable>''']
[def __kwd_custom_par__			'''<replaceable>_param</replaceable>''']
[def __custom_fun__				'''<replaceable>fun</replaceable>''']

[def __container__				cont]
[def __map__					map]
[def __list__					list]
[def __from__					from]
[def __from_type_				From]
[def __to__						to]
[def __to_type__				To]
[def __container_type__			Cont]
[def __container___				[tpl_typeof __container__]]
[def __key__					s]
[def __key_type__				S]
[def __value__					t]
[def __value___					[tpl_typeof __value__]]
[def __value_type__				T]
[def __key_data__				u]
[def __key_data_type__			U]
[def __f__						f]
[def __f___						[tpl_typeof __f__]]
[def __object__					obj]
[def __object___				[tpl_typeof __object__]]
[def __range__					r]
[def __range___					[tpl_typeof __range__]]
[def __array__					ar]
[def __array__					[tpl_typeof __array__]]

[def __kwd_fun__				_fun]
[def __kwd_nil__				_nil]
[def __param__					p]
[def __kwd_param__				_p]
[def __param___					[tpl_typeof __param__]]
[def __param_type__				P]
[def __param_index__			l]
[def __param_count__			m]

[def __kwd_push_back__			_push_back]
[def __kwd_push_front__			_push_front]
[def __kwd_push__				_push]
[def __kwd_insert__				_insert]

[def __kwd_repeat__				_repeat]
[def __kwd_iterate__			_iterate]
[def __kwd_lookup__				_lookup]

[def __kwd_chain__				_chain]

[/Ranges]
[def __r1__						r1]
[def __r1_type__				R1]
[def __r2__						r2]
[def __r2_type__				R2]

[def __1st_value__				x]
[def __2nd_value__				y]
[def __3rd_value__				z]
[def __i__						i] 
[def __n__						n]

[def __arg__ 					arg]
[def __1st_of_arg__ 			a]
[def __2nd_of_arg__ 			b]
[def __3rd_of_arg__ 			c]
[def __j__						j]
[def __k__						k]

[section:intro Introduction]

This library provides a small set of tools for carrying out operations that can be characterized as either putting a set of values in a container, in simple
or complex ways, or manipulating references through a [tpl_concept_range range-like] interface. These are refered to as the [link boost_assign_v2.put ['put]] and [link boost_assign_v2.ref ['ref]]
frameworks, respectively. Each allows to code in one sweep, what would ordinarily require repetitive statements, and integrates nicely with [tpl_range_algorithm range algorithms]. 

[endsect]
[section:qs Quickstart]

To be able to use this library, it is ['necessary] to put the directory containing the __url_boost__ library in the search path of the C++ compiler and 
it ['suffices] to declare
``
	#include <boost/assign/v2.hpp>	
	using namespace boost::assign::v2;
``
in order to bring all the functionality's identifiers into scope. The examples that follow are taken from actual [tpl_ex source files] that conform to 
certain [link boost_assign_v2.conv.ex conventions], notably that `as2` is the alias for the above `namespace`[footnote Why not use unqualified names, given
the above `using` declaration? To make sure the reader is able to distinguish this library's functionality from that of others which also appears in the 
examples.] .

[import ../example/put/pipe.cpp]
A typical [link boost_assign_v2.put ['put]] call is
[map2]
Each call to `__kwd_put__()` executes two steps. The first forwards each set of arguments to the value-type of `cont`, yielding a value that 
we label `__value__`. The second calls `__container__.insert( __value__ )`, as deemed appropriate by the library, for this category of container 
([tpl_stl_assoc Associative]). 

The user may wish to override the library's default choice, which is accomodated by a parameter passing mechanism. Below is an example in which 
`push_front()` is requested for executing the second step:
[list]
The keyword `__kwd_push_front__` is one of several parameters, some of which perform complex tasks, that are available. In addition, this library makes it easy, 
through the use of macros, to extend the repertoire. 

[import ../example/ref/array.cpp]
Framework [link boost_assign_v2.ref ['ref]] provides a generalization of the reference wrapper to an array (like [tpl_boost_array `boost::array<>`], not C-style) e.g.
[csv_array_w]
A tool for forming the union of ranges that caters to the possibility that at least of them is a reference-array is also provided.

[endsect][/ using]
[section:conv Convention]

In this section, we invite the reader to become acquainted with the conventions used in this documentation. They are hopefully intuitive so that the impatient 
reader can alternatively skip them. 

[section:symb Symbols]

[table 
	[[Symbol][Description]]
	[
		[`__container__`]
		[ A container] 
	]
	[
		[`__value__`]
		[ A value ] 
	]
	[	
		[`__arg__`]
		[ Arguments to a function ]
	]
]

To represent the types of the above, we typically use the a capital letter. For example, `__value_type__` is the type of `t`.

[endsect][/symb]
[section:index Indexes]

[table Indexes
	[ 
		[ Expression ] 
		[ Description] 
	]
	[ 
		[ [^[tpl_seq [^__i__]..0..[^__n__]-1]] ] 
		[Indexes a sequence of `__value__`'s] 
	]
	[ 
		[ [^[tpl_seq [^__j__]..0..[^__k__]-1]] ] 
		[Indexes arguments at some [^__i__]] 
	]
	[ 
		[ [^__1st_of_arg__], [^__2nd_of_arg__], [^__3rd_of_arg__] ] 
		[ Aliases for [tpl_sub [^__arg__]..[^0]], [tpl_sub [^__arg__]..[^1]], [tpl_sub [^__arg__]..[^2]], respectively, at some [^__i__]]
	]
	[ 
		[ [^__1st_value__], [^__2nd_value__], [^__3rd_value__] ] 
		[ Aliases for [link boost_assign_v2.conv.symb `__value__`] at [^__i__ = 0, 1, 2], respectively ]
	]
]

[heading Example]

``
	__value_type__ __1st_value__, __2nd_value__( __1st_of_arg__, __2nd_of_arg__ );
``

[endsect][/index]
[section:syn  Synopsis]

In any code snippet under heading [*Synopsis], and more generally those that describe a feature, identifiers in the `namespace` of this library, 
`boost::assign::v2`, are ['not] fully qualified. Another way to say this, is to assume that the code is preceded by the following `using` declaration.
``
	using namespace boost::assign::v2;
``

Code that describes a feature is expressed in terms of [link boost_assign_v2.conv.symb symbols] and [link boost_assign_v2.conv.symb indexes], 
never actual data-types (such as `int`). 

[endsect][/ syn]
[section:ex  Example]

Snippets of code under heading [*Example] are assumed to be preceded by the statement under heading [*Header] appearing in the nearest enclosing 
section (if not the current one, that of the top level etc.). Furthermore, it is assumed that identifiers defined in the `namespace` of this library are 
fully qualified, with following alias as prefix:
``
	namespace as2 = boost::assign::v2;
``
Another alias that appears in examples is 
``
	namespace bl = boost::lambda;
``

Headers or definitions that are not part of this library are not explicitly included in the documentation. They can be found in the sources files of the examples 
located in this [tpl_ex directory]. 

[endsect][/ ex]
[endsect][/ conv]
[section:put Put ]

[heading Header]

[def __header_put__ [@../../../../../boost/assign/v2/put.hpp boost/assign/v2/put.hpp]]

``
	#include <__header_put__>
``

[section:pipe `operator|()` ]

[heading Header]

[def __header_put_pipe__ [@../../../../../boost/assign/v2/put/pipe.hpp boost/assign/v2/put/pipe.hpp]]

``
	#include <__header_put_pipe__>
``

[heading Description]

The semantics of `operator|()`, in this library, emulate those of [tpl_range_adaptor range adaptors] to the extent that they 
are [tpl_range_adaptor_compose composable] and therefore convenient in conjunction with [tpl_range_algorithm  range algorithms]. 
In the context of [tpl_range_adaptor range adaptors], expression
``
	lhs | rhs
``
maps a [tpl_concept_range range], identified by `lhs`, according to specifications encapsulated by `rhs`. In the remainder of this section, 
['unless otherwise stated], the above expression returns a reference to container `lhs`, after modifying its state according to specifications 
embodied by `rhs`.

[section:csv `__kwd_csv_put__`]

[heading Header]

[def __header_put_pipe_csv__ [@../../../../../boost/assign/v2/put.hpp boost/assign/v2/put/pipe/csv.hpp]]

``
	#include <__header_put_pipe_csv__>
``

[heading Synopsis]

[table 
	[ [Expression][ Result ][ Side effect ] ]
	[
		[`__container__ | __kwd_csv_put__( __value__[0], ....,__value__[__n__-1] )`]
		[A reference to `__container__`]
		[Puts `__value__[0]`, ....,`__value__[__n__-1]` in  `__container__`] 
	]
]

[heading Modifier]
[#csv_modifier]
The particular side effect is determined by the `__container__` 's category ([tpl_stl_seq Sequence], [tpl_stl_assoc Associative] etc.),
and can be found under [*Keywords] in [link boost_assign_v2.put.modulo.modifier.std.keys this section]. 

[heading Miscellanea]
[#csv_misc]

In the right hand side of `operator|`, the result of `__kwd_csv_put__()` internally keeps references to its arguments so as to avoid any storage overhead.

[heading Example]

[vector]

[endsect][/ csv]
[section:functor `__kwd_put__`]

[heading Header]

[def __header_put_pipe_functor__ [@../../../../../boost/assign/v2/put.hpp boost/assign/v2/put/pipe/functor.hpp]]

``
	#include <__header_put_pipe_functor__>
``

[heading Introduction]

Consider this example
[map]
Instead of explicitly calling `type()` for each set of arguments, what we'd like, the topic of this section, is to automatically forward to the constructor.

[heading Synopsis]

In terms of our [link boost_assign_v2.conv.index notation], for [^__n__ = 1], 

[table 
	[ [Expression][ Result ][ Side effect ] ]
	[
		[`__container__ | __kwd_put__(__arg__[0], ....,__arg__[__k__]) `]
		[A reference to `__container__`]
		[Forwards to `__value_type__(__arg__[0], ....,__arg__[__k__])` and puts the result in the container.] 
	]
]

The above extends to arbitrary `__n__` as follows:
``
	__container__ | __kwd_put__(__arg__[0][0], ....,__arg__[0][__k__[0]])...(__arg__[__n__-1][0], ....,__arg__[__n__-1][__k__[__n__-1]])
``

[heading Value-type]

The appropriate type, `__value_type__`, is deduced at compile time, from the type of destination 
container, `__container__`. 

[heading Modifier]

See [link csv_modifier comment].

[heading Miscellanea]

See [link csv_misc comment].

[heading Example]

[map2]

[endsect][/functor]

[section:ptr_cont Pointer container]

This section discusses the side effect of [link boost_assign_v2.put.pipe `operator|()`], with a [tpl_ptr_container pointer container] as left-argument. Consider 
this example:
[ptr_vector]
Copies of `__1st_value__`, `__2nd_value__` and `__3rd_value__` are allocated on the heap, and their pointers put into
`cont`, using `push_back()`, in this case. 

[endsect][/ ptr_cont]
[section:range `__put_range__`]

[heading Header]
[def __header_put_pipe_range__ [@../../../../../boost/assign/v2/put.hpp boost/assign/v2/put/pipe/range.hpp]]
``
	#include <__header_put_pipe_range__>
``

[heading Synopsis]

Let `__value__[0]`...`__value__[__n__]` denote the dereferenced values of [tpl_concept_range range] `__range__`.

[table
	[[Expression][Result][Equivalent expression]]
	[
		[``
			__container__ | __put_range__( __range__ );
		``]
		[
			A reference to `__container__`
		]
		[``
			__container__ | __kwd_put__(__value__[0])...(__value__[__n__])
		``]
	]
]

[#put_range_caution]
[caution A [tpl_range_algorithm range algorithm] such as `boost::copy` is preferable, if applicable. This tends to restrict the usefulness of 
`__put_range__` to the case in which `__container__` is an [tpl_stl_adapter adapter].]

[heading Example]

[import ../example/put/range.cpp]
[put_range_queue]

[endsect][/ put_range]
[section:convert `__put_convert__`]

[heading Synopsis]

[table
	[[Expression][Result][ Property ]]
	[
		[``
			__range__ | __put_convert__<__container_type__>();
		``]
		[
			A container of type `__container_type__`
		]
		[
			The result is initialized with the elements of `__range__`
		]
	]
]

[note This is a [tpl_range_adaptor range adaptor]. ]

[heading Example]

[import ../example/put/convert.cpp]
[convert_stack]
[endsect][/put_convert]
[endsect][/op]
[section:deque Deque]

[heading Header]

[def __header_put_deque__ [@../../../../../boost/assign/v2/anon.hpp boost/assign/v2/put/deque.hpp]]

``
	#include <__header_put_deque__>
``

[heading Description]

The functions documented in this section, `csv_deque()` and `deque()` each constructs a container like `std::deque<>` whose interface for putting elements
is shared with that of `__kwd_csv_put__` and `__kwd_csv_put__`, respectively.

[section:csv `csv_deque`]

[import ../example/put/deque.cpp]

[heading Synopsis]

[table 
	[ [Expression][ Result type] ]
	[
		[`csv_deque( __value__[0], ..., __value__[__n__-1] )`]
		[`result_of::deque<__value_type__>::type`]
	]
]

[heading Example]

[csv_deque]

[endsect][/csv]
[section:deque `deque`]

[heading Header]

[def __header_put_deque_functor__ [@../../../../../boost/assign/v2/anon.hpp boost/assign/v2/put/deque/functor.hpp]]

``
	#include <__header_put_deque_functor__>
``

[heading Synopsis]

[table 
	[ [Expression][ Result type ][[^__n__]] ]
	[
		[
			`deque<__value_type__>(__kwd_nil__)`
		][
			`result_of::deque<__value_type__>::type`
		][ 
			[^0] 
		]
	]
	[
		[
			`deque<__value_type__>( __arg__[0][0], ..., __arg__[0][__k__[0]] )`
		][
			`result_of::deque<__value_type__>::type`
		][ 
			[^1] 
		]
	]
]

[heading Example]

[deque]

Find [tpl_foo_h here] the declaration of `Foo`, and  [tpl_foo_cpp here] its definition.

[endsect][/functor]
[endsect][/deque]
[section:modulo `operator%()`]

[heading Convention]

We add to our [link boost_assign_v2.conv conventions] that `__put_implem__` denotes an object returned by keyword such as 
[link boost_assign_v2.put.pipe.csv `__kwd_csv_put__`], and `__kwd_param__` denotes some parameter.

[heading Description]

The [link boost_assign_v2.put put framework] relies on traits of the container to be modified to determine the appropriate implementation. 
This has the advantage that the same and compact interface works across different container categories, whether [tpl_stl_seq Sequence], 
[tpl_stl_assoc Associative] or [tpl_stl_adapter adapters]. To allow the user to override the implementation, however, this library provides a ['composable] parameter passing mechanism. 

[heading Synopsis]

[table 
	[ [Expression][ Result ] ]
	[
		[`__put_implem__ % __kwd_param__`]
		[ An implementation with a new type or state  ]
	]
]

[section:fun `__kwd_fun__`]

[heading Header]

[def __header_put_fun__ [@../../../../../boost/assign/v2/anon.hpp boost/assign/v2/put/generic/new_fun.hpp]]
``
	#include <__header_put_fun__>
``

[heading Synopsis]

[table 
	[ [Expression][ Result ] ]
	[
		[`__put_implem__ % (__kwd_fun__ = __f__)`]
		[Replaces the internal functor of `lhs` by `__f__` ]
	]
]

[heading Example]

[fun]

[endsect][/fun]
[section:modifier Modifier]

[heading Header]

[def __header_put_modifier__ [@../../../../../boost/assign/v2/put.hpp boost/assign/v2/put/modifier.hpp]]

``
	#include <__header_put_modifier__>
``

[heading Description]

This section documents the mechanisms by which a passed value, `__value__`, is put in a container, `__container__`. These mechanisms are of two kinds,
['standard], and ['extended].

[section:std Standard]

[heading Header]

[def __header_put_modifier_std__ [@../../../../../boost/assign/v2/put.hpp boost/assign/v2/put/modifier/std.hpp]]

``
	#include <__header_put_modifier_std__>
``

[heading Description]

A ['standard modifier] is charaterized by an implementation that, given a passed value, `__value__`,  inserts it in the destination container, `__container__`, 
by calling a member function, `__container__.mf( __value__ )`.

[heading Example]

The default standard modifier of `std::list<>` is `push_back()`. In this example, it is changed
to `push_front()`:
[list]
Make sure to keep the statement involving `operator%` in between brackets, as shown above.

[section:keys Keywords]

Here's a catalog of the keywords that control standard modifiers, and the container categories
under which they are the default. 

[table 
	[ [ Keyword ][ Implementation ][ Default ] ]
	[ [ `__kwd_insert__` ][ `__container__.insert( __value__ )` ][ [tpl_stl_assoc Associative] ] ]
	[ [ 
		`__kwd_iterate__` [footnote  This keyword does not agree with our definition of a standard modifier which 
		requires that the element be inserted, not merely assigned. However, it makes sense from a user standpoint to leave 
		that keyword in this table. Also see [link boost_assign_v2.put.modulo.modifier.ext.iterate Extended functionality].
		]
	  ]
	  [ `__container__[ __i__++ ] = __value__ ` ]
	  [ [tpl_boost_array Static arrays] ] 
	]
	[ [ `__kwd_push__` ][ `__container__.push( __value__ )` ][ [tpl_stl_adapter Adapters] ]  ]
	[ [ `__kwd_push_back__` ][ `__container__.push_back( __value__ )` ][ [tpl_stl_seq Sequence] ] ]
	[ [ `__kwd_push_front__` ][ `__container__.push_front( __value__ )` ][ ]  ]
]
where index `__i__` is initialized to zero.  

[endsect][/ keys ]
[section:custom Customization ]

[heading Header]

[def __header_put_modifier_xxx__ [@../../../../../boost/assign/v2/put/modifier/xxx.hpp boost/assign/v2/put/modifier/xxx.hpp]]

``
	#include <__header_put_modifier_xxx__>
``

[heading Synopsis]

[table

	[[Expression][Defines][Implementation]]
	[
		[``
			BOOST_ASSIGN_V2_PUT_MODIFIER_STD_XXX( mf )
		``]
		[``
			__put_implem__ % _mf 
		``]
		[``
			__container__.mf( __value__ )	
		``]
	]
]
where identifier `_mf` is defined in an anonymous namespace nested in `boost::assign::v2`.

[heading Example]
``
	BOOST_ASSIGN_V2_PUT_MODIFIER_STD_XXX(push_back)
``

[endsect][/ custom]
[endsect][/ std ]
[section:ext Extended]

[heading Header]

[def __header_put_modifier_ext__ [@../../../../../boost/assign/v2/put/modifier/ext/lookup.hpp boost/assign/v2/put/modifier/ext.hpp]]
``
	#include <__header_put_modifier_ext__>
``

[heading Description]

An ['extended] modifier is one that is not standard. 

[note Passing such a parameter to an implementation may also affect the forwarding functor i.e. that which maps a set of arguments to the value that 
is to be put in a container.]

[section:iterate `__kwd_iterate__` ]

[heading Header]

[def __header_put_modifier_ext_iterate__ [@../../../../../boost/assign/v2/put/modifier/ext/lookup.hpp boost/assign/v2/put/modifier/ext/iterate.hpp]]

``
	#include <__header_put_modifier_ext_iterate__>
``

[heading Synopsis]

[table 
	[ [ Expression ][ Implementation ] ]
	[ [ `__kwd_iterate__ = __n__` ][ `__container__[ __i__++ ] = __value__` ] ]
]
where `__i__` is initialized to `__n__`.

[heading Example]

[iterate]

[endsect]
[section:repeat `__kwd_repeat__`]

[heading Header]

[def __header_put_modifier_ext_repeat__ [@../../../../../boost/assign/v2/put/modifier/ext/repeat.hpp boost/assign/v2/put/modifier/ext/repeat.hpp]]

``
	#include <__header_put_modifier_ext_repeat__>
``

[heading Synopsis]

[table 
	[ [ Expression ][ Implementation ] ]
	[ [ `_repeat = n` ][ `m = n; while(--m) __implem_defined__` ] ]
]
where `__implem_defined__` is the implementation prior to passing the parameter.

[heading Example]

[repeat]

[endsect]
[section:lookup `__kwd_lookup__` ]

[heading Header]

[def __header_put_modifier_ext_lookup__ [@../../../../../boost/assign/v2/put/modifier/ext/lookup.hpp boost/assign/v2/put/modifier/ext/lookup.hpp]]

``
	#include <__header_put_modifier_ext_lookup__>
``

[heading Synopsis]

[table 
	[ [ Expression ][ Implementation ] ]
	[ [ `__kwd_lookup__ = __f__` ][ `__container__[ __key__ ] = __f__( __container__[ __key__ ] )` ] ]
]

[heading Example]

[lookup]

[endsect]

[section:custom Customization]

[heading Header]

[def __header_put_modifier_ext_xxx__ [@../../../../../boost/assign/v2/put/modifier/ext/xxx.hpp boost/assign/v2/put/modifier/ext/xxx.hpp]]

``
	#include <__header_put_modifier_ext_xxx__>
``

[section Description]

We want to create a keyword `__kwd_custom_par__` such that
``
	__put_implem__ % ( __kwd_custom_par__ = arg )
``
a returns a different (but not necessarily independent) implementation, based on the information in the right-hand-side. 
The macro of this section allows us to do so, given some requirements, the topic of the next section. 

[section:req Requirements]

In the next sub-sections we present the functionality that the user needs to define. They must be within 
`namespace` `boost::assign::v2`.

[heading RHS of `operator%()`]

``
    template<typename Arg>
    struct __custom_par__
    {
    	// Constructor
        __implem_defined__ get()const; 
    };
``

[heading Keyword `class`]
``
    template<typename Arg>
    struct __custom_par_kwd__
    {
    	template<typename Arg>
        __custom_par__<Arg> operator=(Arg const&); 
    };
``

[endsect][/ interface]

[heading Tag ]

``
	namespace modifier_tag{

    	template<typename ...> struct __custom_par__{};

	}
``

[heading Traits ]

``
	namespace put_parameter{

    	template<typename Arg>
    	struct __custom_par__{

            template<typename OldFun, typename OldTag>
            struct apply; // must derive from put_parameter::pair<>

    	};

	}
``

[heading Specialization]

``
	namespace put_aux{

        template<typename...>
        class modifier<modifier_tag::__custom_par__<Tag> >
        {
            public:

            modifier(){}
            explicit modifier(__implem_defined__); 

            template<typename V, typename T>
            void impl(V& v, T& t)const; // puts t in v

            template<typename V, typename T>
            void impl(V& v, T* t)const; // for ptr_container
        };
    	
    }
``
where `__implem_defined__` is the result type of `( __kwd_custom_par__ = arg ).get()`.

[endsect][/ req]
[section:usage Usage]

Expand in `namespace` `boost::assign::v2`,

``
	BOOST_ASSIGN_V2_PUT_MODIFIER_EXT_XXX(__custom_par__)
``

[endsect][/ usage]
[section Example]

# __header_put_modifier_ext_iterate__
# __header_put_modifier_ext_lookup__
# __header_put_modifier_ext_repeat__

[endsect]
[endsect][/ custom]
[endsect][/ ext]
[endsect][/ modifier]
[endsect][/ modulo]
[endsect][/ put]

[section:ref Ref]


[heading Header]

[def __header_ref__ [@../../../../../boost/assign/v2/ref.hpp boost/assign/v2/ref.hpp]]

``
	#include <__header_ref__>
``

[heading Convention]

In addition to the usual [link boost_assign_v2.conv conventions],  the code that follows is assumed to be preceded by
``
	using namespace ref;
``

Furthermore, in terms of our convened [link boost_assign_v2.conv.symb symbols], template argument `U` is either
of `__value_type__` or `__value_type__ const`.

[section:if Interface]

[heading Header]

[def __header_ref_if__ [@../../../../../boost/assign/v2/ref.hpp boost/assign/v2/ref/array/interface.hpp]]

``
	#include <__header_ref_if__>
``

[heading Synopsis]

The interface of the object, which we denote `__array__`, returned by `csv_array()` or `array()` is akin to `std::array<>`, but
it has, in addition, a `rebind()` member function.

[table
	[[Expression][Description]]
	[
		[``
			__array__.rebind( __i__, __value__ )
		``]
		[ Rebinds the `__i__`th reference to `&__value__`]
	]
]

[endsect][/ if]
[section:csv `csv_array`]

[heading Header]

[def __header_ref_csv__ [@../../../../../boost/assign/v2/ref.hpp boost/assign/v2/ref/array/csv.hpp]]

``
	#include <__header_ref_csv__>
``

[heading Synopsis]

[table 
	[ [Expression ][ Result type ]]
	[
		[`csv_array<U>( __kwd_nil__ )`]
		[`nth_result_of::csv_array<0, U>::type`]
	]
	[
		[`csv_array( __value__[0], ..., __value__[__n__-1] )`]
		[`nth_result_of::csv_array<__n__, U>::type`]
	]
]
In the second expression, `U == __value_type__ const` if and only if `__value__[__i__]` is passed 
as a `const` lvalue or an `rvalue`,  for at least one `__i__`, and `U == __value_type__` otherwise.

[heading Example]

[csv_array_w]

[endsect][/ csv_array]
[section:array `array`]

[heading Header]

[def __header_ref_functor__ [@../../../../../boost/assign/v2/ref.hpp boost/assign/v2/ref/array/functor.hpp]]

``
	#include <__header_ref_functor__>
``

[heading Synopsis]

[table 
	[ [Expression ][ Result type] ]
	[
		[`array( __kwd_nil__ )`]
		[`nth_result_of::array<0, U>::type`]
	]
	[
		[`array( __value__[0]) ...(__value__[__n__-1] )`]
		[`nth_result_of::csv_array<__n__, U>::type`]
	]
]
The determination of `U` for the second expression is identical to that for
[link boost_assign_v2.ref.csv.synopsis `csv_array()`].

[heading Example]

[array_r]

[endsect][/ array]
[endsect][/ ref]


[section:chain Adaptor `__kwd_chain__`]

[heading Header]

[def __header_chain__ [@../../../../../boost/assign/v2/chain.hpp boost/assign/v2/chain.hpp]]

``
	#include <__header_chain__>
``

[heading Description]

Adaptor `_chain` is an outgrowth of a similar functionality that appeared in the beta version of 
[tpl_range Boost.RangeEx] that maps two ranges into their union, and is composable.

It also has the special property that it is lvalue preserving : two chained ranges, either of which is 
passed as an rvalue, but both of which hold lvalues, is a range whose references are lvalues. Such
an instance occurs if the rvalue is n [link boost_assign_v2.ref reference-array] of lvalues.

[heading Synopsis]

[table 
	[ [Expression][ Result type ] ]
	[
		[`__r1__ | __kwd_chain__( __r2__ )`]
		[`result_of::chain<__r1_type__,__r2_type__>::type`]
	]
]

[heading Example]

[import ../example/chain.cpp]
In access mode,
[chain_r]

In write mode, thanks to the lvalue preserving property:
[chain_w]

[endsect][/ chain]
[section:arity Configuring arity]

[heading Header]

[def __header_arity__ [@../../../../../boost/assign/v2/chain.hpp boost/assign/v2/detail/config/arity.hpp]]
``
	#include <__header_arity__>
``

[heading Synopsis]

Below are overridable constants's identifier, default value, and the [link boost_assign_v2.conv.index index] that they control. 

[table
	[[ Constant ][ Default value ][ Index ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_CSV_ARITY`][20][ __n__ ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_LVALUE_CONST_ARITY`][2][ __k__ ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_ARITY`][ `BOOST_MPL_LIMIT_METAFUNCTION_ARITY`][ __k__ ]]
]

[Note  Applies to __url_cpp03__, not __url_cpp0x__ ]

[heading Comments]

The first constant is the limit arity for
``
	__kwd_csv_put__( __value__[0], ..., __value__[__n__-1]);
``
and similar functions. The second and third constants apply only to the functor form:
``
	__kwd_put__( __arg__[0][0], ..., __arg__[0][__k__[0]])...( __arg__[__n__-1][0], ..., __arg__[__n__-1][__k__[__n__-1]]);
``
The second constant is the limit for arity `__k__[__i__]` under which any combination of lvalue and rvalue arguments is preserved, for any given `__i__` 
in `[0,...,__n__)`. Beyond this limit, arguments are treated as either all lvalues or all const-lvalues. The third constant is the total limit for arity 
`__k__[__i__]`.

[endsect][/ arity]
[section:apx Appendix]
[section:portability Portability]

[def __ubuntu__ Ubuntu 10.04]
[def __log_mac_gcc42__ 			[@../../test/unit_testing/log_mac_gcc42 log_mac_gcc42] ] 
[def __log_ubuntu_gcc44__ 		[@../../test/unit_testing/log_ubuntu_gcc44 log_ubuntu_gcc44] ]
[def __log_ubuntu_gcc440x__ 	[@../../test/unit_testing/log_ubuntu_gcc440x log_ubuntu_gcc440x] ]
[def __num_tests__				[^32]]
[def __boost_version__			[^__boost_trunk__] as of 11/2010]

[table
	[
		[ OS]
		[ Compiler ]
		[ Option(s) ]
		[__url_boost__ version(s)]
		[ Success rate ]
		[ Date ]
	]
	[
		[ __mac_os__]
		[ __mac_default_compiler__ ]
		[  ]
		[ __boost_version__ ]
		[ NA ]
		[ NA ] 
		[/
			VAR='date \"+%D\"'
			echo $VAR> log_mac_gcc_42
	    	sudo bjam \"toolset=darwin\" >> log_mac_gcc42
		]	
	]
	[
		[ __mac_os__]
		[ gcc4.4 (__url_fink__ ) ]
		[ __cpp0x__ ]
		[ __boost_version__ ]
		[ [^100%], it looks like... ]
		[ [^01/2011] ]
	]
	[
		[ __ubuntu__ ]
		[ gcc4.4 ]
		[  ]
		[ __boost_version__ ]
		[ [^100%] ]
		[ [^01/2011] ]
		[/
			VAR=`date "+%D"`
			echo $VAR> log_ubuntu_44
	    	sudo bjam "toolset=gcc" debug release >> log_mac_gcc44
		]	
	]
	[
		[ __ubuntu__ ]
		[ gcc4.4 ]
		[ __cpp0x__ ]
		[ __boost_version__ ]
		[ NA[footnote By running the test suite with ['bjam], otherwise [^32/32]... ] ]
		[ NA ]
		[/	
			VAR=`date "+%D"`
			echo $VAR> log_ubuntu_44_0x
			sudo sudo bjam "toolset=gcc" cxxflags=-std=c++0x >> log_mac_gcc44_0x 
		]
	]
]

[endsect][/Portability]

[section:change_log Change log]

[section:v2 \[Proposal for\] Upgrading from __boost__ v1.4x : __boost_assign_v2__]

[heading Organization]

For backward compatibility and to permit a smooth transition for users that are familiar with __url_boost_assign_v1__, the latter will continue to be supported. 
The two versions, in fact, can be used in the same project as their interfaces don't clash. A good place to form an impression about the upgrade is in
section [link boost_assign_v2.qs quick start]. To compare (non-exhaustively) the two versions, see section [link boost_assign_v2.apx.run_eff Runtime efficiency].

[heading Ref-framework]

A revision to `ref_list_of<>()` and the addition of a tool for [link boost_assign_v2.chain chaining] were the subject of a 
__url_boost_assign_v2_mini_review__, and carry through to __url_boost_assign_v2__. 

The first of these proposed changes was to eliminate the redundant template parameter of generating function `ref_list_of<>()`, the size of the desired result,
and deduce it, instead, as the number of arguments. It also fitted the returned container with [tpl_boost_array boost::array<>]'s richer functionality. Finally, a type of 
function, termed ['csv], was introduced, as a more elegant alternative (but not a replacement) to multiple calls to a functor. [#change_log_chain] The second feature, chaining, served as an alternative to a container-of-references' member function `range()`.  

Since the __url_boost_assign_v2_mini_review__, the proposal has been further improved. For instance, the dual interface, `ref_list_of()` and `cref_list_of()` is 
replaced by a single function, `ref::array()`, that resolves lvalue/const-ness automatically, and likewise for chaining. Also, the latter now preserves the 
lvalue-ness of the chained ranges' elements, even if either of the input ranges is passed as an rvalue, as may be the case with a container of references.

[heading Miscellanea]

During the same __url_boost_assign_v2_mini_review__, it became apparent that the existing and proposed features lacked homogeneity in their interface, and that the
relevance of the proposed one was insufficiently outlined in the documentation. Conversely, some newly introduced features, such as the already mentioned 
['csv] functions, had received enough interest to warrant their generalization throughout the rest of the library. Another consensus was the request for exploiting 
__url_cpp0x__'s features. Incidentally, some confusion was voiced as to whether a nullary call to some container generator, fun(), is supposed to return a container
that is empty or one that contains a default constructed value. __url_boost_assign_v2__ adresses these requests. 

The solution to the `fun()` problem, adopted in __url_boost_assign_v2__, is to keep __url_boost_assign_v1__'s convention that `fun()` creates a default value, 
but, in addition, `fun(__kwd_nil__)` returns an empty container. As for __url_cpp0x__, functions are variadic and preserve the lvalue/const-ness of their 
arguments. Under __url_cpp03__, these aspects are controlled by [link boost_assign_v2.arity overridable constants] (macros).

[heading Put-framework]

The inception of this framework began as a result of some of the comments under heading [*Miscellanea].

A defining feature of the interface is [link boost_assign_v2.put.pipe `operator|()`], which emulates [tpl_range_adaptor range-adaptors]. The key to efficiency is to hold arguments on the right 
hand side of  `operator|` as references, a spillover from the work done in the [link boost_assign_v2.ref ref-framework]. The other operator that was
introduced is [link boost_assign_v2.put.modulo `operator%`], for selectively overriding the default implementation. 

In terms of code-reuse, while `list_of()` and the ['list inserters] (e.g. `push_back()`) are, under __url_boost_assign_v1__, independently implemented, their 
counterparts, under __url_boost_assign_v2__, [link boost_assign_v2.put.deque `deque()`][footnote The analog __url_boost_assign_v1__'s `list_of()` is, 
in __url_boost_assign_v2__, renamed `deque()`. This is because  `list_of` evokes a particular data-structure  (forward traversal) that is different from the actual 
underlying one, `std::deque<>` (random access).] and [link boost_assign_v2.put `__kwd_put__`], respectively, derive from a common __crtp__ `class`. Thanks to this integrated approach, containers such as `std::map<>` or [tpl_ptr_container pointer containers] fit into the framework without the need for (major)
adjustments. The implementation is more open to customization, a task that is facilitated by macros. See  [link boost_assign_v2.put.modulo.modifier.std.custom here] and [link boost_assign_v2.put.modulo.modifier.ext.custom here]. 

Finally, functions `range<>()` and `convert<>()` that in  __url_boost_assign_v1__ are  members of objects, are now standalone keywords 
[link boost_assign_v2.put.pipe.range `put_range()`] and  [link boost_assign_v2.put.pipe.convert `put_convert<>()`], respectively, in the rhs of
[link boost_assign_v2.put.pipe `operator|()`]. 

[endsect][/ v2 ]
[endsect][/log]

[section:help Getting help]

To get help or make a suggestion, post to the __user_mailing_list__, but also make sure to notify 
__TO__ and __ER__ by cc-ing them.

[endsect][/Getting help]

[section:hist History and acknowledgement]

[heading __boost_assign_v1__]

The idea for an assignment/initialization library is not new. The  functionality of this library 
resembles Leor Zolman's STL Container Initialization Library a great deal, but it does not rely on 
string parsing to achieve its goals. 

Special thanks go to 

* Leor Zolman for our many discussion that eventually led to this library.
* Tom Brinkman for being review manager.
* Joaquín Muñoz for vc6/vc7 portability.
* Pavel Vozenilek for his countless suggestions, improvements and  portability fixes. 
* Rene Rivera for Code Warrior portability.     

[heading __boost_assign_v2__ ]

* Manuel Peinado Gallego identified the need for a (revised) [link boost_assign_v2.ref ref-framework], and provided
  valuable advice throughout the early development of __boost_assign_v2__, such as proposing a [@http://gist.github.com/287791 design] 
  that laid the foundation for [link boost_assign_v2.chain chaining].
* __TO__ and John Bytheway have shaped this new version of the library and its documentation, through their feedback as review managers of 
__url_boost_assign_v2_mini_review__, and the main review, respectively. 

[endsect] [/Ackowledgement]

[section:bibl Bibliography]

* Scott. Meyers, "More Effective C++", Item 7, Addison Wesley, 1996       
* K. Czarnecki and U.W. Eisenecker, "Generative programming", Addison-Wesley, 2000        
* [@http://www.oonumerics.org/blitz/ Blitz]
* Gabriel Dos Reis and Bjarne Stroustrup, 
 [@http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1509.pdf Generalized Initializer Lists], 2003
* Abrahams, David and Gurtovoy, Aleksey,
 [@http://portal.acm.org/citation.cfm?id=1044941# C++ Template Metaprogramming]: Concepts, Tools, and Techniques from Boost and Beyond (C++ in Depth Series),
 2004, Addison-Wesley Professional.

[endsect][/ Bibliography]
[endsect][/apx]
[/xinclude ref.xml]
