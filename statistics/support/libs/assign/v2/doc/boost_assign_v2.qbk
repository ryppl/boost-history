[library Boost.Assign
    [quickbook 1.5]
    [version 2.0]
    [authors [Thorsten, Ottosen],[Rogard, Erwann]]
    [copyright 2003-2004 Thorsten Ottosen, 2010 Erwann Rogard]
    [dirname /libs/assign/v2/doc/]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [id boost_assign_v2]
]

[/Support]

[def __TO__						[@http://www.boost.org/users/people/thorsten_ottosen.html TO]]
[def __ER__						[@mailto:erDOTciDOT2020ATgmailDOTcom ER]]

[template tpl_user_mailing_list[var]		[@http://www.boost.org/community/groups.html#users [var]]]
[def __user_mailing_list__      			[tpl_user_mailing_list Boost Users Mailing List]]
[def __url_boost_assign_v2_mini_review__ 	[@http://lists.boost.org/Archives/boost/2010/06/168028.php mini-review]]


[/ C++ Standard ]

[def __cpp03__ C++03]
[def __cpp0x__ C++0x]
[template tpl_cpp03[var] [@http://en.wikipedia.org/wiki/C%2B%2B03 [var]]]
[template tpl_cpp0x[var] [@http://www2.research.att.com/~bs/C++0xFAQ.html [var]]]
[def __url_cpp03__ [tpl_cpp03 __cpp03__]]
[def __url_cpp0x__ [tpl_cpp0x __cpp0x__]]

[/ Platform]

[def __mac_os__ OS X 10.6.5]
[def __mac_default_compiler__ gcc4.2]
[def __mac_processor__ 2.4 Ghz Intel Core 2 Duo]
[def __mac_mem__ 4GB 1067 Mhz DDR3]

[def __fink__ Fink]
[template tpl_fink[var] [@http://www.finkproject.org/ [var]]]
[def __url_fink__ [tpl_fink __fink__]]

[/ Libraries ]

[def __boost_assign_v1__ 								Boost.Assign 1.0]
[template tpl_boost_assign_v1[var] 						[@../../../../../libs/assign/doc/index.html [var]]]
[def __url_boost_assign_v1__ 							[tpl_boost_assign_v1 __boost_assign_v1__]]

[def __boost_assign_v2__ 								Boost.Assign 2.0]
[template tpl_boost_assign_v2[var] 						[@./index.html [var]]]
[def __url_boost_assign_v2__ 							[tpl_boost_assign_v2 __boost_assign_v2__]]

[def __boost__											Boost]
[template tpl_boost[var] 								[@http://www.boost.org [var]]]
[def __url_boost__ 										[tpl_boost __boost__]]

[template tpl_boost_array[var] 							[@http://www.boost.org/doc/libs/release/doc/html/array.html [var]]]

[template tpl_mpl[var] 									[@http://www.boost.org/libs/mpl/index.html [var]]]
[def __mpl__ 											[tpl_mpl MPL]]

[template tpl_stl[var] 									[@http://en.wikipedia.org/wiki/Standard_Template_Library [var]]]
[def __stl__ 											[tpl_stl STL]]

[template tpl_stl_associative_cont[var] 				[@http://www.sgi.com/tech/stl/AssociativeContainer.html [var]]]

[template tpl_stl_sequence_cont[var] 					[@http://www.sgi.com/tech/stl/Sequence.html [var]]]

[template tpl_stl_adapter[var]							[@http://flylib.com/books/en/2.674.1.106/1/ [var]]]

[template tpl_lambda[var] 								[@http://www.boost.org/doc/libs/release/doc/html/lambda.html [var]]]
[def __lambda__											[tpl_lambda lambda]]

[template tpl_ptr_container[var] 						[@http://www.boost.org/doc/libs/release/libs/ptr_container/doc/ptr_container.html [var]]]

[template tpl_range[var] 								[@http://www.boost.org/doc/libs/release/libs/range/index.html [var]]]
[template tpl_range_adaptor[var] 						[@http://www.boost.org/doc/libs/1_44_0/libs/range/doc/html/range/reference/adaptors.html [var]]]
[template tpl_range_adaptor_compose[var] 				[@http://www.boost.org/doc/libs/1_44_0/libs/range/doc/html/range/reference/adaptors/introduction.html#range.reference.adaptors.introduction.composition_of_adaptors [var]]]
[template tpl_range_algorithm[var] 						[@http://www.boost.org/doc/libs/1_44_0/libs/range/doc/html/range/reference/algorithms.html [var]]]

[/Concepts]

[template tpl_concept_meta_fun[var] 					[@http://www.boost.org/doc/libs/1_45_0/libs/mpl/doc/refmanual/metafunction.html [var]]]

[/Headers]

[template tpl_boost_trunk [var]										[@http://svn.boost.org/svn/boost/trunk [var]]]
[def __boost_trunk__												[tpl_boost_trunk [^boost-trunk]]]

[template tpl_dir_boost_assign_v2[var] 								[@../../../../../boost/assign/v2 [var]]]
[def __dir_boost_assign_v2__ 										[tpl_dir_boost_assign_v2 boost/assign/v2]]


[template tpl_dir_libs_assign_v2[var] 								[@../../ [var]]]
[def __dir_libs_assign_v2__ 										[tpl_dir_libs_assign_v2 libs/assign/v2]]

[template tpl_dir_libs_assign_v2_example [var] 						[@../../example [var]]]
[def __dir_libs_assign_v2_example__ 								[tpl_dir_libs_assign_v2_example libs/assign/v2/example]]

[/Files]

[template tpl_foo_h[var] [@../../example/foo.h [var]] ] 
[template tpl_foo_cpp[var] [@../../example/foo.cpp [var]] ] 


[/Concepts]

[template tpl_concept_range[var] [@http://www.boost.org/doc/libs/1_43_0/libs/range/doc/html/range/concepts.html [var]]]

[template tpl_crtp[var] [@http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern [var]]]
[def __crtp__ [tpl_crtp crtp]]

[/Internal]


[/ CodeLinks]

[def __macro_put_ext_xxx__ 	BOOST_ASSIGN_V2_PUT_MODIFIER_EXT_XXX]
[def __put_param_pair__		pair]
[def __put_modifier__		modifier]

[def __kwd_csv_put__		_csv_put]
[def __kwd_put__			_put]
[def __kwd_incr_lookup__	_incr_lookup]
[def __kwd_repeat__			_repeat]

[def __put_range__			put_range]
[def __put_convert__		put_convert]

[/ Templates]

[def __type_ext__ _]
[template tpl_join[a b][a][b]]
[template tpl_typeof[object][tpl_join [object]..__type_ext__]]
[template tpl_seq[index first last] [index] = [first], ..., [last]]
[template tpl_sub[var index] [var]\[[index]\] ]
[template tpl_sub_sub[var index1 index2] [var]\[[index1],[index2]\]]

[/ Notation ]

[def __implem_defined__ 		'''<replaceable>implementation-defined</replaceable>''']
[def __custom_parameter__		'''<replaceable>param</replaceable>''']
[def __custom_fun__				'''<replaceable>fun</replaceable>''']
[def __custom_kwd_parameter__	'''<replaceable>_param</replaceable>''']

[def __container__				cont]
[def __map__					map]
[def __list__					list]
[def __from__					from]
[def __from_type_				From]
[def __to__						to]
[def __to_type__				To]
[def __container_type__			Cont]
[def __container___				[tpl_typeof __container__]]
[def __key__					s]
[def __key_type__				S]
[def __value__					t]
[def __value___					[tpl_typeof __value__]]
[def __value_type__				T]
[def __key_data__				u]
[def __key_data_type__			U]
[def __f__						f]
[def __f___						[tpl_typeof __f__]]
[def __object__					obj]
[def __object___				[tpl_typeof __object__]]
[def __range__					r]
[def __range___					[tpl_typeof __range__]]

[def __kwd_fun__				_fun]
[def __kwd_nil__				_nil]
[def __param__					p]
[def __kwd_param__				_p]
[def __param___					[tpl_typeof __param__]]
[def __param_type__				P]
[def __param_index__			l]
[def __param_count__			m]

[def __kwd_push_front__			_push_front]

[/Ranges]
[def __r1__						r1]
[def __r1_type__				R1]
[def __r2__						r2]
[def __r2_type__				R2]

[def __1st_value__				x]
[def __2nd_value__				y]
[def __3rd_value__				z]
[def __i__						i] 
[def __n__						n]

[def __arg__ 					arg]
[def __1st_of_arg__ 			a]
[def __2nd_of_arg__ 			b]
[def __3rd_of_arg__ 			c]
[def __j__						j]
[def __k__						k]


[section:preface Preface]

This library provides a small set of tools for carrying out operations that can be characterized as taking a set of elements, 
and putting them in a container. It allows to code in one sweep, what would ordinarily require repetitive statements. 
More specifically, the destination container can be modified in place through adaptors 
[footnote A concept borrowed from [tpl_range_adaptor range adaptors]. Strictly speaking, the object in the right hand side of `operator|` is 
an ['adaptor generator], but we take the liberty to call it by its shorthand, ['adaptor].], and, for instance, passed to a
[tpl_range_algorithm range algorithm]:
[#preface_csv_put]
``
	boost::copy( 
		__container__ | adaptor::__kwd_csv_put__(__1st_value__, __2nd_value__, __3rd_value__), 
		std::ostream_iterator<__value_type__>(std::cout," ")
	);
``
The variable aspect of the implementation defaults to one that is deduced from the container's properties, so that the interface is uniform
across container categories, such as, in the snippet that follows, an [tpl_stl_associative_cont associative container],
[#preface_map]
``
	__map__ | adaptor::__kwd_put__("x", __1st_value__)("y", __2nd_value__)("z", __3rd_value__);
``
Alternatively, the user can selectively specify his/her choice of implementation using a parameter 
passing mechanism: 
[#preface_list]
``
	__list__ | ( adaptor::__kwd_put__ % ( __kwd_fun__ = __f__ ) % __kwd_push_front__ )( __1st_of_arg__, __2nd_of_arg__ )()( __3rd_value__ );
``
The library supports adding custom parameters, the development of which is facilitated by macros. 

While typical clients of the above involve  __stl__ containers, the library also caters to [tpl_boost_array boost::array<>] and 
[tpl_ptr_container pointer containers]. In addition, this library defines two anonymous containers[footnote By that we mean constructible in place], one of 
values and the other of references[footnote It can be thought of as the extension of a reference wrapper to a static array.]. The latter is particularly relevant if the elements are expensive
to copy, for modifying them using a [tpl_range_algorithm range algorithm], or simply assigning them a common value:
[#preface_ref]
``		
		ref::assign_copy::csv_anon(__1st_value__, __2nd_value__, __3rd_value__).assign( __value_type__( __1st_of_arg__, __2nd_of_arg__ ) );
``

Finally, an adaptor for forming the union of ranges, in a way that that exploits the particular properties of our anonymous container of references, 
if needed, is provided.

[endsect][/Preface]

[section:ug User's guide]

[section:start Getting started]

The library's file are in the directory structure rooted at __dir_boost_assign_v2__. To be able to use all of the library's functionality,
except macros,
``
	#include <boost/assign/v2.hpp>
	using namespace boost::assign::v2;
``
To use only a subset of it, find the relevant section in the [link boost_assign_v2.ug user's guide] and include only the associated header.

[tip Check [link boost_assign_v2.ug.apx.portability portability], and if necessary ask for [link boost_assign_v2.ug.apx.help help]. ]

[endsect]

[section:notation Notation]

[table Symbols
	[[Symbol][Description]]
	[
		[`__container__`]
		[ A container] 
	]
	[
		[`__key__`]
		[ A key ] 
	]
	[
		[`__value__`]
		[ A data ] 
	]
	[
		[`__key_data__`]
		[ A key data pair ] 
	]
	[	
		[`__arg__`]
		[ An argument to a function ]
	]
	[	
		[`__object__`]
		[ An object defined in this library ]
	]
	[
		[`__kwd_param__`]
		[ A keyword parameter ]
	]
]

To represent the types of the above, we typically use the a capital letter. For example, `__value_type__` is the type of `t`.

[/
	[
		[`__f__`]
		[ A function ]
	]
]

[table Indexes
	[ 
		[ Expression ] 
		[ Description] 
	]
	[ 
		[ [^[tpl_seq [^__i__]..0..[^__n__]-1]] ] 
		[Indexes a sequences of `__value__`'s] 
	]
	[ 
		[ [^[tpl_seq [^__j__]..0..[^__k__]-1]] ] 
		[Indexes arguments associated with a `__value__` ] 
	]
	[ 
		[ [^[tpl_sub [^__k__]..[^__i__]]] ] 
		[Number of function arguments at [^__i__] ]
	]
	[ 
		[ [^[tpl_sub `__arg__`..[^__i__]]] ] 
		[ Set of arguments at [^__i__] ]
	]
	[ 
		[ [^[tpl_sub_sub `__arg__`..[^__i__]..[^__j__]]] ] 
		[[^__j__] th argument at [^__i__] ]
	]
	[ 
		[ [tpl_sub [^__1st_of_arg__]..[^__i__]], [tpl_sub [^__2nd_of_arg__]..[^__i__]], [tpl_sub [^__3rd_of_arg__]..[^__i__]] etc.] 
		[ Shorthand for [tpl_sub_sub [^__arg__]..[^__i__]..[^0]], [tpl_sub_sub [^__arg__]..[^__i__]..[^1]], [tpl_sub_sub [^__arg__]..[^__i__]..[^2]] etc.]
	]
	[ 
		[ [^[tpl_seq [^__param_index__]..0..[^__param_count__]-1]] ] 
		[Indexes a sequences of `__kwd_param__`'s] 
	]
]

[endsect][/Notation]

[def __notation_reminder__ This section relies on notational conventions laid out in section [link boost_assign_v2.ug.notation Notation].]

[section:example_background Examples' background]

__notation_reminder__

[heading Sources files]

Almost all the examples in this documentation can be compiled and executed. Their source files are 
located in __dir_libs_assign_v2_example__. 

[heading Include files]

In addition to the statements in section [link boost_assign_v2.ug.start Getting started], assumed throughout is the following set of 
`#include <>` statements.

[import ../example/include.h]
[include_statements]

Those of the particular containers that will be encountered are ommitted, but they can be found in the aforementioned source files.

[heading Data-type `foo`]

[import ../example/foo.h]

For most of our examples, we will assume that our value-type, `__value_type__`, is a particular 
data-structure, `foo`. We also need a few more types for working with [tpl_stl_associative_cont associative containers]. 
Altogether, we have:
[foo_types]

Class `foo` has a number of characteristics thanks to which, by appealing to deduction,  a broad range 
of programming needs, including the basic ones, are covered. A basic need would be filling a container
with `int`s. One that is at the complexity  boundary allowed by our framework, would be working with 
a collection of `boost::tuple`s of references. 

Here's  `foo` and related classes' declaration:
[foo]

Additional detail can be found in [tpl_foo_h foo.h], and [tpl_foo_cpp foo.cpp].

[heading Constants]

[import ../example/constants.h]
[foo_constants]

In terms of our [link boost_assign_v2.ug.notation notation], by seeing `__1st_value__`, `__2nd_value__`, 
and `__3rd_value__` as forming a sequence, `__n__ = 3`, `__k__[0] = 1`, `__k__[1] = 0`, and `__k__[2] = 2`. 

[endsect][/Examples' background]

[def __ex_background_reminder__ Examples of this section assume preceding code laid out in section 
[link boost_assign_v2.ug.example_background Examples' background].]

[def __reminder__ __notation_reminder__ __ex_background_reminder__]

[section:put Put ]

__reminder__

[heading Header]

[def __header_put__ [@../../../../../boost/assign/v2/put.hpp boost/assign/v2/put.hpp]]

Unless explicitly specified, the relevant header, throughout this section, is

``
	#include <__header_put__>
``

[section:usage Basic usage]

[heading Synopsis]

[table 
	[ [Expression][ Result ][ Side effect ] ]
	[
		[`__container__ | adaptor::__kwd_csv_put__( __value__[0], ....,__value__[__n__-1] )`]
		[A reference to `__container__`]
		[Puts the elements in  `__container__`] 
	]
]

Operator `operator|` in conjunction with a keyword defined in `namespace` `adaptor`, is an idiom,
['adaptor], that is borrowed from [tpl_range_adaptor range adaptors]. In particular, they
are [tpl_range_adaptor_compose composable]. For our purpose, however, an adaptor modifies the state of a 
container before returning it.

In the right hand side of `operator|`, the result of `__kwd_csv_put__()` internally keeps references
to its arguments so as to avoid any storage overhead.

[heading Example]

To put elements, `__1st_value__`, `__2nd_value__` and `__3rd_value__` into a container, and print them,
[#example_put_basic_usage]
[import ../example/put_adaptor.cpp]
[vector]

The statement inside the first argument of `boost::for_each` is equivalent, for this particular 
container type, to
``
	__container__.push_back( __1st_value__ );
	__container__.push_back( __2nd_value__ );
	__container__.push_back( __3rd_value__ );
``
and returns a reference to `cont`.   

[endsect][/ Basic usage]

[section:std_modifier Standard modifier]

A container has one or more member functions to alter its state. In this library, we concern ourselves 
only with inserting elements, and designate the relevant interface a ['standard modifier]. 

[section:auto Automatic deduction]

In the [link example_put_basic_usage example] illustrating [link boost_assign_v2.ug.put.usage basic usage]
we encountered a [tpl_stl_sequence_cont sequence container], `std::vector<>`, but the same adaptor 
works seamlessly with [tpl_stl_associative_cont associative] and [tpl_stl_adapter adapter] [footnote At least 
`std::stack<>` and `std::queue<>`] __stl__ containers, and the static array [tpl_boost_array `boost::array<>`]. 

The mechanism that permits this uniform interface across varied container types is the selection, 
at compile time, of an appropriate standard modifier based on the destination container's traits. 
In this example,
[#example_put_auto_map]
[map]
the library determines that it is appropriate to forward to `__container__.insert()`.

The repetition of `key_data_()` is not very elegant. There is a better solution, but it would be 
outside of the topic of this section and therefore it will be shown in a subsequent 
[link boost_assign_v2.ug.put.arg_forward.auto section]. 

[endsect][/ Automatic deduction]

[section:user User specified]

Rather than leaving the library to [link boost_assign_v2.ug.put.std_modifier.auto automatically deduce] 
a standard modifier at compile time, the user can specify it explicitly by passing a keyword ['parameter], 
`__kwd_param__`, with `operator%`. 

[heading Synopsis]

[table 
	[ [Expression][ Result ] ]
	[
		[`adaptor::__kwd_csv_put__ % __kwd_param__`]
		[An adaptor whose standard modifier has a different type and/or state ]
	]
]

[heading Parameters]

Here's a catalog of the keywords that control standard modifiers, and the container categories
under which they are the default. 

[table 
	[ [ Keyword ][ Implementation ][ Default ] ]
	[ [ `_push_back` ][ `__container__.push_back( __value__ )` ][ [tpl_stl_sequence_cont Sequence] ] ]
	[ [ `_push_front` ][ `__container__.push_front( __value__ )` ][ ]  ]
	[ [ `_push` ][ `__container__.push( __value__ )` ][ [tpl_stl_adapter Adapters] ]  ]
	[ [ `_at_next` ][ `__container__[ __i__++ ] = __value__ ` ][ [tpl_boost_array Static arrays] ] ]
	[ [ `_insert` ][ `__container__.insert( __value__ )` ][ [tpl_stl_associative_cont Associative] ] ]
]
where index `__i__` is initialized to zero.

[heading Example]

The default standard modifier of `std::list<>` is `push_back()`. In this example, it is changed
to `push_front()`:
[list]
Make sure to keep the statement involving `operator%` in between brackets, as shown above.

[endsect][/ User specified ]

[section:custom Customization ]

[heading Header]

[def __header_put_modifier_xxx__ [@../../../../../boost/assign/v2/put/modifier/xxx.hpp boost/assign/v2/put/modifier/xxx.hpp]]

``
	#include <__header_put_modifier_xxx__>
``

[heading Usage]

Suppose the user has defined his/her own container and that `baz()` is a member function for
putting an element in it:
``
	struct bar{ void baz(int); };
``
Expanding
``
	BOOST_ASSIGN_V2_PUT_MODIFIER_XXX(baz)
``
creates a keyword `_baz`, such that the following statement
``
	bar __container__;
	__container__ | (__kwd_csv_put__ % _baz)( __1st_value__, __2nd_value__, __3rd_value__ );	
``
forwards each of `__1st_value__`, `__2nd_value__`, and `__3rd_value__` to `__container__.baz()`. 

[endsect][/ Customization]

[endsect][/ Standard modifier ]

[section:arg_forward Argument forwarding]

[section Introduction]

The adaptor `__kwd_csv_put__`, exclusively used so far, is fine when the objects to be 
put into a container are already constructed. Otherwise, we have to construct them in place, as we show
in the following example, 
[#example_put_arg_forwarding_in_place]
[in_place]
which, in terms of our [link boost_assign_v2.ug.notation notation], corresponds to [^__n__ = 3], 
[^ __k__\[0\] = 1], [^__k__\[1\] = 0], and [^__k__\[2\] = 2],

In this section we introduce an alternative interface that achieves the same result, but in a compact fashion. 
Echoing the structure of the section [link boost_assign_v2.ug.put.std_modifier Standard modifier], 
our next two sections describe the implementations that are automatically deduced and user specified, respectively.

[endsect]

[section:auto Automatic deduction]

[heading Synopsis]

In terms of our [link boost_assign_v2.ug.notation notation], for [^__n__ = 1], 

[table 
	[ [Expression][ Result ][ Side effect ] ]
	[
		[`__container__ | adaptor::__kwd_put__( __arg__[0], ....,__arg__[__k__]) `]
		[A reference to `__container__`]
		[Forwards to `__value_type__(__arg__[0], ....,__arg__[__k__])` and passes the result to the standard modifier] 
	]
]

The appropriate type, `__value_type__`, is deduced at compile time, from the type of destination 
container, `__container__`. The above extends to arbitrary `__n__` as follows:
``
	__container__ | __kwd_put__(__arg__[0][0], ....,__arg__[0][__k__[0]])...(__arg__[__n__-1][0], ....,__arg__[__n__-1][__k__[__n__-1]])
``

[heading Examples]

We now revisit the [link example_put_arg_forwarding_in_place example] motivating this section,
[#example_put_arg_forwarding_auto]
[forward_to_constructor]

In an earlier [link boost_assign_v2.ug.put.std_modifier.auto section], we had already pointed that 
filling `std::map<>` with `__kwd_csv_put__` was clumsy, and now continue that [link example_put_auto_map example] to show the better approach:
[#example_put_arg_forwarding_auto_map]
[map_proper]

[/warning Under the [tpl_sec_platform default testing platform], for  [^__n__ > 32] and [^__k__ = 1], is it 
necessary to construct objects in place, and pass them to `__kwd_csv_put__`, because of `__kwd_put__`'s greater compilation needs.]

[endsect][/ Automatic deduction]

[section:user User specified]

[heading Synopsis]

[table 
	[ [Expression][ Result ] ]
	[
		[`adaptor::__kwd_put__ % (__kwd_fun__ = __f__)`]
		[An adaptor whose embedded functor is `__f__` ]
	]
]

[heading Examples]

As a variation on the [link example_put_arg_forwarding_auto example] of the previous section,
[#example_put_arg_forwarding_user]
[forward_to_make_foo]

Users that are familiar with the __lambda__ library will have recognized that the repetition of 
`b` would be better avoided thanks to a binding functor:
[#example_put_arg_forwarding_user_bind]
[forward_to_bind]
Notice that since each argument in the sequence is now unary, we were able to revert to using `__kwd_csv_put__`, 
and did so only because it's more elegant that way.

[endsect][/User specified]
[endsect][/Argument forwarding]

[section:ptr_container Pointer container]

The same functionality as that for STL containers works for [tpl_ptr_container pointer containers], but the side effect is a bit different.
For example, consider,
[ptr_vector]
Copies of `__1st_value__`, `__2nd_value__` and `__3rd_value__` are allocated on the heap, and their pointers put into
`cont`, using `push_back()`, in this case. Just as with other categories of containers, we can override both the modifier and the argument forwarding mechanism, by
passign the appropriate parameters with `operator%`.

[endsect][/Pointer containers]

[section:ext Extended functionality]

A [link boost_assign_v2.ug.put.std_modifier standard modifier], as we recall, only passes the 
result of a functor to a particular member function of the destination container. Either of the  
[link boost_assign_v2.ug.put.arg_forward.user functor] and the 
[link boost_assign_v2.ug.put.std_modifier.user standard modifier] can be user specified by
calling the respective appropriate keyword with `operator%`. The latter is composable, 
such that the functor keyword `__kwd_fun__`, an arbitrary number of parameters, [^__param_count__],
can all be successively passed to the implementation:

``
	adaptor::__kwd_put__ % ( __kwd_fun__ = __f__ ) % __kwd_param__[0] ... % __kwd_param__[__param_count__-1]
``

A non-standard modifier, the topic of this section, is one that executes a more complicated task
than a standard modifier does.

[section:repeat `__kwd_repeat__`]

[heading Header]

[def __header_put_modifier_ext_repeat__ [@../../../../../boost/assign/v2/put/modifier/ext/repeat.hpp boost/assign/v2/put/modifier/ext/repeat.hpp]]

``
	#include <__header_put_modifier_ext_repeat__>
``

[heading Synopsis]

[table 
	[ [ Parameter expression ][ Implementation ] ]
	[ [ `_repeat = n` ][ `m = n; while(--m) __implem_defined__` ] ]
]
where `__implem_defined__` is the implementation prior to passing the parameter.

[heading Example]

[repeat_simple]

[endsect]

[section:incr_looup `__kwd_incr_lookup__` ]

[heading Header]

[def __header_put_modifier_ext_incr_lookup__ [@../../../../../boost/assign/v2/put/modifier/ext/incr_lookup.hpp boost/assign/v2/put/modifier/ext/incr_lookup.hpp]]

``
	#include <__header_put_modifier_ext_incr_lookup__>
``

[heading Synopsis]

[table 
	[ [ Parameter expression ][ Implementation ] ]
	[ [ `_incr_lookup = n` ][ `__container__[ __key__ ] += n` ] ]
]

[heading Example]

[incr_lookup]

[endsect]

[section:quiz Quiz]

This section gives the reader a chance to evaluate his/her knowledge of the current [link boost_assign_v2.ug.put framework], up to this point.

Question: What will be output from the code below? Shown in the comments are the outputs of the individual 
values, in the order in which they are passed to the adaptor. For example, the output of `std::cout << __1st_value__` is [^(1,0)]. 
[complex_ex1]

Answer:
[complex_ex1_answer]

[endsect][/ Quiz]

[section:custom Customization]

[heading Header]

[def __header_put_modifier_ext_xxx__ [@../../../../../boost/assign/v2/put/modifier/ext/xxx.hpp boost/assign/v2/put/modifier/ext/xxx.hpp]]

``
	#include <__header_put_modifier_ext_xxx__>
``

[heading Usage]

Suppose we want to add a keyword, `__custom_kwd_parameter__`, to our framework, so that  
``
	__container__ | (__kwd_put__ % __custom_kwd_parameter__)(__arg__[0], ..., __arg__[__k__-1])
``
controls the execution of `operation|` in a specific way.  We label ['new] and ['old] the implementations 
behind the execution of the statements above and below,  
``
	__container__ | __kwd_put__(__arg__[0], ..., __arg__[__k__-1])
``
respectively, and proceed as follows:

# Create a tag :
``
	namespace modifier_tag{ 
		template<typename OldTag> struct __custom_parameter__; 
	}
``
Here, and throughout the rest of this itemized list, we are assuming that the new implementation builds 
upon the old one. Otherwise, we would have declared `__custom_parameter__` without a template
parameter. 

# Pair the tag with a function type:
``
	namespace put_parameter{ 
		template<typename OldFun,typename OldTag> 
		struct __custom_parameter__ : __put_param_pair__<
			__custom_fun__,
			modifier_tag::__custom_parameter__<OldTag>
		>; 
	}
``
If `__custom_fun__` is set to `OldFun`, the implementation is instantiated by copying the old function. 
Otherwise, the default constructor of `__custom_fun__` is called.

# Specialize `__put_modifier__<>` on the tag created in step 1:
``
	namespace put_aux{
		template<typename OldTag>
		struct __put_modifier__<__custom_parameter__<OldTag> >
		{
			// Constructors as needed

			// Provide an implementation
			template<typename __container_type__,typename __value_type__> 
			void impl(__container_type__& __container__, __value_type__& __value__)const; 

		};
	}
``
Optionally, member function `impl()` can be overloaded in its second argument to take, instead, 
a `__value_type__*`, which is needed if `__container_type__` is a [tpl_ptr_container pointer container]. 

# Create a class that the user can use to specify desired customization,
``
	namespace put_aux{
		struct __custom_parameter__{
			// As needed, a constructor that stores a runtime value
			// As needed, operator= with which the user interacts to pass
			// a runtime value.
			__implem_defined__ get(); // Forwarded to modifier<>'s constructor
		};
``
# Expand the macro
``
	__macro_put_ext_xxx__(__custom_parameter__)
``

The last step will create keyword `__custom_kwd_parameter__` with the desired properties. This keyword
has type `put_aux::__custom_parameter__`, from step 4, the interface of which is that which the user interacts
with, for example, to specify a runtime variable.

[endsect][/ Customization]

[endsect][/Extending functionality]

[section:put_range Adaptor `__put_range__`]

[heading Description]

Adaptor `__put_range__` takes elements from a range and puts them in a container. 

[heading Synopsis]

Assuming `__from__` is a [tpl_concept_range range] whose dereferenced values are 
`__value__[0]`...`__value__[__n__]`,

[table
	[[Expression][Result][Equivalent expression]]
	[
		[``
			__to__ | adaptor::__put_range__( __from__ );
		``]
		[
			A reference to `__to__`
		]
		[``
			to | __kwd_put__(__value__[0])...(__value__[__n__])
		``]
	]
]

[#put_range_caution]
[caution It is likely to be preferable to call `boost::copy(from, boost::begin(to) )` whenever possible, 
which tends to restrict the applicability of `__put_range__` to the case in which `__to__` is an [tpl_stl_adapter adapter].]

[heading Example]

[import ../example/put_range.cpp]
[put_range_queue]

[endsect][/ put_range]

[section:put_convert Adaptor `__put_convert__`]

[heading Description]

An adaptor for intializing a container in place.

[heading Synopsis]

[table
	[[Expression][Result][ Property ]]
	[
		[``
			__from__ | adaptor::__put_convert__<__to_type__>();
		``]
		[
			An object of type `__to_type__`
		]
		[
			The result is initialized with the elements of `__from__`
		]
	]
]

[endsect]

[heading Example]

[import ../example/conversion.cpp]
[convert_stack]

[endsect][/Put]

[section:anon_cont Anonymous container of values]

__reminder__

[import ../example/anon.cpp]

[heading Header]

[def __header_anon_cont__ [@../../../../../boost/assign/v2/anon.hpp boost/assign/v2/anon.hpp]]

``
	#include <__header_anon_cont__>
``

[heading Description]

A pair of functions, `csv_anon()` and `anon()`, to construct in place (hence the name ['anonymous]) 
a container of values that is akin to `std::deque<>`. 

[section:csv_anon `csv_anon`]

[heading Synopsis]

[table 
	[ [Expression][ Result type] ]
	[
		[`csv_anon( __value__[0], ...,__value__[__n__-1] )`]
		[`typename result_of::anon<__value_type__>::type`]
	]
]

[heading Example]

[csv_anon]

[endsect]

[section:anon `anon`]

Argument forwarding and the ability to specify a user-specified implementation (functor or modifier) 
are two features provided that we encountered in the [link boost_assign_v2.ug.put put framework], specifically
sections [link boost_assign_v2.ug.put.std_modifier Standard modifier] and [link boost_assign_v2.ug.put.arg_forward Argument forwarding], 
and which also are provided here.

[heading Synopsis]

[table Forwarding to the constructor
	[ [Expression][ Result type] ]
	[
		[`anon<__value_type__>(__kwd_nil__)( __arg__[0][0], ..., __arg__[0][__k__[0]])...( __arg__[__n__-1][0], ..., __arg__[__n__-1][__k__[__n__-1]])`]
		[`typename result_of::anon<__value_type__>::type`]
	]
]

Notice that the result type of `csv_anon<__value_type__>()` and `anon<__value_type__>()` are of the
same type. Only using the former can `__value_type__` be deduced from the arguments[footnote If, in the expression for argument forwarding, [^__k__\[0\] = 1] and it is known that 
`__arg__[0][0]` is of type `__value_type__`,  such that we may label it, instead, `__value__[0]`, 
the first two calls to `operator()` are  equivalent `anon<__value_type__>(__kwd_nil__)( __value__[0] )`. 
Under these conditions, it is equivalent,  but preferable to call `csv_anon( __value__[0] )`. 
], and only using the latter can an empty container, by passing keyword `__kwd_nil__`, be created.

[table User specified functor and modifier
	[ [Expression][ Result type] ]
	[
		[`anon<T>(__kwd_nil__) % (__kwd_fun__ = f)`]
		[`typename result_of::anon<T>::type`]
	]
	[
		[`anon<T>(__kwd_nil__) % __kwd_param__[0] % ... % __kwd_param__[__param_count__]`]
		[`typename result_of::anon<T>::type`]
	]
]

[heading Example]

[anon]

[endsect]

[endsect][/Anonymous container of values]

[section:ref Anonymous container of references]

__reminder__

[import ../example/ref_anon.cpp]

[heading Header]

[def __header_ref__ [@../../../../../boost/assign/v2/ref.hpp boost/assign/v2/ref.hpp]]

``
	#include <__header_ref__>
``

[heading Description]

A pair of functions, `csv_anon()` and `anon()`, to construct in place (hence the name ['anonymous]) 
a static array of references. In access mode, the latter can be used practically as [tpl_boost_array `boost::array<>`]. 
In write mode, since the underlying data is of reference type, the semantics of `operator=` and `assign()` are particular, 
which is the topic of section [link boost_assign_v2.ug.ref.assign Assignment policy]. 

[heading Notation]

To proceed to the next sections, suffice it to know that `csv_anon()` and `anon()` are defined in both
`namespace`s `assign_copy` and `assign_rebind`, each corresponding to a particular assignment policy.
Accordingly, we will use the following convention 

[def __assign_xxx__ '''<replaceable>assign_xxx</replaceable>''']

``
	namespace ns = ref::__assign_xxx__;
``
where `__assign_xxx__` designates either of the two aforementioned `namespace`s. 

Template argument `U` is, in terms of our [link boost_assign_v2.ug.notation notation], either
of `__value_type__` or `__value_type__ const`.

[section:csv_anon `csv_anon`]

[heading Synopsis]

[table 
	[ [Expression ][ Result type ]]
	[
		[`ns::csv_anon<U>( __kwd_nil__ )`]
		[`typename ns::nth_result_of::csv_anon<0, U>::type`]
	]
	[
		[`ns::csv_anon( __value__[0], ..., __value__[__n__-1] )`]
		[`typename ns::nth_result_of::csv_anon<__n__, U>::type`]
	]
]
In the second expression, `U == __value_type__ const` if and only if `__value__[__i__]` is passed 
as a `const` lvalue or an `rvalue`,  for at least one `__i__`, and `U == __value_type__` otherwise [footnote 
Under __url_cpp03__. Under __url_cpp0x__, const-ness is, for now, determined by `__value__[0]` ].

[heading Example]

Refer to [link boost_assign_v2.ug.ref.assign.copy.example `assign_copy`] and 
[link boost_assign_v2.ug.ref.assign.rebind.example `assign_rebind`] examples of section
[link boost_assign_v2.ug.ref.assign Assignment policy]

[endsect][/csv_anon]

[section:anon `anon`]

[heading Synopsis]

[table 
	[ [Expression ][ Result type] ]
	[
		[`ref::assign_xxx::anon( __kwd_nil__ )`]
		[`typename ref::assign_xxx::nth_result_of::anon<0, U>::type`]
	]
	[
		[`ref::assign_xxx::anon( __value__[0]) ...(__value__[__n__-1] )`]
		[`typename ref::assign_xxx::nth_result_of::csv_anon<__n__, U>::type`]
	]
]
The determination of `U` for the second expression is identical to that for
[link boost_assign_v2.ug.ref.csv_anon.synopsis `csv_anon()`].

[heading Example]

The advantage over `csv_anon()` is that a result can be saved, 
[anon_read_empty]
and later appended,
[anon_read_fill]
but not until the `boost::array<>` interface is called (presumably
`begin()` and `end()` in the example that follows), 
[anon_read_print]
is a static array of references internally allocated.

[endsect] 

[section:assign Assignment policy]

Throughout this section, it is assumed that `__container__`, is an initialized static array returned by
`csv_anon()` or `anon()`.

[section:copy `assign_copy` ]

[heading Synopsis]

[table 
	[ [Expression ][ Post condition ] ]
	[ 
		[``	
				__container__[__i__] = __value__;
		``]
		[``	
				__container__[__i__] == __value__
		``]
	]
]

[heading Example]

In access mode,
[assign_copy_read]

In assignment mode,
[assign_copy_write]

[endsect][/ Assign copy]

[section:rebind `assign_rebind`]

[heading Synopsis]

[table 
	[ [Expression ][ Post condition ] ]
	[ 
		[``	
				__container__[__i__] = __value__;
		``]
		[``	
				&__container__[__i__] == &__value__
		``]
	]
]

[heading Example]

In access mode,
[assign_rebind_read]
In assignment mode,
[assign_rebind_write]

[endsect][/ rebind]

[endsect][/Assignment]


[endsect][/ Anonymous container of references]

[section:chain Adaptor `_chain`]

__reminder__

[heading Header]

[def __header_chain__ [@../../../../../boost/assign/v2/chain.hpp boost/assign/v2/chain.hpp]]

``
	#include <__header_chain__>
``

[heading Description]

Adaptor `_chain` is an outgrowth of a similar functionality that appeared in the beta version of 
[tpl_range Boost.RangeEx] that maps two ranges into their union, and is composable.

It also has the special property that it is lvalue preserving : two chained ranges, either of which is 
passed as an rvalue, but both of which hold lvalues, is a range whose references are lvalues. Such
an instance occurs if the rvalue is an [link boost_assign_v2.ug.ref anonymous container of lvalue references]

[heading Synopsis]

[table 
	[ [Expression][ Result type ] ]
	[
		[`__r1__ | adaptor::_chain( __r2__ )`]
		[`typename result_of::chain<__r1_type__,__r2_type__>::type`]
	]
]

[heading Example]

[import ../example/chain.cpp]
In access mode,
[chain_read]

In write mode, thanks to the lvalue preserving property:
[chain_write]

[endsect][/ Adaptor `_chain`]

[section:arity Configuring arity]

__notation_reminder__

Below are overridable constants's identifier, default value, and the [link boost_assign_v2.ug.notation index] that they control. 

[table
	[[ Constant ][ Default value ][ Index ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_CSV_ARITY`][20][ __n__ ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_LVALUE_CONST_ARITY`][2][ __k__ ]]
	[[ `BOOST_ASSIGN_V2_LIMIT_ARITY`][ `BOOST_MPL_LIMIT_METAFUNCTION_ARITY`][ __k__ ]]
]

The first constant is the limit arity for
``
	__kwd_csv_put__( __value__[0], ..., __value__[__n__-1]);
``
and similar functions. The second and third constants apply only to the functor form:
``
	__kwd_put__( __arg__[0][0], ..., __arg__[0][__k__[0]])...( __arg__[__n__-1][0], ..., __arg__[__n__-1][__k__[__n__-1]]);
``
The second constant is the limit for arity `__k__[__i__]` under which any combination of lvalue and rvalue arguments is preserved, for any given `__i__` 
in `[0,...,__n__)`. Beyond this limit, arguments are treated as either all lvalues or all const-lvalues. The third constant is the total limit for arity 
`__k__[__i__]`.

[Note  These restrictions only apply under __url_cpp03__, not __url_cpp0x__ ]

[endsect][/Configuring arity]

[section:apx Appendix]
[section:run_efficiency Runtime efficiency]

__notation_reminder__. We compare the execution time of various ways to fill a given STL container and creating an anonymous container provided by this library.

[heading Testing platform]

[variablelist
	[[Processor][__mac_processor__]]
	[[Memory][__mac_mem__]]
	[[OS][__mac_os__]]
	[[Compiler][gcc4.4 (__url_fink__ )]]
	[[Flags][[^-O2 -std=c++0x]]]
]

[heading Set up]

[import ../speed/anon_put_ref.cpp]

Here are the types that are used:
[types]
And here are the simulation parameters:
[sim_param]

[heading Results]

[table 
	[
		[Library]
		[Expression]
			[ [^__n__ = 1] ]
				[ [^__n__ = 2] ]
					[ [^__n__ = 4] ]
						[ [^__n__ = 8] ]
							[ [^__n__ = 16] ]
								[ [^__n__ = 32] ]
									[ [^__n__ = 64] ]
										[ [^__n__ = 128] ]
	]
	[
		[
			__stl__
		]
		[``
			__container__.push_back( __value__[0] );...__container__.push_back( __value__[__n__-1] );
		``]
			[[^0.12] s]
				[[^0.36] s]
					[[^0.91] s]
						[[^1.90] s]
							[[^4.29] s]
								[[^8.98] s]
									[[^18.40] s]
										[[^37.41] s]
	]
	[
		[``
			__boost_assign_v1__	
		``]
		[``
			list_of( __value__[0] )...( __value__[__n__-1] )
		``]
			[[^1.21] s]
				[[^2.54] s]
					[[^4.28] s]
						[[^7.56] s]
							[[^14.29] s]
								[[^28.22] s]
									[[^55.33] s]
										[[^110.85] s] 
	]
	[
		[``
			__boost_assign_v1__	
		``]
		[``
			cref_list_of<__n__>( __value__[0] )...( __value__[__n__-1] )
		``]
			[[^0.00] s]
				[[^0.00] s]
					[[^0.00] s]
						[[^0.00] s]
							[[^0.00] s]
								[[^0.04] s]
									[[^0.06] s]
										[[^0.12] s] 
	]
	[
		[``
			__boost_assign_v1__	
		``]
		[``
			push_back( __container__ )( __value__[0] )...( __value__[__n__-1] )
		``]
			[[^0.34] s]
				[[^0.77] s]
					[[^1.89] s]
						[[^4.16] s]
							[[^8.59] s]
								[[^18.33] s]
									[[^36.52] s]
										[[^73.42] s] 
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			csv_anon( __value__[0], ...,__value__[__n__-1] )
		``]
			[[^0.40] s]
				[[^0.66] s]
					[[^1.23] s]
						[[^2.38] s]
							[[^4.74] s]
								[[^9.38] s]
									[[^19.36] s]
										[[^47.84] s] 
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			anon<T>(__kwd_nil__)( __value__[0] )...( __value__[__n__-1] )
		``]
			[[^0.99] s]
				[[^1.65] s]
					[[^2.75] s]
						[[^5.16] s]
							[[^9.51] s]
								[[^18.33] s]
									[[^36.56] s]
										[[^72.54] s]
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			ref::assign_copy::csv_anon( __value__[0], ..., __value__[__n__-1] )
		``]
			[[^0.00] s]
				[[^0.00] s]
					[[^0.00] s]
						[[^0.01] s]
							[[^0.04] s]
								[[^0.11] s]
									[[^0.57] s]
										[[^10.15] s] 
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			ref::assign_copy::anon( __value__[0] )...( __value__[__n__-1] )
		``]
			[[^0.33] s]
				[[^0.38] s]
					[[^0.38] s]
						[[^0.38] s]
							[[^0.51] s]
								[[^0.63] s]
									[[^1.12] s]
										[[^2.90] s] 
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			csv_put( __container__ )( __value__[0], ....,__value__[__n__-1] )
		``]
			[[^0.12] s]
				[[^0.36] s]
					[[^0.88] s]
						[[^1.92] s]
							[[^4.24] s]
								[[^8.97] s]
									[[^18.16] s]
										[[^37.28] s] 
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			put( __container__ )( __value__[0] )...( __value__[__n__-1] )
		``]
			[[^0.12] s]
				[[^0.37] s]
					[[^0.86] s]
						[[^1.91] s]
							[[^4.24] s]
								[[^8.94] s]
									[[^18.09] s]
										[[^36.79] s]
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			__container__ | csv_put( __value__[0], ....,__value__[__n__-1] )
		``]
			[[^0.13] s]
				[[^0.37] s]
					[[^0.91] s]
						[[^1.95] s]
							[[^4.35] s]
								[[^9.23] s]
									[[^18.76] s]
										[[^48.04] s] 
	]
	[
		[``
			__boost_assign_v2__	
		``]
		[``
			__container__ | __kwd_put__( __value__[0] )...( __value__[__n__-1] )
		``]
			[[^0.12] s]
				[[^0.36] s]
					[[^0.86] s]
						[[^1.96] s]
							[[^4.46] s]
								[[^9.79] s]
									[[^20.51] s]
										[[^46.75] s] 
	]
]

[/ GCC4.4 - C++0x
This test times the filling of a std::deque<T>
where T = std::vector<int>, and has max size 100
Number of loops over which execution time is summed : 1000000 
N = 1 . . . N = 2 . . . N = 4 . . . N = 8 . . . N = 16 . . . N = 32 . . . N = 64 . . . N = 128 . . . 
n = [1 2 4 8 16 32 64 128 ]
vec.push_back( t0 ); ... vec.push_back( tN-1 );[0.123938 s 0.367076 s 0.914986 s 1.90062 s 4.29098 s 8.98548 s 18.403 s 37.4122 s ]
list_of( t0 )...( tN-1 )[1.21883 s 2.54334 s 4.28334 s 7.5633 s 14.2961 s 28.2285 s 55.3357 s 110.854 s ]
cref_list_of<N>( t0 )...( tN-1 )[1e-06 s 2e-06 s 2e-06 s 1e-06 s 2e-06 s 0.042728 s 0.068423 s 0.127774 s ]
push_back( vec )( t0 )...( tN-1 )[0.344784 s 0.774222 s 1.89953 s 4.16403 s 8.59715 s 18.3335 s 36.521 s 73.4246 s ]
csv_anon(t0, ...,tN-1)[0.409826 s 0.66199 s 1.23808 s 2.38836 s 4.74928 s 9.38014 s 19.3646 s 47.8482 s ]
anon<T>( _nil )( t0 )...( tN-1 )[0.997468 s 1.65431 s 2.75162 s 5.16503 s 9.51286 s 18.3376 s 36.5653 s 72.5427 s ]
ref::assign_copy::csv_anon(t0, ...,tN-1)[2e-06 s 0.003395 s 0.008194 s 0.017556 s 0.041773 s 0.117394 s 0.574327 s 10.1556 s ]
ref::assign_copy::anon( t0 )...( tN-1 )[0.335089 s 0.381143 s 0.38832 s 0.389494 s 0.517601 s 0.63537 s 1.12653 s 2.90775 s ]

]

[/ GCC4.2 
-> Runtime efficiency 
Each value, t, is a std::vector<int> of max size 100
Number of loops over which execution time is summed : 1000000 
N = 1 . . . N = 2 . . . N = 4 . . . N = 8 . . . N = 16 . . . N = 32 . . . 
n = [1 2 4 8 16 32 ]
vec.push_back( t0 ); ... vec.push_back( tN-1 );[0.09474 s 0.364069 s 0.756583 s 1.73736 s 3.85251 s 7.80783 s ]
list_of( t0 )...( tN-1 )[1.21162 s 2.61857 s 4.21912 s 7.22663 s 13.1252 s 26.4862 s ]
push_back( vec )( t0 )...( tN-1 )[0.251143 s 0.726118 s 1.70959 s 3.78038 s 7.86995 s 16.1174 s ]
csv_anon(t0, ...,tN-1)[1.25213 s 2.06734 s 3.56238 s 6.36345 s 12.3659 s 25.7607 s ]
anon<T>( __kwd_nil__ )( t0 )...( tN-1 )[1.28602 s 2.16045 s 3.66355 s 6.57027 s 12.5592 s 25.8411 s ]
ref::assign_copy::csv_anon(t0, ...,tN-1)[1e-06 s 0.003894 s 0.00378 s 0.008088 s 0.016149 s 0.030065 s ]
ref::assign_copy::anon( t0 )...( tN-1 )[0.289133 s 0.289451 s 0.320333 s 0.367231 s 0.47232 s 0.77807 s ]
csv_put( vec )(t0, ...,tN-1)[0.257457 s 0.647526 s 1.69284 s 3.71717 s 7.91357 s 16.1927 s ]
put( vec )( t0 )...( tN-1 )[0.260559 s 0.716297 s 1.74887 s 3.8568 s 8.04035 s 16.4621 s ]
vec | _csv_put(t0, ...,tN-1)[0.280242 s 0.723652 s 1.71606 s 3.71251 s 7.96936 s 16.2413 s ]
vec | _put( t0 )...( tN-1 )[0.266304 s 0.718539 s 1.72965 s 3.81051 s 8.12922 s 16.949 s ]
<- 

]

The functions `csv_put()` `put()` are part of the implementation of the adaptors `__kwd_csv_put__` and `__kwd_put__`, respectively.  
Their execution time is given here only to gauge the overhead of the layer of code between them and the final product (the adaptors). 

[endsect][/Runtime efficiency]

[section:portability Portability]

[def __ubuntu__ Ubuntu 10.04]
[def __log_mac_gcc42__ 			[@../../test/unit_testing/log_mac_gcc42 log_mac_gcc42] ] 
[def __log_ubuntu_gcc44__ 		[@../../test/unit_testing/log_ubuntu_gcc44 log_ubuntu_gcc44] ]
[def __log_ubuntu_gcc440x__ 	[@../../test/unit_testing/log_ubuntu_gcc440x log_ubuntu_gcc440x] ]
[def __num_tests__				[^32]]
[def __boost_version__			[^__boost_trunk__] as of 11/2010]

[table
	[
		[ OS]
		[ Compiler ]
		[ Option(s) ]
		[__url_boost__ version(s)]
		[ Passed, out of __num_tests__ ]
		[Log file]
	]
	[
		[ __mac_os__]
		[ __mac_default_compiler__ ]
		[  ]
		[ __boost_version__ ]
		[ 32/32 ]
		[ __log_mac_gcc42__ ]
		[/
			VAR='date \"+%D\"'
			echo $VAR> log_mac_gcc_42
	    	sudo bjam \"toolset=darwin\" >> log_mac_gcc42
		]	
	]
	[
		[ __mac_os__]
		[ gcc4.4 (__url_fink__ ) ]
		[ __cpp0x__ ]
		[ __boost_version__ ]
		[ 32/32 ]
		[ ]
	]
	[
		[ __ubuntu__ ]
		[ gcc4.4 ]
		[  ]
		[ __boost_version__ ]
		[ 32/32 ]
		[ __log_ubuntu_gcc44__ ]
		[/
			VAR=`date "+%D"`
			echo $VAR> log_ubuntu_44
	    	sudo bjam "toolset=gcc" debug release >> log_mac_gcc44
		]	
	]
	[
		[ __ubuntu__ ]
		[ gcc4.4 ]
		[ __cpp0x__ ]
		[ __boost_version__ ]
		[ 30/32 ]
		[ __log_ubuntu_gcc440x__ ]
		[/	
			VAR=`date "+%D"`
			echo $VAR> log_ubuntu_44_0x
			sudo sudo bjam "toolset=gcc" cxxflags=-std=c++0x >> log_mac_gcc44_0x 
		]
	]
]

[endsect][/Portability]

[section:change_log Change log]

[section:v2 \[Proposal for\] Upgrading from __boost__ v1.4x : __boost_assign_v2__]

For backward compatibility and to permit a smooth transition for users that are familiar with __url_boost_assign_v1__, the latter will continue to be supported. The two
versions, in fact, can be used in the same project as their interfaces don't overlap. The reader can quickly form an impression about the latter by referring to the 
[link boost_assign_v2.preface preface], and compare (non-exhaustively) the two versions in section [link boost_assign_v2.ug.apx.run_efficiency Runtime efficiency].
The organizational change is apparent in section [link boost_assign_v2.ug.start Getting started]. The remainder of this section discusses the rationale for this 
upgrade. 

A revision to [link boost_assign_v2.ug.ref anonymous container of references], and the addition of a tool for [link boost_assign_v2.ug.chain chaining] them were the
subject of a __url_boost_assign_v2_mini_review__, and carry through to __url_boost_assign_v2__. The first discarded the container generating function
`ref_list_of<>()`'s template parameter specifying a size, deducing the latter, instead, as the number of arguments. It also added an 
[link boost_assign_v2.ug.ref.assign assignment policy] and fitted the container with [tpl_boost_array boost::array<>]'s functionality. Finally, a type of function, 
termed ['csv], was introduced, as a more elegant alternative (but not a replacement) to multiple calls to a functor. [#change_log_chain] The second feature, chaining, 
served as an alternative to a container-of-references' member function `range()`.  Since the __url_boost_assign_v2_mini_review__, the proposal has been further improved. For 
instance, the dual interface, `ref_list_of()` and `cref_list_of()` is replaced by a single function, `anon()`, that resolves lvalue/const-ness automatically, and 
likewise for chaining. Also, the latter now preserves the lvalue-ness of the chained ranges' elements, even if either of the input ranges is passed as an rvalue, 
as may be the case with a container of references.

During the same __url_boost_assign_v2_mini_review__, it became apparent that the existing and proposed features lacked homogeneity in their interface, and that the
relevance of the proposed one was insufficiently outlined in the documentation. Conversely, some newly introduced features, such as the already mentioned 
['csv] functions, had received enough interest to warrant their generalization throughout the rest of the library. Another consensus was the request for exploiting 
__url_cpp0x__'s features. Incidentally, some confusion was voiced as to whether a nullary call to some container generator, fun(), is supposed to return a container
that is empty or one that contains a default constructed value. __boost_assign_v2__ adresses these requests with a new design that incorporates added benefits. 

The solution to the `fun()` problem, adopted in __url_boost_assign_v2__, is to keep __url_boost_assign_v1__'s convention that `fun()` creates a default value, 
but, in addition, `fun(__kwd_nil__)` returns an empty container. As for __url_cpp0x__, functions are variadic and preserve the lvalue/const-ness of their 
arguments. Under __url_cpp03__, these aspects are controlled by [link boost_assign_v2.ug.arity overridable constants] (macros).

A defining feature of the interface is `operator|`, which expresses a variant of [tpl_range_adaptor range-adaptors], and the [tpl_range_adaptor_compose composability]
that follows from it. In the library's core framework, [link boost_assign_v2.ug.put put], the key to efficiency is to hold arguments on the right hand side of 
`operator|` as references, a spillover from [link boost_assign_v2.ug.ref container of references]. The only other operator is `operator%`, for selectively overriding
the default implementation, as seen [link preface_list here]. 

In terms of code-reuse, while `list_of()` and the ['list inserters] (e.g. `push_back()`) are, under __url_boost_assign_v1__, independently implemented, their 
counterparts, under __url_boost_assign_v2__, [link boost_assign_v2.ug.anon_cont `anon()`][footnote The analog of function in __url_boost_assign_v1__'s `list_of()`is 
renamed `anon()`, in __url_boost_assign_v2__, for several of reasons. First, `list_of` evokes a particular data-structure  (forward traversal) that is different from the actual underlying one, `std::deque<>` (random access). 
Second, in  __url_boost_assign_v1__'s documentation, the result of `list_of()` is referred to as an  anon-ymous container. The new identifier is therefore consistent 
with this established practice. Third, it avoids ambiguity resolution, in case both __url_boost_assign_v1__ and  __url_boost_assign_v2__ are used in the same project.] and  adaptor [link boost_assign_v2.ug.put `__kwd_put__`], respectively, derive from a common __crtp__ `class`.
Thanks to this integrated approach, containers such as `std::map<>` or [tpl_ptr_container pointer containers] fit into the framework without requiring a
special interface, and internally without or only minor code adustments, respectively.  The implementation is open to customization and that job is facilitated by 
macros. See sections [link boost_assign_v2.ug.put.std_modifier.custom Standard modifier] and [link boost_assign_v2.ug.put.ext.custom Extending functionality]. 
Finally, functions `range<>()` and `convert<>()` that in  __url_boost_assign_v1__ are  members of objects, are now standalone adaptors, renamed 
[link boost_assign_v2.ug.put.put_range `put_range<>()`] and  [link boost_assign_v2.ug.put.put_convert `put_convert<>()`], respectively [footnote These new names
make it clear that they forward to the [link boost_assign_v2.ug.put put] framework, whereas their equivalents in __url_boost_assign_v1__ had a broader mandate. See
the word of [link put_range_caution caution]. ], an approach that is coherent with that adaptor for container of references (see [link change_log_chain here]). 

[endsect][/ Upgrading from __boost__ v1.4x ]

[endsect][/Change log]

[section:help Getting help]

To get help or make a suggestion, post to the __user_mailing_list__, but also make sure to notify 
__TO__ and __ER__ by cc-ing them.

[endsect][/Getting help]

[section History and acknowledgement]

[heading __boost_assign_v1__]

The idea for an assignment/initialization library is not new. The  functionality of this library 
resembles Leor Zolman's STL Container Initialization Library a great deal, but it does not rely on 
string parsing to achieve its goals. 

Special thanks go to 

* Leor Zolman for our many discussion that eventually led to this library.
* Tom Brinkman for being review manager.
* Joaqun Muoz for vc6/vc7 portability.
* Pavel Vozenilek for his countless suggestions, improvements and  portability fixes. 
* Rene Rivera for Code Warrior portability.     

[heading __boost_assign_v2__ ]

* Manuel Peinado Gallego identified the need for a (revised) [link boost_assign_v2.ug.ref anonymous container of references], and provided
  valuable advice throughout the early development of __boost_assign_v2__, such as proposing a [@http://gist.github.com/287791 design] 
  that laid the foundation for [link boost_assign_v2.ug.chain chaining].
* __TO__ for his help leading up to the __url_boost_assign_v2_mini_review__, which he managed, and thereafter.

[endsect] [/Ackowledgement]

[section Bibliography]

* Scott. Meyers, "More Effective C++", Item 7, Addison Wesley, 1996       
* K. Czarnecki and U.W. Eisenecker, "Generative programming", Addison-Wesley, 2000        
* [@http://www.oonumerics.org/blitz/ Blitz]
* Gabriel Dos Reis and Bjarne Stroustrup, 
 [@http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1509.pdf Generalized Initializer Lists], 2003
* Abrahams, David and Gurtovoy, Aleksey,
 [@http://portal.acm.org/citation.cfm?id=1044941# C++ Template Metaprogramming]: Concepts, Tools, and Techniques from Boost and Beyond (C++ in Depth Series),
 2004, Addison-Wesley Professional.

[endsect][/ Bibliography]
[endsect][/ Appendix]
[endsect][/ User's guide]

[/ ---------------------------------------------------------------------------------------------- ]

[/xinclude ref.xml]
