<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.Assignment Documentation </title>
<link rel="stylesheet" href="style.css" type="text/css">
</head>

<body>

  <table border="0" >
    <tr>
      <td ><img src="../../../boost.png" border="0" ></td>
      <td >
        <h1 align="center">Assignment Library</h1>
      </td>
    </tr>
  </table>

  <p>
  Copyright © 2003-2006 Thorsten Ottosen <br/>
  Copyright © 2010- Erwann Rogard
  </p>
  <p>
  Use, modification and distribution is subject to the Boost Software License, Version 1.0
  (see <a href="http://www.boost.org/LICENSE_1_0.txt">
   http://www.boost.org/LICENSE_1_0.txt</a>).
  </p>
  <h3>Table of Contents</h3>
  <ul>
    <li><a href="#intro">Introduction</a></li>
    <li>     
        <a href="#tutorial" >Tutorial</a>
        <ul>
            <li>Function <a href="#operator+="><code>operator+=()</code></a>
            <li>Function <a href="#operator()"><code>operator()()</code></a>
            <li>Function <a href="#list_of"><code>list_of()</code></a>    
            <li>Function <a href="#map_list_of"><code>map_list_of()</code></a> 
            <li>Function <a href="#tuple_list_of"><code>tuple_list_of()</code></a>
            <li>Functions <a href="#repeat"><code>repeat()</code></a>, <a href="#repeat"><code>repeat_fun()</code></a> and <a href="#repeat"><code>range()</code> </a>
            <li>Function <a href="#chain"><code>operator &&</code></a>
            <li>Functions <a href="#ref_list_of"><code>ref_list_of()</code></a>, <a href="#ref_list_of"><code>cref_list_of()</code></a> and variants   
            <li>Functions <a href="#ref_csv"><code>ref_csv()</code></a>, <a href="#ref_csv"><code>cref_csv()</code></a> and variants   
            <li>A <a href="#complicated">"complicated"</a> example    
            <li>Functions <a href="#ptr_push_back"><code>ptr_push_back()</code></a>, <a href="#ptr_push_back"><code>ptr_push_front()</code></a>, 
                                                   <a href="#ptr_push_back"><code>ptr_insert()</code></a> and <a href="#ptr_push_back"><code>ptr_map_insert()</code></a>
            <li>Function <a href="#ptr_list_of"><code>ptr_list_of()</code></a>         
       </ul>           
    <li>          
        <a href="#ref-functions">Functions and operators</a>
      <ul>
        <li><a href="#ref-function-headers">Headers</a> </li>
        <li>Functions <a href="#ref-list_of"><code>list_of()</code></a></li>
        <li>Functions <a href="#ref-map_list_of"><code>map_list_of()</code></a></li>
        <li>Functions <a href="#ref-ref_list_of_int"><code>ref_list_of<code>&lt;int&gt;()</code></a></li>
        <li>Function <a href="#ref-make_list_inserter"><code>make_list_inserter()</code></a></li>
        <li>Functions <a href="#ref-ref_list_of"><code>ref_list_of()</code></a>, <a href="#ref-ref_list_of"><code>cref_list_of()</code></a>, and variants</li>
        <li>Functions <a href="#ref-ref_csv"><code>ref_csv()</code></a>, <a href="#ref-ref_csv"><code>cref_csv()</code></a>, and variants</li>
        <li>Operator <a href="#ref-std"><code>+=</code></a> for standard containers</li>
        <li>Functions <a href="#ref-repeat"><code>repeat()</code></a>, <a href="#ref-repeat"><code>repeat_fun()</code></a> and 
                                                                      <a href="#ref-repeat"><code>range()</code>
                                                                      </a></li>
         <li>Operator <a href="#ref-chain"><code>&&</code></a></li>
       <li><a href="#ref-limit">Customizing</a> argument list sizes </li>
     </ul>
    <li> <a href="#concepts" >Concepts</a> </li>
      <ul>
        <li> Concept <a href="#concept-ano_list">         <code>AnonymousList</code>   </a> </li>
        <li> Concept <a href="#concept-auto_size">        <code>AutoSize</code>        </a> </li>
        <li> Concept <a href="#concept-converter">        <code>Converter</code>       </a> </li>
        <li> Concept <a href="#concept-range_comparable"> <code>RangeComparable</code> </a> </li>
        <li> Concept <a href="#concept-range_extensible"> <code>RangeExtensible</code> </a> </li>
        <li> Concept <a href="#concept-ref_wrapper">      <code>RefWrapper</code>      </a> </li>
        <li> Concept <a href="#concept-ref_array">        <code>RefArray</code>        </a> </li>
        <li> Concept <a href="#concept-repeatable">       <code>Repeatable</code>      </a> </li>
      </ul>

    <li> <a href="#ref-impl">Proxy objects</a> </li>
      <ul>
        <li> Proxy object <a href="#ref-generic_list">       <code>generic_list&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-list_inserter">      <code>list_inserter&lt;&gt;</code></a></li>
        <li> Proxy object <a href="#ref-static_generic_list"><code>static_generic_list&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-chain_impl_l">       <code>chain_impl_l&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-chain_impl_r">       <code>chain_impl_r&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-expr">               <code>expr&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-static_array">       <code>static_array&lt;&gt;</code></a> </li>
     </ul>
    <li> <a href="#exceptions">Exceptions and exception-safety </a></li>
    <li> <a href="#extensions">Extending the library</a></li>            
    <li> <a href="#boost_libs">Supported libraries </a></li>        
    <li> <a href="#examples">Examples</a></li>
    <li> <a href="#portability">Portability</a></li>
    <li> <a href="#history">History and Acknowledgment</a></li>    
    <li> <a href="#upgrading_from_1_42">Upgrading from Boost v. <span class=number>1</span><span class=special>.</span><span class=number>42</span></a></li>
    <li> <a href="#ref">References</a></li>
  </ul>
  <hr>
  
<h2><a name="intro">Introduction</a></h2> <p> <i>There appear to be few 
practical uses of <code>operator,()</code></i>.  <!-- p.  247 --> <br><b>Bjarne 
Stroustrup</b>, The Design and Evolution of C++ </p> <p> The purpose of this 
library is to make it easy to fill containers with data by overloading 
<code>operator,()</code> and <code>operator()()</code>.  These two operators 
make it possible to construct lists of values with range and/or conversion capabilities: 
</p> 
<ul> <li> A comma-separated list: <p> 
       <!--  vector< int > v; v += 1,2,3,4,5,6,7,8,9; -->
 
<pre><span 
class=identifier>vector</span><span class=special><</span><span 
class=keyword>int</span><span class=special>></span><span 
class=identifier> v</span><span class=special>; </span>
<span class=identifier>v </span><span class=special>+= </span><span 
class=number>1</span><span
class=special>,</span><span class=number>5</span><span 
class=special>,</span><span class=number>3</span><span 
class=special>,</span><span class=number>4</span><span 
class=special>,</span><span class=number>2</span><span 
class=special>,</span><span class=number>9</span><span 
class=special>,</span><span class=number>0</span><span 
class=special>,</span><span class=number>7</span><span class=special>;</span></pre></p>
       <li> A parenthesis-separated list: 
             <p>       
             <pre>
<span class=identifier>map</span><span class=special><</span><span 
class=identifier>string</span><span class=special>,</span><span class=keyword>int</span><span class=special>> </span><span class=identifier>m</span><span class=special>; </span>
<span class=identifier>insert</span><span class=special>( </span><span class=identifier>m </span><span class=special>)( </span><span class=string>&quot;Bar&quot;</span><span class=special>, </span><span class=number>1 </span><span class=special>)( </span><span class=string>&quot;Foo&quot;</span><span class=special>, </span><span class=number>2 </span><span class=special>);</span></pre> 
    </ul> 

<ul> <li> A list of references (to temporaries, in this example): <p> 
   <pre><span class=special>boost::array&lt;<span class=keyword>int</span><span class=special>,</span><span class=number>9</span>&gt; </span><span class=identifier>a</span> <span class=special>= </span><span class=identifier>cref_csv</span><span class=special>( </span><span 
class=number>1</span><span
class=special>,</span><span class=number>5</span><span 
class=special>,</span><span class=number>3</span><span 
class=special>,</span><span class=number>4</span><span 
class=special>,</span><span class=number>2</span><span 
class=special>,</span><span class=number>9</span><span 
class=special>,</span><span class=number>0</span><span 
class=special>,</span><span class=number>7</span><span 
class=special><span class=special> )</span></pre>
</p> </ul>

<ul> <li> Chained ranges: <p> 
   <pre><span class=special>vector&lt;<span class=keyword>int</span>&gt; </span><span class=identifier>v</span> <span class=special>= </span><span class=identifier>vector&lt;<span class=keyword>int</span>&gt;</span><span class=special>( </span><span 
class=number>3</span><span
class=special>,</span><span class=number>1</span><span 
<span class=special> )</span><span class=special> && </span><span class=identifier>vector&lt;<span class=keyword>int</span>&gt;</span><span class=special>( </span><span 
class=number>3</span><spanclass=special>,</span><span class=number>2</span><span 
<span class=special> )</span><span class=special> && </span><span class=identifier>vector&lt;<span class=keyword>int</span>&gt;</span><span class=special>( </span><span 
class=number>3</span><span class=special>,</span><span class=number>3</span><span class=special> )</span><span>;</span>
</pre>
</p> </ul>



<p>
    These lists are particularly useful in
    learning, testing, and prototyping situations, but can also be handy otherwise. 
      The library comes with predefined operators for the containers of the  
      standard library, but most functionality will work with any standard 
compliant container. The library also makes it possible to extend user
  defined types so for example a member function can be called for a list of 
values instead of its normal arguments. </p>
   <hr>
   
   <a name="tutorial"></a>
   <h2>Tutorial</h2>
   <p>
   Within two minutes you should be able to use this library. The main 
components are explained in these sections:
        <a href="#tutorial" >Tutorial</a>
        <ul>
            <li>Function <a href="#operator+="><code>operator+=()</code></a>
            <li>Function <a href="#operator()"><code>operator()()</code></a>
            <li>Function <a href="#list_of"><code>list_of()</code></a>    
            <li>Function <a href="#map_list_of"><code>map_list_of()</code></a> 
            <li>Function <a href="#tuple_list_of"><code>tuple_list_of()</code></a>
            <li>Functions <a href="#repeat"><code>repeat()</code></a>, <a href="#repeat"><code>repeat_fun()</code></a> and <a href="#repeat"><code>range()</code> </a>
            <li>Function <a href="#chain"><code>operator&&</code></a>
            <li>Functions <a href="#ref_list_of"><code>ref_list_of()</code></a>, <a href="#ref_list_of"><code>cref_list_of()</code></a> and variants   
            <li>Functions <a href="#ref_csv"><code>ref_csv()</code></a>, <a href="#ref_csv"><code>cref_csv()</code></a> and variants   
            <li>A <a href="#complicated">"complicated"</a> example    
            <li>Functions <a href="#ptr_push_back"><code>ptr_push_back()</code></a>, <a href="#ptr_push_back"><code>ptr_push_front()</code></a>, 
                                                   <a href="#ptr_push_back"><code>ptr_insert()</code></a> and <a href="#ptr_push_back"><code>ptr_map_insert()</code></a>
            <li>Function <a href="#ptr_list_of"><code>ptr_list_of()</code></a>         
       </ul>           
   The two first functions are used for adding elements after a container object
   has been created whereas the next two is used when we need to initialize an 
   object. </p>
   <h3>Function <code>operator+=()</code><a name="operator+="></h3>
   <p>
    To fill a vector (or any standard container) with values using 
    <code>operator+=()</code> you write   
    <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>vector</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'operator+=()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;; 
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'operator+=()' into scope
</span><span class=special>
</span><span class=special>{
    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>values</span><span class=special>;  
    </span><span class=identifier>values </span><span class=special>+= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>,</span><span class=number>4</span><span class=special>,</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>; </span><span class=comment>// insert values at the end of the container
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>values</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>9 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>values</span><span class=special>[</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>values</span><span class=special>[</span><span class=number>8</span><span class=special>] </span><span class=special>== </span><span class=number>9 </span><span class=special>);
</span><span class=special>}</span></pre></blockquote>

    Here we only stuffed constants into the container, but the list can
    consists of arbitrary expressions as long as the result of each  
expression is convertible to the <code>value_type</code> of the container.
   </p> 
   
   <h3>Function <code>operator()()</code> <a name="operator()"></h3>
   <p>
   We do not call <code>operator()()</code> directly, but instead we call a 
   function that returns a proxy-object that defines <code>operator()()</code>.
   The function that returns the proxy object is always named after the member
   function that is used to copy the values in the list into the container.
   So to fill a map with pairs of values you write 
   <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span 
class=identifier>boost</span><span class=special>/</span><span 
class=identifier>assign</span><span class=special>/</span><span 
class=identifier>list_inserter</span><span class=special>.</span><span 
class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'insert()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'insert()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=identifier>map</span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>months</span><span class=special>;  
    </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>months </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;january&quot;</span><span class=special>,   </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;february&quot;</span><span class=special>, </span><span class=number>28 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;march&quot;</span><span class=special>,     </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;april&quot;</span><span class=special>,    </span><span class=number>30 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;may&quot;</span><span class=special>,       </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;june&quot;</span><span class=special>,     </span><span class=number>30 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;july&quot;</span><span class=special>,      </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;august&quot;</span><span class=special>,   </span><span class=number>31 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;september&quot;</span><span class=special>, </span><span class=number>30 </span><span class=special>)( </span><span class=string>&quot;october&quot;</span><span class=special>,  </span><span class=number>31 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;november&quot;</span><span class=special>,  </span><span class=number>30 </span><span class=special>)( </span><span class=string>&quot;december&quot;</span><span class=special>, </span><span class=number>31 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>months</span><span class=special>.</span><span 
class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>12 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>months</span><span class=special>[</span><span class=string>&quot;january&quot;</span><span class=special>] </span><span class=special>== </span><span class=number>31 </span><span class=special>);
</span><span class=special>}</span> </pre></blockquote>

   Note that <code>operator()()</code> is much more handy when
   we need to construct objects using several arguments
   (up to five arguments are supported by default, but the limit can be <a href="#limit">customized</a>).
    This is also true for sequences:

      <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span 
class=identifier>boost</span><span class=special>/</span><span 
class=identifier>assign</span><span class=special>/</span>list_inserter</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'push_front()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>utility</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'push_front()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=keyword>typedef </span><span class=identifier>pair</span><span class=special>&lt; </span><span class=identifier>string</span><span class=special>,</span><span class=identifier>string </span><span class=special>&gt; </span><span class=identifier>str_pair</span><span class=special>;
    </span><span class=identifier>deque</span><span class=special>&lt;</span><span class=identifier>str_pair</span><span class=special>&gt; </span><span class=identifier>deq</span><span class=special>;
    </span><span class=identifier>push_front</span><span class=special>( </span><span class=identifier>deq </span><span class=special>)( </span><span class=string>&quot;foo&quot;</span><span class=special>, </span><span class=string>&quot;bar&quot;</span><span class=special>)( </span><span class=string>&quot;boo&quot;</span><span class=special>, </span><span class=string>&quot;far&quot; </span><span class=special>); 
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>2 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>front</span><span class=special>().</span><span class=identifier>first </span><span class=special>== </span><span class=string>&quot;boo&quot; </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>back</span><span class=special>().</span><span class=identifier>second </span><span class=special>== </span><span class=string>&quot;bar&quot; </span><span class=special>);
</span><span class=special>}   </span></pre></blockquote>

   Besides <code>push_front()</code> we could also have used
   <code>push_back()</code> if the container has a corresponding member
   function. Empty parentheses can be used to insert default-constructed 
objects, for example, 
<code>push_front( deq )()()</code> will insert two default-constructed 
<code>str_pair</code> objects. </p>   
   
   <p>
   If <code>operator()()</code> is too cumbersome to use with eg. 
<code>push_front()</code>we can also say </p>

<blockquote>
    <pre>
<span class=identifier>deque</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>di</span><span class=special>;    </span>
<span class=identifier>push_front</span><span class=special>( </span><span class=identifier>di </span><span class=special>) </span><span class=special>= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>,</span><span class=number>4</span><span class=special>,</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>;</span>
<span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>di</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>9 </span><span class=special>);    </span>
<span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span 
class=identifier>di</span><span class=special>[</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>9 </span><span class=special>);    </span>
</pre>
</blockquote>
<p>
Just to make it perfectly clear, the code above is not restricted to the 
standard containers, but will work with all <i>standard compliant</i> containers 
with the right member function. It is only <code>operator+=()</code> that has been restricted to 
the standard containers. </p>
  
  <h3>Function <code>list_of()</code> <a name="list_of"></h3>
  But what if we need to <i>initialize</i> a container? This is where 
  <code>list_of()</code> comes into play. With <code>list_of()</code>
  we can create anonymous lists that automatically converts to
  any container:
  <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'list_of()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>list</span><span class=special>&gt;
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>stack</span><span class=special>&gt;
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'list_of()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=keyword>const </span><span class=identifier>list</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>primes </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>5</span><span class=special>)(</span><span class=number>7</span><span class=special>)(</span><span class=number>11</span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>primes</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>5 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>primes</span><span class=special>.</span><span class=identifier>back</span><span class=special>() </span><span class=special>== </span><span class=number>11 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>primes</span><span class=special>.</span><span class=identifier>front</span><span class=special>() </span><span class=special>== </span><span class=number>2 </span><span class=special>);
   
    </span><span class=keyword>const </span><span 
class=identifier>stack</span><span class=special>&lt;</span><span 
class=identifier>string</span><span class=special>&gt; </span><span 
class=identifier>names </span><span class=special>= </span><span 
class=special></span><span class=identifier>list_of</span><span class=special>( </span><span class=string>&quot;Mr. Foo&quot; </span><span class=special>)( </span><span class=string>&quot;Mr. Bar&quot;</span><span class=special>)( </span><span class=string>&quot;Mrs. FooBar&quot; </span><span
class=special>).</span><span class=identifier>to_adapter();
    </span><span class=keyword>const </span><span 
class=identifier>stack</span><span class=special>&lt;</span><span 
class=identifier>string</span><span class=special>&gt; </span><span 
class=identifier>names2 </span><span class=special>= </span><span 
class=special>(</span><span class=identifier>list_of</span><span class=special>( </span><span class=string>&quot;Mr. Foo&quot; </span><span class=special>), </span><span class=string>&quot;Mr. Bar&quot;</span><span class=special>, </span><span class=string>&quot;Mrs. FooBar&quot; </span><span
class=special>).</span><span class=identifier>to_adapter();
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>names</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>names</span><span class=special>.</span><span class=identifier>top</span><span class=special>()</span><span class=special> == </span><span class=string>&quot;Mrs. FooBar&quot; </span><span class=special>);
</span><span class=special>}   </span></pre></blockquote>
  If we need to initialize a container adapter, we need to help the compiler a 
little by calling <code>to_adapter()</code>. As the second example also shows, 
we can use a comma-separated
list with <code>list_of()</code> if we add parenthesis around the 
  entire right hand side. It is worth noticing that the first argument
  of <code>list_of()</code> determines the type of the anonymous list.
  In case of the stack, the anonymous list consists of
  <code>const char*</code> objects which are then converted to 
  a stack of <code>string</code> objects. The conversion is always  
  possible as long as the conversion between the stored types is possible.
 </p>
 <p>
 Please notice that <code>list_of()</code> can even convert to a 
 <code>boost::<a 
href="../../array/index.html">array</a>&lt;T,sz></code> and see also the list 
of <a href="#boost_libs">supported libraries </a>. </p>
           <p>
               Note that the type returned by 
               <code>list_of()</code> (and its variants) has overloaded comparison operators. This allows you to
               write test code such as 
                   <code>
                       BOOST_CHECK_EQUAL( my_container, list_of(2)(3)(4)(5) );.
                   </code>
               </p>
 
 <h3>Function <code>map_list_of()</code> <a name="map_list_of"></h3>
 This function is defined for pure convenience when working with
 maps. Its usage is simple:
 <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'map_list_of()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>map</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'map_list_of()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>next </span><span class=special>= </span><span class=identifier>map_list_of</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>)(</span><span class=number>3</span><span class=special>,</span><span class=number>4</span><span class=special>)(</span><span class=number>4</span><span class=special>,</span><span class=number>5</span><span class=special>)(</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>5 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>1 </span><span class=special>] </span><span class=special>== </span><span class=number>2 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>5 </span><span class=special>] </span><span class=special>== </span><span class=number>6 </span><span class=special>);
    
    </span><span class=comment>// or we can use 'list_of()' by specifying what type
    // the list consists of
    </span><span class=identifier>next </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>&lt; </span><span class=identifier>pair</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=special>&gt;(</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>)(</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>)(</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>6 </span><span class=special>] </span><span class=special>== </span><span class=number>7 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>8 </span><span class=special>] </span><span class=special>== </span><span class=number>9 </span><span class=special>);      
</span><span class=special>}   </span></pre></blockquote>

The function <code>pair_list_of()</code> may also be used.

<h3>Function <code>tuple_list_of()</code> <a name="tuple_list_of"></h3>

If you are working with tuples, it might be convenient to use 
<code>tuple_list_of()</code>:


<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>vector</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
</span>
<span class=special>{
    </span><span class=keyword>typedef </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>tuple</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>tuple</span><span class=special>;

    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>tuple</span><span class=special>&gt; </span><span class=identifier>v </span><span class=special>= </span><span class=identifier>tuple_list_of</span><span class=special>( </span><span class=number>1</span><span class=special>, </span><span class=string>&quot;foo&quot;</span><span class=special>, </span><span class=number>2 </span><span class=special>)( </span><span class=number>3</span><span class=special>, </span><span class=string>&quot;bar&quot;</span><span class=special>, </span><span class=number>4 </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>2 </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK</span><span class=special>( </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>get</span><span class=special>&lt;</span><span class=number>0</span><span class=special>&gt;( </span><span class=identifier>v</span><span class=special>[</span><span class=number>1</span><span class=special>] </span><span class=special>) </span><span class=special>==  </span><span class=number>3 </span><span class=special>);</span>
<span class=special>}</span>
    </pre>
</blockquote>

<h3>Functions <code>repeat()</code>, <code>repeat_fun()</code> and <code>range()</code> <a name="repeat"></h3> 
<p>
Sometimes it is too irritating to repeat the same value many times. This is 
where <code>repeat()</code> can be handy:
<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>vector</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;</span>
<span class=special> </span>
<span class=special>{
    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>v</span><span class=special>;
    </span><span class=identifier>v </span><span class=special>+= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>,</span><span class=identifier>repeat</span><span class=special>(</span><span class=number>10</span><span class=special>,</span><span class=number>4</span><span class=special>),</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>;
    </span><span class=comment>// v = [1,2,3,4,4,4,4,4,4,4,4,4,4,5,6,7,8,9]
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>+ </span><span class=number>10 </span><span class=special>+ </span><span class=number>5 </span><span class=special>);
    
    </span><span class=identifier>v </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>).</span><span class=identifier>repeat</span><span class=special>(</span><span class=number>5</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>);
    </span><span class=comment>// v = [1,2,2,2,2,2,3]
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>1 </span><span class=special>+ </span><span class=number>5 </span><span class=special>+ </span><span class=number>1 </span><span class=special>);
    
    </span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>v </span><span class=special>)(</span><span class=number>1</span><span class=special>).</span><span class=identifier>repeat</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>);
    </span><span class=comment>// v = old v + [1,2,3]
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>10 </span><span class=special>);</span>
<span class=special>}</span></pre>
</blockquote>
As we can see, then the first argument to <code>repeat()</code> is the number
of times to repeat the second argument.
</p>
<p>
A more general list can be constructed with <code>repeat_fun()</code>:

<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>vector</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>cstdlib</span><span class=special>&gt; </span><span class=comment>// for 'rand()'              
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;</span>
<span class=special> </span>
<span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;</span>
<span class=keyword>struct </span><span class=identifier>next    </span>
<span class=special>{
    </span><span class=identifier>T </span><span class=identifier>seed</span><span class=special>;
    </span><span class=identifier>next</span><span class=special>( </span><span class=identifier>T </span><span class=identifier>seed </span><span class=special>) </span><span class=special>: </span><span class=identifier>seed</span><span class=special>(</span><span class=identifier>seed</span><span class=special>) 
    </span><span class=special>{ </span><span class=special>}
    
    </span><span class=identifier>T </span><span class=keyword>operator</span><span class=special>()() </span><span class=keyword>
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>seed</span><span class=special>++;
    </span><span class=special>}</span>
<span class=special>};</span>
<span class=special>     </span>
<span class=special>{
    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>v</span><span class=special>;
    </span><span class=identifier>v </span><span class=special>+= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=identifier>repeat_fun</span><span class=special>(</span><span class=number>4</span><span class=special>,&amp;</span><span class=identifier>rand</span><span class=special>),</span><span class=number>4</span><span class=special>;
    </span><span class=comment>// v = [1,2,?,?,?,?,4] 
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>7 </span><span class=special>);
    
    </span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>v </span><span class=special>).</span><span class=identifier>repeat_fun</span><span class=special>(</span><span class=number>4</span><span class=special>,</span><span class=identifier>next</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;(</span><span class=number>0</span><span class=special>))(</span><span class=number>4</span><span class=special>).</span><span class=identifier>repeat_fun</span><span class=special>(</span><span class=number>4</span><span class=special>,</span><span class=identifier>next</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;(</span><span class=number>5</span><span class=special>));
    </span><span class=comment>// v = old v + [0,1,2,3,4,5,6,7,8] 
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>16 </span><span class=special>);</span>
<span class=special>}</span>        </pre>
</blockquote>
The only requirement of the second argument to <code>repeat_fun()</code> is that 
it is a nullary function. </p>


<p>
If you just need to insert an iterator-range somewhere in the list, the member function <code>range()</code> provides just what you want.
It is based on <a href="../../range/index.html">Boost.Range</a>, so you can pass all the ranges supported by that library. For example
<blockquote><pre><span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_inserter</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span> <span class=comment>// for 'push_back()'</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span> <span class=comment>// for 'list_of()' and 'ref_list_of&lt;int&gt;()'</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>

<span class=keyword>using</span> <span class=keyword>namespace</span> <span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using</span> <span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;</span>
 
<span class=special>{</span>
    <span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;</span> <span class=identifier>v</span><span class=special>,</span> <span class=identifier>v2</span><span class=special>;</span>
    <span class=identifier>v</span>  <span class=special>=</span> <span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>);</span>
    <span class=identifier>v2</span> <span class=special>=</span> <span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>).</span><span class=identifier>range</span><span class=special>(</span><span class=identifier>v</span><span class=special>).</span><span class=identifier>range</span><span class=special>(</span><span class=identifier>v</span><span class=special>.</span><span class=identifier>begin</span><span class=special>(),</span><span class=identifier>v</span><span class=special>.</span><span class=identifier>end</span><span class=special>())(</span><span class=number>4</span><span class=special>);</span>
    <span class=comment>// v2 = [0,1,2,3,1,2,3,4]</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>v2</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>8u</span> <span class=special>);</span>

    <span class=identifier>push_back</span><span class=special>(</span> <span class=identifier>v</span> <span class=special>).</span><span class=identifier>range</span><span class=special>(</span><span class=identifier>v2</span><span class=special>)(</span><span class=number>5</span><span class=special>);</span>
    <span class=comment>// v = [1,2,3,0,1,2,3,1,2,3,4,5]</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>12u</span> <span class=special>);</span> 

    <span class=comment>//
    // create a list of references, some coming from a container, others from the stack 
    //</span>
    <span class=keyword>int</span> <span class=identifier>x</span> <span class=special>=</span> <span class=number>0</span><span class=special>;</span>
    <span class=keyword>int</span> <span class=identifier>y</span> <span class=special>=</span> <span class=number>1</span><span class=special>;</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>ref_list_of</span><span class=special>&lt;</span><span class=number>10</span><span class=special>&gt;(</span><span class=identifier>x</span><span class=special>).</span><span class=identifier>range</span><span class=special>(</span><span class=identifier>v2</span><span class=special>)(</span><span class=identifier>y</span><span class=special>).</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>10u</span> <span class=special>);</span>
<span class=special>}</span></pre>
</blockquote>
As you can see, one can also pass two iterators if that is more appropriate.
The last example also introduces list of references. More about that below.

</p>

<h3>Operator <code>&&</code><a name="chain"></h3>

While the function <a href="#repeat"><code>range()</code></a> works in combination with functions
such as <a href="#list_of"><code>list_of()</code></a>, it is not compatible with  
<a href="#ref_csv"><code>ref_csv()</code></a>, <a href="#ref_list"><code>ref_list_of()</code></a> and their variants, 
which are part of a different <a href="#concept-auto_size">framework</a>. The function <code>operator&&</code>, 
achieves a similar goal by chaining <a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html">ranges</a> at <a href="#concept-auto_size">compile time</a>, which is typically the faster option. 
Continuing the <a href="#repeat">example</code></a> above,


<blockquote><pre><span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>auto_size</span><span class=special>/</span><span class=identifier>chain</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span> 
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>auto_size</span><span class=special>/</span><span class=identifier>ref_list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
 
<span class=special>{</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=special>(</span> <span class=identifier>cref_list_of</span>( </span><span class=identifier>x</span><span class=special> )</span><span class=special>&&</span><span class=identifier> v2</span><span class=special> && </span><span class=identifier>cref_list_of</span>(</span><span class=identifier> y </span><span class=special>)</span> <span class=special>)</span><span class=special>.</span><span class=identifier>size</span><span class=special>(</span><span class=special>)</span><span class=special> == </span><span class=number>10u</span><span class=special> )</span><span class=special>;</span>
<span class=special>}</span></pre>
</blockquote>

<h3>Functions <code>ref_list_of()</code>, <code>cref_list_of()</code> and variants<a name="ref_list_of"></h3>

When you need to create an anonymous range of values and speed is essential, 
these two functions provide what you want. <blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>auto_size</span><span class=special>/</span><span class=identifier>ref_list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>range</span><span class=special>/</span><span class=identifier>algorithm</span><span class=special>/</span><span class=identifier>max_element</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
</span>
<span class=special>{
    </span><span class=keyword>int </span><span class=identifier>a</span><span class=special>=</span><span class=number>1</span><span class=special>,</span><span class=identifier>b</span><span class=special>=</span><span class=number>5</span><span class=special>,</span><span class=identifier>c</span><span class=special>=</span><span class=number>3</span><span class=special>,</span><span class=identifier>d</span><span class=special>=</span><span class=number>4</span><span class=special>,</span><span class=identifier>e</span><span class=special>=</span><span class=number>2</span><span class=special>,</span><span class=identifier>f</span><span class=special>=</span><span class=number>9</span><span class=special>,</span><span class=identifier>g</span><span class=special>=</span><span class=number>0</span><span class=special>,</span><span class=identifier>h</span><span class=special>=</span><span class=number>7</span><span class=special>;
    </span><span class=keyword>int</span><span class=special>&amp; </span><span class=identifier>max </span><span class=special>= </span><span class=special>*</span><span class=identifier>boost::max_element</span><span class=special>( </span><span class=identifier>ref_list_of</span><span class=special>(</span><span class=identifier>a</span><span class=special>)(</span><span class=identifier>b</span><span class=special>)(</span><span class=identifier>c</span><span class=special>)(</span><span class=identifier>d</span><span class=special>)(</span><span class=identifier>e</span><span class=special>)(</span><span class=identifier>f</span><span class=special>)(</span><span class=identifier>g</span><span class=special>)(</span><span class=identifier>h</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK_EQUAL</span><span class=special>( </span><span class=identifier>max</span><span class=special>, </span><span class=identifier>f </span><span class=special>);
    </span><span class=identifier>max </span><span class=special>= </span><span class=number>8</span><span class=special>;
    </span><span class=identifier>BOOST_CHECK_EQUAL</span><span class=special>( </span><span class=identifier>f</span><span class=special>, </span><span class=number>8 </span><span class=special>);
    </span><span class=keyword>const </span><span class=keyword>int</span><span class=special>&amp; </span><span class=identifier>const_max </span>
    	<span class=special>= </span><span class=special>*</span><span class=identifier>boost::max_element</span><span class=special>( </span><span class=identifier>cref_list_of</span><span class=special>(</span><span class=identifier>1</span><span class=special>)(</span><span class=identifier>5</span><span class=special>)(</span><span class=identifier>3</span><span class=special>)(</span><span class=identifier>d</span><span class=special>)(</span><span class=identifier>e</span><span class=special>)(</span><span class=identifier>f</span><span class=special>)(</span><span class=identifier>g</span><span class=special>)(</span><span class=identifier>h</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK_EQUAL</span><span class=special>( </span><span class=identifier>max</span><span class=special>, </span><span class=identifier>const_max </span><span class=special>);</span>
<span class=special>}</span>
    </pre>
</blockquote>

You can only use lvalues with <code>ref_list_of()</code> while 
<code>cref_list_of()</code> accepts rvalues too, as exemplified by the first three arguments of the 
corresponding function call in this example. 

<p> A collection built from <code>ref_list_of()</code> and <code>cref_list_of()</code> has most of the functionality of <code>boost::array<></code>, and 
the same conversion capabilities as a collection built from <code>list_of()</code>. However, the user can customize his own functionality via a policy and 
call it with the overloaded functions <code>ref_list_of&lt;P&gt;()</code> and <code>cref_list_of&lt;P&gt;()</code>, where <code>P</code> is an associated policy tag. 
See the <a href="#ref-ref_list_of">reference</a> for details
</p>

<p>
There are overloads which predate the above functions,
<code>ref_list_of&lt;int&gt;()</code> and <code>cref_list_of&lt;int&gt;()</code>, whose integer template parameter specifies the maximum number of arguments. 
The resulting collection exposes a similar interface to that above, save for the specifics of an array, and is not customizable via a policy.
See the <a href="#ref-list_of">reference</a> for details
</p>

<p>
A variation on <code>ref_list_of()</code> and <code>cref_list_of()</code>, are <code>ref_rebind_list_of()</code> and <code>cref_rebind_list_of()</code>, respectively, 
that have rebind, rather than copy semantics, when the collection is used as the left hand side of an assignement. 
Their use is discouraged unless this specific feature is required. See the <a href="#ref-ref_list_of">reference</a>.
</p>

<h3>Functions <code>ref_csv()</code>, <code>cref_csv()</code> <a name="ref_csv"> and variants</h3>

The functions <a href="#ref_list_of"><code>ref_list_of()</code></a>, <a href="#ref_list_of"><code>cref_list_of()</code></a>, 
their respective rebind analogs, and the custom policy overloads of these four, have counterparts that are identified by suffix 'csv' (comma separated values) 
instead of 'list_of'. For example,
<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>auto_size</span><span class=special>/</span><span class=identifier>ref_csv</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>range</span><span class=special>/</span><span class=identifier>algorithm</span><span class=special>/</span><span class=identifier>max_element</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
</span>
<span class=special>{
    </span><span class=keyword>int </span><span class=identifier>a</span><span class=special>=</span><span class=number>1</span><span class=special>,</span><span class=identifier>b</span><span class=special>=</span><span class=number>5</span><span class=special>,</span><span class=identifier>c</span><span class=special>=</span><span class=number>3</span><span class=special>,</span><span class=identifier>d</span><span class=special>=</span><span class=number>4</span><span class=special>,</span><span class=identifier>e</span><span class=special>=</span><span class=number>2</span><span class=special>,</span><span class=identifier>f</span><span class=special>=</span><span class=number>9</span><span class=special>,</span><span class=identifier>g</span><span class=special>=</span><span class=number>0</span><span class=special>,</span><span class=identifier>h</span><span class=special>=</span><span class=number>7</span><span class=special>;
    </span><span class=keyword>int</span><span class=special>&amp; </span><span class=identifier>max </span><span class=special>= </span><span class=special>*</span><span class=identifier>boost::max_element</span><span class=special>( </span><span class=identifier>ref_csv</span><span class=special>(</span><span class=identifier>a</span><span class=special>,</span><span class=identifier>b</span><span class=special>,</span><span class=identifier>c</span><span class=special>,</span><span class=identifier>d</span><span class=special>,</span><span class=identifier>e</span><span class=special>,</span><span class=identifier>f</span><span class=special>,</span><span class=identifier>g</span><span class=special>,</span><span class=identifier>h</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK_EQUAL</span><span class=special>( </span><span class=identifier>max</span><span class=special>, </span><span class=identifier>f </span><span class=special>);
}</span>
    </pre>
</blockquote>

<p> The result of a csv call has the same array and conversion capabilities as its non-csv counterpart. 
The main difference is that the the collection is not extensible. See the <a href="#ref-ref_csv">reference</a>.</p>

<p> The maximum number of arguments to a csv function is <code>BOOST_ASSIGN_CSV_SIZE</code>. </p>

<h3>A "complicated" example <a name="complicated"></h3>
<p> 
As a last example, let us assume that we need to keep track of the
result of soccer matches. A team will get one point if it wins 
and zero otherwise. If there has been played three games in each group, the code might look
like this:

<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span 
class=identifier>boost</span><span class=special>/</span><span 
class=identifier>assign</span><span class=special>/</span><span 
class=identifier>list_inserter</span><span class=special>.</span><span 
class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>vector</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
 </span>
<span class=special>{
    </span><span class=keyword>typedef </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;                   </span><span class=identifier>score_type</span><span class=special>;
    </span><span class=keyword>typedef </span><span class=identifier>map</span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>,</span><span class=identifier>score_type</span><span class=special>&gt;        </span><span class=identifier>team_score_map</span><span class=special>;
    </span><span class=keyword>typedef </span><span class=identifier>pair</span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>,</span><span class=identifier>score_type</span><span class=special>&gt;       </span><span class=identifier>score_pair</span><span class=special>;

    </span><span class=identifier>team_score_map </span><span class=identifier>group1</span><span class=special>, </span><span class=identifier>group2</span><span class=special>;
    
    </span><span class=comment>//
    // method 1: using 'insert()'
    //
    </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>group1 </span><span class=special>)( </span><span class=string>&quot;Denmark&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>1</span><span class=special>) </span><span class=special>)
                    </span><span class=special>( </span><span class=string>&quot;Germany&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>)(</span><span class=number>0</span><span class=special>) </span><span class=special>)
                    </span><span class=special>( </span><span class=string>&quot;England&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>)(</span><span class=number>1</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group1</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group1</span><span class=special>[ </span><span class=string>&quot;Denmark&quot; </span><span class=special>][</span><span class=number>1</span><span class=special>] </span><span class=special>== </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group1</span><span class=special>[ </span><span class=string>&quot;Germany&quot; </span><span class=special>][</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>0 </span><span class=special>);
    
    </span><span class=comment>//
    // method 2: using 'list_of()'
    //
    </span><span class=identifier>group2 </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>&lt; </span><span class=identifier>score_pair </span><span class=special>&gt;
                        </span><span class=special>( </span><span class=string>&quot;Norway&quot;</span><span class=special>,  </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>0</span><span class=special>) </span><span class=special>)
                        </span><span class=special>( </span><span class=string>&quot;USA&quot;</span><span class=special>,     </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>)(</span><span class=number>0</span><span class=special>) </span><span class=special>)
                        </span><span class=special>( </span><span class=string>&quot;Andorra&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>1</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group2</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group2</span><span class=special>[ </span><span class=string>&quot;Norway&quot; </span><span class=special>][</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group2</span><span class=special>[ </span><span class=string>&quot;USA&quot; </span><span class=special>][</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>0 </span><span class=special>);</span>
<span class=special>}</span>
    </pre>
</blockquote>

In the first example, notice how the result of <code>list_of()</code>
can be converted automatically to a <code>vector&lt;int></code> because
<code>insert()</code> knows it expects a <code>vector&lt;int></code>.
In the second example we can see that <code>list_of()</code> is somewhat
less intelligent since here it needs to be told explicitly what arguments to
expect. (In the future it might be possible to introduce a more intelligent
conversion layer in <code>list_of()</code>.)
</p>

<h3>Functions <code>ptr_push_back(), 
ptr_push_front()</code>, <code>ptr_insert()</code> and <code>ptr_map_insert()</code> <a name="ptr_push_back"></h3>

For use with <a href="../../ptr_container/index.html">Boost.Pointer Container</a>
a few special exception-safe functions are provided. Using these function you
do not need to call <code>new</code> manually:


<blockquote>
    <pre>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>ptr_list_inserter</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span> <span class=comment>// for 'ptr_push_back()', 'ptr_insert()' and 'ptr_push_front()'</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>ptr_map_inserter</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>  <span class=comment>// for 'ptr_map_insert()'</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>ptr_container</span><span class=special>/</span><span class=identifier>ptr_deque</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>ptr_container</span><span class=special>/</span><span class=identifier>ptr_set</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>ptr_container</span><span class=special>/</span><span class=identifier>ptr_map</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>

<span class=comment>//
// Example class
//</span>
<span class=keyword>struct</span> <span class=identifier>Foo</span>
<span class=special>{</span>
    <span class=keyword>int</span> <span class=identifier>i</span><span class=special>;</span>
    
    <span class=identifier>Foo</span><span class=special>()</span> <span class=special>:</span> <span class=identifier>i</span><span class=special>(</span><span class=number>0</span><span class=special>)</span>
    <span class=special>{</span> <span class=special>}</span>
    <span class=identifier>Foo</span><span class=special>(</span> <span class=keyword>int</span> <span class=identifier>i</span> <span class=special>)</span> <span class=special>:</span> <span class=identifier>i</span><span class=special>(</span><span class=identifier>i</span><span class=special>)</span>
    <span class=special>{</span> <span class=special>}</span>
    <span class=identifier>Foo</span><span class=special>(</span> <span class=keyword>int</span> <span class=identifier>i</span><span class=special>,</span> <span class=keyword>int</span> <span class=special>)</span> <span class=special>:</span> <span class=identifier>i</span><span class=special>(</span><span class=identifier>i</span><span class=special>)</span>
    <span class=special>{</span> <span class=special>}</span>
    <span class=identifier>Foo</span><span class=special>(</span> <span class=keyword>const</span> <span class=keyword>char</span><span class=special>*,</span> <span class=keyword>int</span> <span class=identifier>i</span><span class=special>,</span> <span class=keyword>int</span> <span class=special>)</span> <span class=special>:</span> <span class=identifier>i</span><span class=special>(</span><span class=identifier>i</span><span class=special>)</span>
    <span class=special>{</span> <span class=special>}</span>

    <span class=keyword>virtual</span> <span class=special>~</span><span class=identifier>Foo</span><span class=special>()</span>
    <span class=special>{}</span>
<span class=special>};</span>

<span class=keyword>struct</span> <span class=identifier>Bar</span> <span class=special>:</span> <span class=identifier>Foo</span>
<span class=special>{</span>
    <span class=identifier>Bar</span><span class=special>()</span>
    <span class=special>{</span> <span class=special>}</span>
    
    <span class=identifier>Bar</span><span class=special>(</span> <span class=keyword>int</span> <span class=identifier>i</span> <span class=special>)</span> <span class=special>:</span> <span class=identifier>Foo</span><span class=special>(</span> <span class=number>42</span> <span class=special>)</span>
    <span class=special>{</span> <span class=special>}</span>
<span class=special>};</span>

<span class=comment>//
// Required by ptr_set&lt;Foo&gt;
//</span>
<span class=keyword>inline</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>&lt;(</span> <span class=identifier>Foo</span> <span class=identifier>l</span><span class=special>,</span> <span class=identifier>Foo</span> <span class=identifier>r</span> <span class=special>)</span>
<span class=special>{</span>
    <span class=keyword>return</span> <span class=identifier>l</span><span class=special>.</span><span class=identifier>i</span> <span class=special>&lt;</span> <span class=identifier>r</span><span class=special>.</span><span class=identifier>i</span><span class=special>;</span>
<span class=special>}</span>

 
<span class=keyword>using</span> <span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>;</span>
<span class=keyword>using</span> <span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;</span>

<span class=keyword>int</span> <span class=identifier>main</span><span class=special>()</span>
<span class=special>{</span>
    <span class=identifier>ptr_deque</span><span class=special>&lt;</span><span class=identifier>Foo</span><span class=special>&gt;</span> <span class=identifier>deq</span><span class=special>;</span>
    <span class=identifier>ptr_push_back</span><span class=special>(</span> <span class=identifier>deq</span> <span class=special>)()();</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>2u</span> <span class=special>);</span>
    <span class=identifier>ptr_push_back</span><span class=special>&lt;</span><span class=identifier>Bar</span><span class=special>&gt;(</span> <span class=identifier>deq</span> <span class=special>)()();</span> <span class=comment>// insert 'Bar' objects</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>4u</span> <span class=special>);</span>
    <span class=identifier>ptr_push_front</span><span class=special>(</span> <span class=identifier>deq</span> <span class=special>)(</span> <span class=number>3</span> <span class=special>)(</span> <span class=number>42</span><span class=special>,</span> <span class=number>42</span> <span class=special>)(</span> <span class=string>&quot;foo&quot;</span><span class=special>,</span> <span class=number>42</span><span class=special>,</span> <span class=number>42</span> <span class=special>);</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>7u</span> <span class=special>);</span>

    <span class=identifier>ptr_set</span><span class=special>&lt;</span><span class=identifier>Foo</span><span class=special>&gt;</span> <span class=identifier>a_set</span><span class=special>;</span>
    <span class=identifier>ptr_insert</span><span class=special>(</span> <span class=identifier>a_set</span> <span class=special>)()(</span> <span class=number>1</span> <span class=special>)(</span> <span class=number>2</span><span class=special>,</span> <span class=number>2</span> <span class=special>)(</span> <span class=string>&quot;foo&quot;</span><span class=special>,</span> <span class=number>3</span><span class=special>,</span> <span class=number>3</span> <span class=special>);</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>a_set</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>4u</span> <span class=special>);</span>
    <span class=identifier>ptr_insert</span><span class=special>(</span> <span class=identifier>a_set</span> <span class=special>)()()()();</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>a_set</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>4u</span> <span class=special>);</span> <span class=comment>// duplicates not inserted</span>
    <span class=identifier>ptr_insert</span><span class=special>&lt;</span><span class=identifier>Bar</span><span class=special>&gt;(</span> <span class=identifier>a_set</span> <span class=special>)(</span> <span class=number>42</span> <span class=special>);</span> <span class=comment>// insert a 'Bar' object</span> 
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>a_set</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>5u</span> <span class=special>);</span>

    <span class=identifier>ptr_map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=identifier>Foo</span><span class=special>&gt;</span> <span class=identifier>a_map</span><span class=special>;</span>
    <span class=identifier>ptr_map_insert</span><span class=special>(</span> <span class=identifier>a_map</span> <span class=special>)(</span> <span class=number>1</span> <span class=special>)(</span> <span class=number>2</span><span class=special>,</span> <span class=number>2</span> <span class=special>)(</span> <span class=number>3</span><span class=special>,</span> <span class=number>3</span><span class=special>,</span> <span class=number>3</span> <span class=special>)(</span> <span class=number>4</span><span class=special>,</span> <span class=string>&quot;foo&quot;</span><span class=special>,</span> <span class=number>4</span><span class=special>,</span> <span class=number>4</span> <span class=special>);</span>
    <span class=identifier>ptr_map_insert</span><span class=special>&lt;</span><span class=identifier>Bar</span><span class=special>&gt;(</span> <span class=identifier>a_map</span> <span class=special>)(</span> <span class=number>42</span><span class=special>,</span> <span class=number>42</span> <span class=special>);</span> <span class=comment>// insert a  'Bar' object</span>
<span class=special>}</span>
    </pre>
</blockquote>

Notice how you may provide a template argument to these functions. This argument determines the type to allocate with <code>new</code>.
You have to specify this argument when the container is based on an abstract type (because one cannot create objects of such a type).

<p>
For <code>ptr_map_insert()</code> the first argument <code>arg1</code> in an argument tuple <code>(arg1,arg2,...,argN)</code> is used to
construct a key; this means that the first argument need only be convertible to the <code>key_type</code> of the container.
The rest of the arguments are used to construct the mapped object.
</p>
                        
<h3>Function <code>ptr_list_of()</code> <a name="ptr_list_of"></h3>         

Just like you can use <code>list_of()</code> to initialize containers, you can 
use <code>ptr_list_of()</code> to initialize a <a href="../../ptr_container/index.html">pointer container</a>.
Here is a small example:

<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>ptr_list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>ptr_container</span><span class=special>/</span><span class=identifier>ptr_deque</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
</span>
<span class=special>{
    </span><span class=identifier>ptr_deque</span><span class=special>&lt;</span><span class=identifier>Foo</span><span class=special>&gt; </span><span class=identifier>deq</span><span class=special>;
    </span><span class=identifier>deq </span><span class=special>= </span><span class=identifier>ptr_list_of</span><span class=special>&lt;</span><span class=identifier>Foo</span><span class=special>&gt;( </span><span class=number>42 </span><span class=special>)()()( </span><span class=number>3</span><span class=special>, </span><span class=number>3 </span><span class=special>)( </span><span class=string>&quot;foo&quot;</span><span class=special>, </span><span class=number>2</span><span class=special>, </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>5 </span><span class=special>);</span>
<span class=special>}</span>    
    </pre>
</blockquote>

Notice that a trailing <code>.to_container(deq)</code> may be added to help many poor 
compilers to figure out the conversion (a few get it right). 
Notice also that pointer maps are 
not supported.

<p>
That is all; now you are ready to use this library.
 </p>

  <hr> 
  
  <h2><a name="design">Design</a></h2>

    <p>
  This section explains the way the library is implemented.
  A free-standing function (eg. <code>push_back()</code>
  or <code>operator+=()</code>) returns a proxy
  object which is responsible for the insertion or the assignment. The proxy 
object does the insertion or assignment by overloading <code>operator,()</code>
  and <code>operator()()</code> and by calling the "insert" function from within 
  those operators. The "insert" function is typically stored in the proxy object 
  by using <code>boost::<a href="../../function/index.html">function</a></code>. </p>
  
  <p>
  Often overloading
  of <code>operator,()</code> is discouraged because it can lead to surprising
  results, but the approach taken in this library is safe since the
  user never deals with objects that have overloaded <code>operator,()</code>
  directly. However, you should be aware of this:
  </p>
  
  <p><i>
  The 
  expressions in a comma-separated list no longer follow the rules of the 
  built-in comma-operator. This means that the order of evaluation of 
  expressions in a comma-separated list is undefined like when one specifies 
  a list of function arguments.
  </i></p>
  
    <p>
  Most of the code in this document use <code>int</code> in the examples, 
  but of course it works for arbitrary types as long as they are 
  Copy Constructible. The inserted data need not be constant data,
  but can be variables or data returned from functions; the only requirement 
  is that the type of the data is convertible to the type stored in the 
  container. 
  </p>
  
  <p>
  All forwarding is done by passing objects by <code>const</code> reference. 
Originally arguments were passed by value (and still is in 
<code>tuple_list_of()</code>). One thing to remember is that references
  can be passed by using <code>boost::<a href="http://www.boost.org/doc/html/ref.html">ref</a></code>.
  </p>

  <p>
   The functions, operators and their proxy objects are by defaut in namespace <code>boost::assign</code>. 
  </p>

  <h2>Functions and operators <a name="ref-functions"> </h2>

  <h3>Contents</h3>

      <ul>
        <li><a href="#ref-function-headers">Headers</a></li>
        <li>Functions <a href="#ref-list_of"><code>list_of()</code></a></li>
        <li>Functions <a href="#ref-map_list_of"><code>map_list_of()</code></a></li>
        <li>Functions <a href="#ref-ref_list_of_int"><code>ref_list_of<code>&lt;int&gt;()</code></a></li>
        <li>Function <a href="#ref-make_list_inserter"><code>make_list_inserter()</code></a></li>
        <li>Functions <a href="#ref-ref_list_of"><code>ref_list_of()</code></a>, <a href="#ref-ref_list_of"><code>cref_list_of()</code></a>, and variants</li>
        <li>Functions <a href="#ref-ref_csv"><code>ref_csv()</code></a>, <a href="#ref-ref_csv"><code>cref_csv()</code></a>, and variants</li>
        <li>Operator <a href="#ref-std"><code>+=</code></a> for standard containers</li>
        <li>Functions <a href="#ref-repeat"><code>repeat()</code></a>, <a href="#ref-repeat"><code>repeat_fun()</code></a> and <a href="#ref-repeat"><code>range()</code></a></li>
        <li>Operator <a href="#ref-chain"><code>&&</code></a></li>
        <li><a href="#ref-limit">Customizing</a> argument list sizes </li>
     </ul>

  <h3>Headers <a name="ref-function-headers"></h3>      
  
  <p>Please notice <code>&lt;boost/assign/list_inserter.hpp></code> is included for each header that defines <code>operator+=()</code>.</p>

<table cellpadding=5 border=1 > <tr>
         <th>  Header                      </th>
         <th>        Includes              </th> 
     <tr>
         <td> &lt;boost/assign.hpp>               </td>
         <td>     everything except support for pointer containers and functions returning <a href="#concept-auto_size">auto-size</a> proxy objects  </td>
     <tr>
         <td> &lt;boost/assign/auto_size.hpp>               </td>
         <td>     All functions returning <a href="#concept-auto_size">auto-size</a> proxy objects.  </td>

     <tr>
         <td> &lt;boost/assign/auto_size/range/chain_operator.hpp> </td>
         <td> <a href="#chain"><code>operator&&</code></a>

     <tr>
         <td> &lt;boost/assign/auto_size/ref_csv.hpp>               </td>
         <td>     <a href="#ref_csv"><code>ref_csv()</code> </a> and <a href="#ref_csv"><code>cref_csv()</code> </a>
     <tr>
         <td> &lt;boost/assign/auto_size/ref_rebind_csv.hpp>               </td>
         <td>     <a href="#ref_csv"><code>ref_rebind_csv()</code> </a> and <a href="#ref_csv"><code>cref_rebind_csv()</code> </a> 
     <tr>
         <td> &lt;boost/assign/auto_size/ref_list_of.hpp>               </td>
         <td>     <a href="#ref_list_of"><code>ref_list_of()</code> </a> and 
<a href="#ref_list_of"><code>cref_list_of()</code></a>  </td>
     <tr>
         <td> &lt;boost/assign/auto_size/ref_rebind_list_of.hpp>               </td>
         <td>     <a href="#ref_list_of"><code>ref_rebind_list_of()</code> </a> and 
<a href="#ref_list_of"><code>cref_rebind_list_of()</code></a>  </td>
     <tr>
         <td> &lt;boost/assign/list_of.hpp>       </td>
         <td> 
         <a href="#list_of"><code>list_of()</a>, <a href="#map_list_of">map_list_of()</code></a>, 
         <a href="#tuple_list_of">tuple_list_of()</code></a>, <a href="#ref_list_of"><code>ref_list_of&lt;int&gt;()</code> </a>
                  
         </td> <tr>
         <td> &lt;boost/assign/std.hpp>       </td>
         <td> <a href="#operator+="><code>operator+=()</code></a> for all standard containers (see below)</td> <tr> <td>  &lt;boost/assign/std/deque.hpp> </td>
        <td>  <code>operator+=()</code> for <code>std::deque</code>, <code>&lt;deque></code> 
    <tr> 
        <td>  &lt;boost/assign/std/list.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::list</code>, <code>&lt;list></code>  
    <tr> 
        <td>  &lt;boost/assign/std/map.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::map</code> and <code>std::multimap</code> , 
<code>&lt;map></code> <tr> 
        <td>  &lt;boost/assign/std/queue.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::queue</code> and <code>std::priority_queue</code>, 
<code>&lt;queue></code> <tr> 
        <td>  &lt;boost/assign/std/set.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::set</code> and <code>std::multiset</code>, 
<code>&lt;set></code> <tr> 
        <td>  &lt;boost/assign/std/slist.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::slist</code> if the class is available , 
<code>&lt;slist></code> <tr> 
        <td>  &lt;boost/assign/std/stack.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::stack</code>, <code>&lt;stack></code>  
    <tr> 
        <td>  &lt;boost/assign/std/vector.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::vector</code>, <code>&lt;vector></code>  
    <tr> 
        <td>  &lt;boost/assign/assignment_exception.hpp> </td>
        <td>  Class <a 
href="#assignment_exception"><code>assignment_exception</code></a> which might 
be thrown by the proxy returned by <code>list_of()</code>
    <tr> 
        <td>  &lt;boost/assign/list_inserter.hpp> </td>
            <td>Functions <a
               href="#ref-make_list_inserter"><code>make_list_inserter()</code></a>, <code>push_back()</code>,
                <code>push_front()</code>,<code>insert()</code>,
                <code>
                push()</code> and class <a href="#list_inserter"><code>list_inserter</code></a> 
                which is the back-bone of this entire library.

            <tr>    
            <td>  &lt;boost/assign/ptr_list_inserter.hpp> </td>
            <td>Functions <a href="#ptr_push_back"><code>ptr_push_back()</code></a>,
                <code>ptr_push_front()</code> and <code>ptr_insert()</code>
                 
            <tr>    
            <td>  &lt;boost/assign/ptr_map_inserter.hpp> </td>
            <td>Functions <a href="#ptr_push_back"><code>ptr_map_insert()</code></a>
    
                            <tr>    
            <td>  &lt;boost/assign/ptr_list_of.hpp> </td>             
            <td>Function <a href="#ptr_list_of"><code>ptr_list_of()</code></a>

    </table>

   <h3><a name="ref-limit">Customizing argument list sizes </a></h3>   
      <p>
    This library uses the boost Preprocessor Library to implement overloaded 
    versions of <code>operator()()</code> and <code>list_of()</code>. By default you 
    can call these functions with five arguments, but you can also customize this 
    number by defining a macros before including a header from this library:
       <blockquote>
       <pre>
<span class=preprocessor>#define </span><span class=identifier>BOOST_ASSIGN_MAX_PARAMS </span><span class=number>10
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
</pre>
       </blockquote>      
       </p>


  <h3><a name=ref-list_of>Function <code>list_of()</code></a></h3> 

  <h4>Template parameters</h4>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><td><tt>T</tt></td><td>Element</td></tr>
  	</table>
  </blockquote>

  <h4>Usage</h4>

  <p>Let <code>d</code> an instance of <code>const T</code>. </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result</th>
  	<tr><td><tt>list_of( d )</tt></td>         <td><a href="#ref-generic_list"><code>generic_list</code></a><code>&lt;T&gt;</code></td></tr>
  	</table>
  </blockquote>

  <h4>Synopsis</h4>
  
  <blockquote>  
  <pre><span class=keyword>namespace </span><span class=identifier>boost  </span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{</span>
                
    <span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>(</span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>T </span><span class=identifier>t </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2 </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U3 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2</span><span class=special>, </span><span class=identifier>U3 </span><span class=identifier>u3 </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U3</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U4 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2</span><span class=special>, </span><span class=identifier>U3 </span><span class=identifier>u3</span><span class=special>, </span><span class=identifier>U4 </span><span class=identifier>u4 </span><span class=special>);
  
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U3</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U4</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U5 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2</span><span class=special>, </span><span class=identifier>U3 </span><span class=identifier>u3</span><span class=special>, </span><span class=identifier>U4 </span><span class=identifier>u4</span><span class=special>, </span><span class=identifier>U5 </span><span class=identifier>u5 </span><span class=special>);

<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span>  </pre></blockquote>


  <h3><a name=ref-map_list_of>Function <code>map_list_of()</code></a></h3> 

  <h4>Template parameters</h4>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>K</tt></td><td>A key type</td></tr>
  	<tr><td><tt>T</tt></td><td>A data type</td></tr>
  	</table>
  </blockquote>

  <h4>Usage</h4>

  <p>Let <code>k</code> and <code>d</code> denote instances of <code>const K</code> and <code>const T</code>, respectively. </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result</th>
  	<tr><td><tt>map_list_of( k, d )</tt></td>  <td><a href="#ref-generic_list"><code>generic_list</code></a><code>&lt;std::pair&lt;const K, const T &gt; &gt;</code></td></tr>
  	</table>
  </blockquote>


  <h3><a name=ref-ref_list_of_int>Function <code>ref_list_of&lt;int&gt;()</code></a></h3> 

  <p> This function has been <a href="#upgrading_from_1_42">superseded</a>.</p>

  <h4>Template parameters</h4>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>N</tt></td><td>An integer</td></tr>
  	<tr><td><tt>T</tt></td><td>Element</td></tr>
  	</table>
  </blockquote>

  <b>Usage</b>

  <p>Let <code>U</code> be either <code>T</code> or <code>const T</code> and <code>d</code> an object of type <code>U</code>. 

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result</th>
  	<tr><td><tt>ref_list_of&lt;N&gt;(d)</tt></td>   <td><a href="#ref-static_generic_list"><code>static_generic_list</code></a><code>&lt;U,N&gt;</code></td></tr>
  	</table>
  </blockquote>
  
  <h3><a name="ref-make_list_inserter">Function <code>make_list_inserter()</code></a></h3>

  <p>
  A simple "constructor" function for <code>list_inserter</code>. A typical 
  use of this function is to call it with the result of 
<code>boost::bind()</code>
  which in general returns some unreadable and weird class template.
  </p>

  <b>Synopsis</b>
  
  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost </span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{  
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>Function </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt;</span><span class=identifier>Function</span><span class=special>&gt;  </span><span class=identifier>make_list_inserter</span><span class=special>( </span><span class=identifier>Function </span><span class=identifier>fun </span><span class=special>)
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>list_inserter</span><span class=special>&lt;</span><span class=identifier>Function</span><span class=special>&gt;( </span><span class=identifier>fun </span><span class=special>);
    </span><span class=special>} </span>
<span class=special>}</span>
<span class=special>}  </span>  </pre></blockquote>


  <h3>Functions <code>ref_list_of()</code>, 
      <code>cref_list_of()</code> and variants <a name=ref-ref_list_of> </h3>

  <h4>Template parameters</h4>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>P</tt></td><td>A policy tag</td></tr>
  	<tr><td><tt>T</tt></td><td>Element</td></tr>
  	</table>
  </blockquote>

  <h4>Usage</h4>
  <p>Let <code>d1</code> and <code>d2</code> denote objects of type <code>T</code> and <code>const T</code>, respectively.</p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result</th><th class="head">Description</th>
  	<tr><td><tt>ref_list_of&lt;P&gt;( d1 ) </tt></td><td><a href="#ref-expr"> <tt>expr</a>&lt;_,T,1,<a href="#concept-ref_wrapper_assign">assign_reference_copy</a>,P&gt;</tt><tt></td></tr>
  	<tr><td><tt>cref_list_of&lt;P&gt;( d2 )</tt></td><td><a href="#ref-expr"> <tt>expr</a>&lt;_,const T,1,<a href="#concept-ref_wrapper_assign">assign_reference_copy</a>,P&gt;</tt><tt></td></tr>
  	<tr><td><tt>ref_list_of( d1 )          </tt></td><td><a href="#ref-expr"> <tt>expr</a>&lt;_,T,1,<a href="#concept-ref_wrapper_assign">assign_reference_copy</a>,use_default&gt;</tt><tt></td></tr>
  	<tr><td><tt>cref_list_of( d2 )         </tt></td><td><a href="#ref-expr"> <tt>expr</a>&lt;_,const T,1,<a href="#concept-ref_wrapper_assign">assign_reference_copy</a>,use_default&gt;</tt><tt></td></tr>
  	</table>
  </blockquote>
  
  <p>Usage for the related functions <code>ref_rebind_list_of()</code> and <code>cref_rebind_list_of()</code> are identical to those
  above, except the fourth argument to <a href="#ref-expr"> <tt>expr&lt;&gt;</tt></a> is <a href="#concept-ref_wrapper_assign"><tt>assign_reference_rebind</tt></a>. </p>

  <h3>Functions <code>ref_csv()</code>, <code>cref_csv()</code> and variants <a name=ref-ref_csv> </h3>

  <h4>Template parameters</h4>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>P</tt></td><td>A policy tag</td></tr>
  	<tr><td><tt>T</tt></td><td>Element</td></tr>
  	<tr><td><tt>N</tt></td><td>Size</td></tr>
  	</table>
  </blockquote>

<!--
  <b>Associated types</b>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Description</th> <th>Alias</th>
  	<tr><td><tt>csv_policy&lt;P&gt;::apply&lt;U,N,R&gt;::type</tt></td><td>A proxy object</td><td><tt>Impl&lt;P,U,N,R&gt;</tt></td></tr>
  	<tr><td><tt>csv_policy&lt;default_policy&gt;::apply&lt;U,N,R&gt;::type</tt></td><td><a href="#ref-static_array"> <tt>static_array<tt></a><tt>&lt;T,N,R&gt;</tt></td><td><tt>Impl0&lt;U,N,R&gt;</tt></td></tr>
  	</table>
  </blockquote>
-->

  <h4>Usage</h4>
  <p>Let <code>ai</code> and <code>bi</code> denote the <tt>i</tt>-th element of size-<tt>N</tt> sequences of objects of type <code>T</code> and <code>const T</code>, 
  respectively</p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result</th>
  	<tr><td><tt>ref_csv&lt;P&gt;(a1,...,aN)</tt></td><td>A custom implementation</td></tr>
  	<tr><td><tt>cref_csv&lt;P&gt;(b1,...,bN)</tt></td><td>A custom implementation </td></tr>
  	<tr><td><tt>ref_csv(a1,...,aN)</tt></td><td> <a href="#ref-static_array"> <tt>static_array<tt></a><tt>&lt;T,N,<a href="#concept-ref_wrapper_assign">assign_reference_copy</a>&gt;</tt> </td></tr>
  	<tr><td><tt>cref_csv(b1,...,bN)</tt></td><td><a href="#ref-static_array"> <tt>static_array<tt></a><tt>&lt;const T,N,<a href="#concept-ref_wrapper_assign">assign_reference_copy</a>&gt;</tt></td> </tr>
  	</table>
  </blockquote>
<p>
Usage for the related functions <code>ref_rebind_list_of()</code> and <code>cref_rebind_list_of()</code> are identical to those
above but with <a href="#concept-ref_wrapper_assign">rebind</a> rather than <a href="#concept-ref_wrapper_assign">copy</a> semantics.
</p>

<p>The maximum number of arguments to a csv function is <code>BOOST_ASSIGN_CSV_SIZE</code>.</p>
  
  <h3><a name="ref-std">Operator <code>+=</code> for standard containers </a> </h3>
   <p> In the following three dots (...) will mean
       implementation defined.  
       <code>operator+=()</code> returns a proxy that forwards calls to either
       <code>push_back()</code>,<code>insert()</code>, or <code>push()</code>  
       depending on which operation the container supports. </p> <b>Synopsis</b>
  <p>
<blockquote>
<pre>
<span class=keyword>namespace </span><span class=identifier>boost</span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>deque</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>list</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>P </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>map</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>m</span><span class=special>, </span><span class=keyword>const </span><span class=identifier>P</span><span class=special>&amp; </span><span class=identifier>p </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>P </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>multimap</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>m</span><span class=special>, </span><span class=keyword>const </span><span class=identifier>P</span><span class=special>&amp; </span><span class=identifier>p </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>queue</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>priority_queue</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>K2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>set</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>K2 </span><span class=identifier>k </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>K2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>multiset</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>K2 </span><span class=identifier>k </span><span class=special>);
    
    </span><span class=preprocessor>#ifdef </span><span class=identifier>BOOST_HAS_SLIST
              
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>slist</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=preprocessor>#endif
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>stack</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);    </span>

<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span>  </pre></blockquote>
    Note that the extra template argument <code>V2</code> etc. is 
    necessary to allow for types convertible to <code>V</code>.   

  <h3>Functions <code>repeat()</code>, 
     <code>repeat_fun()</code> and <code>range()</code> <a name="ref-repeat"> </h3>
  <p>
            These first two function exist both as free-standing functions and as member functions of the object returned by 
      <code>list_of()</code> and of <code>list_inserter</code>. 
      The free-standing versions are used to create a
      hook for <code>operator,()</code> so we can call the functions in the middle of a comma-list. The member functions
      are used when we need to call the functions in the middle of a parenthesis-list. In both cases we have that
      <ul>
          <li> the return type is always implementation defined for both functions, 
          <li> the argument list of <code>repeat()</code> is <code>(std::size_t,T)</code>, and  
          <li> the argument list of <code>repeat_fun()</code> is <code>(std::size_t,Nullary_function)</code>    
      </ul>
      
        </p>
  <p>
  The function <code>range()</code> only exists as a member function. The following two overloads are provided:
  <blockquote>
      <pre><span class=keyword>template</span><span class=special>&lt;</span> <span class=keyword>class</span> <span class=identifier>SinglePassIterator</span> <span class=special>&gt;</span>
<span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span> <span class=identifier>range</span><span class=special>(</span> <span class=identifier>SinglePassIterator</span> <span class=identifier>first</span><span class=special>,</span> <span class=identifier>SinglePassIterator</span> <span class=identifier>last</span> <span class=special>);</span>

<span class=keyword>template</span><span class=special>&lt;</span> <span class=keyword>class</span> <span class=identifier>SinglePassRange</span> <span class=special>&gt;</span>
<span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span> <span class=identifier>range</span><span class=special>(</span> <span class=keyword>const</span> <span class=identifier>SinglePassRange</span><span class=special>&amp;</span> <span class=identifier>rng</span> <span class=special>);</span></pre>
  </blockquote>
  </p>


  <h3> <a name="ref-chain">Operator <code>&&</code></a> </h3>
  
  <h4>Template parameters</h4>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>R1</tt></td><td>Models <a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html"><tt>Range</tt></a></td></tr>
  	<tr><td><tt>R2</tt></td><td>Models <a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html"><tt>Range</tt></a></td></tr>
  	</table>
  </blockquote>

  <h4>Requirements</h4>

  There exists some type <tt>T</tt> such that for each of <tt>R = R1, R2</tt>,

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>boost::range_reference&lt;R&gt;::type</tt></td><td>Convertible to <tt>T</tt></td></tr>
  	</table>
  </blockquote>

In particular, elements modeling <a href="#concept-ref_wrapper"><tt>RefWrapper</tt></a><tt>(T)</tt> are allowed.

  <h4>Usage</h4>
  <p>Let <code>r1</code>, <code>r2</code>, denote instances of <code>R1</code>, and <code>const R2</code>.
  Let <code>s1</code> and <code>s2</code> of type <code>R1</code>, and <code>R2</code>, respectively,
  such that at least one of them is <code>const</code>.

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result</th>
  	<tr><td><tt>r1 && r2</tt></td><td> <a href="#ref-chain_impl_l"><code>result_of::chain_l</code></a><code>&lt;R1,R2&gt;::type</code>  </td></tr>
  	<tr><td><tt>s1 && s2</tt></td><td> <a href="#ref-chain_impl_l"><code>result_of::chain_r</code></a><code>&lt;R1,R2&gt;::type</code>  </td></tr>
  	</table>
  </blockquote>
  
  <h4> Fine control </h4>

  Let <tt>T1</tt> and <tt>T2</tt> each be <tt>const</tt> or non-<tt>const</tt> without restriction. 
  For finer control over the resulting proxy objects, one may call <tt>chain_l&lt;V,R&gt;(r1)(r2)</tt> or <tt>chain_l(r1)(r2)</tt>, where
<tt>V</tt> is a value type, and <tt>R</tt> a reference type, and similarly <tt>chain_r&lt;V,R&gt;(t1)(t2)</tt> or 
<tt>chain_r(t1)(t2)</tt>.

  <h2>Concepts <a name="concepts"> </h2>

  <h3>Contents</h3>

      <ul>
        <li> Concept <a href="#concept-ano_list">         <code>AnonymousList</code>   </a> </li>
        <li> Concept <a href="#concept-auto_size">        <code>AutoSize</code>        </a> </li>
        <li> Concept <a href="#concept-chainable">        <code>Chainable</code>       </a> </li>
        <li> Concept <a href="#concept-converter">        <code>Converter</code>       </a> </li>
        <li> Concept <a href="#concept-range_comparable"> <code>RangeComparable</code> </a> </li>
        <li> Concept <a href="#concept-range_extensible"> <code>RangeExtensible</code> </a> </li>
        <li> Concept <a href="#concept-ref_wrapper">      <code>RefWrapper</code>      </a> </li>
        <li> Concept <a href="#concept-ref_array">        <code>RefArray</code>        </a> </li>
        <li> Concept <a href="#concept-repeatable">       <code>Repeatable</code>      </a> </li>
     </ul>

  <h3>Concept <a name="concept-ano_list"><tt>AnonymousList</tt></a></h3>
  
  <p>For now <tt>AnonymousList</tt> is still a loose concept (once an acceptable formalization is found,
  this doc will be updated accordingly). Its distinguishing feature, however, is that it exposes 
  public member functions to <i>internally</i> grow a list of a given type, <tt>T</tt>.</p>
  
  <p>How the internal list is accessible publically is not part of the concept. It needs to be
  specified separately, such as <tt>AnonymousList</tt>+<a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html">Range</a></p>

  <h3>Concept <a name="concept-auto_size"><tt>Auto-Size</tt></a></h3>

  <p>For now <tt>Auto-Size</tt> list is still a loose concept (once an acceptable formalization is found,
  this doc will be updated accordingly). Its distinguishing feature, is that it is a compile time expression 
  that is formed from references to passed argument, which may be faster than runtime alternatives, and frees the user from the need to specify the size of 
  the resulting collection.</p>
    
  <h3>Concept <a name="concept-chainable"><tt>Chainable</tt></a></h3>

  <h4>Notation</h4>

  Let <tt>c</tt> model <tt>Chainable</tt> for value type <tt>T</tt>, and <tt>r</tt> model 
  <a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html">Range</a> each element of
  which is convertible to <tt>T</tt>.

  <h4>Refinement of</h4>

  Models <a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html">Range</a>.

  <h4>Requirements</h4>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result</th>
  	<tr><td><span class="pre"><tt>c && r</tt></span></td><td>Models <tt>Range</tt> and is equivalent to <tt>c</tt> and <tt>r</tt> concatenated</td> </tr>
  	</table>
  </blockquote>

  <h3>Concept <a name="concept-ref_wrapper"><tt>RefWrapper</tt></a></h3>

  <h4>Headers</h4>
  </p> <code>&lt;boost/assign/list_of.hpp></code> <p>
  </p> <code>&lt;boost/assign/auto_size/reference_wrapper/copy.hpp></code> <p>
  </p> <code>&lt;boost/assign/auto_size/reference_wrapper/rebind.hpp></code> <p>

  <h4>Notation</h4>

  Let <tt>R</tt> model <tt>RefWrapper</tt> for value type <tt>T</tt>, and <tt>r</tt> an instance thereof. 
  Let <tt>x</tt> denote an object of type <tt>T</tt>.

  <h4>Requirements</h4>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result</th>
  	<tr><td><span class="pre"><tt>r</tt></span></td><td>convertible to <tt>T&</tt></td> </tr>
  	</table>
  </blockquote>

  <h4> <a name="concept-ref_wrapper_assign">Assignment semantics </a></h4>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Concept</th><th class="head">Expression</th> <th class="head">Post-condition</th><th class="head">Model</th> </tr>
  	<tr><td> <tt>Copy</tt>  </td><td><span class="pre"><tt>r = x; T& y = r; </tt></span></td><td><tt> x == y</tt></td> <td><code>assign_reference_copy</code></td></tr>
  	<tr><td> <tt>Rebind</tt> </td><td><span class="pre"><tt>r = x; T& y = r; </tt></span></td><td><tt>&x == &y</tt></td> <td><code>assign_reference</code>, <code>assign_reference_rebind</code></td></tr>
  	</table>
  </blockquote>

  <h3>Concept <a name="concept-converter"><tt>Converter</tt></a></h3>

  <h4>Headers</h4>
  </p> <code>&lt;boost/assign/list_of.hpp></code> <p>
  </p> <code>&lt;boost/assign/auto_size/range/converter.hpp></code> <p>
  
  <h4>Refinement of</h4>

  <p><a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html"><tt>Range</tt></a></p>

  <h4>Notation</h4>
  <p>Let <code>V1</code>, <code>V2</code> and <code>V3</code> denote three classes, each of whose interface captures a valid conversion operand for <tt>Converter</tt>,
  that  we call <i>container</i>, <i>adapter</i>, and <i>indexable</i>. Let <code>v1</code>, <code>v2</code> and <code>v3</code>, instances thereof. Let <tt>C</tt> denote
  a class that models <tt>Converter</tt>, and <tt>c</tt> and instance thereof. 
  Let <code>b</code> and <code>e</code> denote the begin and end iterators of <tt>c</tt>, and <tt>n</tt> the distance between them. Assume that the elements of each 
  of these data-structures are of type <code>X</code>, of which <code>x</code> is and instance, and <code>k</code> <i>any</i> index in the range 
  <tt>&#91;<span class=number>0</span>,n)</tt>. 
  </p>
  
  <h4>Conversion operands</h4>

  Each of <code>v1</code>, <code>v2</code> and <code>v3</code> must be <a href="http://www.boost.org/doc/libs/1_42_0/doc/html/CopyConstructible.html">copy constructible</a>. 
  In addition, 
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Concept</th><th class="head">Expression</th> <th class="head">Effect</th>
  	<tr><td>Container</td><td><tt><span class="pre">V1 v1(b,e);</span></tt></td> <td>Constructs an object of type <tt><span class=identifier>V</span></tt></td></tr>
  	<tr><td>Adapter</td><td><tt><span class="pre">v2.push(x)</span></tt></td><td>Adds element <tt><span class=identifier>x</span></tt> to <tt><span class=identifier>a</span></tt></td> </tr>
  	<tr><td>Indexable</td><td><tt><span class="pre">v3[k] = x</span></tt></td><td>Assigns value <tt><span class=identifier>x</span></tt> to the kth element of <tt><span class=identifier>r</span></tt> </tt></td> </tr>
  	</table>
  </blockquote>
</p>

  <h4>Requirements</h4>
  
  For each of <tt>v</tt> in <tt><span class="pre">{v1,v3}</span></tt>, these are valid expressions whose effect is to assign/copy the content of the rhs to the lhs:
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> 
  	<tr><td><tt><span class="pre">v = c;</span></tt></td> </tr>
  	<tr><td><tt><span class="pre">v = c.convert_to_container();</span></tt></td> </tr>
  	<tr><td><tt><span class="pre">v2 = c.to_adapter()</span></tt></td> </tr>
  	</table>
  </blockquote>

  <h4> Models </h4>

  A proxy-object models this concept by inheriting from <tt>converter&lt;&gt;</tt> or by expanding the macro 
  <code>BOOST_ASSIGN_AS_CONVERTER</code> inside its definition.

  <h3><a name="concept-ref_array">Concept <code>RefArray</code><a></h3> 

  <h4>Header</h4> <code>&lt;boost/assign/auto_size/array/interface.hpp></code>

  <h4>Requirements</h4> 

  A <tt>RefArray</tt> for value type <tt>T</tt> and size <tt>N</tt> exposes the interface of 
  <a href="http://www.boost.org/doc/libs/release/libs/array/"><code>boost::array&lt;&gt;</code><a>, 
  each element of which models <a href="#concept-ref_wrapper"><tt>RefWrapper</tt></a> for value type <tt>T</tt>.

  <h4> Models </h4>
 
  Any object of type <tt>D</tt> inheriting publicly from <code>range_comparison_op::base_of&lt;D&gt;</code>.

  <h3><a name="concept-range_comparable">Concept <tt>RangeComparable</tt><a></h3> 

  <h4>Headers</h4> 

  </p> <code>&lt;boost/assign/list_of.hpp></code> <p>

  <h4>Notation</h4> 

  Let <tt>r1</tt> denote an object modeling <tt>RangeComparable</tt> and <tt>r2</tt> modeling
  <a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html"><tt>Range</tt></a>.
  
  <h4>Requirements</h4> 
  
  All comparison operators are defined for each pair involving <tt>r1</tt> and <tt>r2</tt>.

  <h3><a name="concept-range_extensible">Concept <tt>RangeExtensible</tt><a></h3> 

  An anonymous list may optionally be increased by passing a range to it, rather than an invidivual element.

  <h4>Notation</h4> 

  Let  <tt>v</tt> denote <a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html"><tt>Range</tt></a>
  and <tt>e</tt> an object modeling <tt>RangeExtensible</tt>.

  <h4>Requirements</h4> 
  
    <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th><th class="head">Result</th></tr> 
  	<tr><td><tt><span class="pre">e.range( v );</span></tt></td><td>reference to <tt>e</tt></td> </tr>
  	</table>
    </blockquote>

  <h3><a name="concept-repeatable">Concept <tt>Repeatable</tt><a></h3> 

  <h4>Notation</h4> 

  Let  <tt>T</tt> denote the value type with respect to which <tt>Repeatable</tt> is invoked, and
  <tt>t</tt> an instance thereof. Let <tt>e</tt> an object modeling <tt>Repeatable</tt>. Let 
  <tt>n</tt> denote an integer.

  <h4>Requirements</h4> 
  
    <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th><th class="head">Result</th></tr> 
  	<tr><td><tt><span class="pre">e.repeat( n, t );</span></tt></td><td>reference to <tt>e</tt></td> </tr>
  	</table>
    </blockquote>
  
  <h2>Proxy objects <a name="ref-impl"> </h2>

  Proxy objects are those that are returned by <a name="ref-functions">functions<a>, which are
  invisible to their caller, and take care of the implementation.

  <h3>Contents</h3>

     <ul>
        <li> Proxy object <a href="#ref-generic_list">        <code>generic_list&lt;&gt;</code>        </a> </li>
        <li> Proxy object <a href="#ref-list_inserter">       <code>list_inserter&lt;&gt;</code>       </a> </li>
        <li> Proxy object <a href="#ref-static_generic_list"> <code>static_generic_list&lt;&gt;</code> </a> </li>
<!--        <li> Proxy object <a href="#ref-array_interface">     <code>array_interface&lt;&gt;</code>   </a> </li> -->
        <li> Proxy object <a href="#ref-expr">                <code>expr&lt;&gt;</code>                </a> </li>
<!--        <li> Proxy object <a href="#ref-lazy_array">          <code>lazy_array&lt;&gt;</code>          </a> </li> -->
        <li> Proxy object <a href="#ref-static_array">        <code>static_array&lt;&gt;</code>        </a> </li>
        <li> Proxy object <a href="#ref-chain_impl_l">         <code>chain_impl::expr_l&lt;&gt;</code>    </a> </li>
        <li> Proxy object <a href="#ref-chain_impl_r">         <code>chain_impl::expr_r&lt;&gt;</code>    </a> </li>
     </ul>

  <h3>Proxy object <code>generic_list&lt;&gt;</code><a name=ref-generic_list> </h3>

  <h4>Header</h4> <code>&lt;boost/assign/list_of.hpp></code>

  <h4>Template parameters</h4>
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt><span class="pre">T</span></tt></td> <td>Element</td></tr>
  	</table>
  </blockquote>

  <h4> Model of </h4>

  <p>
  <a href="#concept-ano_list">         <tt>AnanymousList(T)    </tt></a>, 
  <a href="#concept-converter">        <tt>Converter(T)        </tt></a>, 
  <a href="#concept-range_comparable"> <tt>RangeComparable     </tt></a>, 
  <a href="#concept-range_extensible"> <tt>RangeExtensible     </tt></a>,
  <a href="#concept-repeatable">       <tt>Repeatable(T)       </tt></a>
  </p>

  <h3>Proxy object <code>static_generic_list<></code><a name=ref-static_generic_list> </h3>
  
  <h4>Header</h4> <code>&lt;boost/assign/list_of.hpp></code>

  <h4>Template parameters</h4> 

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>T</tt></td><td> Element </td> </tr>
  	<tr><td><tt>N</tt></td><td> Size </td> </tr>
  	</table>
  </blockquote>

  <h4>Model of</h4>

  <p> 
  <a href="#concept-ano_list">        <tt>AnonymousList</tt>      </a> for value type <a href="#concept-ref_wrapper_assign"><tt>assign_reference</tt></a><tt>&lt;T&gt;</tt>, 
  <a href="#concept-converter">       <tt>Converter(T)</tt>       </a>, 
  <a href="#concept-range_comparable"><tt>RangeComparable</tt>    </a>, 
  <a href="#concept-range_extensible"><tt>RangeExtensible</tt>    </a> 
  </p>

  <h3>Proxy object <code>list_inserter&lt;&gt;</code><a name="ref-list_inserter"></h3> 

  <p>This class is responsible for inserting elements into containers and 
  it is the key to extending the library to support your favourite class.</p>

  <h4>Header</h4> <code>&lt;boost/assign/list_inserter.hpp></code>

  <h4>Template parameters</h4> 

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>Function</tt></td><td> A functor to which insertion is delegated to </td> </tr>
  	<tr><td><tt>Argument</tt></td><td> Argument to be inserted </td> </tr>
  	</table>
  </blockquote>

  <h4>Synopsis</h4> 

  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost</span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=identifier>Function</span><span class=special>, </span><span class=identifier>Argument </span><span class=special>= </span><span class=keyword>void </span><span class=special>&gt; 
    </span><span class=keyword>class </span><span class=identifier>list_inserter
    </span><span class=special>{
        </span><span class=identifier>Function </span><span class=identifier>fun</span><span class=special>;
        
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=keyword>explicit </span><span class=identifier>list_inserter</span><span class=special>( </span><span class=identifier>Function </span><span class=identifier>fun </span><span class=special>);
        
        </span><span class=comment>// conversion constructor
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>Function2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>Arg </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>( </span><span class=keyword>const </span><span class=identifier>list_inserter</span><span class=special>&lt;</span><span class=identifier>Function2</span><span class=special>,</span><span class=identifier>Arg</span><span class=special>&gt;&amp; </span><span class=special>);
        
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>,( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>=( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=comment>// calls 'fun()' with default-constructed object
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>()();
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2 </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2 </span><span class=special>)
        </span><span class=special>{
           </span><span class=comment>//
           // if 'Argument' is 'void'
           //     fun( u, u2 );
           // else
           //     fun( Argument( u, u2 ) );
           //
           </span><span class=keyword>return </span><span class=special>*</span><span class=keyword>this</span><span class=special>;
        </span><span class=special>}

        </span><span class=comment>//
        // similarly up to 5 arguments
        //
    </span><span class=special>};</span>
    
    <span class=keyword>template</span><span class=special>&lt; </span><span 
class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);
      
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>push_front</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>push</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);</span>
      
<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span></pre></blockquote>
  <p>Notice how the arguments to <code>operator,()</code> and 
  <code>operator()()</code> are passed differently to 
  <code>fun</code> depending of the type of <code>Argument</code>. 
  So if we only pass one template argument to <code>list_inserter,</code>
  we can forward "arbitrary" argument lists of functions. If we pass
  two template arguments to <code>list_inserter</code> we can 
  construct types with "arbitrary" constructors.</p> 
   
  <p> And because a reference to <code>list_inserter</code> is returned, we can chain argument list together in a very space-efficient manner.</p>
  
  <h3><a name="ref-expr">Proxy object <code>expr&lt;&gt;</code></a></h3> 

  <h4>Header</h4> <code>&lt;boost/assign/auto_size/detail/expr.hpp></code>

  <h4>Template parameters</h4> 

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th> <th class="head">Requirements</th></td>
  	<tr><td><tt>E</tt></td><td> Previous collection </td> <td> Unspecified         </td></tr>
  	<tr><td><tt>T</tt></td><td> Element             </td> <td> Unspecified         </td></tr>
  	<tr><td><tt>N</tt></td><td> Size                </td> <td> Unspecified         </td></tr>
  	<tr><td><tt>R</tt></td><td> A class template    </td> <td><tt>R&lt;T&gt;</tt> models <tt>RefWrapper</tt> for value type <tt>T</tt></td></tr>
  	<tr><td><tt>P</tt></td><td> Policy tag          </td> <td> Unspecified </td> </tr>
  	</table>
  </blockquote>

  <h4>Models</h4> 

  <a href="#concept-auto_size"><tt>Auto-size&lt;T&gt;</tt></a>, 
  <a href="#concept-ano_list"><tt>AnonymousList&lt;T&gt;</tt></a>. 

  <h4>Specializations</h4> 

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Description</th>
  	<tr><td><tt>expr&lt;E,T,N,R,use_default&gt;</tt></td> <td>models <a href="#concept-ano_list"><tt>RefArray&lt;T&gt;</tt></a>, <a href="#concept-converter"><tt>Converter&lt;T&gt;</tt></a>, <a href="#concept-range_comparable"><tt>RangeComparable&lt;T&gt;</tt></a> </td> </tr>
  	</table>
  </blockquote>

  <h4>Synopsis</h4> 
  
  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost</span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
<span class=keyword>namespace </span><span class=identifier>detail</span>
<span class=special>{
<span class=keyword>namespace </span><span class=identifier>auto_size</span>
<span class=special>{
    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> T,<span class="keyword">int</span> N,
        <span class="keyword">template&lt</span><span class="keyword">typename</span>> <span class="keyword">class</span> R,<span class="keyword">typename</span> P>
    class expr{
        <span class="keyword">public:</span>       

        <span class="keyword">typedef</span> Implementation-defined result_type;
        <span class="keyword">explicit</span> expr(<span class="keyword">const</span> E& p,T& t);
        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1,<span class="keyword">typename</span> P1 &gt;</span>
        <span class="keyword">explicit</span> expr(<span class="keyword">const</span> expr&lt;E1,T,N,R,P1&gt;& that);

        result_type <span class="keyword">operator</span>()(T& t)<span class="keyword">const</span>;
        
    };  

    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> E,<span class="keyword">typename</span> T,<span class="keyword">int</span> N,
    	<span class="keyword">template</span>&lt;<span class="keyword">typename</span>> <span class="keyword">class</span> R,<span class="keyword">typename</span> P,<span class="keyword">bool</span> F>
    <span class="keyword">void</span> write_to_array(A& a,<span class="keyword">const</span> expr<E,T,N,R,P,F>& e);


<span class=special>} </span><span class=comment>// namespace 'auto_size'</span>
<span class=special>} </span><span class=comment>// namespace 'detail'</span>
<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span></pre></blockquote>

  <h4>Design</h4> 

<p>
   A call to the unary operator returns an object that keeps a reference to the passed argument, and links to the 
   current object, thereby forming a collection whose final size is determined at compile time. 
   The function <code>write_to_array()</code> is typically used to pass the elements of the collection to the policy, 
   that will be chosen to have the desired interface such as iterators and conversion operators. 
</p>   
  
  
<!--  
  <h3>Proxy object <code>lazy_array&lt;&gt;</code><a name="ref-lazy_array"></h3> 

  <h4>Header</h4> <code>&lt;boost/assign/auto_size/array/lazy.hpp></code>

  <h4>Template parameters</h4> 

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>T</tt></td><td> Element </td> </tr>
  	<tr><td><tt>N</tt></td><td> Size </td> </tr>
  	<tr><td><tt>R</tt></td><td> A class template</td> </tr>
  	<tr><td><tt>D</tt></td><td> Derived </td> </tr>
  	</table>
  </blockquote>

  <h4>Associated types</h4> 

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Description</th>
  	<tr><td><tt>R&lt;T&gt;</tt></td><td> Reference wrapper </td> </tr>
  	<tr><td><a href="#ref-array_interface"><tt>array_interface&lt;&gt;</tt><a></td><td> Public base class of <a href="#ref-lazy_array"><tt>lazy_array&lt;&gt;</tt></td> </tr>
  	</table>
  </blockquote>

  <h4>Requirements</h4> 

  Let <tt>d</tt> denote an instance of <tt>D</tt> and <tt>a</tt> an instance of <code>boost::array&lt;R&lt;T&gt;,N&gt;</code>,
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Effect</th>
  	<tr><td><tt>write_to_array(a,d)</tt></td><td> Assigns <tt>a</tt>'s elements </td> </tr>
  	</table>
  </blockquote>

  <h4>Properties</h4> 

  <p>
   Postpones allocation of its data-members (from the derived class) until the interface is used.
 </p>

-->

  <h3>Proxy object <code>static_array&lt;&gt;</code><a name="ref-static_array"></h3> 

  <h4>Header</h4> <code>&lt;boost/assign/auto_size/array/static.hpp></code>

  <h4>Template parameters</h4> 

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th> <th class="head">Requirements</th></tr>
  	<tr><td><tt>T</tt>            </td> <td> Element                </td> <td> Unspecified</td> </tr>
  	<tr><td><tt>N</tt>            </td> <td> Size                   </td> <td> Unspecified</td> </tr>
  	<tr><td><tt>R</tt>            </td> <td> A class template       </td> <td> <tt>R&lt;T&gt;</tt> models <a href="#concept-ref_wrapper"> <tt>RefWrapper(T)</tt> </a></td> </tr>
  	</table>
  </blockquote>

  <h4>Models</h4> 

  <h4>Requirements</h4> 

  Let <tt>e</tt> denote the argument passed to the constructor, and a an instance of <code>boost::array&lt;R&lt;T&gt;,N&gt;</code>,
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Effect</th>
  	<tr><td><tt>write_to_array(a,e)</tt></td><td> Assigns <tt>a</tt>'s elements </td> </tr>
  	</table>
  </blockquote>

  <h3><a name="ref-chain_impl_l">Proxy object <code>chain_impl::expr_l&lt;&gt;</code></a> </h3>
   
  <h4>Header</h4> <code>&lt;boost/assign/auto_size/range/chain_l.hpp></code>

  <h4>Template parameters</h4> 

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>L</tt></td><td> Implementation-defined </td> </tr>
  	<tr><td><tt>E</tt></td><td> Implementation-defined </td> </tr>
  	<tr><td><tt>Rng1</tt></td><td> Models <a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html"><tt>Range</tt></a> </td> </tr>
  	<tr><td><tt>is_first</tt></td><td> boolean constant </td> </tr>
  	<tr><td><tt>V</tt></td><td> A value type </td> </tr>
  	<tr><td><tt>R</tt></td><td> A reference type</td> </tr>
  	</table>
  </blockquote>

  <h4>Models</h4> 
  
  <a name="concept-chainable"><tt>Chainable(T)</tt></a>, <a name="concept-chainable"><tt>Converter(T)</tt></a>
 
  <h3><a name="ref-chain_impl_r">Proxy object <code>chain_impl::expr_r&lt;&gt;</code></a> </h3>

  <h4>Header</h4> <code>&lt;boost/assign/auto_size/range/chain_r.hpp></code>

  <h4>Template parameters</h4> 

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>E</tt></td><td> Implementation-defined </td> </tr>
  	<tr><td><tt>Rng1</tt></td><td> Models <a href="http://www.boost.org/doc/libs/1_42_0/libs/range/doc/range.html"><tt>Range</tt></a> </td> </tr>
  	<tr><td><tt>is_first</tt></td><td> boolean constant </td> </tr>
  	<tr><td><tt>V</tt></td><td> A value type </td> </tr>
  	<tr><td><tt>R</tt></td><td> A reference type</td> </tr>
  	</table>
  </blockquote>

  <h4>Models</h4> 

  <a name="concept-chainable"><tt>Chainable(const T)</tt></a>, <a name="concept-chainable"><tt>Converter(const T)</tt></a>

  <h2><a name="exceptions">Exceptions and exception-safety</a></h2>
  <p>
  The exception guarantees by the library is the same as guarantee as the 
  guarantee of the function that is forwarded to. For standard 
  containers this means that the
  strong guarantee is given for a single insertions and that the basic guarantee 
  is given for many insertions (provided that the object being copied 
  gives the basic guarantee). 
  </p>
  <p>
  The functions may throw standard exceptions
  like <code>std::bad_alloc</code>. Note however that, unfortunately, the standard does not guarantee allocation-failures
  in standard containers to be reported by <code>std::bad_alloc</code> or exceptions derived from <code>std::exception</code>.
 </p>
  
  <h3><a name="assignment_exception">Class 
  <code>assignment_exception</code></a></h3>
  <p>
   The exception is thrown by the conversion operator in the proxy object
   returned from <code>list_of()</code>.
  </p>

  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost </span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>class </span><span class=identifier>assignment_exception </span><span class=special>: </span><span class=keyword>public </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>exception
    </span><span class=special>{
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=keyword>explicit </span><span class=identifier>assignment_exception</span><span class=special>( </span><span class=keyword>const </span><span class=keyword>char</span><span class=special>* </span><span class=identifier>what </span><span class=special>); 
        </span><span class=keyword>virtual </span><span class=keyword>const </span><span class=keyword>char</span><span class=special>* </span><span class=identifier>what</span><span class=special>() </span><span class=keyword>const </span><span class=keyword>throw</span><span class=special>();
    </span><span class=special>};</span>
<span class=special>}   </span>
<span class=special>}</span>  </pre></blockquote> 

  <hr>
  <h2><a name="extensions">Extending the library</a></h2> 
  <p>
  It is very simple to make the library work with new classes. 
  This code shows how to use <code>operator+=()</code> with 
  a container:
  <blockquote><pre>
<span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
</span><span class=keyword>inline </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=identifier>assign_detail</span><span class=special>::</span><span class=identifier>call_push_back</span><span class=special>&lt; </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt; </span><span class=special>&gt;, </span><span class=identifier>V </span><span class=special>&gt; 
</span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>)
</span><span class=special>{
    </span><span class=keyword>return </span><span class=identifier>make_list_inserter</span><span class=special>( </span><span class=identifier>assign_detail</span><span class=special>::</span><span class=identifier>call_push_back</span><span class=special>&lt; </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt; </span><span class=special>&gt;( </span><span class=identifier>c </span><span class=special>) </span><span class=special>)( </span><span class=identifier>v </span><span class=special>);
</span><span class=special>}
</span></pre>
</blockquote>      


where <code>call_push_back</code> is defined as    
      
<blockquote>      
<pre>
<span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
</span><span class=keyword>class </span><span class=identifier>call_push_back
</span><span class=special>{
    </span><span class=identifier>C</span><span class=special>&amp; </span><span class=identifier>c_</span><span class=special>;
</span><span class=keyword>public</span><span class=special>:

    </span><span class=identifier>call_push_back</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=identifier>c </span><span class=special>) </span><span class=special>: </span><span class=identifier>c_</span><span class=special>( </span><span class=identifier>c </span><span class=special>)
    </span><span class=special>{ </span><span class=special>}
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=keyword>void </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>T </span><span class=identifier>r </span><span class=special>) 
    </span><span class=special>{
        </span><span class=identifier>c_</span><span class=special>.</span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>r </span><span class=special>);
    </span><span class=special>}
</span><span class=special>};</span></pre>    
</blockquote>
      
      Note that we pass
  a second template argument to <code>list_inserter</code> so argument 
  lists will be used to construct a <code>V</code> object. Otherwise we
  could end up trying to call <code>push_back()</code> with <i>n</i> arguments 
  instead of one.
  </p>
      
  <p>    
  An alternative way would be to use <code>boost::function</code> and 
  <code>boost::bind()</code> in combination. However, in this case one must
  remember that it is illegal to take the address of a function in
  the standard library.
  </p>
      
  <p>
  Calling a function with more that one argument can be
  very useful too. This small example shows how we take advantage of this 
  functionality:
  </p>
  <blockquote><pre>
<span class=comment>//  
// A class representing emails
//</span>
<span class=keyword>class </span><span class=identifier>email</span>
<span class=special>{</span>
<span class=keyword>public</span><span class=special>:
    </span><span class=keyword>enum </span><span class=identifier>address_option
    </span><span class=special>{
        </span><span class=identifier>check_addr_book</span><span class=special>,
        </span><span class=identifier>dont_check_addr_book
    </span><span class=special>};
    </span>
<span class=keyword>private</span><span class=special>:

    </span><span class=keyword>typedef </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>map</span><span class=special>&lt; </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>,</span><span class=identifier>address_option </span><span class=special>&gt;  </span><span class=identifier>address_map</span><span class=special>;
    
    </span><span class=comment>//
    // Store list of persons that must be cc'ed
    //
    </span><span class=keyword>mutable </span><span class=identifier>address_map </span><span class=identifier>cc_list</span><span class=special>;
        
    </span><span class=comment>//
    // This extra function-object will take care of the 
    // insertion for us. It stores a reference to a 
    // map and 'operator()()' does the work. 
    //
    </span><span class=keyword>struct </span><span class=identifier>add_to_map
    </span><span class=special>{
        </span><span class=identifier>address_map</span><span class=special>&amp; </span><span class=identifier>m</span><span class=special>;
    
        </span><span class=identifier>add_to_map</span><span class=special>( </span><span class=identifier>address_map</span><span class=special>&amp; </span><span class=identifier>m </span><span class=special>) </span><span class=special>: </span><span class=identifier>m</span><span class=special>(</span><span class=identifier>m</span><span class=special>)        
        </span><span class=special>{}
    
        </span><span class=keyword>void </span><span class=keyword>operator</span><span class=special>()( </span><span class=keyword>const </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>&amp; </span><span class=identifier>name</span><span class=special>, </span><span class=identifier>address_option </span><span class=identifier>ao </span><span class=special>)
        </span><span class=special>{
            </span><span class=identifier>m</span><span class=special>[ </span><span class=identifier>name </span><span class=special>] </span><span class=special>= </span><span class=identifier>ao</span><span class=special>; 
        </span><span class=special>}
    </span><span class=special>};
</span>
<span class=keyword>public</span><span class=special>:
    
    </span><span class=comment>//
    // This function constructs the appropriate 'list_inserter'.
    // Again we could have use 'boost::function', but it is
    // trivial to use a function object.
    //
    // Notice that we do not specify an extra template
    // parameter to 'list_inserter'; this means we forward
    // all parameters directly to the function without 
    // calling any constructor.
    //
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=identifier>add_to_map </span><span class=special>&gt;
    </span><span class=identifier>add_cc</span><span class=special>( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string </span><span class=identifier>name</span><span class=special>, </span><span class=identifier>address_option </span><span class=identifier>ao </span><span class=special>)
    </span><span class=special>{
        </span><span class=comment>//
        // Notice how we pass the arguments 'name' and 'ao' to
        // the 'list_inserter'.
        //
        </span><span class=keyword>return </span><span class=identifier>make_list_inserter</span><span class=special>( </span><span class=identifier>add_to_map</span><span class=special>( </span><span class=identifier>cc_list </span><span class=special>) </span><span class=special>)( </span><span class=identifier>name</span><span class=special>, </span><span class=identifier>ao </span><span class=special>);
    </span><span class=special>}</span>
<span class=special>};
</span>
<span class=comment>//
// Now we can use the class like this:
//</span>
<span class=identifier>email </span><span class=identifier>e</span><span class=special>;</span>
<span class=identifier>e</span><span class=special>.</span><span class=identifier>add_cc</span><span class=special>( </span><span class=string>&quot;Mr. Foo&quot;</span><span class=special>, </span><span class=identifier>email</span><span class=special>::</span><span class=identifier>dont_check_addr_book </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;Mr. Bar&quot;</span><span class=special>, </span><span class=identifier>email</span><span class=special>::</span><span class=identifier>check_addr_book </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;Mrs. FooBar&quot;</span><span class=special>, </span><span class=identifier>email</span><span class=special>::</span><span class=identifier>check_addr_book </span><span class=special>);  </span>
</pre></blockquote>
      
   
  The full example can be seen in <a href="email_example.html">email_example.cpp</a> </p>
  <hr>
  <h2>Examples <a name="examples"></h2>
  <p>
  Additional examples can be found in the test files:
  <ul>
      <li> <a href="email_example.html">email_example.cpp</a>          
      <li> <a href="my_vector_example.html">my_vector_example.cpp</a>               
      <li> <a href="multi_index_container.html">multi_index_container.cpp</a> 
      <li> <a href="../test/array.cpp">array.cpp</a>      
      <li> <a href="../test/list_of.cpp">list_of.cpp</a>      
      <li> <a href="../test/std.cpp">std.cpp</a>      
      <li> <a href="../test/list_inserter.cpp">list_inserter.cpp</a>      
      <li> <a href="../test/list_of_workaround.cpp">list_of_work_around.cpp</a>      
      <li> <a href="../test/ref_list_of.cpp">ref_list_of.cpp</a>      
      <li> <a href="../test/ref_csv.cpp">ref_csv.cpp</a>      
</ul> </p>
  
  
  <hr>
  <h2><a name="boost_libs">Supported libraries</a></h2> 
  Here is a list libraries has been tested with Boost.Assign:
  
  <ol>
      <li> <code>boost::<a href="../../array/index.html">array</a></code>
      <li> <code>boost::<a href="../../multi_index/index.html">multi_index_container</a></code>
      <li> <code>Boost.<a href="../../ptr_container/index.html">Pointer Container</code> </ol> <p>

  </p>
  
  
  <hr>
  <h2><a name="portability">Portability</a></h2>
  <p>
    Library has been successfully compiled and tested with
    MVC++ 7.1, GCC 3.2 (under Cygwin) Comeau 4.3.3
  </p>
  <p>
    There are known limitation on platforms not supporting templated 
    conversion operators. The solution is to call certain member functions on 
    the object returned by <code>list_of()</code>: </p>
 <blockquote>
     <pre>
<span class=special>{
    </span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
    </span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>;
    </span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
    
    </span><span class=keyword></span><span 
class=identifier>vector</span><span
class=special>&lt;</span><span class=keyword>int</span><span 
class=special>&gt;</span>         <span class=identifier>v </span><span 
class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_container</span><span class=special>( </span><span class=identifier>v </span><span class=special>);
    </span><span class=identifier>set</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;            </span><span class=identifier>s </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_container</span><span class=special>( </span><span class=identifier>s </span><span class=special>);  
    </span><span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt;        </span><span class=identifier>m </span><span class=special>= </span><span class=identifier>map_list_of</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>).</span><span class=identifier>to_container</span><span class=special>( </span><span class=identifier>m </span><span class=special>);
    </span><span class=identifier>stack</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;         </span><span class=identifier>st </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_adapter</span><span class=special>( </span><span class=identifier>st </span><span class=special>);
    </span><span class=identifier>queue</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;          </span><span class=identifier>q </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_adapter</span><span class=special>( </span><span class=identifier>q </span><span class=special>); 
    </span><span class=identifier>array</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=number>4</span><span class=special>&gt;        </span><span class=identifier>a </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_array</span><span class=special>( </span><span class=identifier>a </span><span class=special>);</span>
<span class=special>}</span>     </pre>
 </blockquote>
 <p>
 Notice how one must supply the functions with an argument so the right
 return type can be deduced.
 </p>
 <p>Some standard libraries are also broken. One problem is that 
<code>insert()</code> might not work:
<blockquote>
    <pre>
<span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>next</span><span class=special>; 
</span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>next </span><span class=special>)(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>); </span><span class=comment>// compile-time error</span> </pre>
</blockquote>
The solution is to use <code>map_list_of()</code> instead:
<blockquote>
    <pre>
<span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>next </span><span class=special>= </span><span class=identifier>map_list_of</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>);</span></pre></blockquote>
</p>
 <hr>
  <h2><a name="history">History and Acknowledgment</a></h2>
  <p>
  The idea for an assignment/initialization library is not new. The 
  functionality of this
  library resembles Leor Zolman's STL Container Initialization Library a great 
  deal, but it does not rely on string parsing to achieve its goals. 
  </p> 
  <p>
  The  
  library is non-intrusive and puts only a minimum of requirements 
  on its supported classes.
 Overloading operator comma is sometimes viewed as a bad practice <a 
href="#meyers">[1]</A>. However, it has been done
  with success in eg. the Generative Matrix Computation Library  and Blitz to initialize matrices 
      (see <a href="#gmcl">[2]</A>) and <a href="#blitz">[3]</A>). The 
Initialization Library overloads
      the comma operator in a safe manner by letting free standing functions
 return an object that is responsible for the initialization. Therefore it takes 
explicit
      action from the programmer to begin using the overloaded <code>operator,()</CODE>.
  </p>
  <p>
  There has recently been some discussion about enhancing the language to 
support better initialization (see <a href="#initializer">[4]</a>).
  </p>
  
  
  <p>
  Special thanks goes to 
  <ul>
  <li> Leor Zolman for our many discussion that eventually led to this library.
  <li> Tom Brinkman for being review manager.
  <li> Joaquín Muñoz for vc6/vc7 portability.
  <li> Pavel Vozenilek for his countless suggestions, improvements and 
       portability fixes. 
  <li> Rene Rivera for Code Warrior portability.     
  <li> Manuel Peinado Gallego for identifying the need for an <a href="#concept-auto_size">auto-size framework</a>, 
  his valuable advice throughout its development, and proposing a
  <a href="http://gist.github.com/287791">design</a> that laid the foundation for 
  <a href="#chain"> <code>chain_l</code></a>  and <a href="#chain"> chaining ranges</a>.
       
       </ul>
  </p>

  <hr>
  <h2><a name="upgrading_from_1_42">Upgrading from Boost v. <span class=number>1</span><span class=special>.</span><span class=number>42</span></a></h2>

  <p> 
  The <a href="#concept-auto_size">auto-size framework</a> for building a collection of references whose size is deduced at compile time supersedes <a href="#ref-list_of"><code>ref_list_of&lt;int&gt;()</code></a>.
  The latter will continue to be supported to ensure backward compatibility.
  </p>


  <hr>
  <h2><a name="ref">References</a></h2>
  <p>
  <ol>
      <li> <a name="meyers">     Scott. Meyers, "More Effective C++", Item 7, Addison Wesley, 1996       
      <li> <a name="gmcl">       K. Czarnecki and U.W. Eisenecker, "Generative programming", Addison-Wesley, 2000        
      <li> <a name="blitz">      <a href="http://www.oonumerics.org/blitz/"> http://www.oonumerics.org/blitz/ </A>     
      <li> <a name="initializer"> 
          Gabriel Dos Reis and Bjarne Stroustrup, 
          <a href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1509.pdf"> "Generalized Initializer
            Lists"</a>, 2003  </a>
 </OL> 
 </p>
  <hr>
  <p>
    (C) Copyright Thorsten Ottosen 2003-2006 <br/>
    (C) Copyright Erwann Rogard 2010-
  </p>

  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
</body>
</html>
