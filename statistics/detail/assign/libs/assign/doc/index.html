<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.Assignment Documentation </title>
<link rel="stylesheet" href="style.css" type="text/css">
</head>

<body>

  <table border="0" >
    <tr>
      <td ><img src="../../../boost.png" border="0" ></td>
      <td >
        <h1 align="center">Assignment Library</h1>
      </td>
    </tr>
  </table>

  <p>
  Copyright © 2003-2006 Thorsten Ottosen
  </p>
  <p>
  Use, modification and distribution is subject to the Boost Software License, Version 1.0
  (see <a href="http://www.boost.org/LICENSE_1_0.txt">
   http://www.boost.org/LICENSE_1_0.txt</a>).
  </p>
  <h3>Table of Contents</h3>
  <ul>
    <li><a href="#intro">Introduction</a></li>
    <li>     
        <a href="#tutorial" >Tutorial</a>
        <ul>
            <li>Function <a href="#operator+="><code>operator+=()</code></a>
            <li>Function <a href="#operator()"><code>operator()()</code></a>
            <li>Function <a href="#list_of"><code>list_of()</code></a>    
            <li>Function <a href="#map_list_of"><code>map_list_of()</code></a> 
            <li>Function <a href="#tuple_list_of"><code>tuple_list_of()</code></a>
            <li>Functions <a href="#repeat"><code>repeat()</code></a>, <a href="#repeat"><code>repeat_fun()</code></a> and <a href="#repeat"><code>range()</code> </a>
            <li>Functions <a href="#ref_list_of"><code>ref_list_of()</code></a>, <a href="#ref_list_of"><code>cref_list_of()</code></a> and related functions   
            <li>Functions <a href="#ref_csv"><code>ref_csv()</code></a>, <a href="#ref_csv"><code>cref_csv()</code></a> and related functions   
            <li>A <a href="#complicated">"complicated"</a> example    
            <li>Functions <a href="#ptr_push_back"><code>ptr_push_back()</code></a>, <a href="#ptr_push_back"><code>ptr_push_front()</code></a>, 
                                                   <a href="#ptr_push_back"><code>ptr_insert()</code></a> and <a href="#ptr_push_back"><code>ptr_map_insert()</code></a>
            <li>Function <a href="#ptr_list_of"><code>ptr_list_of()</code></a>         
       </ul>           
    <li> <a href="#design" >Design</a> </li>
    <li>          
        <a href="#ref-functions">Reference for functions and operators</a>
      <ul>
        <li><a href="#ref-function-headers">Headers</a> </li>
        <li>Functions <a href="#ref-list_of"><code>list_of()</code></a>, <a href="#ref-list_of"><code>map_list_of()</code></a> and <a href="#ref-list_of"><code>ref_list_of&lt;int&gt;()</code></a></li>
        <li>Function <a href="#ref-make_list_inserter"><code>make_list_inserter()</code></a></li>
        <li>Functions <a href="#ref-ref_list_of"><code>ref_list_of()</code></a>, <a href="#ref-ref_list_of"><code>cref_list_of()</code></a>, and related functions</li>
        <li>Functions <a href="#ref-ref_csv"><code>ref_csv()</code></a>, <a href="#ref-ref_csv"><code>cref_csv()</code></a>, and related functions</li>
        <li>Operator <a href="#ref-std"><code>+=</code></a> for standard containers</li>
        <li>Functions <a href="#ref-repeat_ref"><code>repeat()</code></a>, <a href="#ref-repeat_ref"><code>repeat_fun()</code></a> and 
                                                                      <a href="#ref-repeat_ref"><code>range()</code>
                                                                      </a></li>
        <li><a href="#ref-limit">Customizing</a> argument list sizes </li>
     </ul>
    <li>          
        <a href="#ref-impl">Reference for the implementation</a>
      <ul>
        <li> Proxy object <a href="#ref-converter"><code>converter&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-generic_list"><code>generic_list&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-list_inserter"><code>list_inserter&lt;&gt;</code></a></li>
        <li> Proxy object <a href="#ref-static_generic_list"><code>static_generic_list&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-array_interface"><code>array_interface&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-expr"><code>expr&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-lazy_array"><code>lazy_array&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-static_array"><code>static_array&lt;&gt;</code></a> </li>
     </ul>
    <li> <a href="#exceptions">Exceptions and exception-safety </a></li>
    <li> <a href="#extensions">Extending the library</a>            
    <li> <a href="#boost_libs">Supported libraries </a>        
    <li> <a href="#examples">Examples</a></li> <ul></ul>
    <li><a href="#portability">Portability</a></li>
    <li><a href="#history">History and Acknowledgment</a>    
    <li><a href="#ref">References</a></li>
  </ul>
  <hr>

 
  
<h2><a name="intro">Introduction</a></h2> <p> <i>There appear to be few 
practical uses of <code>operator,()</code></i>.  <!-- p.  247 --> <br><b>Bjarne 
Stroustrup</b>, The Design and Evolution of C++ </p> <p> The purpose of this 
library is to make it easy to fill containers with data by overloading 
<code>operator,()</code> and <code>operator()()</code>.  These two operators 
make it possible to construct lists of values that are then copied into a 
container: </p> <ul> <li> A comma-separated list: <p> 
       <!--  vector< int > v; v += 1,2,3,4,5,6,7,8,9; -->
 
<pre><span 
class=identifier>vector</span><span class=special><</span><span 
class=keyword>int</span><span class=special>></span><span 
class=identifier> v</span><span class=special>; </span>
<span class=identifier>v </span><span class=special>+= </span><span 
class=number>1</span><span
class=special>,</span><span class=number>2</span><span 
class=special>,</span><span class=number>3</span><span 
class=special>,</span><span class=number>4</span><span 
class=special>,</span><span class=number>5</span><span 
class=special>,</span><span class=number>6</span><span 
class=special>,</span><span class=number>7</span><span 
class=special>,</span><span class=number>8</span><span 
class=special>,</span><span class=number>9</span><span class=special>;</span></pre></p>
       <li> A parenthesis-separated list: 
             <p>       
             <pre>
<span class=identifier>map</span><span class=special><</span><span 
class=identifier>string</span><span class=special>,</span><span class=keyword>int</span><span class=special>> </span><span class=identifier>m</span><span class=special>; </span>
<span class=identifier>insert</span><span class=special>( </span><span class=identifier>m </span><span class=special>)( </span><span class=string>&quot;Bar&quot;</span><span class=special>, </span><span class=number>1 </span><span class=special>)( </span><span class=string>&quot;Foo&quot;</span><span class=special>, </span><span class=number>2 </span><span class=special>);</span></pre> 
    </ul> 
<p>
    These lists are particularly useful in
    learning, testing, and prototyping situations, but can also be handy otherwise. 
      The library comes with predefined operators for the containers of the  
      standard library, but most functionality will work with any standard 
compliant container. The library also makes it possible to extend user
  defined types so for example a member function can be called for a list of 
values instead of its normal arguments. </p>
   <hr>
   
   <a name="tutorial"></a>
   <h2>Tutorial</h2>
   <p>
   Within two minutes you should be able to use this library. The main 
components are explained in these sections:
   <ul>
        <li>Function <a href="#operator+="><code>operator+=()</code></a>
        <li>Function <a href="#operator()"><code>operator()()</code></a>
        <li>Function <a href="#list_of"><code>list_of()</code></a>    
        <li>Function <a href="#map_list_of"><code>map_list_of()</code></a> 
        <li>Function <a href="#tuple_list_of"><code>tuple_list_of()</code></a>   
        <li>Functions <a href="#repeat"><code>repeat()</code>, <code>repeat_fun()</code> and <code>range()</code> </a>
        <li>Functions <a href="#ref_list_of"><code>ref_list_of()</code></a>, <a href="#ref_list_of"><code>cref_list_of()</code></a>  and related functions  
        <li>Functions <a href="#ref_csv"><code>ref_csv()</code></a>, <a href="#ref_csv"><code>cref_csv()</code></a> and related functions   
        <li>A <a href="#complicated">"complicated"</a> example    
        <li>Functions <a href="#ptr_push_back"><code>ptr_push_back(), ptr_push_front()</code>, <code>ptr_insert()</code> and <code>ptr_map_insert()</code></a>
        <li>Function <a href="#ptr_list_of"><code>ptr_list_of()</code></a>         
            
   </ul>
   The two first functions are used for adding elements after a container object
   has been created whereas the next two is used when we need to initialize an 
   object. </p>
   <h3>Function <code>operator+=()</code><a name="operator+="></h3>
   <p>
    To fill a vector (or any standard container) with values using 
    <code>operator+=()</code> you write   
    <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>vector</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'operator+=()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;; 
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'operator+=()' into scope
</span><span class=special>
</span><span class=special>{
    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>values</span><span class=special>;  
    </span><span class=identifier>values </span><span class=special>+= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>,</span><span class=number>4</span><span class=special>,</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>; </span><span class=comment>// insert values at the end of the container
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>values</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>9 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>values</span><span class=special>[</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>values</span><span class=special>[</span><span class=number>8</span><span class=special>] </span><span class=special>== </span><span class=number>9 </span><span class=special>);
</span><span class=special>}</span></pre></blockquote>

    Here we only stuffed constants into the container, but the list can
    consists of arbitrary expressions as long as the result of each  
expression is convertible to the <code>value_type</code> of the container.
   </p> 
   
   
   <h3>Function <code>operator()()</code> <a name="operator()"></h3>
   <p>
   We do not call <code>operator()()</code> directly, but instead we call a 
   function that returns a proxy-object that defines <code>operator()()</code>.
   The function that returns the proxy object is always named after the member
   function that is used to copy the values in the list into the container.
   So to fill a map with pairs of values you write 
   <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span 
class=identifier>boost</span><span class=special>/</span><span 
class=identifier>assign</span><span class=special>/</span><span 
class=identifier>list_inserter</span><span class=special>.</span><span 
class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'insert()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'insert()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=identifier>map</span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>months</span><span class=special>;  
    </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>months </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;january&quot;</span><span class=special>,   </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;february&quot;</span><span class=special>, </span><span class=number>28 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;march&quot;</span><span class=special>,     </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;april&quot;</span><span class=special>,    </span><span class=number>30 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;may&quot;</span><span class=special>,       </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;june&quot;</span><span class=special>,     </span><span class=number>30 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;july&quot;</span><span class=special>,      </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;august&quot;</span><span class=special>,   </span><span class=number>31 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;september&quot;</span><span class=special>, </span><span class=number>30 </span><span class=special>)( </span><span class=string>&quot;october&quot;</span><span class=special>,  </span><span class=number>31 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;november&quot;</span><span class=special>,  </span><span class=number>30 </span><span class=special>)( </span><span class=string>&quot;december&quot;</span><span class=special>, </span><span class=number>31 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>months</span><span class=special>.</span><span 
class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>12 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>months</span><span class=special>[</span><span class=string>&quot;january&quot;</span><span class=special>] </span><span class=special>== </span><span class=number>31 </span><span class=special>);
</span><span class=special>}</span> </pre></blockquote>

   Note that <code>operator()()</code> is much more handy when
   we need to construct objects using several arguments
   (up to five arguments are supported by default, but the limit can be <a href="#limit">customized</a>).
    This is also true for sequences:

      <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span 
class=identifier>boost</span><span class=special>/</span><span 
class=identifier>assign</span><span class=special>/</span>list_inserter</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'push_front()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>utility</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'push_front()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=keyword>typedef </span><span class=identifier>pair</span><span class=special>&lt; </span><span class=identifier>string</span><span class=special>,</span><span class=identifier>string </span><span class=special>&gt; </span><span class=identifier>str_pair</span><span class=special>;
    </span><span class=identifier>deque</span><span class=special>&lt;</span><span class=identifier>str_pair</span><span class=special>&gt; </span><span class=identifier>deq</span><span class=special>;
    </span><span class=identifier>push_front</span><span class=special>( </span><span class=identifier>deq </span><span class=special>)( </span><span class=string>&quot;foo&quot;</span><span class=special>, </span><span class=string>&quot;bar&quot;</span><span class=special>)( </span><span class=string>&quot;boo&quot;</span><span class=special>, </span><span class=string>&quot;far&quot; </span><span class=special>); 
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>2 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>front</span><span class=special>().</span><span class=identifier>first </span><span class=special>== </span><span class=string>&quot;boo&quot; </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>back</span><span class=special>().</span><span class=identifier>second </span><span class=special>== </span><span class=string>&quot;bar&quot; </span><span class=special>);
</span><span class=special>}   </span></pre></blockquote>

   Besides <code>push_front()</code> we could also have used
   <code>push_back()</code> if the container has a corresponding member
   function. Empty parentheses can be used to insert default-constructed 
objects, for example, 
<code>push_front( deq )()()</code> will insert two default-constructed 
<code>str_pair</code> objects. </p>   
   
   <p>
   If <code>operator()()</code> is too cumbersome to use with eg. 
<code>push_front()</code>we can also say </p>

<blockquote>
    <pre>
<span class=identifier>deque</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>di</span><span class=special>;    </span>
<span class=identifier>push_front</span><span class=special>( </span><span class=identifier>di </span><span class=special>) </span><span class=special>= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>,</span><span class=number>4</span><span class=special>,</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>;</span>
<span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>di</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>9 </span><span class=special>);    </span>
<span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span 
class=identifier>di</span><span class=special>[</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>9 </span><span class=special>);    </span>
</pre>
</blockquote>
<p>
Just to make it perfectly clear, the code above is not restricted to the 
standard containers, but will work with all <i>standard compliant</i> containers 
with the right member function. It is only <code>operator+=()</code> that has been restricted to 
the standard containers. </p>
  
  <h3>Function <code>list_of()</code> <a name="list_of"></h3>
  But what if we need to <i>initialize</i> a container? This is where 
  <code>list_of()</code> comes into play. With <code>list_of()</code>
  we can create anonymous lists that automatically converts to
  any container:
  <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'list_of()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>list</span><span class=special>&gt;
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>stack</span><span class=special>&gt;
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'list_of()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=keyword>const </span><span class=identifier>list</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>primes </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>5</span><span class=special>)(</span><span class=number>7</span><span class=special>)(</span><span class=number>11</span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>primes</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>5 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>primes</span><span class=special>.</span><span class=identifier>back</span><span class=special>() </span><span class=special>== </span><span class=number>11 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>primes</span><span class=special>.</span><span class=identifier>front</span><span class=special>() </span><span class=special>== </span><span class=number>2 </span><span class=special>);
   
    </span><span class=keyword>const </span><span 
class=identifier>stack</span><span class=special>&lt;</span><span 
class=identifier>string</span><span class=special>&gt; </span><span 
class=identifier>names </span><span class=special>= </span><span 
class=special></span><span class=identifier>list_of</span><span class=special>( </span><span class=string>&quot;Mr. Foo&quot; </span><span class=special>)( </span><span class=string>&quot;Mr. Bar&quot;</span><span class=special>)( </span><span class=string>&quot;Mrs. FooBar&quot; </span><span
class=special>).</span><span class=identifier>to_adapter();
    </span><span class=keyword>const </span><span 
class=identifier>stack</span><span class=special>&lt;</span><span 
class=identifier>string</span><span class=special>&gt; </span><span 
class=identifier>names2 </span><span class=special>= </span><span 
class=special>(</span><span class=identifier>list_of</span><span class=special>( </span><span class=string>&quot;Mr. Foo&quot; </span><span class=special>), </span><span class=string>&quot;Mr. Bar&quot;</span><span class=special>, </span><span class=string>&quot;Mrs. FooBar&quot; </span><span
class=special>).</span><span class=identifier>to_adapter();
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>names</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>names</span><span class=special>.</span><span class=identifier>top</span><span class=special>()</span><span class=special> == </span><span class=string>&quot;Mrs. FooBar&quot; </span><span class=special>);
</span><span class=special>}   </span></pre></blockquote>
  If we need to initialize a container adapter, we need to help the compiler a 
little by calling <code>to_adapter()</code>. As the second example also shows, 
we can use a comma-separated
list with <code>list_of()</code> if we add parenthesis around the 
  entire right hand side. It is worth noticing that the first argument
  of <code>list_of()</code> determines the type of the anonymous list.
  In case of the stack, the anonymous list consists of
  <code>const char*</code> objects which are then converted to 
  a stack of <code>string</code> objects. The conversion is always  
  possible as long as the conversion between the stored types is possible.
 </p>
 <p>
 Please notice that <code>list_of()</code> can even convert to a 
 <code>boost::<a 
href="../../array/index.html">array</a>&lt;T,sz></code> and see also the list 
of <a href="#boost_libs">supported libraries </a>. </p>
           <p>
               Note that the type returned by 
               <code>list_of()</code> (and its variants) has overloaded comparison operators. This allows you to
               write test code such as 
                   <code>
                       BOOST_CHECK_EQUAL( my_container, list_of(2)(3)(4)(5) );.
                   </code>
               </p>
 
 <h3>Function <code>map_list_of()</code> <a name="map_list_of"></h3>
 This function is defined for pure convenience when working with
 maps. Its usage is simple:
 <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'map_list_of()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>map</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'map_list_of()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>next </span><span class=special>= </span><span class=identifier>map_list_of</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>)(</span><span class=number>3</span><span class=special>,</span><span class=number>4</span><span class=special>)(</span><span class=number>4</span><span class=special>,</span><span class=number>5</span><span class=special>)(</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>5 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>1 </span><span class=special>] </span><span class=special>== </span><span class=number>2 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>5 </span><span class=special>] </span><span class=special>== </span><span class=number>6 </span><span class=special>);
    
    </span><span class=comment>// or we can use 'list_of()' by specifying what type
    // the list consists of
    </span><span class=identifier>next </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>&lt; </span><span class=identifier>pair</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=special>&gt;(</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>)(</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>)(</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>6 </span><span class=special>] </span><span class=special>== </span><span class=number>7 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>8 </span><span class=special>] </span><span class=special>== </span><span class=number>9 </span><span class=special>);      
</span><span class=special>}   </span></pre></blockquote>

The function <code>pair_list_of()</code> may also be used.

<h3>Function <code>tuple_list_of()</code> <a name="tuple_list_of"></h3>

If you are working with tuples, it might be convenient to use 
<code>tuple_list_of()</code>:


<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>vector</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
</span>
<span class=special>{
    </span><span class=keyword>typedef </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>tuple</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>tuple</span><span class=special>;

    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>tuple</span><span class=special>&gt; </span><span class=identifier>v </span><span class=special>= </span><span class=identifier>tuple_list_of</span><span class=special>( </span><span class=number>1</span><span class=special>, </span><span class=string>&quot;foo&quot;</span><span class=special>, </span><span class=number>2 </span><span class=special>)( </span><span class=number>3</span><span class=special>, </span><span class=string>&quot;bar&quot;</span><span class=special>, </span><span class=number>4 </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>2 </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK</span><span class=special>( </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>get</span><span class=special>&lt;</span><span class=number>0</span><span class=special>&gt;( </span><span class=identifier>v</span><span class=special>[</span><span class=number>1</span><span class=special>] </span><span class=special>) </span><span class=special>==  </span><span class=number>3 </span><span class=special>);</span>
<span class=special>}</span>
    </pre>
</blockquote>

<h3>Functions <code>repeat()</code>, <code>repeat_fun()</code> and <code>range()</code> <a name="repeat"></h3> 
<p>
Sometimes it is too irritating to repeat the same value many times. This is 
where <code>repeat()</code> can be handy:
<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>vector</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;</span>
<span class=special> </span>
<span class=special>{
    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>v</span><span class=special>;
    </span><span class=identifier>v </span><span class=special>+= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>,</span><span class=identifier>repeat</span><span class=special>(</span><span class=number>10</span><span class=special>,</span><span class=number>4</span><span class=special>),</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>;
    </span><span class=comment>// v = [1,2,3,4,4,4,4,4,4,4,4,4,4,5,6,7,8,9]
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>+ </span><span class=number>10 </span><span class=special>+ </span><span class=number>5 </span><span class=special>);
    
    </span><span class=identifier>v </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>).</span><span class=identifier>repeat</span><span class=special>(</span><span class=number>5</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>);
    </span><span class=comment>// v = [1,2,2,2,2,2,3]
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>1 </span><span class=special>+ </span><span class=number>5 </span><span class=special>+ </span><span class=number>1 </span><span class=special>);
    
    </span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>v </span><span class=special>)(</span><span class=number>1</span><span class=special>).</span><span class=identifier>repeat</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>);
    </span><span class=comment>// v = old v + [1,2,3]
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>10 </span><span class=special>);</span>
<span class=special>}</span></pre>
</blockquote>
As we can see, then the first argument to <code>repeat()</code> is the number
of times to repeat the second argument.
</p>
<p>
A more general list can be constructed with <code>repeat_fun()</code>:

<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>vector</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>cstdlib</span><span class=special>&gt; </span><span class=comment>// for 'rand()'              
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;</span>
<span class=special> </span>
<span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;</span>
<span class=keyword>struct </span><span class=identifier>next    </span>
<span class=special>{
    </span><span class=identifier>T </span><span class=identifier>seed</span><span class=special>;
    </span><span class=identifier>next</span><span class=special>( </span><span class=identifier>T </span><span class=identifier>seed </span><span class=special>) </span><span class=special>: </span><span class=identifier>seed</span><span class=special>(</span><span class=identifier>seed</span><span class=special>) 
    </span><span class=special>{ </span><span class=special>}
    
    </span><span class=identifier>T </span><span class=keyword>operator</span><span class=special>()() </span><span class=keyword>
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>seed</span><span class=special>++;
    </span><span class=special>}</span>
<span class=special>};</span>
<span class=special>     </span>
<span class=special>{
    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>v</span><span class=special>;
    </span><span class=identifier>v </span><span class=special>+= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=identifier>repeat_fun</span><span class=special>(</span><span class=number>4</span><span class=special>,&amp;</span><span class=identifier>rand</span><span class=special>),</span><span class=number>4</span><span class=special>;
    </span><span class=comment>// v = [1,2,?,?,?,?,4] 
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>7 </span><span class=special>);
    
    </span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>v </span><span class=special>).</span><span class=identifier>repeat_fun</span><span class=special>(</span><span class=number>4</span><span class=special>,</span><span class=identifier>next</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;(</span><span class=number>0</span><span class=special>))(</span><span class=number>4</span><span class=special>).</span><span class=identifier>repeat_fun</span><span class=special>(</span><span class=number>4</span><span class=special>,</span><span class=identifier>next</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;(</span><span class=number>5</span><span class=special>));
    </span><span class=comment>// v = old v + [0,1,2,3,4,5,6,7,8] 
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>16 </span><span class=special>);</span>
<span class=special>}</span>        </pre>
</blockquote>
The only requirement of the second argument to <code>repeat_fun()</code> is that 
it is a nullary function. </p>


<p>
If you just need to insert an iterator-range somewhere in the list, the member function <code>range()</code> provides just what you want.
It is based on <a href="../../range/index.html">Boost.Range</a>, so you can pass all the ranges supported by that library. For example
<blockquote><pre><span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_inserter</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span> <span class=comment>// for 'push_back()'</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>       <span class=comment>// for 'list_of()' and 'ref_list_of()'</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>

<span class=keyword>using</span> <span class=keyword>namespace</span> <span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using</span> <span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;</span>
 
<span class=special>{</span>
    <span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;</span> <span class=identifier>v</span><span class=special>,</span> <span class=identifier>v2</span><span class=special>;</span>
    <span class=identifier>v</span>  <span class=special>=</span> <span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>);</span>
    <span class=identifier>v2</span> <span class=special>=</span> <span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>).</span><span class=identifier>range</span><span class=special>(</span><span class=identifier>v</span><span class=special>).</span><span class=identifier>range</span><span class=special>(</span><span class=identifier>v</span><span class=special>.</span><span class=identifier>begin</span><span class=special>(),</span><span class=identifier>v</span><span class=special>.</span><span class=identifier>end</span><span class=special>())(</span><span class=number>4</span><span class=special>);</span>
    <span class=comment>// v2 = [0,1,2,3,1,2,3,4]</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>v2</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>8u</span> <span class=special>);</span>

    <span class=identifier>push_back</span><span class=special>(</span> <span class=identifier>v</span> <span class=special>).</span><span class=identifier>range</span><span class=special>(</span><span class=identifier>v2</span><span class=special>)(</span><span class=number>5</span><span class=special>);</span>
    <span class=comment>// v = [1,2,3,0,1,2,3,1,2,3,4,5]</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>12u</span> <span class=special>);</span> 

    <span class=comment>//
    // create a list of references, some coming from a container, others from the stack 
    //</span>
    <span class=keyword>int</span> <span class=identifier>x</span> <span class=special>=</span> <span class=number>0</span><span class=special>;</span>
    <span class=keyword>int</span> <span class=identifier>y</span> <span class=special>=</span> <span class=number>1</span><span class=special>;</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>ref_list_of</span><span class=special>&lt;</span><span class=number>10</span><span class=special>&gt;(</span><span class=identifier>x</span><span class=special>).</span><span class=identifier>range</span><span class=special>(</span><span class=identifier>v2</span><span class=special>)(</span><span class=identifier>y</span><span class=special>).</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>10u</span> <span class=special>);</span>
<span class=special>}</span></pre>
</blockquote>
As you can see, one can also pass two iterators if that is more appropriate.
The last example also introduces list of references. More about that below.

</p>

<h3>Functions <code>ref_list_of()</code>, <code>cref_list_of()</code> <a name="ref_list_of"> and related functions</h3>

When you need to create an anonymous range of values and speed is essential, 
these two functions provide what you want. <blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>auto_size</span><span class=special>/</span><span class=identifier>ref_list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>range</span><span class=special>/</span><span class=identifier>algorithm</span><span class=special>/</span><span class=identifier>max_element</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
</span>
<span class=special>{
    </span><span class=keyword>int </span><span class=identifier>a</span><span class=special>=</span><span class=number>1</span><span class=special>,</span><span class=identifier>b</span><span class=special>=</span><span class=number>5</span><span class=special>,</span><span class=identifier>c</span><span class=special>=</span><span class=number>3</span><span class=special>,</span><span class=identifier>d</span><span class=special>=</span><span class=number>4</span><span class=special>,</span><span class=identifier>e</span><span class=special>=</span><span class=number>2</span><span class=special>,</span><span class=identifier>f</span><span class=special>=</span><span class=number>9</span><span class=special>,</span><span class=identifier>g</span><span class=special>=</span><span class=number>0</span><span class=special>,</span><span class=identifier>h</span><span class=special>=</span><span class=number>7</span><span class=special>;
    </span><span class=keyword>int</span><span class=special>&amp; </span><span class=identifier>max </span><span class=special>= </span><span class=special>*</span><span class=identifier>boost::max_element</span><span class=special>( </span><span class=identifier>ref_list_of</span><span class=special>(</span><span class=identifier>a</span><span class=special>)(</span><span class=identifier>b</span><span class=special>)(</span><span class=identifier>c</span><span class=special>)(</span><span class=identifier>d</span><span class=special>)(</span><span class=identifier>e</span><span class=special>)(</span><span class=identifier>f</span><span class=special>)(</span><span class=identifier>g</span><span class=special>)(</span><span class=identifier>h</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK_EQUAL</span><span class=special>( </span><span class=identifier>max</span><span class=special>, </span><span class=identifier>f </span><span class=special>);
    </span><span class=identifier>max </span><span class=special>= </span><span class=number>8</span><span class=special>;
    </span><span class=identifier>BOOST_CHECK_EQUAL</span><span class=special>( </span><span class=identifier>f</span><span class=special>, </span><span class=number>8 </span><span class=special>);
    </span><span class=keyword>const </span><span class=keyword>int</span><span class=special>&amp; </span><span class=identifier>const_max </span>
    	<span class=special>= </span><span class=special>*</span><span class=identifier>boost::max_element</span><span class=special>( </span><span class=identifier>cref_list_of</span><span class=special>(</span><span class=identifier>1</span><span class=special>)(</span><span class=identifier>5</span><span class=special>)(</span><span class=identifier>3</span><span class=special>)(</span><span class=identifier>d</span><span class=special>)(</span><span class=identifier>e</span><span class=special>)(</span><span class=identifier>f</span><span class=special>)(</span><span class=identifier>g</span><span class=special>)(</span><span class=identifier>h</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK_EQUAL</span><span class=special>( </span><span class=identifier>max</span><span class=special>, </span><span class=identifier>const_max </span><span class=special>);</span>
<span class=special>}</span>
    </pre>
</blockquote>

You can only use lvalues with <code>ref_list_of()</code> while 
<code>cref_list_of()</code> accepts rvalues too, as exemplified by the first three arguments of the 
corresponding function call in this example. 

<p> The collection built from <code>ref_list_of()</code> and <code>cref_list_of()</code> has most of the functionality of <code>boost::array<></code>, and 
the same conversion capabilities as the collection built from <code>list_of()</code>. However, the user can design his own 'policy' and call it with the overloaded functions
<code>ref_list_of&lt;P&gt;()</code> and 
<code>cref_list_of&lt;P&gt;()</code>, where <code>P</code> is an associated policy tag. See the <a href="#ref-ref_list_of">reference</a> for details
</p>

<p>
There are overloads which predate the above functions,
<code>ref_list_of&lt;int&gt;()</code> and <code>cref_list_of&lt;int&gt;()</code>, whose integer template parameter specifies the maximum number of arguments. 
The resulting collection builder exposes a similar interface to that above, save for the specifics of an array, and is not customizable via a policy.
See the <a href="#ref-list_of">reference</a> for details
</p>

<p>
A variation on <code>ref_list_of()</code> and <code>cref_list_of()</code>, are <code>ref_rebind_list_of()</code> and <code>cref_rebind_list_of()</code>, respectively, that have rebind, 
rather than copy semantics, when the collection is used as the left hand side of an assignement. These are discouraged unless this specific feature is required. See the <a href="#ref-ref_list_of">reference</a>.
</p>

<h3>Functions <code>ref_csv()</code>, <code>cref_csv()</code> <a name="ref_csv"> and related functions</h3>

The functions <a href="#ref_list_of"><code>ref_list_of()</code></a>, <a href="#ref_list_of"><code>cref_list_of()</code></a>, 
their respective rebind analogs, and the overloads of these four whose policy is specified by a template parameter, 
have counterparts that are identified by suffix 'csv' (comma separated values) instead of 'list_of'. For example,
<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>auto_size</span><span class=special>/</span><span class=identifier>ref_csv</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>range</span><span class=special>/</span><span class=identifier>algorithm</span><span class=special>/</span><span class=identifier>max_element</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
</span>
<span class=special>{
    </span><span class=keyword>int </span><span class=identifier>a</span><span class=special>=</span><span class=number>1</span><span class=special>,</span><span class=identifier>b</span><span class=special>=</span><span class=number>5</span><span class=special>,</span><span class=identifier>c</span><span class=special>=</span><span class=number>3</span><span class=special>,</span><span class=identifier>d</span><span class=special>=</span><span class=number>4</span><span class=special>,</span><span class=identifier>e</span><span class=special>=</span><span class=number>2</span><span class=special>,</span><span class=identifier>f</span><span class=special>=</span><span class=number>9</span><span class=special>,</span><span class=identifier>g</span><span class=special>=</span><span class=number>0</span><span class=special>,</span><span class=identifier>h</span><span class=special>=</span><span class=number>7</span><span class=special>;
    </span><span class=keyword>int</span><span class=special>&amp; </span><span class=identifier>max </span><span class=special>= </span><span class=special>*</span><span class=identifier>boost::max_element</span><span class=special>( </span><span class=identifier>ref_csv</span><span class=special>(</span><span class=identifier>a</span><span class=special>,</span><span class=identifier>b</span><span class=special>,</span><span class=identifier>c</span><span class=special>,</span><span class=identifier>d</span><span class=special>,</span><span class=identifier>e</span><span class=special>,</span><span class=identifier>f</span><span class=special>,</span><span class=identifier>g</span><span class=special>,</span><span class=identifier>h</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK_EQUAL</span><span class=special>( </span><span class=identifier>max</span><span class=special>, </span><span class=identifier>f </span><span class=special>);
}</span>
    </pre>
</blockquote>

<p> The result of a csv call has the same array and conversion capabilities as its non-csv counterpart. 
The main difference is that the the collection is not extensible. See the <a href="#ref-ref_csv">reference</a>.</p>

<p> The maximum number of arguments to a csv function is <code>BOOST_ASSIGN_CSV_SIZE</code>. </p>

<h3>A "complicated" example <a name="complicated"></h3>
<p> 
As a last example, let us assume that we need to keep track of the
result of soccer matches. A team will get one point if it wins 
and zero otherwise. If there has been played three games in each group, the code might look
like this:

<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span 
class=identifier>boost</span><span class=special>/</span><span 
class=identifier>assign</span><span class=special>/</span><span 
class=identifier>list_inserter</span><span class=special>.</span><span 
class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>vector</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
 </span>
<span class=special>{
    </span><span class=keyword>typedef </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;                   </span><span class=identifier>score_type</span><span class=special>;
    </span><span class=keyword>typedef </span><span class=identifier>map</span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>,</span><span class=identifier>score_type</span><span class=special>&gt;        </span><span class=identifier>team_score_map</span><span class=special>;
    </span><span class=keyword>typedef </span><span class=identifier>pair</span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>,</span><span class=identifier>score_type</span><span class=special>&gt;       </span><span class=identifier>score_pair</span><span class=special>;

    </span><span class=identifier>team_score_map </span><span class=identifier>group1</span><span class=special>, </span><span class=identifier>group2</span><span class=special>;
    
    </span><span class=comment>//
    // method 1: using 'insert()'
    //
    </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>group1 </span><span class=special>)( </span><span class=string>&quot;Denmark&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>1</span><span class=special>) </span><span class=special>)
                    </span><span class=special>( </span><span class=string>&quot;Germany&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>)(</span><span class=number>0</span><span class=special>) </span><span class=special>)
                    </span><span class=special>( </span><span class=string>&quot;England&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>)(</span><span class=number>1</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group1</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group1</span><span class=special>[ </span><span class=string>&quot;Denmark&quot; </span><span class=special>][</span><span class=number>1</span><span class=special>] </span><span class=special>== </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group1</span><span class=special>[ </span><span class=string>&quot;Germany&quot; </span><span class=special>][</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>0 </span><span class=special>);
    
    </span><span class=comment>//
    // method 2: using 'list_of()'
    //
    </span><span class=identifier>group2 </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>&lt; </span><span class=identifier>score_pair </span><span class=special>&gt;
                        </span><span class=special>( </span><span class=string>&quot;Norway&quot;</span><span class=special>,  </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>0</span><span class=special>) </span><span class=special>)
                        </span><span class=special>( </span><span class=string>&quot;USA&quot;</span><span class=special>,     </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>)(</span><span class=number>0</span><span class=special>) </span><span class=special>)
                        </span><span class=special>( </span><span class=string>&quot;Andorra&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>1</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group2</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group2</span><span class=special>[ </span><span class=string>&quot;Norway&quot; </span><span class=special>][</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group2</span><span class=special>[ </span><span class=string>&quot;USA&quot; </span><span class=special>][</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>0 </span><span class=special>);</span>
<span class=special>}</span>
    </pre>
</blockquote>

In the first example, notice how the result of <code>list_of()</code>
can be converted automatically to a <code>vector&lt;int></code> because
<code>insert()</code> knows it expects a <code>vector&lt;int></code>.
In the second example we can see that <code>list_of()</code> is somewhat
less intelligent since here it needs to be told explicitly what arguments to
expect. (In the future it might be possible to introduce a more intelligent
conversion layer in <code>list_of()</code>.)
</p>

<h3>Functions <code>ptr_push_back(), 
ptr_push_front()</code>, <code>ptr_insert()</code> and <code>ptr_map_insert()</code> <a name="ptr_push_back"></h3>

For use with <a href="../../ptr_container/index.html">Boost.Pointer Container</a>
a few special exception-safe functions are provided. Using these function you
do not need to call <code>new</code> manually:


<blockquote>
    <pre>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>ptr_list_inserter</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span> <span class=comment>// for 'ptr_push_back()', 'ptr_insert()' and 'ptr_push_front()'</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>ptr_map_inserter</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>  <span class=comment>// for 'ptr_map_insert()'</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>ptr_container</span><span class=special>/</span><span class=identifier>ptr_deque</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>ptr_container</span><span class=special>/</span><span class=identifier>ptr_set</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include</span> <span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>ptr_container</span><span class=special>/</span><span class=identifier>ptr_map</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>

<span class=comment>//
// Example class
//</span>
<span class=keyword>struct</span> <span class=identifier>Foo</span>
<span class=special>{</span>
    <span class=keyword>int</span> <span class=identifier>i</span><span class=special>;</span>
    
    <span class=identifier>Foo</span><span class=special>()</span> <span class=special>:</span> <span class=identifier>i</span><span class=special>(</span><span class=number>0</span><span class=special>)</span>
    <span class=special>{</span> <span class=special>}</span>
    <span class=identifier>Foo</span><span class=special>(</span> <span class=keyword>int</span> <span class=identifier>i</span> <span class=special>)</span> <span class=special>:</span> <span class=identifier>i</span><span class=special>(</span><span class=identifier>i</span><span class=special>)</span>
    <span class=special>{</span> <span class=special>}</span>
    <span class=identifier>Foo</span><span class=special>(</span> <span class=keyword>int</span> <span class=identifier>i</span><span class=special>,</span> <span class=keyword>int</span> <span class=special>)</span> <span class=special>:</span> <span class=identifier>i</span><span class=special>(</span><span class=identifier>i</span><span class=special>)</span>
    <span class=special>{</span> <span class=special>}</span>
    <span class=identifier>Foo</span><span class=special>(</span> <span class=keyword>const</span> <span class=keyword>char</span><span class=special>*,</span> <span class=keyword>int</span> <span class=identifier>i</span><span class=special>,</span> <span class=keyword>int</span> <span class=special>)</span> <span class=special>:</span> <span class=identifier>i</span><span class=special>(</span><span class=identifier>i</span><span class=special>)</span>
    <span class=special>{</span> <span class=special>}</span>

    <span class=keyword>virtual</span> <span class=special>~</span><span class=identifier>Foo</span><span class=special>()</span>
    <span class=special>{}</span>
<span class=special>};</span>

<span class=keyword>struct</span> <span class=identifier>Bar</span> <span class=special>:</span> <span class=identifier>Foo</span>
<span class=special>{</span>
    <span class=identifier>Bar</span><span class=special>()</span>
    <span class=special>{</span> <span class=special>}</span>
    
    <span class=identifier>Bar</span><span class=special>(</span> <span class=keyword>int</span> <span class=identifier>i</span> <span class=special>)</span> <span class=special>:</span> <span class=identifier>Foo</span><span class=special>(</span> <span class=number>42</span> <span class=special>)</span>
    <span class=special>{</span> <span class=special>}</span>
<span class=special>};</span>

<span class=comment>//
// Required by ptr_set&lt;Foo&gt;
//</span>
<span class=keyword>inline</span> <span class=keyword>bool</span> <span class=keyword>operator</span><span class=special>&lt;(</span> <span class=identifier>Foo</span> <span class=identifier>l</span><span class=special>,</span> <span class=identifier>Foo</span> <span class=identifier>r</span> <span class=special>)</span>
<span class=special>{</span>
    <span class=keyword>return</span> <span class=identifier>l</span><span class=special>.</span><span class=identifier>i</span> <span class=special>&lt;</span> <span class=identifier>r</span><span class=special>.</span><span class=identifier>i</span><span class=special>;</span>
<span class=special>}</span>

 
<span class=keyword>using</span> <span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>;</span>
<span class=keyword>using</span> <span class=keyword>namespace</span> <span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;</span>

<span class=keyword>int</span> <span class=identifier>main</span><span class=special>()</span>
<span class=special>{</span>
    <span class=identifier>ptr_deque</span><span class=special>&lt;</span><span class=identifier>Foo</span><span class=special>&gt;</span> <span class=identifier>deq</span><span class=special>;</span>
    <span class=identifier>ptr_push_back</span><span class=special>(</span> <span class=identifier>deq</span> <span class=special>)()();</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>2u</span> <span class=special>);</span>
    <span class=identifier>ptr_push_back</span><span class=special>&lt;</span><span class=identifier>Bar</span><span class=special>&gt;(</span> <span class=identifier>deq</span> <span class=special>)()();</span> <span class=comment>// insert 'Bar' objects</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>4u</span> <span class=special>);</span>
    <span class=identifier>ptr_push_front</span><span class=special>(</span> <span class=identifier>deq</span> <span class=special>)(</span> <span class=number>3</span> <span class=special>)(</span> <span class=number>42</span><span class=special>,</span> <span class=number>42</span> <span class=special>)(</span> <span class=string>&quot;foo&quot;</span><span class=special>,</span> <span class=number>42</span><span class=special>,</span> <span class=number>42</span> <span class=special>);</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>7u</span> <span class=special>);</span>

    <span class=identifier>ptr_set</span><span class=special>&lt;</span><span class=identifier>Foo</span><span class=special>&gt;</span> <span class=identifier>a_set</span><span class=special>;</span>
    <span class=identifier>ptr_insert</span><span class=special>(</span> <span class=identifier>a_set</span> <span class=special>)()(</span> <span class=number>1</span> <span class=special>)(</span> <span class=number>2</span><span class=special>,</span> <span class=number>2</span> <span class=special>)(</span> <span class=string>&quot;foo&quot;</span><span class=special>,</span> <span class=number>3</span><span class=special>,</span> <span class=number>3</span> <span class=special>);</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>a_set</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>4u</span> <span class=special>);</span>
    <span class=identifier>ptr_insert</span><span class=special>(</span> <span class=identifier>a_set</span> <span class=special>)()()()();</span>
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>a_set</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>4u</span> <span class=special>);</span> <span class=comment>// duplicates not inserted</span>
    <span class=identifier>ptr_insert</span><span class=special>&lt;</span><span class=identifier>Bar</span><span class=special>&gt;(</span> <span class=identifier>a_set</span> <span class=special>)(</span> <span class=number>42</span> <span class=special>);</span> <span class=comment>// insert a 'Bar' object</span> 
    <span class=identifier>BOOST_ASSERT</span><span class=special>(</span> <span class=identifier>a_set</span><span class=special>.</span><span class=identifier>size</span><span class=special>()</span> <span class=special>==</span> <span class=number>5u</span> <span class=special>);</span>

    <span class=identifier>ptr_map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=identifier>Foo</span><span class=special>&gt;</span> <span class=identifier>a_map</span><span class=special>;</span>
    <span class=identifier>ptr_map_insert</span><span class=special>(</span> <span class=identifier>a_map</span> <span class=special>)(</span> <span class=number>1</span> <span class=special>)(</span> <span class=number>2</span><span class=special>,</span> <span class=number>2</span> <span class=special>)(</span> <span class=number>3</span><span class=special>,</span> <span class=number>3</span><span class=special>,</span> <span class=number>3</span> <span class=special>)(</span> <span class=number>4</span><span class=special>,</span> <span class=string>&quot;foo&quot;</span><span class=special>,</span> <span class=number>4</span><span class=special>,</span> <span class=number>4</span> <span class=special>);</span>
    <span class=identifier>ptr_map_insert</span><span class=special>&lt;</span><span class=identifier>Bar</span><span class=special>&gt;(</span> <span class=identifier>a_map</span> <span class=special>)(</span> <span class=number>42</span><span class=special>,</span> <span class=number>42</span> <span class=special>);</span> <span class=comment>// insert a  'Bar' object</span>
<span class=special>}</span>
    </pre>
</blockquote>

Notice how you may provide a template argument to these functions. This argument determines the type to allocate with <code>new</code>.
You have to specify this argument when the container is based on an abstract type (because one cannot create objects of such a type).

<p>
For <code>ptr_map_insert()</code> the first argument <code>arg1</code> in an argument tuple <code>(arg1,arg2,...,argN)</code> is used to
construct a key; this means that the first argument need only be convertible to the <code>key_type</code> of the container.
The rest of the arguments are used to construct the mapped object.
</p>
                        
<h3>Function <code>ptr_list_of()</code> <a name="ptr_list_of"></h3>         

Just like you can use <code>list_of()</code> to initialize containers, you can 
use <code>ptr_list_of()</code> to initialize a <a href="../../ptr_container/index.html">pointer container</a>.
Here is a small example:

<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>ptr_list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>ptr_container</span><span class=special>/</span><span class=identifier>ptr_deque</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
</span>
<span class=special>{
    </span><span class=identifier>ptr_deque</span><span class=special>&lt;</span><span class=identifier>Foo</span><span class=special>&gt; </span><span class=identifier>deq</span><span class=special>;
    </span><span class=identifier>deq </span><span class=special>= </span><span class=identifier>ptr_list_of</span><span class=special>&lt;</span><span class=identifier>Foo</span><span class=special>&gt;( </span><span class=number>42 </span><span class=special>)()()( </span><span class=number>3</span><span class=special>, </span><span class=number>3 </span><span class=special>)( </span><span class=string>&quot;foo&quot;</span><span class=special>, </span><span class=number>2</span><span class=special>, </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_CHECK</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>5 </span><span class=special>);</span>
<span class=special>}</span>    
    </pre>
</blockquote>

Notice that a trailing <code>.to_container(deq)</code> may be added to help many poor 
compilers to figure out the conversion (a few get it right). 
Notice also that pointer maps are 
not supported.

<p>
That is all; now you are ready to use this library.
 </p>

  <hr> 
  <h2><a name="design">Design</a></h2>
    <p>
  This section explains the way the library is implemented.
  A free-standing function (eg. <code>push_back()</code>
  or <code>operator+=()</code>) returns a proxy
  object which is responsible for the insertion or the assignment. The proxy 
object does the insertion or assignment by overloading <code>operator,()</code>
  and <code>operator()()</code> and by calling the "insert" function from within 
  those operators. The "insert" function is typically stored in the proxy object 
  by using <code>boost::<a href="../../function/index.html">function</a></code>. </p>
  
  <p>
  Often overloading
  of <code>operator,()</code> is discouraged because it can lead to surprising
  results, but the approach taken in this library is safe since the
  user never deals with objects that have overloaded <code>operator,()</code>
  directly. However, you should be aware of this:
  </p>
  
  <p><i>
  The 
  expressions in a comma-separated list no longer follow the rules of the 
  built-in comma-operator. This means that the order of evaluation of 
  expressions in a comma-separated list is undefined like when one specifies 
  a list of function arguments.
  </i></p>
  
    <p>
  Most of the code in this document use <code>int</code> in the examples, 
  but of course it works for arbitrary types as long as they are 
  Copy Constructible. The inserted data need not be constant data,
  but can be variables or data returned from functions; the only requirement 
  is that the type of the data is convertible to the type stored in the 
  container. 
  </p>
  
  <p>
  All forwarding is done by passing objects by <code>const</code> reference. 
Originally arguments were passed by value (and still is in 
<code>tuple_list_of()</code>). One thing to remember is that references
  can be passed by using <code>boost::<a href="http://www.boost.org/doc/html/ref.html">ref</a></code>.
  </p>
  
  <p>
   Everything is put in namespace 
  <code>boost::assign</code>. </p>

According to the above design considerations, the reference is organized into two parts:
<a href="#ref-functions">Functions and operators</a> and <a href="#ref-impl">Proxy objects</a>.

  <h2>Reference for functions and operators <a name="ref-functions"> </h3>

  <h3>Contents</h3>

      <ul>
          
        <li><a href="#ref-function-headers">Headers</a> </li>
        <li>Functions <a href="#ref-list_of"><code>list_of()</code></a>, <a href="#ref-list_of"><code>map_list_of()</code></a> and <a href="#ref-list_of"><code>ref_list_of&lt;int&gt;()</code></a></li>
        <li>Function <a href="#ref-make_list_inserter"><code>make_list_inserter()</code></a></li>
        <li>Functions <a href="#ref-ref_list_of"><code>ref_list_of()</code></a>, <a href="#ref-ref_list_of"><code>cref_list_of()</code></a>, and related functions</li>
        <li>Functions <a href="#ref-ref_csv"><code>ref_csv()</code></a>, <a href="#ref-ref_csv"><code>cref_csv()</code></a>, and related functions</li>
        <li>Operator <a href="#ref-std"><code>+=</code></a> for standard containers</li>
        <li>Functions <a href="#ref-repeat_ref"><code>repeat()</code></a>, <a href="#ref-repeat_ref"><code>repeat_fun()</code></a> and 
                                                                      <a href="#ref-repeat_ref"><code>range()</code>
                                                                      </a></li>
        <li><a href="#ref-limit">Customizing</a> argument list sizes </li>
     </ul>

  <h3>Headers <a name="ref-function-headers"></h3>      
  
  <p>
  Please notice <code>&lt;boost/assign/list_inserter.hpp></code> is included for each header that defines <code>operator+=()</code>.</p>

<table cellpadding=5 border=1 > <tr>
         <th>  Header                      </th>
         <th>        Includes              </th> 
     <tr>
         <td> &lt;boost/assign.hpp>               </td>
         <td>     everything except support for pointer containers  </td>
     <tr>
         <td> &lt;boost/assign/auto_size/ref_csv.hpp>               </td>
         <td>     <a href="#ref_csv"><code>ref_csv()</code> </a> and <a href="#ref_csv"><code>cref_csv()</code> </a>
     <tr>
         <td> &lt;boost/assign/auto_size/ref_rebind_csv.hpp>               </td>
         <td>     <a href="#ref_csv"><code>ref_rebind_csv()</code> </a> and <a href="#ref_csv"><code>cref_rebind_csv()</code> </a> 
     <tr>
         <td> &lt;boost/assign/auto_size/ref_list_of.hpp>               </td>
         <td>     <a href="#ref_list_of"><code>ref_list_of()</code> </a> and 
<a href="#ref_list_of"><code>cref_list_of()</code></a>  </td>
     <tr>
         <td> &lt;boost/assign/auto_size/ref_rebind_list_of.hpp>               </td>
         <td>     <a href="#ref_list_of"><code>ref_rebind_list_of()</code> </a> and 
<a href="#ref_list_of"><code>cref_rebind_list_of()</code></a>  </td>
     <tr>
         <td> &lt;boost/assign/list_of.hpp>       </td>
         <td> <a href="#list_of"><code>list_of()</a>, <a 
href="#map_list_of">map_list_of()</code></a>, 
         <a href="#tuple_list_of">tuple_list_of()</code></a>,
         <a href="#ref_list_of"><code>ref_list_of&lt;int&gt;()</code> </a> and
<a href="#ref_list_of"><code>ref_list_of&lt;int&gt;()</code></a> 

                  
         </td> <tr>
         <td> &lt;boost/assign/std.hpp>       </td>
         <td> <a href="#operator+="><code>operator+=()</code></a> for all 
standard
containers (see below)</td> <tr> <td>  &lt;boost/assign/std/deque.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::deque</code>, <code>&lt;deque></code> 
    <tr> 
        <td>  &lt;boost/assign/std/list.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::list</code>, <code>&lt;list></code>  
    <tr> 
        <td>  &lt;boost/assign/std/map.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::map</code> and <code>std::multimap</code> , 
<code>&lt;map></code> <tr> 
        <td>  &lt;boost/assign/std/queue.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::queue</code> and <code>std::priority_queue</code>, 
<code>&lt;queue></code> <tr> 
        <td>  &lt;boost/assign/std/set.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::set</code> and <code>std::multiset</code>, 
<code>&lt;set></code> <tr> 
        <td>  &lt;boost/assign/std/slist.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::slist</code> if the class is available , 
<code>&lt;slist></code> <tr> 
        <td>  &lt;boost/assign/std/stack.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::stack</code>, <code>&lt;stack></code>  
    <tr> 
        <td>  &lt;boost/assign/std/vector.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::vector</code>, <code>&lt;vector></code>  
    <tr> 
        <td>  &lt;boost/assign/assignment_exception.hpp> </td>
        <td>  Class <a 
href="#assignment_exception"><code>assignment_exception</code></a> which might 
be thrown by the proxy returned by <code>list_of()</code>
    <tr> 
        <td>  &lt;boost/assign/list_inserter.hpp> </td>
            <td>Functions <a
               href="#ref-make_list_inserter"><code>make_list_inserter()</code></a>, <code>push_back()</code>,
                <code>push_front()</code>,<code>insert()</code>,
                <code>
                push()</code> and class <a href="#list_inserter"><code>list_inserter</code></a> 
                which is the back-bone of this entire library.

            <tr>    
            <td>  &lt;boost/assign/ptr_list_inserter.hpp> </td>
            <td>Functions <a href="#ptr_push_back"><code>ptr_push_back()</code></a>,
                <code>ptr_push_front()</code> and <code>ptr_insert()</code>
                 
            <tr>    
            <td>  &lt;boost/assign/ptr_map_inserter.hpp> </td>
            <td>Functions <a href="#ptr_push_back"><code>ptr_map_insert()</code></a>
    
                            <tr>    
            <td>  &lt;boost/assign/ptr_list_of.hpp> </td>             
            <td>Function <a href="#ptr_list_of"><code>ptr_list_of()</code></a>

    </table>

   <h3><a name="ref-limit">Customizing argument list sizes </a></h3>   
      <p>
    This library uses the boost Preprocessor Library to implement overloaded 
    versions of <code>operator()()</code> and <code>list_of()</code>. By default you 
    can call these functions with five arguments, but you can also customize this 
    number by defining a macros before including a header from this library:
       <blockquote>
       <pre>
<span class=preprocessor>#define </span><span class=identifier>BOOST_ASSIGN_MAX_PARAMS </span><span class=number>10
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
</pre>
       </blockquote>      
       </p>


  <h3>Functions <code>list_of()</code>, 
      <code>map_list_of()</code> and <code>ref_list_of&lt;int&gt;()</code> <a name=ref-list_of> </h3>
    <p>  
  The first two functions are used to construct anonymous list which can be converted to any standard container
  and <code>boost::<a href="../../array/index.html">array</a>&lt;T,sz>.</code> Specifically, the 
  object returned by the two functions is <a href="#generic_list"><code>generic_list&lt;&gt;</code></a>.
  The third function can be used to construct an anonymous list of references. The corresponding collection builder is 
  <a href="#ref-static_generic_list"><code>static_generic_list&lt;&gt;</code></a>. Note that the 'auto-size'
  framework defines <a href="#ref-ref_list_of">overloads<a> for this function, that deduce the number of arguments at compile time.
  
  <h3><a name="ref-make_list_inserter">Function <code>make_list_inserter()</code></a></h3>
  <p>
  A simple "constructor" function for <code>list_inserter</code>. A typical 
  use of this function is to call it with the result of 
<code>boost::bind()</code>
  which in general returns some unreadable and weird class template.
  </p>
  <b>Synopsis</b>
  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost </span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{  
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>Function </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt;</span><span class=identifier>Function</span><span class=special>&gt;  </span><span class=identifier>make_list_inserter</span><span class=special>( </span><span class=identifier>Function </span><span class=identifier>fun </span><span class=special>)
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>list_inserter</span><span class=special>&lt;</span><span class=identifier>Function</span><span class=special>&gt;( </span><span class=identifier>fun </span><span class=special>);
    </span><span class=special>} </span>
<span class=special>}</span>
<span class=special>}  </span>  </pre></blockquote>


  <h3>Functions <code>ref_list_of()</code>, 
      <code>cref_list_of()</code> and related functions <a name=ref-ref_list_of> </h3>

  <b>Template parameters</b>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>P</tt></td><td>A policy tag</td></tr>
  	<tr><td><tt>T</tt></td><td>Element</td></tr>
  	</table>
  </blockquote>

  <b>Usage</b>
  <p>Let <code>d1</code> and <code>d2</code> denote objects of type <code>T</code> and <code>const T</code>, respectively.</p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result type</th>
  	<tr><td><tt>ref_list_of&lt;P&gt;(d1)</tt></td><td><a href="#ref-expr"> <tt>expr&lt;top_,T,1,ref_copy,P&gt;</tt></a></td></tr>
  	<tr><td><tt>cref_list_of&lt;P&gt;(d2)</tt></td><td><a href="#ref-expr"> <tt>expr&lt;top_,const T,1,ref_copy,P&gt;</tt></a></td></tr>
  	<tr><td><tt>ref_list_of(d1)</tt></td><td><a href="#ref-expr"> <tt>expr&lt;top_,T,1,ref_copy,default_policy&gt;</tt></a></td></tr>
  	<tr><td><tt>cref_list_of(d2)</tt></td><td><a href="#ref-expr"> <tt>expr&lt;top_,const T,1,ref_copy,default_policy&gt;</tt></a></td></tr>
  	</table>
  </blockquote>
<p>
Usage for the related functions <code>ref_rebind_list_of()</code> and <code>cref_rebind_list_of()</code> are identical to those
above, except the fourth argument to <a href="#ref-expr"> <tt>expr&lt;&gt;</tt></a> is a reference wrapper with rebind semantics, <code>ref_rebind</code>.
</p>

  <h3>Functions <code>ref_csv()</code>, 
      <code>cref_csv()</code> and related functions <a name=ref-ref_csv> </h3>

  <b>Template parameters</b>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>P</tt></td><td>A policy tag</td></tr>
  	<tr><td><tt>T</tt></td><td>Element</td></tr>
  	<tr><td><tt>U</tt></td><td><tt>T</tt> or <tt>const T</tt></td></tr>
  	<tr><td><tt>N</tt></td><td>Size</td></tr>
  	<tr><td><tt>R</tt></td><td>A Reference wrapper</td></tr>
  	</table>
  </blockquote>

  <b>Associated types</b>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Description</th> <th>Alias</th>
  	<tr><td><tt>csv_policy&lt;P&gt;::apply&lt;U,N,R&gt;::type</tt></td><td>A proxy object</td><td><tt>Impl&lt;P,U,N,R&gt;</tt></td></tr>
  	<tr><td><tt>csv_policy&lt;default_policy&gt;::apply&lt;U,N,R&gt;::type</tt></td><td><a href="#ref-static_array"> <tt>static_array&lt;T,N,R&gt;</tt></a></td><td><tt>Impl0&lt;U,N,R&gt;</tt></td></tr>
  	</table>
  </blockquote>

  <b>Usage</b>
  <p>Let <code>ai</code> and <code>bi</code> denote the <tt>i</tt>-th element of size-<tt>N</tt> sequences of objects of type <code>T</code> and <code>const T</code>, 
  respectively</p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result type</th>
  	<tr><td><tt>ref_csv&lt;P&gt;(a1,...,aN)</tt></td><td><tt>Impl&lt;P,T,N,ref_copy&gt;</tt></td></tr>
  	<tr><td><tt>cref_csv&lt;P&gt;(b1,...,bN)</tt></td><td><tt>Impl&lt;P,const T,N,ref_copy&gt;</tt></td></tr>
  	<tr><td><tt>ref_csv(a1,...,aN)</tt></td><td><tt>Impl0&lt;T,N,ref_copy&gt;</tt></td></tr>
  	<tr><td><tt>cref_csv(b1,...,bN)</tt></td><td><tt>Impl0&lt;const T,N,ref_copy&gt;</tt></td></tr>
  	</table>
  </blockquote>
<p>
Usage for the related functions <code>ref_rebind_list_of()</code> and <code>cref_rebind_list_of()</code> are identical to those
above, except <code>R=ref_rebind</code>.
</p>

<p>
The maximum number of arguments to a csv function is <code>BOOST_ASSIGN_CSV_SIZE</code>. 
</p>
  
  <h3><a name="ref-std">Operator <code>+=</code> for standard containers </a> </h3>
   <p> In the following three dots (...) will mean
       implementation defined.  
       <code>operator+=()</code> returns a proxy that forwards calls to either
       <code>push_back()</code>,<code>insert()</code>, or <code>push()</code>  
       depending on which operation the container supports. </p> <b>Synopsis</b>
  <p>
<blockquote>
<pre>
<span class=keyword>namespace </span><span class=identifier>boost</span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>deque</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>list</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>P </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>map</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>m</span><span class=special>, </span><span class=keyword>const </span><span class=identifier>P</span><span class=special>&amp; </span><span class=identifier>p </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>P </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>multimap</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>m</span><span class=special>, </span><span class=keyword>const </span><span class=identifier>P</span><span class=special>&amp; </span><span class=identifier>p </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>queue</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>priority_queue</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>K2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>set</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>K2 </span><span class=identifier>k </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>K2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>multiset</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>K2 </span><span class=identifier>k </span><span class=special>);
    
    </span><span class=preprocessor>#ifdef </span><span class=identifier>BOOST_HAS_SLIST
              
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>slist</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=preprocessor>#endif
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>stack</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);    </span>

<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span>  </pre></blockquote>
    Note that the extra template argument <code>V2</code> etc. is 
    necessary to allow for types convertible to <code>V</code>.   

  <h3>Functions <code>repeat()</code>, 
     <code>repeat_fun()</code> and <code>range()</code> <a name="ref-repeat_ref"> </h3>
  <p>
            These first two function exist both as free-standing functions and as member functions of the object returned by 
      <code>list_of()</code> and of <code>list_inserter</code>. 
      The free-standing versions are used to create a
      hook for <code>operator,()</code> so we can call the functions in the middle of a comma-list. The member functions
      are used when we need to call the functions in the middle of a parenthesis-list. In both cases we have that
      <ul>
          <li> the return type is always implementation defined for both functions, 
          <li> the argument list of <code>repeat()</code> is <code>(std::size_t,T)</code>, and  
          <li> the argument list of <code>repeat_fun()</code> is <code>(std::size_t,Nullary_function)</code>    
      </ul>
      
        </p>
  <p>
  The function <code>range()</code> only exists as a member function. The following two overloads are provided:
  <blockquote>
      <pre><span class=keyword>template</span><span class=special>&lt;</span> <span class=keyword>class</span> <span class=identifier>SinglePassIterator</span> <span class=special>&gt;</span>
<span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span> <span class=identifier>range</span><span class=special>(</span> <span class=identifier>SinglePassIterator</span> <span class=identifier>first</span><span class=special>,</span> <span class=identifier>SinglePassIterator</span> <span class=identifier>last</span> <span class=special>);</span>

<span class=keyword>template</span><span class=special>&lt;</span> <span class=keyword>class</span> <span class=identifier>SinglePassRange</span> <span class=special>&gt;</span>
<span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span> <span class=identifier>range</span><span class=special>(</span> <span class=keyword>const</span> <span class=identifier>SinglePassRange</span><span class=special>&amp;</span> <span class=identifier>rng</span> <span class=special>);</span></pre>
  </blockquote>
  </p>

  <h2>Reference for the implementation <a name="ref-impl"> </h2>
  Proxy objects are those that are returned by <a name="ref-functions">functions<a>, which are
  'invisible' to the caller, and take care of the implementation.
  <h3>Contents</h3>

      <ul>
        <li> Proxy object <a href="#ref-converter"><code>converter&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-generic_list"><code>generic_list&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-list_inserter"><code>list_inserter&lt;&gt;</code></a></li>
        <li> Proxy object <a href="#ref-static_generic_list"><code>static_generic_list&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-array_interface"><code>array_interface&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-expr"><code>expr&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-lazy_array"><code>lazy_array&lt;&gt;</code></a> </li>
        <li> Proxy object <a href="#ref-static_array"><code>static_array&lt;&gt;</code></a> </li>
     </ul>

  <h3>Proxy object <code>converter<></code><a name=ref-converter> </h3>
  <b>Header</b> <code>&lt;boost/assign/list_of.hpp></code>

    <p>
  <b>Template parameters</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>D</tt></td><td> A derived class </td> </tr>
  	<tr><td><tt>I</tt></td><td> An iterator </td> </tr>
  	</table>
  </blockquote>

<p>
  In the tables below, let <code>d</code> and object of type <code>const D</code>. 
</p>
  <b>Requirements on the derived type</b>
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Return</th>
  	<tr><td><tt><span class="pre">d.begin()</span></tt></td> <td>An iterator of type <tt><span class=identifier>I</span></tt></td></tr>
  	<tr><td><tt><span class="pre">d.end()</span></tt></td><td>An iterator of type <tt><span class=identifier>I</span></tt></td> </tr>
  	</table>
  </blockquote>

  <b>Requirements on the conversion operands</b>
</p>
  There are three concepts that allow for conversion which we call container, adapters, and arrays. Let <code>C</code>,
  <code>A</code> and <code>R</code> denote models of the respective concepts,
  and <code>c</code>, <code>a</code> and <code>r</code>, instances thereof. Let <code>b</code> and <code>e</code> denote the begin and end iterators of <code>d</code>,
  and <tt>n</tt> their distance. Assume that the elements of each of these data-structures
  are of type <code>X</code>, of which <code>x</code> is and instance, and <code>k</code> <i>any</i> index in the range <tt>&#91;<span class=number>0</span>,n)</tt>.
  
  Each of <code>c</code>, <code>a</code> and <code>r</code> must be copy constructible. In addition, 
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Effect</th>
  	<tr><td><tt><span class="pre">C c(b,e);</span></tt></td> <td>Constructs an object of type <tt><span class=identifier>C</span></tt></td></tr>
  	<tr><td><tt><span class="pre">a.push(x)</span></tt></td><td>Adds element <tt><span class=identifier>x</span></tt> to <tt><span class=identifier>a</span></tt></td> </tr>
  	<tr><td><tt><span class="pre">r[k]=x</span></tt></td><td>Assigns value <tt><span class=identifier>x</span></tt> to the kth element of <tt><span class=identifier>r</span></tt> </tt></td> </tr>
  	</table>
  </blockquote>
</p>

  <b>Synopsis</b>
  <blockquote>  

   <pre>
<span class=keyword>namespace </span><span class=identifier>boost</span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> <span class=identifier>D</span>, <span class=keyword>class</span> <span class=identifier>I</span> &gt;
    <span class=keyword>class</span> converter
    {
    <span class=keyword>public:</span> 
        <span class=keyword>typedef</span> <span class=identifier>I</span> iterator;
        <span class=keyword>typedef</span> <span class=identifier>I</span> const_iterator;
        
        iterator begin() <span class=keyword>const</span>;

        iterator end() <span class=keyword>const</span>;
        
        <span class=keyword>template</span>&lt; <span class=keyword>class</span> Container >
        Container convert_to_container();
        
        <span class=keyword>template</span>&lt; <span class=keyword>class</span> Container >
        Container to_container( Container& c );

        adapter_converter to_adapter() <span class=keyword>const</span>

        <span class=keyword>template</span>&lt; <span class=keyword>class</span> Adapter >
        Adapter to_adapter( Adapter& a ) <span class=keyword>const</span>

        <span class=keyword>template</span>&lt; <span class=keyword>class</span> Array >
        Array to_array( Array& a ) <span class=keyword>const</span>;
    };

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span>==( <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; l, <span class=keyword>const</span> Range& r );

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span>==( <span class=keyword>const</span> Range& l, <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; r );

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span>!=( <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; l, <span class=keyword>const</span> Range& r );
    
    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span>!=( <span class=keyword>const</span> Range& l, <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; r );

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span><( <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; l, <span class=keyword>const</span> Range& r );

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span><( <span class=keyword>const</span> Range& l, <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; r );

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span>>( <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; l, <span class=keyword>const</span> Range& r );

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span>>( <span class=keyword>const</span> Range& l, <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; r );

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span><=( <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; l, <span class=keyword>const</span> Range& r );

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span><=( <span class=keyword>const</span> Range& l, <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; r );
    
    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span>>=( <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; l, <span class=keyword>const</span> Range& r );

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Range >
    bool <span class=keyword>operator</span>>=( <span class=keyword>const</span> Range& l, <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; r );

    <span class=keyword>template</span>&lt; <span class=keyword>class</span> D, <span class=keyword>class</span> <span class=identifier>I</span>, <span class=keyword>class</span> Elem, <span class=keyword>class</span> Draits >
    std::basic_ostream<Elem,Traits>& 
    <span class=keyword>operator</span><<( std::basic_ostream<Elem, Traits>& Os,
                <span class=keyword>const</span> <span class=identifier>converter<span>&lt;<span class=identifier>D<span>,<span class=identifier>I</span>&gt;&amp; r );
<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span></pre></blockquote>

  <h3>Proxy object <code>generic_list&lt;&gt;</code><a name=ref-generic_list> </h3>
  <p>
  <b>Header</b> <code>&lt;boost/assign/list_of.hpp></code>
  </p>

  <b>Template parameters</b>
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt><span class="pre">T</span></tt></td> <td>Element</td></tr>
  	</table>
  </blockquote>

  <b>Associated types</b>
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Description</th>
  	<tr><td><a href="#ref-converter"><tt>converter&lt&gt</tt><a></td> <td>Public base class</td></tr>
  	</table>
  </blockquote>

  <b>Synopsis</b>
  <blockquote>  
  <pre><span class=keyword>namespace </span><span class=identifier>boost  </span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=keyword>class </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>
    </span><span class=special>{
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=identifier>const_iterator  </span><span class=identifier>begin</span><span class=special>() <span class=keyword>const</span>;
        </span><span class=identifier>const_iterator  </span><span class=identifier>end</span><span class=special>() <span class=keyword>const</span>;
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>&amp; </span><span class=keyword>operator</span><span class=special>,( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=comment>// inserts default-constructed object
        </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>&amp; </span><span class=keyword>operator</span><span class=special>()();  

        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>&amp; </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2 </span><span class=special>&gt;
        </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>&amp; </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2 </span><span class=special>);

        </span><span class=comment>//
        // and similarly up to 5 arguments
        //
                
    <span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>(</span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>T </span><span class=identifier>t </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2 </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U3 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2</span><span class=special>, </span><span class=identifier>U3 </span><span class=identifier>u3 </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U3</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U4 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2</span><span class=special>, </span><span class=identifier>U3 </span><span class=identifier>u3</span><span class=special>, </span><span class=identifier>U4 </span><span class=identifier>u4 </span><span class=special>);
  
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U3</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U4</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U5 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2</span><span class=special>, </span><span class=identifier>U3 </span><span class=identifier>u3</span><span class=special>, </span><span class=identifier>U4 </span><span class=identifier>u4</span><span class=special>, </span><span class=identifier>U5 </span><span class=identifier>u5 </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>Key</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>map_list_of</span><span class=special>( </span><span class=identifier>Key </span><span class=identifier>k</span><span class=special>, </span><span class=identifier>T </span><span class=identifier>t </span><span class=special>)
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>list_of</span><span class=special>&lt; </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>pair</span><span class=special>&lt;</span><span class=identifier>Key</span><span class=special>,</span><span class=identifier>T</span><span class=special>&gt; </span><span class=special>&gt;()( </span><span class=identifier>k</span><span class=special>, </span><span class=identifier>t </span><span class=special>);
    </span><span class=special>}</span>
<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span>  </pre></blockquote>

  <h3>Proxy object <code>static_generic_list<></code><a name=ref-static_generic_list> </h3>
  <b>Header</b> <code>&lt;boost/assign/list_of.hpp></code>

    <p>
  <b>Template parameters</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>T</tt></td><td> Element </td> </tr>
  	<tr><td><tt>N</tt></td><td> Size </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Associated types</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Description</th>
  	<tr><td><a href="#ref-converter"><tt>converter&lt&gt</tt><a></td><td> Public base class </td> </tr>
  	</table>
  </blockquote>

  <h3><a name="ref-list_inserter">Proxy object <code>list_inserter&lt;&gt;</code></a></h3> 
<p>
  
  This class is responsible for inserting elements into containers and 
  it is the key to extending the library to support your favourite class.
</p>
<p>
  <b>Header</b> <code>&lt;boost/assign/list_inserter.hpp></code>
</p>

    <p>
  <b>Template parameters</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>Function</tt></td><td> A functor to which insertion is delegated to </td> </tr>
  	<tr><td><tt>Argument</tt></td><td> Argument to be inserted </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Synopsis</b> 
  </p>
  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost</span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=identifier>Function</span><span class=special>, </span><span class=identifier>Argument </span><span class=special>= </span><span class=keyword>void </span><span class=special>&gt; 
    </span><span class=keyword>class </span><span class=identifier>list_inserter
    </span><span class=special>{
        </span><span class=identifier>Function </span><span class=identifier>fun</span><span class=special>;
        
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=keyword>explicit </span><span class=identifier>list_inserter</span><span class=special>( </span><span class=identifier>Function </span><span class=identifier>fun </span><span class=special>);
        
        </span><span class=comment>// conversion constructor
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>Function2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>Arg </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>( </span><span class=keyword>const </span><span class=identifier>list_inserter</span><span class=special>&lt;</span><span class=identifier>Function2</span><span class=special>,</span><span class=identifier>Arg</span><span class=special>&gt;&amp; </span><span class=special>);
        
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>,( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>=( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=comment>// calls 'fun()' with default-constructed object
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>()();
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2 </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2 </span><span class=special>)
        </span><span class=special>{
           </span><span class=comment>//
           // if 'Argument' is 'void'
           //     fun( u, u2 );
           // else
           //     fun( Argument( u, u2 ) );
           //
           </span><span class=keyword>return </span><span class=special>*</span><span class=keyword>this</span><span class=special>;
        </span><span class=special>}

        </span><span class=comment>//
        // similarly up to 5 arguments
        //
    </span><span class=special>};</span>
    
    <span class=keyword>template</span><span class=special>&lt; </span><span 
class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);
      
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>push_front</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>push</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);</span>
      
<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span></pre></blockquote>
  <p>
  Notice how the arguments to <code>operator,()</code> and 
  <code>operator()()</code> are passed differently to 
  <code>fun</code> depending of the type of <code>Argument</code>. 
  So if we only pass one template argument to <code>list_inserter,</code>
  we can forward "arbitrary" argument lists of functions. If we pass
  two template arguments to <code>list_inserter</code> we can 
  construct types with "arbitrary" constructors.
  </p> 
   
  <p> 
   And because
  a reference to <code>list_inserter</code> is returned, we can
  chain argument list together in a very space-efficient manner.
  </p>

  <h4><a name="ref-array_interface">Proxy object <code>array_interface&lt;&gt;</code></a></h4> 
  <p>Exposes most of the <code>boost::array&lt;&gt;</code> interface.</p>
  <b>Header</b> <code>&lt;boost/assign/auto_size/array/interface.hpp></code>

    <p>
  <b>Template parameters</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>T</tt></td><td> Element </td> </tr>
  	<tr><td><tt>N</tt></td><td> Size </td> </tr>
  	<tr><td><tt>R</tt></td><td> Reference wrapper around an element </td> </tr>
  	<tr><td><tt>D</tt></td><td> Derived </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Requirements</b> 
  </p>
   Let <tt>d1</tt> and <tt>d2</tt> instances of <tt>D</tt> and <tt>const D</tt>, respectively,
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Result</th>
  	<tr><td><tt>d1.ref_array_impl()</tt></td><td> array_interface::ref_array_& </td> </tr>
  	<tr><td><tt>d2.ref_array_impl()</tt></td><td> const array_interface::ref_array_& </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Associated types</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Description</th>
  	<tr><td><a href="#ref-converter"><tt>converter&lt&gt</tt><a></td><td> Public base class </td> </tr>
  	</table>
  </blockquote>


  <h3><a name="ref-expr">Proxy object <code>expr&lt;&gt;</code></a></h3> 
    <p>
  <b>Header</b> <code>&lt;boost/assign/auto_size/detail/expr.hpp></code>
  </p>

    <p>
  <b>Template parameters</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>E</tt></td><td> Previous collection </td> </tr>
  	<tr><td><tt>T</tt></td><td> Element </td> </tr>
  	<tr><td><tt>N</tt></td><td> Size </td> </tr>
  	<tr><td><tt>R</tt></td><td> Reference wrapper around an element </td> </tr>
  	<tr><td><tt>P</tt></td><td> Policy tag</td> </tr>
  	<tr><td><tt>F</tt></td><td> Use reference to link to the previous collection </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Associated types</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Description</th>
  	<tr><td><tt><code>policy&lt;P&gt;::apply&lt;expr,R&gt;::type</code></tt></td><td> Public base class </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Synopsis</b> 
  </p>
  
  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost</span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
<span class=keyword>namespace </span><span class=identifier>detail</span>
<span class=special>{
<span class=keyword>namespace </span><span class=identifier>auto_size</span>
<span class=special>{
    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> T,<span class="keyword">int</span> N,
        <span class="keyword">template&lt</span><span class="keyword">typename</span>> <span class="keyword">class</span> R,<span class="keyword">typename</span> P,<span class="keyword">bool</span> F = <span class="keyword">true</span>>
    class expr{
        <span class="keyword">public:</span>       

        <span class="keyword">typedef</span> Implementation defined result_type;
        <span class="keyword">explicit</span> expr(<span class="keyword">const</span> E& p,T& t);
        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> E1,<span class="keyword">typename</span> P1,<span class="keyword">bool</span> F1>
        <span class="keyword">explicit</span> expr(<span class="keyword">const</span> expr<E1,T,N,R,P1,F1>& that);

        result_type <span class="keyword">operator</span>()(T& t)<span class="keyword">const</span>;
        
        <span class="keyword">template</span>&lt;<span class="keyword">int</span> K,<span class="keyword">typename</span> I>
        Implementation defined
        range(I b,I e)<span class="keyword">const</span>;

        <span class="keyword">template</span>&lt;<span class="keyword">int</span> K,<span class="keyword">typename</span> Range>
        Implementation defined
        range(Range& r)<span class="keyword">const</span>;

        <span class="keyword">template</span>&lt;<span class="keyword">int</span> K,<span class="keyword">typename</span> Range>
        Implementation defined
        range(<span class="keyword">const</span> Range& r)<span class="keyword">const</span>;

        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range>
        Implementation defined
        range(Range& r);

        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range>
        Implementation defined
        range(<span class="keyword">const</span> Range& r);

    };  

    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> E,<span class="keyword">typename</span> T,<span class="keyword">int</span> N,
    	<span class="keyword">template</span>&lt;<span class="keyword">typename</span>> <span class="keyword">class</span> R,<span class="keyword">typename</span> P,<span class="keyword">bool</span> F>
    <span class="keyword">void</span> write_to_array(A& a,<span class="keyword">const</span> expr<E,T,N,R,P,F>& e);


<span class=special>} </span><span class=comment>// namespace 'auto_size'</span>
<span class=special>} </span><span class=comment>// namespace 'detail'</span>
<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span></pre></blockquote>

    <p>
  <b>Design</b> 
  </p>
<p>
   A call to the unary operator returns an object that keeps a reference to the passed argument,
   and links to the current object, thereby forming a collection, whose final size is determined
   at compile time. The function <code>write_to_array()</code> passes the elements of the collection 
   to any array. 
</p>   
<p>   
   Naturally, this requires that the arguments be allocated on the stack. Consequently, this set up is 
   ill-suited for the method <code>range()</code> whose size, unlike those of the proxy objects that 
   predate this one throughout this library, must be specified explictly. A fully 'auto-size' framework 
   could be achieved, in the future, by having <code>auto_size::expr&lt;&gt;</code> expose a member function 
   <code>concat()</code>, that returns a proxy object whose task is to aggregate collections, similarly to
   <code>join_view()</code> in <a href="http://www.boost.org/doc/libs/1_42_0/libs/fusion/doc/html/fusion/view/joint_view.html">Boost.Fusion</a> 
   or <code>chain()</code> in <a href="http://boost-sandbox.sourceforge.net/libs/range_ex/doc/html/index.html">Boost.RangeEx</a>.

</p>
  <h3><a name="ref-lazy_array">Proxy object <code>lazy_array&lt;&gt;</code></a></h3> 
  <b>Header</b> <code>&lt;boost/assign/auto_size/array/lazy.hpp></code>

    <p>
  <b>Template parameters</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>T</tt></td><td> Element </td> </tr>
  	<tr><td><tt>N</tt></td><td> Size </td> </tr>
  	<tr><td><tt>R</tt></td><td> Reference wrapper around an element </td> </tr>
  	<tr><td><tt>D</tt></td><td> Derived </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Associated types</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Description</th>
  	<tr><td><a href="#ref-array_interface"><tt>array_interface&lt&gt</tt><a></td><td> Public base class </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Requirements</b> 
  </p>
  Let <tt>d</tt> denote an instance of <tt>D</tt> and <tt>a</tt> an instance of <code>boost::array&lt;T,N&gt;</code>,
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Effect</th>
  	<tr><td><tt>write_to_array(a,d)</tt></td><td> Assigns <tt>a</tt>'s elements </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Properties</b> 
  </p>
  <p>
   Postpones allocation of its data-members (from the derived class) until the interface is used.
 </p>


  <h4><a name="ref-static_array">Proxy object <code>static_array&lt;&gt;</code></a></h4> 
  <b>Header</b> <code>&lt;boost/assign/auto_size/array/static.hpp></code>
    <p>
  <b>Template parameters</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Parameter</th> <th class="head">Description</th>
  	<tr><td><tt>T</tt></td><td> Element </td> </tr>
  	<tr><td><tt>N</tt></td><td> Size </td> </tr>
  	<tr><td><tt>R</tt></td><td> Reference wrapper around an element </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Associated types</b> 
  </p>

  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Description</th>
  	<tr><td><a href="#ref-array_interface"><tt>array_interface&lt&gt</tt><a></td><td> Public base class </td> </tr>
  	</table>
  </blockquote>

    <p>
  <b>Requirements</b> 
  </p>
  Let <tt>e</tt> denote the argument passed to the constructor, and a an instance of <code>boost::array&lt;T,N&gt;</code>,
  <blockquote>
  	<table cellpadding=5 border=1>
  	<tr><th class="head">Expression</th> <th class="head">Effect</th>
  	<tr><td><tt>write_to_array(a,e)</tt></td><td> Assigns <tt>a</tt>'s elements </td> </tr>
  	</table>
  </blockquote>


  <h2><a name="exceptions">Exceptions and exception-safety</a></h2>
  <p>
  The exception guarantees by the library is the same as guarantee as the 
  guarantee of the function that is forwarded to. For standard 
  containers this means that the
  strong guarantee is given for a single insertions and that the basic guarantee 
  is given for many insertions (provided that the object being copied 
  gives the basic guarantee). 
  </p>
  <p>
  The functions may throw standard exceptions
  like <code>std::bad_alloc</code>. Note however that, unfortunately, the standard does not guarantee allocation-failures
  in standard containers to be reported by <code>std::bad_alloc</code> or exceptions derived from <code>std::exception</code>.
 </p>
  
  <h3><a name="assignment_exception">Class 
  <code>assignment_exception</code></a></h3>
  <p>
   The exception is thrown by the conversion operator in the proxy object
   returned from <code>list_of()</code>.
  </p>

  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost </span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>class </span><span class=identifier>assignment_exception </span><span class=special>: </span><span class=keyword>public </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>exception
    </span><span class=special>{
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=keyword>explicit </span><span class=identifier>assignment_exception</span><span class=special>( </span><span class=keyword>const </span><span class=keyword>char</span><span class=special>* </span><span class=identifier>what </span><span class=special>); 
        </span><span class=keyword>virtual </span><span class=keyword>const </span><span class=keyword>char</span><span class=special>* </span><span class=identifier>what</span><span class=special>() </span><span class=keyword>const </span><span class=keyword>throw</span><span class=special>();
    </span><span class=special>};</span>
<span class=special>}   </span>
<span class=special>}</span>  </pre></blockquote> 

  <hr>
  <h2><a name="extensions">Extending the library</a></h2> 
  <p>
  It is very simple to make the library work with new classes. 
  This code shows how to use <code>operator+=()</code> with 
  a container:
  <blockquote><pre>
<span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
</span><span class=keyword>inline </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=identifier>assign_detail</span><span class=special>::</span><span class=identifier>call_push_back</span><span class=special>&lt; </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt; </span><span class=special>&gt;, </span><span class=identifier>V </span><span class=special>&gt; 
</span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>)
</span><span class=special>{
    </span><span class=keyword>return </span><span class=identifier>make_list_inserter</span><span class=special>( </span><span class=identifier>assign_detail</span><span class=special>::</span><span class=identifier>call_push_back</span><span class=special>&lt; </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt; </span><span class=special>&gt;( </span><span class=identifier>c </span><span class=special>) </span><span class=special>)( </span><span class=identifier>v </span><span class=special>);
</span><span class=special>}
</span></pre>
</blockquote>      


where <code>call_push_back</code> is defined as    
      
<blockquote>      
<pre>
<span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
</span><span class=keyword>class </span><span class=identifier>call_push_back
</span><span class=special>{
    </span><span class=identifier>C</span><span class=special>&amp; </span><span class=identifier>c_</span><span class=special>;
</span><span class=keyword>public</span><span class=special>:

    </span><span class=identifier>call_push_back</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=identifier>c </span><span class=special>) </span><span class=special>: </span><span class=identifier>c_</span><span class=special>( </span><span class=identifier>c </span><span class=special>)
    </span><span class=special>{ </span><span class=special>}
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=keyword>void </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>T </span><span class=identifier>r </span><span class=special>) 
    </span><span class=special>{
        </span><span class=identifier>c_</span><span class=special>.</span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>r </span><span class=special>);
    </span><span class=special>}
</span><span class=special>};</span></pre>    
</blockquote>
      
      Note that we pass
  a second template argument to <code>list_inserter</code> so argument 
  lists will be used to construct a <code>V</code> object. Otherwise we
  could end up trying to call <code>push_back()</code> with <i>n</i> arguments 
  instead of one.
  </p>
      
  <p>    
  An alternative way would be to use <code>boost::function</code> and 
  <code>boost::bind()</code> in combination. However, in this case one must
  remember that it is illegal to take the address of a function in
  the standard library.
  </p>
      
  <p>
  Calling a function with more that one argument can be
  very useful too. This small example shows how we take advantage of this 
  functionality:
  </p>
  <blockquote><pre>
<span class=comment>//  
// A class representing emails
//</span>
<span class=keyword>class </span><span class=identifier>email</span>
<span class=special>{</span>
<span class=keyword>public</span><span class=special>:
    </span><span class=keyword>enum </span><span class=identifier>address_option
    </span><span class=special>{
        </span><span class=identifier>check_addr_book</span><span class=special>,
        </span><span class=identifier>dont_check_addr_book
    </span><span class=special>};
    </span>
<span class=keyword>private</span><span class=special>:

    </span><span class=keyword>typedef </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>map</span><span class=special>&lt; </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>,</span><span class=identifier>address_option </span><span class=special>&gt;  </span><span class=identifier>address_map</span><span class=special>;
    
    </span><span class=comment>//
    // Store list of persons that must be cc'ed
    //
    </span><span class=keyword>mutable </span><span class=identifier>address_map </span><span class=identifier>cc_list</span><span class=special>;
        
    </span><span class=comment>//
    // This extra function-object will take care of the 
    // insertion for us. It stores a reference to a 
    // map and 'operator()()' does the work. 
    //
    </span><span class=keyword>struct </span><span class=identifier>add_to_map
    </span><span class=special>{
        </span><span class=identifier>address_map</span><span class=special>&amp; </span><span class=identifier>m</span><span class=special>;
    
        </span><span class=identifier>add_to_map</span><span class=special>( </span><span class=identifier>address_map</span><span class=special>&amp; </span><span class=identifier>m </span><span class=special>) </span><span class=special>: </span><span class=identifier>m</span><span class=special>(</span><span class=identifier>m</span><span class=special>)        
        </span><span class=special>{}
    
        </span><span class=keyword>void </span><span class=keyword>operator</span><span class=special>()( </span><span class=keyword>const </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>&amp; </span><span class=identifier>name</span><span class=special>, </span><span class=identifier>address_option </span><span class=identifier>ao </span><span class=special>)
        </span><span class=special>{
            </span><span class=identifier>m</span><span class=special>[ </span><span class=identifier>name </span><span class=special>] </span><span class=special>= </span><span class=identifier>ao</span><span class=special>; 
        </span><span class=special>}
    </span><span class=special>};
</span>
<span class=keyword>public</span><span class=special>:
    
    </span><span class=comment>//
    // This function constructs the appropriate 'list_inserter'.
    // Again we could have use 'boost::function', but it is
    // trivial to use a function object.
    //
    // Notice that we do not specify an extra template
    // parameter to 'list_inserter'; this means we forward
    // all parameters directly to the function without 
    // calling any constructor.
    //
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=identifier>add_to_map </span><span class=special>&gt;
    </span><span class=identifier>add_cc</span><span class=special>( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string </span><span class=identifier>name</span><span class=special>, </span><span class=identifier>address_option </span><span class=identifier>ao </span><span class=special>)
    </span><span class=special>{
        </span><span class=comment>//
        // Notice how we pass the arguments 'name' and 'ao' to
        // the 'list_inserter'.
        //
        </span><span class=keyword>return </span><span class=identifier>make_list_inserter</span><span class=special>( </span><span class=identifier>add_to_map</span><span class=special>( </span><span class=identifier>cc_list </span><span class=special>) </span><span class=special>)( </span><span class=identifier>name</span><span class=special>, </span><span class=identifier>ao </span><span class=special>);
    </span><span class=special>}</span>
<span class=special>};
</span>
<span class=comment>//
// Now we can use the class like this:
//</span>
<span class=identifier>email </span><span class=identifier>e</span><span class=special>;</span>
<span class=identifier>e</span><span class=special>.</span><span class=identifier>add_cc</span><span class=special>( </span><span class=string>&quot;Mr. Foo&quot;</span><span class=special>, </span><span class=identifier>email</span><span class=special>::</span><span class=identifier>dont_check_addr_book </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;Mr. Bar&quot;</span><span class=special>, </span><span class=identifier>email</span><span class=special>::</span><span class=identifier>check_addr_book </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;Mrs. FooBar&quot;</span><span class=special>, </span><span class=identifier>email</span><span class=special>::</span><span class=identifier>check_addr_book </span><span class=special>);  </span>
</pre></blockquote>
      
   
  The full example can be seen in <a href="email_example.html">email_example.cpp</a> </p>
  <hr>
  <h2>Examples <a name="examples"></h2>
  <p>
  Additional examples can be found in the test files:
  <ul>
      <li> <a href="email_example.html">email_example.cpp</a>          
      <li> <a href="my_vector_example.html">my_vector_example.cpp</a>               
      <li> <a href="multi_index_container.html">multi_index_container.cpp</a> 
      <li> <a href="../test/array.cpp">array.cpp</a>      
      <li> <a href="../test/list_of.cpp">list_of.cpp</a>      
      <li> <a href="../test/std.cpp">std.cpp</a>      
      <li> <a href="../test/list_inserter.cpp">list_inserter.cpp</a>      
      <li> <a href="../test/list_of_workaround.cpp">list_of_work_around.cpp</a>      
</ul> </p>
  
  
  <hr>
  <h2><a name="boost_libs">Supported libraries</a></h2> 
  Here is a list libraries has been tested with Boost.Assign:
  
  <ol>
      <li> <code>boost::<a href="../../array/index.html">array</a></code>
      <li> <code>boost::<a href="../../multi_index/index.html">multi_index_container</a></code>
      <li> <code>Boost.<a href="../../ptr_container/index.html">Pointer Container</code> </ol> <p>

  </p>
  
  
  <hr>
  <h2><a name="portability">Portability</a></h2>
  <p>
    Library has been successfully compiled and tested with
    MVC++ 7.1, GCC 3.2 (under Cygwin) Comeau 4.3.3
  </p>
  <p>
    There are known limitation on platforms not supporting templated 
    conversion operators. The solution is to call certain member functions on 
    the object returned by <code>list_of()</code>: </p>
 <blockquote>
     <pre>
<span class=special>{
    </span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
    </span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>;
    </span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
    
    </span><span class=keyword></span><span 
class=identifier>vector</span><span
class=special>&lt;</span><span class=keyword>int</span><span 
class=special>&gt;</span>         <span class=identifier>v </span><span 
class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_container</span><span class=special>( </span><span class=identifier>v </span><span class=special>);
    </span><span class=identifier>set</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;            </span><span class=identifier>s </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_container</span><span class=special>( </span><span class=identifier>s </span><span class=special>);  
    </span><span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt;        </span><span class=identifier>m </span><span class=special>= </span><span class=identifier>map_list_of</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>).</span><span class=identifier>to_container</span><span class=special>( </span><span class=identifier>m </span><span class=special>);
    </span><span class=identifier>stack</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;         </span><span class=identifier>st </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_adapter</span><span class=special>( </span><span class=identifier>st </span><span class=special>);
    </span><span class=identifier>queue</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;          </span><span class=identifier>q </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_adapter</span><span class=special>( </span><span class=identifier>q </span><span class=special>); 
    </span><span class=identifier>array</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=number>4</span><span class=special>&gt;        </span><span class=identifier>a </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_array</span><span class=special>( </span><span class=identifier>a </span><span class=special>);</span>
<span class=special>}</span>     </pre>
 </blockquote>
 <p>
 Notice how one must supply the functions with an argument so the right
 return type can be deduced.
 </p>
 <p>Some standard libraries are also broken. One problem is that 
<code>insert()</code> might not work:
<blockquote>
    <pre>
<span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>next</span><span class=special>; 
</span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>next </span><span class=special>)(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>); </span><span class=comment>// compile-time error</span> </pre>
</blockquote>
The solution is to use <code>map_list_of()</code> instead:
<blockquote>
    <pre>
<span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>next </span><span class=special>= </span><span class=identifier>map_list_of</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>);</span></pre></blockquote>
</p>
 <hr>
  <h2><a name="history">History and Acknowledgment</a></h2>
  <p>
  The idea for an assignment/initialization library is not new. The 
  functionality of this
  library resembles Leor Zolman's STL Container Initialization Library a great 
  deal, but it does not rely on string parsing to achieve its goals. 
  </p> 
  <p>
  The  
  library is non-intrusive and puts only a minimum of requirements 
  on its supported classes.
 Overloading operator comma is sometimes viewed as a bad practice <a 
href="#meyers">[1]</A>. However, it has been done
  with success in eg. the Generative Matrix Computation Library  and Blitz to initialize matrices 
      (see <a href="#gmcl">[2]</A>) and <a href="#blitz">[3]</A>). The 
Initialization Library overloads
      the comma operator in a safe manner by letting free standing functions
 return an object that is responsible for the initialization. Therefore it takes 
explicit
      action from the programmer to begin using the overloaded <code>operator,()</CODE>.
  </p>
  <p>
  There has recently been some discussion about enhancing the language to 
support better initialization (see <a href="#initializer">[4]</a>).
  </p>
  
  <p> The auto-size framework for building a collection of references whose size is deduced from the input was added in March 2010.</p>
  <p>
  Special thanks goes to 
  <ul>
  <li> Leor Zolman for our many discussion that eventually led to this library.
  <li> Tom Brinkman for being review manager.
  <li> Joaquín Muñoz for vc6/vc7 portability.
  <li> Pavel Vozenilek for his countless suggestions, improvements and 
       portability fixes. 
  <li> Rene Rivera for Code Warrior portability.     
  <li> Manuel Peinado Gallego for valuable discussions that led to the auto-size framework. 
  In particular, he identified the need to distinguish between copy and rebind semantics.
       
       </ul>
  </p>
  <hr>
  <h2><a name="ref">References</a></h2>
  <p>
  <ol>
      <li> <a name="meyers">     Scott. Meyers, "More Effective C++", Item 7, Addison Wesley, 1996       
      <li> <a name="gmcl">       K. Czarnecki and U.W. Eisenecker, "Generative programming", Addison-Wesley, 2000        
      <li> <a name="blitz">      <a href="http://www.oonumerics.org/blitz/"> http://www.oonumerics.org/blitz/ </A>     
      <li> <a name="initializer"> 
          Gabriel Dos Reis and Bjarne Stroustrup, 
          <a href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1509.pdf"> "Generalized Initializer
            Lists"</a>, 2003  </a>
 </OL> 
 </p>
  <hr>
  <p>
    (C) Copyright Thorsten Ottosen 2003-2006
  </p>

  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
</body>
</html>
