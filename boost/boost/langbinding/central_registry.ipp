// Copyright (c) 2003 Daniel Wallin

// Permission is hereby granted, free of charge, to any person or organization 
// obtaining a copy of the software covered by this license (the "Software") 
// to use, reproduce, display, distribute, execute, and transmit the Software, 
// and to prepare derivative works of the Software, and to permit others
// to do so, all subject to the following:

// The copyright notice in the Software and this entire statement, including 
// the above license grant, this restriction and the following disclaimer, 
// must be included in all copies of the Software, in whole or in part, and 
// all derivative works of the Software, unless such copies or derivative 
// works are solely in the form of machine-executable object code generated by 
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.

#ifndef BOOST_LANGBINDING_CENTRAL_REGISTRY_IMPLEMENTATION
#define BOOST_LANGBINDING_CENTRAL_REGISTRY_IMPLEMENTATION

#include <vector>
#include <map>
#include <string>
#include <utility>
#include <iostream>
#include <set>

#include <boost/shared_ptr.hpp>

#include <boost/langbinding/central_registry.hpp>
#include <boost/langbinding/registry.ipp>

#include <boost/mpl/aux_/config/msvc_typename.hpp>

namespace
{
   using namespace boost::langbinding;

   template<class T>
   struct implementation
   {
      typedef typename central_registry<T>::registry_ptr registry_ptr;

      struct entry
      {
         registry_ptr registry_;
      };

      typedef boost::shared_ptr<entry> entry_ptr;

      struct cmp_entry
      {
         bool operator()(
               const entry_ptr& lhs
             , const entry_ptr& rhs) const
         {
            return lhs->registry_ < rhs->registry_;
         }
      };

      typedef std::vector<entry_ptr> registry_t;
      typedef std::map<std::string, entry_ptr> name_to_entry_t;

      static registry_t& entries()
      {
         static registry_t x;
         return x;
      }

      static name_to_entry_t& name_to_entry()
      {
         static name_to_entry_t x;
         return x;
      }
   };

   struct null_deleter
   {
      void operator()(const void*) const {};
   };
}

namespace boost { namespace langbinding {
   
   template<class T>
   void central_registry<T>::register_module(
         const char* name, registry_ptr r, inheritance_graph_ptr g)
   {
      std::cout << "central registry: registering module \""
                << name << "\"..\n";

      typename implementation<T>::entry tmp;
      tmp.registry_ = r;
      typename implementation<T>::entry_ptr ptr(&tmp, null_deleter());

      typedef typename implementation<T>::registry_t::iterator iter_type;

      iter_type iter = std::lower_bound(
           implementation<T>::entries().begin()
         , implementation<T>::entries().end()
         , ptr
         , implementation<T>::cmp_entry()
      );

      if (iter == implementation<T>::entries().end() ||
          (*iter)->registry_ != ptr->registry_)
      {
         ptr = BOOST_MSVC_TYPENAME implementation<T>::entry_ptr(
            new BOOST_MSVC_TYPENAME implementation<T>::entry);
         ptr->registry_ = r;

         implementation<T>::entries().insert(
            iter, ptr);
      }
      else
         ptr = *iter;

      std::string id(name);
      implementation<T>::name_to_entry()[id] = ptr;
   }

   template<class T>
   void central_registry<T>::insert_converter(
           registry_ptr r
         , const typename registry<T>::type_info_& x
         , typename registry<T>::lvalue_from_function convert
      )
   {
      typename implementation<T>::entry tmp;
      tmp.registry_ = r;
      typename implementation<T>::entry_ptr ptr(&tmp, null_deleter());

      typedef typename implementation<T>::registry_t::iterator iter_type;

      iter_type iter = std::lower_bound(
           implementation<T>::entries().begin()
         , implementation<T>::entries().end()
         , ptr
         , implementation<T>::cmp_entry()
      );

      if (iter == implementation<T>::entries().end() ||
          (*iter)->registry_ != ptr->registry_)
      {
         ptr = BOOST_MSVC_TYPENAME implementation<T>::entry_ptr(
            new BOOST_MSVC_TYPENAME implementation<T>::entry);
         ptr->registry_ = r;

         implementation<T>::entries().insert(
            iter, ptr);
      }
      else
         ptr = *iter;

      // .. add converter
   }

   template<class T>
   void central_registry<T>::insert_converter(
           registry_ptr r
         , const typename registry<T>::type_info_& x
         , typename registry<T>::rvalue_from_stage1 convertible
         , typename registry<T>::rvalue_from_stage2 convert
      )
   {
      typename implementation<T>::entry tmp;
      tmp.registry_ = r;
      typename implementation<T>::entry_ptr ptr(&tmp, null_deleter());

      typedef typename implementation<T>::registry_t::iterator iter_type;

      iter_type iter = std::lower_bound(
           implementation<T>::entries().begin()
         , implementation<T>::entries().end()
         , ptr
         , implementation<T>::cmp_entry()
      );

      if (iter == implementation<T>::entries().end() ||
          (*iter)->registry_ != ptr->registry_)
      {
         ptr = BOOST_MSVC_TYPENAME implementation<T>::entry_ptr(
            new BOOST_MSVC_TYPENAME implementation<T>::entry);
         ptr->registry_ = r;

         implementation<T>::entries().insert(
            iter, ptr);
      }
      else
         ptr = *iter;

      // .. add converter
   }

   template<class T>
   void central_registry<T>::import(
           registry_ptr r
         , const char* module)
   {
      typename implementation<T>::name_to_entry_t::const_iterator iter
         = implementation<T>::name_to_entry().find(module);

      assert(iter != implementation<T>::name_to_entry().end());
      typename implementation<T>::entry_ptr e = iter->second;

      e->registry_->export_converters(*r);
   }

   template<class T>
   void central_registry<T>::import(
           registry_ptr r
         , const char* module
         , const typename registry<T>::type_info_& x)
   {
      typename implementation<T>::name_to_entry_t::const_iterator iter
         = implementation<T>::name_to_entry().find(module);

      assert(iter != implementation<T>::name_to_entry().end());
      typename implementation<T>::entry_ptr e = iter->second;

      e->registry_->export_converters(x, *r);
   }

}}

#endif

