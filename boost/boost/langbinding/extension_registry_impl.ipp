// Copyright (c) 2003 Daniel Wallin

// Permission is hereby granted, free of charge, to any person or organization 
// obtaining a copy of the software covered by this license (the "Software") 
// to use, reproduce, display, distribute, execute, and transmit the Software, 
// and to prepare derivative works of the Software, and to permit others
// to do so, all subject to the following:

// The copyright notice in the Software and this entire statement, including 
// the above license grant, this restriction and the following disclaimer, 
// must be included in all copies of the Software, in whole or in part, and 
// all derivative works of the Software, unless such copies or derivative 
// works are solely in the form of machine-executable object code generated by 
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.

#include <boost/langbinding/config.hpp>
#include <boost/langbinding/extension_registry_impl.hpp>
#include <boost/tuple/tuple.hpp>
#include <map>

#include <iostream>

namespace boost { namespace langbinding {

   namespace {

      template<class T>
      struct implementation
      {
         typedef tuples::tuple<
               registry<T>*
             , inheritance_graph*
         > entry_t;

         typedef std::map<extension_id_t, entry_t> registry_t;

         static registry_t& entries()
         {
            static registry_t x;
            return x;
         }

         typedef std::map<std::string, typename registry_t::iterator> names_t;

         static names_t& names()
         {
            static names_t x;
            return x;
         }
      };

      using tuples::tie;
      using tuples::get;
      tuples::detail::swallow_assign _; // ignore is too verbose

   } // boost::langbinding::unnamed namespace

   template<class T>
   void extension_registry_impl<T>::register_(
            extension_id_t id
          , const char* name
          , registry<T>* converters
          , inheritance_graph* graph)
   {
      std::cout << "registering extension " << id << " with name "
         << name << "\n";

      typename implementation<T>::registry_t::iterator iter;
      
      tie(iter, _) = implementation<T>::entries().insert(
            typename implementation<T>::registry_t::value_type(
               id, make_tuple(converters, graph)));

      bool already_registered;

      tie(_, already_registered)
         = implementation<T>::names().insert(
               typename implementation<T>::names_t::value_type(
                  std::string(name), iter));

      assert(already_registered);
   }

   template<class T>
   std::pair<
        registry<T>*
      , inheritance_graph*
   > extension_registry_impl<T>::extension(extension_id_t id)
   {
      typename implementation<T>::registry_t::iterator iter
         = implementation<T>::entries().find(id);

      assert(iter != implementation<T>::entries().end());

      return std::make_pair(
                  get<0>(iter->second)
                , get<1>(iter->second));
   }

   template<class T>
   std::pair<
        registry<T>*
      , inheritance_graph*
   > extension_registry_impl<T>::extension(const char* name)
   {
      std::cout << "requesting extension: " << name << "\n";

      typedef typename implementation<T>::names_t::iterator iter_t;

      typename implementation<T>::names_t::iterator iter
         = implementation<T>::names().find(name);

      return iter == implementation<T>::names().end()
                ? extension_t(0, 0)
                : extension_t(
                     get<0>(iter->second->second)
                   , get<1>(iter->second->second));               
   }

}}

