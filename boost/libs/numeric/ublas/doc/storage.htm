<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Storage</title>
</head>

<body bgcolor="#FFFFFF">

<h1>Storage</h1>

<h2><a name="unbounded_array"></a>Unbounded Array</h2>

<p>The templated class <code>unbounded_array</code> implements a
simple C-like array using allocation via <code>new/delete</code>.</p>

<pre><code>    // Unbounded array 
    template&lt;class T&gt;
    class unbounded_array {
    public:      
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef T value_type;
        typedef const T &amp;const_reference_type;
        typedef T &amp;reference_type;
        typedef const T *const_pointer_type;
        typedef T *pointer_type;

        // Construction and destruction
        unbounded_array ();
        unbounded_array (size_type size);
        unbounded_array (const unbounded_array &amp;a);
        ~unbounded_array ();

        // Resizing
        void resize (size_type size);

        size_type size () const;

        // Element access
        value_type operator [] (size_type i) const;
        reference_type operator [] (size_type i);

        // Assignment
        unbounded_array &amp;operator = (const unbounded_array &amp;a);
        unbounded_array &amp;assign_temporary (unbounded_array &amp;a);

        // Swapping
	void swap (unbounded_array &amp;a);
	friend void swap (unbounded_array &amp;a1, unbounded_array &amp;a2);

        // Element insertion
        void clear ();
        pointer_type insert (pointer_type it, const value_type &amp;t);

        // Iterators simply are pointers.

        typedef const_pointer_type const_iterator;

        const_iterator begin () const;
        const_iterator end () const;

        typedef pointer_type iterator;

        iterator begin ();
        iterator end ();

        // Reverse iterators

        typedef std::reverse_iterator&lt;const_iterator, value_type, const_reference_type&gt; const_reverse_iterator;

        const_reverse_iterator rbegin () const;
        const_reverse_iterator rend () const;

        typedef std::reverse_iterator&lt;iterator, value_type, reference_type&gt; reverse_iterator;

        reverse_iterator rbegin ();
        reverse_iterator rend ();
    };
</code></pre>

<h2><a name="bounded_array"></a>Bounded Array</h2>

<p>The templated class <code>bounded_array</code> implements a
simple C-like array.</p>

<pre><code>    // Bounded array 
    template&lt;class T, std::size_t N&gt;
    class bounded_array {
    public:      
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef T value_type;
        typedef const T &amp;const_reference_type;
        typedef T &amp;reference_type;
        typedef const T *const_pointer_type;
        typedef T *pointer_type;

        // Construction and destruction
        bounded_array ();
        bounded_array (size_type size);
        bounded_array (const bounded_array &amp;a);

	// Resizing
        void resize (size_type size);

        size_type size () const;

        // Element access
        value_type operator [] (size_type i) const;
        reference_type operator [] (size_type i);

        // Assignment
        bounded_array &amp;operator = (const bounded_array &amp;a);
        bounded_array &amp;assign_temporary (bounded_array &amp;a);

        // Swapping
    	void swap (bounded_array &amp;a);
	friend void swap (bounded_array &amp;a1, bounded_array &amp;a2);

        // Iterators simply are pointers.

        typedef const_pointer_type const_iterator;

        const_iterator begin () const;
        const_iterator end () const;

        typedef pointer_type iterator;

        iterator begin ();
        iterator end ();

        // Element insertion
        void clear ();
        pointer_type insert (pointer_type it, const value_type &amp;t);

        // Reverse iterators

        typedef std::reverse_iterator&lt;const_iterator, value_type, const_reference_type&gt; const_reverse_iterator;

        const_reverse_iterator rbegin () const;
        const_reverse_iterator rend () const;

        typedef std::reverse_iterator&lt;iterator, value_type, reference_type&gt; reverse_iterator;

        reverse_iterator rbegin ();
        reverse_iterator rend ();
    };</code></pre>

<h2><a name="range"></a>Range</h2>

<p>The class <code>range </code>implements base functionality
needed to address ranges of vectors and matrices.</p>

<pre><code>    // Range class
    class range {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef difference_type value_type;
        typedef size_type const_iterator_type;

        // Construction and destruction
        range (size_type start, size_type stop);

        size_type start () const;
        size_type size () const;

        // Element access
        value_type operator () (size_type i) const;

        // Composition
        range composite (const range &amp;r) const;

        // Comparison
        bool operator == (const range &amp;r) const;
        bool operator != (const range &amp;r) const;

        // Iterators simply are indexes.

        class const_iterator:
            public container_const_reference&lt;range&gt;,
            public random_access_iterator_base&lt;const_iterator, value_type&gt; {
        public:

            // Construction and destruction
            const_iterator (const range &amp;r, const const_iterator_type &amp;it);

            // Arithmetic
            const_iterator &amp;operator ++ ();
            const_iterator &amp;operator -- ();
            const_iterator &amp;operator += (difference_type n);
            const_iterator &amp;operator -= (difference_type n);
            difference_type operator - (const const_iterator &amp;it) const;

            // Dereference
            value_type operator * () const;

            // Index
            size_type index () const;

            // Comparison
            bool operator == (const const_iterator &amp;it) const;
        };

        const_iterator begin () const;
        const_iterator end () const;

        // Reverse iterator

        typedef std::reverse_iterator&lt;const_iterator, value_type, value_type&gt; const_reverse_iterator;

        const_reverse_iterator rbegin () const;
        const_reverse_iterator rend () const;
    };</code></pre>

<h2><a name="slice"></a>Slice</h2>

<p>The class <code>slice </code>implements base functionality
needed to address slices of vectors and matrices.</p>

<pre><code>    // Slice class
    class slice {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef difference_type value_type;
        typedef size_type const_iterator_type;

        // Construction and destruction
        slice (size_type start, size_type stride, size_type size);

        size_type start () const;
        size_type stride () const;
        size_type size () const;

        // Element access
        value_type operator () (size_type i) const;

        // Composition
        slice composite (const range &amp;r) const;
        slice composite (const slice &amp;s) const;

        // Comparison
        bool operator == (const slice &amp;s) const;
        bool operator != (const slice &amp;s) const;

        // Iterator simply is a index.

        class const_iterator:
            public container_const_reference&lt;slice&gt;,
            public random_access_iterator_base&lt;const_iterator, value_type&gt; {
        public:

            // Construction and destruction
            const_iterator (const slice &amp;s, const const_iterator_type &amp;it);

            // Arithmetic
            const_iterator &amp;operator ++ ();
            const_iterator &amp;operator -- ();
            const_iterator &amp;operator += (difference_type n);
            const_iterator &amp;operator -= (difference_type n);
            difference_type operator - (const const_iterator &amp;it) const;

            // Dereference
            value_type operator * () const;

            // Index
            size_type index () const;

            // Comparison
            bool operator == (const const_iterator &amp;it) const;
        };

        const_iterator begin () const;
        const_iterator end () const;

        // Reverse iterator

        typedef std::reverse_iterator&lt;const_iterator, value_type, value_type&gt; const_reverse_iterator;

        const_reverse_iterator rbegin () const;
        const_reverse_iterator rend () const;
    };</code></pre>
</body>
</html>
