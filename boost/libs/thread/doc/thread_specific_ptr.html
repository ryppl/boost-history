<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="threads, BTL, thread library, C++">
<link rel="stylesheet" type="text/css" href="styles.css">
<title>Boost.Threads, thread_specific_ptr</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="300">
			<h3><img src="../../../c++boost.gif" alt="C++ Boost" width="277" height="86"></h3>
        </td>
        <td valign="top">
			<h1 align="center">Boost.Threads</h1>
			<h2 align="center">thread_specific_ptr</h2>
        </td>
    </tr>
</table>

<hr>

<p><A href="#Introduction">Introduction</A><br>
<A href="#Header">Header</A><br>
<A href="#Synopsis">Synopsis</A><br>
<A href="#Members">Members</A><br>
<A href="#Example">Example</A></p>

<h2><a name="Introduction">Introduction</a></h2>

<p>The <code>thread_specific_ptr</code> class defines an interface for using thread specific storage.
Thread specific storage is data associated with individual threads and is often used to make
operations <a href="definitions.html#Thread-safe">thread-safe</a> that rely on global data.</p>

<h2><a name="Header">Header</a></h2>

<pre>
#include <a href="../../../boost/thread/tss.hpp">&lt;boost/thread/tss.hpp&gt;</a>
</pre>

<h2><a name="Synopsis">Synopsis</a></h2>

<pre>
namespace boost {

template &lt;typename T&gt;
class thread_specific_ptr : private boost::noncopyable
{
public:
    thread_specific_ptr();
    ~thread_specific_ptr();

    T* get() const;
    T* operator->() const;
    T& operator*() const;
};

} // namespace boost
</pre>    

<h2><a name="Members">Members</a></h2>

<hr>
<h3>Constructor</h3>

<pre>
thread_specific_ptr();
</pre>

<p><b>Postconditions:</b> A thread specific storage slot has been reserved for use by *this
in all threads.</p>

<p><b>Requires:</b> The expression <code>delete get()</code> is well formed.</p>

<p><b>Notes:</b> There may be an implementation specific limit to the number of thread specific
storage slots that can be created, and this limit may be small.  No object is actually created
for storage in any running thread.</p>

<hr>
<h3>Destructor</h3>

<pre>
~thread_specific_ptr();
</pre>

<p><b>Notes:</b> Does not destroy any data that may be stored in any thread's thread specific
storage. For this reason you should not destroy a <code>thread_specific_ptr</code> object until
you are certain there are no threads running that have made use of its thread specific storage.</p>

<hr>
<h3>get</h3>

<pre>
T* get() const;
</pre>

<p><b>Returns:</b> The object stored in thread specific storage for the current thread for *this.</p>

<p><b>Requires:</b> The experession <code>new T()</code> is well formed.</p>

<p><b>Notes:</b> If the current thread has not previously accessed it's thread specific storage
for *this then an object of type T shall be default constructed and stored.</p>

<hr>
<h3>Smart Pointer Operations</h3>

<pre>
T* operator->() const;
</pre>

<p><b>Returns:</b> <code>get()</code></p>

<pre>
T& operator*() const;
</pre>

<p><b>Returns:</b> <code>get()</code></p>

<p><b>Requires:</b> <code>get() != 0</code></p>

<hr>
<h2><a name="Example">Example Usage</a></h2>

<pre>
#include <a href="../../../boost/thread/thread.hpp">&lt;boost/thread/thread.hpp&gt;</a>
#include <a href="../../../boost/thread/tss.hpp">&lt;boost/thread/tss.hpp&gt;</a>
#include &lt;cassert&gt;

boost::tss value;

void increment()
{
   int* p = static_cast<int*>(value.get());
   ++*p;
}

void thread_proc()
{
   value.set(new int(0)); // initialize the thread's storage
   for (int i=0; i&lt;10; ++i)
   {
       increment();
       int* p = static_cast<int*>(value.get());
       assert(*p == i+1);
   }
   delete value.get();
}

int main(int argc, char* argv[])
{
   boost::thread::thread_group threads;
   for (int i=0; i&lt;5; ++i)
      threads.create(&amp;thread_proc);
   threads.join_all();
}
</pre>

<hr>

<p>Revised <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->01 August, 2001<!--webbot bot="Timestamp" endspan i-checksum="34342" -->
</p>

<p><i>© Copyright <a href="mailto:williamkempf@hotmail.com">William E. Kempf</a>
2001 all rights reserved.</i></p>

</body>
</html>
