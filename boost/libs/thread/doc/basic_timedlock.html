<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="threads, BTL, thread library, C++">
<title>Boost.Threads, basic_timedlock</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="300">
			<h3><img src="../../../c++boost.gif" alt="C++ Boost" width="277" height="86"></h3>
        </td>
        <td valign="top">
			<h1 align="center">Boost.Threads</h1>
			<h2 align="center">basic_timedlock</h2>
        </td>
    </tr>
</table>

<hr>

<p>This template class defines a <a href="lock_concept.html">lock type</a> that allows a
program to attempt to lock the associated <a href="mutex_concept.html">mutex model</a>
blocking only for a specified amount of time. The <a href="mutex.html">timed_mutex</a> and
<a href="recursive_mutex.html">recursive_timed_mutex</a> use this template to define their
<tt>timed_lock</tt> types.</p>

<p>Like all the <b>Boost.Threads</b> <a href="lock_concept.html">lock models</a>, the
<tt>basic_timedlock</tt> is meant to be short lived and is not thread safe, so should not
be shared between threads.</p>

<h4>Header</h4>

<pre>
#include <a href="../../../boost/thread/xlock.hpp">&lt;boost/thread/xlock.hpp&gt;</a>
   <i>This header is usually not included directly by programmers.  Instead it's
   included by the <a href="mutex_concept.html">mutex model</a> that exposes it.</i>
</pre>

<h4>Public Interface</h4>

<hr width="50%" align="left">

<pre>
    template &lt;typename M&gt;
    class basic_timedlock : private boost::noncopyable
    {
    public:
        typedef M mutex_type;

        basic_timedlock(M&amp; mx, const boost::xtime&amp; xt);
        basic_timedlock(M&amp; mx, bool lock_it);
        ~basic_timedlock();
        
        void lock();
        bool timed_lock(const xtime&amp; xt);
        void unlock();
        
        operator const void*() const;
    };
</pre>

<h5>Constructors</h5>

<pre>
    basic_timedlock(M&amp; mx, const xtime&amp; xt);
</pre>

<p>Constructs a <tt>basic_timedlock</tt> and calls <tt>timed_lock</tt> with <tt>xt</tt>.</p>

<pre>
    basic_timedlock(M&amp; mx, bool lock_it);
</pre>

<p>Constructs a <tt>basic_timedlock</tt> and if <tt>lock_it</tt> is <tt>true</tt> then
calls <tt>lock</tt>.

<h5>Destructor</h5>

<pre>
    ~basic_timedlock();
</pre>

<p>Destructs the <tt>basic_timedlock</tt> and if locked calls <tt>unlock</tt>.</p>

<h3>lock</h3>

<pre>
    void lock();
</pre>

<p>Locks the associated <a href="mutex_concept.html">mutex model</a>.  If the <tt>basic_timedlock</tt>
is already locked then a <a href="lock_error.html">lock_error</a> is thrown.  Depending on the
<a href="mutex_concept.html#LockingStrategies">locking strategy</a> of the
<a href="mutex_concept.html">mutex model</a> if the calling thread already owns a lock through
another <a href="lock_concept.html">lock model</a> this may cause a deadlock or for a
<a href="lock_error.html">lock_error</a> to be thrown.</p>

<h3>timed_lock</h3>

<pre>
    bool timed_lock(const xtime&amp; xt);
</pre>

<p>Attempts to lock the associated <a href="mutex_concept.html">mutex model</a>. If the
<tt>basic_timedlock</tt> is already locked then a <a href="lock_error.html">lock_error</a> is
thrown. If the <a href="mutex_concept.html">mutex model</a> is already locked by another thread
this operation will wait until <tt>xt</tt> before returning <tt>false</tt>.</p>

<h3>unlock</h3>

<pre>
    void unlock();
</pre>

<p>Unlocks the associated <a href="mutex_concept.html#Mutex">mutex model</a>.  If the <tt>basic_timedlock</tt>
is not already locked then a <a href="lock_error.html">lock_error</a> is thrown.</p>

<h3>const void* Conversion</h3>

<pre>
    operator const void*() const;
</pre>

<p>Implicitly converts the lock to a value that can be used in boolean expressions to test if the
lock is currently locked or not.</p>

<h4>Example Usage</h4>

<pre>
#include &lt;boost/thread/mutex.hpp&gt;
#include &lt;iostream&gt;

int main(int, char*[])
{
   boost::mutex mutex;
   boost::xtime xt;
   boost::get_xtime(&amp;xt, boost::TIME_UTC);
   xt.sec += 1;
   boost::mutex::timed_lock lock(mutex, xt);
   if (lock)
      std::cout &lt;&lt; &quot;locked&quot; &lt;&lt; std::endl;
   else
      std::cout &lt;&lt; &quot;unlocked&quot; &lt;&lt; std::endl;
   return 0;
}
</pre>

<p>The output is:</p>

<pre>
locked
</pre>

<hr>

<p><i>Copyright <a href="mailto:williamkempf@hotmail.com">William E. Kempf</a>
2001 all rights reserved.</i></p>

</body>
</html>
