<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../../boost.css">
<title>Boost.Threads - Header &lt;boost/thread/barrier.hpp&gt;</title>
</head>
<body link="#0000ff" vlink="#800080">
<table border="0" cellpadding="7" cellspacing="0" width="100%" summary=
    "header">
  <tr> 
    <td valign="top" width="300"> 
      <h3><a href="../../../index.htm"><img height="86" width="277" alt="C++ Boost" src="../../../c++boost.gif" border="0"></a></h3>
    </td>
    <td valign="top"> 
      <h1 align="center">Boost.Threads</h1>
      <h2 align="center">Header &lt;<a href="../../../boost/thread/barrier.hpp">boost/thread/barrier.hpp</a>&gt;</h2>
    </td>
  </tr>
</table>
<hr>
<h2>Contents</h2>
<dl class="page-index"> 
  <dt><a href="#introduction">Introduction</a></dt>
  <dt><a href="#classes">Classes</a></dt>
  <dl class="page-index"> 
    <dt><a href="#class-barrier">Class <code>barrier</code></a></dt>
    <dl class="page-index"> 
      <dt><a href="#class-barrier-synopsis">Class <code>barrier</code> synopsis</a></dt>
      <dt><a href="#class-barrier-ctors">Class <code>barrier</code> constructors 
        and destructor</a></dt>
      <dt><a href="#class-barrier-modifiers">Class <code>barrier</code> modifier 
        functions</a></dt>
    </dl>
  </dl>
  <dt><a href="#examples">Example(s)</a></dt>
</dl>
<hr>
<h2><a name="introduction"></a>Introduction</h2>
<p>Include the header &lt;<a href="../../../boost/thread/barrier.hpp">boost/thread/barrier.hpp</a>&gt; 
  to define the class <code>boost::barrier</code>.</p>
<h2><a name="classes"></a>Classes</h2>
<h3><a name="class-barrier"></a>Class <code>barrier</code></h3>
<p>An object of class <code>barrier</code> is a synchronization primitive used 
  to cause a set of threads to wait until they each perform a certain function 
  or each reach a particular point in their execution.&nbsp; When a barrier is 
  created, it is initialized with a thread count "N".&nbsp; The first N-1 calls 
  to wait() will all cause their threads to be blocked.&nbsp; The Nth call to 
  wait() will allow all of the waiting threads, including the Nth thread, to be 
  placed in a ready state.&nbsp; Should an additional thread make an N+1th call 
  to wait() on the barrier, it will be as though this was the first call to wait(), 
  and the process will be repeated until another N threads call wait().&nbsp; 
  This functionality allows the same set of N threads to re-use a barrier object 
  to synchronize their execution at multiple points during their execution.</p>
<p>See <A href="definitions.html">Formal Definitions</A> for definitions of thread 
  states <A href="definitions.html#state">blocked</A> and <A href="definitions.html#state"> 
  ready</A>. Note that "waiting" is a synonym for blocked.</p>
<P>The header &lt;<a href="../../../boost/thread/barrier.hpp">boost/threads/barrier.hpp</a>&gt; contains a second class, "one_shot_barrier" 
  which allows for one generation of waiting.&nbsp; If the N+1th thread calls 
  wait(), an exception will be thrown.&nbsp; One use case for barriers is to synchronize 
  threads as they start on some initialization process.&nbsp; Once that is completed, 
  the threads can run freely.&nbsp; boost::one_shot_barrier provides a somewhat 
  more lightweight implementation of barrier for those cases.&nbsp; The author 
  isn't convinced that this use case justified an additional class in Boost.Threads, 
  however.</P>
<P>The implementation of boost::barrier addresses a race condition that can occur 
  in barrier implementations using only one condition variable or semaphore.&nbsp; 
  The N+1th waiter is able to steal&nbsp;a wakeup from an earlier thread if it 
  reaches its wait() call before an the earlier wait()&nbsp;is scheduled by the 
  OS.&nbsp;&nbsp;In this implementation (a combination of that&nbsp;in ACE and 
  pthreads-win32), the N+1th waiter will wait on a different condition variable.</P>
<P>There is a MUCH less likely race condition even in this implementation where 
  if waiters N+1 through 2N+1 ALL reach their wait() call and ALL steal the wakeup 
  from one the first generation threads.&nbsp; The author believes that this implementation 
  is race-free if fewer than 2N threads ever call wait().&nbsp; In the most common 
  use case of exactly N threads calling wait, the imlementation is certainly race-free.&nbsp; 
  One uncommon use case for barriers is for M threads where M&nbsp;is some multiple 
  of N, continually use a barrier to cause an action to occurs every time N threads 
  reach a certain point.&nbsp; Strictly speaking, the behavior of this implementation 
  of boost::barrier is undefined for more than 2N threads calling wait().&nbsp; 
</P>
<h4><a name="class-barrier-synopsis"></a>Class <code>barrier</code> synopsis</h4>
<pre>
namespace boost
{
    class barrier : private <A href="../../utility/utility.htm#Class noncopyable">boost::noncopyable</A> // Exposition only.
        // Class barrier meets the <A href="overview.html#NonCopyable"  .. utility.htm#Class? utility>NonCopyable</A> requirement.
    {
    public:
        barrier(size_t count);
        ~barrier();

        int wait();
    };
};
</pre>
<h4><a name="class-barrier-ctors"></a>Class <code>barrier</code> constructors 
  and destructor</h4>
<pre>
barrier(size_t count);
</pre>
<dl class="function-semantics"> 
  <dt><b>Effects:</b> Constructs a <code>barrier</code> object that will cause 
    count threads to block on a call to wait().</dt>
</dl>
<pre>
~barrier();
</pre>
<dl class="function-semantics"> 
  <dt><b>Effects:</b> Destroys <code>*this</code>.&nbsp; If threads are still 
    executing their wait() operations, the behavior for these threads is undefined.</dt>
</dl>
<h4><a name="class-barrier-modifiers"></a>Class <code>barrier</code> modifier 
  functions</h4>
<pre>
int wait();
</pre>
<dl class="function-semantics"> 
  <dt><b>Effects:</b> Wait until N threads call wait(), where N equals the count 
    provided to the constructor for the barrier object.</dt>
  <dt><b>Returns:</b> Exactly one of the N threads will receive a return value 
    of BOOST_SERIAL_THREAD, the others will receive a value of 0.&nbsp; Precisely 
    which thread receives the return value of BOOST_SERIAL_THREAD will be implementation 
    defined.&nbsp; Applications can use this value to designate one thread as 
    a leader that will take a certain action, and the other threads emerging from 
    the barrier can wait for that action to take place.</dt>
  <dt><b>Danger:</b> If the barrier is destroyed before wait() can return, the 
    behavior is undefined.</dt>
</dl>
<h2><a name="examples"></a>Example(s)</h2>
<pre>
#include <a href="../../../boost/thread/condition.hpp">&lt;boost/thread/barrier.hpp&gt;</a>
#include <a href="../../../boost/thread/thread.hpp">&lt;boost/thread/thread.hpp&gt;</a>
#include <a href="../../../boost/thread/mutex.hpp">&lt;boost/thread/mutex.hpp&gt;</a>
#include &lt;iostream&gt;

const int N_THREADS = 10;
boost::barrier gen_barrier(N_THREADS);
int global_parameter = 0;
boost::mutex mutex;

static void worker()
{
    int i;
    for (i = 0; i &lt; 5; i++)
    {
        // Simulate 5 cycles of computation...
        if (gen_barrier.wait() == boost::BOOST_SERIAL_THREAD)
        {
		    boost::mutex::scoped_lock lock(mutex);
            global_parameter++;
        }
    }
    // Let one worker "report" the results
    if (gen_barrier.wait() == boost::BOOST_SERIAL_THREAD)
	{
	    boost::mutex::scoped_lock lock(lock);
        std::cout &lt;&lt; "Global Parameter=" &lt;&lt; global_parameter &lt;&lt; "\n";
    }
}

int main(int, char*[])
{
    int i;
    boost::thread_group g;
    global_parameter = 0;

    for(i = 0; i &lt; N_THREADS; i++)
        g.create_thread(&amp;worker);

    g.join_all();

}
</pre>
<p>The output is:</p>
<pre>
Global Parameter=5
</pre>
<p>Revised 
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
  05 November, 2001 
  <!--webbot bot="Timestamp" endspan i-checksum="39359" -->
</p>
<p><i>&copy; Copyright <a href="mailto:{{address}}">{{author}}</a> 2002. All Rights 
  Reserved.</i></p>
</body>
</html>
