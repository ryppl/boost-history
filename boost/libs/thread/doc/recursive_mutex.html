<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="threads, BTL, thread library, C++">
<title>Boost.Threads, recursive_mutex</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="300">
			<h3><img src="../../../c++boost.gif" alt="C++ Boost" width="277" height="86"></h3>
        </td>
        <td valign="top">
			<h1 align="center">Boost.Threads</h1>
			<h2 align="center">recursive_mutex</h2>
        </td>
    </tr>
</table>

<hr>

<h3><a name="recursive_mutex">recursive_mutex</a></h3>

<p>The <tt>recursive_mutex</tt>, <tt>recursive_try_mutex</tt> and <tt>recursive_timed_mutex</tt>
classes define full featured <a href="mutex_concept.html">mutex models</a>
with recursive locking semantics. These models should be used to synchronize access to shared resources
when recursive locking by a single thread is likely to occur. A good example for this is when a class
supplies "internal synchronization" to insure <a href="thread_formal_definition.html#Thread-safe"> thread-safety</a> and a method on the class may have to call
other methods on the class which would also attempt to lock the <a href="mutex_concept.html">mutex model</a>.

<p>Each type adds another <A href="lock_concept.html">lock concept</a>, including the
<A href="basic_lock.html">basic_lock</a>, <A href="basic_trylock.html">basic_trylock</a> and
<A href="basic_timedlock.html">basic_timedlock</a> types. For the best possible performance you should use
the mutex type that supports only the lock types that you need.</p>

<p>The <tt>recursive_mutex</tt>, <tt>recursive_try_mutex</tt> and <tt>recursive_timed_mutex</tt> employ a
<tt>Recursive</tt> <a href="mutex_concept.html#LockingStrategies">locking strategy</a>, so attempts to
recursively lock them succeed and an internal "lock count" is maintained.  Attempts to unlock them
by a thread that does not own a lock on them will result in a <a href="lock_error.html">lock_error</a>
exception being thrown.</p>

<p>Like all the <b>Boost.Threads</b> <a href="mutex_concept.html">mutex models</a>, the
<tt>recursive_mutex</tt>, <tt>recursive_try_mutex</tt> and <tt>recursive_timed_mutex</tt> leave the
<a href="mutex_concept.html#SchedulingPolicies">scheduling policy</a> as <tt>Unspecified</tt>. Programmers
should assume that threads waiting for a lock on them shall acquire the lock in a random order, though the
specific behavior for a given platform may be different.</p>

<h2>Header</h2>

<pre>
#include <a href="../../../boost/thread/recursive_mutex.hpp">&lt;boost/thread/recursive_mutex.hpp&gt;</a>
</pre>

<h2>Public Interface</h2>

<hr width="50%" align="left">

<pre>
    class recursive_mutex : private boost::noncopyable
    {
    public:
       typedef boost::basic_lock&lt;recursive_mutex&gt; lock;
      
       recursive_mutex();
       ~recursive_mutex();
    };
</pre>

<hr width="50%" align="left">

<h3>Constructor</h3>

<pre>
    recursive_mutex();
</pre>

<p>Constructs a <tt>recursive_mutex</tt>.</p>

<h3>Destructor</h3>

<pre>
    ~recursive_mutex();
</pre>

<p>Destructs a <tt>recursive_mutex</tt>.</p>

<hr width="50%" align="left">

<pre>
    class recursive_try_mutex : private boost::noncopyable
    {
    public:
       typedef boost::basic_lock&lt;recursive_try_mutex&gt; lock;
       typedef boost::basic_trylock&lt;recursive_try_mutex&gt; try_lock;
      
       recursive_try_mutex();
       ~recursive_try_mutex();
    };
</pre>

<hr width="50%" align="left">

<h3>Constructor</h3>

<pre>
    recursive_try_mutex();
</pre>

<p>Constructs a <tt>recursive_try_mutex</tt>.</p>

<h3>Destructor</h3>

<pre>
    ~recursive_try_mutex();
</pre>

<p>Destructs a <tt>recursive_try_mutex</tt>.</p>

<hr width="50%" align="left">

<pre>
    class recursive_timed_mutex : private boost::noncopyable
    {
    public:
       typedef boost::basic_lock&lt;recursive_timed_mutex&gt; lock;
       typedef boost::basic_trylock&lt;recursive_timed_mutex&gt; try_lock;
       typedef boost::basic_timedlock&lt;recursive_timed_mutex&gt; timed_lock;
      
       recursive_timed_mutex();
       ~recursive_timed_mutex();
    };
</pre>

<hr width="50%" align="left">

<h3>Constructor</h3>

<pre>
    recursive_timed_mutex();
</pre>

<p>Constructs a <tt>recursive_timed_mutex</tt>.</p>

<h3>Destructor</h3>

<pre>
    ~recursive_timed_mutex();
</pre>

<p>Destructs a <tt>recursive_timed_mutex</tt>.</p>

<h2>Example Usage</h2>

<pre>
#include <a href="../../../boost/thread/recursive_mutex.hpp">&lt;boost/thread/recursive_mutex.hpp&gt;</a>
#include <a href="../../../boost/thread/thread.hpp">&lt;boost/thread/thread.hpp&gt;</a>
#include &lt;iostream&gt;

class counter
{
private:
    boost::recursive_mutex mutex;
    int count;
   
public:
    counter() : count(0) { }

    int add(int val) {
        boost::recursive_mutex::lock lock(mutex);
        count += val;
        return count;
    }   
    int increment() {
        boost::recursive_mutex::lock lock(mutex);
        return add(1);
    }
};

counter c;

void change_count(void*)
{
    std::cout &lt;&lt; &quot;count == &quot; &lt;&lt; c.increment() &lt;&lt; std::endl;
}

int main(int, char*[])
{
    const int num_threads=4;
   
    for (int i=0; i &lt; num_threads; ++i)
        boost::thread::create(&amp;change_count, 0);
      
    boost::thread::join_all();
   
    return 0;
}
</pre>

<p>The output is:</p>

<pre>
count == 1
count == 2
count == 3
count == 4
</pre>

<hr>

<p><i>Copyright <a href="mailto:williamkempf@hotmail.com">William E. Kempf</a>
2001 all rights reserved.</i></p>

</body>
</html>
