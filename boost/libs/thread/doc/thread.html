<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="threads, BTL, thread library, C++">
<title>Boost.Threads, thread</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="300">
			<h3><img src="../../../c++boost.gif" alt="C++ Boost" width="277" height="86"></h3>
        </td>
        <td valign="top">
			<h1 align="center">Boost.Threads</h1>
			<h2 align="center">thread</h2>
        </td>
    </tr>
</table>

<hr>

<p>The <tt>thread</tt> class provides the functionality to create and manage threads
within the <b>Boost.Threads</b> library. See <a href="thread_formal_definition.html">Formal
Definition of &quot;Thread&quot;</a> for a precise description of what a thread
is.</p>

<h2>Header</h2>

<pre>
#include &lt;boost/thread/thread.hpp&gt;
</pre>

<h2>Public Interface</h2>

<hr width="50%" align="left">

<pre>
    class thread : boost::noncopyable
    {
    public:
        thread();
        thread(const boost::function0&lt;void&gt;&amp; threadfunc);
        ~thread();

        bool operator==(const thread&amp; other) const;
        bool operator!=(const thread&amp; other) const;

        void join();
        bool try_join();
        bool timed_join(const xtime& xt);

        static void sleep(const xtime& xt);
        static void yield();
    };
</pre>    

<hr width="50%" align="left">

<h3>Constructor</h3>

<pre>
    thread();
</pre>

<p>Constructs a <tt>thread</tt> object that's associated with the currently running thread
of execution.</p>

<pre>
    thread(const boost::function0&lt;void&gt;&amp; threadfunc);
</pre>

<p>Starts a new thread of execution that calls <tt>threadfunc</tt> and constructs a <tt>thread</tt>
object that's associated with it.</p>

<h3>Destructor</h3>

<pre>
    ~thread();
</pre>

<p>Destructs a <tt>thread</tt> object.  The actual thread of execution may continue to run after
the <tt>thread</tt> object has been destroyed.  If you need to insure a thread of execution
runs to completion before the <tt>thread</tt> object is destroyed you should call join().</p>

<h3>Comparison Operators</h3>

<pre>
    bool operator==(const thread&amp; other);
    bool operator!=(const thread&amp; other);
</pre>

<p>Compares a <tt>thread</tt> object to <tt>other</tt> to see if they are associated with the same
running thread of execution.</p>

<h3>join</h3>

<pre>
   void join();
</pre>

<p>Causes the current thread to "join" the associated running thread of execution.  In other words,
the current thread will block until the associated running thread of execution finishes.</p>

<h3>try_join</h3>

<pre>
   bool try_join();
</pre>

<p>Attempts to "join" a thread with out blocking when the thread of execution is still running.
If the thread of execution has finished the return value shall be <tt>true</tt>, otherwise it shall
be <tt>false</tt>.</p>

<h3>timed_join</h3>

<pre>
   bool timed_join(const xtime& xt);
</pre>

<p>Attempts to "join" a thread, blocking until either the thread of execution finishes or
until <tt>xt</tt>.  If the thread of execution has finished or finishes before <tt>xt</tt>
the return value shall be <tt>true</tt>, otherwise it shall be <tt>false</tt>.</p>

<h3>sleep</h3>

<pre>
    static void sleep(const xtime&amp; xt);
</pre>

<p>Causes the current thread to block until <tt>xt</tt>.</p>

<h3>yield</h3>

<pre>
    static void yield();
</pre>

<p>Causes the current thread to give up the rest of its time slice to any other thread that may be waiting
on CPU time.  This method may also used to allow for a non-preemptive implementation.</p>

<h2>Example Usage</h2>

<pre>
#include &lt;boost/thread/thread.hpp&gt;
#include &lt;iostram&gt;

struct thread_alarm
{
   thread_alarm(int* secs) : m_secs(secs) { }
   void operator()()
   {
       boost::xtime xt;
       boost::xtime_get(&amp;xt, boost::TIME_UTC);
       xt.sec += m_secs;
   
       boost::thread::sleep(xt);
   
       std::cout &lt;&lt; &quot;alarm sounded...&quot; &lt;&lt; std::endl;
   }
   
   int m_secs;
};

int main(int argc, char* argv[])
{
   int secs = 5;
   std::cout &lt;&lt; &quot;setting alarm for 5 seconds...&quot; &lt;&lt; std::endl;
   boost::thread thrd(thread_alarm(5));
   thrd.join();
}
</pre>

<p>The output is:</p>

<pre>
setting alarm for 5 seconds...
alarm sounded...
</pre>
<hr>

<p><i>Copyright <a href="mailto:williamkempf@hotmail.com">William E. Kempf</a>
2001 all rights reserved.</i></p>

</body>
</html>
