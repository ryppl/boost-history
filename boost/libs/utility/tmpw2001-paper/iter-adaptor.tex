% Introduction/Motivation, etc. (Dave & Jeremy)

% iterator policies   (Dave)
%   default policies
%   type<> wrapper
% \cite{alexandrescu01:_modern_cpp_design}

% iterator_comparisons base (B&N) (Jeremy) \cite{Barton94}
%  workaround for g++ compiler bug with friend functions?

% operator_array_proxy (Dave)

% default pointer/reference type selection (Dave)

% wrapping non-iterators (count_iterator) (Jeremy)

% named template parameters (Jeremy)

% operator[] return type (Dave)

% the static asserts (Dave)

% generators (Jeremy)
%   type generators
%     tempting to try to use inheritance to replace
%        templated typedef, but that doesn't work.
%   object generators

% const/non-const interoperability (Dave)

% implementing const/mutable iterators with the same class
%   common mistake is to make the return type of operator*()
%     depend on whether the iterator object is const/non-const.
%     See the transform iterator in \cite{TMPW00:Weiser}

% custom iterators \cite{TMPW00:Baus}
%   generating iterators 
%     line iterator \cite{austern99:_gener_progr_stl}
%     constant iterator \cite{koenig97:_rumin_cpp}

% reverse iterator, front_insert_iterator, back_insert_iterator,
% insert_iterator \cite{iso98:_cpp_final_draft_standard}

% view iterators
%   \cite{TMPW00:Weiser}

% future work, container adaptors

\documentclass{netobjectdays}

\input{defs}

\begin{document}

\title{Generating Iterator Types}

\author{David Abrahams$^\dag$ and Jeremy Siek$^\ddag$ \\
\\
$^\dag$ Altra Broadband \\
\texttt{abrahams@altrabroadband.com}\\
\\
$^\ddag$ AT\&T Labs - Research \\
Florham Park, NJ 07932, USA \\
\texttt{jsiek@research.att.com}
}

\maketitle

\begin{abstract}
The iterator abstraction is one of the most commonly used in
programming and a considerable amount of time is spent building new
iterator types. However, implementing an iterator type that satisfies
the C++ Standard requirements for an iterator can be
challenging. There are a number of common mistakes that people make,
and there are necessary complexities in a C++ Standard conforming
implementation that one would rather not have to think about. In this
paper we present the iterator type generator from the Boost Iterator
Adaptor Library. This generator simplifies the creation of iterators;
it automates the error-prone and redundant parts of the implementation
and greatly simplifies the creation of iterator types that are
variations on other iterators (adapted iterators). The Iterator
Adaptor Library is an example of policy-based design and employs
template meta-programming. It uses an extremely flexible
implementation pattern which can be easily adapted to generate new
representatives of other abstract Concept families.

\end{abstract}


\section{Introduction}

%- defaults make it easy to adapt an iterator
%- extensions from base operations to other operations make it
%  easier to create iterators

Iterators play an important role in modern C++ programing. The
iterator is the central abstraction of the algorithms of the Standard
Library and creating new iterator types is a common task for C++
programmers. There are plenty of examples of iterators in the
literature: the
\code{line\_iterator}~\cite{austern99:_gener_progr_stl},
\code{Constant\_iterator}~\cite{koenig97:_rumin_cpp},
\code{std::istream\_iterator} and
\code{std::ostream\_iterator}~\cite{iso98:_cpp_final_draft_standard}
to name a few.

% right here you introduce the notion of iterator adaptor as a
% byproduct of saying something else. Should say: 

In addition, large number of iterator adaptors are now in use:
iterators that adapt some \code{Base} type, often itself an iterator,
to produce a new adapted iterator that conforms to the Conceptual
requirements of its iterator category.
%
% although this may not be the best place for it.
% I'm not sure if I changed your meaning by striking ``Also'' below:
%
Examples of iterator adaptors include
\code{std::reverse\_iterator}~\cite{iso98:_cpp_final_draft_standard},
\code{Checked\_iter}~\cite{stroustrup00:_cpp_prog_lang}, iterators of
the View Template Library~\cite{TMPW00:Weiser}, custom and smart
iterators~\cite{becker98:_smart_iteraters,TMPW00:Baus}, compound
iterators~\cite{alexandrescu98:_compound_iters}, and several iterators
from the MTL~\cite{siek99:_scitools}.

For an iterator to be usable with the Standard algorithms (and other
generic algorithms in third-party libraries), it must fulfill the
Standard requirements for an iterator type, which range from the few
requirements of an \stlconcept{InputIterator} to the many requirements
of a \stlconcept{RandomAccessIterator}. Implementing an iterator class
that meets these requirements is a tedious and error-prone task
despite the fact that most iterators are conceptually simple.

\subsection{Redundant Operators}

Perhaps the most obvious reason that implementing an iterator can
be tedious is that there are lots of redundant operators.  That is,
there are many operators that can be trivially defined in terms of
other operators. For example, the post-fix \code{operator++(int)} is often best
implemented in terms of prefix \code{operator++()} as shown below.

{\footnotesize
\begin{verbatim}
  class iter {
    // ...
    iter& operator++() { /* ... */ return *this; }
    iter operator++(int) { iter tmp(*this); ++*this; return tmp; }
  };
\end{verbatim}
}

For a full \stlconcept{RandomAccessIterator}, there are a total of 17
operators. 7 of the operators are fundamental while the other 10 are
redundant.

% 7 core operations
% 10 derived operations
 
% \code{operator->}
% \code{operator[]}
% \code{operator++(int)},
% \code{operator--(int)},
% \code{operator-=},
% \code{operator+},
% \code{operator!=},
% \code{operator>}, 
% \code{operator<=},
% \code{operator>=}


\subsection{Delegation of Operators and Type Definitions}

An iterator adaptor used to adapt an underlying iterator type often
changes the meaning of one or two operators while leaving the rest of
the operators defined in the same way as in the base iterator.  This
is typically implemented with delegating functions. The following
example shows an excerpt from an \code{indirect\_iterator} adaptor,
which takes an iterator over pointers or smart-pointers and creates an
iterator over the things pointed to. The \code{operator*} and
\code{operator->} are changed to dereference twice but all the other
operators stay the same. Writing all of the delegating functions for
the \code{indirect\_iterator} is a tedious job.

{\footnotesize
\begin{verbatim}
  template <class Base> class indirect_iterator {
  public:
    // Adapt the meaning of dereference
    reference operator*() const {
      return **iter; // dereference twice
    }
    // a ``redundant'' operator
    pointer operator->() const { return &*(*this); }
    // Delegating the implementation to the underlying iterator.
    indirect_iterator& operator++() { ++iter; return *this; }
    indirect_iterator& operator--() { --iter; return *this; }
    // delegate for all the other operators...
  private:
    Base iter;
  };
\end{verbatim}
}

% I think it would be better to use reverse_iterator as an example
% here, because it delegates more types than indirect_iterator does.
% But reverse_iterator doesn't delegate many operators... it changes
% the meaning of all of them. I wonder if there's a good example
% for both operators and typedefs.
A standard-conforming iterator must either come with a specialization
of \code{std::iterator\_\-traits<>} or it must define five nested
types: \code{value\_\-type}, \code{reference}, \code{pointer},
\code{difference\_\-type}, and \code{iterator\_\-category}. In the
example above, the last two would be delegated to the \code{Base}
iterator type. For many iterator adaptors, all five must be delegated.

\subsection{Iterator Implementation Complexities}

In addition to the tedious aspects of iterator implementation, there
are some complexities that trip up even the most experienced of
programmers. Ideally, an iterator implementer should not have to worry
about these details.

\subsubsection{Constant/Mutable Iterator Interactions}
\label{sec:constant-mutable-iterations}

Iterators over containers and other sequences of stored objects
usually come in pairs: a constant iterator type and a mutable iterator
type. It is desirable to allow the constant and mutable iterators to
interoperate through comparison and
subtraction. For example, suppose
that you are implementing a container type \code{C}. Then you ought to
define the following four versions of \code{operator==}, along with
corresponding versions of \code{operator!=}, and (for
\stlconcept{RandomAccessIterator}), operators \code{<}, \code{>},
\code{<=}, \code{>=}, and \code{-}.

{\footnotesize
\begin{verbatim}
  bool operator==(const C::iterator& x, const C::iterator& y);
  bool operator==(const C::const_iterator& x, const C::iterator& y);
  bool operator==(const C::iterator& x, const C::const_iterator& y);
  bool operator==(const C::const_iterator& x, const C::const_iterator& y);
\end{verbatim}
}

Implementers often forget to define the operators for constant/mutable
iterator interaction. In addition, iterator adaptors applied to these
kinds of iterators should propagate the ability to interact. For
example, a reverse iterator adaptor applied to \code{C::iterator} and
\code{C::const\_iterator} should result in mutable and constant reverse iterator types that
have the same ability to interact as the \code{Base} iterators do.

\subsubsection{Constant/Mutable Iterator Code Duplication}

% Is this section really worthwhile? It was confusing to read until I
% finally figured out what you were driving at. Who makes this conceptual mistake?
% It may not be worthwhile... though I've seen other grad students make
% this mistake, and the TMPW2000 VTL paper contains this mistake.

The implementations of the constant and mutable versions of an
iterator typically differ only in their \code{reference} and
\code{pointer} types. Therefore it is desirable to merge the two
iterator classes into a single class template with the
\code{reference} and \code{pointer} types as template parameters.

Some care must be taken when merging the constant and mutable
iterators.  One common mistake is that the programmer will confuse the
ideas of a \code{const} iterator object and a \emph{constant
iterator}. Such a misunderstanding can, for example, lead to an
iterator class template that has two versions of \code{operator*}, one
that is a \code{const} member function and one that is not.
 
{\footnotesize
\begin{verbatim}
  // this is a mistake
  reference operator*();
  const_reference operator*() const;
\end{verbatim}
}

There should be only one \code{operator*} that returns the
\code{reference} type and the member function should be \code{const} since
dereferencing an iterator does not change the state of the iterator
object itself (unlike \code{operator++}).

{\footnotesize
\begin{verbatim}
  // this is right
  reference operator*() const;
\end{verbatim}
}


\subsubsection{Input Iterators and \code{operator->}}
\label{sec:operator-arrow}

When creating an iterator adaptor that produces an
\stlconcept{InputIterator} some extra care must be taken in the
implementation of \code{operator->}. Remember that an input iterator
need not iterate over stored objects: it can manufacture new objects
when it is dereferenced as is the case for
\code{std::istream\_iterator}. If the iterator's \code{value\_type} is
of class type, we need to support \code{operator->}. Since the result
of using \code{operator->} must produce a true pointer even when
dereferencing the iterator does not yield a true reference type, we
need a \code{const} lvalue to which a pointer can be formed.  In
\S\ref{sec:operator-arrow} we show how this can be accomplished.


\subsubsection{The Return Type of \code{operator[]} for Adaptors}
\label{sec:operator-bracket}

The C++ Standard specifies that the return type of \code{operator[]}
of a random access iterator must be ``convertible to \code{T}''.  This
is a rather lenient requirement since \code{operator*} is required to
return the exact type \code{T\&}, and one might think that
\code{operator[]} and \code{operator*} should be same in this respect.
The C++ Standards Committee is currently debating as to whether the
random access iterator requirements should be changed.

To complicate the matter, returning \code{T\&} from \code{operator[]}
causes a run-time error in a certain class of situations. We will
discuss this in detail in \S\ref{sec:op-bracket-impl}.


% Automatic implementation of redundant operators
% Default delegation to adapted iterator

% complexities: 
%   const-non const interaction
%   const/mutable iterator distinction
%   input iterator \code{operator->}

\section{The Boost \code{iterator\_adaptor} Class Template}

The \code{iterator\_\-adaptor} class template simplifies the creation
of iterators by automating the implementation of redundant operators
and delegating functions and by taking care of the complex details of
iterator implementation.

The central design feature of \code{iterator\_\-adaptor} is the
parameterization by an iterator policies class. The policies class is
the primary communication mechanism between the iterator implementer
and the \code{iterator\_\-adaptor}; it specifies how the new iterator
type is different from the \code{Base} type. Unlike the policy classes
in~\cite{alexandrescu01:_modern_cpp_design}, we group several policies
into a single class as this proved more convenient for iterator
implementation.

\subsection{Iterator Policies Class}

In the following we show an example of implementing the policies class
for a transform iterator adaptor: an iterator that applies some
function to the value returned by dereferencing the base iterator.
The \code{transform\_\-iterator\_\-policies} class is templated on the
function object type, and a function object is stored as a data member
of the policies class.  In general, any extra state needed by the
iterator should be stored in the policies class. The policies class
inherits from \code{default\_\-iterator\_\-policies}, which delegates
all other operations to the base iterator. The main event of the
\code{transform\_\-iterator\_\-policies} class is the
\code{dereference()} member function, which simply applies the
function to the dereferenced value. The base iterator object is the
second argument to the \code{dereference()} function. The iterator
type is a template parameter to allow this policy class to be used
with any base iterator type.

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction>
  struct transform_iterator_policies : public default_iterator_policies
  {
    transform_iterator_policies() { }
    transform_iterator_policies(const AdaptableUnaryFunction& f)
      : m_f(f) { }
    template <class Reference, class BaseIterator>
    Reference dereference(type<Reference>, const BaseIterator& i) const
      { return m_f(*i); } // apply the function and return the result
    AdaptableUnaryFunction m_f;
  };
\end{verbatim}
}

The \code{type<Reference>} parameter is used to convey the appropriate
return type to the \code{dereference()} function. This method is
perhaps not the most elegant, but it was the most portable solution.

A policies class is required to have a default constructor because the
\code{iterator\_\-adaptor} has an instance of the policies class as a
data-member, and iterators are required to have default constructors
thereby requiring the policies class to also have a default
constructor.

With the policies class complete, the iterator implementer is almost
finished: and only eleven lines of code have been written. The code
consists of little more than the main idea of the transform iterator,
applying a function to the result of dereferencing the base iterator.
Next we will take a closer look at the
\code{default\_\-iterator\_\-policies} class and then in
\S\ref{sec:iter-type-generator} we will show how the transform
iterator type is constructed using \code{iterator\_\-adaptor}.


\subsection{Default Iterator Policies Class}

The \code{default\_\-iterator\_\-policies} class is the mechanism that
provides automatic delegation to the base iterator, freeing the
iterator implementer from the tedious task of writing delegating
functions. As above, an iterator policies class inherits from this
class and overrides any functions that should not be delegated. The
\code{default\_\-iterator\_\-policies} class also serves as an example
of the iterator policies interface. There are seven member functions
that correspond to the core iterator operations and an
\code{initialize()} function to provide a hook for customization of
iterator construction.

{\footnotesize
\begin{verbatim}
namespace boost {
  struct default_iterator_policies
  {
    template <class Base>
    void initialize(Base&) { }

    template <class Reference, class Base>
    Reference dereference(type<Reference>, const Base& x) const
      { return *x; }

    template <class Base>
    void increment(Base& x) { ++x; }

    template <class Base>
    void decrement(Base& x) { --x; }

    template <class Base, class DifferenceType>
    void advance(Base& x, DifferenceType n) { x += n; }

    template <class Difference, class Base1, class Base2>
    Difference distance(type<Difference>, const Base1& x,
                        const Base2& y) const { return y - x; }

    template <class Base1, class Base2>
    bool equal(const Base1& x, const Base2& y) const
      { return x == y; }

    template <class Base1, class Base2>
    bool less(const Base1& x, const Base2& y) const
      { return x < y; }
  };
} // namespace boost
\end{verbatim}
}


\subsection{Iterator Type Generator}
\label{sec:iter-type-generator}

With the policy class for the transform iterator complete, the next
step is to use the \code{iterator\_adaptor} template to construct the
actual iterator type. The best way to package the construction of the
transform iterator is to create a \emph{type generator}, which is a
class template whose sole purpose is to simplify the instantiation of
some other complicated class template. It fulfills the same need as a
templated typedef would if that were part of the {C++} language.  The
first template parameter to the generator is the type of the function
object and the second is the base iterator type.  The following code
shows the type generator for the transform iterator.

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction, class BaseIterator>
  struct transform_iterator_generator
  {
    typedef typename AdaptableUnaryFunction::result_type val_t;
  public:
    typedef iterator_adaptor<BaseIterator, 
      transform_iterator_policies<AdaptableUnaryFunction>,
      iterator_category_is<std::input_iterator_tag>, 
      value_type_is<val_t>, reference_is<val_t> > type;
  };
\end{verbatim}
}

We use \code{iterator\_adaptor} to define the transform iterator type
as a nested \code{typedef} inside the
\code{transform\_\-iterator\_\-generator} class. The first parameter
to \code{iterator\_\-adaptor} is the base iterator type and the second
is the policies class. The remaining parameters specify the iterators
associated types and are given as \emph{named parameters}.  We will
discuss this technique in \S\ref{sec:named-template-parameters}.

The \code{iterator\_category} is set to
\code{std::input\_\-iterator\_\-tag} because the function object may
return by-value. For the same reason the \code{reference} type (which
will be the return type of \code{operator*}) is set to \code{val\_t}
(and not \code{val\_t\&}). There are two parameters that are left out:
the \code{pointer} type defaults to \code{value\_type*} and the
\code{difference\_\-type} defaults to the \code{difference\_\-type} of
the base iterator.

It is tempting to create a \code{transform\_\-iterator} by deriving
from \code{iterator\_\-adaptor} (as an alternative to using the
generator).  This approach does not work, for example, because the
return type of \code{operator++} of an iterator is required to be the
same iterator type, but in this case the return type would be
\code{iterator\_\-adaptor} and not \code{transform\_\-iterator}.

%It
%would be possible to arrange for using inheritance by applying the
%Barton and Nackman trick, but we felt that design 

\subsection{Iterator Object Generator}
\label{sec:iter-object-generator}

The next question is how users of the transform iterator will
construct the iterator. The \code{iterator\_\-adaptor} class has the
following constructor.

{\footnotesize
\begin{verbatim}
  iterator_adaptor(const Base& it, const Policies& p = Policies())
\end{verbatim}
}

It would be cumbersome for the user to call this constructor since
they would have to separately construct a policies object and
then the iterator object. We therefore recommend that iterator
implementers create an \emph{object generator} function for their
iterator. The following is the generator function for the transform
iterator adaptor.

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction, class Iterator>
  typename transform_iterator_generator<AdaptableUnaryFunction,
      Iterator>::type
  make_transform_iterator(Iterator base,
      const AdaptableUnaryFunction& f = AdaptableUnaryFunction())
  {
    typedef typename transform_iterator_generator<AdaptableUnaryFunction,
      Iterator>::type result_t;
    transform_iterator_policies<AdaptableUnaryFunction> policies(f);
    return result_t(base, policies);
  }
\end{verbatim}
}

An alternative solution to using object generating functions would be
to have a constructor in \code{iterator\_adaptor} that takes arbitrary
arguments (the constructor would be templated). The arguments would
then be passed as a heterogeneous value list~\cite{TMPW00:Eisenecker}
to the policies class. This would remove the need for object
generating functions but would increase the complexity of the
implementation and the compile time. For a low-level component such as
an iterator adaptor we felt that simplicity and compile-time were more
important than implementer convenience.

\subsection{Example Use of the Transform Iterator Adaptor}

The following example shows how a transform iterator can be used to
iterate through a range of numbers, multiplying each of them by 2 and
printing the result to standard output.

{\footnotesize
\begin{verbatim}
  #include <functional>
  #include <algorithm>
  #include <iostream>
  #include <boost/iterator_adaptors.hpp>
  int main(int, char*[])
  {
    int x[] = { 1, 2, 3, 4, 5, 6, 7, 8 };
    const int N = sizeof(x)/sizeof(int);
    std::cout << "multiplying the array by 2:" << std::endl;
    std::copy(boost::make_transform_iterator(x, 
                std::bind1st(std::multiplies<int>(), 2)),
              boost::make_transform_iterator(x + N, 
                std::bind1st(std::multiplies<int>(), 2)),
              std::ostream_iterator<int>(std::cout, " "));
    std::cout << std::endl;
    return 0;
  }
\end{verbatim}
}

\noindent This output is: 
{\footnotesize
\begin{verbatim}
2 4 6 8 10 12 14 16
\end{verbatim}
}


\section{The Implementation of \code{iterator\_adaptor}}

The outline for the implementation of the \code{iterator\_adaptor}
class is as follows. In the next few sections we will discuss aspects
of the implementation in more depth, including how the problems
discussed in the introduction were solved.

{\footnotesize
\begin{verbatim}
namespace boost {
  template <class Base, class Policies, 
	    class Param1 = default_argument,
	    class Param2 = default_argument,
	    class Param3 = default_argument,
	    class Param4 = default_argument,
	    class Param5 = default_argument>
  struct iterator_adaptor {
    // Deduce iterator associated types (value_type, etc.) from the
    //   named template parameters, and resolve any defaults.
  public:
    // Core operators, delegate to policies class.
    // Redundant operators, implemented in terms of the core operators.
  private:
    compressed_pair<Base, Policies> m_iter_p;
    // If the policies class is empty, apply the empty-base class
    // optimization to conserve space. The base is ``first'' and
    // the policies are ``second''.
    Policies& policies() { return m_iter_p.second(); }
    Base& iter() { return m_iter_p.first(); }
    // and similarly for const...
  };
  // Core binary operators.
  // Redundant binary operators.
} // namespace boost
\end{verbatim}
}

\subsection{Deducing the Associates Types}

Iterators have five associated types: \code{value\_\-type},
\code{reference}, \code{pointer}, \code{iterator\_\-category}, and
\code{difference\_\-type}. Each of these types must either be supplied
by the user, using the named parameter technique described below in
\S\ref{sec:named-template-parameters}, or a default must be computed
for the type.

\subsubsection{Defaults for the Associated Types}

The defaults for the \code{value\_type}, \code{iterator\_\-category},
and \code{difference\_\-type} are straightforward: they are the
respective types from the base iterator. So, for example, the default
for the \code{value\_type} is
\code{std::iterator\_\-traits\-<Base>::\-value\_type}.

Computing the defaults for \code{reference} and \code{pointer} is a
bit more complicated. If a \code{value\_type} is specified by the
user, then \code{value\_type\&} and \code{value\_type*} are used for
the \code{reference} and \code{pointer} type. Otherwise, if the
default was used for \code{value\_type} then the \code{reference} and
\code{pointer} types are taken from the base iterator using
\code{std::iterator\_traits}.
% Dave, is the above right? I'm not sure...


\subsubsection{Named Template Parameters}
\label{sec:named-template-parameters}

Since each of the parameters for the associated types has a default
user may specify zero or more of them. One difficulty with {C++}
templates is that if a default is used for a parameter then all the
following parameters must also be default. When there are a large
number of parameters this becomes inconvenient.

A solution to this problem is the idea of named parameters.  Instead
of matching arguments to parameters based on order, the assignment of
arguments to parameters is made explicitly by name (so the ordering no
longer matters). The way this works for the \code{iterator\_\-adaptor}
class is that there is a wrapper class for each parameter, for
example:

{\footnotesize
\begin{verbatim} 
  template <class Value> struct value_type_is {
    typedef value_type_tag tag;
    typedef Value type;
  };
\end{verbatim} 
}

Instead of passing the argument \code{Value} directly to
\code{iterator\_\-adaptor} the user passes
\code{value\_type\_is<Value>}. The \code{iterator\_\-adaptor} has
five arguments for the associated types, each of which could be used
to specify any of the actual parameters. The
\code{iterator\_\-adaptor} must deduce which argument is for which
parameter based on the \code{tag} inside the wrapper.

First we take all of the parameters and place them in a
lisp-style list, using \code{std::pair} for \code{cons}. Each
parameter wrapper has a key/value pair (the \code{tag} and \code{type}
respectively), so we can treat this as an associative list.

{\footnotesize
\begin{verbatim} 
  typedef pair<Param1, pair<Param2, pair<Param3, pair<Param4,
	    pair<Param5, list_end_type> > > > > NamedParamList;
\end{verbatim} 
}

\noindent For each parameter we perform a look-up in the associative
list using a template meta-program utility class named
\code{find\_param}.

{\footnotesize
\begin{verbatim} 
  template <class AssociativeList, class Key>
  struct find_param {
    typedef ... type;
  };
\end{verbatim} 
}

\noindent So, for example, to retrieve the argument for the
\code{value\_type} we write the following:

{\footnotesize
\begin{verbatim} 
  typedef typename find_param<NamedParamList, value_type_tag>::type Value;
\end{verbatim} 
}

The result of this look-up will either be the argument specified by the
user, or if there is none, the \code{default\_argument} type. If it is
the default, then a further step is taken to resolve what the default
should be for the parameter. The defaults for some of the parameters
depend on other parameters, so the order in which defaults are
resolved is tailored to respect these dependencies.


\subsection{Core Operators}

The core operators of the \code{iterator\_adaptor} are implemented by
delegating the work to the policies class. Each core operator invokes
the appropriate policy function and passes in the base
iterator. Sometimes extra type information is also passed in, as is
the case with the \code{reference} type in the implementation of
\code{operator*}.

{\footnotesize
\begin{verbatim}
  reference operator*() const {
    return policies().dereference(type<reference>(), iter());
  }
\end{verbatim}
}

The binary operators of the iterator are implemented as free functions
(not member functions) to allow both the left and right hand operands
to be treated symmetrically.  We use separate template parameters for
the two \code{iterator\_\-adaptor} arguments. This allows a single
operator to implement all of the combinations of constant/mutable
iterator interactions, avoiding the combinatorial explosion discussed
in \S\ref{sec:constant-mutable-iterations}. Note that we only use a
single \code{Policies} template parameter: this restricts iterator
interaction to those iterators with the same policies class.  This is
not restrictive as it should be, however the only real disadvantage to
not being restrictive enough is in the kind of error message the user
will see when misusing two unrelated iterators. Instead of an
``operator not found'' message they will see an error message from
inside the iterator adaptor.

{\footnotesize
\begin{verbatim}
  template <class Iter1, class Iter2, class Policies, class V1, class V2,
      class R1, class R2, class P1, class P2, class C1, class C2, 
      class D1, class D2>
  bool operator<(
    const iterator_adaptor<Iter1,Policies,V1,R1,P1,C1,D1>& x,
    const iterator_adaptor<Iter2,Policies,V2,R2,P2,C2,D2>& y)
  {
    return x.policies().less(x.iter(), y.iter());
  }
\end{verbatim}
}


\subsection{Redundant Operators}

Most of the redundant operators are implemented in a straightforward
way based on the core operators. For example, the \code{operator+} is
implemented in terms of \code{operator+=}.

{\footnotesize
\begin{verbatim}
template <class B, class P, class V, class R, class Ptr,
    class C, class D, class Distance>
iterator_adaptor<B,P,V,R,Ptr,C,D>
operator+(iterator_adaptor<B,P,V,R,Ptr,C,D> p, Distance x)
{
  return p += x;
}
\end{verbatim}
}

The implementation of \code{operator->} and \code{operator[]}, as
alluded to in \S\ref{sec:operator-arrow} and
\S\ref{sec:operator-bracket}, are not straightforward. We discuss them
in the following two sections.


\subsubsection{Implementing \code{operator->} for Input Iterators}
\label{sec:operator-arrow}

As introduced in \S\ref{sec:operator-arrow}, it is difficult to
implement \code{operator->} for input iterators because there may not
be an lvalue from which to form a pointer.

Fortunately, the standard makes a workaround possible: section
13.3.1.2 paragraph 8 describes a seemingly quirky rule that the
\code{->} operator will be applied to the \emph{result} of any call to
\code{operator->}. This is a convenient way to describe the semantics
of ordinary \code{operator->}, which returns a pointer: it just uses
the pointer to perform the usual member dereferencing. It also turns
out to be what we need to make a conforming
\stlconcept{InputIterator}. By making the return type of
\code{operator->} a proxy containing an instance of the iterator's
\code{value\_type}, we can eventually form a \code{const} pointer to
the returned temporary:

{\footnotesize
\begin{verbatim}
  template <class T>
  struct operator_arrow_proxy
  {
    operator_arrow_proxy(const T& x) : m_value(x) {}
    const T* operator->() const { return &m_value; }
    T m_value;
  };
\end{verbatim}
}

\noindent The iterator adaptor library uses a small meta-program to
select the appropriate type for the result of an iterator's
\code{operator->}:

{\footnotesize
\begin{verbatim}
  template <class Category, class Value, class Pointer>
  struct operator_arrow_result_generator
  {
    // Is it an input iterator, or something more?
    static bool const is_input_iter
      = is_convertible<Category*, std::input_iterator_tag*>::value
         && !is_convertible<Category*,std::forward_iterator_tag*>::value;

    typedef typename type_if<is_input_iter,
      operator_arrow_proxy<Value>, /*else*/ Pointer>::type type;
  };
\end{verbatim}
}

The Boost Type Traits library is used to check whether the iterator's
category is no more refined than \stlconcept{InputIterator}. If so,
the appropriate \code{operator\_arrow\_proxy} is selected.
Convertibility is used as a criterion to allow for user-defined
iterator categories derived from the standard ones.


\subsubsection{Implementation of \code{operator[]}}
\label{sec:op-bracket-impl}

The implementation of \code{operator[]} would be trivial except for
the issue surrounding what the return type should be.  As mentioned in
\S\ref{sec:operator-bracket}, it would be dangerous to make the
\code{iterator\_adaptor} always return a reference for
\code{operator[]} for there are certain situations in which this can
cause run-time errors.

Suppose the adapted iterator is reading in elements from a file and
caching each element as a data member of the iterator.

{\footnotesize
\begin{verbatim}
class file_iter {
  T x;
  int pos;
public:
  file_iter(int pos = 0) { x = read_from_file(pos); }
  T& operator*() const { return x; }
  file_iter operator+(int n) const { return file_iter(pos + n); }
  file_iter& operator++() { x = read_from_file(++pos); return *this; }
  // ...
};
\end{verbatim}
}

\noindent The \code{operator*} of this iterator returns a reference to
the data member. Now consider what happens inside the
\code{operator[]} of the adaptor:

{\footnotesize
\begin{verbatim}
template <class Iterator> class iter_adaptor {
  Iterator iter;
public:
  reference operator[](difference_type n) const {
    return *(iter + n);
  }
 // ...
};
\end{verbatim}
}

\noindent The iterator addition creates a temporary iterator and the
dereference returns a reference to a data member of this
temporary. The result is a dangling reference being returned from
\code{operator[]}.


The \code{iterator\_adaptor} takes the safe route and returns the
result by-value. This meets the random access iterator requirements of
the Standard, which only says that the return type must be
``convertible to T'',

{\footnotesize
\begin{verbatim}
  value_type operator[](difference_type n) const
    { return *(*this + n); }
\end{verbatim}
}

Under the current {C++} Standard, when using a random access iterator
in a generic algorithm, you can not use \code{operator[]} for
assignment (on the left hand side) but instead must write \code{*(i +
n) = x}.

Alternatively, it would be nice to return by-reference for some
iterators and by-value for others. However, the current
\code{iterator\_\-traits} does not provide enough information make the
choice. In addition, the lack of consistency between \code{operator[]}
and \code{operator*} will be surprising to people. Preferably an
iterator would either return by-value for both \code{operator*} and
\code{operator[]} or return by-reference for both.  The proposal
in~\cite{siek01:_improved_iter_cat} would solves these problems, but
of course that will take some time to gain acceptance.


\section{Conclusion}

Constructing iterators and iterator adaptors is a common task for
modern C++ programming. Despite the conceptual simplicity of most
iterators, implementing {C++} Standard conforming iterators requires a
non-trivial amount of code: some of which is challenging to get right
and a lot of which is tedious. The \code{iterator\_adaptor} class that
we present in this paper solves this problem by providing a mechanism
by which the user provides a minimal specification (by way of the
policies class) for the iterator, and then the
\code{iterator\_\-adaptor} takes care of most of the implementation
details.

Taking a step back, the design approach was to create a canonical
implementation of a concept (iterator) and then delegate the core
implementation issues to a policies class. This approach can be
applied in situations where there is large family of components that
share the same interface. For example, we plan on applying this design
approach to containers and algebraic types.


\bibliographystyle{abbrv}
\bibliography{refs,tmpw00}

\end{document}
% LocalWords:  Iterator Siek Altra Broadband Florham iterator Adaptor iterators
% LocalWords:  adaptors istream ostream iter MTL InputIterator adaptor const
% LocalWords:  RandomAccessIterator dereference interoperate Implementers tmpw
% LocalWords:  dereferencing adaptor's lvalues iterator's instantiation typedef
% LocalWords:  AdaptableUnaryFunction templated dereferenced lvalue val param
% LocalWords:  parameterization implementers combinatorial InputIterators
% LocalWords:  Convertibility
