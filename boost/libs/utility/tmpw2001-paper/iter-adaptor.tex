% Introduction/Motivation, etc. (Dave & Jeremy)

% iterator policies   (Dave)
%   default policies
%   type<> wrapper
% \cite{alexandrescu01:_modern_cpp_design}

% iterator_comparisons base (B&N) (Jeremy) \cite{Barton94}
%  workaround for g++ compiler bug with friend functions?

% operator_array_proxy (Dave)

% default pointer/reference type selection (Dave)

% wrapping non-iterators (count_iterator) (Jeremy)

% named template parameters (Jeremy)

% operator[] return type (Dave)

% the static asserts (Dave)

% generators (Jeremy)
%   type generators
%     tempting to try to use inheritance to replace
%        templated typedef, but that doesn't work.
%   object generators

% const/non-const interoperability (Dave)

% implementing const/mutable iterators with the same class
%   common mistake is to make the return type of operator*()
%     depend on whether the iterator object is const/non-const.
%     See the transform iterator in \cite{TMPW00:Weiser}

% custom iterators \cite{TMPW00:Baus}
%   generating iterators 
%     line iterator \cite{austern99:_gener_progr_stl}
%     constant iterator \cite{koenig97:_rumin_cpp}

% reverse iterator, front_insert_iterator, back_insert_iterator,
% insert_iterator \cite{iso98:_cpp_final_draft_standard}

% view iterators
%   \cite{TMPW00:Weiser}

% future work, container adaptors

\documentclass{netobjectdays}

\input{defs}

\begin{document}

\title{Generating Iterator Types}

\author{David Abrahams$^\dag$ and Jeremy Siek$^\ddag$ \\
\\
$^\dag$ Altra Broadband \\
\texttt{abrahams@altrabroadband.com}\\
\\
$^\ddag$ AT\&T Labs - Research \\
Florham Park, NJ 07932, USA \\
\texttt{jsiek@research.att.com}
}

\maketitle


\begin{abstract}
The iterator abstraction is one of the most commonly used in
programming and a considerable amount of time is spent building new
iterator types. However, implementing an iterator type that satisfies
the C++ Standard requirements for an iterator can be
challenging. There are a number of common mistakes that people make,
and there are necessary complexities in a C++ Standard conforming
implementation that one would rather not have to think about. In this
paper we present the iterator type generator from the Boost Iterator
Adaptor Library. This generator simplifies the creation of iterators;
it automates the error-prone and redundant parts of the implementation
and greatly simplifies the creation of iterator types that are
variations on other iterators (adapted iterators). The Iterator
Adaptor Library employs template meta-programming and is an example of
policy-based design. It uses an extremeley flexible implementation
pattern which can be easily adapted to generate new representatives of
other abstract Concept families.

\end{abstract}


\section{Introduction}

%- defaults make it easy to adapt an iterator
%- extensions from base operations to other operations make it
%  easier to create iterators

Iterators play an important role in modern C++ programing. The
iterator is the central abstraction of the algorithms of the Standard
Library and creating new iterator types and adapting old ones are
common tasks for C++ programmers. There are plenty of examples of
custom-made iterators in the literature: the
\code{line\_iterator}~\cite{austern99:_gener_progr_stl},
\code{Constant\_iterator}~\cite{koenig97:_rumin_cpp}, 
\code{std::istream\_iterator} and
\code{std::ostream\_iterator}~\cite{iso98:_cpp_final_draft_standard}n to
name a few. 

% right here you introduce the notion of iterator adaptor as a
% byproduct of saying something else. Should say: 

An iterator adaptor's job is to adapt some \code{Base} type, often
itself an iterator, to produce a new adapted iterator that conforms to
the Conceptual requirements of its iterator category.

% although this may not be the best place for it.
% I'm not sure if I changed your meaning by striking ``Also'' below:

A growing number of generic iterator adaptors are available:
\code{std::reverse\_iterator}~\cite{iso98:_cpp_final_draft_standard},
\code{Checked\_iter}~\cite{stroustrup00:_cpp_prog_lang}, iterators of
the View Template Library~\cite{TMPW00:Weiser}, custom and smart
iterators~\cite{becker98:_smart_iteraters,TMPW00:Baus}, compound
iterators~\cite{alexandrescu98:_compound_iters}, and several iterators
in the MTL~\cite{siek99:_scitools}.

For an iterator to be usable with the Standard algorithms (and other
generic algorithms in third-party libraries), it must fulfill the
Standard requirements for an iterator type, which range from the few
requirements of an \stlconcept{InputIterator} to the many requirements
of a \stlconcept{RandomAccessIterator}. Implementing an iterator class
that meets these requirements is a tedious and error-prone task
despite the fact that most iterators are conceptually simple.

\subsection{Redundant Operators}

Perhaps the most obvious reason that implementing an iterator can
be tedious is that there are lots of redundant operators.  That is,
there are many operators that can be trivially defined in terms of
other operators. For example, the postfix \code{operator++(int)} is often best
implemented in terms of prefix \code{operator++()} as shown below.

{\footnotesize
\begin{verbatim}
  class iter {
    // ...
    iter& operator++() { /* ... */ return *this; }
    iter operator++(int) { iter tmp(*this); ++*this; return tmp; }
  };
\end{verbatim}
}

For a full \stlconcept{RandomAccessIterator}, there are a total of 17
operators. 7 of the operators are fundamental while the other 10 are
redundant.

% 7 core operations
% 10 derived operations
 
% \code{operator->}
% \code{operator[]}
% \code{operator++(int)},
% \code{operator--(int)},
% \code{operator-=},
% \code{operator+},
% \code{operator!=},
% \code{operator>}, 
% \code{operator<=},
% \code{operator>=}


\subsection{Delegation of Operators and Type Definitions}

An iterator adaptor used to adapt an underlying iterator type often
changes the meaning of one or two operators while leaving the rest of
the operators defined in the same way as in the base iterator.  This
is typically implemented with delegating functions. The following
example shows an excerpt from an \code{indirect\_iterator} adaptor,
which takes an iterator over pointers or smart-pointers and creates an
iterator over the things pointed to. The \code{operator*} and
\code{operator->} are changed to dereference twice but all the other
operators stay the same. Writing all of the delegating functions for
the \code{indirect\_iterator} is a tedious job.

{\footnotesize
\begin{verbatim}
  template <class Iterator> class indirect_iterator {
  public:
    // Adapt the meaning of dereference
    reference operator*() const {
      return **iter; // dereference twice
    }
    pointer operator->() const {
      return &**iter; // dereference twice
    }
    // Delegating the implementation to the underlying iterator.
    indirect_iterator& operator++() { ++iter; return *this; }
    indirect_iterator& operator--() { --iter; return *this; }
    // delegate for all the other operators...
  private:
    Iterator iter;
  };
\end{verbatim}
}

% I think it would be better to use reverse_iterator as an example
% here, because it delegates more types than indirect_iterator does.
In addition, a standard-conforming iterator must either come with a
specialization of \code{std::iterator\_traits<>} or it must define
five nested types: \code{value\_type}, \code{reference},
\code{pointer}, \code{difference\_type}, and
\code{iterator\_category}. In the example above, the last two would be
delegated to the \code{Base} iterator type. For many iterator
adaptors, all five must be delegated.

\subsection{Iterator Complexities}

In addition to the tedious aspects of iterator implementation, there
are some complexities that trip up even the most experienced of
programmers.

\subsubsection{Constant/Mutable Iterator Interactions}

Iterators over containers and other sequences of stored objects
usually come in pairs: a constant iterator type and a mutable iterator
type. It is desirable to allow the constant and mutable iterators to
interoperate through comparison and
subtraction. For example, suppose
that you are implementing a container type \code{C}. Then you ought to
define the following four version of \code{operator==}, along with
corresponding versions of \code{operator!=}, and (for
RandomAccessIterators), operators \code{<}, \code{>},
\code{<=}, \code{>=}, and \code{-}.


{\footnotesize
\begin{verbatim}
  bool operator==(const C::iterator& x, const C::iterator& y);
  bool operator==(const C::const_iterator& x, const C::iterator& y);
  bool operator==(const C::iterator& x, const C::const_iterator& y);
  bool operator==(const C::const_iterator& x, const C::const_iterator& y);
\end{verbatim}
}

Implementers often forget to define the operators for constant/mutable
iterator interaction. In addition, iterator adaptors applied to these
kinds of iterators should propagate the ability to interact. For
example, a reverse iterator adaptor applied to \code{C::iterator} and
\code{C::const\_iterator} should result in mutable and constant reverse iterator types that
have the same ability to interact as the \code{Base} iterators do.

\subsubsection{Constant/Mutable Iterator Implementation}

% Is this section really worthwhile? It was confusing to read until I
% finally figured out what you were driving at. Who makes this conceptual mistake?
Another subtlety in the implementation of iterators is how the the
distinction between constant and mutable iterators affects the
implementation. It is obvious that a constant iterator should have
\code{const} \code{reference} and \code{pointer} types, while a mutable iterator should have a
non-\code{const} \code{reference} and \code{pointer}, though in other regards the constant and
mutable versions of an iterator are the same. It is therefore
desirable to implement both versions of the iterator with a the same
code. It is possible to do this, however some care must be taken.

One common mistake is that the programmer will confuse the ideas of
a \code{const} iterator object and a \emph{constant iterator}. Such a
misunderstanding can, for example, lead to a single iterator class that has
two versions of \code{operator*}, one that is a \code{const} member function
and one that is not.
 
{\footnotesize
\begin{verbatim}
  // this is a mistake
  reference operator*();
  const_reference operator*() const;
\end{verbatim}
}

The right way to implement both a constant and mutable iterators using
the same code is to use a class template parameterized on the
\code{reference} type. To create the constant iterator a \code{const}
reference would be used as the template argument and to create the
mutable iterator a non-\code{const} reference would be used instead. 
There should be only one \code{operator*} that returns the
\code{reference} type and the member function should be \code{const} since
dereferencing an iterator does not change the state of the iterator
object itself (unlike \code{operator++}).

{\footnotesize
\begin{verbatim}
  // this is right
  reference operator*() const;
\end{verbatim}
}


\subsubsection{Input Iterators and \code{operator->}}

When creating an iterator adaptor that produces an
\stlconcept{InputIterator} some extra care must be
taken in the implementation of \code{operator->}. Remember that an
input iterator need not iterate over stored objects: it
can manufacture new objects when it is dereferenced as is the case for
\code{std::istream\_iterator}. If the iterator's \code{value\_type} is
of class type, we need to support \code{operator->}. Since the result
of using \code{operator->} must produce a true pointer even when
dereferencing the iterator does not yeild a true reference type, we
need a \code{const} lvalue to which a pointer can be formed.

Fortunately, the standard gives us a way: section 13.3.1.2 paragraph 8
describes a seemingly quirky rule that the \code{->} operator will be
applied to the \emph{result} of any call to \code{operator->}. This is
a convenient way to describe the semantics of ordinary
\code{operator->}, which returns a pointer: it just uses the pointer
to perform the usual member dereferencing. It also turns out to be
what we need to make conforming \stlconcept{InputIterators}. By making
the return type of \code{operator->} a proxy containing an instance of
the iterator's \code{value\_type}, we can eventually form a
\code{const} pointer to the returned temporary:

{\footnotesize
\begin{verbatim}
  template <class T>
  struct operator_arrow_proxy
  {
      operator_arrow_proxy(const T& x) : m_value(x) {}
      const T* operator->() const { return &m_value; }
      T m_value;
  };
\end{verbatim}
}

The iterator adaptor library uses a small meta-program to select the
appropriate type for the result of an iterator's \code{operator->}:

{\footnotesize
\begin{verbatim}
  template <class Category, class Value, class Pointer>
  struct operator_arrow_result_generator
  {
    // Is it an input iterator, or something more?
    static bool const is_input_iter
      = is_convertible<Category*,std::input_iterator_tag*>::value
         && !is_convertible<Category*,std::forward_iterator_tag*>::value;

    typedef typename type_if<is_input_iter,
        operator_arrow_proxy<Value>, /*else*/ Pointer>::type type;
  };
\end{verbatim}
}

The boost Type Traits library is used to check whether the iterator's
category is no more refined than \stlconcept{InputIterator}. If so,
the appropriate \code{operator\_arrow\_proxy} is selected.
Convertibility is used as a criterion to allow for user-defined
iterator categories derived from the standard ones.

\subsubsection{The Return Type of \code{operator[]} for Adaptors}

The C++ Standard specifies that the return type of \code{operator[]}
of a random access iterator must be ``convertible to \code{T}''.  This
is a rather lenient requirement since \code{operator*} is required to
return the exact type \code{T\&}, and one might think that
\code{operator[]} and \code{operator*} should be same in this respect.
The C++ Standards Committee is currently debating as to whether the
random access iterator requirements should be changed.

To complicate the matter, returning \code{T\&} from \code{operator[]}
causes a run-time error in a certain class of situations.  Suppose the
adapted iterator is reading in elements from a file and caching each
element as a data member of the iterator.  

{\footnotesize
\begin{verbatim}
class file_iter {
  T x;
  int pos;
public:
  file_iter(int pos = 0) { x = read_from_file(pos); }
  T& operator*() const { return x; }
  file_iter operator+(int n) const { return file_iter(pos + n); }
  file_iter& operator++() { x = read_from_file(++pos); return *this; }
  // ...
};
\end{verbatim}
}

\noindent The \code{operator*} of this iterator returns a reference to
the data member. Now consider what happens inside the
\code{operator[]} of the adaptor:

{\footnotesize
\begin{verbatim}
template <class Iterator> class iter_adaptor {
  Iterator iter;
public:
  reference operator[](difference_type n) const {
    return *(iter + n);
  }
 // ...
};
\end{verbatim}
}

\noindent The iterator addition creates a temporary iterator and the
dereference returns a reference to a data member of this
temporary. The result is a dangling reference being returned from
\code{operator[]}.

Under the current state of affairs returning by-value from the
\code{operator[]} of an adaptor is the safer and therefore better
approach.  Ideally the return type of an iterator adaptor's
\code{operator[]} would be varied depending on the characteristics of
the underlying iterator, and there would be a standard iterator
category for describing random access iterators that do not return
lvalues such as proposed in~\cite{siek01:_improved_iter_cat}.

% Automatic implementation of redundant operators
% Default delegation to adapted iterator

% complexities: 
%   const-non const interaction
%   const/mutable iterator distinction
%   input iterator \code{operator->}

\section{The Boost \code{iterator\_adaptor}}



\subsection{Example}

It is often useful to automatically apply some function to the value
returned by dereferencing an iterator. The transform iterator of the
Iterator Adaptor Library makes it easy to create an iterator adaptor
which does just that. Here we will show how easy it is to implement
the transform iterator using the
\code{iterator\_adaptor} template.

We want to be able to adapt a range of iterators and functions, so the
policies class will have a template parameter for the function type
and it will have a data member of that type. We know that the function
takes one argument and that we'll need to be able to deduce the
\code{result\_type} of the function so we can use it for the adapted
iterator's \code{value\_type}. \stlconcept{AdaptableUnaryFunction} is
the \textsf{concept}\cite{austern99:_gener_progr_stl} that fulfills
those requirements.

To implement a transform iterator we will only change one of the base
iterator's behaviors, so the \code{transform\_iterator\_policies}
class can inherit the rest from \code{default\_iterator\_policies}. We
will define the \code{dereference()} member function, which is used
to implement \code{operator*()} of the adapted iterator. The
implementation will dereference the base iterator and apply the
function object. The \code{type<Reference>} parameter is used
to convey the appropriate return type. The complete code for
\code{transform\_iterator\_policies} is:

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction>
  struct transform_iterator_policies : public default_iterator_policies
  {
    transform_iterator_policies() { }
    transform_iterator_policies(const AdaptableUnaryFunction& f)
      : m_f(f) { }
    template <class Reference, class BaseIterator>
    Reference dereference(type<Reference>, const BaseIterator& i) const
      { return m_f(*i); }
    AdaptableUnaryFunction m_f;
  };
\end{verbatim}
}

The next step is to use the \code{iterator\_adaptor} template to
construct the transform iterator type. The nicest way to package the
construction of the transform iterator is to create a \emph{type
generator}, which is a class template whose sole purpose is to
simplify the instantiation of some other complicated class
template. It fulfills the same need as a templated typedef would if
that were part of the {C++} language.

The first template parameter to the generator will be the type of the
function object and the second will be the base iterator type. We use
\code{iterator\_adaptor} to define the transform iterator type as a
nested \code{typedef} inside the
\code{transform\_iterator\_generator} class.  Because the function may
return by-value, we must limit the \code{iterator\_category} to 
\stlconcept{InputIterator}, and the iterator's \code{reference} type cannot be a
true reference (the standard allows this for input iterators), so in
this case we can use few of \code{iterator\_adaptor}'s default template
arguments.

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction, class Iterator>
  struct transform_iterator_generator
  {
      typedef typename AdaptableUnaryFunction::result_type value_type;
  public:
      typedef iterator_adaptor<Iterator, 
          transform_iterator_policies<AdaptableUnaryFunction>,
          value_type, value_type, value_type*, std::input_iterator_tag> type;
  };
\end{verbatim}
}

As a finishing touch, we will create an 
\textsf{object generator} for the transform iterator, which
 is a function that makes it more convenient to create objects of some
class template.

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction, class Iterator>
  typename transform_iterator_generator<AdaptableUnaryFunction,
      Iterator>::type
  make_transform_iterator(Iterator base,
      const AdaptableUnaryFunction& f = AdaptableUnaryFunction())
  {
      typedef typename transform_iterator_generator<AdaptableUnaryFunction,
        Iterator>::type result_t;
      return result_t(base, f);
  }
\end{verbatim}
}

Here is an example that shows how to use a transform iterator to
iterate through a range of numbers, multiplying each of them by 2
and printing the result to standard output.

{\footnotesize
\begin{verbatim}
  #include <functional>
  #include <algorithm>
  #include <iostream>
  #include <boost/iterator_adaptors.hpp>

  int main(int, char*[])
  {
    int x[] = { 1, 2, 3, 4, 5, 6, 7, 8 };
    const int N = sizeof(x)/sizeof(int);
    std::cout << "multiplying the array by 2:" << std::endl;
    std::copy(boost::make_transform_iterator(x, 
                std::bind1st(std::multiplies<int>(), 2)),
              boost::make_transform_iterator(x + N, 
                std::bind1st(std::multiplies<int>(), 2)),
              std::ostream_iterator<int>(std::cout, " "));
    std::cout << std::endl;
    return 0;
  }
\end{verbatim}
}

\noindent This output is: 
{\footnotesize
\begin{verbatim}
2 4 6 8 10 12 14 16
\end{verbatim}
}

\bibliographystyle{abbrv}
\bibliography{refs,tmpw00}

\end{document}
% LocalWords:  Iterator Siek Altra Broadband Florham iterator Adaptor iterators
% LocalWords:  adaptors istream ostream iter MTL InputIterator adaptor const
% LocalWords:  RandomAccessIterator dereference interoperate Implementers tmpw
% LocalWords:  dereferencing adaptor's lvalues iterator's instantiation typedef
% LocalWords:  AdaptableUnaryFunction templated
