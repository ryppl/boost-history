\documentclass{netobjectdays}

\newcommand{\Cpp}{C\kern-0.05em\texttt{+\kern-0.03em+}}
\newcommand{\iteratoradaptor}{\code{iterator\_\-adaptor}}
\newcommand{\valuetype}{\code{value\_\-type}}
\newcommand{\differencetype}{\code{difference\_\-type}}
\newcommand{\iteratorcategory}{\code{iterator\_\-category}}
\newcommand{\iteratortraits}{\code{iterator\_\-traits}}
\newcommand{\constiterator}{\code{const\_\-iterator}}
\newcommand{\reverseiterator}{\code{reverse\_\-iterator}}

\input{defs}

\begin{document}

\title{Policy Adaptors and the Boost Iterator Adaptor Library}

\author{David Abrahams$^\dag$ and Jeremy Siek$^\ddag$\thanks{This work
was partially supported by NSF grant ACI-9982205.} \\
\\
$^\dag$ Altra Broadband \\
\texttt{abrahams@altrabroadband.com}\\
\\
$^\ddag$ AT\&T Labs - Research \\
Florham Park, NJ 07932, USA \\
\texttt{jsiek@research.att.com}
}

\maketitle

 \begin{abstract} $\!$The iterator abstraction is one of the most
commonly used in programming, but implementing an iterator type can be
challenging. The requirements for a standard-conforming iterator are
at once tedious and subtle: tedious because much of an iterator's rich
interface is ``boilerplate'' surrounding a few core operations, and
subtle because of the intricate details involved in getting that
interface right. This paper presents the generalized iterator template
from the Boost Iterator Adaptor Library. In addition to automating the
error-prone and redundant job of implementing new iterator types, the
library simplifies the creation of iterator types that are variations
on other iterators (adapted iterators) and generators of new iterator
families (iterator adaptors). The Iterator Adaptor Library is an
example of policy-based design and employs template
meta-programming. We also present the Policy Adapter implementation
pattern, a strategy which can also be used to generate new
representatives of other abstract concept families.
\end{abstract}


\section{Introduction}

%- defaults make it easy to adapt an iterator
%- extensions from base operations to other operations make it
%  easier to create iterators

Iterators play an important role in modern \Cpp\ programming. The
iterator is the central abstraction of the algorithms of the Standard
Library, allowing algorithms to be re-used in in a wide variety of
contexts. 

\subsection{Iterators}

The power of iterators derives from several key
features:
\begin{itemize}
\item Iterators form a rich \emph{family} of concepts\footnote{We use
    the term \emph{concept} to mean a set of requirements that a type
    must satisfy to be used with a particular template parameter.}
  whose functionality varies along several axes: movement,
  dereferencing, and associated type exposure.
  
\item The iterator concepts of the \Cpp\ standard form a refinement
  hierarchy which allows the same basic interface elements to
  implement diverse functionality.
  
\item Because built-in pointer types model the
  \stlconcept{RandomAccessIterator} concept, iterators can be both
  efficient and convenient to use.
\end{itemize}

The \Cpp\ Standard Library contains a wide variety of useful
iterators. Every one of the standard containers comes with constant
and mutable iterators\footnote{The term \emph{mutable iterator} refers
to iterators over objects that can be changed by assigning to the
dereferenced iterator, while \emph{constant iterator} refers to
iterators over objects that cannot be modified.}, and also
\code{reverse\_} versions of those same iterators which traverse the
container in the opposite direction. The Standard also supplies
\code{istream\_\-iterator} and \code{ostream\_\-iterator} for reading
from and writing to streams, \code{insert\_iterator},
\code{front\_insert\_iterator} and \code{back\_insert\_iterator} for
inserting elements into containers, and
\code{raw\_\-storage\_\-iterator} for initializing raw
memory~\cite{iso98:_cpp_final_draft_standard}.

Despite the many iterators supplied by the Standard Library, many
obvious iterators are missing, and creating new iterator types is
still a common task for \Cpp\ programmers. The literature documents
several of these, for example
\code{line\_iterator}~\cite{austern99:_gener_progr_stl}
\code{Constant\_iterator}~\cite{koenig97:_rumin_cpp}. The iterator
abstraction is so powerful, however, that we expect programmers will
always need to invent new iterator types.

\subsection{Adaptors}

Because iterators combine traversal, indirection, and associated type
exposure, it is common to want to adapt one iterator to form a new
one. This strategy allows one to reuse some of original iterator's
axes of variation while redefining others. For example, the Standard
provides \reverseiterator{}, which adapts any
\stlconcept{BidirectionalIterator} by inverting its direction of
traversal.

As with plain iterators, iterator adaptors defined outside the
Standard have become commonplace in the literature:\begin{itemize}

\item \code{Checked\_iter}~\cite{stroustrup00:_cpp_prog_lang} adds
bounds-checking to an existing iterator.

 \item The iterators of the View Template
Library~\cite{TMPW00:Weiser}, which adapts containers, are themselves
adaptors over the underlying iterators.

 \item smart iterators~\cite{becker98:_smart_iteraters}
adapt an iterator's dereferencing behavior by applying a
function object to the object being referenced and returning the
result.

 \item Custom iterators~\cite{TMPW00:Baus},
in which a variety of adaptor types are enumerated.

% Jeremy, I don't know what to say about these two. Can you fill it in?
 \item compound iterators~\cite{alexandrescu98:_compound_iters},
   which access a slice out of a container of containers. 

 \item Several iterator adaptors from the MTL~\cite{siek99:_scitools}.
  The MTL contains a strided iterator, where each call to \code{operator++()}
  moves the iterator ahead by some constant factor, and a 
  scaled iterator, which multiplies the dereferenced value by some
  constant. 

\end{itemize}

\section{The Design of the Boost Iterator Adaptor Library}

% We need an intro here (do we?), but I don't think the text below
% fits in. Suggestions?

% For an iterator to be usable with the Standard algorithms (and other
% generic algorithms), it must fulfill the Standard requirements for an
% iterator type, which range from the few requirements of an
% \stlconcept{InputIterator} to the many requirements of a
% \stlconcept{RandomAccessIterator}. Implementing an iterator class that
% meets these requirements is a tedious and error-prone task despite the
% fact that most iterators are conceptually simple. The Boost Iterator
% Adaptor Library addresses these problems.

%\subsection{Overall Design}

To automate the repetitive work of constructing iterators, one would
need a generator of new iterator types that can accommodate all the
ways in which iterators vary. One could then make new iterators with
relative ease, specifying the parts that matter and letting the
library do the rest. To that end, the Boost Iterator Adaptor Library
provides a fully-generalized iterator called \iteratoradaptor{}. The
\iteratoradaptor\ class template adapts a \code{Base} type, (usually
an iterator), to produce a new adapted iterator type.\footnote{ The
term``\code{Base}'' is not meant to imply the use of inheritance. We
have followed the lead of the standard library, which provides a
\code{base()} function to access the underlying iterator object of a
\reverseiterator\ adaptor.}

\subsection{Core Elements of the Iterator Concept}

The first step in designing such a generalized model of the iterator
concept is to identify the core elements of its interface. We have
identified the following core behaviors for iterators:
\begin{itemize}
 \item dereferencing
 \item incrementing
 \item decrementing
 \item equality comparison
 \item random-access motion
 \item distance measurement
%% \item ordered comparison
%% Yikes, Jeremy! I think that including both less and distance in the
%% design might be a design mistake. Doesn't that introduce redundancy?
%% Shouldn't operator<() be implemented in terms of distance?
%% I had the same thought while reading this section. I think
%% we can implement < like this:
%% bool operator<(x, y) {
%%   return (y - x) > 0;
%% }
%% I've found that writing papers about stuff is good for debugging :)
\end{itemize}

In addition to the behaviors listed above, the core interface elements
include the associated types exposed through \iteratortraits{}:
\valuetype{}, \code{reference}, \code{pointer}, and
\iteratorcategory{}. The library supports two ways of specifying
these: as traditional template parameters and also as \emph{named}
template parameters (described below), and uses a system of smart
defaults which in most cases reduces the number of these types that
must be specified.

\subsection{From Building Models to Building Adaptors}

A generalized iterator generator is useful (helping to create new
iterator types from scratch), but a generalized iterator
\emph{adaptor} is even more useful. An adaptor generator allows one to
build whole families of iterator instances based on existing
iterators. In the Boost Iterator Adaptor Library, the
\iteratoradaptor\ class template plays the roles of both an iterator
generator and an iterator adaptor generator. The behaviors of
\iteratoradaptor{} instances are supplied through a policies
class~\cite{alexandrescu01:_modern_cpp_design} which allows
users to specialize adaptation. Users go beyond generating new
iterator types to easily generating new iterator adaptor families.

The library contains several examples of specialized adaptors which
were quickly implemented using \iteratoradaptor{}:\begin{itemize}

 \item Indirect Iterator Adaptor, which iterates over iterators, pointers, or
smart pointers and applies an extra level of dereferencing.

 \item Reverse Iterator Adaptor, which inverts the direction of a
\code{Base} iterator's motion, while allowing adapted constant and
mutable iterators to interact in the expected ways. We will discuss
this further in Section \ref{sec:constant-mutable-iterations}.

 \item Transform Iterator Adaptor, which applies a user-defined
function object to the underlying values when dereferenced. We will
show how this adaptor is implemented in
Section~\ref{sec:iterator-policies-class}.

 \item Projection Iterator Adaptor, which is similar to Transform
Iterator Adaptor except that when dereferenced it returns by-reference
instead of by-value.

 \item Filter Iterator Adaptor, which provides a view of an iterator
 range in which some elements of the underlying range are skipped.

 \item Counting Iterator Adaptor, which adapts any incrementable type
(e.g. integers, iterators) so that incrementing/decrementing the
adapted iterator and dereferencing it produces successive values of
the \code{Base} type.

 \item Function Output Iterator Adaptor, which makes it easier to
create custom output iterators.

\end{itemize}

Based on the examples in the library, users have generated many new
adaptors, among them a permutation adaptor which applies some
permutation to a \stlconcept{RandomAccessIterator}, and a strided
adaptor, which adapts a \stlconcept{RandomAccessIterator} by
multiplying its unit of motion by a constant factor.  In addition, the
Boost Graph Library (BGL) uses iterator adaptors to adapt other graph
libraries, such as LEDA~\cite{mehlhorn99:_leda} and Stanford
GraphBase~\cite{knu94:sgb}, to the BGL interface (which requires C++
Standard compliant iterators).

\section{The Boost \iteratoradaptor\ Class Template}

The \iteratoradaptor\ class template simplifies the creation
of iterators by automating the implementation of redundant operators
and delegating functions and by taking care of the complex details of
iterator implementation.

The central design feature of \iteratoradaptor\ is parameterization by
a policies class. The policies class is the primary
communication mechanism between the iterator implementer and the
\iteratoradaptor{}; it specifies how the new iterator type
behaves. Unlike the policy classes
in~\cite{alexandrescu01:_modern_cpp_design}, we group several policies
into a single class as this proved more convenient for iterator
implementation.

\subsection{Iterator Policies Class}
\label{sec:iterator-policies-class}

The following example shows how to implement the policies class for a
transform iterator adaptor: an iterator that applies some function to
the value returned by dereferencing the base iterator.  The
\code{transform\_\-iterator\_\-policies} class is templated on the
function object type, and a function object is stored as a data member
of the policies class.

% \footnote{We might instead have composed the
% underlying iterator and the function object into a single \code{Base}
% type, but that would have been much more work because so many useful
% defaults are provided when the \code{Base} type is itself an
% iterator.}

When adapting an underlying iterator, it is easiest to store any extra
state needed by the resulting iterator in the policies class.  The
alternative is to wrap the underlying iterator in another class that
contains the state, thereby incorporating the state into the
\code{Base} type. This approach is much more work since the wrapping
class will have to delegate many operations (instead of allowing
the \iteratoradaptor\ to implement the delegations).

The policies class inherits from
\code{default\_\-iterator\_\-policies}, which delegates all other
operations to the base iterator. The main event of the
\code{transform\_\-iterator\_\-policies} class is the
\code{dereference()} member function, which simply applies the
function to the dereferenced value. The base iterator object is the
second argument to the \code{dereference()} function. Because the
iterator type is a template parameter of the \code{dereference()}
function, the same concrete policies class can be used with any base
iterator type, which greatly simplifies adaptation.

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction>
  struct transform_iterator_policies : public default_iterator_policies
  {
    transform_iterator_policies() { }
    transform_iterator_policies(const AdaptableUnaryFunction& f)
      : m_f(f) { }

    template <class Reference, class Base>
    Reference dereference(type<Reference>, const Base& x) const
      { return m_f(*x); } // apply the function and return the result

    AdaptableUnaryFunction m_f;
  };
\end{verbatim}
}
Notes on the policies class implementation:\begin{itemize}

\item Because \iteratoradaptor\ stores an instance of the policies class as
a data member, and all iterators are required to have default
constructors, policies classes to be used with \iteratoradaptor\ are
also required to have default constructors.

\item The \code{type<Reference>} parameter is an empty class used only to
convey the appropriate return type to the \code{dereference()}
function. Although it might have been more elegant to rely on the
caller for explicit specification of the \code{Reference} template
argument as in
\code{policies.dereference<reference>(base\_\-iterator)}, that
approach proved not to to be portable to all of the targeted
compilers.\end{itemize}

With the policies class complete, the iterator implementer is almost
finished, and only eleven lines of code have been written. The code
consists of little more than the main idea of the transform iterator,
applying a function to the result of dereferencing the base iterator.
Next we will take a closer look at the
\code{default\_\-iterator\_\-policies} class and then in
\S\ref{sec:iter-type-generator} we will show how the transform
iterator type is constructed using \iteratoradaptor{}.


\subsection{Default Iterator Policies Class}

The \code{default\_\-iterator\_\-policies} class is the mechanism that
automatically delegates operator implementations to the base iterator,
freeing the iterator implementer from the tedious task of writing
delegating functions. As above, an iterator policies class inherits
from this class and overrides any functions that should not be
delegated. The \code{default\_\-iterator\_\-policies} class also
serves as an example of the iterator policies interface. There are
six member functions corresponding to the core iterator operations
and an \code{initialize()} function which provides a hook for
customized iterator construction.

{\footnotesize
\begin{verbatim}
namespace boost {
  struct default_iterator_policies
  {
    template <class Base>
    void initialize(Base&) { }

    template <class Reference, class Base>
    Reference dereference(type<Reference>, const Base& x) const
      { return *x; }

    template <class Base>
    void increment(Base& x) { ++x; }

    template <class Base>
    void decrement(Base& x) { --x; }

    template <class Base, class Difference>
    void advance(Base& x, Difference n) { x += n; }

    template <class Difference, class Base1, class Base2>
    Difference distance(type<Difference>, const Base1& x,
                        const Base2& y) const { return y - x; }

    template <class Base1, class Base2>
    bool equal(const Base1& x, const Base2& y) const
      { return x == y; }
  };
} // namespace boost
\end{verbatim}
}


\subsection{Iterator Type Generator}
\label{sec:iter-type-generator}

In Section~\ref{sec:iterator-policies-class} we showed how to create
the policy class for the transform iterator; the next step is to use
the \iteratoradaptor\ template to construct the actual iterator type.
The best way to package the construction of the transform iterator is
to create a \emph{type generator}: a class template whose sole purpose
is to simplify the instantiation of some other complicated class
template. It fulfills the same need as a template typedef would, if
that were part of the \Cpp\ language.  The first template parameter to
the type generator is the type of the function object and the second
is the base iterator type.  The following code shows the type
generator for the transform iterator.

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction, class BaseIterator>
  struct transform_iterator_generator
  {
    typedef typename AdaptableUnaryFunction::result_type val_t;
  public:
    typedef iterator_adaptor<BaseIterator, 
      transform_iterator_policies<AdaptableUnaryFunction>,
      iterator_category_is<std::input_iterator_tag>, 
      value_type_is<val_t>, reference_is<val_t> > type;
  };
\end{verbatim}
}

We use \iteratoradaptor\ to define the transform iterator type as a
nested \code{typedef} inside the
\code{transform\_\-iterator\_\-generator} class. The first parameter
to \iteratoradaptor\ is the base iterator type and the second is the
policies class. The remaining parameters specify the iterator's
associated types and are given as \emph{named parameters}.  We will
discuss this technique in \S\ref{sec:named-template-parameters}.

The \iteratorcategory\ is set to
\code{std::input\_\-iterator\_\-tag} because the function object may
return by-value. For the same reason the \code{reference} type (which
will be the return type of \code{operator*}) is set to \code{val\_t}
(and not \code{val\_t\&}). There are two parameters that are left out:
the \code{pointer} type defaults to \code{value\_type*} and the
\differencetype{} defaults to the \differencetype{} of
the base iterator.

It is tempting to create a \code{transform\_\-iterator} class template
which is derived from \iteratoradaptor\, instead of using the
type generator.  This approach does not work, for example, because the
return type of \code{operator++} of an iterator is required to be the
same iterator type, while in this case the return type would be
\iteratoradaptor\ and not \code{transform\_\-iterator}.

\subsection{Iterator Object Generator}
\label{sec:iter-object-generator}

Even though we now have a way to easily express the type of our
transform iterator, writing the type down at all is often more trouble
than it is worth. The \stlconcept{AdaptableUnaryFunction}'s type alone
could be quite complex if it were generated using standard library
facilities such as \code{std::bind1st}, \code{std::bind2nd}, or
\code{std::ptr\_fun}.  Declaring the entire transform iterator type
can be much worse. For example, suppose we wanted to multiply the
elements of a \code{set} by 2, and append them to a \code{list}. The
transform iterator type might be declared as follows:

{\footnotesize
\begin{verbatim}
  typedef transform_iterator_generator<
        std::binder2nd<std::multiplies<int> >,
        std::set<int, std::greater<int> >::const_iterator>::type
    int_set_doubler;
  // to be continued...
\end{verbatim}
}

Continuing our example, we find that the ``adapting constructor'' of
\iteratoradaptor\ is not always well-suited to easy construction of
specialized adaptor types. That constructor is declared as follows:

{\footnotesize
\begin{verbatim}
  iterator_adaptor(const Base& it, const Policies& p = Policies())
\end{verbatim}
}

Because we stored the \stlconcept{AdaptableUnaryFunction} object
(which may have state) inside the Policies class of our transform
iterator, the user can't rely on the default constructor argument to
generate the correct policies object. Instead the policies object must
be explicitly constructed and passed to the adaptor's
constructor:

{\footnotesize
\begin{verbatim}
  // ...example (continued)
  typedef transform_iterator_policies<
      std::binder2nd<std::multiplies<int> > > policies;

  policies p(std::bind2nd(std::multiplies<int>(),2));

  std::copy(
    int_set_doubler(my_set.begin(), p),
    int_set_doubler(my_set.end(), p),
    std::back_inserter(my_list));
\end{verbatim}
}

If every use of transform iterator required this much code, users
would quickly give up on it and use handwritten loops
instead. Fortunately, the \Cpp\ standard library provides a useful
precedent.

In the example above, \code{std::back\_\-inserter} is a type of
function called an \emph{object generator} which returns an object of
type \code{std::back\_\-insert\_\-iterator<my\_\-list>}. An object
generator allows the user to build adapted types ``on the fly'' and
pass them directly to functions, so that no declaration is needed.
This idiom is especially convenient in the case of iterators, since so
many algorithms are implemented in terms of iterator ranges. We
therefore recommend that iterator implementers create an object
generator for their iterators. The object generator function for the
transform iterator adaptor, \code{make\_\-transform\_\-iterator}, is
shown below.\footnote{ Although there is precedent in the standard for
  calling such an object generator, simply
  ``\code{transform\_iterator()}'' (e.g.
  \code{std::back\_\-inserter}), the standard also uses the more
  explicit ``\code{make\_}'' prefix (e.g. \code{std::make\_pair()})
  and occasionally also reserves the simple name for the iterator type
  itself (e.g. \code{std::reverse\_iterator}).  In the end, the
  authors felt that explicit was better than implicit and decided to
  use the ``\code{make\_}'' prefix for object generators.  }

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction, class BaseIterator>
  typename transform_iterator_generator<
      AdaptableUnaryFunction, BaseIterator>::type
  make_transform_iterator(BaseIterator base,
      const AdaptableUnaryFunction& f = AdaptableUnaryFunction())
  {
    typedef typename transform_iterator_generator<AdaptableUnaryFunction,
      BaseIterator>::type result_t;

    transform_iterator_policies<AdaptableUnaryFunction> policies(f);

    return result_t(base, policies);
  }
\end{verbatim}
}

With the object generator in place, we can considerably simplify the
code for our previous example:

{\footnotesize
\begin{verbatim}
  std::copy(
    make_transform_iterator(my_set.begin(), 
        std::bind2nd(std::multiplies<int>(),2)),
    make_transform_iterator(my_set.end(), 
        std::bind2nd(std::multiplies<int>(),2)),
    std::back_inserter(my_list));
\end{verbatim}
}

% Jeremy, I'm not sure I buy the arguments below. I certainly never
% considered and rejected that approach on the basis you give ;-). 
% I wonder whether this section should be a footnote, stricken, 
% cleaned up, or I'm nuts.

An alternative solution to using an object generator function would
have been to give \iteratoradaptor\ a templated constructor accepting
arbitrary arguments. The arguments would then be passed as a
heterogeneous value list~\cite{TMPW00:Eisenecker} to the policies
class. This scheme would remove the need for object generating
functions but would increase the complexity of the implementation and
the compile time. For a low-level component such as an iterator
adaptor we felt that simplicity and compile-time were more important
than implementer convenience.

\subsection{Example Use of the Transform Iterator Adaptor}

This example shows how a transform iterator can be used to
negate the numbers over which it iterates.

{\footnotesize
\begin{verbatim}
  #include <functional>
  #include <algorithm>
  #include <iostream>
  #include <boost/iterator_adaptors.hpp>
  int main(int, char*[])
  {
    int x[] = { 1, 2, 3, 4, 5, 6, 7, 8 };
    const int N = sizeof(x)/sizeof(int);
    std::cout << "negating the elements of the array:" << std::endl;
    std::copy(
        boost::make_transform_iterator(x, std::negate<int>()),
        boost::make_transform_iterator(x + N, std::negate<int>()),
        std::ostream_iterator<int>(std::cout, " "));
    std::cout << std::endl;
    return 0;
  }
\end{verbatim}
}

\noindent This output is: 
{\footnotesize
\begin{verbatim}
-1 -2 -3 -4 -5 -6 -7 -8
\end{verbatim}
}

\section{The Policy Adaptor Design Pattern}

The Iterator Adaptor Library illustrates how a generalized Model
(\iteratoradaptor{}) of a concept family (iterators) combined with
default policy delegation allows users to easily build new Models and
behavioral adaptors for existing Models. We can capture this strategy
in the Policy Adaptor design pattern:\footnote{This is not quite the
same as the Policy Class pattern which has been discussed previously
in the literature~\cite{alexandrescu01:_modern_cpp_design}. The
construction of an adaptor which can easily transform existing Models
into new ones is the key difference}\begin{enumerate}

\item Identify the core elements of the public
  interface of the concept family to be modeled. In our case, the
  Adaptor will model one of the iterator concepts:
  \stlconcept{InputIterator}, \stlconcept{ForwardIterator},
  \stlconcept{BidirectionalIterator}, or
  \stlconcept{RandomAccessIterator} (this depends on the
  base iterator type and the parameters of the Adaptor). 
   
\item Encapsulate core elements of the concept family in a
  Policies concept.

\item Write a default policies class which delegates behavior to the
  public interface of the Adaptor's concept. This is the mechanism that
  supplies default adaptation behavior.
  
\item Build an Adaptor class template parameterized on Policies. The
  Adaptor should be a generalized model of the Adaptor Concept,
  providing the public interface, but delegating functionality to the
  policies class.
  
\item Store a member of the Policies parameter in the Adaptor template
  so that users can maintain additional state while taking advantage of
  default behavior delegation.

\end{enumerate}

We believe this design pattern is a powerful new tool for modeling any
concept which varies along several axes and contains significant
redundancy.

\section{The Implementation of \iteratoradaptor{}}

The outline for the implementation of the \iteratoradaptor\
class template is as follows. In the next few sections we will discuss
aspects of the implementation in more depth, including how the
problems discussed in the introduction were solved.

{\footnotesize
\begin{verbatim}
namespace boost {
  template <class Base, class Policies, 
            class Value = default_argument,
            class Reference = default_argument,
            class Pointer = default_argument,
            class Category = default_argument,
            class Distance = default_argument>
  struct iterator_adaptor {
    // Deduce iterator associated types (value_type, etc.) from the
    // named template parameters, and resolve any defaults.
  public:
    // Core operators, delegate to policies class.
    // Redundant operators, implemented in terms of the core operators.
  private:
    // If the policies class is empty, compressed_pair applies the
    // empty-base class optimization to conserve space. The base is
    // ``first'' and the policies are ``second''.
    compressed_pair<Base, Policies> m_iter_p;

    Policies& policies() { return m_iter_p.second(); }
    Base& base() { return m_iter_p.first(); }
    // and similarly for const...
  };
  // Core binary operators.
  // Redundant binary operators.
} // namespace boost
\end{verbatim}
}

\subsection{Deducing the Associated Types}

Iterators have five associated types: \valuetype{},
\code{reference}, \code{pointer}, \iteratorcategory{}, and
\differencetype{}. Each of these types must either be supplied
by the user, using the named parameter technique described below in
\S\ref{sec:named-template-parameters}, or a default must be computed
for the type.

\subsubsection{Defaults for the Associated Types}

Because an iterator has so many type parameters, the order and
semantics of the associated type parameters was carefully chosen so
that users would be able to use as many defaults as possible. The list
of associated types begins with the most fundamental element, the
iterator's \valuetype{}. If no \code{Value} parameter is supplied,
the \code{Base} type is assumed to be an iterator, and the adapted
iterator takes its \valuetype\ from the \code{Base}
iterator's \iteratortraits{}. However, if the \code{Value} parameter \emph{is} supplied,
an adjustment is made which allows the user to more easily create a
constant iterator: if the \code{Value} parameter is \code{const T},
the \valuetype\ will just be \code{T}. Perhaps
strangely, a constant iterator's \valuetype\ should never be
\code{const}, because it would prevent algorithms from declaring
modifiable temporary objects which are copied from dereferenced
iterators. For example:

{\footnotesize
\begin{verbatim}
  template <class ForwardIterator>
  typename iterator_traits<ForwardIterator>::value_type
  sum(ForwardIterator start, ForwardIterator finish)
  {
      typedef typename
          iterator_traits<ForwardIterator>::value_type value;
      if (start == finish)
          return value();
      value x = *start;
      while (++start != finish)
          x += *start; // error?
      return x;
  }
\end{verbatim}
}

The defaults for the \code{pointer} and \code{reference} types
cooperate with the \code{Value} parameter: if the \code{Value}
parameter is supplied, the \code{pointer} and \code{reference} types
default to simply \code{Value*} and \code{Value\&} respectively
(without the \code{const}-ness stripped). Otherwise, as above the
\code{Base} type is assumed to be an iterator and the \code{pointer}
and \code{reference} types are taken from its
\iteratortraits{}.

Since these defaults correspond to the required relationships between
the \code{reference}, \code{pointer}, \valuetype\ for all
constant and mutable \stlconcept{ForwardIterator}s, it is often
sufficient to supply just the \code{Value} parameter when there is no
\code{Base} iterator with appropriate
\iteratortraits{}.\footnote{The \code{Reference} parameter
precedes the \code{Pointer} parameter because it must be often
customized for \stlconcept{OutputIterator}s and other iterator types
(e.g. \code{std::vector<bool>::iterator}, which uses a proxy
\code{reference}).}

The defaults for the \iteratorcategory{} and \differencetype{} are
straightforward: they are the respective types from the \code{Base}
iterator. These work out well as the final parameters, because one usually wants
all of the capabilities supplied by the iterator being adapted, and it is
difficult to provide more capabilities.

The code used to select the appropriate defaults for the iterator's
associated types used to look something like this:

{\footnotesize
\begin{verbatim}
  // compute default pointer and reference types.
  template <class Iterator,class Value>
  struct iterator_defaults : iterator_traits<Iterator>
  {
     // If the Value parameter is not the same as its default, the
     // user supplied it. 
     static const bool value_type_supplied
      = !is_same<Value,typename iterator_traits<Iterator>::value_type>::value;

     typedef typename type_if<value_type_supplied,
             Value*,
        // else
              typename iterator_traits<Iterator>::pointer
     >::type pointer;

     typedef typename type_if<value_type_supplied,
             Value*,
        // else
              typename iterator_traits<Iterator>::reference
     >::type reference;
  };

  template <class Base, class Policies, 
      class Value = typename std::iterator_traits<Base>::value_type,
      class Reference = typename iterator_defaults<Base,Value>::reference,
      class Pointer = typename iterator_defaults<Base,Value>::pointer,
      class Category = typename std::iterator_traits<Base>::iterator_category,
      class Distance = typename std::iterator_traits<Base>::difference_type
           >
  class iterator_adaptor
  {
   public:
      typedef Distance difference_type;
      typedef remove_const<Value>::type value_type;
      typedef Pointer pointer;
      typedef Reference reference;
      typedef Category iterator_category;
\end{verbatim}
}

Unfortunately, this strategy can only take us so far. It turns out
that there are plenty of iterators which don't fit neatly into the
system for ordering defaults. For example, the specialized Transform
Iterator Adaptor described in Section~\ref{sec:iterator-policies-class}
limits the category of its \code{Base} iterator to
\stlconcept{InputIterator}, so we'd only need to supply the
\valuetype{}, \code{reference}, and \iteratorcategory\ if
the \code{Category} parameter didn't appear last. Iterators where the
\code{Base} type is not itself an iterator also act this way, since
there are no appropriate \iteratortraits\ from which to derive
the \code{Pointer} and \code{Reference} parameters.

\subsubsection{Named Template Parameters}
\label{sec:named-template-parameters}

Instead of matching arguments to parameters based on order, the
assignment of arguments to parameters can be made explicitly by name,
so that the order no longer matters~\cite{czarnecki00:_named_param}.
The Iterator Adaptors library supplies an appropriately-named wrapper
class for each parameter. For example:

{\footnotesize
\begin{verbatim} 
  template <class Value> struct value_type_is {
    typedef value_type_tag tag;
    typedef Value type;
  };
\end{verbatim} 
}

Instead of passing the argument \code{Value} directly to
\iteratoradaptor\ the user can pass
\code{value\_type\_is<Value>}. The \iteratoradaptor\ has
five arguments for the associated types, each of which could be used
to specify any of the actual parameters. The
\iteratoradaptor\ must deduce which argument is for which
parameter based on the \code{tag} inside the wrapper.

First we take all of the parameters and place them in a
lisp-style list, using \code{std::pair} for \code{cons}. Each
parameter wrapper has a key/value pair (the \code{tag} and \code{type}
respectively), so we can treat this as an associative list.

{\footnotesize
\begin{verbatim} 
  typedef pair<Param1, pair<Param2, pair<Param3, pair<Param4,
            pair<Param5, list_end_type> > > > > NamedParamList;
\end{verbatim} 
}

\noindent For each parameter we perform a look-up in the associative
list using a template meta-program utility class named
\code{find\_param}.

{\footnotesize
\begin{verbatim} 
  template <class AssociativeList, class Key>
  struct find_param {
    typedef ... type;
  };
\end{verbatim} 
}

\noindent So, for example, to retrieve the argument for the
\valuetype\ we write the following:

{\footnotesize
\begin{verbatim} 
  typedef typename find_param<NamedParamList, value_type_tag>::type Value;
\end{verbatim} 
}

The result of this look-up will either be the argument specified by the
user, or if there is none, the \code{default\_argument} type. If it is
the default, then a further step is taken to resolve what the default
should be for the parameter. The defaults for some of the parameters
depend on other parameters, so the order in which defaults are
resolved is tailored to respect these dependencies.


\subsection{Core Operators}

The core operators of the \iteratoradaptor\ are implemented by
delegating the work to the policies class. Each core operator passes
the base object to the appropriate policy function. Sometimes extra
type information is also passed in, as is the case with the
\code{reference} type in the implementation of \code{operator*}.

{\footnotesize
\begin{verbatim}
  reference operator*() const {
    return policies().dereference(type<reference>(), base());
  }
\end{verbatim}
}

The binary operators of the iterator are implemented as free functions
(not member functions) to allow both the left and right hand operands
to be treated symmetrically, and to implement constant and mutable
iterator interactions (more about this in the following
Subsection). The implementation of \code{operator==()} is shown below.
We use separate template parameters for the two \iteratoradaptor\
arguments. This allows a single operator to implement all of the
combinations of constant/mutable iterator interactions, avoiding the
combinatorial explosion discussed in
\S\ref{sec:constant-mutable-iterations}. Note that we only use a
single \code{Policies} template parameter: this restricts iterator
interaction to those iterators with the same policies class.  This is
not as restrictive as it probably should be, but most iterator
interaction errors will be caught anyway, when the policies are
applied. The disadvantage of not being restrictive enough is in the
kind of error message the user will see when misusing two unrelated
iterators. Instead of an ``operator not found'' message they will see
an error message from inside the iterator adaptor.

{\footnotesize
\begin{verbatim}
  template <class Base1, class Base2, class Policies, class V1, class V2,
      class R1, class R2, class P1, class P2, class C1, class C2, 
      class D1, class D2>
  bool operator==(
    const iterator_adaptor<Base1,Policies,V1,R1,P1,C1,D1>& x,
    const iterator_adaptor<Base2,Policies,V2,R2,P2,C2,D2>& y)
  {
    return x.policies().equal(x.base(), y.base());
  }
\end{verbatim}
}

\subsubsection{Constant/Mutable Iterator Interactions}
\label{sec:constant-mutable-iterations}

Iterators over containers and other sequences of stored objects
usually come in pairs: a constant iterator type and a mutable iterator
type. It is desirable to allow the constant and mutable iterators to
interoperate through comparison and subtraction. For example, suppose
that you are implementing a container type \code{C}. Then you ought to
define the following four versions of \code{operator==}, along with
corresponding versions of \code{operator!=}, and (for
\stlconcept{RandomAccessIterator}), operators \code{<}, \code{>},
\code{<=}, \code{>=}, and \code{-}.

{\footnotesize
\begin{verbatim}
  bool operator==(const C::iterator& x, const C::iterator& y);
  bool operator==(const C::const_iterator& x, const C::iterator& y);
  bool operator==(const C::iterator& x, const C::const_iterator& y);
  bool operator==(const C::const_iterator& x, const C::const_iterator& y);
\end{verbatim}
}

Implementers often forget to define the operators for constant/mutable
iterator interaction. In addition, iterator adaptors applied to these
kinds of iterators should propagate the ability to interact. For
example, a reverse iterator adaptor applied to \code{C::iterator} and
\code{C::const\_iterator} should result in mutable and constant
reverse iterator types that have the same ability to interact as the
\code{Base} iterators do. The \reverseiterator{} adaptor supplied by
the Iterator Adaptor Library have this ability, although those
supplied by the \Cpp\ standard library do not.

The iterator adaptor binary operators are implemented using function
templates (as shown in the previous Subsection). This allows the same
function template to provide the implementation of all the
combinations of constant and mutable iterator interaction.


\subsection{Redundant Operators}

Most of the redundant operators are implemented in a straightforward
way based on the core operators. For example, the \code{operator+} is
implemented in terms of \code{operator+=}. There are a total of 6 core
operators and 11 redundant operators.

{\footnotesize
\begin{verbatim}
template <class B, class P, class V, class R, class Ptr,
    class C, class D, class Distance>
iterator_adaptor<B,P,V,R,Ptr,C,D>
operator+(iterator_adaptor<B,P,V,R,Ptr,C,D> p, Distance x)
{
  return p += x;
}
\end{verbatim}
}

The implementation of \code{operator->} and \code{operator[]}are not
straightforward. We discuss them in the following two sections.

\subsubsection{Implementing \code{operator->} for Input Iterators}
\label{sec:operator-arrow}

When creating an iterator adaptor that produces an
\stlconcept{InputIterator} some extra care must be taken in the
implementation of \code{operator->}. Remember that an input iterator
need not iterate over stored objects: it can manufacture new objects
when it is dereferenced as is the case for
\code{std::istream\_iterator}. If the iterator's \valuetype\ is of
class type, we need to support \code{operator->}. Since the result of
using \code{operator->} must produce a true pointer even when
dereferencing the iterator does not yield a true reference type, we
need a \code{const} lvalue to which a pointer can be formed.

Fortunately, the standard makes a workaround possible: section
13.3.1.2 paragraph 8 describes a seemingly quirky rule that the
\code{->} operator will be applied to the \emph{result} of any call to
\code{operator->}. This is a convenient way to describe the semantics
of ordinary \code{operator->}, which returns a pointer: it just uses
the pointer to perform the usual member dereferencing. It also turns
out to be what we need to make a conforming
\stlconcept{InputIterator}. By making the return type of
\code{operator->} a proxy containing an instance of the iterator's
\valuetype{}, we can eventually form a \code{const} pointer to the
returned temporary:

{\footnotesize
\begin{verbatim}
  template <class T>
  struct operator_arrow_proxy
  {
    operator_arrow_proxy(const T& x) : m_value(x) {}
    const T* operator->() const { return &m_value; }
    T m_value;
  };
\end{verbatim}
}

\noindent The iterator adaptor library uses a small meta-program to
select the appropriate type for the result of an iterator's
\code{operator->}:

{\footnotesize
\begin{verbatim}
  template <class Category, class Value, class Pointer>
  struct operator_arrow_result_generator
  {
    // Is it an input iterator, or something more?
    static bool const is_input_iter
      = is_convertible<Category*, std::input_iterator_tag*>::value
         && !is_convertible<Category*,std::forward_iterator_tag*>::value;

    typedef typename type_if<is_input_iter,
           operator_arrow_proxy<Value>,
      // else
           Pointer
      >::type type;
  };
\end{verbatim}
}

The Boost Type Traits library is used to check whether the iterator's
category is no more refined than \stlconcept{InputIterator}. If so,
the appropriate \code{operator\_arrow\_proxy} is selected.
Convertibility is used as a criterion to allow for user-defined
iterator categories derived from the standard ones.


\subsubsection{Implementation of \code{operator[]}}
\label{sec:op-bracket-impl}

The implementation of \code{operator[]} would be trivial except for
the question of whether it should return a reference or a
value. Although it would be more useful to return a reference, this
can cause run-time errors when adapting a certain class of legal base
iterators.  Suppose the base iterator is reading in elements from a
file and caching each element as a data member of the iterator.

{\footnotesize
\begin{verbatim}
class file_iter {
  T x;
  int pos;
public:
  file_iter(int pos = 0) { x = read_from_file(pos); }
  T& operator*() const { return x; }
  file_iter operator+(int n) const { return file_iter(pos + n); }
  file_iter& operator++() { x = read_from_file(++pos); return *this; }
  // ...
};
\end{verbatim}
}

\noindent The \code{operator*} of this iterator returns a reference to
the data member. Now consider what happens inside the
\code{operator[]} of the adaptor:

{\footnotesize
\begin{verbatim}
template <class BaseIterator> class my_iterator_adaptor {
  BaseIterator iter;
public:
  reference operator[](difference_type n) const {
    return *(iter + n);
  }
 // ...
};
\end{verbatim}
}

\noindent The iterator addition creates a temporary iterator and the
dereference returns a reference to a data member of this temporary,
which is destroyed before \code{operator[]} returns. The result is a
dangling reference.

The \Cpp\ Standard specifies that the return type of \code{operator[]}
of a random access iterator must be ``convertible to \code{T}''.  This
opens up the possibility of returning by-value from \code{operator[]}
instead of by-reference, thereby avoiding the above problem.  This
approach, though safer, has the disadvantage of being unintuitive
since \code{operator*} is required to return the exact type \code{T\&}
and one might expect that \code{operator[]} and \code{operator*} would
be same in this respect.  The \Cpp\ Standards Committee is currently
debating the question of whether the random access iterator
requirements should be changed.

Boost's \iteratoradaptor\ takes the safe route and returns the result
by-value. This meets the random access iterator requirements of the
Standard, which only says that the return type must be ``convertible
to T'',

{\footnotesize
\begin{verbatim}
  value_type operator[](difference_type n) const
    { return *(*this + n); }
\end{verbatim}
}

Under the current \Cpp\ Standard, you cannot assign into the result of
\code{operator[]} applied to a generic random access iterator,
but instead must write \code{*(i + n) = x}.

It would be nice to return by-reference for iterators that can support
it, and by-value for the rest. However, the current \iteratortraits\
does not provide enough information to make the choice. The proposal
in~\cite{siek01:_improved_iter_cat} would solve this problem, but of
course that will take some time to gain acceptance.


% Jeremy: I didn't agree with this part, so commented it out
% temporarily. I think an iterator which can return by-reference for
% operator* should be allowed to do so, regardless of what it can do
% for operator[]. Let's discuss.

% In addition, the lack of consistency between \code{operator[]}
% and \code{operator*} will be surprising to people. Preferably an
% iterator would either return by-value for both \code{operator*} and
% \code{operator[]} or return by-reference for both. 

\section{Conclusion}

Constructing iterators and iterator adaptors is a common task for
modern \Cpp\ programming. Despite the conceptual simplicity of most
iterators, implementing \Cpp\ Standard conforming iterators requires a
non-trivial amount of code, some of which is challenging to get right
and a lot of which is tedious. The \iteratoradaptor\ class that
we've presented solves these problem by providing a mechanism
by which the user provides a minimal specification (by way of the
policies class) for the iterator, and then the
\iteratoradaptor\ takes care of most of the implementation
details.

Taking a step back, the design approach was to create a canonical
implementation of a concept (iterator) and then delegate the core
implementation issues to a policies class. This approach can be
applied in situations where there is large family of components that
share the same interface. For example, we plan on applying this design
approach to containers and algebraic types.

\bibliographystyle{abbrv}
\bibliography{refs,tmpw00}

\end{document}
% LocalWords:  Iterator Siek Altra Broadband Florham iterator Adaptor iterators
% LocalWords:  adaptors istream ostream iter MTL InputIterator adaptor const ag
% LocalWords:  RandomAccessIterator dereference interoperate Implementers tmpw
% LocalWords:  dereferencing adaptor's lvalues iterator's instantiation typedef
% LocalWords:  AdaptableUnaryFunction templated dereferenced lvalue val param
% LocalWords:  parameterization InputIterators TOC BGL LEDA GraphBase
% LocalWords:  Convertibility interoperability rogramming tandard terator nsert
% LocalWords:  torage rogrammers BidirectionalIterator ter daptor Yikes strided
% LocalWords:  incrementable olicies BaseIterator ype emplate anguage enerator
% LocalWords:  Nackman nserter int raits VTL tandards rom hould ness bool ust
% LocalWords:  ForwardIterator OutputIterator aram rgument rguments rrow roxy
% LocalWords:  lways Boost's akes oes onstructor unintuitive
