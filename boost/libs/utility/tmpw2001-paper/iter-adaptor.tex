% Current TOC outline
% 0 Abstract
% 1 Introduction
%   1.1 Redundant Operators
%   1.2 Delegation of Operators and Type Definitions
%   1.3 Iterator Implementation Complexities
%     1.3.1 Constant/Mutable Iterator Interactions
%     1.3.2 Constant/Mutable Iterator Code Duplication
%     1.3.3 Input Iterators and operator->
%     1.3.4 The Return Type of operator[] for Adaptors
% 2 The Boost iterator_adaptor Class Template
%   2.1 Iterator Policies Class
%   2.2 Default Iterator Policies Class
%   2.3 Iterator Type Generator
%   2.4 Iterator Object Generator
%   2.5 Example Use of the Transform Iterator Adaptor
% 3 The Implementation of iterator_adaptor
%   3.1 Deducing the Associates Types
%     3.1.1 Defaults for the Associated Types
%     3.1.2 Named Template Parameters
%   3.2 Core Operators
%   3.3 Redundant Operators
%     3.3.1 Implementing operator-> for Input Iterators
%     3.3.2 Implementation of operator[]
% 4. Conclusion

% Introduction/Motivation, etc. (Dave & Jeremy)

% iterator policies   (Dave)
%   default policies
%   type<> wrapper
% \cite{alexandrescu01:_modern_cpp_design}

% iterator_comparisons base (B&N) (Jeremy) \cite{Barton94}
%  workaround for g++ compiler bug with friend functions?

% operator_array_proxy (Dave)

% default pointer/reference type selection (Dave)

% wrapping non-iterators (count_iterator) (Jeremy)

% named template parameters (Jeremy)

% operator[] return type (Dave)

% the static asserts (Dave)

% generators (Jeremy)
%   type generators
%     tempting to try to use inheritance to replace
%        templated typedef, but that doesn't work.
%   object generators

% const/non-const interoperability (Dave)

% implementing const/mutable iterators with the same class
%   common mistake is to make the return type of operator*()
%     depend on whether the iterator object is const/non-const.
%     See the transform iterator in \cite{TMPW00:Weiser}

% custom iterators \cite{TMPW00:Baus}
%   generating iterators 
%     line iterator \cite{austern99:_gener_progr_stl}
%     constant iterator \cite{koenig97:_rumin_cpp}

% reverse iterator, front_insert_iterator, back_insert_iterator,
% insert_iterator \cite{iso98:_cpp_final_draft_standard}

% view iterators
%   \cite{TMPW00:Weiser}

% future work, container adaptors

\documentclass{netobjectdays}

\newcommand{\Cpp}{C\kern-0.05em\texttt{+\kern-0.03em+}}
\newcommand{\iteratoradaptor}{\code{iterator\_\-adaptor}}
\newcommand{\valuetype}{\code{value\_\-type}}
\newcommand{\differencetype}{\code{difference\_\-type}}
\newcommand{\iteratorcategory}{\code{iterator\_\-category}}
\newcommand{\iteratortraits}{\code{iterator\_\-traits}}
\newcommand{\constiterator}{\code{const\_\-iterator}}
\newcommand{\reverseiterator}{\code{reverse\_\-iterator}}

\input{defs}

\begin{document}

\title{Generating Iterator Types}

\author{David Abrahams$^\dag$ and Jeremy Siek$^\ddag$ \\
\\
$^\dag$ Altra Broadband \\
\texttt{abrahams@altrabroadband.com}\\
\\
$^\ddag$ AT\&T Labs - Research \\
Florham Park, NJ 07932, USA \\
\texttt{jsiek@research.att.com}
}

\maketitle

 \begin{abstract} $\!$The iterator abstraction is one of the most
commonly used in programming, but implementing an iterator type can be
challenging. The requirements for a standard-conforming iterator are
at once tedious and subtle: tedious because much of an iterator's rich
interface is ``boilerplate'' surrounding a few core opertions, and
subtle because of the intricate details involved in getting that
interface right. This paper presents the generalized iterator template
from the Boost Iterator Adaptor Library. In addition to automating the
error-prone and redundant job of implementing new iterator types, the
library simplifies the creation of iterator types that are variations
on other iterators (adapted iterators) and generators of new iterator
families (iterator adaptors). The Iterator Adaptor Library is an
example of policy-based design and employs template
meta-programming. We also present the Policy Adapter implementation
pattern, a strategy used by the library that can also be used to
generate new representatives of other abstract Concept families.
\end{abstract}


\section{Introduction}

%- defaults make it easy to adapt an iterator
%- extensions from base operations to other operations make it
%  easier to create iterators

Iterators play an important role in modern \Cpp\ programing. The
iterator is the central abstraction of the algorithms of the Standard
Library, allowing algorithms to be re-used in in a wide variety of
contexts. 

\subsection{Iterators}

The power of iterators derives from several key
features:\begin{itemize}

 \item Iterators form a rich \emph{family} of Concepts
whose functionality varies along several axes: movement,
dereferencing, and type exposure. 

 \item The iterator concepts of the \Cpp\
standard form a refinement hierarchy which allows the same basic
interface elements to implement diverse functionality.

 \item Because
built-in pointer types model the \stlconcept{RandomAccessIterator}
Concept, iterators can be both efficient and convenient to use.

\end{itemize}

The \Cpp\ Standard Library contains a wide variety of useful
iterators. Every one of the standard containers comes with constant
and mutable iterators, and also \code{reverse\_} versions which
traverse the container in the opposite direction. The Standard also
supplies \code{istream\_\-iterator} and \code{ostream\_\-iterator} for
reading from and writing to streams, \code{insert\_iterator} and
\code{back\_insert\_iterator} for inserting elements in containers,
and \code{raw\_\-storage\_\-iterator} for initializing raw
memory~\cite{iso98:_cpp_final_draft_standard}.

Despite the many iterators supplied by the Standard Library, many
obvious iterators are missing, and creating new iterator types is
still a common task for \Cpp\ programmers. The literature documents
several of these, for example
\code{line\_iterator}~\cite{austern99:_gener_progr_stl}
\code{Constant\_iterator}~\cite{koenig97:_rumin_cpp}. The iterator
abstraction is so powerful, however, that we expect programmers will
always invent new iterator types.

\subsection{Adaptors}

Because iterators combine traversal, indirection, and type exposure,
it is common to want to adapt one iterator to form a new one. This
strategy allows one to reuse some of original iterator's axes of
variation while redefining others. For example, the Standard provides
\reverseiterator{}, which adapts any \stlconcept{BidirectionalIterator}
by inverting its direction of traversal. 

As with plain iterators, iterator adaptors defined outside the
Standard have become commonplace in the literature:\begin{itemize}

\item \code{Checked\_iter}~\cite{stroustrup00:_cpp_prog_lang} adds
bounds-checking to an existing iterator.

 \item The iterators of the View Template
Library~\cite{TMPW00:Weiser}, which adapts containers, are themselves
adaptors over the underlying iterators.

 \item smart iterators~\cite{becker98:_smart_iterators},
which adapt an iterator's dereferencing behavior by applying a
function object to the object being referenced and returning the
result.

 \item Custom iterators~\cite{TMPW00:Baus},
in which a variety of adaptor types are enumerated.

% Jeremy, I don't know what to say about these two. Can you fill it in?
 \item compound iterators~\cite{alexandrescu98:_compound_iters}

 \item Several iterators from the MTL~\cite{siek99:_scitools}.

\end{itemize}

\section{The Boost Iterator Adaptor Library}

% We need an intro here (do we?), but I don't think the text below
% fits in. Suggestions?

% For an iterator to be usable with the Standard algorithms (and other
% generic algorithms), it must fulfill the Standard requirements for an
% iterator type, which range from the few requirements of an
% \stlconcept{InputIterator} to the many requirements of a
% \stlconcept{RandomAccessIterator}. Implementing an iterator class that
% meets these requirements is a tedious and error-prone task despite the
% fact that most iterators are conceptually simple. The Boost Iterator
% Adaptor Library addresses these problems.

\subsection{Overall Design}

To automate this repetitive work, one would need a generator of new
iterator types that can accomodate all the ways in which iterators
vary. One could then make new iterators with relative ease, specifying
the parts that matter and letting the library do the rest. To that
end, the library provides a fully-generalized iterator called
\iteratoradaptor{}. The \iteratoradaptor\ class template adapts a
\code{Base} type, (usually an iterator), to produce a new adapted
iterator type.\footnote{ The term``\code{Base}'' is not meant to imply
the use of inheritance. We have followed the lead of the standard
library, which provides a \code{base()} function to access the
underlying iterator object of a \reverseiterator\ adaptor.}

\subsection{Core Elements of the Concept}

The first step in designing such a generalized Model is to identify
the core elements of its interface. We have identified the following
core behaviors for iterators:\begin{itemize}
 \item dereferencing
 \item incrementing
 \item decrementing
 \item equality comparison
 \item random-access motion
 \item distance measurement
 \item ordered comparison
%% Yikes, Jeremy! I think that including both less and distance in the
%% design might be a design mistake. Doesn't that introduce redundancy?
%% Shouldn't operator<() be implemented in terms of distance?
\end{itemize}

In addition to the behaviors listed above, the core interface elements
include the associated types exposed through
\iteratortraits{}: \valuetype{}, \code{reference}, \code{pointer}, and
\iteratorcategory{}. The library supports two ways of specifying
these: as traditional and also as \emph{named} template parameters
(described below), and uses a system of smart defaults which in most
cases reduces the number of these types that must be specified.

\subsection{From Building Models to Building Adaptors}

A generalized iterator is useful, but a generalized iterator
\emph{adaptor} would be even more useful. One could then build
specialized adaptors to generate new families of iterator instances
based on existing iterators. In the Boost Iterator Adaptor Library,
the \iteratoradaptor\ class template plays the roles of both Adaptor
and Model. The behaviors of \iteratoradaptor{} instances are supplied
through a policies class~\cite{alexandrescu01:_modern_cpp_design}
which allows allows users to specialize adaptation. Users go beyond
generating new iterator types to easily generating new iterator
adaptor families.

The library contains several examples of specialized adaptors which
were quickly implemented using \iteratoradaptor{}:\begin{itemize}

 \item Indirect Iterator Adaptor, which iterates over iterators, pointers, or
smart pointers and applies an extra level of dereferencing.

 \item Reverse Iterator Adaptor, which inverts the direction of a
\code{Base} iterator's motion.

 \item Transform Iterator Adaptor, which applies a user-defined
function object to the underlying values when dereferenced. We will
show how this adaptor is implemented below.

 \item Projection Iterator Adaptor, which is similar to Transform
Iterator Adaptor except that when dereferenced it returns by-reference
instead of by-value.

 \item Filter Iterator Adaptor, which provides a view of an iterator
 range in which some elements of the underlying range are skipped.

 \item Counting Iterator Adaptor, which adapts any incrementable type
(e.g. integers, iterators) so that incrementing/decrementing the
adapted iterator and dereferencing it produces successive values of
the \code{Base} type.

 \item Function Output Iterator Adaptor, which makes it easier to
create custom output iterators.

\end{itemize}

Based on the examples in the library, users have generated many new
adaptors, among them a permutation adaptor which applies some
permutation to a \stlconcept{RandomAccessIterator}, and a strided
adaptor, which adapts a \stlconcept{RandomAccessIterator} by
multiplying its unit of motion by a constant factor.

\section{The Boost \iteratoradaptor\ Class Template}

The \iteratoradaptor\ class template simplifies the creation
of iterators by automating the implementation of redundant operators
and delegating functions and by taking care of the complex details of
iterator implementation.

The central design feature of \iteratoradaptor\ is 
parameterization by an iterator policies class. The policies class is
the primary communication mechanism between the iterator implementer
and the \iteratoradaptor{}; it specifies how the new iterator
type is behaves. Unlike the policy classes
in~\cite{alexandrescu01:_modern_cpp_design}, we group several policies
into a single class as this proved more convenient for iterator
implementation.

\subsection{Iterator Policies Class}

The following example shows how to implement the policies class for a transform
iterator adaptor: an iterator that applies some function to the value returned
by dereferencing the base iterator.  The
\code{transform\_\-iterator\_\-policies} class is templated on the function
object type, and a function object is stored as a data member of the policies
class. When adapting an underlying iterator, it is easiest to store any extra state
needed by the resulting adapted iterator in the policies class rather than
incorporating it into the \code{Base} type because \iteratoradaptor\
provides so many useful defaults when the \code{Base} type is an iterator.

The policies class inherits from
\code{default\_\-iterator\_\-policies}, which delegates all other
operations to the base iterator. The main event of the
\code{transform\_\-iterator\_\-policies} class is the
\code{dereference()} member function, which simply applies the
function to the dereferenced value. The base iterator object is the
second argument to the \code{dereference()} function. The iterator
type is a template parameter to allow this policy class to be used
with any base iterator type.\footnote{The term``\code{BaseIterator}''
here is meant to denote that the \code{Base} type is expected to be an
iterator.}

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction>
  struct transform_iterator_policies : public default_iterator_policies
  {
    transform_iterator_policies() { }
    transform_iterator_policies(const AdaptableUnaryFunction& f)
      : m_f(f) { }

    template <class Reference, class BaseIterator>
    Reference dereference(type<Reference>, const BaseIterator& i) const
      { return m_f(*i); } // apply the function and return the result

    AdaptableUnaryFunction m_f;
  };
\end{verbatim}
}

The \code{type<Reference>} parameter is used to convey the appropriate return
type to the \code{dereference()} function. This method is perhaps not the most
elegant, but it was the most portable solution.\footnote{It would have been more
elegant to rely on the caller for explicit specification of the \code{Reference}
template argument as in
\code{policies.dereference<reference\_type>(base\_iterator)}, but that approach
proved not to to be portable to all of the targeted compilers.}

A policies class is required to have a default constructor because the
\iteratoradaptor\ has an instance of the policies class as a
data member, and iterators are required to have default constructors
thereby requiring the policies class to also have a default
constructor.

With the policies class complete, the iterator implementer is almost
finished: and only eleven lines of code have been written. The code
consists of little more than the main idea of the transform iterator,
applying a function to the result of dereferencing the base iterator.
Next we will take a closer look at the
\code{default\_\-iterator\_\-policies} class and then in
\S\ref{sec:iter-type-generator} we will show how the transform
iterator type is constructed using \iteratoradaptor{}.


\subsection{Default Iterator Policies Class}

The \code{default\_\-iterator\_\-policies} class is the mechanism that
automatically delegates operator implementations to the base iterator,
freeing the iterator implementer from the tedious task of writing
delegating functions. As above, an iterator policies class inherits
from this class and overrides any functions that should not be
delegated. The \code{default\_\-iterator\_\-policies} class also
serves as an example of the iterator policies interface. There are
seven member functions corresponding to the core iterator operations
and an \code{initialize()} function which provides a hook for
customized iterator construction.

{\footnotesize
\begin{verbatim}
namespace boost {
  struct default_iterator_policies
  {
    template <class Base>
    void initialize(Base&) { }

    template <class Reference, class Base>
    Reference dereference(type<Reference>, const Base& x) const
      { return *x; }

    template <class Base>
    void increment(Base& x) { ++x; }

    template <class Base>
    void decrement(Base& x) { --x; }

    template <class Base, class Difference>
    void advance(Base& x, Difference n) { x += n; }

    template <class Difference, class Base1, class Base2>
    Difference distance(type<Difference>, const Base1& x,
                        const Base2& y) const { return y - x; }

    template <class Base1, class Base2>
    bool equal(const Base1& x, const Base2& y) const
      { return x == y; }

    template <class Base1, class Base2>
    bool less(const Base1& x, const Base2& y) const
      { return x < y; }
  };
} // namespace boost
\end{verbatim}
}


\subsection{Iterator Type Generator}
\label{sec:iter-type-generator}

With the policy class for the transform iterator complete, the next
step is to use the \iteratoradaptor\ template to construct the
actual iterator type. The best way to package the construction of the
transform iterator is to create a \emph{type generator}, which is a
class template whose sole purpose is to simplify the instantiation of
some other complicated class template. It fulfills the same need as a
template typedef would if that were part of the \Cpp\ language.  The
first template parameter to the generator is the type of the function
object and the second is the base iterator type.  The following code
shows the type generator for the transform iterator.

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction, class BaseIterator>
  struct transform_iterator_generator
  {
    typedef typename AdaptableUnaryFunction::result_type val_t;
  public:
    typedef iterator_adaptor<BaseIterator, 
      transform_iterator_policies<AdaptableUnaryFunction>,
      iterator_category_is<std::input_iterator_tag>, 
      value_type_is<val_t>, reference_is<val_t> > type;
  };
\end{verbatim}
}

We use \iteratoradaptor\ to define the transform iterator type
as a nested \code{typedef} inside the
\code{transform\_\-iterator\_\-generator} class. The first parameter
to \iteratoradaptor\ is the base iterator type and the second
is the policies class. The remaining parameters specify the iterators
associated types and are given as \emph{named parameters}.  We will
discuss this technique in \S\ref{sec:named-template-parameters}.

The \iteratorcategory\ is set to
\code{std::input\_\-iterator\_\-tag} because the function object may
return by-value. For the same reason the \code{reference} type (which
will be the return type of \code{operator*}) is set to \code{val\_t}
(and not \code{val\_t\&}). There are two parameters that are left out:
the \code{pointer} type defaults to \code{value\_type*} and the
\differencetype{} defaults to the \differencetype{} of
the base iterator.

It is tempting to create a \code{transform\_\-iterator} by deriving
from \iteratoradaptor\ (as an alternative to using the
generator).  This approach does not work, for example, because the
return type of \code{operator++} of an iterator is required to be the
same iterator type, but in this case the return type would be
\iteratoradaptor\ and not \code{transform\_\-iterator}.

%It
%would be possible to arrange for using inheritance by applying the
%Barton and Nackman trick, but we felt that design 

\subsection{Iterator Object Generator}
\label{sec:iter-object-generator}

The next question is how users of the transform iterator will
construct the iterator. The \iteratoradaptor\ class has the
following constructor.

{\footnotesize
\begin{verbatim}
  iterator_adaptor(const Base& it, const Policies& p = Policies())
\end{verbatim}
}

It would be cumbersome for the user to call this constructor since
they would have to separately construct a policies object and then the
iterator object. We therefore recommend that iterator implementers
create an \emph{object generator} function for their iterator. The
following is the generator function for the transform iterator
adaptor.\footnote{
    There is precedent in the standard for calling such
an object generator, simply ``\code{transform\_iterator()}''
(e.g. \code{std::back\_inserter}), but also for the more explicit
\code{make\_} prefix (e.g. \code{std::make\_pair()}) and occasionally
for using the simple name for the adaptor type itself
(e.g. \code{std::reverse\_iterator}).  In the end, the authors decided
that explicit was better than implicit.  }

{\footnotesize
\begin{verbatim}
  template <class AdaptableUnaryFunction, class BaseIterator>
  typename transform_iterator_generator<
      AdaptableUnaryFunction, BaseIterator>::type
  make_transform_iterator(BaseIterator base,
      const AdaptableUnaryFunction& f = AdaptableUnaryFunction())
  {
    typedef typename transform_iterator_generator<AdaptableUnaryFunction,
      BaseIterator>::type result_t;

    transform_iterator_policies<AdaptableUnaryFunction> policies(f);

    return result_t(base, policies);
  }
\end{verbatim}
}

An alternative solution to using object generating functions would be
to have a constructor in \iteratoradaptor\ that takes arbitrary
arguments (the constructor would be templated). The arguments would
then be passed as a heterogeneous value list~\cite{TMPW00:Eisenecker}
to the policies class. This would remove the need for object
generating functions but would increase the complexity of the
implementation and the compile time. For a low-level component such as
an iterator adaptor we felt that simplicity and compile-time were more
important than implementer convenience.

\subsection{Example Use of the Transform Iterator Adaptor}

This example shows how a transform iterator can be used to
negate the numbers over which it iterates.

{\footnotesize
\begin{verbatim}
  #include <functional>
  #include <algorithm>
  #include <iostream>
  #include <boost/iterator_adaptors.hpp>
  int main(int, char*[])
  {
    int x[] = { 1, 2, 3, 4, 5, 6, 7, 8 };
    const int N = sizeof(x)/sizeof(int);
    std::cout << "negating the elements of the array:" << std::endl;
    std::copy(
        boost::make_transform_iterator(x, std::negate<int>()),
        boost::make_transform_iterator(x + N, std::negate<int>()),
        std::ostream_iterator<int>(std::cout, " "));
    std::cout << std::endl;
    return 0;
  }
\end{verbatim}
}

\noindent This output is: 
{\footnotesize
\begin{verbatim}
-1 -2 -3 -4 -5 -6 -7 -8
\end{verbatim}
}

\section{The Policy Adaptor Design Pattern}

The Iterator Adaptor Library illustrates how a generalized Model
(\iteratoradaptor{}) of a Concept family (iterators) combined with
default policy delegation allows users to easily build new Models and
behavioral adaptors for existing Models. We can capture this strategy
in the Policy Adaptor design pattern:\footnote{This is not quite the
same as the Policy Class pattern which has been discussed previously
in the literature~\cite{alexandrescu01:_modern_cpp_design}. The
construction of an adaptor which can easily transforms existing Models
into new ones is the key difference}\begin{itemize}

% Jeremy, can we get a numbered list here?
 \item First, identify the core elements of the Adaptor Concept's
 public interface. In our case, the Adaptor Concept is Iterator.

 \item then, encapsulate core elements of the Concept family in a
Policies Concept.

 \item Write a default policies class which delegates behavior to the
public interface of the Adaptor Concept. This is the mechanism that
supplies default adaptation behavior.

 \item build an Adaptor class template parameterized on Policies. The
Adaptor should be a generalized model of the Adaptor Concept,
providing the public interface, but delegating functionality to the
policies class.

 \item Store a member of the Policies parameter in the Adaptor
template so that users can store additional data while taking
advantage of default behavior delegation.

\end{itemize}

While the This pattern has not yet been widely tested for
applicability, we believe it will be useful for modelling any Concept
which varies along several axes and contains significant
redundancy. 

% In addition, large number of iterator adaptors are now in use:
% iterators that  that conforms to the Conceptual
% requirements of its iterator category


\section{The Iterator Implementation Generator}

\subsection{Redundant Operators}

Perhaps the most obvious reason that implementing an iterator can
be tedious is that there are lots of redundant operators.  That is,
there are many operators that can be trivially defined in terms of
other operators. For example, the postfix \code{operator++(int)} is often best
implemented in terms of prefix \code{operator++()} as shown below.

{\footnotesize
\begin{verbatim}
  class iter {
    // ...
    iter& operator++() { /* ... */ return *this; }
    iter operator++(int) { iter tmp(*this); ++*this; return tmp; }
  };
\end{verbatim}
}

For a full \stlconcept{RandomAccessIterator}, there are a total of 17
operators. 7 of the operators are fundamental while the other 10 are
redundant.

% 7 core operations
% 10 derived operations
 
% \code{operator->}
% \code{operator[]}
% \code{operator++(int)},
% \code{operator--(int)},
% \code{operator-=},
% \code{operator+},
% \code{operator!=},
% \code{operator>}, 
% \code{operator<=},
% \code{operator>=}


\subsection{Delegation of Operators and Type Definitions}

An iterator adaptor used to adapt an underlying iterator type often
changes the meaning of one or two operators while leaving the rest of
the operators defined in the same way as in the base iterator.  This
is typically implemented with delegating functions.\footnote{Although
one might normally consider parametrized inheritance for cases where
many functions must be forwarded, that is not possible for a
generalized iterator adaptor because the underlying type may be a
pointer} The following example shows an excerpt from an
\code{indirect\_iterator} adaptor, which takes an iterator over
pointers or smart-pointers and creates an iterator over the things
pointed to. The \code{operator*} and \code{operator->} are changed to
dereference twice but all the other operators stay the same. Writing
all of the delegating functions for the \code{indirect\_iterator} is a
tedious job.

{\footnotesize
\begin{verbatim}
  template <class Base> class indirect_iterator {
  public:
    // Adapt the meaning of dereference
    reference operator*() const {
      return **iter; // dereference twice
    }
    // a ``redundant'' operator
    pointer operator->() const { return &this->operator*(); } % dwa -- changed for clarity. I don't think the review comment was correct.
    // Delegating the implementation to the underlying iterator.
    indirect_iterator& operator++() { ++iter; return *this; }
    indirect_iterator& operator--() { --iter; return *this; }
    // delegate for all the other operators...
  private:
    Base iter;
  };
\end{verbatim}
}

% I think it would be better to use reverse_iterator as an example
% here, because it delegates more types than indirect_iterator does.
% But reverse_iterator doesn't delegate many operators... it changes
% the meaning of all of them. I wonder if there's a good example
% for both operators and typedefs.
A standard-conforming iterator must either come with a specialization
of \code{std::iterator\_\-traits<>} or it must define five nested
types: \valuetype{}, \code{reference}, \code{pointer},
\differencetype{}, and \iteratorcategory{}. In the
example above, the last two would be delegated to the \code{Base}
iterator type. For many iterator adaptors, all five must be delegated.

\subsection{Iterator Implementation Complexities}

In addition to the tedious aspects of iterator implementation, there
are some complexities that trip up even the most experienced of
programmers. Ideally, an iterator implementer should not have to worry
about these details.

\subsubsection{Constant/Mutable Iterator Interactions}
\label{sec:constant-mutable-iterations}

Iterators over containers and other sequences of stored objects
usually come in pairs: a constant iterator type and a mutable iterator
type. It is desirable to allow the constant and mutable iterators to
interoperate through comparison and
subtraction. For example, suppose
that you are implementing a container type \code{C}. Then you ought to
define the following four versions of \code{operator==}, along with
corresponding versions of \code{operator!=}, and (for
\stlconcept{RandomAccessIterator}), operators \code{<}, \code{>},
\code{<=}, \code{>=}, and \code{-}.

{\footnotesize
\begin{verbatim}
  bool operator==(const C::iterator& x, const C::iterator& y);
  bool operator==(const C::const_iterator& x, const C::iterator& y);
  bool operator==(const C::iterator& x, const C::const_iterator& y);
  bool operator==(const C::const_iterator& x, const C::const_iterator& y);
\end{verbatim}
}

Implementers often forget to define the operators for constant/mutable
iterator interaction. In addition, iterator adaptors applied to these
kinds of iterators should propagate the ability to interact. For
example, a reverse iterator adaptor applied to \code{C::iterator} and
\code{C::const\_iterator} should result in mutable and constant reverse iterator types that
have the same ability to interact as the \code{Base} iterators do.

\subsubsection{Constant/Mutable Iterator Code Duplication}

% Is this section really worthwhile? It was confusing to read until I
% finally figured out what you were driving at. Who makes this conceptual mistake?
% It may not be worthwhile... though I've seen other grad students make
% this mistake, and the TMPW2000 VTL paper contains this mistake.

The implementations of the constant and mutable versions of an
iterator typically differ only in their \code{reference} and
\code{pointer} types. Therefore it is desirable to merge the two
iterator classes into a single class template with the
\code{reference} and \code{pointer} types as template parameters.

Some care must be taken when merging the constant and mutable
iterators.  One common mistake is that the programmer will confuse the
ideas of a \code{const} iterator object and a \emph{constant
iterator}. Such a misunderstanding can, for example, lead to an
iterator class template that has two versions of \code{operator*}, one
that is a \code{const} member function and one that is not.
 
{\footnotesize
\begin{verbatim}
  // this is a mistake
  reference operator*();
  const_reference operator*() const;
\end{verbatim}
}

There should be only one \code{operator*} that returns the
\code{reference} type and the member function should be \code{const} since
dereferencing an iterator does not change the state of the iterator
object itself (unlike \code{operator++}).

{\footnotesize
\begin{verbatim}
  // this is right
  reference operator*() const;
\end{verbatim}
}


\subsubsection{Input Iterators and \code{operator->}}
\label{sec:operator-arrow}

When creating an iterator adaptor that produces an
\stlconcept{InputIterator} some extra care must be taken in the
implementation of \code{operator->}. Remember that an input iterator
need not iterate over stored objects: it can manufacture new objects
when it is dereferenced as is the case for
\code{std::istream\_iterator}. If the iterator's \valuetype\ is
of class type, we need to support \code{operator->}. Since the result
of using \code{operator->} must produce a true pointer even when
dereferencing the iterator does not yield a true reference type, we
need a \code{const} lvalue to which a pointer can be formed.  In
\S\ref{sec:operator-arrow} we show how this can be accomplished.


\subsubsection{The Return Type of \code{operator[]} for Adaptors}
\label{sec:operator-bracket}

The \Cpp\ Standard specifies that the return type of \code{operator[]}
of a random access iterator must be ``convertible to \code{T}''.  This
is a rather lenient requirement since \code{operator*} is required to
return the exact type \code{T\&}, and one might think that
\code{operator[]} and \code{operator*} should be same in this respect.
The \Cpp\ Standards Committee is currently debating as to whether the
random access iterator requirements should be changed.

To complicate the matter, returning \code{T\&} from \code{operator[]}
causes a run-time error in a certain class of situations. We will
discuss this in detail in \S\ref{sec:op-bracket-impl}.


% Automatic implementation of redundant operators
% Default delegation to adapted iterator

% complexities: 
%   const-non const interaction
%   const/mutable iterator distinction
%   input iterator \code{operator->}

\section{The Implementation of \iteratoradaptor{}}

The outline for the implementation of the \iteratoradaptor\
class template is as follows. In the next few sections we will discuss
aspects of the implementation in more depth, including how the
problems discussed in the introduction were solved.

{\footnotesize
\begin{verbatim}
namespace boost {
  template <class Base, class Policies, 
	    class Value = default_argument,
	    class Reference = default_argument,
	    class Pointer = default_argument,
	    class Category = default_argument,
	    class Distance = default_argument>
  struct iterator_adaptor {
    // Deduce iterator associated types (value_type, etc.) from the
    // named template parameters, and resolve any defaults.
  public:
    // Core operators, delegate to policies class.
    // Redundant operators, implemented in terms of the core operators.
  private:
    // If the policies class is empty, compressed_pair applies the
    // empty-base class optimization to conserve space. The base is
    // ``first'' and the policies are ``second''.
    compressed_pair<Base, Policies> m_iter_p;

    Policies& policies() { return m_iter_p.second(); }
    Base& base() { return m_iter_p.first(); }
    // and similarly for const...
  };
  // Core binary operators.
  // Redundant binary operators.
} // namespace boost
\end{verbatim}
}

\subsection{Deducing the Associated Types}

Iterators have five associated types: \valuetype{},
\code{reference}, \code{pointer}, \iteratorcategory{}, and
\differencetype{}. Each of these types must either be supplied
by the user, using the named parameter technique described below in
\S\ref{sec:named-template-parameters}, or a default must be computed
for the type.

\subsubsection{Defaults for the Associated Types}

Because an iterator has so many type parameters, the order and
semantics of the associated type parameters was carefully chosen so
that users would be able to use as many defaults as possible. The list
of associated types begins with the most fundamental element, the
iterator's \valuetype{}. If no \code{Value} parameter is supplied,
the \code{Base} type is assumed to be an iterator, and the adapted
iterator takes its \valuetype\ from the \code{Base}
iterator's \iteratortraits{}. However, if the \code{Value} parameter \emph{is} supplied,
an adjustment is made which allows the user to more easily create a
constant iterator: if the \code{Value} parameter is \code{const T},
the \valuetype\ will just be \code{T}.Perhaps
strangely, a constant iterator's \valuetype\ should never be
\code{const}, because it would prevent algorithms from declaring
modifiable temporary objects which are copied from dereferenced
iterators:

{\footnotesize
\begin{verbatim}
  template <class ForwardIterator>
  typename iterator_traits<ForwardIterator>::value_type
  accumulate(ForwardIterator start, ForwardIterator finish)
  {
      typedef typename
          iterator_traits<ForwardIterator>::value_type value;
      if (start == finish)
          return value();
      value x = *start;
      while (++start != finish)
          x += *start; // error?
      return x;
  }
\end{verbatim}
}

The defaults for the \code{pointer} and \code{reference} types
cooperate with the \code{Value} parameter: if the \code{Value}
parameter is supplied, the \code{pointer} and \code{reference} types
default to simply \code{Value*} and \code{Value\&} respectively
(without the \code{const}-ness stripped). Otherwise, as above the
\code{Base} type is assumed to be an iterator and the \code{pointer}
and \code{reference} types are taken from its
\iteratortraits{}.

Since these defaults correspond to the required relationships between
the \code{reference}, \code{pointer}, \valuetype\ for all
constant and mutable \stlconcept{ForwardIterator}s, it is often
sufficient to supply just the \code{Value} parameter when there is no
\code{Base} iterator with appropriate
\iteratortraits{}.\footnote{The \code{Reference} parameter
precedes the \code{Pointer} parameter because it must be often
customized for \stlconcept{OutputIterator}s and other iterator types
(e.g. \code{std::vector<bool>::iterator}, which uses a proxy
\code{reference}).}

The defaults for the \iteratorcategory{} and \differencetype{} are
straightforward: they are the respective types from the \code{Base}
iterator. These work out well as the final parameters, because one usually wants
all of the capabilities supplied by the iterator being adapted, and it is
difficult to provide more capabilities.

The code used to select the appropriate defaults for the iterator's
associated types used to look something like this:

{\footnotesize
\begin{verbatim}
  // compute default pointer and reference types.
  template <class Iterator,class Value>
  struct iterator_defaults : iterator_traits<Iterator>
  {
     // If the Value parameter is not the same as its default, the
     // user supplied it. 
     static const bool value_type_supplied
      = !is_same<Value,typename iterator_traits<Iterator>::value_type>::value;

     typedef typename type_if<value_type_supplied,
             Value*,
        // else
              typename iterator_traits<Iterator>::pointer
     >::type pointer;

     typedef typename type_if<value_type_supplied,
             Value*,
        // else
              typename iterator_traits<Iterator>::reference
     >::type reference;
  };

  template <class Base, class Policies, 
      class Value = typename std::iterator_traits<Base>::value_type,
      class Reference = typename iterator_defaults<Base,Value>::reference,
      class Pointer = typename iterator_defaults<Base,Value>::pointer,
      class Category = typename std::iterator_traits<Base>::iterator_category,
      class Distance = typename std::iterator_traits<Base>::difference_type
           >
  class iterator_adaptor
  {
   public:
      typedef Distance difference_type;
      typedef remove_const<Value>::type value_type;
      typedef Pointer pointer;
      typedef Reference reference;
      typedef Category iterator_category;
\end{verbatim}
}

Unfortunately, this strategy can only take us so far. It turns out
that there are plenty of iterators which don't fit neatly into the
system for ordering defaults. For example, the specialized Transform
Iterator Adaptor described earlier
% When we reorganize the paper it may appear later. check this out.
limits the category of its \code{Base} iterator to
\stlconcept{InputIterator}, so the we'd only need to supply the
\valuetype{}, \code{reference}, and \iteratorcategory\ if
the \code{Category} parameter didn't appear last. Iterators where the
\code{Base} type is not itself an iterator also act this way, since
there are no appropriate \iteratortraits\ from which to derive
the \code{Pointer} and \code{Reference} parameters.

\subsubsection{Named Template Parameters}
\label{sec:named-template-parameters}

Instead of matching arguments to parameters based on order, the
assignment of arguments to parameters can be made explicitly by name, so
the order no longer matters. The Iterator Adaptors library supplies
an appropriately-named wrapper class for each parameter. For example:

{\footnotesize
\begin{verbatim} 
  template <class Value> struct value_type_is {
    typedef value_type_tag tag;
    typedef Value type;
  };
\end{verbatim} 
}

Instead of passing the argument \code{Value} directly to
\iteratoradaptor\ the user passes
\code{value\_type\_is<Value>}. The \iteratoradaptor\ has
five arguments for the associated types, each of which could be used
to specify any of the actual parameters. The
\iteratoradaptor\ must deduce which argument is for which
parameter based on the \code{tag} inside the wrapper.

First we take all of the parameters and place them in a
lisp-style list, using \code{std::pair} for \code{cons}. Each
parameter wrapper has a key/value pair (the \code{tag} and \code{type}
respectively), so we can treat this as an associative list.

{\footnotesize
\begin{verbatim} 
  typedef pair<Param1, pair<Param2, pair<Param3, pair<Param4,
	    pair<Param5, list_end_type> > > > > NamedParamList;
\end{verbatim} 
}

\noindent For each parameter we perform a look-up in the associative
list using a template meta-program utility class named
\code{find\_param}.

{\footnotesize
\begin{verbatim} 
  template <class AssociativeList, class Key>
  struct find_param {
    typedef ... type;
  };
\end{verbatim} 
}

\noindent So, for example, to retrieve the argument for the
\valuetype\ we write the following:

{\footnotesize
\begin{verbatim} 
  typedef typename find_param<NamedParamList, value_type_tag>::type Value;
\end{verbatim} 
}

The result of this look-up will either be the argument specified by the
user, or if there is none, the \code{default\_argument} type. If it is
the default, then a further step is taken to resolve what the default
should be for the parameter. The defaults for some of the parameters
depend on other parameters, so the order in which defaults are
resolved is tailored to respect these dependencies.


\subsection{Core Operators}

The core operators of the \iteratoradaptor\ are implemented by
delegating the work to the policies class. Each core operator invokes
the appropriate policy function and passes in the base
iterator. Sometimes extra type information is also passed in, as is
the case with the \code{reference} type in the implementation of
\code{operator*}.

{\footnotesize
\begin{verbatim}
  reference operator*() const {
    return policies().dereference(type<reference>(), base());
  }
\end{verbatim}
}

The binary operators of the iterator are implemented as free functions
(not member functions) to allow both the left and right hand operands
to be treated symmetrically.  We use separate template parameters for
the two \iteratoradaptor\ arguments. This allows a single
operator to implement all of the combinations of constant/mutable
iterator interactions, avoiding the combinatorial explosion discussed
in \S\ref{sec:constant-mutable-iterations}. Note that we only use a
single \code{Policies} template parameter: this restricts iterator
interaction to those iterators with the same policies class.  This is
not as restrictive as it probably should be, but most iterator
interaction errors will be caught anyway, when the policies are applied
disadvantage to not being restrictive enough is in the kind of error
message the user will see when misusing two unrelated
iterators. Instead of an ``operator not found'' message they will see
an error message from inside the iterator adaptor.

{\footnotesize
\begin{verbatim}
  template <class Base1, class Base2, class Policies, class V1, class V2,
      class R1, class R2, class P1, class P2, class C1, class C2, 
      class D1, class D2>
  bool operator<(
    const iterator_adaptor<Base1,Policies,V1,R1,P1,C1,D1>& x,
    const iterator_adaptor<Base2,Policies,V2,R2,P2,C2,D2>& y)
  {
    return x.policies().less(x.base(), y.base());
  }
\end{verbatim}
}


\subsection{Redundant Operators}

Most of the redundant operators are implemented in a straightforward
way based on the core operators. For example, the \code{operator+} is
implemented in terms of \code{operator+=}.

{\footnotesize
\begin{verbatim}
template <class B, class P, class V, class R, class Ptr,
    class C, class D, class Distance>
iterator_adaptor<B,P,V,R,Ptr,C,D>
operator+(iterator_adaptor<B,P,V,R,Ptr,C,D> p, Distance x)
{
  return p += x;
}
\end{verbatim}
}

The implementation of \code{operator->} and \code{operator[]}, as
alluded to in \S\ref{sec:operator-arrow} and
\S\ref{sec:operator-bracket}, are not straightforward. We discuss them
in the following two sections.


\subsubsection{Implementing \code{operator->} for Input Iterators}
\label{sec:operator-arrow}

As introduced in \S\ref{sec:operator-arrow}, it is difficult to
implement \code{operator->} for input iterators because there may not
be an lvalue from which to form a pointer.

Fortunately, the standard makes a workaround possible: section
13.3.1.2 paragraph 8 describes a seemingly quirky rule that the
\code{->} operator will be applied to the \emph{result} of any call to
\code{operator->}. This is a convenient way to describe the semantics
of ordinary \code{operator->}, which returns a pointer: it just uses
the pointer to perform the usual member dereferencing. It also turns
out to be what we need to make a conforming
\stlconcept{InputIterator}. By making the return type of
\code{operator->} a proxy containing an instance of the iterator's
\valuetype{}, we can eventually form a \code{const} pointer to
the returned temporary:

{\footnotesize
\begin{verbatim}
  template <class T>
  struct operator_arrow_proxy
  {
    operator_arrow_proxy(const T& x) : m_value(x) {}
    const T* operator->() const { return &m_value; }
    T m_value;
  };
\end{verbatim}
}

\noindent The iterator adaptor library uses a small meta-program to
select the appropriate type for the result of an iterator's
\code{operator->}:

{\footnotesize
\begin{verbatim}
  template <class Category, class Value, class Pointer>
  struct operator_arrow_result_generator
  {
    // Is it an input iterator, or something more?
    static bool const is_input_iter
      = is_convertible<Category*, std::input_iterator_tag*>::value
         && !is_convertible<Category*,std::forward_iterator_tag*>::value;

    typedef typename type_if<is_input_iter,
           operator_arrow_proxy<Value>,
      // else
           Pointer
      >::type type;
  };
\end{verbatim}
}

The Boost Type Traits library is used to check whether the iterator's
category is no more refined than \stlconcept{InputIterator}. If so,
the appropriate \code{operator\_arrow\_proxy} is selected.
Convertibility is used as a criterion to allow for user-defined
iterator categories derived from the standard ones.


\subsubsection{Implementation of \code{operator[]}}
\label{sec:op-bracket-impl}

The implementation of \code{operator[]} would be trivial except for
the issue surrounding what the return type should be.  As mentioned in
\S\ref{sec:operator-bracket}, it would be dangerous to make the
\iteratoradaptor\ always return a reference for
\code{operator[]} for there are certain situations in which this can
cause run-time errors.

Suppose the base iterator is reading in elements from a file and
caching each element as a data member of the iterator.

{\footnotesize
\begin{verbatim}
class file_iter {
  T x;
  int pos;
public:
  file_iter(int pos = 0) { x = read_from_file(pos); }
  T& operator*() const { return x; }
  file_iter operator+(int n) const { return file_iter(pos + n); }
  file_iter& operator++() { x = read_from_file(++pos); return *this; }
  // ...
};
\end{verbatim}
}

\noindent The \code{operator*} of this iterator returns a reference to
the data member. Now consider what happens inside the
\code{operator[]} of the adaptor:

{\footnotesize
\begin{verbatim}
template <class BaseIterator> class my_iterator_adaptor {
  BaseIterator iter;
public:
  reference operator[](difference_type n) const {
    return *(iter + n);
  }
 // ...
};
\end{verbatim}
}

\noindent The iterator addition creates a temporary iterator and the
dereference returns a reference to a data member of this temporary,
which is destroyed before \code{operator[]} returns. The result is a
dangling reference.

Boost's \iteratoradaptor\ takes the safe route and returns the
result by-value. This meets the random access iterator requirements of
the Standard, which only says that the return type must be
``convertible to T'',

{\footnotesize
\begin{verbatim}
  value_type operator[](difference_type n) const
    { return *(*this + n); }
\end{verbatim}
}

Under the current \Cpp\ Standard, you cannot assign into the result of
\code{operator[]} applied to a generic random access iterator,
but instead must write \code{*(i + n) = x}.

It would be nice to return by-reference for iterators that can support
it, and by-value for the rest. However, the current
\iteratortraits\ does not provide enough information to make the
choice.

% Jeremy: I didn't agree with this part, so commented it out
% temporarily. I think an iterator which can return by-reference for
% operator* should be allowed to do so, regardless of what it can do
% for operator[]. Let's discuss.

% In addition, the lack of consistency between \code{operator[]}
% and \code{operator*} will be surprising to people. Preferably an
% iterator would either return by-value for both \code{operator*} and
% \code{operator[]} or return by-reference for both. 

The proposal in~\cite{siek01:_improved_iter_cat} would solve this
problem, but of course that will take some time to gain acceptance.


\section{Conclusion}

Constructing iterators and iterator adaptors is a common task for
modern \Cpp\ programming. Despite the conceptual simplicity of most
iterators, implementing \Cpp\ Standard conforming iterators requires a
non-trivial amount of code, some of which is challenging to get right
and a lot of which is tedious. The \iteratoradaptor\ class that
we've presented solves these problem by providing a mechanism
by which the user provides a minimal specification (by way of the
policies class) for the iterator, and then the
\iteratoradaptor\ takes care of most of the implementation
details.

Taking a step back, the design approach was to create a canonical
implementation of a concept (iterator) and then delegate the core
implementation issues to a policies class. This approach can be
applied in situations where there is large family of components that
share the same interface. For example, we plan on applying this design
approach to containers and algebraic types.

\bibliographystyle{abbrv}
\bibliography{refs,tmpw00}

\end{document}
% LocalWords:  Iterator Siek Altra Broadband Florham iterator Adaptor iterators
% LocalWords:  adaptors istream ostream iter MTL InputIterator adaptor const
% LocalWords:  RandomAccessIterator dereference interoperate Implementers tmpw
% LocalWords:  dereferencing adaptor's lvalues iterator's instantiation typedef
% LocalWords:  AdaptableUnaryFunction templated dereferenced lvalue val param
% LocalWords:  parameterization implementers combinatorial InputIterators
% LocalWords:  Convertibility
