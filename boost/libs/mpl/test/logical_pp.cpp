// 1 "C:\\home\\cvs_mplbook\\boost\\libs\\mpl\\test\\logical.cpp"

 
 
 
 
 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/logical.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/or.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/use_preprocessed.hpp" 1




 
 
 
 
 
 
 

 
 
 

 


// 17 "c:/home/cvs_mplbook/boost/boost/mpl/or.hpp" 2





// 1 "c:/home/cvs_mplbook/boost/boost/mpl/bool.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/bool_fwd.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/adl_barrier.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/msvc.hpp" 1




 
 
 
 
 
 
 

 
 
 


 
// 1 "c:/home/cvs_08_may_03/boost/boost/config.hpp" 1
 

 
 
 
 

 

 
 
 
 
 
 




 



 

// 1 "c:/home/cvs_08_may_03/boost/boost/config/user.hpp" 1
 

 
 
 
 

 
 

 
 
 
 

 
 

 
 

 
 

 
 
 

 
 
 

 
 
 

 
 
 
 
 
 

 
 
 
 
 
 
 
 

 
 
 
 
 


 
 
 

 
 
 

 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


// 26 "c:/home/cvs_08_may_03/boost/boost/config.hpp" 2



 

// 1 "c:/home/cvs_08_may_03/boost/boost/config/select_compiler_config.hpp" 1
 

 
 
 
 
 
 

 

 
 

// 27 "c:/home/cvs_08_may_03/boost/boost/config/select_compiler_config.hpp"

 


// 83 "c:/home/cvs_08_may_03/boost/boost/config/select_compiler_config.hpp"

// 31 "c:/home/cvs_08_may_03/boost/boost/config.hpp" 2


 

// 1 "c:/home/cvs_08_may_03/boost/boost/config/compiler/gcc.hpp" 1
 
 
 
 
 
 
 
 
 
 

 

 





// 30 "c:/home/cvs_08_may_03/boost/boost/config/compiler/gcc.hpp"




















 
 
 




 
 
 
 
 




 
 
 


 
 
 






 
 
 



 
 









// 35 "c:/home/cvs_08_may_03/boost/boost/config.hpp" 2



 

// 1 "c:/home/cvs_08_may_03/boost/boost/config/select_stdlib_config.hpp" 1
 

 
 
 
 
 


 

 

 
 
 
 
 

// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/utility" 1 3
 




























// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_config.h" 1 3
 




























 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 


 

 
 
 
 
 
 
 








// 148 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_config.h" 3



// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../mingw32/include/_G_config.h" 1 3
  









typedef          int   _G_int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int  _G_uint8_t __attribute__((__mode__(__QI__)));
typedef          int  _G_int16_t __attribute__((__mode__(__HI__)));
typedef unsigned int _G_uint16_t __attribute__((__mode__(__HI__)));
typedef          int  _G_int32_t __attribute__((__mode__(__SI__)));
typedef unsigned int _G_uint32_t __attribute__((__mode__(__SI__)));
typedef          int  _G_int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int _G_uint64_t __attribute__((__mode__(__DI__)));

__extension__ typedef long long _G_llong;
__extension__ typedef unsigned long long _G_ullong;








typedef long _G_clock_t;
typedef unsigned int _G_dev_t;
typedef _G_llong _G_fpos_t;
typedef int   _G_gid_t;
typedef short _G_ino_t;
typedef unsigned short _G_mode_t;
typedef int   _G_nlink_t;
typedef long _G_off_t;
typedef int _G_pid_t;



typedef int _G_ptrdiff_t;
typedef int _G_sigset_t;



typedef unsigned int _G_size_t;
typedef long _G_time_t;
typedef int   _G_uid_t;
typedef short unsigned int _G_wchar_t;















typedef  int   _G_ssize_t;
typedef unsigned int _G_wint_t;
typedef char * _G_va_list;

















// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 1 3
 

































 


// 47 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3





 


 





 


// 91 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 





 


















 





 

 

// 161 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 

 

// 220 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 




 

// 300 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


// 312 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 

 

// 346 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3






 





















// 86 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../mingw32/include/_G_config.h" 2 3


// 151 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_config.h" 2 3

















// 178 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_config.h" 3



































// 237 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_config.h" 3


// 251 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_config.h" 3



































 
 
 
 


















 
 
// 319 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_config.h" 3






































 
 
 
// 30 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/utility" 2 3

// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_relops.h" 1 3
 

























 






 

template <class _Tp>
inline bool operator!=(const _Tp& __x, const _Tp& __y) {
  return !(__x == __y);
}

template <class _Tp>
inline bool operator>(const _Tp& __x, const _Tp& __y) {
  return __y < __x;
}

template <class _Tp>
inline bool operator<=(const _Tp& __x, const _Tp& __y) {
  return !(__y < __x);
}

template <class _Tp>
inline bool operator>=(const _Tp& __x, const _Tp& __y) {
  return !(__x < __y);
}

 



 
 
 
// 31 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/utility" 2 3

// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_pair.h" 1 3
 

























 






 

template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;
  pair() : first(_T1()), second(_T2()) {}
  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

};

template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ 
  return __x.first == __y.first && __x.second == __y.second; 
}

template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ 
  return __x.first < __y.first || 
         (!(__y.first < __x.first) && __x.second < __y.second); 
}

template <class _T1, class _T2>
inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)
{
  return pair<_T1, _T2>(__x, __y);
}

 



 
 
 
// 32 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/utility" 2 3




 
 
 
// 20 "c:/home/cvs_08_may_03/boost/boost/config/select_stdlib_config.hpp" 2


// 40 "c:/home/cvs_08_may_03/boost/boost/config/select_stdlib_config.hpp"

 


// 65 "c:/home/cvs_08_may_03/boost/boost/config/select_stdlib_config.hpp"




// 40 "c:/home/cvs_08_may_03/boost/boost/config.hpp" 2


 

// 1 "c:/home/cvs_08_may_03/boost/boost/config/stdlib/sgi.hpp" 1
 
 
 
 
 
 

 

 








 
 
 




 
 
 
// 41 "c:/home/cvs_08_may_03/boost/boost/config/stdlib/sgi.hpp"


 
 
 
 




 
 
 




 
 
 




 
 
 
 





 
 
 



 
 
 

// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/string" 1 3
 




// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/bastring.h" 1 3
 
 

 
 
 
 
 

 
 
 
 

 
 
 

 
 
 
 
 

 
 





//pragma interface


// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/cstddef" 1 3
 
 



// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 1 3
 

































 







 

 






 


 





 


// 91 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 





 


















 





 

 





















typedef int ptrdiff_t;









 




 

 


































typedef unsigned int size_t;





















 




 





























 




















































typedef unsigned int  wint_t;




 

 

// 346 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3






 













 







// 6 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/cstddef" 2 3


// 35 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/bastring.h" 2 3

// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/straits.h" 1 3
 
 

 
 
 
 
 

 
 
 
 

 
 
 

 
 
 
 
 

 
 





 
//pragma interface "std/straits.h"




extern "C++" {
template <class charT>
struct string_char_traits {
  typedef charT char_type;  

   

  static void assign (char_type& c1, const char_type& c2)
    { c1 = c2; }
  static bool eq (const char_type& c1, const char_type& c2)
    { return (c1 == c2); }
  static bool ne (const char_type& c1, const char_type& c2)
    { return !(c1 == c2); }
  static bool lt (const char_type& c1, const char_type& c2)
    { return (c1 < c2); }
  static char_type eos () { return char_type(); }  
  static bool is_del(char_type a) { return 0; }
   
  
   

  static int compare (const char_type* s1, const char_type* s2, size_t n)
    {
      size_t i;
      for (i = 0; i < n; ++i)
	if (ne (s1[i], s2[i]))
	  return lt (s1[i], s2[i]) ? -1 : 1;

      return 0;
    }
    
  static size_t length (const char_type* s)
    {
      size_t l = 0;
      while (ne (*s++, eos ()))
	++l;
      return l;
    }

  static char_type* copy (char_type* s1, const char_type* s2, size_t n)
    {
      for (; n--; )
	assign (s1[n], s2[n]);
      return s1;
    }

  static char_type* move (char_type* s1, const char_type* s2, size_t n)
    {
      char_type a[n];
      size_t i;
      for (i = 0; i < n; ++i)
	assign (a[i], s2[i]);
      for (i = 0; i < n; ++i)
	assign (s1[i], a[i]);
      return s1;

    }

  static char_type* set (char_type* s1, const char_type& c, size_t n)
    {
      for (; n--; )
	assign (s1[n], c);
      return s1;
    }
};

class istream;
class ostream;
// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/cctype" 1 3
 
 



// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/ctype.h" 1 3
 




























 
// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/_mingw.h" 1 3
 
























 
























    

















// 31 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/ctype.h" 2 3





// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 1 3
 

































 


// 47 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3





 


 





 


// 91 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 





 


















 





 

 


// 156 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 




 

 


// 218 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3




 




 


// 298 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3
















 

 

// 346 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3






 













 







// 36 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/ctype.h" 2 3




 


















extern "C" {


int	isalnum(int);
int	isalpha(int);
int	iscntrl(int);
int	isdigit(int);
int	isgraph(int);
int	islower(int);
int	isprint(int);
int	ispunct(int);
int	isspace(int);
int	isupper(int);
int	isxdigit(int);


int	_isctype (int, int);


int	tolower(int);
int	toupper(int);

 




int	_tolower(int);
int	_toupper(int);






 



   __attribute__((dllimport)) extern  int __mb_cur_max;







typedef wchar_t wctype_t;



 
int	iswalnum(wint_t);
int	iswalpha(wint_t);
int	iswascii(wint_t);
int	iswcntrl(wint_t);
int	iswctype(wint_t, wctype_t);
int	is_wctype(wint_t, wctype_t);	 
int	iswdigit(wint_t);
int	iswgraph(wint_t);
int	iswlower(wint_t);
int	iswprint(wint_t);
int	iswpunct(wint_t);
int	iswspace(wint_t);
int	iswupper(wint_t);
int	iswxdigit(wint_t);

wchar_t	towlower(wchar_t);
wchar_t	towupper(wchar_t);

int	isleadbyte (int);


int	__isascii (int);
int	__toascii (int);
int	__iscsymf (int);	 
int	__iscsym (int);		 


int	isascii (int);
int	toascii (int);
int	iscsymf (int);
int	iscsym (int);





}






// 6 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/cctype" 2 3


// 105 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/straits.h" 2 3

// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/cstring" 1 3
 
 




// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/string.h" 1 3
 




























 


 






// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 1 3
 

































 


// 47 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3





 


 





 


// 91 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 





 


















 





 

 


// 156 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 




 

 


// 218 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3




 




 


// 298 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3
















 

 

// 346 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3






 













 







// 40 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/string.h" 2 3






extern "C" {


 


void*	memchr (const void*, int, size_t);
int 	memcmp (const void*, const void*, size_t);
void* 	memcpy (void*, const void*, size_t);
void*	memmove (void*, const void*, size_t);
void*	memset (void*, int, size_t);
char*	strcat (char*, const char*);
char*	strchr (const char*, int);
int	strcmp (const char*, const char*);
int	strcoll (const char*, const char*);	 
char*	strcpy (char*, const char*);
size_t	strcspn (const char*, const char*);
char*	strerror (int);  
char*	_strerror (const char *);
size_t	strlen (const char*);
char*	strncat (char*, const char*, size_t);
int	strncmp (const char*, const char*, size_t);
char*	strncpy (char*, const char*, size_t);
char*	strpbrk (const char*, const char*);
char*	strrchr (const char*, int);
size_t	strspn (const char*, const char*);
char*	strstr (const char*, const char*);
char*	strtok (char*, const char*);
size_t	strxfrm (char*, const char*, size_t);


 


void*	_memccpy (void*, const void*, int, size_t);
int 	_memicmp (const void*, const void*, size_t);
char* 	_strdup (const char*);
int	_strcmpi (const char*, const char*);
int	_stricmp (const char*, const char*);
int	_stricoll (const char*, const char*);
char*	_strlwr (char*);
int	_strnicmp (const char*, const char*, size_t);
char*	_strnset (char*, int, size_t);
char*	_strrev (char*);
char*	_strset (char*, int);
char*	_strupr (char*);
void	_swab (const char*, char*, size_t);

 


unsigned char*	_mbschr (unsigned char*, unsigned char*);
unsigned char*	_mbsncat (unsigned char*, const unsigned char*, size_t);
unsigned char*	_mbstok (unsigned char*, unsigned char*);


int  _strncoll(const char*, const char*, size_t);
int  _strnicoll(const char*, const char*, size_t);




 


wchar_t* wcscat (wchar_t*, const wchar_t*);
wchar_t* wcschr (const wchar_t*, wchar_t);
int	wcscmp (const wchar_t*, const wchar_t*);
int	wcscoll (const wchar_t*, const wchar_t*);
wchar_t* wcscpy (wchar_t*, const wchar_t*);
size_t	wcscspn (const wchar_t*, const wchar_t*);
 
size_t	wcslen (const wchar_t*);
wchar_t* wcsncat (wchar_t*, const wchar_t*, size_t);
int	wcsncmp(const wchar_t*, const wchar_t*, size_t);
wchar_t* wcsncpy(wchar_t*, const wchar_t*, size_t);
wchar_t* wcspbrk(const wchar_t*, const wchar_t*);
wchar_t* wcsrchr(const wchar_t*, wchar_t);
size_t	wcsspn(const wchar_t*, const wchar_t*);
wchar_t* wcsstr(const wchar_t*, const wchar_t*);
wchar_t* wcstok(wchar_t*, const wchar_t*);
size_t	wcsxfrm(wchar_t*, const wchar_t*, size_t);


 



 


wchar_t* _wcsdup (wchar_t*);
int	_wcsicmp (const wchar_t*, const wchar_t*);
int	_wcsicoll (const wchar_t*, const wchar_t*);
wchar_t* _wcslwr (wchar_t*);
int	_wcsnicmp (const wchar_t*, const wchar_t*, size_t);
wchar_t* _wcsnset (wchar_t*, wchar_t, size_t);
wchar_t* _wcsrev (wchar_t*);
wchar_t* _wcsset (wchar_t*, wchar_t);
wchar_t* _wcsupr (wchar_t*);


int  _wcsncoll(const wchar_t*, const wchar_t*, size_t);
int  _wcsnicoll(const wchar_t*, const wchar_t*, size_t);









 





void*	memccpy (void*, const void*, int, size_t);
int	memicmp (const void*, const void*, size_t);
char*	strdup (const char*);
int	strcmpi (const char*, const char*);
int	stricmp (const char*, const char*);
int	strcasecmp (const char*, const char*);
int	stricoll (const char*, const char*);
char*	strlwr (char*);
int	strnicmp (const char*, const char*, size_t);
int	strncasecmp (const char*, const char*, size_t);
char*	strnset (char*, int, size_t);
char*	strrev (char*);
char*	strset (char*, int);
char*	strupr (char*);

void	swab (const char*, char*, size_t);


 
int	wcscmpi	(const wchar_t*, const wchar_t*);
wchar_t* wcsdup (wchar_t*);
int	wcsicmp (const wchar_t*, const wchar_t*);
int	wcsicoll (const wchar_t*, const wchar_t*);
wchar_t* wcslwr (wchar_t*);
int	wcsnicmp (const wchar_t*, const wchar_t*, size_t);
wchar_t* wcsnset (wchar_t*, wchar_t, size_t);
wchar_t* wcsrev (wchar_t*);
wchar_t* wcsset (wchar_t*, wchar_t);
wchar_t* wcsupr (wchar_t*);






}






// 7 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/cstring" 2 3


// 94 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/cstring" 3



// 106 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/straits.h" 2 3


struct string_char_traits <char> {
  typedef char char_type;

  static void assign (char_type& c1, const char_type& c2)
    { c1 = c2; }
  static bool eq (const char_type & c1, const char_type& c2)
    { return (c1 == c2); }
  static bool ne (const char_type& c1, const char_type& c2)
    { return (c1 != c2); }
  static bool lt (const char_type& c1, const char_type& c2)
    { return (c1 < c2); }
  static char_type eos () { return 0; }
  static bool is_del(char_type a) { return isspace(a); }

  static int compare (const char_type* s1, const char_type* s2, size_t n)
    { return memcmp (s1, s2, n); }
  static size_t length (const char_type* s)
    { return strlen (s); }
  static char_type* copy (char_type* s1, const char_type* s2, size_t n)
    { return (char_type*) memcpy (s1, s2, n); }
  static char_type* move (char_type* s1, const char_type* s2, size_t n)
    { return (char_type*) memmove (s1, s2, n); }
  static char_type* set (char_type* s1, const char_type& c, size_t n)
    { return (char_type*) memset (s1, c, n); }
};

// 159 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/straits.h" 3

}  

// 36 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/bastring.h" 2 3


 
// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/alloc.h" 1 3
 



















// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 1 3
 












 



















 
 
 
 
 
 





// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/iostream.h" 1 3
 

























//pragma interface



// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/streambuf.h" 1 3
 


























//pragma interface


   



extern "C" {
// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/libio.h" 1 3
 













































// 55 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/libio.h" 3






















 















// 104 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/libio.h" 3











 

























 



















struct _IO_jump_t;  struct _IO_FILE;

 
// 175 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/libio.h" 3









    typedef void _IO_lock_t;





 

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
   

   
  int _pos;
// 208 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/libio.h" 3

};

struct _IO_FILE {
  int _flags;		 


   
   
  char* _IO_read_ptr;	 
  char* _IO_read_end;	 
  char* _IO_read_base;	 
  char* _IO_write_base;	 
  char* _IO_write_ptr;	 
  char* _IO_write_end;	 
  char* _IO_buf_base;	 
  char* _IO_buf_end;	 
   
  char *_IO_save_base;  
  char *_IO_backup_base;   
  char *_IO_save_end;  

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _blksize;



  _G_off_t  _offset;



   
  unsigned short _cur_column;
  char _unused;
  char _shortbuf[1];

   








};











struct _IO_FILE_plus;
extern struct _IO_FILE_plus _IO_stdin_, _IO_stdout_, _IO_stderr_;





 
typedef struct
{
  _G_ssize_t  (*read)  (struct _IO_FILE *, void *, _G_ssize_t )  ;
  _G_ssize_t  (*write)  (struct _IO_FILE *, const void *, _G_ssize_t )  ;
  _G_off_t  (*seek)  (struct _IO_FILE *, _G_off_t , int)  ;
  int (*close)  (struct _IO_FILE *)  ;
} _IO_cookie_io_functions_t;

 
struct _IO_cookie_file
{
  struct _IO_FILE file;
  const void *vtable;
  void *cookie;
  _IO_cookie_io_functions_t io_functions;
};



extern "C" {


extern int __underflow  (_IO_FILE *)  ;
extern int __uflow  (_IO_FILE *)  ;
extern int __overflow  (_IO_FILE *, int)  ;

















extern int _IO_getc  (_IO_FILE *__fp)  ;
extern int _IO_putc  (int __c, _IO_FILE *__fp)  ;
extern int _IO_feof  (_IO_FILE *__fp)  ;
extern int _IO_ferror  (_IO_FILE *__fp)  ;

extern int _IO_peekc_locked  (_IO_FILE *__fp)  ;

 



extern void _IO_flockfile  (_IO_FILE *)  ;
extern void _IO_funlockfile  (_IO_FILE *)  ;
extern int _IO_ftrylockfile  (_IO_FILE *)  ;













extern int _IO_vfscanf  (_IO_FILE *, const char *, _G_va_list , int *)  ;
extern int _IO_vfprintf  (_IO_FILE *, const char *, _G_va_list )  ;
extern _G_ssize_t  _IO_padn  (_IO_FILE *, int, _G_ssize_t )  ;
extern _G_size_t  _IO_sgetn  (_IO_FILE *, void *, _G_size_t )  ;





extern _G_off_t  _IO_seekoff  (_IO_FILE *, _G_off_t , int, int)  ;
extern _G_off_t  _IO_seekpos  (_IO_FILE *, _G_off_t , int)  ;


extern void _IO_free_backup_area  (_IO_FILE *)  ;


}



// 36 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/streambuf.h" 2 3

}
 


























extern "C++" {
class istream;  
class ostream; class streambuf;

 







typedef _G_off_t  streamoff;
typedef _G_off_t  streampos;

typedef _G_ssize_t  streamsize;

typedef unsigned long __fmtflags;
typedef unsigned char __iostate;

struct _ios_fields
{  
    streambuf *_strbuf;
    ostream* _tie;
    int _width;
    __fmtflags _flags;
    short  _fill;
    __iostate _state;
    __iostate _exceptions;
    int _precision;

    void *_arrays;  
};















// 124 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/streambuf.h" 3


class ios : public _ios_fields {
  ios& operator=(ios&);   
  ios (const ios&);  
  public:
    typedef __fmtflags fmtflags;
    typedef int iostate;
    typedef int openmode;
    typedef _G_ssize_t  streamsize;
    enum io_state {
	goodbit = 0 ,
	eofbit = 1 ,
	failbit = 2 ,
	badbit = 4  };
    enum open_mode {
	in = 1 ,
	out = 2 ,
	ate = 4 ,
	app = 8 ,
	trunc = 16 ,
	nocreate = 32 ,
	noreplace = 64 ,
	bin = 128 ,  
	binary = 128  };
    enum seek_dir { beg, cur, end};
    typedef enum seek_dir seekdir;
     
    enum { skipws= 01 ,
	   left= 02 , right= 04 , internal= 010 ,
	   dec= 020 , oct= 040 , hex= 0100 ,
	   showbase= 0200 , showpoint= 0400 ,
	   uppercase= 01000 , showpos= 02000 ,
	   scientific= 04000 , fixed= 010000 ,
	   unitbuf= 020000 , stdio= 040000 



	   };
    enum {  
	basefield=dec+oct+hex,
	floatfield = scientific+fixed,
	adjustfield = left+right+internal
    };

// 177 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/streambuf.h" 3


    ostream* tie() const { return _tie; }
    ostream* tie(ostream* val) { ostream* save=_tie; _tie=val; return save; }

     
    short  fill() const { return _fill; }
    short  fill(short  newf)
	{short  oldf = _fill; _fill = newf; return oldf;}
    fmtflags flags() const { return _flags; }
    fmtflags flags(fmtflags new_val) {
	fmtflags old_val = _flags; _flags = new_val; return old_val; }
    int precision() const { return _precision; }
    int precision(int newp) {
	unsigned short oldp = _precision; _precision = (unsigned short)newp;
	return oldp; }
    fmtflags setf(fmtflags val) {
	fmtflags oldbits = _flags;
	_flags |= val; return oldbits; }
    fmtflags setf(fmtflags val, fmtflags mask) {
	fmtflags oldbits = _flags;
	_flags = (_flags & ~mask) | (val & mask); return oldbits; }
    fmtflags unsetf(fmtflags mask) {
	fmtflags oldbits = _flags;
	_flags &= ~mask; return oldbits; }
    int width() const { return _width; }
    int width(int val) { int save = _width; _width = val; return save; }




    void _throw_failure() const { }

    void clear(iostate state = 0) {
	_state = _strbuf ? state : state|badbit;
	if (_state & _exceptions) _throw_failure(); }
    void set(iostate flag) { _state |= flag;
	if (_state & _exceptions) _throw_failure(); }
    void setstate(iostate flag) { _state |= flag;  
	if (_state & _exceptions) _throw_failure(); }
    int good() const { return _state == 0; }
    int eof() const { return _state & ios::eofbit; }
    int fail() const { return _state & (ios::badbit|ios::failbit); }
    int bad() const { return _state & ios::badbit; }
    iostate rdstate() const { return _state; }
    operator void*() const { return fail() ? (void*)0 : (void*)(-1); }
    int operator!() const { return fail(); }
    iostate exceptions() const { return _exceptions; }
    void exceptions(iostate enable) {
	_exceptions = enable;
	if (_state & _exceptions) _throw_failure(); }

    streambuf* rdbuf() const { return _strbuf; }
    streambuf* rdbuf(streambuf *_s) {
      streambuf *_old = _strbuf; _strbuf = _s; clear (); return _old; }

    static int sync_with_stdio(int on);
    static void sync_with_stdio() { sync_with_stdio(1); }
    static fmtflags bitalloc();
    static int xalloc();
    void*& pword(int);
    void* pword(int) const;
    long& iword(int);
    long iword(int) const;









     
    class Init {
    public:
      Init () { }
    };

  protected:
    inline ios(streambuf* sb = 0, ostream* tie_to = 0);
    inline virtual ~ios();
    inline void init(streambuf* sb, ostream* tie = 0);
};




typedef ios::seek_dir _seek_dir;


 
 
 
 
 

 
 
class streammarker : private _IO_marker {
    friend class streambuf;
    void set_offset(int offset) { _pos = offset; }
  public:
    streammarker(streambuf *sb);
    ~streammarker();
    int saving() { return  1; }
    int delta(streammarker&);
    int delta();
};

struct streambuf : public _IO_FILE {  
    friend class ios;
    friend class istream;
    friend class ostream;
    friend class streammarker;
    const void *&_vtable() { return *(const void**)((_IO_FILE*)this + 1); }
  protected:
    static streambuf* _list_all;  
    _IO_FILE*& xchain() { return _chain; }
    void _un_link();
    void _link_in();
    char* gptr() const
      { return _flags  & 0x100  ? _IO_save_base : _IO_read_ptr; }
    char* pptr() const { return _IO_write_ptr; }
    char* egptr() const
      { return _flags  & 0x100  ? _IO_save_end : _IO_read_end; }
    char* epptr() const { return _IO_write_end; }
    char* pbase() const { return _IO_write_base; }
    char* eback() const
      { return _flags  & 0x100  ? _IO_save_base : _IO_read_base;}
    char* base() const { return _IO_buf_base; }
    char* ebuf() const { return _IO_buf_end; }
    int blen() const { return _IO_buf_end - _IO_buf_base; }
    void xput_char(char c) { *_IO_write_ptr++ = c; }
    int xflags() { return _flags ; }
    int xflags(int f) {int fl = _flags ; _flags  = f; return fl;}
    void xsetflags(int f) { _flags  |= f; }
    void xsetflags(int f, int mask)
      { _flags  = (_flags  & ~mask) | (f & mask); }
    void gbump(int n)
      { _flags  & 0x100  ? (_IO_save_base+=n):(_IO_read_ptr+=n);}
    void pbump(int n) { _IO_write_ptr += n; }
    void setb(char* b, char* eb, int a=0);
    void setp(char* p, char* ep)
      { _IO_write_base=_IO_write_ptr=p; _IO_write_end=ep; }
    void setg(char* eb, char* g, char *eg) {
      if (_flags  & 0x100 ) _IO_free_backup_area(this); 
      _IO_read_base = eb; _IO_read_ptr = g; _IO_read_end = eg; }
    char *shortbuf() { return _shortbuf; }

    int in_backup() { return _flags & 0x100 ; }
     
    char *Gbase() { return in_backup() ? _IO_save_base : _IO_read_base; }
     
    char *eGptr() { return in_backup() ? _IO_save_end : _IO_read_end; }
     
    char *Bbase() { return in_backup() ? _IO_read_base : _IO_save_base; }
    char *Bptr() { return _IO_backup_base; }
     
    char *eBptr() { return in_backup() ? _IO_read_end : _IO_save_end; }
    char *Nbase() { return _IO_save_base; }
    char *eNptr() { return _IO_save_end; }
    int have_backup() { return _IO_save_base != __null ; }
    int have_markers() { return _markers != __null ; }
    void free_backup_area();
    void unsave_markers();  
    int put_mode() { return _flags & 0x800 ; }
    int switch_to_get_mode();
    
    streambuf(int flags=0);
  public:
    static int flush_all();
    static void flush_all_linebuffered();  
    virtual ~streambuf();
    virtual int overflow(int c = (-1) );  
    virtual int underflow();  
    virtual int uflow();  
    virtual int pbackfail(int c);
 
    virtual streamsize xsputn(const char* s, streamsize n);
    virtual streamsize xsgetn(char* s, streamsize n);
    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    virtual streampos seekpos(streampos pos, int mode = ios::in|ios::out);

    streampos pubseekoff(streamoff o, _seek_dir d, int mode=ios::in|ios::out)
      { return _IO_seekoff (this, o, d, mode); }
    streampos pubseekpos(streampos pos, int mode = ios::in|ios::out)
      { return _IO_seekpos (this, pos, mode); }
    streampos sseekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    streampos sseekpos(streampos pos, int mode = ios::in|ios::out);
    virtual streambuf* setbuf(char* p, int len);
    virtual int sync();
    virtual int doallocate();

    int seekmark(streammarker& mark, int delta = 0);
    int sputbackc(char c);
    int sungetc();
    int unbuffered() { return _flags & 2  ? 1 : 0; }
    int linebuffered() { return _flags & 0x200  ? 1 : 0; }
    void unbuffered(int i)
	{ if (i) _flags |= 2 ; else _flags &= ~2 ; }
    void linebuffered(int i)
	{ if (i) _flags |= 0x200 ; else _flags &= ~0x200 ; }
    int allocate() {  
	if (base() || unbuffered()) return 0;
	else return doallocate(); }
     
    void allocbuf() { if (base() == __null ) doallocbuf(); }
    void doallocbuf();
    int in_avail() { return _IO_read_end - _IO_read_ptr; }
    int out_waiting() { return _IO_write_ptr - _IO_write_base; }
    streamsize sputn(const char* s, streamsize n) { return xsputn(s, n); }
    streamsize padn(char pad, streamsize n) { return _IO_padn(this, pad, n); }
    streamsize sgetn(char* s, streamsize n) { return _IO_sgetn(this, s, n); }
    int ignore(int);
    int get_column();
    int set_column(int);
    long sgetline(char* buf, _G_size_t  n, char delim, int putback_delim);
    int sputc(int c) { return _IO_putc(c, this); }
    int sbumpc() { return _IO_getc(this); }
    int sgetc() { return ((  this  )->_IO_read_ptr >= (  this  )->_IO_read_end && __underflow (  this  ) == (-1)  ? (-1)  : *(unsigned char *) (  this  )->_IO_read_ptr)  ; }
    int snextc() {
	if (_IO_read_ptr >= _IO_read_end && __underflow(this) == (-1) )
	  return (-1) ;
	else return _IO_read_ptr++, sgetc(); }
    void stossc() { if (_IO_read_ptr < _IO_read_end) _IO_read_ptr++; }
    int vscan(char const *fmt0, _G_va_list  ap, ios* stream = __null );
    int scan(char const *fmt0 ...);
    int vform(char const *fmt0, _G_va_list  ap);
    int form(char const *fmt0 ...);




    virtual streamsize sys_read(char* buf, streamsize size);
    virtual streamsize sys_write(const char*, streamsize);
    virtual streampos sys_seek(streamoff, _seek_dir);
    virtual int sys_close();
    virtual int sys_stat(void*);  




};

 
 

class filebuf : public streambuf {
  protected:
    void init();
  public:
    static const int openprot;  
    filebuf();
    filebuf(int fd);
    filebuf(int fd, char* p, int len);



    ~filebuf();
    filebuf* attach(int fd);
    filebuf* open(const char *filename, const char *mode);
    filebuf* open(const char *filename, ios::openmode mode, int prot = 0664);
    virtual int underflow();
    virtual int overflow(int c = (-1) );
    int is_open() const { return _fileno >= 0; }
    int fd() const { return is_open() ? _fileno : (-1) ; }
    filebuf* close();
    virtual int doallocate();
    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    virtual streambuf* setbuf(char* p, int len);
    streamsize xsputn(const char* s, streamsize n);
    streamsize xsgetn(char* s, streamsize n);
    virtual int sync();
  protected:  
 
    int is_reading() { return eback() != egptr(); }
    char* cur_ptr() { return is_reading() ?  gptr() : pptr(); }
     
    char* file_ptr() { return eGptr(); }
     
    virtual streamsize sys_read(char* buf, streamsize size);
    virtual streampos sys_seek(streamoff, _seek_dir);
    virtual streamsize sys_write(const char*, streamsize);
    virtual int sys_stat(void*);  
    virtual int sys_close();




};

inline void ios::init(streambuf* sb, ostream* tie_to) {
		_state = sb ? ios::goodbit : ios::badbit; _exceptions=0;
		_strbuf=sb; _tie = tie_to; _width=0; _fill=' ';

		_flags=ios::skipws|ios::dec;



		_precision=6; _arrays = 0; }

inline ios::ios(streambuf* sb, ostream* tie_to) { init(sb, tie_to); }

inline ios::~ios() {



     
     
    operator delete[] (_arrays);
}
}  

// 31 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/iostream.h" 2 3


extern "C++" {
class istream; class ostream;
typedef ios& (*__manip)(ios&);
typedef istream& (*__imanip)(istream&);
typedef ostream& (*__omanip)(ostream&);

extern istream& ws(istream& ins);
extern ostream& flush(ostream& outs);
extern ostream& endl(ostream& outs);
extern ostream& ends(ostream& outs);

class ostream : virtual public ios
{
     
    void do_osfx();
  public:
    ostream() { }
    ostream(streambuf* sb, ostream* tied= __null );
    int opfx() {
	if (!good()) return 0;
	else { if (_tie) _tie->flush();  ; return 1;} }
    void osfx() {  ;
		  if (flags() & (ios::unitbuf|ios::stdio))
		      do_osfx(); }
    ostream& flush();
    ostream& put(char c) { _strbuf->sputc(c); return *this; }





    ostream& write(const char *s, streamsize n);
    ostream& write(const unsigned char *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& write(const signed char *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& write(const void *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& seekp(streampos);
    ostream& seekp(streamoff, _seek_dir);
    streampos tellp();
    ostream& form(const char *format ...);
    ostream& vform(const char *format, _G_va_list  args);

    ostream& operator<<(char c);
    ostream& operator<<(unsigned char c) { return (*this) << (char)c; }
    ostream& operator<<(signed char c) { return (*this) << (char)c; }
    ostream& operator<<(const char *s);
    ostream& operator<<(const unsigned char *s)
	{ return (*this) << (const char*)s; }
    ostream& operator<<(const signed char *s)
	{ return (*this) << (const char*)s; }
    ostream& operator<<(const void *p);
    ostream& operator<<(int n);
    ostream& operator<<(unsigned int n);
    ostream& operator<<(long n);
    ostream& operator<<(unsigned long n);

    __extension__ ostream& operator<<(long long n);
    __extension__ ostream& operator<<(unsigned long long n);

    ostream& operator<<(short n) {return operator<<((int)n);}
    ostream& operator<<(unsigned short n) {return operator<<((unsigned int)n);}

    ostream& operator<<(bool b) { return operator<<((int)b); }

    ostream& operator<<(double n);
    ostream& operator<<(float n) { return operator<<((double)n); }



    ostream& operator<<(long double n) { return operator<<((double)n); }

    ostream& operator<<(__omanip func) { return (*func)(*this); }
    ostream& operator<<(__manip func) {(*func)(*this); return *this;}
    ostream& operator<<(streambuf*);



};

class istream : virtual public ios
{
     
protected:
    _G_size_t  _gcount;

    int _skip_ws();
  public:
    istream(): _gcount (0) { }
    istream(streambuf* sb, ostream*tied= __null );
    istream& get(char* ptr, int len, char delim = '\n');
    istream& get(unsigned char* ptr, int len, char delim = '\n')
	{ return get((char*)ptr, len, delim); }
    istream& get(char& c);
    istream& get(unsigned char& c) { return get((char&)c); }
    istream& getline(char* ptr, int len, char delim = '\n');
    istream& getline(unsigned char* ptr, int len, char delim = '\n')
	{ return getline((char*)ptr, len, delim); }
    istream& get(signed char& c)  { return get((char&)c); }
    istream& get(signed char* ptr, int len, char delim = '\n')
	{ return get((char*)ptr, len, delim); }
    istream& getline(signed char* ptr, int len, char delim = '\n')
	{ return getline((char*)ptr, len, delim); }
    istream& read(char *ptr, streamsize n);
    istream& read(unsigned char *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& read(signed char *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& read(void *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& get(streambuf& sb, char delim = '\n');
    istream& gets(char **s, char delim = '\n');
    int ipfx(int need = 0) {
	if (!good()) { set(ios::failbit); return 0; }
	else {
	   ;
	  if (_tie && (need == 0 || rdbuf()->in_avail() < need)) _tie->flush();
	  if (!need && (flags() & ios::skipws)) return _skip_ws();
	  else return 1;
	}
    }
    int ipfx0() {  
	if (!good()) { set(ios::failbit); return 0; }
	else {
	   ;
	  if (_tie) _tie->flush();
	  if (flags() & ios::skipws) return _skip_ws();
	  else return 1;
	}
    }
    int ipfx1() {  
	if (!good()) { set(ios::failbit); return 0; }
	else {
	   ;
	  if (_tie && rdbuf()->in_avail() == 0) _tie->flush();
	  return 1;
	}
    }
    void isfx() {  ; }
    int get() { if (!ipfx1()) return (-1) ;
		else { int ch = _strbuf->sbumpc();
		       if (ch == (-1) ) set(ios::eofbit);
		       isfx();
		       return ch;
		     } }
    int peek();
    _G_size_t  gcount() { return _gcount; }
    istream& ignore(int n=1, int delim = (-1) );
    int sync ();
    istream& seekg(streampos);
    istream& seekg(streamoff, _seek_dir);
    streampos tellg();
    istream& putback(char ch) {
	if (good() && _strbuf->sputbackc(ch) == (-1) ) clear(ios::badbit);
	return *this;}
    istream& unget() {
	if (good() && _strbuf->sungetc() == (-1) ) clear(ios::badbit);
	return *this;}
    istream& scan(const char *format ...);

    istream& vscan(const char *format, _G_va_list  args);






    istream& operator>>(char*);
    istream& operator>>(unsigned char* p) { return operator>>((char*)p); }
    istream& operator>>(signed char*p) { return operator>>((char*)p); }
    istream& operator>>(char& c);
    istream& operator>>(unsigned char& c) {return operator>>((char&)c);}
    istream& operator>>(signed char& c) {return operator>>((char&)c);}
    istream& operator>>(int&);
    istream& operator>>(long&);

    __extension__ istream& operator>>(long long&);
    __extension__ istream& operator>>(unsigned long long&);

    istream& operator>>(short&);
    istream& operator>>(unsigned int&);
    istream& operator>>(unsigned long&);
    istream& operator>>(unsigned short&);

    istream& operator>>(bool&);

    istream& operator>>(float&);
    istream& operator>>(double&);
    istream& operator>>(long double&);
    istream& operator>>( __manip func) {(*func)(*this); return *this;}
    istream& operator>>(__imanip func) { return (*func)(*this); }
    istream& operator>>(streambuf*);
};

class iostream : public istream, public ostream
{
  public:
    iostream() { }
    iostream(streambuf* sb, ostream*tied= __null );
};

class _IO_istream_withassign : public istream {
public:
  _IO_istream_withassign& operator=(istream&);
  _IO_istream_withassign& operator=(_IO_istream_withassign& rhs)
    { return operator= (static_cast<istream&> (rhs)); }
};

class _IO_ostream_withassign : public ostream {
public:
  _IO_ostream_withassign& operator=(ostream&);
  _IO_ostream_withassign& operator=(_IO_ostream_withassign& rhs)
    { return operator= (static_cast<ostream&> (rhs)); }
};

extern _IO_istream_withassign cin;
 
extern _IO_ostream_withassign cout, cerr;

extern _IO_ostream_withassign clog



;

extern istream& lock(istream& ins);
extern istream& unlock(istream& ins);
extern ostream& lock(ostream& outs);
extern ostream& unlock(ostream& outs);

struct Iostream_init { } ;   

inline ios& dec(ios& i)
{ i.setf(ios::dec, ios::dec|ios::hex|ios::oct); return i; }
inline ios& hex(ios& i)
{ i.setf(ios::hex, ios::dec|ios::hex|ios::oct); return i; }
inline ios& oct(ios& i)
{ i.setf(ios::oct, ios::dec|ios::hex|ios::oct); return i; }
}  


// 45 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 2 3








// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 1 3
 



























// 373 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3

// 53 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 2 3

// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stdlib.h" 1 3
 




























 







// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 1 3
 


































 


// 47 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3





 


 





 


// 91 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 





 


















 





 

 


// 156 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3


 




 

 


// 218 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3




 




 


// 298 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3
















 

 

// 346 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3






 













 







// 38 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stdlib.h" 2 3



 





 





 























extern "C" {


 





extern int	_argc;
extern char**	_argv;

 


extern int*     __p___argc(void);
extern char***   __p___argv(void);
extern wchar_t***   __p___wargv(void);





// 118 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stdlib.h" 3


 



// 132 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stdlib.h" 3


 







int*	_errno(void);


int*	__doserrno(void);


 




  extern char *** __p__environ();
  extern wchar_t *** __p__wenviron();


// 165 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stdlib.h" 3





 





  __attribute__((dllimport)) extern  int	_sys_nerr;





// 194 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stdlib.h" 3






__attribute__((dllimport)) extern  char*	_sys_errlist[];





 





 

extern unsigned int*	__p__osver(void);
extern unsigned int*	__p__winver(void);
extern unsigned int*	__p__winmajor(void);
extern unsigned int*	__p__winminor(void);






// 253 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stdlib.h" 3



 

char**  __p__pgmptr(void);

wchar_t**  __p__wpgmptr(void);

// 274 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stdlib.h" 3










double	atof	(const char*);
int	atoi	(const char*);
long	atol	(const char*);
int	_wtoi (const wchar_t *);
long _wtol (const wchar_t *);

double	strtod	(const char*, char**);
double	wcstod	(const wchar_t*, wchar_t**);
long	strtol	(const char*, char**, int);
long	wcstol	(const wchar_t*, wchar_t**, int);

unsigned long	strtoul	(const char*, char**, int);
unsigned long	wcstoul (const wchar_t*, wchar_t**, int);

size_t	wcstombs	(char*, const wchar_t*, size_t);
int	wctomb		(char*, wchar_t);

int	mblen		(const char*, size_t);
size_t	mbstowcs	(wchar_t*, const char*, size_t);
int	mbtowc		(wchar_t*, const char*, size_t);

int	rand	(void);
void	srand	(unsigned int);

void*	calloc	(size_t, size_t);
void*	malloc	(size_t);
void*	realloc	(void*, size_t);
void	free	(void*);

void	abort	(void) __attribute__ ((noreturn)) ;
void	exit	(int) __attribute__ ((noreturn)) ;
int	atexit	(void (*)(void));

int	system	(const char*);
char*	getenv	(const char*);

void*	bsearch	(const void*, const void*, size_t, size_t, 
                 int (*)(const void*, const void*));
void	qsort	(const void*, size_t, size_t,
                 int (*)(const void*, const void*));

int	abs	(int);
long	labs	(long);

 







typedef struct { int quot, rem; } div_t;
typedef struct { long quot, rem; } ldiv_t;

div_t	div	(int, int);
ldiv_t	ldiv	(long, long);




 



void	_beep (unsigned int, unsigned int);
void	_seterrormode (int);
void	_sleep (unsigned long);

void	_exit	(int) __attribute__ ((noreturn)) ;

int	_putenv	(const char*);
void	_searchenv (const char*, const char*, char*);


char*	_ecvt (double, int, int*, int*);
char*	_fcvt (double, int, int*, int*);
char*	_gcvt (double, int, char*);

void	_makepath (char*, const char*, const char*, const char*, const char*);
void	_splitpath (const char*, char*, char*, char*, char*);
char*	_fullpath (char*, const char*, size_t);


char*	_itoa (int, char*, int);
char*	_ltoa (long, char*, int);
char*   _ultoa(unsigned long, char*, int);
wchar_t*  _itow (int, wchar_t*, int);
wchar_t*  _ltow (long, wchar_t*, int);
wchar_t*  _ultow (unsigned long, wchar_t*, int);


long long 	_atoi64(const char *);
char*	_i64toa(long long , char *, int);
char*	_ui64toa(unsigned long long , char *, int);
long long 	_wtoi64(const wchar_t *);
wchar_t* _i64tow(long long , wchar_t *, int);
wchar_t* _ui64tow(unsigned long long , wchar_t *, int);

wchar_t* _wgetenv(const wchar_t*);
int	 _wputenv(const wchar_t*);
void	_wsearchenv(const wchar_t*, const wchar_t*, wchar_t*);
void    _wmakepath(wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*);
void	_wsplitpath (const wchar_t*, wchar_t*, wchar_t*, wchar_t*, wchar_t*);
wchar_t*    _wfullpath (wchar_t*, const wchar_t*, size_t);




int	putenv (const char*);
void	searchenv (const char*, const char*, char*);

char*	itoa (int, char*, int);
char*	ltoa (long, char*, int);


char*	ecvt (double, int, int*, int*);
char*	fcvt (double, int, int*, int*);
char*	gcvt (double, int, char*);





 





}






// 54 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 2 3


// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/assert.h" 1 3
 




























 





extern "C" {











 



void	_assert (const char*, const char*, int)

	__attribute__ ((noreturn))

	;

 






}






// 56 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 2 3











// 78 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 3

// 87 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 3

// 97 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 3

// 115 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 3


 






 





 
 









template <int __inst>
class __malloc_alloc_template {

private:

  static void* _S_oom_malloc(size_t);
  static void* _S_oom_realloc(void*, size_t);


  static void (* __malloc_alloc_oom_handler)();


public:

  static void* allocate(size_t __n)
  {
    void* __result = malloc(__n);
    if (0 == __result) __result = _S_oom_malloc(__n);
    return __result;
  }

  static void deallocate(void* __p, size_t  )
  {
    free(__p);
  }

  static void* reallocate(void* __p, size_t  , size_t __new_sz)
  {
    void* __result = realloc(__p, __new_sz);
    if (0 == __result) __result = _S_oom_realloc(__p, __new_sz);
    return __result;
  }

  static void (* __set_malloc_handler(void (*__f)()))()
  {
    void (* __old)() = __malloc_alloc_oom_handler;
    __malloc_alloc_oom_handler = __f;
    return(__old);
  }

};

 


template <int __inst>
void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;


template <int __inst>
void*
__malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)
{
    void (* __my_malloc_handler)();
    void* __result;

    for (;;) {
        __my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == __my_malloc_handler) { cerr << "out of memory" << endl; exit(1) ; }
        (*__my_malloc_handler)();
        __result = malloc(__n);
        if (__result) return(__result);
    }
}

template <int __inst>
void* __malloc_alloc_template<__inst>::_S_oom_realloc(void* __p, size_t __n)
{
    void (* __my_malloc_handler)();
    void* __result;

    for (;;) {
        __my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == __my_malloc_handler) { cerr << "out of memory" << endl; exit(1) ; }
        (*__my_malloc_handler)();
        __result = realloc(__p, __n);
        if (__result) return(__result);
    }
}

typedef __malloc_alloc_template<0> malloc_alloc;

template<class _Tp, class _Alloc>
class simple_alloc {

public:
    static _Tp* allocate(size_t __n)
      { return 0 == __n ? 0 : (_Tp*) _Alloc::allocate(__n * sizeof (_Tp)); }
    static _Tp* allocate(void)
      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }
    static void deallocate(_Tp* __p, size_t __n)
      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }
    static void deallocate(_Tp* __p)
      { _Alloc::deallocate(__p, sizeof (_Tp)); }
};

 
 
 
 
 
template <class _Alloc>
class debug_alloc {

private:

  enum {_S_extra = 8};   
                         
                         

public:

  static void* allocate(size_t __n)
  {
    char* __result = (char*)_Alloc::allocate(__n + _S_extra);
    *(size_t*)__result = __n;
    return __result + _S_extra;
  }

  static void deallocate(void* __p, size_t __n)
  {
    char* __real_p = (char*)__p - _S_extra;
    (( *(size_t*)__real_p == __n ) ? (void)0 : _assert("*(size_t*)__real_p == __n", "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h", 263)) ;
    _Alloc::deallocate(__real_p, __n + _S_extra);
  }

  static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz)
  {
    char* __real_p = (char*)__p - _S_extra;
    (( *(size_t*)__real_p == __old_sz ) ? (void)0 : _assert("*(size_t*)__real_p == __old_sz", "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h", 270)) ;
    char* __result = (char*)
      _Alloc::reallocate(__real_p, __old_sz + _S_extra, __new_sz + _S_extra);
    *(size_t*)__result = __new_sz;
    return __result + _S_extra;
  }

};










 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 







template <bool threads, int inst>
class __default_alloc_template {

private:
   
   

    enum {_ALIGN = 8};
    enum {_MAX_BYTES = 128};
    enum {_NFREELISTS = _MAX_BYTES/_ALIGN};

  static size_t
  _S_round_up(size_t __bytes)
    { return (((__bytes) + _ALIGN-1) & ~(_ALIGN - 1)); }

private :
  union _Obj {
        union _Obj* _M_free_list_link;
        char _M_client_data[1];     
  };
private:




    static _Obj*   _S_free_list[_NFREELISTS];

  static  size_t _S_freelist_index(size_t __bytes) {
        return (((__bytes) + _ALIGN-1)/_ALIGN - 1);
  }

   
  static void* _S_refill(size_t __n);
   
   
  static char* _S_chunk_alloc(size_t __size, int& __nobjs);

   
  static char* _S_start_free;
  static char* _S_end_free;
  static size_t _S_heap_size;















// 389 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 3


    class _Lock {
        public:
            _Lock() {  ; }
            ~_Lock() {  ; }
    };
    friend class _Lock;

public:

   
  static void* allocate(size_t __n)
  {
    _Obj*  * __my_free_list;
    _Obj*   __result;

    if (__n > (size_t) _MAX_BYTES) {
        return(malloc_alloc::allocate(__n));
    }
    __my_free_list = _S_free_list + _S_freelist_index(__n);
     
     
     




    __result = *__my_free_list;
    if (__result == 0) {
        void* __r = _S_refill(_S_round_up(__n));
        return __r;
    }
    *__my_free_list = __result -> _M_free_list_link;
    return (__result);
  };

   
  static void deallocate(void* __p, size_t __n)
  {
    _Obj* __q = (_Obj*)__p;
    _Obj*  * __my_free_list;

    if (__n > (size_t) _MAX_BYTES) {
        malloc_alloc::deallocate(__p, __n);
        return;
    }
    __my_free_list = _S_free_list + _S_freelist_index(__n);
     




    __q -> _M_free_list_link = *__my_free_list;
    *__my_free_list = __q;
     
  }

  static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz);

} ;

typedef __default_alloc_template< false , 0> alloc;
typedef __default_alloc_template<false, 0> single_client_alloc;



 
 
 
 
template <bool __threads, int __inst>
char*
__default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size,
                                                            int& __nobjs)
{
    char* __result;
    size_t __total_bytes = __size * __nobjs;
    size_t __bytes_left = _S_end_free - _S_start_free;

    if (__bytes_left >= __total_bytes) {
        __result = _S_start_free;
        _S_start_free += __total_bytes;
        return(__result);
    } else if (__bytes_left >= __size) {
        __nobjs = (int)(__bytes_left/__size);
        __total_bytes = __size * __nobjs;
        __result = _S_start_free;
        _S_start_free += __total_bytes;
        return(__result);
    } else {
        size_t __bytes_to_get =
	  2 * __total_bytes + _S_round_up(_S_heap_size >> 4);
         
        if (__bytes_left > 0) {
            _Obj*  * __my_free_list =
                        _S_free_list + _S_freelist_index(__bytes_left);

            ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;
            *__my_free_list = (_Obj*)_S_start_free;
        }
        _S_start_free = (char*)malloc(__bytes_to_get);
        if (0 == _S_start_free) {
            size_t __i;
            _Obj*  * __my_free_list;
	    _Obj* __p;
             
             
             
            for (__i = __size; __i <= _MAX_BYTES; __i += _ALIGN) {
                __my_free_list = _S_free_list + _S_freelist_index(__i);
                __p = *__my_free_list;
                if (0 != __p) {
                    *__my_free_list = __p -> _M_free_list_link;
                    _S_start_free = (char*)__p;
                    _S_end_free = _S_start_free + __i;
                    return(_S_chunk_alloc(__size, __nobjs));
                     
                     
                }
            }
	    _S_end_free = 0;	 
            _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get);
             
             
             
        }
        _S_heap_size += __bytes_to_get;
        _S_end_free = _S_start_free + __bytes_to_get;
        return(_S_chunk_alloc(__size, __nobjs));
    }
}


 
 
 
template <bool __threads, int __inst>
void*
__default_alloc_template<__threads, __inst>::_S_refill(size_t __n)
{
    int __nobjs = 20;
    char* __chunk = _S_chunk_alloc(__n, __nobjs);
    _Obj*  * __my_free_list;
    _Obj* __result;
    _Obj* __current_obj;
    _Obj* __next_obj;
    int __i;

    if (1 == __nobjs) return(__chunk);
    __my_free_list = _S_free_list + _S_freelist_index(__n);

     
      __result = (_Obj*)__chunk;
      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);
      for (__i = 1; ; __i++) {
        __current_obj = __next_obj;
        __next_obj = (_Obj*)((char*)__next_obj + __n);
        if (__nobjs - 1 == __i) {
            __current_obj -> _M_free_list_link = 0;
            break;
        } else {
            __current_obj -> _M_free_list_link = __next_obj;
        }
      }
    return(__result);
}

template <bool threads, int inst>
void*
__default_alloc_template<threads, inst>::reallocate(void* __p,
                                                    size_t __old_sz,
                                                    size_t __new_sz)
{
    void* __result;
    size_t __copy_sz;

    if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES) {
        return(realloc(__p, __new_sz));
    }
    if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p);
    __result = allocate(__new_sz);
    __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;
    memcpy(__result, __p, __copy_sz);
    deallocate(__p, __old_sz);
    return(__result);
}















// 602 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 3


// 689 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_alloc.h" 3


template <bool __threads, int __inst>
char* __default_alloc_template<__threads, __inst>::_S_start_free = 0;

template <bool __threads, int __inst>
char* __default_alloc_template<__threads, __inst>::_S_end_free = 0;

template <bool __threads, int __inst>
size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;

template <bool __threads, int __inst>
__default_alloc_template<__threads, __inst>::_Obj*  
__default_alloc_template<__threads, __inst> ::_S_free_list[
    _NFREELISTS
] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
 
 
 










 
 
 
 
 
 
 



template <class _Tp>
class allocator {
  typedef alloc _Alloc;           
public:
  typedef size_t     size_type;
  typedef ptrdiff_t  difference_type;
  typedef _Tp*       pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp&       reference;
  typedef const _Tp& const_reference;
  typedef _Tp        value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() throw()  {}
  allocator(const allocator&) throw()  {}
  template <class _Tp1> allocator(const allocator<_Tp1>&) throw()  {}
  ~allocator() throw()  {}

  pointer address(reference __x) const { return &__x; }
  const_pointer address(const_reference __x) const { return &__x; }

   
   
  _Tp* allocate(size_type __n, const void* = 0) {
    return __n != 0 ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)))
                    : 0;
  }

   
  void deallocate(pointer __p, size_type __n)
    { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }

  size_type max_size() const throw() 
    { return size_t(-1) / sizeof(_Tp); }

  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }
  void destroy(pointer __p) { __p->~_Tp(); }
};

template<>
class allocator<void> {
  typedef size_t      size_type;
  typedef ptrdiff_t   difference_type;
  typedef void*       pointer;
  typedef const void* const_pointer;
  typedef void        value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};


template <class _T1, class _T2>
inline bool operator==(const allocator<_T1>&, const allocator<_T2>&)
{
  return true;
}

template <class _T1, class _T2>
inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&)
{
  return false;
}

 
 
 
 
 
 

template <class _Tp, class _Alloc>
struct __allocator {
  _Alloc __underlying_alloc;

  typedef size_t    size_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp*       pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp&       reference;
  typedef const _Tp& const_reference;
  typedef _Tp        value_type;

  template <class _Tp1> struct rebind {
    typedef __allocator<_Tp1, _Alloc> other;
  };

  __allocator() throw()  {}
  __allocator(const __allocator& __a) throw() 
    : __underlying_alloc(__a.__underlying_alloc) {}
  template <class _Tp1>
  __allocator(const __allocator<_Tp1, _Alloc>& __a) throw() 
    : __underlying_alloc(__a.__underlying_alloc) {}
  ~__allocator() throw()  {}

  pointer address(reference __x) const { return &__x; }
  const_pointer address(const_reference __x) const { return &__x; }

   
  _Tp* allocate(size_type __n, const void* = 0) {
    return __n != 0
        ? static_cast<_Tp*>(__underlying_alloc.allocate(__n * sizeof(_Tp)))
        : 0;
  }

   
  void deallocate(pointer __p, size_type __n)
    { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }

  size_type max_size() const throw() 
    { return size_t(-1) / sizeof(_Tp); }

  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }
  void destroy(pointer __p) { __p->~_Tp(); }
};

template <class _Alloc>
class __allocator<void, _Alloc> {
  typedef size_t      size_type;
  typedef ptrdiff_t   difference_type;
  typedef void*       pointer;
  typedef const void* const_pointer;
  typedef void        value_type;

  template <class _Tp1> struct rebind {
    typedef __allocator<_Tp1, _Alloc> other;
  };
};

template <class _Tp, class _Alloc>
inline bool operator==(const __allocator<_Tp, _Alloc>& __a1,
                       const __allocator<_Tp, _Alloc>& __a2)
{
  return __a1.__underlying_alloc == __a2.__underlying_alloc;
}


template <class _Tp, class _Alloc>
inline bool operator!=(const __allocator<_Tp, _Alloc>& __a1,
                       const __allocator<_Tp, _Alloc>& __a2)
{
  return __a1.__underlying_alloc != __a2.__underlying_alloc;
}


 
 
 

template <int inst>
inline bool operator==(const __malloc_alloc_template<inst>&,
                       const __malloc_alloc_template<inst>&)
{
  return true;
}


template <int __inst>
inline bool operator!=(const __malloc_alloc_template<__inst>&,
                       const __malloc_alloc_template<__inst>&)
{
  return false;
}



template <bool __threads, int __inst>
inline bool operator==(const __default_alloc_template<__threads, __inst>&,
                       const __default_alloc_template<__threads, __inst>&)
{
  return true;
}


template <bool __threads, int __inst>
inline bool operator!=(const __default_alloc_template<__threads, __inst>&,
                       const __default_alloc_template<__threads, __inst>&)
{
  return false;
}



template <class _Alloc>
inline bool operator==(const debug_alloc<_Alloc>&,
                       const debug_alloc<_Alloc>&) {
  return true;
}


template <class _Alloc>
inline bool operator!=(const debug_alloc<_Alloc>&,
                       const debug_alloc<_Alloc>&) {
  return false;
}


 
 
 
 
 
 

 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 

 

template <class _Tp, class _Allocator>
struct _Alloc_traits
{
  static const bool _S_instanceless = false;
  typedef typename _Allocator::   rebind<_Tp>::other
          allocator_type;
};

template <class _Tp, class _Allocator>
const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;

 

template <class _Tp, class _Tp1>
struct _Alloc_traits<_Tp, allocator<_Tp1> >
{
  static const bool _S_instanceless = true;
  typedef simple_alloc<_Tp, alloc> _Alloc_type;
  typedef allocator<_Tp> allocator_type;
};

 

template <class _Tp, int __inst>
struct _Alloc_traits<_Tp, __malloc_alloc_template<__inst> >
{
  static const bool _S_instanceless = true;
  typedef simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
  typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
};


template <class _Tp, bool __threads, int __inst>
struct _Alloc_traits<_Tp, __default_alloc_template<__threads, __inst> >
{
  static const bool _S_instanceless = true;
  typedef simple_alloc<_Tp, __default_alloc_template<__threads, __inst> >
          _Alloc_type;
  typedef __allocator<_Tp, __default_alloc_template<__threads, __inst> >
          allocator_type;
};


template <class _Tp, class _Alloc>
struct _Alloc_traits<_Tp, debug_alloc<_Alloc> >
{
  static const bool _S_instanceless = true;
  typedef simple_alloc<_Tp, debug_alloc<_Alloc> > _Alloc_type;
  typedef __allocator<_Tp, debug_alloc<_Alloc> > allocator_type;
};

 
 

template <class _Tp, class _Tp1, int __inst>
struct _Alloc_traits<_Tp,
                     __allocator<_Tp1, __malloc_alloc_template<__inst> > >
{
  static const bool _S_instanceless = true;
  typedef simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
  typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
};


template <class _Tp, class _Tp1, bool __thr, int __inst>
struct _Alloc_traits<_Tp,
                      __allocator<_Tp1,
                                  __default_alloc_template<__thr, __inst> > >
{
  static const bool _S_instanceless = true;
  typedef simple_alloc<_Tp, __default_alloc_template<__thr,__inst> >
          _Alloc_type;
  typedef __allocator<_Tp, __default_alloc_template<__thr,__inst> >
          allocator_type;
};


template <class _Tp, class _Tp1, class _Alloc>
struct _Alloc_traits<_Tp, __allocator<_Tp1, debug_alloc<_Alloc> > >
{
  static const bool _S_instanceless = true;
  typedef simple_alloc<_Tp, debug_alloc<_Alloc> > _Alloc_type;
  typedef __allocator<_Tp, debug_alloc<_Alloc> > allocator_type;
};








 





 
 
 
// 21 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/alloc.h" 2 3



// 40 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/alloc.h" 3




 
 
 
// 39 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/bastring.h" 2 3


extern "C++" {
class istream; class ostream;

// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/iterator" 1 3
 






























// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 1 3
 



























// 373 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/stddef.h" 3

// 32 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/iterator" 2 3






// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_iterator.h" 1 3
 

























 






 

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

 
 
 
 

template <class _Tp, class _Distance> struct input_iterator {
  typedef input_iterator_tag iterator_category;
  typedef _Tp                value_type;
  typedef _Distance          difference_type;
  typedef _Tp*               pointer;
  typedef _Tp&               reference;
};

struct output_iterator {
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;
};

template <class _Tp, class _Distance> struct forward_iterator {
  typedef forward_iterator_tag iterator_category;
  typedef _Tp                  value_type;
  typedef _Distance            difference_type;
  typedef _Tp*                 pointer;
  typedef _Tp&                 reference;
};


template <class _Tp, class _Distance> struct bidirectional_iterator {
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp                        value_type;
  typedef _Distance                  difference_type;
  typedef _Tp*                       pointer;
  typedef _Tp&                       reference;
};

template <class _Tp, class _Distance> struct random_access_iterator {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                        value_type;
  typedef _Distance                  difference_type;
  typedef _Tp*                       pointer;
  typedef _Tp&                       reference;
};

// 98 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_iterator.h" 3




template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type        value_type;
  typedef typename _Iterator::difference_type   difference_type;
  typedef typename _Iterator::pointer           pointer;
  typedef typename _Iterator::reference         reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef _Tp*                        pointer;
  typedef _Tp&                        reference;
};

template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef const _Tp*                  pointer;
  typedef const _Tp&                  reference;
};

 
 
 
 

 

template <class _Iter>
inline typename iterator_traits<_Iter>::iterator_category
__iterator_category(const _Iter&)
{
  typedef typename iterator_traits<_Iter>::iterator_category _Category;
  return _Category();
}

template <class _Iter>
inline typename iterator_traits<_Iter>::difference_type*
__distance_type(const _Iter&)
{
  return static_cast<typename iterator_traits<_Iter>::difference_type*>(0);
}

template <class _Iter>
inline typename iterator_traits<_Iter>::value_type*
__value_type(const _Iter&)
{
  return static_cast<typename iterator_traits<_Iter>::value_type*>(0);
}

template <class _Iter>
inline typename iterator_traits<_Iter>::iterator_category
iterator_category(const _Iter& __i) { return __iterator_category(__i); }


template <class _Iter>
inline typename iterator_traits<_Iter>::difference_type*
distance_type(const _Iter& __i) { return __distance_type(__i); }

template <class _Iter>
inline typename iterator_traits<_Iter>::value_type*
value_type(const _Iter& __i) { return __value_type(__i); }





// 259 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_iterator.h" 3


template <class _InputIterator, class _Distance>
inline void __distance(_InputIterator __first, _InputIterator __last,
                       _Distance& __n, input_iterator_tag)
{
  while (__first != __last) { ++__first; ++__n; }
}

template <class _RandomAccessIterator, class _Distance>
inline void __distance(_RandomAccessIterator __first, 
                       _RandomAccessIterator __last, 
                       _Distance& __n, random_access_iterator_tag)
{
  __n += __last - __first;
}

template <class _InputIterator, class _Distance>
inline void distance(_InputIterator __first, 
                     _InputIterator __last, _Distance& __n)
{
  __distance(__first, __last, __n, iterator_category(__first));
}



template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
__distance(_InputIterator __first, _InputIterator __last, input_iterator_tag)
{
  typename iterator_traits<_InputIterator>::difference_type __n = 0;
  while (__first != __last) {
    ++__first; ++__n;
  }
  return __n;
}

template <class _RandomAccessIterator>
inline typename iterator_traits<_RandomAccessIterator>::difference_type
__distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
           random_access_iterator_tag) {
  return __last - __first;
}

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
distance(_InputIterator __first, _InputIterator __last) {
  typedef typename iterator_traits<_InputIterator>::iterator_category 
    _Category;
  return __distance(__first, __last, _Category());
}



template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, input_iterator_tag) {
  while (__n--) ++__i;
}





template <class _BidirectionalIterator, class _Distance>
inline void __advance(_BidirectionalIterator& __i, _Distance __n, 
                      bidirectional_iterator_tag) {
  if (__n >= 0)
    while (__n--) ++__i;
  else
    while (__n++) --__i;
}





template <class _RandomAccessIterator, class _Distance>
inline void __advance(_RandomAccessIterator& __i, _Distance __n, 
                      random_access_iterator_tag) {
  __i += __n;
}

template <class _InputIterator, class _Distance>
inline void advance(_InputIterator& __i, _Distance __n) {
  __advance(__i, __n, iterator_category(__i));
}

template <class _Container>
class back_insert_iterator {
protected:
  _Container* container;
public:
  typedef _Container          container_type;
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;

  explicit back_insert_iterator(_Container& __x) : container(&__x) {}
  back_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __value) { 
    container->push_back(__value);
    return *this;
  }
  back_insert_iterator<_Container>& operator*() { return *this; }
  back_insert_iterator<_Container>& operator++() { return *this; }
  back_insert_iterator<_Container>& operator++(int) { return *this; }
};

// 378 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_iterator.h" 3


template <class _Container>
inline back_insert_iterator<_Container> back_inserter(_Container& __x) {
  return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class front_insert_iterator {
protected:
  _Container* container;
public:
  typedef _Container          container_type;
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;

  explicit front_insert_iterator(_Container& __x) : container(&__x) {}
  front_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __value) { 
    container->push_front(__value);
    return *this;
  }
  front_insert_iterator<_Container>& operator*() { return *this; }
  front_insert_iterator<_Container>& operator++() { return *this; }
  front_insert_iterator<_Container>& operator++(int) { return *this; }
};

// 417 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_iterator.h" 3


template <class _Container>
inline front_insert_iterator<_Container> front_inserter(_Container& __x) {
  return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class insert_iterator {
protected:
  _Container* container;
  typename _Container::iterator iter;
public:
  typedef _Container          container_type;
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;

  insert_iterator(_Container& __x, typename _Container::iterator __i) 
    : container(&__x), iter(__i) {}
  insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __value) { 
    iter = container->insert(iter, __value);
    ++iter;
    return *this;
  }
  insert_iterator<_Container>& operator*() { return *this; }
  insert_iterator<_Container>& operator++() { return *this; }
  insert_iterator<_Container>& operator++(int) { return *this; }
};

// 459 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_iterator.h" 3


template <class _Container, class _Iterator>
inline 
insert_iterator<_Container> inserter(_Container& __x, _Iterator __i)
{
  typedef typename _Container::iterator __iter;
  return insert_iterator<_Container>(__x, __iter(__i));
}


template <class _BidirectionalIterator, class _Tp, class _Reference = _Tp&, 
          class _Distance = ptrdiff_t> 




class reverse_bidirectional_iterator {
  typedef reverse_bidirectional_iterator<_BidirectionalIterator, _Tp, 
                                         _Reference, _Distance>  _Self;
protected:
  _BidirectionalIterator current;
public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp                        value_type;
  typedef _Distance                  difference_type;
  typedef _Tp*                       pointer;
  typedef _Reference                 reference;

  reverse_bidirectional_iterator() {}
  explicit reverse_bidirectional_iterator(_BidirectionalIterator __x)
    : current(__x) {}
  _BidirectionalIterator base() const { return current; }
  _Reference operator*() const {
    _BidirectionalIterator __tmp = current;
    return *--__tmp;
  }

  pointer operator->() const { return &(operator*()); }

  _Self& operator++() {
    --current;
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    --current;
    return __tmp;
  }
  _Self& operator--() {
    ++current;
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    ++current;
    return __tmp;
  }
};

// 550 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_iterator.h" 3


template <class _BiIter, class _Tp, class _Ref,
          class _Distance>
inline bool operator==(
    const reverse_bidirectional_iterator<_BiIter, _Tp, _Ref, _Distance>& __x, 
    const reverse_bidirectional_iterator<_BiIter, _Tp, _Ref, _Distance>& __y)
{
  return __x.base() == __y.base();
}



 
 
 
 
 

template <class _Iterator>
class reverse_iterator 
{
protected:
  _Iterator current;
public:
  typedef typename iterator_traits<_Iterator>::iterator_category
          iterator_category;
  typedef typename iterator_traits<_Iterator>::value_type
          value_type;
  typedef typename iterator_traits<_Iterator>::difference_type
          difference_type;
  typedef typename iterator_traits<_Iterator>::pointer
          pointer;
  typedef typename iterator_traits<_Iterator>::reference
          reference;

  typedef _Iterator iterator_type;
  typedef reverse_iterator<_Iterator> _Self;

public:
  reverse_iterator() {}
  explicit reverse_iterator(iterator_type __x) : current(__x) {}

  reverse_iterator(const _Self& __x) : current(__x.current) {}

  template <class _Iter>
  reverse_iterator(const reverse_iterator<_Iter>& __x)
    : current(__x.base()) {}

    
  iterator_type base() const { return current; }
  reference operator*() const {
    _Iterator __tmp = current;
    return *--__tmp;
  }

  pointer operator->() const { return &(operator*()); }


  _Self& operator++() {
    --current;
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    --current;
    return __tmp;
  }
  _Self& operator--() {
    ++current;
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    ++current;
    return __tmp;
  }

  _Self operator+(difference_type __n) const {
    return _Self(current - __n);
  }
  _Self& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  _Self operator-(difference_type __n) const {
    return _Self(current + __n);
  }
  _Self& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  reference operator[](difference_type __n) const { return *(*this + __n); }  
}; 
 
template <class _Iterator>
inline bool operator==(const reverse_iterator<_Iterator>& __x, 
                       const reverse_iterator<_Iterator>& __y) {
  return __x.base() == __y.base();
}

template <class _Iterator>
inline bool operator<(const reverse_iterator<_Iterator>& __x, 
                      const reverse_iterator<_Iterator>& __y) {
  return __y.base() < __x.base();
}

template <class _Iterator>
inline typename reverse_iterator<_Iterator>::difference_type
operator-(const reverse_iterator<_Iterator>& __x, 
          const reverse_iterator<_Iterator>& __y) {
  return __y.base() - __x.base();
}

template <class _Iterator>
inline reverse_iterator<_Iterator> 
operator+(typename reverse_iterator<_Iterator>::difference_type __n,
          const reverse_iterator<_Iterator>& __x) {
  return reverse_iterator<_Iterator>(__x.base() - __n);
}

// 805 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_iterator.h" 3


 
 

template <class _Tp, class _Dist = ptrdiff_t> 
class istream_iterator {
  friend bool operator== <>  (const istream_iterator&,
                                               const istream_iterator&);
protected:
  istream* _M_stream;
  _Tp _M_value;
  bool _M_end_marker;
  void _M_read() {
    _M_end_marker = (*_M_stream) ? true : false;
    if (_M_end_marker) *_M_stream >> _M_value;
    _M_end_marker = (*_M_stream) ? true : false;
  }
public:
  typedef input_iterator_tag  iterator_category;
  typedef _Tp                 value_type;
  typedef _Dist               difference_type;
  typedef const _Tp*          pointer;
  typedef const _Tp&          reference;

  istream_iterator() : _M_stream(&cin), _M_end_marker(false) {}
  istream_iterator(istream& __s) : _M_stream(&__s) { _M_read(); }
  reference operator*() const { return _M_value; }

  pointer operator->() const { return &(operator*()); }

  istream_iterator<_Tp, _Dist>& operator++() { 
    _M_read(); 
    return *this;
  }
  istream_iterator<_Tp, _Dist> operator++(int)  {
    istream_iterator<_Tp, _Dist> __tmp = *this;
    _M_read();
    return __tmp;
  }
};

// 864 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_iterator.h" 3


template <class _Tp, class _Distance>
inline bool operator==(const istream_iterator<_Tp, _Distance>& __x,
                       const istream_iterator<_Tp, _Distance>& __y) {
  return (__x._M_stream == __y._M_stream &&
          __x._M_end_marker == __y._M_end_marker) ||
         __x._M_end_marker == false && __y._M_end_marker == false;
}

template <class _Tp>
class ostream_iterator {
protected:
  ostream* _M_stream;
  const char* _M_string;
public:
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;

  ostream_iterator(ostream& __s) : _M_stream(&__s), _M_string(0) {}
  ostream_iterator(ostream& __s, const char* __c) 
    : _M_stream(&__s), _M_string(__c)  {}
  ostream_iterator<_Tp>& operator=(const _Tp& __value) { 
    *_M_stream << __value;
    if (_M_string) *_M_stream << _M_string;
    return *this;
  }
  ostream_iterator<_Tp>& operator*() { return *this; }
  ostream_iterator<_Tp>& operator++() { return *this; } 
  ostream_iterator<_Tp>& operator++(int) { return *this; } 
};

// 907 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/stl_iterator.h" 3


 



 
 
 
// 38 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/iterator" 2 3




 
 
 
// 44 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/bastring.h" 2 3




extern void __out_of_range (const char *);
extern void __length_error (const char *);














template <class charT, class traits = string_char_traits<charT>,
	  class Allocator = alloc >
class basic_string
{
private:
  struct Rep {
    size_t len, res, ref;
    bool selfish;

    charT* data () { return reinterpret_cast<charT *>(this + 1); }
    charT& operator[] (size_t s) { return data () [s]; }
    charT* grab () { if (selfish) return clone (); ++ref; return data (); }
// 108 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/bastring.h" 3

    void release () { if (--ref == 0) delete this; }


    inline static void * operator new (size_t, size_t);
    inline static void operator delete (void *);
    inline static Rep* create (size_t);
    charT* clone ();

    inline void copy (size_t, const charT *, size_t);
    inline void move (size_t, const charT *, size_t);
    inline void set  (size_t, const charT,   size_t);

    inline static bool excess_slop (size_t, size_t);
    inline static size_t frob_size (size_t);

  private:
    Rep &operator= (const Rep &);
  };

public:
 
  typedef	   traits		traits_type;
  typedef typename traits::char_type	value_type;
  typedef	   Allocator		allocator_type;

  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef charT& reference;
  typedef const charT& const_reference;
  typedef charT* pointer;
  typedef const charT* const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;
  typedef ::reverse_iterator<iterator> reverse_iterator;
  typedef ::reverse_iterator<const_iterator> const_reverse_iterator;
  static const size_type npos = static_cast<size_type>(-1);

private:
  Rep *rep () const { return reinterpret_cast<Rep *>(dat) - 1; }
  void repup (Rep *p) { rep ()->release (); dat = p->data (); }

public:
  const charT* data () const
    { return rep ()->data(); }
  size_type length () const
    { return rep ()->len; }
  size_type size () const
    { return rep ()->len; }
  size_type capacity () const
    { return rep ()->res; }
  size_type max_size () const
    { return (npos - 1)/sizeof (charT); }		 
  bool empty () const
    { return size () == 0; }

 
  basic_string& operator= (const basic_string& str)
    {
      if (&str != this) { rep ()->release (); dat = str.rep ()->grab (); }
      return *this;
    }

  explicit basic_string (): dat (nilRep.grab ()) { }
  basic_string (const basic_string& str): dat (str.rep ()->grab ()) { }
  basic_string (const basic_string& str, size_type pos, size_type n = npos)
    : dat (nilRep.grab ()) { assign (str, pos, n); }
  basic_string (const charT* s, size_type n)
    : dat (nilRep.grab ()) { assign (s, n); }
  basic_string (const charT* s)
    : dat (nilRep.grab ()) { assign (s); }
  basic_string (size_type n, charT c)
    : dat (nilRep.grab ()) { assign (n, c); }

  template<class InputIterator>
    basic_string(InputIterator __begin, InputIterator __end)



    : dat (nilRep.grab ()) { assign (__begin, __end); }

  ~basic_string ()
    { rep ()->release (); }

  void swap (basic_string &s) { charT *d = dat; dat = s.dat; s.dat = d; }

  basic_string& append (const basic_string& str, size_type pos = 0,
			size_type n = npos)
    { return replace (length (), 0, str, pos, n); }
  basic_string& append (const charT* s, size_type n)
    { return replace (length (), 0, s, n); }
  basic_string& append (const charT* s)
    { return append (s, traits::length (s)); }
  basic_string& append (size_type n, charT c)
    { return replace (length (), 0, n, c); }

  template<class InputIterator>
    basic_string& append(InputIterator first, InputIterator last)



    { return replace (iend (), iend (), first, last); }

  void push_back(charT __c)
  { append(1, __c); }
  
  basic_string& assign (const basic_string& str, size_type pos = 0,
			size_type n = npos)
    { return replace (0, npos, str, pos, n); }
  basic_string& assign (const charT* s, size_type n)
    { return replace (0, npos, s, n); }
  basic_string& assign (const charT* s)
    { return assign (s, traits::length (s)); }
  basic_string& assign (size_type n, charT c)
    { return replace (0, npos, n, c); }

  template<class InputIterator>
    basic_string& assign(InputIterator first, InputIterator last)



    { return replace (ibegin (), iend (), first, last); }

  basic_string& operator= (const charT* s)
    { return assign (s); }
  basic_string& operator= (charT c)
    { return assign (1, c); }

  basic_string& operator+= (const basic_string& rhs)
    { return append (rhs); }
  basic_string& operator+= (const charT* s)
    { return append (s); }
  basic_string& operator+= (charT c)
    { return append (1, c); }

  basic_string& insert (size_type pos1, const basic_string& str,
			size_type pos2 = 0, size_type n = npos)
    { return replace (pos1, 0, str, pos2, n); }
  basic_string& insert (size_type pos, const charT* s, size_type n)
    { return replace (pos, 0, s, n); }
  basic_string& insert (size_type pos, const charT* s)
    { return insert (pos, s, traits::length (s)); }
  basic_string& insert (size_type pos, size_type n, charT c)
    { return replace (pos, 0, n, c); }
  iterator insert(iterator p, charT c)
    { size_type __o = p - ibegin ();
      insert (p - ibegin (), 1, c); selfish ();
      return ibegin () + __o; }
  iterator insert(iterator p, size_type n, charT c)
    { size_type __o = p - ibegin ();
      insert (p - ibegin (), n, c); selfish ();
      return ibegin () + __o; }

  template<class InputIterator>
    void insert(iterator p, InputIterator first, InputIterator last)



    { replace (p, p, first, last); }

  basic_string& erase (size_type pos = 0, size_type n = npos)
    { return replace (pos, n, (size_type)0, (charT)0); }
  iterator erase(iterator p)
    { size_type __o = p - begin();
      replace (__o, 1, (size_type)0, (charT)0); selfish ();
      return ibegin() + __o; }
  iterator erase(iterator f, iterator l)
    { size_type __o = f - ibegin();
      replace (__o, l-f, (size_type)0, (charT)0);selfish ();
      return ibegin() + __o; }

  basic_string& replace (size_type pos1, size_type n1, const basic_string& str,
			 size_type pos2 = 0, size_type n2 = npos);
  basic_string& replace (size_type pos, size_type n1, const charT* s,
			 size_type n2);
  basic_string& replace (size_type pos, size_type n1, const charT* s)
    { return replace (pos, n1, s, traits::length (s)); }
  basic_string& replace (size_type pos, size_type n1, size_type n2, charT c);
  basic_string& replace (size_type pos, size_type n, charT c)
    { return replace (pos, n, 1, c); }
  basic_string& replace (iterator i1, iterator i2, const basic_string& str)
    { return replace (i1 - ibegin (), i2 - i1, str); }
  basic_string& replace (iterator i1, iterator i2, const charT* s, size_type n)
    { return replace (i1 - ibegin (), i2 - i1, s, n); }
  basic_string& replace (iterator i1, iterator i2, const charT* s)
    { return replace (i1 - ibegin (), i2 - i1, s); }
  basic_string& replace (iterator i1, iterator i2, size_type n, charT c)
    { return replace (i1 - ibegin (), i2 - i1, n, c); }

  template<class InputIterator>
    basic_string& replace(iterator i1, iterator i2,
			  InputIterator j1, InputIterator j2);





private:
  static charT eos () { return traits::eos (); }
  void unique () { if (rep ()->ref > 1) alloc (length (), true); }
  void selfish () { unique (); rep ()->selfish = true; }

public:
  charT operator[] (size_type pos) const
    {
      if (pos == length ())
	return eos ();
      return data ()[pos];
    }

  reference operator[] (size_type pos)
    { selfish (); return (*rep ())[pos]; }

  reference at (size_type pos)
    {
      do { if ( pos >= length () ) __out_of_range ("pos >= length ()"); } while (0) ;
      return (*this)[pos];
    }
  const_reference at (size_type pos) const
    {
      do { if ( pos >= length () ) __out_of_range ("pos >= length ()"); } while (0) ;
      return data ()[pos];
    }

private:
  void terminate () const
    { traits::assign ((*rep ())[length ()], eos ()); }

public:
  const charT* c_str () const
    { if (length () == 0) return ""; terminate (); return data (); }
  void resize (size_type n, charT c);
  void resize (size_type n)
    { resize (n, eos ()); }
  void reserve (size_type) { }

  size_type copy (charT* s, size_type n, size_type pos = 0) const;

  size_type find (const basic_string& str, size_type pos = 0) const
    { return find (str.data(), pos, str.length()); }
  size_type find (const charT* s, size_type pos, size_type n) const;
  size_type find (const charT* s, size_type pos = 0) const
    { return find (s, pos, traits::length (s)); }
  size_type find (charT c, size_type pos = 0) const;

  size_type rfind (const basic_string& str, size_type pos = npos) const
    { return rfind (str.data(), pos, str.length()); }
  size_type rfind (const charT* s, size_type pos, size_type n) const;
  size_type rfind (const charT* s, size_type pos = npos) const
    { return rfind (s, pos, traits::length (s)); }
  size_type rfind (charT c, size_type pos = npos) const;

  size_type find_first_of (const basic_string& str, size_type pos = 0) const
    { return find_first_of (str.data(), pos, str.length()); }
  size_type find_first_of (const charT* s, size_type pos, size_type n) const;
  size_type find_first_of (const charT* s, size_type pos = 0) const
    { return find_first_of (s, pos, traits::length (s)); }
  size_type find_first_of (charT c, size_type pos = 0) const
    { return find (c, pos); }

  size_type find_last_of (const basic_string& str, size_type pos = npos) const
    { return find_last_of (str.data(), pos, str.length()); }
  size_type find_last_of (const charT* s, size_type pos, size_type n) const;
  size_type find_last_of (const charT* s, size_type pos = npos) const
    { return find_last_of (s, pos, traits::length (s)); }
  size_type find_last_of (charT c, size_type pos = npos) const
    { return rfind (c, pos); }

  size_type find_first_not_of (const basic_string& str, size_type pos = 0) const
    { return find_first_not_of (str.data(), pos, str.length()); }
  size_type find_first_not_of (const charT* s, size_type pos, size_type n) const;
  size_type find_first_not_of (const charT* s, size_type pos = 0) const
    { return find_first_not_of (s, pos, traits::length (s)); }
  size_type find_first_not_of (charT c, size_type pos = 0) const;

  size_type find_last_not_of (const basic_string& str, size_type pos = npos) const
    { return find_last_not_of (str.data(), pos, str.length()); }
  size_type find_last_not_of (const charT* s, size_type pos, size_type n) const;
  size_type find_last_not_of (const charT* s, size_type pos = npos) const
    { return find_last_not_of (s, pos, traits::length (s)); }
  size_type find_last_not_of (charT c, size_type pos = npos) const;

  basic_string substr (size_type pos = 0, size_type n = npos) const
    { return basic_string (*this, pos, n); }

  int compare (const basic_string& str, size_type pos = 0, size_type n = npos) const;
   
  int compare (const charT* s, size_type pos, size_type n) const;
  int compare (const charT* s, size_type pos = 0) const
    { return compare (s, pos, traits::length (s)); }

  iterator begin () { selfish (); return &(*this)[0]; }
  iterator end () { selfish (); return &(*this)[length ()]; }

private:
  iterator ibegin () const { return &(*rep ())[0]; }
  iterator iend () const { return &(*rep ())[length ()]; }

public:
  const_iterator begin () const { return ibegin (); }
  const_iterator end () const { return iend (); }

  reverse_iterator       rbegin() { return reverse_iterator (end ()); }
  const_reverse_iterator rbegin() const
    { return const_reverse_iterator (end ()); }
  reverse_iterator       rend() { return reverse_iterator (begin ()); }
  const_reverse_iterator rend() const
    { return const_reverse_iterator (begin ()); }

private:
  void alloc (size_type size, bool save);
  static size_type _find (const charT* ptr, charT c, size_type xpos, size_type len);
  inline bool check_realloc (size_type s) const;

  static Rep nilRep;
  charT *dat;
};


template <class charT, class traits, class Allocator> template <class InputIterator>
basic_string <charT, traits, Allocator>& basic_string <charT, traits, Allocator>::
replace (iterator i1, iterator i2, InputIterator j1, InputIterator j2)





{
  const size_type len = length ();
  size_type pos = i1 - ibegin ();
  size_type n1 = i2 - i1;
  size_type n2 = j2 - j1;

  do { if ( pos > len ) __out_of_range ("pos > len"); } while (0) ;
  if (n1 > len - pos)
    n1 = len - pos;
  do { if ( len - n1 > max_size () - n2 ) __length_error ("len - n1 > max_size () - n2"); } while (0) ;
  size_t newlen = len - n1 + n2;

  if (check_realloc (newlen))
    {
      Rep *p = Rep::create (newlen);
      p->copy (0, data (), pos);
      p->copy (pos + n2, data () + pos + n1, len - (pos + n1));
      for (; j1 != j2; ++j1, ++pos)
	traits::assign ((*p)[pos], *j1);
      repup (p);
    }
  else
    {
      rep ()->move (pos + n2, data () + pos + n1, len - (pos + n1));
      for (; j1 != j2; ++j1, ++pos)
	traits::assign ((*rep ())[pos], *j1);
    }
  rep ()->len = newlen;

  return *this;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>
operator+ (const basic_string <charT, traits, Allocator>& lhs,
	   const basic_string <charT, traits, Allocator>& rhs)
{
  basic_string <charT, traits, Allocator> str (lhs);
  str.append (rhs);
  return str;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>
operator+ (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  basic_string <charT, traits, Allocator> str (lhs);
  str.append (rhs);
  return str;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>
operator+ (charT lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  basic_string <charT, traits, Allocator> str (1, lhs);
  str.append (rhs);
  return str;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>
operator+ (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  basic_string <charT, traits, Allocator> str (lhs);
  str.append (rhs);
  return str;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>
operator+ (const basic_string <charT, traits, Allocator>& lhs, charT rhs)
{
  basic_string <charT, traits, Allocator> str (lhs);
  str.append (1, rhs);
  return str;
}

template <class charT, class traits, class Allocator>
inline bool
operator== (const basic_string <charT, traits, Allocator>& lhs,
	    const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) == 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator== (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) == 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator== (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) == 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator!= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) != 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator!= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) != 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator< (const basic_string <charT, traits, Allocator>& lhs,
	    const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) < 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator< (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) > 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator< (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) < 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator> (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) < 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator> (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) > 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator<= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) >= 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator<= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) <= 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator>= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)
{
  return (rhs.compare (lhs) <= 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator>= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)
{
  return (lhs.compare (rhs) >= 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator!= (const basic_string <charT, traits, Allocator>& lhs,
	    const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) != 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator> (const basic_string <charT, traits, Allocator>& lhs,
	   const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) > 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator<= (const basic_string <charT, traits, Allocator>& lhs,
	    const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) <= 0);
}

template <class charT, class traits, class Allocator>
inline bool
operator>= (const basic_string <charT, traits, Allocator>& lhs,
	    const basic_string <charT, traits, Allocator>& rhs)
{
  return (lhs.compare (rhs) >= 0);
}

class istream; class ostream;
template <class charT, class traits, class Allocator> istream&
operator>> (istream&, basic_string <charT, traits, Allocator>&);
template <class charT, class traits, class Allocator> ostream&
operator<< (ostream&, const basic_string <charT, traits, Allocator>&);
template <class charT, class traits, class Allocator> istream&
getline (istream&, basic_string <charT, traits, Allocator>&, charT delim = '\n');

}  

// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/bastring.cc" 1 3
 
 

 
 
 
 
 

 
 
 
 

 
 
 

 
 
 
 
 

 
 

extern "C++" {
template <class charT, class traits, class Allocator>
inline void * basic_string <charT, traits, Allocator>::Rep::
operator new (size_t s, size_t extra)
{
  return Allocator::allocate(s + extra * sizeof (charT));
}

template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
operator delete (void * ptr)
{
  Allocator::deallocate(ptr, sizeof(Rep) +
			reinterpret_cast<Rep *>(ptr)->res *
			sizeof (charT));
}

template <class charT, class traits, class Allocator>
inline size_t basic_string <charT, traits, Allocator>::Rep::
frob_size (size_t s)
{
  size_t i = 16;
  while (i < s) i *= 2;
  return i;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>::Rep *
basic_string <charT, traits, Allocator>::Rep::
create (size_t extra)
{
  extra = frob_size (extra + 1);
  Rep *p = new (extra) Rep;
  p->res = extra;
  p->ref = 1;
  p->selfish = false;
  return p;
}

template <class charT, class traits, class Allocator>
charT * basic_string <charT, traits, Allocator>::Rep::
clone ()
{
  Rep *p = Rep::create (len);
  p->copy (0, data (), len);
  p->len = len;
  return p->data ();
}

template <class charT, class traits, class Allocator>
inline bool basic_string <charT, traits, Allocator>::Rep::
excess_slop (size_t s, size_t r)
{
  return 2 * (s <= 16 ? 16 : s) < r;
}

template <class charT, class traits, class Allocator>
inline bool basic_string <charT, traits, Allocator>::
check_realloc (basic_string::size_type s) const
{
  s += sizeof (charT);
  rep ()->selfish = false;
  return (rep ()->ref > 1
	  || s > capacity ()
	  || Rep::excess_slop (s, capacity ()));
}

template <class charT, class traits, class Allocator>
void basic_string <charT, traits, Allocator>::
alloc (basic_string::size_type __size, bool __save)
{
  if (! check_realloc (__size))
    return;

  Rep *p = Rep::create (__size);

  if (__save)
    {
      p->copy (0, data (), length ());
      p->len = length ();
    }
  else
    p->len = 0;

  repup (p);
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>&
basic_string <charT, traits, Allocator>::
replace (size_type pos1, size_type n1,
	 const basic_string& str, size_type pos2, size_type n2)
{
  const size_t len2 = str.length ();

  if (pos1 == 0 && n1 >= length () && pos2 == 0 && n2 >= len2)
    return operator= (str);

  do { if ( pos2 > len2 ) __out_of_range ("pos2 > len2"); } while (0) ;

  if (n2 > len2 - pos2)
    n2 = len2 - pos2;

  return replace (pos1, n1, str.data () + pos2, n2);
}

template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
copy (size_t pos, const charT *s, size_t n)
{
  if (n)
    traits::copy (data () + pos, s, n);
}

template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
move (size_t pos, const charT *s, size_t n)
{
  if (n)
    traits::move (data () + pos, s, n);
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>&
basic_string <charT, traits, Allocator>::
replace (size_type pos, size_type n1, const charT* s, size_type n2)
{
  const size_type len = length ();
  do { if ( pos > len ) __out_of_range ("pos > len"); } while (0) ;
  if (n1 > len - pos)
    n1 = len - pos;
  do { if ( len - n1 > max_size () - n2 ) __length_error ("len - n1 > max_size () - n2"); } while (0) ;
  size_t newlen = len - n1 + n2;

  if (check_realloc (newlen))
    {
      Rep *p = Rep::create (newlen);
      p->copy (0, data (), pos);
      p->copy (pos + n2, data () + pos + n1, len - (pos + n1));
      p->copy (pos, s, n2);
      repup (p);
    }
  else
    {
      rep ()->move (pos + n2, data () + pos + n1, len - (pos + n1));
      rep ()->copy (pos, s, n2);
    }
  rep ()->len = newlen;

  return *this;
}

template <class charT, class traits, class Allocator>
inline void basic_string <charT, traits, Allocator>::Rep::
set (size_t pos, const charT c, size_t n)
{
  traits::set  (data () + pos, c, n);
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>& basic_string <charT, traits, Allocator>::
replace (size_type pos, size_type n1, size_type n2, charT c)
{
  const size_t len = length ();
  do { if ( pos > len ) __out_of_range ("pos > len"); } while (0) ;
  if (n1 > len - pos)
    n1 = len - pos;
  do { if ( len - n1 > max_size () - n2 ) __length_error ("len - n1 > max_size () - n2"); } while (0) ;
  size_t newlen = len - n1 + n2;

  if (check_realloc (newlen))
    {
      Rep *p = Rep::create (newlen);
      p->copy (0, data (), pos);
      p->copy (pos + n2, data () + pos + n1, len - (pos + n1));
      p->set  (pos, c, n2);
      repup (p);
    }
  else
    {
      rep ()->move (pos + n2, data () + pos + n1, len - (pos + n1));
      rep ()->set  (pos, c, n2);
    }
  rep ()->len = newlen;

  return *this;
}

template <class charT, class traits, class Allocator>
void basic_string <charT, traits, Allocator>::
resize (size_type n, charT c)
{
  do { if ( n > max_size () ) __length_error ("n > max_size ()"); } while (0) ;

  if (n > length ())
    append (n - length (), c);
  else
    erase (n);
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
copy (charT* s, size_type n, size_type pos) const
{
  do { if ( pos > length () ) __out_of_range ("pos > length ()"); } while (0) ;

  if (n > length () - pos)
    n = length () - pos;

  traits::copy (s, data () + pos, n);
  return n;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find (const charT* s, size_type pos, size_type n) const
{
  size_t xpos = pos;
  for (; xpos + n <= length (); ++xpos)
    if (traits::eq (data () [xpos], *s)
	&& traits::compare (data () + xpos, s, n) == 0)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
inline basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
_find (const charT* ptr, charT c, size_type xpos, size_type len)
{
  for (; xpos < len; ++xpos)
    if (traits::eq (ptr [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find (charT c, size_type pos) const
{
  return _find (data (), c, pos, length ());
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
rfind (const charT* s, size_type pos, size_type n) const
{
  if (n > length ())
    return npos;

  size_t xpos = length () - n;
  if (xpos > pos)
    xpos = pos;

  for (++xpos; xpos-- > 0; )
    if (traits::eq (data () [xpos], *s)
	&& traits::compare (data () + xpos, s, n) == 0)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
rfind (charT c, size_type pos) const
{
  if (1 > length ())
    return npos;

  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;

  for (++xpos; xpos-- > 0; )
    if (traits::eq (data () [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_first_of (const charT* s, size_type pos, size_type n) const
{
  size_t xpos = pos;
  for (; xpos < length (); ++xpos)
    if (_find (s, data () [xpos], 0, n) != npos)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_last_of (const charT* s, size_type pos, size_type n) const
{
  if (length() == 0)
    return npos;
  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;
  for (++xpos; xpos-- > 0;)
    if (_find (s, data () [xpos], 0, n) != npos)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_first_not_of (const charT* s, size_type pos, size_type n) const
{
  size_t xpos = pos;
  for (; xpos < length (); ++xpos)
    if (_find (s, data () [xpos], 0, n) == npos)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_first_not_of (charT c, size_type pos) const
{
  size_t xpos = pos;
  for (; xpos < length (); ++xpos)
    if (traits::ne (data () [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_last_not_of (const charT* s, size_type pos, size_type n) const
{
  if (length() == 0)
    return npos;
  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;
  for (++xpos; xpos-- > 0;)
    if (_find (s, data () [xpos], 0, n) == npos)
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::
find_last_not_of (charT c, size_type pos) const
{
  if (length() == 0)
    return npos;
  size_t xpos = length () - 1;
  if (xpos > pos)
    xpos = pos;
  for (++xpos; xpos-- > 0;)
    if (traits::ne (data () [xpos], c))
      return xpos;
  return npos;
}

template <class charT, class traits, class Allocator>
int basic_string <charT, traits, Allocator>::
compare (const basic_string& str, size_type pos, size_type n) const
{
  do { if ( pos > length () ) __out_of_range ("pos > length ()"); } while (0) ;

  size_t rlen = length () - pos;
  if (rlen > n)
    rlen = n;
  if (rlen > str.length ())
    rlen = str.length ();
  int r = traits::compare (data () + pos, str.data (), rlen);
  if (r != 0)
    return r;
  if (rlen == n)
    return 0;
  return (length () - pos) - str.length ();
}

template <class charT, class traits, class Allocator>
int basic_string <charT, traits, Allocator>::
compare (const charT* s, size_type pos, size_type n) const
{
  do { if ( pos > length () ) __out_of_range ("pos > length ()"); } while (0) ;

  size_t rlen = length () - pos;
  if (rlen > n)
    rlen = n;
  int r = traits::compare (data () + pos, s, rlen);
  if (r != 0)
    return r;
  return (length () - pos) - n;
}



template <class charT, class traits, class Allocator>
istream &
operator>> (istream &is, basic_string <charT, traits, Allocator> &s)
{
  int w = is.width (0);
  if (is.ipfx0 ())
    {
      register streambuf *sb = is.rdbuf ();
      s.resize (0);
      while (1)
	{
	  int ch = sb->sbumpc ();
	  if (ch == (-1) )
	    {
	      is.setstate (ios::eofbit);
	      break;
	    }
	  else if (traits::is_del (ch))
	    {
	      sb->sungetc ();
	      break;
	    }
	  s += static_cast<charT> (ch);
	  if (--w == 1)
	    break;
	}
    }

  is.isfx ();
  if (s.length () == 0)
    is.setstate (ios::failbit);

  return is;
}

template <class charT, class traits, class Allocator>
ostream &
operator<< (ostream &o, const basic_string <charT, traits, Allocator>& s)
{
  return o.write (s.data (), s.length ());
}

template <class charT, class traits, class Allocator>
istream&
getline (istream &is, basic_string <charT, traits, Allocator>& s, charT delim)
{
  if (is.ipfx1 ())
    {
      _G_size_t  count = 0;
      streambuf *sb = is.rdbuf ();
      s.resize (0);

      while (1)
	{
	  int ch = sb->sbumpc ();
	  if (ch == (-1) )
	    {
	      is.setstate (count == 0
			   ? (ios::failbit|ios::eofbit)
			   : ios::eofbit);
	      break;
	    }

	  ++count;

	  if (ch == delim)
	    break;

	  s += static_cast<charT> (ch);

	  if (s.length () == s.npos - 1)
	    {
	      is.setstate (ios::failbit);
	      break;
	    }
	}
    }

   
   
  is.isfx ();

  return is;
}

template <class charT, class traits, class Allocator>
basic_string <charT, traits, Allocator>::Rep
basic_string<charT, traits, Allocator>::nilRep = { 0, 0, 1, false };

template <class charT, class traits, class Allocator>
const basic_string <charT, traits, Allocator>::size_type
basic_string <charT, traits, Allocator>::npos;

}  
// 655 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/std/bastring.h" 2 3



// 6 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/g++-3/string" 2 3


extern "C++" {
typedef basic_string <char> string;
 
}  


// 84 "c:/home/cvs_08_may_03/boost/boost/config/stdlib/sgi.hpp" 2



 





 
 
 




 
 
 
 
 
 






// 44 "c:/home/cvs_08_may_03/boost/boost/config.hpp" 2



 

// 1 "c:/home/cvs_08_may_03/boost/boost/config/select_platform_config.hpp" 1
 

 
 
 
 
 

 

 
 
 
 

// 40 "c:/home/cvs_08_may_03/boost/boost/config/select_platform_config.hpp"

 


// 83 "c:/home/cvs_08_may_03/boost/boost/config/select_platform_config.hpp"




// 49 "c:/home/cvs_08_may_03/boost/boost/config.hpp" 2


 

// 1 "c:/home/cvs_08_may_03/boost/boost/config/platform/win32.hpp" 1
 
 
 
 
 
 

 

 
















 
 
 
 
 
 
 
 
 





 




// 53 "c:/home/cvs_08_may_03/boost/boost/config.hpp" 2



 
// 1 "c:/home/cvs_08_may_03/boost/boost/config/suffix.hpp" 1
 

 
 
 
 
 
 
 
 
 
 
 

 

 
 
 
 
 
 




 
 
 
 
 
 
// 1 "c:/home/mingw.old/bin/../lib/gcc-lib/mingw32/2.95.3-5/../../../../include/limits.h" 1 3
 































 


 









 












 









 







 







 











 









 








// 33 "c:/home/cvs_08_may_03/boost/boost/config/suffix.hpp" 2










 
 
 





 
 
 




 
 
 





 
 
 
 







 
 
 
 




 
 
 
 




 
 
 
 





 
 
 





 
 
 





 
 
 





 
 
 
 






 
 
 
 






 
 
 




 
 
 




 
 
 




 
 
 




 
 
 




 
 
 




 
 
 





 
 
 
 
 





 
 
 
 
 
 





 
 
 




 
 
 






 
 
 








 
 
 
 




 
 
 
 








 
 
 








 
 
 
 
 
 
 
 






 











 

// 315 "c:/home/cvs_08_may_03/boost/boost/config/suffix.hpp"


 
 
 
 
 







 
 
 
 
 
 
 
 
 
 













 
 
 
 
 
 
 
 
 







 
 
 
 







 
 
 
 
 
 
 
 
 
 







 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


// 458 "c:/home/cvs_08_may_03/boost/boost/config/suffix.hpp"


 















 

 
 
 
 
 



 
 
 
 
 
 
 
 




 
 
 
 



















// 57 "c:/home/cvs_08_may_03/boost/boost/config.hpp" 2














// 19 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/msvc.hpp" 2



// 17 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/adl_barrier.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/workaround.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_08_may_03/boost/boost/detail/workaround.hpp" 1
 
 
 
 
 



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 















// 17 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/workaround.hpp" 2



// 18 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/adl_barrier.hpp" 2


 
 
 
 
 



















// 17 "c:/home/cvs_mplbook/boost/boost/mpl/bool_fwd.hpp" 2


namespace mpl_ { namespace aux {} 

template< bool C_ > struct bool_;

 
typedef bool_<true> true_;
typedef bool_<false> false_;

} namespace boost { namespace mpl { using namespace mpl_; namespace aux { using namespace mpl_::aux; } }} 


// 17 "c:/home/cvs_mplbook/boost/boost/mpl/bool.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/static_constant.hpp" 1




 
 
 
 
 
 
 

 
 
 


 




// 18 "c:/home/cvs_mplbook/boost/boost/mpl/bool.hpp" 2


namespace mpl_ { namespace aux {} 

template< bool C_ > struct bool_
{
    static const  bool    value = C_  ;
    typedef bool_ type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};


template< bool C_ >
bool const bool_<C_>::value;


} namespace boost { namespace mpl { using namespace mpl_; namespace aux { using namespace mpl_::aux; } }} 


// 22 "c:/home/cvs_mplbook/boost/boost/mpl/or.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/nested_type_wknd.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/gcc.hpp" 1




 
 
 
 
 
 
 

 
 
 








// 17 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/nested_type_wknd.hpp" 2









namespace mpl_ { namespace aux {} 
namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}
} namespace boost { namespace mpl { using namespace mpl_; namespace aux { using namespace mpl_::aux; } }} 


















// 23 "c:/home/cvs_mplbook/boost/boost/mpl/or.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp" 1




 
 
 
 
 
 
 

 
 
 


// 1 "c:/home/cvs_mplbook/boost/boost/mpl/lambda_fwd.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/lambda_arity_param.hpp" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/ttp.hpp" 1




 
 
 
 
 
 
 

 
 
 
























// 20 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/lambda_arity_param.hpp" 2









// 17 "c:/home/cvs_mplbook/boost/boost/mpl/lambda_fwd.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/lambda.hpp" 1




 
 
 
 
 
 
 

 
 
 


// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/ctps.hpp" 1




 
 
 
 
 
 
 

 
 
 












 


// 18 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/lambda.hpp" 2


 
 










 
 


// 18 "c:/home/cvs_mplbook/boost/boost/mpl/lambda_fwd.hpp" 2





// 1 "c:/home/cvs_mplbook/boost/boost/mpl/int.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/int_fwd.hpp" 1




 
 
 
 
 
 
 

 
 
 



namespace mpl_ { namespace aux {} 

template< int N > struct int_;

} namespace boost { namespace mpl { using namespace mpl_; namespace aux { using namespace mpl_::aux; } }} 


// 17 "c:/home/cvs_mplbook/boost/boost/mpl/int.hpp" 2



// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/integral_wrapper.hpp" 1

 
 
 
 
 
 
 

 
 
 

 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/static_cast.hpp" 1




 
 

 
 
 
 
 
 
 
 
 
 
 
 












// 16 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/integral_wrapper.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/nttp.hpp" 1




 
 
 
 
 
 
 

 
 
 




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

// 50 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/nttp.hpp"





// 17 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/integral_wrapper.hpp" 2




// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp"








// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"

















// 37 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"






















// 18 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp" 2



















// 21 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/integral_wrapper.hpp" 2


















namespace mpl_ { namespace aux {} 

template<  int      N     >
struct   int_     
{
    static const  int     value = N  ;
 
 



    typedef   int_      type;

    typedef int  value_type;

 
 
 
// 69 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/integral_wrapper.hpp"

    typedef mpl_ ::   int_     <   ( int  )(  (value + 1) )    >  next;
    typedef mpl_ ::   int_     <   ( int  )(  (value - 1) )    >  prior;


     
     
     
     
    operator int () const { return static_cast< int >(this->value); } 
};


template<  int      N     >
int  const mpl_ ::   int_     <  N  > ::value;


} namespace boost { namespace mpl { using namespace mpl_; namespace aux { using namespace mpl_::aux; } }} 





// 20 "c:/home/cvs_mplbook/boost/boost/mpl/int.hpp" 2



// 23 "c:/home/cvs_mplbook/boost/boost/mpl/lambda_fwd.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/void.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/void_fwd.hpp" 1




 
 
 
 
 
 
 

 
 
 

namespace boost { namespace mpl {

struct void_;

}}


// 17 "c:/home/cvs_mplbook/boost/boost/mpl/void.hpp" 2


 
// 1 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/bool_trait_def.hpp" 1
 
 
 
 
 
 
 
 
 
 
 

 

// 1 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/template_arity_spec.hpp" 1
 
 
 
 
 
 
 
 
 
 
 

 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/template_arity_fwd.hpp" 1




 
 
 
 
 
 
 

 
 
 

namespace boost { namespace mpl { namespace aux {

template< typename F > struct template_arity;

}}}


// 15 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/template_arity_spec.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/params.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/preprocessor.hpp" 1




 
 
 
 
 
 
 

 
 
 



// 27 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/preprocessor.hpp"


 









// 17 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/params.hpp" 2


 
 
 
 



// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp"





// 36 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp"

// 26 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/params.hpp" 2

















// 63 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/params.hpp"



// 16 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/template_arity_spec.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/lambda_support.hpp" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 











// 134 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/lambda_support.hpp"



// 17 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/template_arity_spec.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/overload_resolution.hpp" 1




 
 
 
 
 
 
 

 
 
 



// 27 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/overload_resolution.hpp"



// 18 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/template_arity_spec.hpp" 2



// 34 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/template_arity_spec.hpp"



// 15 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/bool_trait_def.hpp" 2





// 34 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/bool_trait_def.hpp"












// 55 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/bool_trait_def.hpp"



// 67 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/bool_trait_def.hpp"






















































































// 194 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/bool_trait_def.hpp"

// 20 "c:/home/cvs_mplbook/boost/boost/mpl/void.hpp" 2


namespace boost {
namespace mpl {

 
 
 
 
struct void_ { typedef void_ type; };

template< typename   T  > struct   is_void_  : mpl::bool_<    false    >  {     };   
template<> struct   is_void_ <   void_  > : mpl::bool_<    true    >  {     }; 

template< typename   T  > struct   is_not_void_  : mpl::bool_<    true    >  {     };   
template<> struct   is_not_void_ <   void_  > : mpl::bool_<    false    >  {     }; 

}}

// 1 "c:/home/cvs_mplbook/boost/boost/type_traits/detail/bool_trait_undef.hpp" 1
 
 
 
 
 
 
 
 
 
 
 
 

 















// 39 "c:/home/cvs_mplbook/boost/boost/mpl/void.hpp" 2



// 24 "c:/home/cvs_mplbook/boost/boost/mpl/lambda_fwd.hpp" 2



namespace boost { namespace mpl {

template< 
      typename T
    , typename Tag = void_
    ,  
          typename Arity = int_< aux::template_arity<T>::value >
          
    >
struct lambda;

}}

// 53 "c:/home/cvs_mplbook/boost/boost/mpl/lambda_fwd.hpp"



// 18 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp" 2


// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na.hpp" 1




 
 
 
 
 
 
 

 
 
 





namespace mpl_ { namespace aux {} 

 
struct na;

template< typename T >
struct is_na
    : false_
{



};

template<>
struct is_na<na>
    : true_
{



};


template< typename T, typename U > struct if_na
{
    typedef T type;
};

template< typename U > struct if_na<na,U>
{
    typedef U type;
};
// 75 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na.hpp"


} namespace boost { namespace mpl { using namespace mpl_; namespace aux { using namespace mpl_::aux; } }} 


// 20 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/arity.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/dtp.hpp" 1




 
 
 
 
 
 
 

 
 
 



 
 
 
 
 











// 44 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/dtp.hpp"



// 17 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/arity.hpp" 2


// 37 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/arity.hpp"



// 21 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp" 2





// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/enum.hpp" 1




 
 
 
 
 
 
 

 
 
 



 
 
 
 



// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp"





// 36 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp"

// 26 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/enum.hpp" 2





    











// 60 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/enum.hpp"



// 26 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 1




 
 
 
 
 
 
 

 
 
 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/limits/arity.hpp" 1




 
 
 
 
 
 
 

 
 
 






// 17 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2




// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/comma_if.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/comma_if.hpp"






// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/punctuation/comma_if.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/punctuation/comma_if.hpp"








// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"



// 58 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"

// 18 "c:/home/cvs_08_may_03/boost/boost/preprocessor/punctuation/comma_if.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/control/if.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/control/if.hpp"








// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"



// 58 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"

// 18 "c:/home/cvs_08_may_03/boost/boost/preprocessor/control/if.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/control/iif.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/control/iif.hpp"






// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"



// 58 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"

// 16 "c:/home/cvs_08_may_03/boost/boost/preprocessor/control/iif.hpp" 2




















// 19 "c:/home/cvs_08_may_03/boost/boost/preprocessor/control/if.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/bool.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/bool.hpp"








// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"



// 58 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"

// 18 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/bool.hpp" 2
















































































































































































































































































// 20 "c:/home/cvs_08_may_03/boost/boost/preprocessor/control/if.hpp" 2












// 19 "c:/home/cvs_08_may_03/boost/boost/preprocessor/punctuation/comma_if.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/facilities/empty.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/facilities/empty.hpp"













// 20 "c:/home/cvs_08_may_03/boost/boost/preprocessor/punctuation/comma_if.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/punctuation/comma.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/punctuation/comma.hpp"













// 21 "c:/home/cvs_08_may_03/boost/boost/preprocessor/punctuation/comma_if.hpp" 2












// 16 "c:/home/cvs_08_may_03/boost/boost/preprocessor/comma_if.hpp" 2



// 21 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/and.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/and.hpp"








// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"



// 58 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"

// 18 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/and.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/bool.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/bool.hpp"





// 289 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/bool.hpp"

// 19 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/and.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/bitand.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/bitand.hpp"






// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"



// 58 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"

// 16 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/bitand.hpp" 2
























// 20 "c:/home/cvs_08_may_03/boost/boost/preprocessor/logical/and.hpp" 2












// 22 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/identity.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/identity.hpp"






// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/facilities/identity.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/facilities/identity.hpp"








// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/facilities/empty.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/facilities/empty.hpp"













// 18 "c:/home/cvs_08_may_03/boost/boost/preprocessor/facilities/identity.hpp" 2







// 16 "c:/home/cvs_08_may_03/boost/boost/preprocessor/identity.hpp" 2



// 23 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/empty.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/empty.hpp"






// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/facilities/empty.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/facilities/empty.hpp"













// 16 "c:/home/cvs_08_may_03/boost/boost/preprocessor/empty.hpp" 2



// 24 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2


 
 
 



// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/filter_params.hpp" 1




 
 
 
 
 
 
 

 
 
 













// 32 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/sub.hpp" 1




 
 
 
 
 
 
 

 
 
 





// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/tuple.hpp" 1




 
 
 
 
 
 
 

 
 
 














// 21 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/sub.hpp" 2


// 33 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/sub.hpp"






















// 63 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/sub.hpp"



// 33 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2































// 89 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessor/def_params_tail.hpp"

















// 27 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp" 2


// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/algorithm_namespace.hpp" 1




 
 
 
 
 
 
 

 
 
 




















// 29 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp" 2


// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/eti.hpp" 1




 
 
 
 
 
 
 

 
 
 




 

















// 31 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp" 2












// 56 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp"





// 74 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp"

// 87 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp"


// 99 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp"






// 123 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp"




// 135 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp"























// 166 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/na_spec.hpp"


// 24 "c:/home/cvs_mplbook/boost/boost/mpl/or.hpp" 2




 
 
 
 









// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/include_preprocessed.hpp" 1

 
 
 
 
 
 
 

 
 
 

 

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/compiler.hpp" 1




 
 
 
 
 
 
 

 
 
 














// 52 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/config/compiler.hpp"



// 16 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/include_preprocessed.hpp" 2


// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp"





// 36 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp"

// 18 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/include_preprocessed.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/stringize.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/stringize.hpp"








// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"



// 58 "c:/home/cvs_08_may_03/boost/boost/preprocessor/config/config.hpp"

// 18 "c:/home/cvs_08_may_03/boost/boost/preprocessor/stringize.hpp" 2














// 19 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/include_preprocessed.hpp" 2












// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessed/gcc/or.hpp" 1
namespace boost { namespace mpl {

namespace aux {
template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct or_impl
    : true_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct or_impl< false,T1,T2,T3,T4 >
    : or_impl<
          :: mpl_ ::aux::nested_type_wknd< T1 > ::value
        , T2, T3, T4
        , false_
        >
{
};

template<>
struct or_impl<
          false
        , false_, false_, false_, false_
        >
    : false_
{
};

}  

template<
      typename  T1  = na 
    , typename  T2  = na 
    , typename T3 = false_, typename T4 = false_, typename T5 = false_
    >
struct or_
    : aux::or_impl<
          :: mpl_ ::aux::nested_type_wknd< T1 > ::value
        , T2, T3, T4, T5
        >
{
     




};

template<> struct     or_
      <   
   na  ,   na      > { template<      typename T1,   typename T2          ,            typename T3        =  na     ,         typename T4        =  na     ,         typename T5        =  na            > struct apply :     or_       <      T1,   T2   > { }; };    template<> struct lambda<     or_       <      na  ,   na      > , na ,  int_<-1>   > { typedef     or_       <      na  ,   na      > type; };    namespace aux { template<   
   typename T1,   typename T2,   typename T3,   typename T4,   typename T5   > struct template_arity<     or_       <      T1,   T2,   T3,   T4,   T5   > > : int_<    5       > { }; template<> struct template_arity<     or_       <      na  ,   na     > > { static const  int    value = -1  ; }; }  

}}  
// 31 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/include_preprocessed.hpp" 2




// 41 "c:/home/cvs_mplbook/boost/boost/mpl/or.hpp" 2

















// 17 "c:/home/cvs_mplbook/boost/boost/mpl/logical.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/and.hpp" 1




 
 
 
 
 
 
 

 
 
 











 
 
 
 









// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/include_preprocessed.hpp" 1

 
 
 
 
 
 
 

 
 
 

 



// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp"





// 36 "c:/home/cvs_08_may_03/boost/boost/preprocessor/cat.hpp"

// 18 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/include_preprocessed.hpp" 2

// 1 "c:/home/cvs_08_may_03/boost/boost/preprocessor/stringize.hpp" 1

// 10 "c:/home/cvs_08_may_03/boost/boost/preprocessor/stringize.hpp"





// 31 "c:/home/cvs_08_may_03/boost/boost/preprocessor/stringize.hpp"

// 19 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/include_preprocessed.hpp" 2












// 1 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/preprocessed/gcc/and.hpp" 1
namespace boost { namespace mpl {

namespace aux {
template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct and_impl
    : false_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct and_impl< true,T1,T2,T3,T4 >
    : and_impl<
          :: mpl_ ::aux::nested_type_wknd< T1 > ::value
        , T2, T3, T4
        , true_
        >
{
};

template<>
struct and_impl<
          true
        , true_, true_, true_, true_
        >
    : true_
{
};

}  

template<
      typename  T1  = na 
    , typename  T2  = na 
    , typename T3 = true_, typename T4 = true_, typename T5 = true_
    >
struct and_
    : aux::and_impl<
          :: mpl_ ::aux::nested_type_wknd< T1 > ::value
        , T2, T3, T4, T5
        >
{
     




};

template<> struct     and_
      <   
   na  ,   na      > { template<      typename T1,   typename T2          ,            typename T3        =  na     ,         typename T4        =  na     ,         typename T5        =  na            > struct apply :     and_       <      T1,   T2   > { }; };    template<> struct lambda<     and_       <      na  ,   na      > , na ,  int_<-1>   > { typedef     and_       <      na  ,   na      > type; };    namespace aux { template<   
   typename T1,   typename T2,   typename T3,   typename T4,   typename T5   > struct template_arity<     and_       <      T1,   T2,   T3,   T4,   T5   > > : int_<    5       > { }; template<> struct template_arity<     and_       <      na  ,   na     > > { static const  int    value = -1  ; }; }  

}}  
// 31 "c:/home/cvs_mplbook/boost/boost/mpl/aux_/include_preprocessed.hpp" 2





// 40 "c:/home/cvs_mplbook/boost/boost/mpl/and.hpp" 2

















// 18 "c:/home/cvs_mplbook/boost/boost/mpl/logical.hpp" 2

// 1 "c:/home/cvs_mplbook/boost/boost/mpl/not.hpp" 1




 
 
 
 
 
 
 

 
 
 






namespace boost {
namespace mpl {

namespace aux {

template< long C_ >  
struct not_impl
    : bool_<!C_>
{
};

}  


template<
      typename  T  = na 
    >
struct not_
    : aux::not_impl<
          :: mpl_ ::aux::nested_type_wknd< T > ::value
        >
{
     
};

template<> struct    not_  <      na      > { template<      typename T1          ,            typename T2        =  na     ,         typename T3        =  na     ,         typename T4        =  na     ,         typename T5        =  na            > struct apply :    not_  <      T1   > { }; };    template<> struct lambda<    not_  <      na      > , na ,  int_<-1>   > { typedef    not_  <      na      > type; };    namespace aux { template<      typename T1   > struct template_arity<    not_  <      T1   > > : int_<   1  > { }; template<> struct template_arity<    not_  <      na     > > { static const  int    value = -1  ; }; }  

}  
}  


// 19 "c:/home/cvs_mplbook/boost/boost/mpl/logical.hpp" 2



// 10 "C:\\home\\cvs_mplbook\\boost\\libs\\mpl\\test\\logical.cpp" 2


// 1 "c:/home/cvs_08_may_03/boost/boost/static_assert.hpp" 1
 
 
 
 

 

 

















namespace boost{

 
template <bool x> struct STATIC_ASSERTION_FAILURE;

template <> struct STATIC_ASSERTION_FAILURE<true> { enum { value = 1 }; };

 
template<int x> struct static_assert_test{};

}

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 



// 90 "c:/home/cvs_08_may_03/boost/boost/static_assert.hpp"

 

















// 12 "C:\\home\\cvs_mplbook\\boost\\libs\\mpl\\test\\logical.cpp" 2


namespace mpl = boost::mpl;

using mpl::true_;
using mpl::false_;

struct unknown;

int main()
{
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::and_< true_,true_ >::value == true)  ) >)>     boost_static_assert_typedef_23        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::and_< false_,true_ >::value == false)  ) >)>     boost_static_assert_typedef_24        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::and_< true_,false_ >::value == false)  ) >)>     boost_static_assert_typedef_25        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::and_< false_,false_ >::value == false)  ) >)>     boost_static_assert_typedef_26        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::and_< false_,unknown >::value == false)  ) >)>     boost_static_assert_typedef_27        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::and_< false_,unknown,unknown >::value == false)  ) >)>     boost_static_assert_typedef_28        ;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::or_< true_,true_ >::value == true)  ) >)>     boost_static_assert_typedef_30        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::or_< false_,true_ >::value == true)  ) >)>     boost_static_assert_typedef_31        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::or_< true_,false_ >::value == true)  ) >)>     boost_static_assert_typedef_32        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::or_< false_,false_ >::value == false)  ) >)>     boost_static_assert_typedef_33        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::or_< true_,unknown >::value == true)  ) >)>     boost_static_assert_typedef_34        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::or_< true_,unknown,unknown >::value == true)  ) >)>     boost_static_assert_typedef_35        ;

    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::not_< true_ >::value == false)  ) >)>     boost_static_assert_typedef_37        ;
    typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (bool)(  (mpl::not_< false_ >::value == true)  ) >)>     boost_static_assert_typedef_38        ;
  
    return 0;
}
