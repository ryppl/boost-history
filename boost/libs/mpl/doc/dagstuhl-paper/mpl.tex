\documentclass{netobjectdays}

\newcommand{\Cpp}{C\kern-0.05em\texttt{+\kern-0.03em+}}
\newcommand{\mpl}{\code{boost::mpl}}

\input{defs}

\begin{document}

\title{The Boost \Cpp\ Template Metaprogramming Library}

\author{Aleksey Gurtovoy$^\dag$ and David Abrahams$^\ddag$ \\
\\
$^\dag$ Meta Communications \\
\texttt{agurtovoy@meta-comm.com}\\
\\
$^\ddag$ Boost Consulting \\
\texttt{david.abrahams@rcn.com}
}

\maketitle

\begin{abstract} $\!$This paper describes the Boost \Cpp template
metaprogramming library (\mpl), an extensible compile-time framework
of algorithms, sequences and function classes. The library brings
together important abstractions from the generic and functional
programming worlds to build a powerful and easy-to-use
metaprogramming toolset which makes template metaprogramming practical
enough for the real-world environments. The MPL is heavily influenced
by its run-time equivalent - the Standard Template Library (STL), a
part of the C++ standard library. Like the STL, it defines an open
conceptual and implementation framework which can serve as a
foundation for future contributions in the domain. The library's
fundamental concepts and idioms enable the user to focus on solutions 
without navigating the universe of possible ad-hoc approaches to a 
given metaprogramming problem, even if no actual MPL code is used. 
{\mpl} also provides a compile-time lambda expression facility enabling
arbitrary currying and composition of class templates, a feature whose
runtime counterpart is often cited as missing from the STL. This paper
explains motivation, usage, design, and implementation of \mpl 
library, gives some advanced examples of its real-life applications, 
and offers some lessons learned about C++ template metaprogramming.
\end{abstract}


\section{Introduction}

\subsection{What is Metaprogramming?}

Metaprogramming is usually defined as the creation of programs which
generate other programs. Parser generators such as YACC are examples
of one kind of program-generating program. The input language to YACC
is a context-free grammar in EBNF, and its output is a program which
parses that grammar. Note that in this case the metaprogram (YACC) is
written in a language (`C') which does not directly support the
description of generated programs. These specifications, which we'll
call \emph{meta-data}, are not written in `C', but in a
\emph{meta-language}. Because the the rest of the user's program
typically requires a general-purpose programming system and must
interact with the generated parser, the meta-data is translated into
`C', which is then compiled and linked together with the rest of the
system. The meta-data thus undergoes two translation steps, and the
user is always very conscious of the boundary between his meta-data
and the rest of his program.
% need bibliography reference for YACC

A more interesting form of metaprogramming is available in languages
such as Scheme, where the generated program specification is given in
the same language as the metaprogram itself. The metaprogrammer
defines his meta-language as a subset of the expressible forms of the
underlying language, and program generation can take place in the same
translation step used to process the rest of the user's program. This
allows users to switch transparently between ordinary programming,
generated program specification, and metaprogramming, often without
being aware of the transition.
% bib reference for Scheme metaprogramming

\subsection{Metaprogramming in \Cpp }

In \Cpp, it was discovered almost by accident that the template
mechanism provides a rich facility for computation at
compile-time. For example, the following tiny meta-function computes the
factorial of its argument:

{\footnotesize
\begin{verbatim}
template <unsigned n>
struct factorial
{
   static const unsigned value = n * factorial<n-1>::value;
};

template <>
struct factorial<0>
{
   static const unsigned value = 1;
};
\end{verbatim}
}

Because of the hard line between the expression of compile-time and
runtime computation in \Cpp, metaprograms look different from their
runtime counterparts. Thus, only a subset of the language is available
to the \Cpp metaprogrammer: those expressions which can be evaluated
at compile-time. Compare the above with a straightforward runtime
definition of the factorial function:

{\footnotesize
\begin{verbatim}
unsigned factorial(unsigned N)
{
   return N == 0 ? 1 : N * factorial(N - 1);
}
\end{verbatim}
}

While it is easy to see the analogy between the two recursive
defintions, recursion is in general more important to \Cpp
metaprograms than it is to runtime \Cpp. In contrast to languages such
as Lisp where recursion is idiomatic, \Cpp programmers will typically
avoid it when possible. This is done not only for efficiency
reasons, but also because of ``cultural momentum'': recursive programs
are just harder (for \Cpp programmers) to think about. Like pure Lisp,
though, the \Cpp template mechanism is a \emph{functional} programming
language: as such it rules out the use of data mutation required to
maintain loop variables.

A key difference between the runtime and compile-time factorial
functions is the expression of the termination condition: our
meta-factorial uses template specialization as a kind of
\emph{pattern-matching} mechanism to describe the behavior when
\code{N} is zero. The syntactic analogue in the runtime world would
require two separate definitions of the same function. In this case
the impact of the second definition is minimal, but in large
metaprograms the cost of maintaining and understanding the terminating
definitions can become significant.

\subsection{Why Metaprogramming?}

It's worth asking why anyone would want to do this. Even a simple toy
example like the factorial metafunction has its uses. It could be
applied, for example, to compute the type of an array which can hold
all permutations of another array:

{\footnotesize
\begin{verbatim}
// Holder for an array of N elements of type T
template <class T, unsigned N>
struct array
{
   T elements[N];
};

// Return an array of the N! permutations of x
template <class T, unsigned N>
array<T[N], factorial<N>::value>
all_permutations(const T (&x)[N])
{
   array<T[N],factorial<N>::value> result;
   std::copy(x, x+N, result.elements[0]);

   for (unsigned i = 1; i < factorial<N>::value; ++i)
   {
       T (*src)[N] = result.elements + i - 1;
       T (*dst)[N] = result.elements + i;
       
       std::copy(&(*src)[0], &(*dst)[0], &(*dst)[0]);
       std::next_permutation(&(*dst)[0], &(*dst)[0] + N);
   }
   return result;
}
\end{verbatim}
}

The runtime definition of \code{factorial} would be useless in
\code{all\_\-permutations} above, since in \Cpp the sizes of array
members must be computed at compile-time. However, there are
alternative approaches:

\begin{enumerate}

\item We could write programs to interpret the meta-data directly. In
  our factorial example, the array size could have been a runtime
  quantity; then we'd have been able to use the straightforward
  factorial function. However, that would imply the use of dynamic
  allocation, which is often expensive.

  To carry this further, YACC might could be rewritten to accept a
  pointer-to-function returning tokens from the stream to be parsed,
  and a string containing the grammar description. This approach,
  however, would impose unacceptable runtime costs for most
  applications: either the parser would have to treat the grammar
  nondeterministically, exploring the grammar for each parse, or it
  would have to begin by replicating at runtime the substantial
  table-generation and optimization work of the existing YACC for each
  input grammar.

\item We could replace the compile-time computation with our own
  analysis. After all, the size of arrays passed to
  \code{all\_\-permutations} are always known at compile-time, and
  thus can be known to its user. We could ask the user to supply the
  result size: {\footnotesize
  \begin{verbatim}
template <unsigned ResultSize, unsigned N, class F>
array<T,ResultSize>
all_permutations(double (&input)[N], F f)
  \end{verbatim}
  }
  The costs to this approach are obvious: we give up expressivity (by
  requiring the user to explicitly specify implementation details),
  and correctness (by allowing the user to specify them
  incorrectly). Anyone who has had to write parser tables by hand will
  tell you that the impracticality of this approach is the very reason
  YACC's existence.
\end{enumerate}

So, the motivation for Metaprogramming comes down to the combination
of three factors: efficiency, expressivity, and correctness.

\subsection{Why a Metaprogramming Library?}


\subsection{What about portability? }
\subsection{Relation to other work.}

\section{Basic usage}
\subsection{Sequences, algorithms, and iterators}
\subsection{Function classes, simple composition}
\subsection{Lambda facility}

\section{Design of boost::mpl}
\subsection{Design goals}
\subsection{Design decisions}
\subsubsection{Use of iterators}
\subsubsection{Abstraction of sequences}

\section{Advanced examples (What can I do with boost::mpl?)}
\subsection{Using \mpl\ to implement compile-time FSM generator}

\section{About implementation}

\section{Lessons learned}

\section{Conclusions}
\section{Acknowledgements}
\section{References}

\bibliographystyle{abbrv} \bibliography{refs}

\end{document}
% LocalWords:  Aleksey David Gurtovoy Abrahams MPL STL Boost boost
