[/
 / Copyright (c) 2006 Eric Niebler
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section Pattern Matching and Meta-Grammars]

Expression trees can have a very rich and complicated structure. Often, you
need to know some things about an expression's structure before you can process
it. Imagine your DSEL is a miniature I/O facility, with iostream operations 
that execute lazily. You might want expressions representing input operations
to be processed by one function, and output operations to be processed by a 
different function. How would you do that?

[h3 Expression Patterns]

The answer is to write patterns that match the structure of input and output
expressions. Proto provides utilities for defining the patterns, and the 
_matches_ template for checking whether a given expression type matches the 
pattern.

First, let's define some terminals we can use in our lazy I/O expressions:

    terminal< std::istream & >::type cin_ = { std::cin };
    terminal< std::ostream & >::type cout_ = { std::cout };

Now, we can use `cout_` instead of `std::cout`, and get I/O expression trees
that we can execute later. To define patterns that match intput and output 
expressions of the form `cin_ >> i` and `cout_ << 1` we do this:

    struct Input
      : right_shift< terminal< std::istream & >, _ >
    {};

    struct Output
      : left_shift< terminal< std::ostream & >, _ >
    {};

We've seen the template `terminal<>` before, but here we're using it 
without accessing the nested `::type`. When used like this, it is a very simple
pattern, as are `right_shift<>` and `left_shift<>`. The newcomer 
here is `_` in the `proto` namespace. It is a wildcard that matches anything.
The `Input` struct is a pattern that matches any right-shift expression that
has a `std::istream` terminal as its left operand.

We can use these patterns together with the _matches_ template to query at
compile time whether a given I/O expression type is an input or output 
operation. Consider the following:

    template< typename Expr >
    void input_output( Expr const & expr )
    {
        if( matches< Expr, Input >::value )
        {
            std::cout << "Input!\n";
        }

        if( matches< Expr, Output >::value )
        {
            std::cout << "Output!\n";
        }
    }

    int main()
    {
        int i = 0;
        input_output( cout_ << 1 );
        input_output( cin_ >> i );
        
        return 0;
    }

This program prints the following:

[pre
Output!
Input!
]

If we wanted to break the `input_output()` function into two functions, one
that handles input expressions and one for output expressions, we can use 
`boost::enable_if<>`, as follows:

    template< typename Expr >
    typename enable_if< matches< Expr, Input > >::type
    input_output( Expr const & expr )
    {
        std::cout << "Input!\n";
    }

    template< typename Expr >
    typename enable_if< matches< Expr, Output > >::type
    input_output( Expr const & expr )
    {
        std::cout << "Output!\n";
    }

This works as the previous version did. However, the following does not compile
at all:

    input_output( cout_ << 1 << 2 ); // oops!

What's wrong? The problem is that this expression does not match our pattern. 
The expression groups as if it were written like `(cout_ << 1) << 2`. It will 
not match the `Output` pattern, which expects the left operand to be a 
terminal, not another left-shift operation. We need to fix the pattern.

We notice that in order to verify an expression as input or output, we'll need
to recurse down to the bottom-left-most leaf and check that it is a 
`std::istream` or `std::ostream`. When we get to the terminal, we must stop 
recursing. We can express this in our pattern using _or_. Here are the correct 
`Input` and `Output` patterns:

    struct Input
      : or_<
            right_shift< terminal< std::istream & >, _ >
          , right_shift< Input, _ >
        >
    {};

    struct Output
      : or_<
            left_shift< terminal< std::ostream & >, _ >
          , left_shift< Output, _ >
        >
    {};

This may look a little odd at first. We seem to be defining the `Input` and
`Output` types in terms of themselves. This is perfectly OK, actually. At
the point in the pattern that the `Input` and `Output` types are being used,
they are /incomplete/, but by the time we actually evaluate the pattern with
_matches_, the types will be complete. These are recursive patterns, and 
rightly so because they must match a recursive data structure!

When the `Output` pattern is evaluated against an expression like 
`cout_ << 1 << 2`, the first alternate of the _or_ is tried first. It will 
fail, because the expression `cout_ << 1 << 2` does not match the pattern
`left_shift< terminal< std::ostream & >, _ >`. Then the second 
alternate is tried. We match the expression against 
`left_shift< Output, _ >`. The expression is a left-shift, so we try 
the operands. The right operand `2` matches `_` trivially. To see if 
the left operand `cout_ << 1` matches `Output`, we must recursively evaluate 
the `Output` pattern. This time we succeed, because `cout_ << 1` will match 
the first alternate of the _or_. We're done -- the pattern matches 
successfully.

[h3 Fuzzy and Exact Matches of Terminals]

By default the terminals in an expression tree are stored by reference.
They could be const or non-const references, or they might not be references
at all. When writing patterns, you usually don't have to worry about it because
_matches_ gives you wiggle room when matching terminals. Two terminal types
are considered a match if there is a /built-in/ conversion from the actual type
to the type in the pattern. (User-defined conversions are not considered.) The
following are considered built-in conversions that you can rely on when writing
Proto patterns:

* Const and volatile conversions
* Array-to-pointer conversions
* Integer and floating-point conversions
* Base-to-derived conversions
* Function-to-function-pointer conversions

For instance, consider the following program fragment:

    struct CharString
      : terminal< char const * >
    {};
    
    typedef terminal< char const (&)[6] >::type char_array;

    BOOST_MPL_ASSERT(( matches< char_array, CharString > ));

The type `char_array` might be the type of a string literal such as `"hello"`.
Even though it is an array type, it successfully matches the pattern 
`terminal< char const * >` because C++ has a built-in conversion from array
types to pointers.

What if we really only wanted `CharString` to match terminals of exactly the 
type `char const *`? Proto provides the template _exact_ for turning off the 
fuzzy matching of terminals. You could use it as follows:

    struct CharString
      : terminal< exact< char const * > >
    {};
    
    typedef terminal<char const (&)[6]>::type char_array;
    typedef terminal<char const *>::type      char_string;

    BOOST_MPL_ASSERT(( matches< char_string, CharString > ));
    BOOST_MPL_ASSERT_NOT(( matches< char_array, CharString > ));

Now, `CharString` does not match array types, only character string pointers.

There is one more way you can perform a fuzzy match on terminals. Consider the
problem of trying to match a `std::complex<>` terminal. You can easily match
a `std::complex<float>` or a `std::complex<double>`, but how would you match
any instantiation of `std::complex<>`? You can use `proto::_` here to solve 
this problem. Here is the pattern to match any `std::complex<>` instantiation:

    struct StdComplex
      : terminal< std::complex< _ > >
    {};

When given a pattern like this, Proto will deconstruct the pattern and the 
expression it is being matched against and see if it can match all the 
constituents. 

[h3 Other Valid Patterns]

We've already seen how to use expression generators like `terminal<>` and
`right_shift<>` as patterns. We've also seen _or_, which we can use to 
express a set of alternate patterns. There are a few others of interest; in 
particular, _if_ and _and_.

The _if_ template is used together with an MPL lambda expression, which is 
evaluated against expression types to find matches. The _and_ template is like
_or_, except that each alternate must match in order for the _and_ to match.
As an example, consider the definition of `CharString` above that uses _exact_.
It could have been written without _exact_ as follows:

    struct CharString
      : and_<
            terminal< _ >
          , if_< is_same< result_of::arg< mpl::_ >, char const * > >
        >
    {};

This says that a `CharString` must be a terminal, *and* its argument must be
the same as `char const *`. Notice the template argument of _if_: 
`is_same< result_of::arg< mpl::_ >, char const * >`. This is an MPL lambda 
expression because it has the MPL placeholder `mpl::_` in it. 

[warning Do not confuse `mpl::_` with `proto::_`. The first is only useful in
MPL lambda expressions. The second is Proto's pattern wildcard. The only place
`mpl::_` should appear in your patterns is in an _if_. Elsewhere in your 
patterns you should be using `proto::_`.]

[h3 Matching Vararg Functions]

Not all of C++'s overloadable operators are unary or binary. There is the 
oddball `operator()` -- the function call operator -- which can have any number
of argumentrs. Likewise, with Proto you may define your own "operators" that 
could also take more that two arguments. As a result, there may be nodes in 
your Proto expression tree that have an arbitrary number of children (up to 
some predefined maximum). How do you write a pattern to match such a node?

For such cases, Proto provides the _vararg_ class template. Its template
argument is a pattern, and the _vararg_ will match the pattern zero or more
times. Consider a Proto lazy function called `fun()` that can take zero or
more characters as arguments, as follows:

    struct fun_tag {};
    struct FunTag : terminal< fun_tag > {};
    FunTag::type const fun = {{}};
    
    // example usage:
    fun();
    fun('a');
    fun('a', 'b');
    ...

Below is the pattern that matches all the allowable invocations of `fun()`:

    struct FunCall
      : function< FunTag, vararg< terminal< char > > >
    {};

The `FunCall` pattern uses _vararg_ to match zero or more character literals
as arguments of the `fun()` function.

As another example, can you guess what the following pattern matches?

    struct Foo
      : or_<
            terminal< _ >
          , nary_expr< _, vararg< Foo > >
        >
    {};

Here's a hint: the first template parameter to `nary_expr<>` represents the 
node type, and any additional template parameters represent children nodes. The
answer is that this is a degenerate pattern that matches every possible 
expression tree, from root to leaves.

[h3 Meta-Grammars]

We've already seen how to use small patterns to answer simple questions about 
expression trees. Here's a harder question: Does this expression conform to the
grammar of my domain-specific embedded language? In this section we'll see how
to use Proto to define a grammar for your DSEL and use it to validate 
expression templates, giving short, readable compile-time errors for invalid
expressions.

[tip You might be thinking that this is a backwards way of doing things.
["If Proto let me select which operators to overload, my users wouldn't be able 
to create invalid expressions in the first place, and I wouldn't need a grammar
at all!] That /may/ be true, but there are reasons for preferring to do things
this way. First, it lets you develop your DSEL rapidly -- all the operators are
there for you already! -- and worry about invalid syntax later. Second, it 
might be the case that some operators are only allowed in certain contexts 
within your DSEL. This is easy to express with a grammar, and hard to do with 
straight operator overloading. Third, using a DSEL grammar to flag invalid 
expressions can often yield better errors than manually selecting the 
overloaded operators. Fourth, the grammar can be used for more than just 
validation. As we'll see later, you can use your grammar to define ['tree 
transformations] that convert expression templates into other more useful 
objects.\n
\n
If none of the above convinces you, you actually /can/ use Proto to control
which operators are overloaded within your domain. We'll see how later.
]

In a previous section, we used Proto to define a DSEL for a lazily evaluated
calculator that allowed any combination of placeholders, floating-point 
literals, addition, subtraction, multiplaction, division and grouping. If
we were to write the grammar for this DSEL in  
[@http://en.wikipedia.org/wiki/Extended_Backus_Naur_Form EBNF], it might look
like this:

[pre
group       ::= '(' expression ')'
factor      ::= double | placeholder1 | placeholder2 | group
term        ::= factor (('*' factor) | ('/' factor))*
expression  ::= term (('+' term) | ('-' term))*
]

This captures the syntax, associativity and precedence rules of a calculator.
Writing the grammar for our calculator DSEL using Proto is /even simpler/. 
Since we are using C++ as the host language, we are bound to the associativity 
and precedence rules for the C++ operators. Our grammar can assume them. Also, 
in C++ grouping is already handled for us with the use of parenthesis, so we 
don't have to code that into our grammar.

Let's begin our grammar for forward-declaring it:

    struct CalculatorGrammar;
    
It's an incomplete type at this point, but we'll still be able to use it to 
define the rules of our grammar. Let's define patterns for the terminals:

    struct Double
      : terminal< double >
    {};

    struct Placeholder1
      : terminal< placeholder1 >
    {};

    struct Placeholder2
      : terminal< placeholder2 >
    {};
    
    struct Terminal
      : or_< Double, Placeholder1, Placeholder2 >
    {};

Now let's define the rules for addition, subtraction, multiplication and 
division. Here, we can ignore issues of associativity and precedence -- the C++
compiler will enforce that for us. We only must enforce that the arguments to
the operators must themselves conform to the `CalculatorGrammar` that we 
forward-declared above.

    struct Add
      : add< CalculatorGrammar, CalculatorGrammar >
    {};

    struct Subtract
      : subtract< CalculatorGrammar, CalculatorGrammar >
    {};

    struct Multiply
      : multiply< CalculatorGrammar, CalculatorGrammar >
    {};

    struct Divide
      : divide< CalculatorGrammar, CalculatorGrammar >
    {};

Now that we've defined all the parts of the grammar, we can define 
`CalculatorGrammar`:

    struct CalculatorGrammar
      : or_<
            Terminal
          , Add
          , Subtract
          , Multiply
          , Divide
        >
    {};

That's it! Now we can use `CalculatorGrammar` to enforce that an expression
template conforms to our grammar. We can use _matches_ and `BOOST_MPL_ASSERT()`
to issue readable compile-time errors for invalid expressions, as below:

    template< typename Expr >
    void evaluate( Expr const & expr )
    {
        BOOST_MPL_ASSERT(( matches< Expr, CalculatorGrammar > ));
        // ...
    }

[endsect]
