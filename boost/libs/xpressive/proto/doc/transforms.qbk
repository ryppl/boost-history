[/
 / Copyright (c) 2006 Eric Niebler
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[/===========================]
[section Tree Transformations]
[/===========================]

Sometimes, rather than immediately executing an expression template, you'd
like to transform it into some other object. Maybe the transformation is simple,
like converting all references into values. Maybe it's complicated, like
transforming an expression template into a finite-state automata for matching a
regular expression. Proto provides a framework for applying tree
transformations and several canned transformations that are generally useful.

[/=========================]
[h3 Transformation Overview]
[/=========================]

Defining tree transformations involves defining the meta-grammar for your DSEL
and decorating it with transformations. Each rule in your meta-grammar will
have an associated transform describing how sub-expressions matching that rule
are to be transformed. Just as the meta-grammar is defined recursively, so too
is the tree transformation.

A meta-grammar decorated with transforms has a static member function named
`call()` which takes three parameters:

* `expr`    -- the expression to transform
* `state`   -- the state of the transformation so far
* `visitor` -- any optional auxiliary mutable state information

It also has a nested `apply<>` template which is used to calculate the return
type of the `call()` member function.

Let's say we have a meta-grammar called `Grammar`, an expression template
object called `expr` that matches the meta-grammar, and `state` and `visitor`
objects of your choosing. What happens when you call
`Grammar::call(expr, state, visitor)`? Well, if `Grammar` were defined as
`shift_right< Rule1, Rule2 >`, for instance, it might transform the left
child of `expr` according to `Rule1`'s transform, do the same thing to the
right child using `Rule2`, and combine the results somehow. Of course, `Rule1`
and `Rule2` might be defined in terms of other rules with other transforms, so
the process executes recursively. Some transforms, the binary `fold<>` in
particular, use the result of transforming one child as the `state` parameter
when transforming the other child. In this way, the results of the recursive
transformations can be accumulated bottom-up.

That's it, in a nutshell. Now let's crack this nut and peek inside.

[/====================]
[h3 Defining a Grammar]
[/====================]

Let's have another look at our trusty calculator example. If you recall, the
calculator allows the lazy evaluation of arithmetic expressions, with
placeholders substituted with actual values provided at evaluation time. Valid
expressions are of the form:

    (_1 + 3)
    (_2 - _1) / _2 * 100

... and so on. In the first expression, one argument must be provided before
the expression can be evaluated. In the second, two arguments are needed. We
could say the /arity/ of the first expression is one and of the second is two.
The arity is determined by the highest placeholder in the expression. Our job
will be to write a transform that calculates the arity of any calculator
expression.

First, we must write the grammar for the calculator. It's really very simple.
Calculator expression can be made up of any combination of 5 constituents:

* Placeholder 1
* Placeholder 2
* A literal
* Unary operations
* Binary operations

We can immediately write the calculator grammar as follows:

    using namespace proto;

    struct CalculatorGrammar
      : or_<
            terminal< placeholder1 >
          , terminal< placeholder2 >
          , terminal< _ >
          , unary_expr< _, CalculatorGrammar >
          , binary_expr< _, CalculatorGrammar, CalculatorGrammar >
        >
    {};

We can read this as follows: a calculator expression is either placeholder 1,
placeholder 2, some other terminal, or some unary or binary operator whose
operands are calculator expressions. Recall that `proto::_` is a wildcard which
matches anything. So `terminal< _ >` will match any terminal, and
`unary_expr< _, CalculatorGrammar >` will match any unary expression
for which the operand matches CalculatorGrammar (the `_` matches any operator
tag).

[/=======================]
[h3 Writing the Transform]
[/=======================]

It's straightforward to describe in words how the arity of an expression should
be calculated. First, we describe the arity of each of the 5 constituents in
the calculator grammar.

[table Calculator Sub-Expression Arities
    [[Sub-Expression]       [Arity]]
    [[Placeholder 1]        [`1`]]
    [[Placeholder 2]        [`2`]]
    [[Literal]              [`0`]]
    [[Unary Expression]     [ /arity of the operand/ ]]
    [[Binary Expression]    [ /max arity of the two operands/ ]]
]

The total arity of a calculator expression is found by recursively evaluating
the arity of all of the sub-expressions and taking the maximum.

Let's look at the sub-expression for placeholder 1. It is matched by this part
of our grammar: `terminal< placeholder1 >`. We want to associate this
part of our grammar with an arity of `1`. We do that by attaching a transform.
Since the arity of an expression can be evaluated at compile time, let's use
`mpl::int_<1>` to represent the arity of the first placeholder. The following
attaches a transform that always evaluates to `mpl::int_<1>`:

    trans::always< terminal< placeholder1 >, mpl::int_<1> >

This grammar rule will match any `placeholder1` terminal, and will transform it
to `mpl::int_<1>`. Likewise, we will use the `trans::always<>` transform to
transform `placeholder2` terminals into `mpl::int_<2>`, and other terminals
into `mpl::int_<0>`.

Next, let's write a transform for unary operators that returns the arity of the
operand. It is simply:

    trans::arg< unary_expr< _, CalculatorGrammar > >

As you might expect, the `trans::arg<>` transform returns the argument of the
unary expression. This looks simple, but there is quite a lot going on here.

First, you should know that transforms are written so that they can be chained.
So `trans::arg<>` invokes the transform associated with
`unary_expr< _, CalculatorGrammar >` before it does anything else.

That begs the question, what does `unary_expr<>`'s transform do? Well,
`unary_expr< _, CalculatorGrammar >` has a default transform
associated with it. It is a /pass-through/ transform. When an expression
of the form `expr< T, arg1< X > >` is passed to the transform, it's `apply<>`
member template will invoke the `CalculatorGrammar` transform (which we haven't
completely defined yet -- patience) on `X` resulting in `Y`, and then
reassemble the expression as `expr< T, arg1< Y > >`.

[note You may have noticed that Proto types like `unary_expr<>` serve several
different but related roles. In particular, `unary_expr<>` is ...

... [*a meta-function]: `unary_expr<T, X>::type` is a typedef for
`expr<T, args1<X> >`.

... [*a grammar]: `unary_expr<U, Y>` is a pattern that matches 
`expr<T, args1<X> >` if an only if `U` is `T` or `proto::_`, and `Y` is a
pattern that matches `X`.

... [*a transform]: `unary_expr<U, Y>::apply<expr<T, args1<X> >, S, V>::type`
applies `unary_expr<>`'s pass-through transform to `expr<T, args1<X> >` with
state `S` and visitor `V`. The result is 
`expr<T, args1< Y::apply<X, S, V>::type > >`.
]

So, putting a few things together, consider the calculator expression `+_1`,
which would have the following type:

    expr< tag::posit, arg1<
        expr< tag::terminal, arg1< placeholder1 > >
    > >

If we executed the `unary_expr< _, CalculatorGrammar >` transform on this
expression, we would expect to get:

    expr< tag::posit, arg1<
        mpl::int_<1>
    > >

And if we added the `trans::arg<>` transform also, as in
`trans::arg< unary_expr< _, CalculatorGrammar > >`, we expect the result
to be:

    mpl::int_<1>

Which is exactly what we want.

[note *Default Transforms*

All the tools Proto provides for defining grammar rules have default transforms
associated with them. Just as `unary_expr<>` has a pass-through transform,
so too does `binary_expr<>`, `shift_right<>`, and all the others.
`proto::or_<>` has a default transform which evaluates the transform of the
branch that matched. `proto::and_<>`'s default transform evaluates the
transform of the last branch. Even `proto::expr<>`, `proto::if_<>`
`proto::not_<>` and `proto::_` have no-op default transforms that simply return
unmodified the expressions passed to them.
]

The arity of a binary operator is the maximum of the arity of the left and
right operands. Proto does not provide a transform that can help us directly,
but we can easily write our own. This is what it looks like, and we'll describe
it below:

    template<typename Grammar>
    struct binary_max
      : Grammar
    {
        template<typename Expr, typename State, typename Visitor>
        struct apply
        {
            typedef typename mpl::apply_wrap3<Grammar, Expr, State, Visitor>::type expr_type;
            typedef typename result_of::left<expr_type>::type left_arity;
            typedef typename result_of::right<expr_type>::type right_arity;
            typedef typename mpl::max<left_arity, right_arity>::type type;
        };

        template<typename Expr, typename State, typename Visitor>
        static typename apply<Expr, State, Visitor>::type
        call(Expr const &, State const &, Visitor &)
        {
            return typename apply<Expr, State, Visitor>::type();
        }
    };

This transform will be used as follows:
`binary_max< binary_expr< _, CalculatorGrammar, CalculatorGrammar > >`.
First, note that the transform is a template that takes a Grammar as a template
parameter. It inherits from the Grammar, as all transforms must. Next, we
define a nested `apply<>` template which calculates the return type. The first
thing it does is invoke `Grammar`'s transform. Recall that `binary_expr<>`
has a pass-through transform. Given an expression like
`expr< T, arg2< A, B > >`, it transforms it to `expr< T, arg2< X, Y > >`, where
`X` and `Y` are the results of transforming `A` and `B` according to
`CalculatorGrammar`.

Next, we extract from this transformed binary expression the left and right
argument types. As the arguments were transformed in the previous step, we
expect them to already be of the form `mpl::int_<N>`. Then we use `mpl::max<>`
to find the maximum, and we're done.

The static `call()` member function is needed to complete the transform
interface. It simply returns a default-constructed object, which will be an
instantiation of `mpl::int_<>`.

Piecing it all together, the complete `CalculatorGrammar` looks like this:

    struct CalculatorGrammar
      : or_<
            trans::always< terminal< placeholder1 >, mpl::int_<1> >
          , trans::always< terminal< placeholder2 >, mpl::int_<2> >
          , trans::always< terminal< _ >, mpl::int_<0> >
          , trans::arg< unary_expr< _, CalculatorGrammar > >
          , binary_max< binary_expr< _, CalculatorGrammar, CalculatorGrammar > >
        >
    {};

We can use our CalculatorGrammar transform to calculate the arity of any
calculator expression:

    int i = 0; // not used, dummy state and visitor parameter

    std::cout << CalculatorGrammar::call( lit(100) * 200, i, i) << '\n';
    std::cout << CalculatorGrammar::call( (_1 - _1) / _1 * 100, i, i) << '\n';
    std::cout << CalculatorGrammar::call( (_2 - _1) / _2 * 100, i, i) << '\n';

This displays the following:

[pre
0
1
2
]

(Aside: this uses the fact that `mpl::int_<1>` has a conversion to `int(1)`.)

[/===================]
[h3 Canned Transforms]
[/===================]

Some transforms are generally useful, so Proto provides them. They are
described below. Each is of the form:

    boost::proto::transform::``[~transform-name]``< Grammar ``[~\[, additional args ...\]]`` >

They each inherit from their `Grammar` parameter; therefore, they themselves
match the same expressions as `Grammar` does. As transforms, they all have
nested static `call()` member functions that accept `expr`, `state`, and
`visitor` parameters, as well as `apply<>` member templates for calculating
the return type of `call()`. The tables below show what `call()` and `apply<>`
do for each of the transforms that Proto provides.

[h4 [^arg<>] and [^arc_c<>]]

These transforms are useful for extracting the ['[^N]]th argument from an
expression.

    namespace boost { namespace proto { namespace transform
    {
        template<typename Grammar, typename N = mpl::long_<0> >
        struct arg;

        template<typename Grammar, long N>
        struct arg_c;
    }}}

[table
    [   [Expression]
        [Returns]
    ]
    [   [`transform::arg<Grammar, N>::apply<Expr, State, Visitor>::type`]
        [`proto::result_of::arg<typename Grammar::apply<Expr, State, Visitor>::type, N>::type`]
    ]
    [   [`transform::arg<Grammar, N>::call(expr, state, visitor)`]
        [`proto::arg<N>(Grammar::call(expr, state, visitor))`]
    ]
    [   [`transform::arg_c<Grammar, N>::apply<Expr, State, Visitor>::type`]
        [`proto::result_of::arg_c<typename Grammar::apply<Expr, State, Visitor>::type, N>::type`]
    ]
    [   [`transform::arg_c<Grammar, N>::call(expr, state, visitor)`]
        [`proto::arg_c<N>(Grammar::call(expr, state, visitor))`]
    ]
]

Example:

    // Matches an integer terminal and extracts the int.
    struct Int
      : transform::arg< terminal<int> >
    {};

[h4 [^left<>] and [^right<>]]

Other ways to extract children from an expression. The `left<Grammar>`
transform is equivalent to the `arg_c<Grammar, 0>` transform, and the
`right<Grammar>` transform is equivalent to the `arg_c<Grammar, 1>`
transform.

    namespace boost { namespace proto { namespace transform
    {
        template<typename Grammar>
        struct left;

        template<typename Grammar>
        struct right;
    }}}

[table
    [   [Expression]
        [Returns]
    ]
    [   [`transform::left<Grammar>::apply<Expr, State, Visitor>::type`]
        [`proto::result_of::left<typename Grammar::apply<Expr, State, Visitor>::type>::type`]
    ]
    [   [`transform::left<Grammar>::call(expr, state, visitor)`]
        [`proto::left(Grammar::call(expr, state, visitor))`]
    ]
    [   [`transform::right<Grammar>::apply<Expr, State, Visitor>::type`]
        [`proto::result_of::right<typename Grammar::apply<Expr, State, Visitor>::type>::type`]
    ]
    [   [`transform::right<Grammar>::call(expr, state, visitor)`]
        [`proto::right(Grammar::call(expr, state, visitor))`]
    ]
]

Example:

    // Matches an assignment, returns the right hand side.
    struct Assign
      : transform::right< assign<_, _> >
    {};

[h4 [^identity<>], [^state<>] and [^visitor<>]]

The `identity<>`, `state<>` and `visitor<>` transforms merely return the
`expr`, `state` and `visitor` arguments, respectively.

    namespace boost { namespace proto { namespace transform
    {
        template<typename Grammar>
        struct identity;

        template<typename Grammar>
        struct state;

        template<typename Grammar>
        struct visitor;
    }}}

[table
    [   [Expression]
        [Returns]
    ]
    [   [`transform::identity<Grammar>::apply<Expr, State, Visitor>::type`]
        [`Expr`]
    ]
    [   [`transform::identity<Grammar>::call(expr, state, visitor)`]
        [`expr`]
    ]
    [   [`transform::state<Grammar>::apply<Expr, State, Visitor>::type`]
        [`State`]
    ]
    [   [`transform::state<Grammar>::call(expr, state, visitor)`]
        [`state`]
    ]
    [   [`transform::visitor<Grammar>::apply<Expr, State, Visitor>::type`]
        [`Visitor`]
    ]
    [   [`transform::visitor<Grammar>::call(expr, state, visitor)`]
        [`visitor`]
    ]
]

Example:

    // Matches an subscript where the left- and right-hand operands match
    // MyGrammar, returns the expression unmodified; that is, without applying
    // the MyGrammar transform to the left and right operands, as would happen
    // by default.
    struct Subscript
      : transform::identity< subscript<MyGrammar, MyGrammar> >
    {};

[h4 [^always<>]]

The `always<>` transform always returns a certain type. By default, its
`call()` member returns a default constructed object of that type, but you can
configure this with the optional `Factory` parameter.

    template<typename Grammar, typename Always, typename Factory = ``[~default-factory]``>
    struct always;

[table
    [   [Expression]
        [Returns]
    ]
    [   [`transform::always<Grammar, Type, Factory>::apply<Expr, State, Visitor>::type`]
        [`Type`]
    ]
    [   [`transform::always<Grammar, Type, Factory>::call(expr, state, visitor)`]
        [`Factory()()`]
    ]
]

Example:

    // Match a placeholder terminal and return the arity of the
    // placeholder.
    struct PlaceholderArity
      : transform::always< terminal<placeholder1>, mpl::int_<1> >
    {};

[h4 [^apply1<>], [^apply2<>] and [^apply3<>]]

The `apply1<>` transform invokes an MPL lambda expression with the Proto
expression as the argument, `apply2<>` uses the expression and the state
as arguments and `apply3<>` uses the expression, state and visitor.

    template<typename Grammar, typename Lambda, typename Factory = ``[~default-factory]``>
    struct apply1;

    template<typename Grammar, typename Lambda, typename Factory = ``[~default-factory]``>
    struct apply2;

    template<typename Grammar, typename Lambda, typename Factory = ``[~default-factory]``>
    struct apply3;

[table
    [   [Expression]
        [Returns]
    ]
    [   [`transform::apply1<Grammar, Lambda, Factory>::apply<Expr, State, Visitor>::type`]
        [`mpl::apply1<Lambda, typename Grammar::apply<Expr, State, Visitor>::type>::type`]
    ]
    [   [`transform::apply1<Grammar, Lambda, Factory>::call(expr, state, visitor)`]
        [`Factory()(Grammar::call(expr, state, visitor))`]
    ]
    [   [`transform::apply2<Grammar, Lambda, Factory>::apply<Expr, State, Visitor>::type`]
        [`mpl::apply2<Lambda, typename Grammar::apply<Expr, State, Visitor>::type, State>::type`]
    ]
    [   [`transform::apply2<Grammar, Lambda, Factory>::call(expr, state, visitor)`]
        [`Factory()(Grammar::call(expr, state, visitor), state)`]
    ]
    [   [`transform::apply3<Grammar, Lambda, Factory>::apply<Expr, State, Visitor>::type`]
        [`mpl::apply3<Lambda, typename Grammar::apply<Expr, State, Visitor>::type, State, Visitor>::type`]
    ]
    [   [`transform::apply3<Grammar, Lambda, Factory>::call(expr, state, visitor)`]
        [`Factory()(Grammar::call(expr, state, visitor), state, visitor)`]
    ]
]

The `call()` member functions of Proto's `applyN<>` transforms simply return a
default constructed object of the appropriate type by default. If you want a
different behavior, you can specify a `Factory` type as the third template
parameter.

Example:

    // Another way to implement a transform that calculates the arity of a
    // binary Calculator expression. This code is functionally equivalent to
    // the binary_max<> transform defined above. The mpl::max<...> type below
    // is an MPL Placeholder expression (note the use of mpl::_) that
    // mpl::apply1<> knows how to evaluate. The effect of the
    // BinaryCalculatorArity grammar is to match binary Calculator expressions,
    // evaluate the arity of the left and right sub-expressions and return the
    // maximum of the two.
    struct BinaryCalculatorArity
      : transform::apply1<
            binary_expr<_, CalculatorArity, CalculatorArity>
          , mpl::max<result_of::left<mpl::_>, result_of::right<mpl::_> >
        >
    {};

[endsect]
