<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title> Standard Container Algortihms </title><meta http-equiv="Content-Type"content="text/html; charset=iso-8859-1"></head> <body><table  ><tr  ><td  ><img src="cboost.gif" width="100%" border="0"></td><td  ><h1  >Standard Container Algorithms</h1></td></tr></table><ul  ><li  ><a href="#Introduction" >Introduction</a></li><li  ><a href="#Reference" >Reference</a></li><li  ><a href="#Portability" >Portability</a></li><li  ><a href="#References" >References</a></li></ul><hr size="1" ><h2  >Introduction</h2><a name="Introduction" ></a><p  >This library makes it possible to use all the standard 
                      algorithms with many different coontainers instead of a pair of iterators.
                      The magic that makes this possible are overloaded versions of the 
                     free-standing functions <code  >begin()</code> and <code  >end()</code> and the accompanying traits class  <a href="../../container_traits/doc/container_traits.html" target="_self" ><code  >container_traits&lt;&gt;</code></a> .</p><p  >The container algorithms has several advantages over
                     the normal algorithms:<ul  ><li  >Shorter and more comprehensible code</li><li  >Functional style programming is now possible</li><li  >Less error prone when using built-in arrays</li><li  >Container specialized algorithms are 
                                 called whenever possible</li></ul></p><p  >Below are given some small examples:<pre  >
       //
       // Example 1: basic iteration
       //
       
       std::vector&lt;int&gt; my_vector;
       int              my_array[size];
       std::pair&lt;iterator,iterator&gt; my_range;
       // ...
       
       // for_each( begin( my_vector ), end( my_vector ), print() );
       for_each( my_vector, print() );
       
       // for_each( begin( my_array ), end( my_array ), print() );
       for_each( my_array, print() );
       
       // for_each( begin( my_range ), end( my_range ), print() );
       for_each( my_range, print() );
       
       //
       // Example 2: functional style programming
       //            (courtesy of Aleksey Gurtovoy)
       //
       
       // std::pair&lt;record_iterator,record_iterator&gt; sel = selection();
       // std::pair&lt;record_iterator,record_iterator&gt; mismatching_part =
       // std::mismatch( sel.first, sel.second, old_selection.begin() );
       // std::vector&lt;record&gt; v( mismatching_part.first, mismatching_part.second );
       std::vector&lt;record&gt; v( mismatch( selection(), begin( old_selection ) ):

       //                                                                                       
       // Example 3: specialized algorithm called for std::map
       //
       
       std::map&lt;int,int&gt; my_map;
       std::vector&lt;int&gt;  my_vector;
       // ...
       
       // my_map.find( 4 );
       find( my_map, 4 );
       // find( begin( my_vector ), end( my_vector ), 4 );
       find( my_vector, 4 );
                          
                       </pre></p><hr size="1" ><h2  >Reference</h2><a name="Reference" ></a><p  >The library is split up into several headers because
                              calling specialized algorithm for eg. <code  >std::map::find()</code> and because it minimizes the
                              inclusion of other necessary headers. In total there are 
                              5 headers: </p><ul  ><li  > <a href="container_algo.hpp" target="_self" >container_algo.hpp</a> : everything. </li><li  > <a href="container_algo/non_modifying.hpp" target="_self" >container_algo/non_modifying.hpp</a> : non-modifying algorithms; includes <code  >&lt;set&gt;</code> and <code  >&lt;map&gt;</code>.</li></ul><pre  >
namespace boost 
{

/////////////////////////////////////////////////////////////////////////
// Nonmodifying Sequence Operations
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container, typename UnaryOperation &gt;
inline UnaryOperation 
for_each( Container& c, UnaryOperation fun );

template&lt; typename Container, typename UnaryOperation &gt;
inline UnaryOperation 
for_each( const Container& c, UnaryOperation fun );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator 
find( Container& c, const T& value );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator 
find( const Container& c, const T& value );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator 
find_if( Container& c, Predicate pred );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
find_if( const Container& c, Predicate pred );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
adjacent_find( Container& c );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
adjacent_find( const Container& c );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator 
adjacent_find( Container& c, BinaryPredicate pred );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator 
adjacent_find( const Container& c, BinaryPredicate pred );

template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator 
find_first_of( Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator 
find_first_of( const Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2, 
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator 
find_first_of( Container1& c1, const Container2& c2, 
               BinaryPredicate pred );
template&lt; typename Container1, typename Container2, 
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator 
find_first_of( const Container1& c1, const Container2& c2, 
               BinaryPredicate pred );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::difference_type
count( const Container& c, const T& value );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::difference_type
count_if( const Container& c, Predicate pred );

template&lt; typename Container, typename InputIterator &gt;
inline std::pair&lt; typename iterator_range_traits&lt;Container&gt;::iterator,
InputIterator &gt;
mismatch( Container& c, InputIterator first2 );

template&lt; typename Container, typename InputIterator &gt;
inline std::pair&lt; typename iterator_range_traits&lt;Container&gt;::const_iterator,
InputIterator &gt;
mismatch( const Container& c, InputIterator first2 );

template&lt; typename Container, typename InputIterator, 
typename BinaryPredicate &gt;
inline std::pair&lt; typename iterator_range_traits&lt;Container&gt;::iterator,
InputIterator &gt;
mismatch( Container& c, InputIterator first2, BinaryPredicate pred );

template&lt; typename Container, typename InputIterator, 
typename BinaryPredicate &gt;
inline std::pair&lt; typename iterator_range_traits&lt;Container&gt;::const_iterator, 
InputIterator &gt;
mismatch( const Container& c, InputIterator first2, 
          BinaryPredicate pred );

template&lt; typename Container, typename InputIterator &gt;
inline bool 
equal( const Container& c, InputIterator first2 );

template&lt; typename Container, typename InputIterator, 
typename BinaryPredicate &gt; 
inline bool 
equal( const Container& c, InputIterator first2, 
       BinaryPredicate pred );
template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator 
search( Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator 
search( const Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2,
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator
search( Container1& c1, const Container2& c2, BinaryPredicate pred );

template&lt; typename Container1, typename Container2,
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator
search( const Container1& c1, const Container2& c2, BinaryPredicate pred );

template&lt; typename Container, typename Integer, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator 
search_n( Container& c, Integer count, const T& value );

template&lt; typename Container, typename Integer, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator 
search_n( const Container& c, Integer count, const T& value );

template&lt; typename Container, typename Integer, 
typename T, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
search_n( Container& c, Integer count, const T& value,
          BinaryPredicate pred );
template&lt; typename Container, typename Integer, 
typename T, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
search_n( const Container& c, Integer count, const T& value,
          BinaryPredicate pred );

template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator 
find_end( Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2 &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator 
find_end( const Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2,
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::iterator 
find_end( Container1& c1, const Container2& c2, BinaryPredicate pred );

template&lt; typename Container1, typename Container2,
typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container1&gt;::const_iterator 
find_end( const Container1& c1, const Container2& c2, 
          BinaryPredicate pred );

/////////////////////////////////////////////////////////////////////////
// Modifying Sequance Operations
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container, typename OutputIterator &gt;
inline OutputIterator
copy( const Container& c, OutputIterator result );

template&lt; typename Container, typename BidirectionalIterator &gt; 
inline BidirectionalIterator
copy_backward( const Container& c, BidirectionalIterator result ); 

template&lt; typename Container, typename ForwardIterator &gt;
inline ForwardIterator 
swap_ranges( Container& c, ForwardIterator first2 ); 

template&lt; typename Container, typename OutputIterator, 
typename UnaryOperation &gt; 
inline OutputIterator 
transform( const Container& c, OutputIterator result, 
           UnaryOperation fun );

template&lt; typename Container, typename InputIterator,
typename OutputIterator, typename BinaryOperation &gt;
inline OutputIterator
transform( const Container& c, InputIterator first2,
           OutputIterator result, BinaryOperation fun );

template&lt; typename Container, typename T &gt;
inline void
replace( Container& c, const T& what, const T& with_what );

template&lt; typename Container, typename Predicate , typename T &gt;
inline void
replace_if( Container& c, Predicate pred, const T& value );

template&lt; typename Container, typename OutputIterator, typename T &gt; 
inline OutputIterator
replace_copy( const Container& c, OutputIterator result, 
              const T& what, const T& with_what );

template&lt; typename Container, typename OutputIterator, 
typename Predicate, typename T &gt;
inline OutputIterator
replace_copy_if( const Container& c, OutputIterator result,
                 Predicate pred, const T& value );

template&lt; typename Container, typename T &gt;
inline void
fill( Container& c, const T& value );

template&lt; typename Container, typename Integer, typename T &gt;
inline void
fill_n( Container& c, Integer size, const T& value );

template&lt; typename Container, typename Generator &gt;
inline void
generate( Container& c, Generator gen );

template&lt; typename Container, typename Integer, typename Generator &gt;
void
generate_n( Container& c, Integer size, Generator gen );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
remove( Container& c, const T& what );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
remove_if( Container& c, Predicate pred );

template&lt; typename Container, typename OutputIterator, typename T &gt;
inline OutputIterator
remove_copy( const Container& c, OutputIterator result, const T& value );

template&lt; typename Container, typename OutputIterator, typename Predicate &gt;
inline OutputIterator
remove_copy_if( const Container& c, OutputIterator result, Predicate pred );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
unique( Container& c );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
unique( Container& c, BinaryPredicate pred );

template&lt; typename Container, typename OutputIterator &gt;
inline OutputIterator
unique_copy( const Container& c, OutputIterator result );

template&lt; typename Container, typename OutputIterator, 
typename BinaryPredicate &gt;
inline OutputIterator
unique_copy( const Container& c, OutputIterator result, 
             BinaryPredicate pred );

template&lt; typename Container &gt;
inline void
reverse( Container& c );

template&lt; typename Container, typename OutputIterator &gt;
inline OutputIterator
reverse_copy( const Container& c, OutputIterator result );

template&lt; typename Container &gt; 
inline void
rotate( Container& c, 
        typename iterator_range_traits&lt;Container&gt;::iterator middle );

template&lt; typename Container, typename ForwardIterator, 
typename OutputIterator &gt;
inline OutputIterator
rotate_copy( Container& c, ForwardIterator middle, OutputIterator result ); 

template&lt; typename Container, typename ForwardIterator, 
typename OutputIterator &gt;
inline OutputIterator
rotate_copy( const Container& c, ForwardIterator middle, 
             OutputIterator result ); 

template&lt; typename Container &gt;
inline void
random_shuffle( Container& c );

template&lt; typename Container, typename Generator &gt;
inline void
random_shuffle( Container& c, Generator gen );

/////////////////////////////////////////////////////////////////////////
// Sorted Sequences
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container &gt;
inline void
sort( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
sort( Container& c, Compare comp );

template&lt; typename Container &gt;
inline void
stable_sort( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
stable_sort( Container& c, Compare comp );

template&lt; typename Container, typename RandomAccessIterator &gt;
inline void
partial_sort( Container& c, RandomAccessIterator middle );

template&lt; typename Container, typename RandomAccessIterator, 
typename Compare &gt;
inline void
partial_sort( Container& c, RandomAccessIterator middle,
              Compare comp );

template&lt; typename Container1, typename InputIterator &gt;
inline typename iterator_range_traits&lt;InputIterator&gt;::iterator
partial_sort_copy( const Container1& c1, InputIterator& c2 );

template&lt; typename Container1, typename InputIterator, typename Compare &gt;
inline typename iterator_range_traits&lt;InputIterator&gt;::iterator
partial_sort_copy( const Container1& c1, InputIterator& c2, Compare comp );

template&lt; typename Container &gt;
inline void
nth_element( Container& c, 
             typename iterator_range_traits&lt;Container&gt;::iterator nth );
template&lt; typename Container, typename Compare &gt;
inline void
nth_element( Container& c, 
             typename iterator_range_traits&lt;Container&gt;::iterator nth, 
             Compare comp );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
lower_bound( Container& c, const T& value );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
lower_bound( const Container& c, const T& value );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
lower_bound( Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
lower_bound( const Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
upper_bound( Container& c, const T& value );

template&lt; typename Container, typename T &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
upper_bound( const Container& c, const T& value );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
upper_bound( Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
upper_bound( const Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T &gt;
inline typename pair_return&lt;Container,Container&gt;::mutable_pair 
equal_range( Container& c, const T& value );

template&lt; typename Container, typename T &gt;
inline typename pair_return&lt;Container,Container&gt;::const_pair 
equal_range( const Container& c, const T& value );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename pair_return&lt;Container,Container&gt;::mutable_pair
equal_range( Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T, typename Compare &gt;
inline typename pair_return&lt;Container,Container&gt;::const_pair
equal_range( const Container& c, const T& value, Compare comp );

template&lt; typename Container, typename T &gt;
inline bool
binary_search( const Container& c, const T& value );


template&lt; typename Container, typename T, typename Compare &gt;
inline bool
binary_search_( const Container& c, const T& value, Compare comp );

template&lt; typename Container1, typename Container2, typename Container3 &gt; 
inline typename iterator_range_traits&lt;Container3&gt;::iterator
merge( const Container1& c1, const Container2& c2, Container3& c3 );

template&lt; typename Container1, typename Container2, typename Container3, 
typename Compare &gt;
inline typename iterator_range_traits&lt;Container3&gt;::iterator
merge( const Container1& c1, const Container2& c2, Container3& c3,
       Compare comp );

template&lt; typename Container &gt;
inline void
inplace_merge( Container& c, 
               typename iterator_range_traits&lt;Container&gt;::iterator middle );

template&lt; typename Container, typename Compare &gt;
inline void
inplace_merge_( Container& c,
                typename iterator_range_traits&lt;Container&gt;::iterator middle, 
                Compare comp );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
partition( Container& c, Predicate pred );

template&lt; typename Container, typename Predicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
stable_partition( Container& c, Predicate pred );

/////////////////////////////////////////////////////////////////////////
// Set Algorithms
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container1, typename Container2 &gt;
inline bool 
includes( const Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2, typename Compare &gt;
inline bool 
includes( const Container1& c1, const Container2& c2, Compare comp );

template&lt; typename Container1, typename Container2, 
typename OutputIterator &gt; 
inline OutputIterator
set_union( const Container1& c1, const Container2& c2, 
           OutputIterator result );

template&lt; typename Container1, typename Container2, 
typename OutputIterator, typename Compare &gt;
inline OutputIterator
set_union( const Container1& c1, const Container2& c2,
           OutputIterator result, Compare comp );

template&lt; typename Container1, typename Container2, 
typename OutputIterator &gt; 
inline OutputIterator
set_intersection( const Container1& c1, const Container2& c2, 
                  OutputIterator result );

template&lt; typename Container1, typename Container2, 
typename OutputIterator, typename Compare &gt; 
inline OutputIterator
set_intersection( const Container1& c1, const Container2& c2, 
                  OutputIterator result, Compare comp );

template&lt; typename Container1, typename Container2, 
typename OutputIterator &gt; 
inline OutputIterator
set_difference( const Container1& c1, const Container2& c2,  
                OutputIterator result );

template&lt; typename Container1, typename Container2, 
typename OutputIterator, typename Compare &gt;
inline OutputIterator
set_difference( const Container1& c1, const Container2& c2,  
                OutputIterator result, Compare comp );

template&lt; typename Container1, typename Container2, 
typename OutputIterator &gt;
inline OutputIterator
set_symmetric_difference( const Container1& c1, const Container2& c2,
                          OutputIterator result );

template&lt; typename Container1, typename Container2, 
typename OutputIterator, typename Compare &gt;
inline OutputIterator
set_symmetric_difference( const Container1& c1, const Container2& c2,
                          OutputIterator result, Compare comp );

///////////////////////////////////////////////////////////////////////////
// Heap Operations
///////////////////////////////////////////////////////////////////////////

template&lt; typename Container &gt;
inline void 
push_heap( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
push_heap( Container& c, Compare comp );

template&lt; typename Container &gt;
inline void 
pop_heap( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
pop_heap( Container& c, Compare comp );

template&lt; typename Container &gt;
inline void 
make_heap( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
make_heap( Container& c, Compare comp );

template&lt; typename Container &gt;
inline void 
sort_heap( Container& c );

template&lt; typename Container, typename Compare &gt;
inline void
sort_heap( Container& c, Compare comp );

/////////////////////////////////////////////////////////////////////////
// Minimum and Maximum
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
min_element( Container& c );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
min_element( const Container& c );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
min_element( Container& c, BinaryPredicate pred );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
min_element( const Container& c, BinaryPredicate pred );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
max_element( Container& c );

template&lt; typename Container &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
max_element( const Container& c );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::iterator
max_element( Container& c, BinaryPredicate pred );

template&lt; typename Container, typename BinaryPredicate &gt;
inline typename iterator_range_traits&lt;Container&gt;::const_iterator
max_element( const Container& c, BinaryPredicate pred );

template&lt; typename Container1, typename Container2 &gt;
inline bool
lexicographical_compare( const Container1& c1, const Container2& c2 );

template&lt; typename Container1, typename Container2, 
typename BinaryPredicate &gt; 
inline bool
lexicographical_compare( const Container1& c1, const Container2& c2, 
                         BinaryPredicate pred );

/////////////////////////////////////////////////////////////////////////
// Permutations
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container &gt;
inline bool
next_permutation( Container& c );

template&lt; typename Container, typename Compare &gt;
inline bool
next_permutation( Container& c, Compare comp );

template&lt; typename Container &gt;
inline bool
prev_permutation( Container& c );

template&lt; typename Container, typename Compare &gt;
inline bool
prev_permutation( Container& c, Compare comp );

/////////////////////////////////////////////////////////////////////////
// Generalized Numeric Algorithms
/////////////////////////////////////////////////////////////////////////

template&lt; typename Container, typename T &gt;
inline T
accumulate( const Container& c, T initial );

template&lt; typename Container, typename T, typename BinaryOperation &gt;
inline T
accumulate( const Container& c, const T initial, BinaryOperation fun );

template&lt; typename Container, typename InputIterator, typename T &gt;
inline T                            
inner_product( const Container& c, InputIterator first2,
               const T initial );

template&lt; typename Container, typename InputIterator, typename T,
typename BinaryOperation1, typename BinaryOperation2 &gt;
inline T                            
inner_product( const Container& c, InputIterator first2,
               const T initial, BinaryOperation1 fun1, 
               BinaryOperation2 fun2 );

template&lt; typename Container, typename OutputIterator &gt;
inline OutputIterator
partial_sum( const Container& c, OutputIterator result );

template&lt; typename Container, typename OutputIterator, 
typename BinaryOperation &gt; 
inline OutputIterator
partial_sum_( const Container& c, OutputIterator result, 
              BinaryOperation fun );

template&lt; typename Container, typename OutputIterator &gt;
inline OutputIterator
adjacent_difference( const Container& c, OutputIterator result );

template&lt;typename Container, typename OutputIterator, typename Predicate &gt;
inline OutputIterator
adjacent_difference( const Container& c, OutputIterator result, 
                     Predicate pred );

} // namespace 'boost' </pre><hr size="1" ><h2  >Portability</h2><a name="Portability" ></a><p  >The portability of the library depends totally on  <a href="../../container_traits/doc/container_traits.html" target="_self" ><code  >container_traits&lt;&gt;</code></a> .This means that you should at least expect everything to work with standard
            containers and pairs of iterators whereas array handling will be a problem on more challenged
            compilers.</p><hr size="1" ><p  >&copy; Thorsten Ottosen 2003 (nesotto@cs.auc.dk).
    Permission to copy, use, modify, sell and distribute this software is granted provided this copyright notice appears
     in all copies. This software is provided "as is" without express or implied warranty, and with no
         claim as to its suitability for any purpose.</p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></body></html>