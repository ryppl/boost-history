<?xml version = "1.0" encoding = "UTF-8"?>
<!--
(C) Copyright 2003-2004: Reece H. Dunn 
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-->

<section id = "outfmt.manipulators"><title>Manipulators</title>
   <para>
      It is often necessary to override the way a type is formatted (written to/read from) to
      a stream, or to format a subrange of a container or array. The manipulators in this
      library serve this purpose. For example:
   </para>
   <programlisting>
      int a[] = { 5, 4, 3, 2, 1 };
      std::cout &lt;&lt; boost::io::formatob( boost::io::range( a, a + 5 ));
      std::cin  &gt;&gt; boost::io::formatob( boost::io::range( a, a + 5 ));
      // output: [ 5, 4, 3, 2, 1 ]</programlisting>
   <section id = "outfmt.manip"><title>boost::io::formatob</title>
      <para>
         The manipulators are available by including <code>boost/outfmt/formatob.hpp</code>. In
         order to add support for various STL and Boost types you need to include the appropriate
         files listed in the <link linkend = "outfmt.stlio">STL I/O</link> section.
      </para><para>
         <code>boost::io::formatob</code> is where all the magic happens. Basically, the way
         <code>boost::io::formatob</code> works is that it uses the manipulator technique to
         create a <code>boost::io::formatob_t</code> class. This class stores a reference to
         the object being outputted so it can be routed to the format object for rendering
         to/from the stream. More information on how this process works can be found in the
         <link linkend = "outfmt.fmtobj">format object</link> section.
      </para>

      <programlisting>   boost::io::formatob( const T &amp; ob );</programlisting>
      <para>
         This will format <code>ob</code> according to its underlying type. This is
         equivalent to using <code>boost::io::formatobex&lt; const char * &gt;</code>
         (see below).
      </para>

      <programlisting>
   std::vector&lt; float &gt; v; // = { 1.1f, 2.2f, 3.3f };
   std::cout &lt;&lt; boost::io::formatob( v );
   // output: [ 1.1, 2.2, 3.3 ]</programlisting>

      <programlisting>   boost::io::formatobex&lt; DelimeterType &gt;( const T &amp; ob );</programlisting>
      <para>
         This will format <code>ob</code> according to its underlying type.
         <code>DelimeterType</code> allows you to specify the type used to store the
         <link linkend = "outfmt.delimeters">delimeters</link> (see that section for more info).
      </para>
      <programlisting>
   std::vector&lt; float &gt; v; // = { 1.1f, 2.2f, 3.3f };
   std::cout &lt;&lt; boost::io::formatobex&lt; std::string &gt;( v );
   // output: [ 1.1, 2.2, 3.3 ]
   std::cout &lt;&lt; boost::io::formatobex&lt; std::string &gt;
                (
                   std::make_pair( 7, 3.14159 )
                );
   // output: ( 7, 3.14159 )</programlisting>

      <para>
         Note that the type construct is automatically deduced and the corresponding
         <link linkend = "outfmt.fmtobj">format object</link> is constructed.
      </para>

      <programlisting>   boost::io::formatob( const T &amp; ob, const FormatObject &amp; fo );</programlisting>
      <para>
         This will format <code>ob</code> based on the <link linkend = "outfmt.fmtobj">format
         object</link> it is passed (<code>FormatObject</code>). Here, the format type is
         taken from <code>FormatObject::format_type</code>. This allows nested constructs
         to be formatted.
      </para>

      <programlisting>
   std::pair&lt; char, std::vector&lt; float &gt; &gt; po;
   std::cout &lt;&lt; boost::io::formatob( po,
                   boost::io::pairfmt
                   (
                      boost::io::basicfmt(),
                      boost::io::containerfmt().format( "[{ ", " }]" )
                   ).format( " : " )
                ).format( "&lt; ", " &gt;" );
   // output: &lt; a : [{ 1.1, 2.2, 3.3 }] &gt;</programlisting>
   </section>
   <section id = "outfmt.range"><title>boost::io::range</title>
      <para>
         The purpose of <code>boost::io::range</code> is to make a range of elements
         <code>[ first, last )</code> behave as a single container-like type that
         can be processed by <code>boost::io::formatob</code>.
      </para>

      <programlisting>
   boost::io::range( ForwardIterator first, ForwardIterator last );</programlisting>
      <para>
         This creates the range <code>[first, last)</code> that can be used by <code>boost::io::formatob</code>.
      </para>

      <programlisting>
   boost::io::range( const std::pair&lt; ForwardIterator, ForwardIterator &gt; pi );</programlisting>
      <para>
         This creates the range <code>[pi.first, pi.second)</code> that can be used by <code>boost::io::formatob</code>.
         Normally, <code>boost::io::formatob</code> interprets a <code>std::pair</code> type as a 2-ary sequence. If
         the pair type specifies a range, you need to use this function to inform <code>boost::io::formatob</code>
         that it is a range.
      </para>

      <programlisting>
   boost::io::range( const Container &amp; c );</programlisting>
      <para>
         This creates the range <code>[c.begin(), c.end())</code>. <code>boost::io::formatob</code> provides
         native support for containers, specifically dynamic construction of the container when reading it
         in from a stream. This is here for completeness and for when you want to specifically keep the
         number of elements in the container the same.
      </para>

      <programlisting>
   boost::io::range( const T a[ n ] );</programlisting>
      <para>
         This creates the range <code>[a, a + n)</code>. <code>boost::io::formatob</code> provides
         native support for arrays, this is here for completeness only.
      </para>

      <programlisting>
   boost::io::range( const T a[ n ], std::size_t off );</programlisting>
      <para>
         This creates the range <code>[a + off, a + n)</code>, allowing you to display an array starting
         at the given offset.
      </para>

      <programlisting>
   boost::io::range( const T a[ n ], std::size_t off, std::size_t len );</programlisting>
      <para>
         This creates the range <code>[a + off, a + off + len)</code>, allowing you to display <code>len</code>
         elements on an array, starting at a given offset.
      </para>

      <programlisting>
   int array = { 1, 2, 3, 4, 5, 6, 7 };
   std::cout &lt;&lt; boost::io::formatob( boost::io::range( array + 2, array + 4 )); // output: [ 3, 4 ]
   std::cout &lt;&lt; boost::io::formatob
                (
                   boost::io::range( std::make_pair( array + 2, array + 4 ))
                ); // output: [ 3, 4 ]
   std::cout &lt;&lt; boost::io::formatob( boost::io::range( array, 2 )); // output: [ 3, 4, 5, 6, 7 ]
   std::cout &lt;&lt; boost::io::formatob( boost::io::range( array, 2, 4 )); // output: [ 3, 4, 5, 6 ]</programlisting>
   </section>
</section>
