<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.2.20 i686) [Netscape]">
   <title>Linear Sort Library</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<h1>
<img SRC="c++boost.gif" ALT="C++ Boost" height=86 width=277>Boost Linear
Sort Library</h1>

<h1>
Block Sort</h1>
<a NAME="Synopsis"></a>Synopsis
<pre>#include <a href="property_map.htm">&lt;boost/linear_sort/property_map.hpp></a></pre>

<pre>namespace boost {

&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( unsigned char );
&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( signed char );
&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( unsigned short );
&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( signed short );
&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( unsigned int );
&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( signed int );
&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( unsigned long );
&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( signed long );
&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( float );
&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( double );
&nbsp; BOOST_DECLARE_BLOCK_SORT_TYPE( long double );

&nbsp; BOOST_DECLARE_BLOCK_SORT_TEMPLATE_1_2( class T, std::size_t N , T[N] );
#ifdef BOOST_ARRAY_HPP
&nbsp; BOOST_DECLARE_BLOCK_SORT_TEMPLATE_2( class T, std::size_t N , ::boost::array&lt;T,N>&nbsp; );
#endif

&nbsp; // straight versions
&nbsp; template &lt;class RandomAccessIterator>
&nbsp; void block_sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last);

&nbsp; template &lt;class RandomAccessIterator,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator>
&nbsp; void block_sort_copy&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator>
&nbsp; void indirect_block_sort(RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result);

&nbsp; // predicate versions
&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ProjectionPropertyMap>
&nbsp; void block_sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProjectionPropertyMap project);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ProjectionPropertyMap>
&nbsp; void block_sort_copy&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProjectionPropertyMap project);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ProjectionPropertyMap>
&nbsp; void indirect_block_sort(RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProjectionPropertyMap project);

} // namespace boost</pre>

<h3>
<a NAME="Algorithms"></a>Algorithms</h3>
The basic block sort algorithm is block_sort. This algorithm is not explained
in <a href="http://theory.lcs.mit.edu/~clr/">Introduction to Algorithms
(Cormen Leiserson, Rivest, Stein, 2nd Edition)</a>, but is very simple
to understand: as opposed to radix sort, it examines the <i>most significant</i>
radix first (recursively, that is using block_sort for the first radix;
this degenerates to counting sort for a one-byte radix), then for each
group of identical value, recursively performs block sort starting with
the second radix. In particular, if we stop the recursion when only one
value is present, then block sort performs at most the number of comparison
as if we were using std::sort with std::lexicographical_compare (viewing
the value type as a container of radices).
<p>The overhead as compared to radix_sort is the initialization of the
counters for each block of each radix (radix_sort initializes the counters
only once for each radix). On the other hand, if all the first radix values
are distinct, then block_sort terminates after the first pass. It is generally
faster than std::sort for large ranges, since the sort for each radix is
linear time, but experiments need to be performed. Therefore, block_sort
should be preferred for large numbers of radices, or when the values are
very separated.
<p>Block sort uses an extra buffer, while block_sort_copy uses both the
input and the output. Both algorithms copy back and forth between the two
buffers (and perform an extra copy if the number of radices is odd for
block_sort_copy, or even for block_sort).
<p>The macro BOOST_DECLARE_BLOCK_SORT_TYPE is used to declare what types
should be usable by counting_sort. If the type is a template, then useBOOST_DECLARE_BLOCK_SORT_TEMPLATE_N
instead (with _N being _2 if there are two template parameters, or _3,
_4). The BOOST_DECLARE_BLOCK_SORT_TEMPLATE_1_2 is used only for declaring
builtin arrays (in that case, the class name does not contain a comma,
which reduces the number of arguments of the macro).
<p>The default is as specified above, but the user may add more types.
If <tt>&lt;boost/array.hpp></tt> is already included, then <tt>boost::array
</tt>is
also supported. Among the types that should be supported are
<tt>boost::tuple</tt>,
standard containers (but there are some issues if the size is shorter than
the number of radices), and std::string (same issues).
<h3>
<a NAME="Examples"></a>Examples</h3>
The first example illustrates the various ways to sort an sequence of integers:
<pre>&nbsp; using namespace std;
&nbsp; size_t array_size = 1000000; // one million elements</pre>

<pre>&nbsp; // Example with vector of integers (could use float, double, etc.)
&nbsp; vector&lt; integer > v(array_size), w(array_size, 0);
&nbsp; generate(v.begin(), v.end(), rand());</pre>

<pre>&nbsp; // Sort vector of integers (needs a temporary buffer, otherwise use std::sort)
&nbsp; copy(v.begin(), v.end(), w.begin());
&nbsp; boost::block_sort(w.begin(), w.end());</pre>

<pre>&nbsp; // Copy sort vector, should yield same result (but no temporary buffer)
&nbsp; boost::block_sort_copy(v.begin(), v.end(), w.begin());</pre>
The second example takes a sequence of arrays. We choose to use <tt>boost::array</tt>
instead of the builtin array types because it plays better with some implementations
of <tt>std::sort</tt> (especially the SGI STL):
<pre>&nbsp; // Example with vector of arrays (unsigned char [4])
&nbsp; typedef boost::array&lt;unsigned char,4> array_t;
&nbsp; vector&lt; array_t > va(array_size/4), wa(array_size/4, 0);</pre>

<pre>&nbsp; // Fill up vector of arrays
&nbsp; for (iterator it = va.begin(); it != va.end(); ++it)
&nbsp;&nbsp;&nbsp; for (unsigned i = 0; i &lt; 4; ++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*it)[i] = (unsigned char) rand();</pre>

<pre>&nbsp; // Sort vector of arrays (will use temporary buffer)
&nbsp; copy(va.begin(), va.end(), wa.begin());
&nbsp; boost::block_sort(wa.begin(), wa.end());</pre>

<pre>&nbsp; // Copy sort vector of arrays, should yield same result (no temporary buffer)
&nbsp; boost::block_sort_copy(va.begin(), va.end(), wa.begin());</pre>

<hr>
<table>
<tr VALIGN=TOP>
<td NOWRAP>Copyright &copy; 2002</td>

<td>Herve Bronnimann, Polytechnic University.</td>
</tr>
</table>

</body>
</html>
