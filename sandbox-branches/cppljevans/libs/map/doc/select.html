<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<STYLE>
		.code { font-family:monospace; font-size: 10pt }
        H1, H2, H3 { font-family:Verdana, Tahoma, sans-serif; font-weight:0 }
        H1 { font-size: 20pt }
        H2 { font-size: 16pt }
		P { color: black }
		TH { text-align:left }
		A { text-decoration:none }
        A:visited { color: #005E20 }
        A.contact { color: black; text-decoration:none }
		.code { font-family:monospace; font-size: 10pt }
		.headingCode { font-family:monospace; font-size: 12pt }
		.concept { font-weight: bold }
	</STYLE>
</HEAD>
<BODY>

<TABLE BORDER='0' WIDTH='100%'>
<TR>
    <TD WIDTH="*" STYLE='text-align:left'><H1>Select</H1></TD>
    <TD ALIGN=right>
        <TABLE>
            <TR>
                <TD STYLE='text-align:center'><A HREF='../../../index.html'><IMG BORDER=0 SRC='../../../kangaroo.gif'></A></TD>
            </TR>
            <TR>
                <TD ALIGN='center'>
                    <A STYLE='text-align:center;color: black;font: bold italic 12pt/17pt Verdana, sans-serif; text-decoration:none' HREF='../../../index.html'>Metaprogramming<BR>Utilities</A>
                </TD>
            </TR>
        </TABLE>
    </TD>
</TR>
</TABLE>

<H2>Contents</H2>

<DL STYLE='margin-left:1em'>
	<DT>1. <A HREF='#overview'>Overview</A>
	<DT>2. <A HREF='#usage'>Usage</A>
	<DT>3. <A HREF='#synopsis'>Synopsis</A>
	<DT>4. <A HREF='#implementation'>Implementation</A>
	<DT>5. <A HREF='#dependencies'>Dependencies</A>
	<DT>6. <A HREF='#portability'>Portability</A>
	<DT>7. <A HREF='#feedback'>Feedback</A>
</DL>

<A NAME='overview'></A>
<H2>Overview</H2>

<P>
	The header <A HREF='../../../boost/mpl/select.hpp'><SPAN CLASS='code'>&lt;boost/mpl/select.hpp&gt;</SPAN></A> provides metafunctions performing multi-case compile-time <I>if-then-else</I> operations in a more user-friendly manner than <A HREF='http://www.boost.org/boost/mpl/switch.hpp'><SPAN CLASS='code'>mpl::switch_</SPAN></A> or nested <A HREF='http://www.boost.org/boost/mpl/if.hpp'><SPAN CLASS='code'>mpl::if_</SPAN></A>'s and <A HREF='http://www.boost.org/boost/mpl/apply_if.hpp'><SPAN CLASS='code'>apply_if</SPAN></A>'s. Lazy evaluation can be requested on a case-by-case basis, or for all specified items. The number of cases supported is implementation defined but is guaranteed to be at least 16.
</P>

<P>
    The header provides two true MPL <A HREF='http://www.boost.org/libs/mpl/doc/ref/Metafunction.html'>Metafunctions</A> <SPAN CLASS='code'>select</SPAN> and <SPAN CLASS='code'>lazy_select</SPAN>, as well as two convenience templates <SPAN CLASS='code'>select_c</SPAN> and <SPAN CLASS='code'>lazy_select_c</SPAN>.

<A NAME='usage'></A>
<H2>Usage</H2>

The template <SPAN CLASS='code'>mpl::select_c</SPAN> takes an alternating sequence of boolean values and types, returning the first type paired with the value <SPAN CLASS='code'>true</SPAN>. <I>E.g.</I>, 

<PRE>    #include &lt;boost/mpl/assert_is_same.hpp&gt;
    #include &lt;boost/mpl/select.hpp&gt;
    using namespace boost::mpl;

    typedef mpl::select_c&lt; 
                false, int,
                false, long,
                true,  char,
                false, bool,
                true,  void 
            &gt;::type selection;

    BOOST_MPL_ASSERT_IS_SAME(selection, char);</PRE>

The template <SPAN CLASS='code'>mpl::select</SPAN> is similar, except that instead of boolean values it takes models of <A HREF='http://www.boost.org/libs/mpl/doc/ref/Integral_Constant.html'>Integral Constant</A>. <I>E.g.</I>, 

<PRE>    #include &lt;boost/mpl/bool.hpp&gt;
        
    typedef select< 
                false_, int,
                false_, long,
                true_,  char,
                false_, bool,
                true_,  void 
            >::type selection;

    BOOST_MPL_ASSERT_IS_SAME(selection, char);</PRE>

To specify that one or more type arguments to <SPAN CLASS='code'>select_c</SPAN> or <SPAN CLASS='code'>select</SPAN> be subject to lazy evaluation, use the template <SPAN CLASS='code'>mpl::lazy</SPAN>:

<PRE>    struct lazy_char { typedef char type; };
        
    typedef select< 
                false_, lazy&lt;lazy_char&gt;,
                false_, long,
                true_,  lazy&lt;lazy_char&gt;,
                false_, bool,
                true_,  void 
            >::type selection;

    BOOST_MPL_ASSERT_IS_SAME(selection, char);</PRE>

Here the metafunction <SPAN CLASS='code'>lazy_char</SPAN> is evaluated only if it is selected.

To request lazy evaluation of each sepecified type, use <SPAN CLASS='code'>mpl::lazy_select_c</SPAN> or <SPAN CLASS='code'>mpl::lazy_select</SPAN>.
 

<A NAME='synopsis'></A>
<H2>Synopsis</H2>

<PRE>    namespace boost {
      namespace mpl {

        template&lt;typename T&gt; struct <B>lazy</B>;

        template&lt; bool B1 = true, typename T1 = <I>implementation-defined</I>, 
                  bool B2 = true, typename T2 = <I>implementation-defined</I>, 
                  ...
                  bool Bn = true, typename Tn = <I>implementation-defined</I> &gt;
        struct <B>select_c</B> {
            typedef <I>unspecified</I> type;
        };

        template&lt; typename B1 = mpl::true_, typename T1 = <I>implementation-defined</I>, 
                  typename B2 = mpl::true_, typename T2 = <I>implementation-defined</I>, 
                  ...
                  typename Bn = mpl::true_, typename T1 = <I>implementation-defined</I> &gt;
        struct <B>select</B> {
            typedef typename select_c&lt;B1::value, T1, ... , Bn::value, Tn&gt;::type type;
        };

        template&lt; bool B1 = true, typename T1 = <I>implementation-defined</I>, 
                  bool B2 = true, typename T2 = <I>implementation-defined</I>, 
                  ...
                  bool Bn = true, typename Tn = <I>implementation-defined</I> &gt;
        struct <B>lazy_select_c</B> {
            typedef typename select_c&lt;B1, T1, ... , Bn, Tn&gt;::type  result;
            typedef typename result::type                          type;
        };

        template&lt; typename B1 = mpl::true_, typename T1 = <I>implementation-defined</I>, 
                  typename B2 = mpl::true_, typename T2 = <I>implementation-defined</I>, 
                  ...
                  typename Bn = mpl::true_, typename T1 = <I>implementation-defined</I> &gt;
        struct <B>lazy_select</B> {
            typedef typename select&lt;B1, T1, ... , Bn, Tn&gt;::type  result;
            typedef typename result::type                        type;
        };

      } 
    }</PRE>


<A NAME='implementation'></A>
<H2>Implementation</H2>

<P>
The template <SPAN CLASS='code'>select</SPAN> is implemented by a recursion of depth logarithmic in the number of cases. It is designed to be a reasonable alternative to nested <SPAN CLASS='code'>mpl::if_</SPAN>'s and <SPAN CLASS='code'>apply_if</SPAN>'s even when only a few cases are specified. In unscientific testing, the present implementation of <SPAN CLASS='code'>select</SPAN> was found to be noticeably  faster than an alternative implementation using <A HREF='http://www.boost.org/boost/mpl/switch.hpp'><SPAN CLASS='code'>mpl::switch_</SPAN></A>. 
</P>

<P>
In general there is a tradeoff between the depth of template nesting and the efficiency of evaluation of the models of <A HREF='http://www.boost.org/libs/mpl/doc/ref/Integral_Constant.html'>Integral Constant</A> passed to <SPAN CLASS='code'>select</SPAN> and <SPAN CLASS='code'>lazy_select</SPAN>. The current implementation evaluates a quarter of the total conditions at a time; an approach with deeper nesting could delay the evaluation of a significant number of these conditions until it is determined that their truth value is relevant to the computation. When <SPAN CLASS='code'>select</SPAN> is restricted to 16 cases, as it is now, the current implementation is more efficient.
</P>

<P>
Note that this means that while the user can guarantee lazy evaluation of a metafunction by wrapping it using <SPAN CLASS='code'>lazy&lt;&gt;</SPAN>, the models of Integral Constant passed to <SPAN CLASS='code'>select</SPAN> cannot be guaranteed lazy evaluation.
</P>

<A NAME='dependencies'></A>
<H2>Dependencies</H2>

The header <A HREF='../../../boost/mpl/select.hpp'><SPAN CLASS='code'>&lt;boost/mpl/select.hpp&gt;</SPAN></A> depends on <A HREF='http://www.boost.org/libs/config/config.htm'>Boost.Config</A>, the <A HREF='http://www.boost.org/libs/preprocessor/doc/index.html'>Boost Preprocessor Library</A>, the <A HREF='http://www.boost.org/libs/type_traits/'>Boost Type Traits Library</A> and the <A HREF='http://www.boost.org/libs/mpl/doc/index.html'>Boost Metaprogramming Library</A>.

<A NAME='portability'></A>
<H2>Portability</H2>

<P>
	The program <A HREF='../test/select.cpp'><SPAN CLASS='code'>&lt;libs/mpl/test/select.cpp&gt;</SPAN></A> has been tested successfully with the following compilers:
	<UL type='square'>
		<LI STYLE='list-style-type: square'>Microsoft Visual C++ 6.0, SP 5</LI>
		<LI STYLE='list-style-type: square'>Microsoft Visual C++ 7.1</LI>
		<LI STYLE='list-style-type: square'>Metrowerks CodeWarrior 8.0</LI>
		<LI STYLE='list-style-type: square'>Intel C++ Compiler for Windows 7.1 and 8.0</LI>
		<LI STYLE='list-style-type: square'>GCC 2.95.3-10 (cygwin special)</LI>
		<LI STYLE='list-style-type: square'>GCC 3.2 (MinGW)</LI>
		<LI STYLE='list-style-type: square'>GCC 3.3.1 (cygming special)</LI>
		<LI STYLE='list-style-type: square'>Comeau C/C++ 4.3.3</LI>
		<LI STYLE='list-style-type: square'>Borland C++ 5.5.1 and 5.6.4</LI>
	</UL>
</P>

<A NAME='feedback'></A>
<H2>Feedback</H2>

The author, Jonathan Turkanis, can be contacted at <A CLASS='contact' HREF='mailto:turkanis@kangaroologic.com'>turkanis@kangaroologic.com</A>

<HR STYLE='margin:20,0,0'>

<P STYLE='font-size:8pt'>
	&copy; Copyright Jonathan Turkanis 2004.
	Permission to copy, use, modify, sell and distribute this document
	is granted provided this copyright notice appears in all copies. This
	document is provided "as is" without express or implied warranty, and
	with no claim as to its suitability for any purpose.
</P>

</BODY>