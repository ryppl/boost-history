<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN" 
  "/home/jjarvi/boost-sandbox/libs/documentation/dtd/boostbook.dtd">

<chapter>
  <title>Partial function application library</title>

  <chapterinfo>
    <author>
      <firstname></firstname>
      <surname></surname>
      <email></email>
    </author>
  </chapterinfo>

  <section>
    <title>Introduction</title>

<section><title>In a Nutshell</title>

<para>
This proposal suggests a library for partial function
application.
The library is a generalization of the <code>bind1st</code> and <code>bind2nd</code>
templates in the current standard.
The following examples demonstrate the proposed functionality:

<programlisting>
double m; double s; double x;
double gaussian(double x, double mean, double std);

bind(gauss, _1, m, s);             // #1
bind(gauss, x, _1, _2);            // #2
bind(gauss, bind(std::rand), m, s) // #3
</programlisting>

Line #1 applies the <code>gauss</code> function partially, 
binding the parameters <code>mean</code> and <code>std</code> 
to <code>m</code> and <code>s</code>, respectively, resulting in 
a unary function.
When called with an actual argument, say <code>x</code>, 
the special placeholder argument <code>_1</code> is replaced 
by <code>x</code> and the <code>gauss</code>
function is invoked with <code>x</code>, <code>m</code>, and <code>s</code>.
Hence, <code>bind(gauss, _1, m, s)(x)</code> computes the same result as
<code>gauss(x, m, s)</code>.

In line #2 we are using another placeholder variable <code>_2</code>,
and the result is a binary function.
The expression in line #3 shows how function compositions can be expressed
as nested bind functions. 
Here, the result is a zero-argument function that calls
 <code>gauss(std::rand(), m, s)</code> on every invocation.
</para>
</section>

<section>
  <title>Motivation</title>

<para>
Commonly small and simple function objects are needed solely 
to be passed to a standard algorithm, having no further use in the program.
Normal functions or function object classes are not 
well suited for this purpose; defining them is verbose and 
they add unnecessary names to the program.
Unnamed functions that can be defined within the algortihm call
are a solution to these problems.
The current tools for this purpose in the standard library include 

<itemizedlist>

<listitem>
<para>
Function object classes for commonly encountered functions
(such as <code>plus</code>, <code>less</code> and <code>negate</code>).
</para>
</listitem>

<listitem>
<para>
The <emphasis>binder</emphasis> templates <code>bind1st</code> and 
<code>bind2nd</code> for creating unary function objects 
from binary function objects by <emphasis>binding</emphasis> 
one of the arguments to a constant value.
</para>
</listitem>
<listitem>
<para>
The <code>ptr_fun</code>, <code>mem_fun</code> and <code>mem_fun_ref</code>
<emphasis>adaptors</emphasis> to allow binders to work with,
respectively, pointers to functions, pointers to member functions and 
references to member functions.
</para>
</listitem>
</itemizedlist>
</para>

<para>
The goal of all these tools is clear: to make it possible to write unnamed 
functions as arguments to standard algorithms.

However, the current set of tools leaves much room for improvement.

Unnamed functors built as compositions of standard function objects, binders, 
adaptors etc. are hard to read in all but the simplest cases.
The binding mechanism is restricted to binding one argument
of binary functions; there are no binders for 3-ary, 4-ary etc. functions.

In the face of these restrictions the programmer must often write explicit
function object classes just to be able to make a single 
standard algorithm invocation.
This is a considerable programming overhead, and not infrequently leads to 
replacing the invocation with a set of lower level looping constructs, 
abandoning thus the otherwise intuitive functional programming style.
</para>

<para>
This proposal suggests a binding mechanism, which 
allows binding any combination of arguments of practically 
any non-template C++ function (the library needs to set an upper limit
for the arity of the functions).
Furthermore, the mechanism defines a natural syntax for function composition.
Finally, certain requirements for bindable function object can be relaxed, 
in particular, there is no need for the adaptor templates 
(<code>fun_ptr</code> etc.).
</para>

<para>
It is possible to go much further in the direction of this proposal,
defining a sublanguage of its own for writing unnamed functions that contains
operators, control structures, casts etc.

</para>
<para>
ADD AN EXAMPLE HERE?
</para>
<para>

Such implementations
exist (reference to LL and Phx) and are relatively widely used.
However, due to the lack of typeof operator these libraries need to 
apply heuristics to deduce the return types of the unnamed functions.
These heuristic rules work well in practice, but there are cases 
where the they fail.

It does not seem to be a reasonable to propose the heuristic rules be
standardized.
The features proposed here are basically a subset of the features provided 
by the aforementioned libraries.
For this subset precise rules for return types exist.
We have carefully prepared this proposal to allow 
the above mentioned features to be written as extensions that 
work with any implementation conforming to the specification of this proposal.
</para>

</section>

</section>
  <section>
    <title>Impact on the Standard</title>

    <para>This proposal is a pure extension, no
    existing headers are modified.
    The proposal obsoletes the <code>bind1st</code>, <code>bind2nd</code>, 
    <code>ptr_fun</code>, <code>mem_fun</code>, and <code>mem_fun_ptr</code>
    templates. Deprecating these templates can be considered.
    </para>

  </section>

  <section>
    <title>Proposed Text</title>
  </section>

  <section>
    <title>Rationale</title>
  </section>

  <section>
    <title>Acknowledgements</title>
  </section>
</chapter>