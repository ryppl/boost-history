<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.2.20 i686) [Netscape]">
   <title>Linear Sort Library</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<h1>
<img SRC="c++boost.gif" ALT="C++ Boost" height=86 width=277>Boost Linear
Sort Library</h1>

<h1>
Counting Sort</h1>
<a NAME="Synopsis"></a>Synopsis
<pre>#include <a href="property_map.htm">&lt;boost/linear_sort/property_map.hpp></a></pre>

<pre>namespace boost {

&nbsp; BOOST_DECLARE_COUNTING_SORT_TYPE(bool);
&nbsp; BOOST_DECLARE_COUNTING_SORT_TYPE(char);
&nbsp; BOOST_DECLARE_COUNTING_SORT_TYPE(unsigned char);
&nbsp; BOOST_DECLARE_COUNTING_SORT_TYPE(signed char);</pre>

<pre>&nbsp; // straight versions
&nbsp; template &lt;class RandomAccessIterator>
&nbsp; void counting_sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last);

&nbsp; template &lt;class RandomAccessIterator,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator>
&nbsp; void counting_sort_copy&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator>
&nbsp; void indirect_counting_sort(RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result);

&nbsp; // predicate versions
&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ProjectionPropertyMap>
&nbsp; void counting_sort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProjectionPropertyMap project);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ProjectionPropertyMap>
&nbsp; void counting_sort_copy&nbsp;&nbsp;&nbsp; (RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProjectionPropertyMap project);

&nbsp; template &lt;class RandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class OutputRandomAccessIterator,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ProjectionPropertyMap>
&nbsp; void indirect_counting_sort(RandomAccessIterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RandomAccessIterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputRandomAccessIterator result,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProjectionPropertyMap project);

} // namespace boost</pre>

<h3>
<a NAME="Algorithms"></a>Algorithms</h3>
The basic counting sort algorithm is counting_sort_copy, as explained e.g.
in <a href="http://theory.lcs.mit.edu/~clr/">Introduction to Algorithms
(Cormen Leiserson, Rivest, Stein, 2nd Edition)</a>. The macro BOOST_DECLARE_COUNTING_SORT_TYPE
is used to declare what types should be usable by counting_sort. The default
is as specified above, but the user may add more types (user-defined enums,
short types if desired).
<h3>
<a NAME="Examples"></a>Examples</h3>
The first example illustrates the various ways to sort an sequence of integers:
<pre>&nbsp; using namespace std;
&nbsp; size_t array_size = 1000000; // one million elements</pre>

<pre>&nbsp; // Example with vector of unsigned chars
&nbsp; vector&lt; unsigned char > v(array_size), w(array_size, 0);
&nbsp; generate(v.begin(), v.end(), rand());</pre>

<pre>&nbsp; // Sort vector (needs a temporary buffer, otherwise use std::sort)
&nbsp; copy(v.begin(), v.end(), w.begin());
&nbsp; boost::counting_sort(w.begin(), w.end());</pre>

<pre>&nbsp; // Copy sort vector of integers, should yield same result (but no temporary buffer)
&nbsp; boost::counting_sort_copy(v.begin(), v.end(), w.begin());</pre>
The second example takes a sequence of arrays. We choose to use <tt>boost::array</tt>
instead of the builtin array types because it plays better with some implementations
of <tt>std::sort</tt> (especially the SGI STL):
<pre>&nbsp; // Example with vector of arrays (unsigned char [4])
&nbsp; typedef boost::array&lt;unsigned char,4> array_t;
&nbsp; vector&lt; array_t > va(array_size/4), wa(array_size/4, 0);n
&nbsp; boost::nth_element_property_map&lt;array_t,unsigned char> project(0);</pre>

<pre>&nbsp; // Fill up vector of arrays
&nbsp; for (iterator it = va.begin(); it != va.end(); ++it)
&nbsp;&nbsp;&nbsp; for (unsigned i = 0; i &lt; 4; ++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*it)[i] = (unsigned char) rand();</pre>

<pre>&nbsp; // Sort vector of arrays (will use temporary buffer)
&nbsp; copy(va.begin(), va.end(), wa.begin());
&nbsp; boost::counting_sort(wa.begin(), wa.end(), project);</pre>

<pre>&nbsp; // Copy sort vector of arrays, should yield same result (no temporary buffer)
&nbsp; boost::counting_sort_copy(va.begin(), va.end(), wa.begin(), project);</pre>

<p><br>
<hr>
<table>
<tr VALIGN=TOP>
<td NOWRAP>Copyright &copy; 2002</td>

<td>Herve Bronnimann, Polytechnic University.</td>
</tr>
</table>

</body>
</html>
