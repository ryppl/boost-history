--- array.hpp	Wed Apr 10 03:27:20 2002
+++ array1.hpp	Wed Apr 10 05:15:54 2002
@@ -5,12 +5,15 @@
  *      http://www.josuttis.com/cppcode
  * for details and the latest version.
  *
+ * (C) Copyright Herve Bronnimann 2002.
+ *
  * (C) Copyright Nicolai M. Josuttis 2001.
  * Permission to copy, use, modify, sell and distribute this software
  * is granted provided this copyright notice appears in all copies.
  * This software is provided "as is" without express or implied
  * warranty, and with no claim as to its suitability for any purpose.
  *
+ * 10 Apr 2002 - Aggregate to allocated (Herve Bronnimann)
  * 05 Aug 2001 - minor update (Nico Josuttis)
  * 20 Jan 2001 - STLport fix (Beman Dawes)
  * 29 Sep 2000 - Initial Revision (Nico Josuttis)
@@ -28,7 +31,7 @@
     template<class T, std::size_t N>
     class array {
       public:
-        T elems[N];    // fixed-size array of elements of type T
+        T* elems;    // fixed-size array of elements of type T
 
       public:
         // type definitions
@@ -40,6 +43,13 @@
         typedef std::size_t    size_type;
         typedef std::ptrdiff_t difference_type;
     
+        // constructors and destructor
+	array() : elems( new T[N] ) {}
+	array(T rhs[N]) : elems( new T[N] ) {
+	  std::copy(rhs, rhs+N, begin());
+	}
+	~array() { delete[] elems; }
+
         // iterator support
         iterator begin() { return elems; }
         const_iterator begin() const { return elems; }
@@ -79,15 +89,15 @@
         static size_type max_size() { return N; }
         enum { static_size = N };
 
-        // swap (note: linear complexity)
+        // swap (note: now constant complexity)
         void swap (array<T,N>& y) {
-            std::swap_ranges(begin(),end(),y.begin());
+            std::swap(elems, y.elems);
         }
 
         // direct access to data
         const T* data() const { return elems; }
 
-        // assignment with type conversion
+        // assignments with type conversion
         template <typename T2>
         array<T,N>& operator= (const array<T2,N>& rhs) {
             std::copy(rhs.begin(),rhs.end(), begin());
