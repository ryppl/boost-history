<?xml version = "1.0" encoding = "UTF-8"?>
<!--
(C) Copyright 2003-2004: Reece H. Dunn 
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-->

<section id = "outfmt.evolution"><title>Library Evolution</title>
   <section id = "outfmt.future"><title>Future Directions</title>
      <section id = "outfmt.future-trans"><title>Transformation/Mapping</title>
         <para>
            Sometimes you need to transform elements in a sequence during the
            read and write process. For example, if you are writing to an XML
            file you need to convert certain characters (like mapping &lt; to
            &amp;lt;). This is a generic version of the character escaping/unescaping
            concept.
         </para><para>
            This would allow a simple <code>string_escaper_t</code> type to be
            constructed that converts <code>"</code> to <code>\"</code> and
            <code>\</code> to <code>\\</code>. A std::string object can then be
            formatted using:
         </para>
         <programlisting>   boost::io::containerfmt( boost::io::string_escaper());</programlisting>
         <para>
            You can also use the escaper concept to create <code>xml_escaper_t</code>
            and <code>html_escaper_t</code> classes.
         </para>
      </section><section id = "outfmt.future-str"><title>String Formatting</title>
         <para>
            Provide a class for formatting a generic string type. Given that
            <code>'\0'</code> terminates a string, the <code>boost::io::stringfmt_t</code>
            class will stop output on a null value. It should also use <code>s[ i ]</code>
            because this should be portable with other string types
            (<code>std::string</code>, <code>CString</code>, <code>CBStr</code>,
            <code>QtString</code>, etc.).
         </para>
      </section><section id = "outfmt.future-posctx"><title>Position/Context Information</title>
         <para>
            Add support for context information, including the length of the
            sub-list being outputted and the current position within that
            sub-list. Other context information may be added at a future
            date. How does this interact with <code>boost::io::statefmt_t</code>?
         </para>
      </section><section id = "outfmt.future-data"><title>Dynamic Delimeter Generation</title>
         <para>
            If the delimeter type is allowed to be a function object, more complex formatting
            can be achieved. For example, it would become possible to create a box around a
            2D array dynamically based on the length of the array instead of using a fixed
            string representation. This would require position/contect information to achieve
            it.
         </para><para>
            It is currently possible to use a FormatObject that will do this, but that requires
            more work.
         </para>
      </section>
   </section><section id = "outfmt.issues"><title>Known Issues</title>
      <section id = "outfmt.issues.pair"><title>std::pair</title>
         <para>
            Reading in a <code>std::pair</code> type is currently broken.
         </para>
      </section><section id = "outfmt.issues.string"><title>strings</title>
         <para>
            Reading in a string that contains spaces will no longer work, since I have
            removed escaping of <code>std::string</code> types. This should be supported
            once generic transformation is supported.
         </para>
      </section><section id = "outfmt.issues.typededuction"><title>Type Deduction</title>
         <para>
            Type deduction is currently broken on older compilers (MS VC 6.5 and
            GCC 2.95). This means that several of the examples will not compile
            on them, since I now assume that type deduction is supported.
         </para>
      </section>
   </section><section id = "outfmt.portability"><title>Portability</title>
      <para>
         The code has been succesfully tested on:
         <orderedlist>
            <listitem>
               MS VC 7.0 and 7.1
               <emphasis role = "bold">[Note:</emphasis>
                  C-style arrays are only supported within type deduction for MS VC 7.1,
                  they do not work on VC 7.0.
               <emphasis role = "bold">]</emphasis>
            </listitem>
            <listitem>Borland C++Compiler 5.5.1 and 5.6.4</listitem>
            <listitem>GNU G++ 3.x (under the i686-pc-cygwin environment)</listitem>
            <listitem>
               GNU G++ 2.95.3-5 (under the i686-pc-cygwin environment)
               <emphasis role = "bold">[Note:</emphasis>
                  Type deduction does not work, but the rest of the library does.
               <emphasis role = "bold">]</emphasis>
            </listitem>
            <listitem>Intel 7.1</listitem>
            <listitem>Como 4.3.3</listitem>
         </orderedlist>
      </para><para>
         <emphasis role = "bold">[Note:</emphasis>
            The library is currently broken on the MS VC 6 compiler.
         <emphasis role = "bold">]</emphasis>
      </para>
   </section><section id = "outfmt.ack"><title>Acknowledgements</title>
      <para>This library was designed and implemented by Reece H. Dunn.</para>
      <para>
         The output functors were based on a comment in the "IO for STL containers"
         thread on the boost developers mailing list.
      </para><para>
         Jonathan Turkanis has provided a reworked version of the format object/type
         deduction mechanism that does not rely on partial specialization as well as
         porting to various compilers.
      </para><para>
         Special thanks to:
         <orderedlist>
            <listitem>Martin Henson:
               For giving me a reason to create the library in the first place!
            </listitem><listitem>Boost Developers:
               For their feedback and support during the development of the library,
               specifically: Paul A. Bristow; Terje Sletteb&#xF8;; Gennadiy Rozental;
               John Torjo; Jonathan Turkanis; and Pavel Vozenilek.
            </listitem>
         </orderedlist>
      </para>
   </section>
</section>
