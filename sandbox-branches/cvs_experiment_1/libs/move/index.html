<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Boost.Move Library</title>
<meta content="Eric Friedman, mailto:ebf@users.sourceforge.net" name="author">
</head>

<body text="#000000" bgColor="#ffffff">

<h1>
	<img height="86" src="../../c++boost.gif" width="277" align="center" border="0">
	Boost.Move Library
</h1>
<h2>Overview</h2>
<ul>
  <li><a href="#motivation">Motivation</a></li>
  <li><a href="#examples">Examples</a></li>
  <li><a href="#MoveableType"><i>MoveableType </i>requirements</a></li>
  <li>Header <code>&quot;boost/move.hpp&quot;</code></li><ul>
	<li><a href="move.html#synopsis">Synopsis</a></li>
	<li><code><a href="move.html#move">move</a></code></li>
	<li><code><a href="move.html#move_traits">move_traits</a></code></li>
	<li><code><a href="move.html#is_moveable">is_moveable</a></code></li>
  </ul>
  <li>Header <code>&quot;boost/auto_mover.hpp&quot;</code></li><ul>
  	<li><a href="auto_mover.html#synopsis">Synopsis</a></li>
	<li><code><a href="auto_mover.html#auto_mover">auto_mover</a></code></li>
  </ul>
  <li><a href="#portability">Portability</a></li>
  <li>Credits<ul>
      <li><a href="#acknowledgments">Acknowledgments</a></li>
      <li><a href="#bibliography">Bibliography</a></li>
    </ul>
  </li>
  </ul>
<hr>
<h2><a name="motivation">Motivation</a></h2>
<p>Given a source object and destination storage, there are two kinds of 
relocation operations: <i>copy</i> and <i>move</i>. The <i>copy</i> operation is well known to every C++ programmer; indeed, C++ 
features explicit language support for the operation in the form of copy 
constructors. On the other hand, the <i>move </i>operation is less common in C++; often a 
C++ programmer's only 
experience with the move operation is from the <code>auto_ptr</code> class template 
in the Standard Library, whose &quot;copy&quot; constructors' behavior is relatively unusual. The 
behavior of <code>auto_ptr</code>'s constructors is well documented [??], however 
(as it often results in 
confusion for new C++ programmers), and is most commonly known as &quot;destructive 
copy.&quot;</p>
<p>Now let's define the two operations more precisely.</p>
<p><i>Copying</i> results in the construction of an object in the 
destination storage that is equivalent to the source object. As well, copying 
does not alter the source object's logical state in any way, which is why 
the argument to copy constructors is declared <code>const</code>.</p>
<p><i>Moving</i>, like copying, results in the construction of an object in the 
destination storage that is equivalent to the source object. In this regard, 
moving is a subset of copying. Unlike copying, however, a move 1) satisfies the 
no-throw guarantee of <a href="../../more/generic_exception_safety.html">exception-safety</a> 
and 2) results in a 
source object whose only generally guaranteed capabilities are destruction and, 
if supported by the object's type, assignment. Thus, since the source object's 
logical state is not generally guaranteed to remain unchanged through a move 
operation, the argument to a move operation may not be declared <code>const</code>.</p>
<p>Why, then, is the move operation important? If the functional behavior of the move 
operation is a subset of the copy operation's behavior, why not simply always 
use the copy operation, which, moreover, does not require non-<code>const</code> source 
objects?</p>
<p>The answer lies in two parts: safety and efficiency.</p>
<p>The move operation is often essential when writing code satisfying the no-throw guarantee of 
exception-safety (and even lesser guarantees, such as the Abraham's strong 
guarantee). 
For objects with dynamically-allocated contents, copying cannot satisfy the 
no-throw guarantee because it relies on the dynamic allocation of the 
destination storage, and dynamic allocation of memory does not satisfy the 
no-throw guarantee. On the other hand, since the move operation is not required to maintain the 
logical state of the source object, its implementation for such objects 
is straightforward; indeed, <code>auto_ptr</code> exhibits this very behavior, 
simply copying the <i>pointer</i> to its dynamically-allocated content rather 
than the content itself.</p>
<p>The move operation is also useful in guaranteeing efficiency. Copy operations 
are often used when move operations would work equally well -- and perhaps more 
efficiently. Moving an object is often more efficient (and otherwise <i>no less 
efficient</i>) than copying for the same reason that makes it safer: 
dynamically-allocated content can often be moved by simply copying its pointer, 
whereas <i>copying </i>the content requires both new storage allocation as well 
as a copy of the content's data -- a vastly more complex operation.</p>
<p>Additionally, the move operation is useful in allowing the 
relocation of statically-allocated objects whose types otherwise do not 
logically support the copy operation; common examples of such types are a 
variety of system-level classes such as threads, files, and sockets. Also, the 
ability to guarantee the success of an object's relocation in memory 
is important in the implementation of some efficient garbage collectors [<a href="#bib-sut02">Sut02</a>].</p>
<p>The <b>Boost.Move</b> library provides solutions to address the problems described 
above:</p>
<ul>
  <li>The <code><a href="move.html#move">move</a></code> function template provides a common semantic form 
  for the expression of non-throwing relocation of objects in memory, an 
  implementation of the &quot;move operation&quot; as described above.</li>
  <li>Specializations 
of the 
<code><a href="move.html#move_traits">move_traits</a></code> class template perform the actual relocation, for which 
the library provides <a href="move.html#move_traits-default">built-in support</a> for common types 
-- such as for POD types and for those standard library classes 
whose default construction and swap operations provide a no-throw guarantee of 
exception safety (e.g., <code>std::basic_string</code>, <code>std::vector</code>, <code>std::map</code>, etc.).</li>
  <li>The <code><a href="move.html#is_moveable">is_moveable</a></code> traits template, without any specialization, provides a compile time
determination as to whether the <code>move</code> function template may be invocated given 
a source object of
the specified type.</li>
  <li>The <code><a href="auto_mover.html#auto_mover">auto_mover</a></code> class template simplifies the movement of objects to 
  statically-allocated storage by encapsulating alignment issues behind an 
  <code>auto_ptr</code>-like interface.</li>
</ul>
<hr>
<h2><a name="examples">Examples</a></h2>
<p>[TODO]</p>
<hr>
<h2><a name="MoveableType"><i>MoveableType</i> requirements</a></h2>
<p>The requirements on types <code>T</code> to be used in an expression of the  form (given an object <code>x</code> of type <code>T</code> and a pointer <code>p</code>)</p>
<blockquote><pre><a href="move.html#move">move</a>(p,x);</pre></blockquote>
are as follows:<ul>
  <li>A <i>MoveableType</i> must defined as such that the following expression is 
  valid:
  <blockquote><pre><a href="move.html#move_traits">move_traits</a>&lt;T&gt;::move(p,x);</pre></blockquote>
  The preceding requirement may be satisfied either by:<ol>
    <li>Explicit user specialization of the <code>move_traits</code> class template for <code>T</code>;
  or</li>
    <li>The default library implementation in the cases enumerated in the <code><a href="move.html#move_traits-default">move_traits</code> documentation</a>.</li>
  </ol>
  </li>
</ul>
<hr>
<h2><a name="header-move">Header <code>&quot;boost/move.hpp&quot;</code></a></h2>
<p>See <code>&quot;<a href="move.html">boost/move.hpp</a>&quot;</code> documentation.</p>
<hr>
<h2><a name="header-auto_mover">Header <code>&quot;boost/auto_mover.hpp&quot;</code></a></h2>
<p>See <code>&quot;<a href="auto_mover.html">boost/auto_mover.hpp</a>&quot;</code> documentation.</p>
<hr>
<h2><a name="portability">Portability</a></h2>
<p>To date the code and test harnesses have been compiled and tested successfully 
using Microsoft Visual C++ 7.0 and GNU g++ 3.2. </p>
<hr>
<h2>Credits</h2>
<h3><a name="acknowledgments">Acknowledgments</a></h3>
<p>Eric Friedman designed and implemented the initial submission.</p>
<h3><a name="bibliography">Bibliography</a></h3>
<p><a name="bib-abr??">[Abr??]</a> David Abrahams. 
&quot;Exception-Safety in Generic Components: Lessons Learned from Specifying 
Exception-Safety for the C++ Standard Library," Boost.org. ????. See <a href="http://www.boost.org/more/generic_exception_safety.html">&lt;http://www.boost.org/more/generic_exception_safety.html&gt;</a>.</p>
<p><a name="bib-sut02">[Sut02]</a> Herb Sutter. &quot;Standard C++ Meets Managed C++,&quot; C/C++ Users Journal. 
September 2002. Available at <a href="http://www.cuj.com/articles/2002/0209/0209i/0209i.htm?topic=cnet">&lt;http://www.cuj.com/articles/2002/0209/0209i/0209i.htm?topic=cnet&gt;</a>.</p>
<hr>
<div align="right">
  <small><i>© Copyright Eric Friedman, 2002</i></small></div>

</body>

</html>