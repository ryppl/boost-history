<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<title>Boost.Move Library : Header &quot;boost/auto_mover.hpp&quot;</title>
<meta content="Eric Friedman, mailto:ebf@users.sourceforge.net" name="author">
</head>

<body text="#000000" bgColor="#ffffff">

<h1>
	<img height="86" src="../../c++boost.gif" width="277" align="center" border="0">
	<a href="index.html">Boost.Move Library</a></h1>
<h2>Header "<a href="../../boost/auto_mover.hpp">boost/auto_mover.hpp</a>"</h2>
<ul>
	<li><a href="#synopsis">Synopsis</a></li>
	<li><code><a href="#auto_mover">auto_mover</a></code></li>
</ul>
<hr>
<h2><a name="synopsis">Synopsis</a></h2>
<p>Dependencies and library features defined in <code>&quot;<a href="../../boost/auto_mover.hpp">boost/auto_mover.hpp</a>&quot;</code>: </p>
  <blockquote><pre>namespace boost
{
    template &lt;typename T&gt;
      class <a href="#auto_mover">auto_mover</a>;
}
</pre></blockquote>
<p>Test harness defined in <code>&quot;<a href="auto_mover_test.cpp">auto_mover_test.cpp</a>&quot;</code>.</p>
<hr>
<h2><code><a name="auto_mover">auto_mover</a></code></h2>
<blockquote>
  <pre>template &lt;typename T&gt;
class auto_mover
{
public: // <i><a href="#structors">structors</a></i>

    explicit <a href="#value-ctor">auto_mover</a>(T &amp;);
    <a href="#move-ctor">auto_mover</a>(auto_mover &amp;);
    <a href="#dtor">~auto_mover</a>();

public: // <i><a href="#modifiers">modifiers</a></i>

    auto_mover &amp; <a href="#swap">swap</a>(auto_mover &amp;);
    auto_mover &amp; <a href="#move-assign">operator=</a>(auto_mover &amp;);
    void <a href="#reset">reset</a>(T &amp; operand);

public: // <i><a href="#queries">queries</a></i>

    T &amp; <a href="#deref">operator*</a>();
    const T &amp; <a href="deref">operator*</a>() const;
    T * <a href="#arrow">operator-&gt;</a>();
    const T * <a href="#arrow">operator-&gt;</a>() const;
    T &amp; <a href="#get">get</a>();
    const T &amp; <a href="#get">get</a>() const;

private:

    struct auto_mover_ref;

public: // <i><a href="#conversions">conversions</a></i>

    <a href="#convert">auto_mover</a>(auto_mover_ref);
    <a href="#convert">operator auto_mover_ref</a>();

private: // <i>representation</i>
    ...
};</pre>
</blockquote>
<p>The <code>auto_mover</code> class template simplifies the movement of objects to 
  statically-allocated storage by encapsulating alignment issues behind an 
  <code>auto_ptr</code>-like interface.</p>
<p>An instance of <code>auto_mover</code> contains exactly one 
instance of  its parameterized type.</p>
<p>Any type provided as the parameterized type
to <code>auto_mover</code> must satisfy the <cite><a href="index.html#MoveableType">MoveableType</a></cite>
requirements. Note that&nbsp;<code>auto_mover</code> itself satisfies
<cite><a href="index.html#MoveableType">MoveableType</a></cite> requirements.</p>
<p>All members of <code>auto_mover</code> satisfy the no-throw guarantee of 
exception-safety.</p>
<p></p>
<blockquote>
  <hr>
  <h3><a name="structors">Structors</a></h3>
  <blockquote>
    <pre><a name="value-ctor">auto_mover(T &amp; value);</a></pre>
  </blockquote>
  <p>Moves <code>value</code> into new instance.</p>
  <blockquote>
    <pre><a name="move-ctor">auto_mover(auto_mover &amp; other);</a></pre>
  </blockquote>
  <p>Moves content of <code>other</code> into new 
  instance.</p>
  <blockquote>
    <pre><a name="dtor">~auto_mover();</a></pre>
  </blockquote>
  <p>Releases all resources used in management of 
  instance. </p>
  <p></p>
  <hr>
  <h3><a name="modifiers">Modifiers</a></h3>
  <blockquote>
    <pre><a name="swap">auto_mover &amp; swap(auto_mover &amp; rhs);</a></pre>
  </blockquote>
  <p>Exchanges contents of instance&nbsp;and <code>rhs</code>.</p>
  <blockquote>
    <pre><a name="move-assign">auto_mover &amp; operator=(auto_mover &amp; rhs);</a>
<a name="reset">void reset(auto_mover &amp; rhs);</a></pre>
  </blockquote>
  <p>Moves content of <code>rhs</code> into instance,&nbsp;destroying&nbsp;previous 
  content.</p>
  <hr>
  <h3><a name="queries">Queries</a></h3>
  <blockquote>
    <pre><a name="deref">T &amp; operator*();
const T &amp; operator*() const;</a></pre>
  </blockquote>
  <p>Dereference operator returns reference to content.</p>  
  <blockquote>
    <pre><a name="arrow">T * operator->();
const T * operator->() const;</a></pre>
  </blockquote>
  <p>Arrow operator returns pointer to content for access to members.</p>  
  <blockquote>
    <pre><a name="get">T &amp; get();
const T &amp; get() const;</a></pre>
  </blockquote>
  <p>Returns reference to content.</p>  <hr>
  <h3><a name="conversions">Conversions</a></h3>
  <blockquote>
    <pre><a name="convert">auto_mover(auto_mover_ref);
operator auto_mover_ref();</a></pre>
  </blockquote>
  <p>Implicit conversion from-to implementation-defined <code>auto_mover_ref</code> type 
  facilitates return of <code>auto_mover</code> from functions.</p>  
  <p>(Note: This behavior 
  mirrors that of <code>auto_ptr</code>; see &lt;<a href="http://www.josuttis.com/libbook/auto_ptr.html">http://www.josuttis.com/libbook/auto_ptr.html</a>&gt; 
  for more information.)</p>  
</blockquote>
<hr>
<div align="right">
  <small><i>© Copyright Eric Friedman, 2002</i></small>
  <p><a href="index.html">Back to library index</a></p>
</div>

</body>

</html>