<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Generic Geometry Library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body style="background-image: url(images/draft.png);">

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="GGL" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<img alt="Boost C++ Libraries" src="images/proposed_boost.png" height="86" width="277">
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>overlay operations (intersection, union, clipping)</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structggl_1_1de9im.html">ggl::de9im</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dimensionally Extended 9 Intersection Matrix.  <a href="structggl_1_1de9im.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classggl_1_1strategy_1_1intersection_1_1liang__barsky.html">ggl::strategy::intersection::liang_barsky&lt; B, P &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Strategy: line clipping algorithm after Liang Barsky.  <a href="classggl_1_1strategy_1_1intersection_1_1liang__barsky.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Geometry , typename SegmentIdentifier , typename RangeOut &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__overlay.html#g72698a9e6c8319f77d1481537096c890">ggl::copy_segments</a> (Geometry const &amp;geometry, SegmentIdentifier const &amp;seg_id, int to_index, RangeOut &amp;range_out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverses through intersection points / geometries.  <a href="#g72698a9e6c8319f77d1481537096c890"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename IntersectionPoints &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__overlay.html#g379db9c2e9741b685302a21f86ea24f3">ggl::enrich_intersection_points</a> (IntersectionPoints &amp;intersection_points, bool trivial)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All intersection points are enriched with successor information.  <a href="#g379db9c2e9741b685302a21f86ea24f3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Geometry , typename IntersectionPoints &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__overlay.html#g402420dc15139d3893450978f30920b9">ggl::get_intersection_points</a> (Geometry const &amp;geometry, IntersectionPoints &amp;intersection_points)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate self intersections of a geometry.  <a href="#g402420dc15139d3893450978f30920b9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Geometry1 , typename Geometry2 , typename IntersectionPoints &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__overlay.html#g9b41efeface4cb10fbce39c8bcc8bec9">ggl::get_intersection_points</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, IntersectionPoints &amp;intersection_points)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate intersection points of two geometries.  <a href="#g9b41efeface4cb10fbce39c8bcc8bec9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename GeometryOut , typename Geometry1 , typename Geometry2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__overlay.html#g60644b53b334602956f0722e9dfb69b5">ggl::intersection</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, OutputIterator out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intersects two geometries which each other.  <a href="#g60644b53b334602956f0722e9dfb69b5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__overlay.html#g5e7b5d7c8e010077237751f3a6b289ec">ggl::intersects</a> (Geometry const &amp;geometry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if there is at least one intersection (crossing or self-tangency).  <a href="#g5e7b5d7c8e010077237751f3a6b289ec"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename IntersectionPoints &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__overlay.html#gc1dcd7471f802810f7d48b36eea24d0f">ggl::merge_intersection_points</a> (IntersectionPoints &amp;intersection_points)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merges intersection points such that points at the same location will be merged, having one <a class="el" href="classggl_1_1point.html" title="Basic point class, having coordinates defined in a neutral way.">point</a> and their info-records appended.  <a href="#gc1dcd7471f802810f7d48b36eea24d0f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename GeometryOut , typename Geometry1 , typename Geometry2 , typename IntersectionPoints , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__overlay.html#g05c8da6bfcd1aa911c5520ac991fdc0d">ggl::traverse</a> (Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, int direction, IntersectionPoints &amp;intersection_points, bool trivial, OutputIterator out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverses through intersection points / geometries.  <a href="#g05c8da6bfcd1aa911c5520ac991fdc0d"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The intersection of two geometries A and B is the geometry containing all points of A also belonging to B, but no other elements. The so-called clip is an intersection of a geometry with a box. <dl class="user" compact><dt><b>Source description:</b></dt><dd><ul>
<li>OGC: Returns a geometric object that represents the Point set intersection of this geometric object with another Geometry. </li></ul>
</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://en.wikipedia.org/wiki/Intersection_(set_theory)">http://en.wikipedia.org/wiki/Intersection_(set_theory)</a> </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Any intersection can result in no geometry at all<p>
Used strategies still have to be modelled. Working only for cartesian </dd></dl>
<dl class="user" compact><dt><b>Geometries:</b></dt><dd>The intersection result is painted with a red outline.<ul>
<li>clip: POLYGON + BOX -&gt; output iterator of polygons <div align="center">
<img src="clip_polygon.png" alt="clip_polygon.png">
</div>
</li><li>clip: LINESTRING + BOX -&gt; output iterator of linestrings <div align="center">
<img src="clip_linestring.png" alt="clip_linestring.png">
</div>
 </li></ul>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>There are some difficulties to model an intersection in the template world. The intersection of two segments can result into nothing, into a point, into another segment. At compiletime the result type is not known. An output iterator iterating points is appropriate here. <div align="center">
<img src="clip_segment_segment.png" alt="clip_segment_segment.png">
</div>
 An intersection of two linestrings can result into nothing, one or more points, one or more segments or one or more linestrings. So an output iterator will NOT do here. So the output might be changed into a unified algorithm where the output is a multi-geometry. For the current clip-only operations the output iterator will do.</dd></dl>
<dl class="user" compact><dt><b>Example:</b></dt><dd>Example showing clipping of linestring with box  <div class="fragment"><pre class="fragment">{
    <span class="keyword">typedef</span> <a class="code" href="classggl_1_1point__xy.html" title="2D point in Cartesian coordinate system">ggl::point_xy&lt;double&gt;</a> P;
    <a class="code" href="classggl_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">ggl::linestring&lt;P&gt;</a> line;
    ggl::read_wkt(<span class="stringliteral">"linestring(1.1 1.1, 2.5 2.1, 3.1 3.1, 4.9 1.1, 3.1 1.9)"</span>, line);
    <a class="code" href="classggl_1_1box.html" title="Class box: defines a box made of two describing points.">ggl::box&lt;P&gt;</a> cb(P(1.5, 1.5), P(4.5, 2.5));
    std::cout &lt;&lt; <span class="stringliteral">"Clipped linestring(s) "</span> &lt;&lt; std::endl;
    <span class="comment">/*</span>
<span class="comment">    TODO: does not work because streamwkt is now extension and not included</span>
<span class="comment">        so make other construct</span>
<span class="comment">    ggl::intersection&lt;ggl::linestring&lt;P&gt; &gt; (cb, line,</span>
<span class="comment">            std::ostream_iterator&lt;ggl::linestring&lt;P&gt; &gt;(std::cout, "\n"));</span>
<span class="comment">    */</span>
}
</pre></div> </dd></dl>
<dl class="user" compact><dt><b>Example:</b></dt><dd>Example showing clipping of vector, outputting vectors, with box  <div class="fragment"><pre class="fragment">{
    <span class="keyword">typedef</span> <a class="code" href="classggl_1_1point__xy.html" title="2D point in Cartesian coordinate system">ggl::point_xy&lt;double&gt;</a> P;
    std::vector&lt;P&gt; vector_in;
    ggl::read_wkt&lt;P&gt;(<span class="stringliteral">"linestring(1.1 1.1, 2.5 2.1, 3.1 3.1, 4.9 1.1, 3.1 1.9)"</span>,
                    std::back_inserter(vector_in));

    <a class="code" href="classggl_1_1box.html" title="Class box: defines a box made of two describing points.">ggl::box&lt;P&gt;</a> cb(P(1.5, 1.5), P(4.5, 2.5));
    <span class="keyword">typedef</span> std::vector&lt;std::vector&lt;P&gt; &gt; VV;
    VV vector_out;
    ggl::intersection&lt;std::vector&lt;P&gt;  &gt;(cb, vector_in, std::back_inserter(vector_out));

    std::cout &lt;&lt; <span class="stringliteral">"Clipped vector(s) "</span> &lt;&lt; std::endl;
    <span class="keywordflow">for</span> (VV::const_iterator it = vector_out.begin(); it != vector_out.end(); it++)
    {
        std::copy(it-&gt;begin(), it-&gt;end(), std::ostream_iterator&lt;P&gt;(std::cout, <span class="stringliteral">" "</span>));
        std::cout &lt;&lt; std::endl;
    }
</pre></div> </dd></dl>
<dl class="user" compact><dt><b>Example:</b></dt><dd>Example showing clipping of polygon with box  <div class="fragment"><pre class="fragment">{
    <span class="keyword">typedef</span> <a class="code" href="classggl_1_1point__xy.html" title="2D point in Cartesian coordinate system">ggl::point_xy&lt;double&gt;</a> P;
    <span class="keyword">typedef</span> std::vector&lt;ggl::polygon&lt;P&gt; &gt; PV;

    <a class="code" href="classggl_1_1box.html" title="Class box: defines a box made of two describing points.">ggl::box&lt;P&gt;</a> cb(P(1.5, 1.5), P(4.5, 2.5));
    <a class="code" href="classggl_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">ggl::polygon&lt;P&gt;</a> poly;
    ggl::read_wkt(<span class="stringliteral">"POLYGON((2 1.3,2.4 1.7,2.8 1.8,3.4 1.2,3.7 1.6,3.4 2,4.1 3,5.3 2.6,5.4 1.2,4.9 0.8,2.9 0.7,2 1.3)"</span>
            <span class="stringliteral">",(4 2,4.2 1.4,4.8 1.9,4.4 2.2,4 2))"</span>, poly);

    PV v;
    ggl::intersection&lt;ggl::polygon&lt;P&gt; &gt;(cb, poly, std::back_inserter(v));

    std::cout &lt;&lt; <span class="stringliteral">"Clipped polygon(s) "</span> &lt;&lt; std::endl;
    <span class="keywordflow">for</span> (PV::const_iterator it = v.begin(); it != v.end(); it++)
    {
        std::cout &lt;&lt; <a class="code" href="namespaceggl.html#3399b7516122f515a1ea5ee5fdf49ce4" title="Main DSV-streaming function.">ggl::dsv</a>(*it) &lt;&lt; std::endl;
    }
</pre></div> </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g60644b53b334602956f0722e9dfb69b5"></a><!-- doxytag: member="ggl::intersection" ref="g60644b53b334602956f0722e9dfb69b5" args="(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, OutputIterator out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryOut , typename Geometry1 , typename Geometry2 , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator ggl::intersection           </td>
          <td>(</td>
          <td class="paramtype">Geometry1 const &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry2 const &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Intersects two geometries which each other. 
<p>
A sequence of points is intersected (clipped) by the specified <a class="el" href="classggl_1_1box.html" title="Class box: defines a box made of two describing points.">box</a> and the resulting <a class="el" href="classggl_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">linestring</a>, or pieces of linestrings, are sent to the specified output operator. <dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>GeometryOut</em>&nbsp;</td><td>output geometry type, must be specified </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Geometry1</em>&nbsp;</td><td>first geometry type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Geometry2</em>&nbsp;</td><td>second geometry type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputIterator</em>&nbsp;</td><td>output iterator </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geometry1</em>&nbsp;</td><td>first geometry (currently only a BOX) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometry2</em>&nbsp;</td><td>second geometry (range, <a class="el" href="classggl_1_1linestring.html" title="A linestring (named so by OGC) is a collection (default a vector) of points.">linestring</a>, <a class="el" href="classggl_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>the output iterator, outputting linestrings or polygons </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the output iterator </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For linestrings: the default clipping <a class="el" href="namespaceggl_1_1strategy.html">strategy</a>, Liang-Barsky, is used. The algorithm is currently only implemented for 2D xy points. It could be generic for most ll cases, but not across the 180 meridian so that issue is still on the todo-list. </dd></dl>

<p>Definition at line <a class="el" href="algorithms_2intersection_8hpp_source.html#l00424">424</a> of file <a class="el" href="algorithms_2intersection_8hpp_source.html">intersection.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5e7b5d7c8e010077237751f3a6b289ec"></a><!-- doxytag: member="ggl::intersects" ref="g5e7b5d7c8e010077237751f3a6b289ec" args="(Geometry const &amp;geometry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ggl::intersects           </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if there is at least one intersection (crossing or self-tangency). 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function can be called for one geometry (self-intersection) and also for two geometries (intersection)</dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Geometry</em>&nbsp;</td><td>geometry type </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geometry</em>&nbsp;</td><td>geometry </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if there are intersections, else FALSE </dd></dl>

<p>Definition at line <a class="el" href="intersects_8hpp_source.html#l00040">40</a> of file <a class="el" href="intersects_8hpp_source.html">intersects.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g72698a9e6c8319f77d1481537096c890"></a><!-- doxytag: member="ggl::copy_segments" ref="g72698a9e6c8319f77d1481537096c890" args="(Geometry const &amp;geometry, SegmentIdentifier const &amp;seg_id, int to_index, RangeOut &amp;range_out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , typename SegmentIdentifier , typename RangeOut &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ggl::copy_segments           </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentIdentifier const &amp;&nbsp;</td>
          <td class="paramname"> <em>seg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>to_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeOut &amp;&nbsp;</td>
          <td class="paramname"> <em>range_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Traverses through intersection points / geometries. 
<p>

<p>Definition at line <a class="el" href="copy__segments_8hpp_source.html#l00195">195</a> of file <a class="el" href="copy__segments_8hpp_source.html">copy_segments.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g379db9c2e9741b685302a21f86ea24f3"></a><!-- doxytag: member="ggl::enrich_intersection_points" ref="g379db9c2e9741b685302a21f86ea24f3" args="(IntersectionPoints &amp;intersection_points, bool trivial)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntersectionPoints &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ggl::enrich_intersection_points           </td>
          <td>(</td>
          <td class="paramtype">IntersectionPoints &amp;&nbsp;</td>
          <td class="paramname"> <em>intersection_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>trivial</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
All intersection points are enriched with successor information. 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IntersectionPoints</em>&nbsp;</td><td>type of intersection container (e.g. vector of "intersection_point"'s) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intersection_points</em>&nbsp;</td><td>container containing intersectionpoints </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trivial</em>&nbsp;</td><td>Boolean flag to indicate that it is trivial, only intersections, no touch, collinearities, etc. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="enrich__intersection__points_8hpp_source.html#l00464">464</a> of file <a class="el" href="enrich__intersection__points_8hpp_source.html">enrich_intersection_points.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9b41efeface4cb10fbce39c8bcc8bec9"></a><!-- doxytag: member="ggl::get_intersection_points" ref="g9b41efeface4cb10fbce39c8bcc8bec9" args="(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, IntersectionPoints &amp;intersection_points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry1 , typename Geometry2 , typename IntersectionPoints &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ggl::get_intersection_points           </td>
          <td>(</td>
          <td class="paramtype">Geometry1 const &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry2 const &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntersectionPoints &amp;&nbsp;</td>
          <td class="paramname"> <em>intersection_points</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate intersection points of two geometries. 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Geometry1</em>&nbsp;</td><td>first geometry type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Geometry2</em>&nbsp;</td><td>second geometry type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IntersectionPoints</em>&nbsp;</td><td>type of intersection container (e.g. vector of "intersection_point"'s) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geometry1</em>&nbsp;</td><td>first geometry </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometry2</em>&nbsp;</td><td>second geometry </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>intersection_points</em>&nbsp;</td><td>container which will contain intersection points </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if it is trivial, else FALSE </dd></dl>

<p>Definition at line <a class="el" href="get__intersection__points_8hpp_source.html#l00682">682</a> of file <a class="el" href="get__intersection__points_8hpp_source.html">get_intersection_points.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc1dcd7471f802810f7d48b36eea24d0f"></a><!-- doxytag: member="ggl::merge_intersection_points" ref="gc1dcd7471f802810f7d48b36eea24d0f" args="(IntersectionPoints &amp;intersection_points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntersectionPoints &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ggl::merge_intersection_points           </td>
          <td>(</td>
          <td class="paramtype">IntersectionPoints &amp;&nbsp;</td>
          <td class="paramname"> <em>intersection_points</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges intersection points such that points at the same location will be merged, having one <a class="el" href="classggl_1_1point.html" title="Basic point class, having coordinates defined in a neutral way.">point</a> and their info-records appended. 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IntersectionPoints</em>&nbsp;</td><td>type of intersection container (e.g. vector of "intersection_point"'s) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intersection_points</em>&nbsp;</td><td>container containing intersectionpoints </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="merge__intersection__points_8hpp_source.html#l00170">170</a> of file <a class="el" href="merge__intersection__points_8hpp_source.html">merge_intersection_points.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g402420dc15139d3893450978f30920b9"></a><!-- doxytag: member="ggl::get_intersection_points" ref="g402420dc15139d3893450978f30920b9" args="(Geometry const &amp;geometry, IntersectionPoints &amp;intersection_points)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry , typename IntersectionPoints &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ggl::get_intersection_points           </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntersectionPoints &amp;&nbsp;</td>
          <td class="paramname"> <em>intersection_points</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate self intersections of a geometry. 
<p>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Geometry</em>&nbsp;</td><td>geometry type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IntersectionPoints</em>&nbsp;</td><td>type of intersection container (e.g. vector of "intersection_point"'s) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>geometry</em>&nbsp;</td><td>geometry </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>intersection_points</em>&nbsp;</td><td>container which will contain intersection points </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>TRUE if it is trivial, else FALSE </dd></dl>

<p>Definition at line <a class="el" href="self__intersection__points_8hpp_source.html#l00149">149</a> of file <a class="el" href="self__intersection__points_8hpp_source.html">self_intersection_points.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g05c8da6bfcd1aa911c5520ac991fdc0d"></a><!-- doxytag: member="ggl::traverse" ref="g05c8da6bfcd1aa911c5520ac991fdc0d" args="(Geometry1 const &amp;geometry1, Geometry2 const &amp;geometry2, int direction, IntersectionPoints &amp;intersection_points, bool trivial, OutputIterator out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryOut , typename Geometry1 , typename Geometry2 , typename IntersectionPoints , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ggl::traverse           </td>
          <td>(</td>
          <td class="paramtype">Geometry1 const &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Geometry2 const &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntersectionPoints &amp;&nbsp;</td>
          <td class="paramname"> <em>intersection_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>trivial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Traverses through intersection points / geometries. 
<p>

<p>Definition at line <a class="el" href="traverse_8hpp_source.html#l00302">302</a> of file <a class="el" href="traverse_8hpp_source.html">traverse.hpp</a>.</p>

</div>
</div><p>
</div>
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>October 13, 2009</p>
</small></td>
<td align="right">
<small>Copyright © 1995-2009 Barend Gehrels, Geodan, Amsterdam<br>
Copyright © 2008-2009 Bruno Lalande, Paris<br>
Copyright © 2009 Mateusz Loskot, Cadcorp, London<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
