<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Generic Geometry Library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body style="background-image: url(images/draft.png);">

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="GGL" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<img alt="Boost C++ Libraries" src="images/proposed_boost.png" height="86" width="277">
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>03_polygon_example.cpp</h1>The polygon example shows some examples of what can be done with polygons in the Generic Geometry Library: the outer ring and the inner rings how to calculate the area of a polygon how to get the centroid, and how to get an often more interesting label point how to correct the polygon such that it is clockwise and closed within: the well-known point in polygon algorithm how to use polygons which use another container, or which use different containers for points and for inner rings how polygons can be intersected, or clipped, using a clipping box<p>
The illustrations below show the usage of the within algorithm and the intersection algorithm.<p>
The within algorithm results in true if a point lies completly within a polygon. If it lies exactly on a border it is not considered as within and if it is inside a hole it is also not within the polygon. This is illustrated below, where only the point in the middle is within the polygon.<p>
<div align="center">
<img src="within_polygon.png" alt="within_polygon.png">
</div>
<p>
The clipping algorithm, called intersection, is illustrated below:<p>
<div align="center">
<img src="clip_polygon.png" alt="clip_polygon.png">
</div>
<p>
The yellow polygon, containing a hole, is clipped with the blue rectangle, resulting in a multi_polygon of three polygons, drawn in red. The hole is vanished.<p>
include polygon_example.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Generic Geometry Library</span>
<span class="comment">//</span>
<span class="comment">// Copyright Barend Gehrels 1995-2009, Geodan Holding B.V. Amsterdam, the Netherlands.</span>
<span class="comment">// Copyright Bruno Lalande 2008, 2009</span>
<span class="comment">// Use, modification and distribution is subject to the Boost Software License,</span>
<span class="comment">// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="comment">// http://www.boost.org/LICENSE_1_0.txt)</span>
<span class="comment">//</span>
<span class="comment">// Polygon Example</span>

<span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// for reverse, unique</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>

<span class="preprocessor">#include &lt;ggl/ggl.hpp&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="cartesian2d_8hpp.html">ggl/geometries/cartesian2d.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="c__array__cartesian_8hpp.html">ggl/geometries/adapted/c_array_cartesian.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="std__as__linestring_8hpp.html">ggl/geometries/adapted/std_as_linestring.hpp</a>&gt;</span>

std::string boolstr(<span class="keywordtype">bool</span> v)
{
    <span class="keywordflow">return</span> v ? <span class="stringliteral">"true"</span> : <span class="stringliteral">"false"</span>;
}

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
    <span class="keyword">using namespace </span>ggl;

    <span class="comment">// Define a polygon and fill the outer ring.</span>
    <span class="comment">// In most cases you will read it from a file or database</span>
    <a name="_a0"></a><a class="code" href="classggl_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon_2d</a> poly;
    {
        <span class="keyword">const</span> <span class="keywordtype">double</span> coor[][2] = {
            {2.0, 1.3}, {2.4, 1.7}, {2.8, 1.8}, {3.4, 1.2}, {3.7, 1.6},
            {3.4, 2.0}, {4.1, 3.0}, {5.3, 2.6}, {5.4, 1.2}, {4.9, 0.8}, {2.9, 0.7},
            {2.0, 1.3} <span class="comment">// closing point is opening point</span>
            };
        <a name="a1"></a><a class="code" href="group__access.html#ge58b5c7b493d0112202dc139af200c73" title="assign two values to a 2D point">assign</a>(poly, coor);
    }

    <span class="comment">// Polygons should be closed, and directed clockwise. If you're not sure if that is the case,</span>
    <span class="comment">// call the correct algorithm</span>
    <a name="a2"></a><a class="code" href="namespaceggl.html#de63f8bac74d1e2a56c2d2712eceb8af">correct</a>(poly);

    <span class="comment">// Polygons can be streamed as text</span>
    <span class="comment">// (or more precisely: as DSV (delimiter separated values))</span>
    std::cout &lt;&lt; <a name="a3"></a><a class="code" href="namespaceggl.html#3399b7516122f515a1ea5ee5fdf49ce4" title="Main DSV-streaming function.">ggl::dsv</a>(poly) &lt;&lt; std::endl;

    <span class="comment">// As with lines, bounding box of polygons can be calculated</span>
    <a name="_a4"></a><a class="code" href="classggl_1_1box.html" title="Class box: defines a box made of two describing points.">box_2d</a> b;
    <a name="a5"></a><a class="code" href="group__envelope.html#g376bdcefa676ef2b705656b690767b36" title="Calculate envelope of a geometry, using a specified strategy.">envelope</a>(poly, b);
    std::cout &lt;&lt; <a class="code" href="namespaceggl.html#3399b7516122f515a1ea5ee5fdf49ce4" title="Main DSV-streaming function.">ggl::dsv</a>(b) &lt;&lt; std::endl;

    <span class="comment">// The area of the polygon can be calulated</span>
    std::cout &lt;&lt; <span class="stringliteral">"area: "</span> &lt;&lt; <a name="a6"></a><a class="code" href="group__area.html#g3ebfdefe9c756498730b6d93b83338b3" title="Calculate area of a geometry.">area</a>(poly) &lt;&lt; std::endl;

    <span class="comment">// And the centroid, which is the center of gravity</span>
    <a name="_a7"></a><a class="code" href="classggl_1_1point__xy.html" title="2D point in Cartesian coordinate system">point_2d</a> cent;
    <a name="a8"></a><a class="code" href="group__centroid.html#g2b743cdd7177313b561780ba87c633cd" title="Calculate centroid.">centroid</a>(poly, cent);
    std::cout &lt;&lt; <span class="stringliteral">"centroid: "</span> &lt;&lt; <a class="code" href="namespaceggl.html#3399b7516122f515a1ea5ee5fdf49ce4" title="Main DSV-streaming function.">ggl::dsv</a>(cent) &lt;&lt; std::endl;

    <span class="comment">// Actually in most cases you don't want the centroid, which is only defined for polygons.</span>
    <span class="comment">// You want a nice labelpoint instead. Call labelpoint in those cases, which is defined</span>
    <span class="comment">// for all geometries</span>
    <span class="comment">/* not yet in preview, syntax might change</span>
<span class="comment">    std::cout &lt;&lt; "labelpoints: ";</span>
<span class="comment">    label_info&lt;0&gt;(poly, , std::ostream_iterator&lt;point_2d&gt;(std::cout, " "));</span>
<span class="comment">    std::cout &lt;&lt; std::endl;</span>
<span class="comment">    */</span>

    <span class="comment">// The number of points have to called per ring separately</span>
    std::cout &lt;&lt; <span class="stringliteral">"number of points in outer ring: "</span> &lt;&lt; poly.<a name="a9"></a><a class="code" href="classggl_1_1polygon.html#5faae375ec2c4b4547da615fa8864e74">outer</a>().size() &lt;&lt; std::endl;

    <span class="comment">// Polygons can have one or more inner rings, also called holes, donuts, islands, interior rings.</span>
    <span class="comment">// Let's add one</span>
    {
        poly.<a name="a10"></a><a class="code" href="classggl_1_1polygon.html#5a8564eeeaa4f244e6f70ab10395a63f">inners</a>().resize(1);
        <a name="_a11"></a><a class="code" href="classggl_1_1linear__ring.html" title="A linear_ring (linear linear_ring) is a closed line which should not be selfintersecting...">linear_ring&lt;point_2d&gt;</a>&amp; inner = poly.<a class="code" href="classggl_1_1polygon.html#5a8564eeeaa4f244e6f70ab10395a63f">inners</a>().back();

        <span class="keyword">const</span> <span class="keywordtype">double</span> coor[][2] = { {4.0, 2.0}, {4.2, 1.4}, {4.8, 1.9}, {4.4, 2.2}, {4.0, 2.0} };
        <a class="code" href="group__access.html#ge58b5c7b493d0112202dc139af200c73" title="assign two values to a 2D point">assign</a>(inner, coor);
    }

    <a class="code" href="namespaceggl.html#de63f8bac74d1e2a56c2d2712eceb8af">correct</a>(poly);

    std::cout &lt;&lt; <span class="stringliteral">"with inner ring:"</span> &lt;&lt; <a class="code" href="namespaceggl.html#3399b7516122f515a1ea5ee5fdf49ce4" title="Main DSV-streaming function.">ggl::dsv</a>(poly) &lt;&lt; std::endl;
    <span class="comment">// The area of the polygon is changed of course</span>
    std::cout &lt;&lt; <span class="stringliteral">"new area of polygon: "</span> &lt;&lt; <a class="code" href="group__area.html#g3ebfdefe9c756498730b6d93b83338b3" title="Calculate area of a geometry.">area</a>(poly) &lt;&lt; std::endl;
    <a class="code" href="group__centroid.html#g2b743cdd7177313b561780ba87c633cd" title="Calculate centroid.">centroid</a>(poly, cent);
    std::cout &lt;&lt; <span class="stringliteral">"new centroid: "</span> &lt;&lt; <a class="code" href="namespaceggl.html#3399b7516122f515a1ea5ee5fdf49ce4" title="Main DSV-streaming function.">ggl::dsv</a>(cent) &lt;&lt; std::endl;

    <span class="comment">// You can test whether points are within a polygon</span>
    std::cout &lt;&lt; <span class="stringliteral">"point in polygon:"</span>
        &lt;&lt; <span class="stringliteral">" p1: "</span>  &lt;&lt; boolstr(<a name="a12"></a><a class="code" href="group__boolean__relations.html#g95d6465a12b762c77df41369a039f6dc" title="Within check.">within</a>(make&lt;point_2d&gt;(3.0, 2.0), poly))
        &lt;&lt; <span class="stringliteral">" p2: "</span>  &lt;&lt; boolstr(<a class="code" href="group__boolean__relations.html#g95d6465a12b762c77df41369a039f6dc" title="Within check.">within</a>(make&lt;point_2d&gt;(3.7, 2.0), poly))
        &lt;&lt; <span class="stringliteral">" p3: "</span>  &lt;&lt; boolstr(<a class="code" href="group__boolean__relations.html#g95d6465a12b762c77df41369a039f6dc" title="Within check.">within</a>(make&lt;point_2d&gt;(4.4, 2.0), poly))
        &lt;&lt; std::endl;

    <span class="comment">// You can call for_each or for_each_segment on polygons to, this will visit all points / segments</span>
    <span class="comment">// in outer ring and inner rings</span>
    <span class="comment">//for_each(poly, f);</span>

    <span class="comment">// As with linestrings and points, you can derive from polygon to add, for example,</span>
    <span class="comment">// fill color and stroke color. Or SRID (spatial reference ID). Or Z-value. Or a property map.</span>
    <span class="comment">// We don't show this here.</span>

    <span class="comment">// Clip the polygon using a bounding box</span>
    <a class="code" href="classggl_1_1box.html" title="Class box: defines a box made of two describing points.">box_2d</a> cb(make&lt;point_2d&gt;(1.5, 1.5), make&lt;point_2d&gt;(4.5, 2.5));
    <span class="keyword">typedef</span> std::vector&lt;polygon_2d &gt; polygon_list;
    polygon_list v;

    intersection&lt;polygon_2d&gt;(cb, poly, std::back_inserter(v));
    std::cout &lt;&lt; <span class="stringliteral">"Clipped output polygons"</span> &lt;&lt; std::endl;
    <span class="keywordflow">for</span> (polygon_list::const_iterator it = v.begin(); it != v.end(); ++it)
    {
        std::cout &lt;&lt; <a class="code" href="namespaceggl.html#3399b7516122f515a1ea5ee5fdf49ce4" title="Main DSV-streaming function.">ggl::dsv</a>(*it) &lt;&lt; std::endl;
    }

    <a class="code" href="classggl_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon_2d</a> hull;
    <a name="a13"></a><a class="code" href="group__convex__hull.html#g2adc5b825bd5feadc7a723c040c36cb7" title="Calculate the convex hull of a geometry.">convex_hull</a>(poly, hull);
    std::cout &lt;&lt; <span class="stringliteral">"Convex hull:"</span> &lt;&lt; <a class="code" href="namespaceggl.html#3399b7516122f515a1ea5ee5fdf49ce4" title="Main DSV-streaming function.">ggl::dsv</a>(hull) &lt;&lt; std::endl;

    <span class="comment">// If you really want:</span>
    <span class="comment">//   You don't have to use a vector, you can define a polygon with a deque</span>
    <span class="comment">//   You can specify the container for the points and for the inner rings independantly</span>

    <span class="keyword">typedef</span> <a class="code" href="classggl_1_1polygon.html" title="The polygon contains an outer ring and zero or more inner rings.">polygon&lt;point_2d, std::vector, std::deque&gt;</a> polygon_type;
    polygon_type poly2;
    <a name="_a14"></a><a class="code" href="structggl_1_1ring__type.html" title="Meta-function which defines ring type of (multi)polygon geometry.">ring_type&lt;polygon_type&gt;::type</a>&amp; ring = <a name="a15"></a><a class="code" href="group__access.html#gf92470d0612da7f0e118d296e7fcfe01" title="Function to get the exterior_ring ring of a polygon.">exterior_ring</a>(poly2);
    <a name="a16"></a><a class="code" href="group__access.html#g8cfdebdb885a95bacb1305744f0d0d7c" title="Appends one or more points to a linestring, linear-ring, polygon, multi.">append</a>(ring, make&lt;point_2d&gt;(2.8, 1.9));
    <a class="code" href="group__access.html#g8cfdebdb885a95bacb1305744f0d0d7c" title="Appends one or more points to a linestring, linear-ring, polygon, multi.">append</a>(ring, make&lt;point_2d&gt;(2.9, 2.4));
    <a class="code" href="group__access.html#g8cfdebdb885a95bacb1305744f0d0d7c" title="Appends one or more points to a linestring, linear-ring, polygon, multi.">append</a>(ring, make&lt;point_2d&gt;(3.3, 2.2));
    <a class="code" href="group__access.html#g8cfdebdb885a95bacb1305744f0d0d7c" title="Appends one or more points to a linestring, linear-ring, polygon, multi.">append</a>(ring, make&lt;point_2d&gt;(3.2, 1.8));
    <a class="code" href="group__access.html#g8cfdebdb885a95bacb1305744f0d0d7c" title="Appends one or more points to a linestring, linear-ring, polygon, multi.">append</a>(ring, make&lt;point_2d&gt;(2.8, 1.9));
    std::cout &lt;&lt; <a class="code" href="namespaceggl.html#3399b7516122f515a1ea5ee5fdf49ce4" title="Main DSV-streaming function.">ggl::dsv</a>(poly2) &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>October 13, 2009</p>
</small></td>
<td align="right">
<small>Copyright © 1995-2009 Barend Gehrels, Geodan, Amsterdam<br>
Copyright © 2008-2009 Bruno Lalande, Paris<br>
Copyright © 2009 Mateusz Loskot, Cadcorp, London<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
