Index: locks.hpp
===================================================================
--- locks.hpp	(revision 65374)
+++ locks.hpp	(working copy)
@@ -12,6 +12,7 @@
 #include <boost/thread/thread_time.hpp>
 #include <boost/detail/workaround.hpp>
 #include <boost/type_traits/is_class.hpp>
+#include <boost/sync/lock_options.hpp>
 
 #include <boost/config/abi_prefix.hpp>
 
@@ -157,16 +158,16 @@
     };
 #endif    
 
-    struct defer_lock_t
-    {};
-    struct try_to_lock_t
-    {};
-    struct adopt_lock_t
-    {};
+    //~ struct defer_lock_t
+    //~ {};
+    //~ struct try_to_lock_t
+    //~ {};
+    //~ struct adopt_lock_t
+    //~ {};
     
-    const defer_lock_t defer_lock={};
-    const try_to_lock_t try_to_lock={};
-    const adopt_lock_t adopt_lock={};
+    //~ const defer_lock_t defer_lock={};
+    //~ const try_to_lock_t try_to_lock={};
+    //~ const adopt_lock_t adopt_lock={};
 
     template<typename Mutex>
     class shared_lock;
Index: pthread/mutex.hpp
===================================================================
--- pthread/mutex.hpp	(revision 65374)
+++ pthread/mutex.hpp	(working copy)
@@ -12,6 +12,7 @@
 #include <boost/thread/locks.hpp>
 #include <boost/thread/thread_time.hpp>
 #include <boost/thread/xtime.hpp>
+#include <boost/sync/lockable_traits.hpp>
 #include <boost/assert.hpp>
 #include <errno.h>
 #include "timespec.hpp"
@@ -27,11 +28,18 @@
 
 namespace boost
 {
-    class mutex
+    class mutex : public sync::lockable_base<
+        sync::multi_threaded_tag,
+        sync::exclusive_try_lockable_tag,
+        sync::non_recursive_tag,
+        sync::owned_tag,
+        sync::process_lifetime_tag,
+        sync::anonymous_tag
+    >
     {
     private:
         mutex(mutex const&);
-        mutex& operator=(mutex const&);        
+        mutex& operator=(mutex const&);
         pthread_mutex_t m;
     public:
         mutex()
@@ -46,7 +54,7 @@
         {
             BOOST_VERIFY(!pthread_mutex_destroy(&m));
         }
-        
+
         void lock()
         {
             int const res=pthread_mutex_lock(&m);
@@ -60,7 +68,7 @@
         {
             BOOST_VERIFY(!pthread_mutex_unlock(&m));
         }
-        
+
         bool try_lock()
         {
             int const res=pthread_mutex_trylock(&m);
@@ -68,7 +76,7 @@
             {
                 boost::throw_exception(lock_error(res));
             }
-            
+
             return !res;
         }
 
@@ -84,11 +92,18 @@
 
     typedef mutex try_mutex;
 
-    class timed_mutex
+    class timed_mutex : public sync::lockable_base<
+        sync::multi_threaded_tag,
+        sync::exclusive_timed_lockable_tag,
+        sync::non_recursive_tag,
+        sync::owned_tag,
+        sync::process_lifetime_tag,
+        sync::anonymous_tag
+    >
     {
     private:
         timed_mutex(timed_mutex const&);
-        timed_mutex& operator=(timed_mutex const&);        
+        timed_mutex& operator=(timed_mutex const&);
     private:
         pthread_mutex_t m;
 #ifndef BOOST_PTHREAD_HAS_TIMEDLOCK
@@ -141,7 +156,7 @@
         {
             BOOST_VERIFY(!pthread_mutex_unlock(&m));
         }
-        
+
         bool try_lock()
         {
             int const res=pthread_mutex_trylock(&m);
@@ -156,6 +171,7 @@
             return !res;
         }
 
+
         typedef pthread_mutex_t* native_handle_type;
         native_handle_type native_handle()
         {
@@ -179,7 +195,7 @@
             is_locked=false;
             BOOST_VERIFY(!pthread_cond_signal(&cond));
         }
-        
+
         bool try_lock()
         {
             boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
@@ -209,6 +225,15 @@
         }
 #endif
 
+        bool try_lock_until(system_time const & abs_time) {
+            return timed_lock(abs_time);
+        }
+
+        template <typename Duration>
+        bool try_lock_for(Duration const & rel_time) {
+            return timed_lock(get_system_time()+rel_time);
+        }
+
         typedef unique_lock<timed_mutex> scoped_timed_lock;
         typedef detail::try_lock_wrapper<timed_mutex> scoped_try_lock;
         typedef scoped_timed_lock scoped_lock;
Index: pthread/recursive_mutex.hpp
===================================================================
--- pthread/recursive_mutex.hpp	(revision 65374)
+++ pthread/recursive_mutex.hpp	(working copy)
@@ -11,6 +11,7 @@
 #include <boost/thread/exceptions.hpp>
 #include <boost/thread/locks.hpp>
 #include <boost/thread/thread_time.hpp>
+#include <boost/sync/lockable_traits.hpp>
 #include <boost/assert.hpp>
 #ifndef _WIN32
 #include <unistd.h>
@@ -34,11 +35,18 @@
 
 namespace boost
 {
-    class recursive_mutex
+    class recursive_mutex : public sync::lockable_base<
+    sync::multi_threaded_tag,
+    sync::exclusive_try_lockable_tag,
+    sync::recursive_tag,
+    sync::owned_tag,
+    sync::process_lifetime_tag,
+    sync::anonymous_tag
+    >
     {
     private:
         recursive_mutex(recursive_mutex const&);
-        recursive_mutex& operator=(recursive_mutex const&);        
+        recursive_mutex& operator=(recursive_mutex const&);
         pthread_mutex_t m;
 #ifndef BOOST_PTHREAD_HAS_MUTEXATTR_SETTYPE
         pthread_cond_t cond;
@@ -51,7 +59,7 @@
         {
 #ifdef BOOST_PTHREAD_HAS_MUTEXATTR_SETTYPE
             pthread_mutexattr_t attr;
-            
+
             int const init_attr_res=pthread_mutexattr_init(&attr);
             if(init_attr_res)
             {
@@ -63,7 +71,7 @@
                 BOOST_VERIFY(!pthread_mutexattr_destroy(&attr));
                 boost::throw_exception(thread_resource_error());
             }
-            
+
             int const res=pthread_mutex_init(&m,&attr);
             if(res)
             {
@@ -105,7 +113,7 @@
         {
             BOOST_VERIFY(!pthread_mutex_unlock(&m));
         }
-        
+
         bool try_lock()
         {
             int const res=pthread_mutex_trylock(&m);
@@ -127,7 +135,7 @@
                 ++count;
                 return;
             }
-            
+
             while(is_locked)
             {
                 BOOST_VERIFY(!pthread_cond_wait(&cond,&m));
@@ -146,7 +154,7 @@
             }
             BOOST_VERIFY(!pthread_cond_signal(&cond));
         }
-        
+
         bool try_lock()
         {
             boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
@@ -168,11 +176,18 @@
 
     typedef recursive_mutex recursive_try_mutex;
 
-    class recursive_timed_mutex
+    class recursive_timed_mutex  : public sync::lockable_base<
+    sync::multi_threaded_tag,
+    sync::exclusive_timed_lockable_tag,
+    sync::recursive_tag,
+    sync::owned_tag,
+    sync::process_lifetime_tag,
+    sync::anonymous_tag
+    >
     {
     private:
         recursive_timed_mutex(recursive_timed_mutex const&);
-        recursive_timed_mutex& operator=(recursive_timed_mutex const&);        
+        recursive_timed_mutex& operator=(recursive_timed_mutex const&);
     private:
         pthread_mutex_t m;
 #ifndef BOOST_USE_PTHREAD_RECURSIVE_TIMEDLOCK
@@ -186,7 +201,7 @@
         {
 #ifdef BOOST_USE_PTHREAD_RECURSIVE_TIMEDLOCK
             pthread_mutexattr_t attr;
-            
+
             int const init_attr_res=pthread_mutexattr_init(&attr);
             if(init_attr_res)
             {
@@ -197,7 +212,7 @@
             {
                 boost::throw_exception(thread_resource_error());
             }
-            
+
             int const res=pthread_mutex_init(&m,&attr);
             if(res)
             {
@@ -245,7 +260,7 @@
         {
             BOOST_VERIFY(!pthread_mutex_unlock(&m));
         }
-        
+
         bool try_lock()
         {
             int const res=pthread_mutex_trylock(&m);
@@ -275,7 +290,7 @@
                 ++count;
                 return;
             }
-            
+
             while(is_locked)
             {
                 BOOST_VERIFY(!pthread_cond_wait(&cond,&m));
@@ -294,7 +309,7 @@
             }
             BOOST_VERIFY(!pthread_cond_signal(&cond));
         }
-        
+
         bool try_lock()
         {
             boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
@@ -333,6 +348,16 @@
         }
 #endif
 
+        bool try_lock_until(system_time const & abs_time) {
+            return timed_lock(abs_time);
+        }
+
+        template <typename Duration>
+        bool try_lock_for(Duration const & rel_time) {
+            return timed_lock(get_system_time()+rel_time);
+        }
+
+
         typedef unique_lock<recursive_timed_mutex> scoped_timed_lock;
         typedef detail::try_lock_wrapper<recursive_timed_mutex> scoped_try_lock;
         typedef scoped_timed_lock scoped_lock;
Index: pthread/shared_mutex.hpp
===================================================================
--- pthread/shared_mutex.hpp	(revision 65374)
+++ pthread/shared_mutex.hpp	(working copy)
@@ -12,12 +12,20 @@
 #include <boost/thread/mutex.hpp>
 #include <boost/thread/condition_variable.hpp>
 #include <boost/thread/detail/thread_interruption.hpp>
+#include <boost/sync/lockable_traits.hpp>
 
 #include <boost/config/abi_prefix.hpp>
 
 namespace boost
 {
-    class shared_mutex
+    class shared_mutex : public sync::lockable_base<
+        sync::multi_threaded_tag,
+        sync::upgradable_basic_lockable_tag,
+        sync::non_recursive_tag,
+        sync::owned_tag,
+        sync::process_lifetime_tag,
+        sync::anonymous_tag
+    >
     {
     private:
         struct state_data
@@ -27,9 +35,9 @@
             bool upgrade;
             bool exclusive_waiting_blocked;
         };
-        
 
 
+
         state_data state;
         boost::mutex state_change;
         boost::condition_variable shared_cond;
@@ -41,8 +49,8 @@
             exclusive_cond.notify_one();
             shared_cond.notify_all();
         }
-        
 
+
     public:
         shared_mutex()
         {
@@ -58,7 +66,7 @@
         {
             boost::this_thread::disable_interruption do_not_disturb;
             boost::mutex::scoped_lock lk(state_change);
-                
+
             while(state.exclusive || state.exclusive_waiting_blocked)
             {
                 shared_cond.wait(lk);
@@ -69,7 +77,7 @@
         bool try_lock_shared()
         {
             boost::mutex::scoped_lock lk(state_change);
-                
+
             if(state.exclusive || state.exclusive_waiting_blocked)
             {
                 return false;
@@ -85,7 +93,7 @@
         {
             boost::this_thread::disable_interruption do_not_disturb;
             boost::mutex::scoped_lock lk(state_change);
-                
+
             while(state.exclusive || state.exclusive_waiting_blocked)
             {
                 if(!shared_cond.timed_wait(lk,timeout))
@@ -107,7 +115,7 @@
         {
             boost::mutex::scoped_lock lk(state_change);
             bool const last_reader=!--state.shared_count;
-                
+
             if(last_reader)
             {
                 if(state.upgrade)
@@ -128,7 +136,7 @@
         {
             boost::this_thread::disable_interruption do_not_disturb;
             boost::mutex::scoped_lock lk(state_change);
-                
+
             while(state.shared_count || state.exclusive)
             {
                 state.exclusive_waiting_blocked=true;
@@ -169,7 +177,7 @@
         bool try_lock()
         {
             boost::mutex::scoped_lock lk(state_change);
-                
+
             if(state.shared_count || state.exclusive)
             {
                 return false;
@@ -179,7 +187,7 @@
                 state.exclusive=true;
                 return true;
             }
-                
+
         }
 
         void unlock()
@@ -248,7 +256,7 @@
             boost::mutex::scoped_lock lk(state_change);
             state.upgrade=false;
             bool const last_reader=!--state.shared_count;
-                
+
             if(last_reader)
             {
                 state.exclusive_waiting_blocked=false;
@@ -278,7 +286,7 @@
             state.exclusive_waiting_blocked=false;
             release_waiters();
         }
-        
+
         void unlock_and_lock_shared()
         {
             boost::mutex::scoped_lock lk(state_change);
@@ -287,7 +295,7 @@
             state.exclusive_waiting_blocked=false;
             release_waiters();
         }
-        
+
         void unlock_upgrade_and_lock_shared()
         {
             boost::mutex::scoped_lock lk(state_change);
@@ -295,6 +303,35 @@
             state.exclusive_waiting_blocked=false;
             release_waiters();
         }
+
+        bool try_lock_until(system_time const & abs_time) {
+            return timed_lock(abs_time);
+        }
+
+        template <typename Duration>
+        bool try_lock_for(Duration const & rel_time) {
+            return timed_lock(get_system_time()+rel_time);
+        }
+
+        bool try_lock_shared_until(system_time const & abs_time) {
+            return timed_lock_shared(abs_time);
+        }
+
+        template <typename Duration>
+        bool try_lock_shared_for(Duration const & rel_time) {
+            return timed_lock_shared(get_system_time()+rel_time);
+        }
+
+        bool try_lock_upgrade_until(system_time const & abs_time) {
+            return timed_lock_upgrade(abs_time);
+        }
+
+        template <typename Duration>
+        bool try_lock_upgrade_for(Duration const & rel_time) {
+            return timed_lock_upgrade(get_system_time()+rel_time);
+        }
+
+
     };
 }
 
Index: win32/thread_data.hpp
===================================================================
--- win32/thread_data.hpp	(revision 65374)
+++ win32/thread_data.hpp	(working copy)
@@ -168,7 +168,7 @@
         template<typename TimeDuration>
         inline void sleep(TimeDuration const& rel_time)
         {
-            interruptible_wait(detail::pin_to_zero(rel_time.total_milliseconds()));
+            interruptible_wait(detail::pin_to_zero(static_cast<long>(rel_time.total_milliseconds())));
         }
         inline void sleep(system_time const& abs_time)
         {
Index: win32/thread_heap_alloc.hpp
===================================================================
--- win32/thread_heap_alloc.hpp	(revision 65374)
+++ win32/thread_heap_alloc.hpp	(working copy)
@@ -56,7 +56,7 @@
 {
     namespace detail
     {
-        inline BOOST_THREAD_DECL void* allocate_raw_heap_memory(unsigned size)
+        inline void* allocate_raw_heap_memory(unsigned size)
         {
             void* const heap_memory=detail::win32::HeapAlloc(detail::win32::GetProcessHeap(),0,size);
             if(!heap_memory)
@@ -66,7 +66,7 @@
             return heap_memory;
         }
 
-        inline BOOST_THREAD_DECL void free_raw_heap_memory(void* heap_memory)
+        inline void free_raw_heap_memory(void* heap_memory)
         {
             BOOST_VERIFY(detail::win32::HeapFree(detail::win32::GetProcessHeap(),0,heap_memory)!=0);
         }
