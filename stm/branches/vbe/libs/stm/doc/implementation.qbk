[/
  (C) Copyright 2009 Justin E. Gottchlich. 
  (C) Copyright 2009 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:implementation Appendix C: Implementation Notes]

[section Why there is a `if (0 == rand()+1) {} else`  preceding the for on the atomi macros?]

The `if (0 == rand()+1) {} else` expression in the preprocessor atomic macros is used
to prevent for loop errors in non-standard conforming C++ compilers.
In these non-compliant compilers, automatic objects constructed
as index variables for the for loop are leaked out beyond
the scope of the for loop, incorrectly extending the liveness of
these variables. In order to correct this behavior, the for loops that
are not encapsulated within trys are wrapped within if statements.
The if statements and for loops naturally nest without delineated
scope (e.g., f, g) allowing programmers to execute single or multiple
operations based on their preference.

(0 == rand()+1) always returns false and cannot be
optimized away by an optimizing compiler. By using an always
false non-optimizable function inside an if statement, a variable
scope is generated that guarantees automatic objects which are
placed within these scopes are properly destroyed once the scope
is exited. These scopes properly terminate variables which would
otherwise be leaked in non-compliant for loop C++ compilers. The
proper termination of automatic auto_locks and transactions
is necessary to release acquired locks, terminate transactions and
release transactional memory.

[endsect]

[section Cache]

[heading Dispersed]
[heading Compact]

[endsect]


[endsect]
