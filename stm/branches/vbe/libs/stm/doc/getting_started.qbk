[/
[/
  (C) Copyright 2009 Justin E. Gottchlich. 
  (C) Copyright 2009 Vicente J. Botet Escriba
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]


[/======================================]
[section:getting_started Getting Started]
[/======================================]

[include installation.qbk]

[/=============================]
[section Hello World! ]
[/=============================]

The below example gives a basic introduction into __Boost_STM_s__  transactional framework and demonstrates __Boost_STM_s__ ACI conformance.


    tx_obj<int> counter;

    int increment() {
        int val = 0;
        use_atomic(_) {
            (*counter)++;
            val = *counter;
        }
        return val;
    }
    
In the above example, (A) both the write on counter and the read operations function atomically or neither operations are performed. In addition, (C) the transaction begins and ends in legal memory
states, meaning global int is guaranteed to be read correctly, preventing thread data races from causing inconsistent results. Lastly, (I) the intermediate state of the incremented global int is isolated until the transaction commits. These three attributes fulfill __Boost_STM_s__ conformance to the ACI principles. The above example also gives a basic introduction into __Boost_STM_s__ transactional framework.

[endsect]

[endsect]


