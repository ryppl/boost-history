[/
  (C) Copyright 2009 Justin E. Gottchlich.
  (C) Copyright 2009 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]


[/==========================================================================================]
[section:transaction_object_hpp Header `<boost/stm/transaction_object.hpp>`]
[/==========================================================================================]

    namespace boost { namespace stm {
        template <class Derived> class transaction_object;
        template <typename T> class native_trans;
    }}

[section Template Class `transaction_object<>`]

To further simplify the usage of __Boost_STM__, an intermediate template class was built which is meant to sit between the base_transaction_object and the user-defined transaction objects. The purpose of this intermediate class is to reduce the code overhead needed for user-defined transaction objects. To do this, the curiously recurring template pattern developed by James Coplien was used.

With the templatized transaction_object, client-side transaction objects need only to derive from it and pass their class type as its template parameter. At compile-time the transaction_object generates the necessary code to override copy_state() and implement operator new and operator delete using __Boost_STM_s__ memory manager for all user-defined types derived from it.

    template <class Derived>
    class transaction_object : public base_transaction_object {
    public:

        virtual base_transaction_object* clone(transaction* t) const;
        virtual void copy_state(base_transaction_object const * const rhs);
        virtual void move_state(base_transaction_object * rhs);
    };

[section Virtual function `clone()`]

        virtual base_transaction_object* clone(transaction* t) const;

The clone() creates a new Derived instace using the copy constructor.

[endsect]


[section Virtual function `copy_state()`]

       virtual void copy_state(base_transaction_object const * const rhs);

The copy_state() assigns the rhs to this instace using the copy-assignement operator.

[endsect]

[section Virtual function `move_state()`]

       virtual void move_state(base_transaction_object * rhs);


[endsect]

[section Virtual function `cache_deallocate()`]

        virtual void cache_deallocate();

The cache_deallocate() delete this instace using the delete operator.

[endsect]
[endsect]


[section Template Class `native_trans<>`]

    template <typename T> class native_trans : public transaction_object< native_trans<T> > {
    public:
       native_trans(){}
       native_trans(T const &rhs);
       native_trans(native_trans const &rhs);
       native_trans(native_trans &&rhs);
       native_trans& operator=(native_trans &&rhs);

       native_trans& operator=(T const &rhs);

       native_trans& operator--();
       native_trans operator--(int);
       native_trans& operator++();
       native_trans operator++(int);
       native_trans& operator+=(T const &rhs);
       native_trans operator+(native_trans const &rhs);

       operator T() const;
       T& value();
       T const & value() const;
    };

[endsect]

[endsect]




