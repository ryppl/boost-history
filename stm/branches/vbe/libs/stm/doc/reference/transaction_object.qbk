[/
  (C) Copyright 2009 Justin E. Gottchlich.
  (C) Copyright 2009 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]


[/==========================================================================================]
[section:transaction_object_hpp Header `<boost/stm/transaction_object.hpp>`]
[/==========================================================================================]

    namespace boost { namespace stm {
        template <class Derived> class transaction_object;
        template <typename T> class native_trans;
    }}

[section Template Class `transaction_object<>`]

To further simplify the usage of __Boost_STM__, an intermediate template class was built which is meant to sit between the base_transaction_object and the user-defined transaction objects. The purpose of this intermediate class is to reduce the code overhead needed for user-defined transaction objects. To do this, the curiously recurring template pattern developed by James Coplien was used.

With the templatized transaction_object, client-side transaction objects need only to derive from it and pass their class type as its template parameter. At compile-time the transaction_object generates the necessary code to override copy_state() and implement operator new and operator delete using __Boost_STM_s__ memory manager for all user-defined types derived from it.

    template <class Derived>
    class transaction_object : public base_transaction_object {
    public:

        virtual base_transaction_object* clone() const;
        virtual void copy_state(base_transaction_object const * const rhs);
        virtual void move_state(base_transaction_object * rhs);
    };

[section Virtual function `clone()`]

        virtual base_transaction_object* clone() const;

The clone() method calls to the free function cache_new_copy which allocates enough memory for the new object and then do a memcpy by default.

[endsect]


[section Virtual function `copy_state()`]

       virtual void copy_state(base_transaction_object const * const rhs);

The copy_state() method call to the free function cache_copy which do a memcpy by default.

[endsect]

[section Virtual function `move_state()`]

       virtual void move_state(base_transaction_object * rhs);

The move_state() method call to the free function cache_copy which do a memcpy by default.

[endsect]

[section Virtual function `cache_deallocate()`]

        virtual void cache_deallocate();

The cache_deallocate() method call to the free function cache_deallocate which do a memcpy by default.

[endsect]
[endsect]


[section Template Class `native_trans<>`]

    template <typename T> class native_trans : public transaction_object< native_trans<T> > {
    public:
       native_trans(){}
       native_trans(T const &rhs);
       native_trans(native_trans const &rhs);
       native_trans(native_trans &&rhs);
       native_trans& operator=(native_trans &&rhs);

       native_trans& operator=(T const &rhs);

       native_trans& operator--();
       native_trans operator--(int);
       native_trans& operator++();
       native_trans operator++(int);
       native_trans& operator+=(T const &rhs);
       native_trans operator+(native_trans const &rhs);

       operator T() const;
       T& value();
       T const & value() const;
    };

[endsect]

[endsect]


[/==========================================================================================]
[section:transactional_object_hpp Header `<boost/stm/transactional_object.hpp>`]
[/==========================================================================================]

    namespace boost { namespace stm {
        template <class T> class transactional_object;

        template <typename T>
        static transactional_object<T>* tx_up_cast(T* ptr);

        template <typename T, typename U>
        static transactional_object<T>* tx_static_cast(transactional_object<U>* ptr);

        template <typename T, typename U>
        static transactional_object<T>* tx_dynamic_cast(transactional_object<U>* ptr);
    }}

[section Template Class `transactional_object<>`]

Transactional object wrapper. A `transactional_object<T>` is a base_transaction_object wrapping an instance of type T. Provides the definition of the virtual functions

* forward constructors to the wrapped type
* `copy_state`: relaying on the cache_copy<T> generic function
* `move_state` and
* `cache_deallocate`: relaying on the cache_copy<T> generic function

Defines in addition the functions `new` and `delete` when `BOOST_STM_USE_MEMORY_MANAGER` is defined

If a class D inherits from B we have that `transactional_object<D>` dont inherits from `transactional_object<B>`, but
we can static/dynamic cast them robustly.

Evidently the `std::static_cast`/`std::dynamic_cast` do not works. We need to define the specific cast

    transactional_object<D>* d=...;
    transactional_object<B>* b=tx_static_cast<B>(d);

    transactional_object<B>* b=...;
    transactional_object<D>* d=tx_dynamic_cast<B>(b);

Synopsis

    template <typename T>
    class transactional_object : public base_transaction_object {
    public:
        T value;

        transactional_object();
        transactional_object(const T*ptr);
        transactional_object(transactional_object<T> const & r);
        template <typename T1>
        transactional_object(T1 const &p1);

        template <typename T1, typename T2>
        transactional_object(T1 const &p1, T2 const &p2);

        transactional_object & operator=(transactional_object const & r);

        virtual void copy_state(base_transaction_object const * const rhs);

    #ifdef BOOST_STM_USE_UNASIGNED_COPY
        virtual void cache_deallocate();
    #endif

    #if BOST_STM_USE_MEMORY_MANAGER
       void* operator new(size_t size) throw ();
       void operator delete(void* mem);
    #endif

    };

[section Virtual function `copy_state()`]

       virtual void copy_state(base_transaction_object const * const rhs);

[endsect]

[section Virtual function `move_state()`]

       virtual void move_state(base_transaction_object * rhs);

[endsect]

[section Virtual function `cache_deallocate()`]

        virtual void cache_deallocate()=0;

[endsect]

[endsect]

[endsect]


