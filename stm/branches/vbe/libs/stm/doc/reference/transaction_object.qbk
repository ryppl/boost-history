[/
  (C) Copyright 2009 Justin E. Gottchlich.
  (C) Copyright 2009 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]


[/==========================================================================================]
[section:base_transaction_hpp Header `<boost/stm/base_transaction.hpp>`]
[/==========================================================================================]

    namespace boost { namespace stm {
        class base_transaction_object;

        template <class T> T* cache_clone(const T& val);
        template <class T> void cache_copy(const T* const ori, T* target);
        void cache_release(base_transaction_object* ptr);

        template <class T> T* cache_allocate();
        template <class T> void cache_deallocate(T*);


        template <class Derived> class transaction_object;
        template <typename T> class native_trans;
    }}

[section Abstract Class `base_transaction_object`]

This is the base class of all the transactional objects. It tracks:

* `transactionThread_`: the thread identifier holding the write acces to this transactional object
* `transaction_`: the pointer to the transaction
* `version_`: the version when performing validation
* `newMemory_`: states whether this object is a new object

Transactional objets must specialize the pure virtual functions

* `copy_state(base_transaction_object const * const rhs)`
* `move_state(base_transaction_object * rhs)` if `BUILD_MOVE_SEMANTICS`
* `cache_deallocate()` if `BOOST_STM_USE_UNASIGNED_COPY`

`copy_state` is used to copy the backup/working copy to the shared transactional object when the roolback/commit is done direct/defered policy is used.

`move_state` is used to move the backup/working copy to the shared transactional object when the roolback/commit is done direct/defered policy is used.

`cache_deallocate` is used to release the backup/working copy when the transaction ends if direct/defered policy is used.

When USE_STM_MEMORY_MANAGER is defined this class provides two functions (`retrieve_mem` and `return_mem`) and  to manage a pool of memory.


    class base_transaction_object
    {
    public:

        base_transaction_object();
        virtual ~base_transaction_object() {};

        virtual base_transaction_object* clone() const = 0;
        virtual void copy_state(base_transaction_object const * const rhs) = 0;
        virtual void move_state(base_transaction_object * rhs) = 0;

        void transaction_thread(thread_id rhs) const;
        thread_id transaction_thread() const;

        void new_memory(bool rhs)
        bool new_memory() const;

    #if BOOST_STM_PERFORMING_VALIDATION
        void version(std::size_t rhs);
        std::size_t version() const;
    #endif

    #if BOOST_STM_USE_MEMORY_MANAGER
        static void return_mem(void *mem, size_t size);
        static void* retrieve_mem(size_t size);
        static void alloc_size(size_t size);
    #endif

    #ifdef BOOST_STM_USE_UNASIGNED_COPY
        virtual void cache_deallocate()=0;
    #endif

    };

[section Constructor `base_transaction_object()`]

       base_transaction_object();

Default constructor (ctor) with no parameters allows derived base_transaction_objects to implicitly construct the base_transaction_object base class for easier integration.

[endsect]

[section Virtual Destructor `~base_transaction_object()`]

       virtual ~base_transaction_object() {};

Virtual destructor (dtor) ensures correct destructors are called in the inheritance hierarchy for delete operations invoked on base_transaction_object pointers, which occur in numerous places throughout the internal transaction code.

[endsect]

[section Virtual function `copy_state()`]

       virtual void copy_state(base_transaction_object const * const rhs) = 0;


The `copy_state()` method is called each time global memory is updated, for either direct or deferred updating policies. With this in mind, it is vital that the this object be set to the exact state of the input parameter.

Derived classes usually simply override this method and perform an `operator=()` function call for the specific derived type.

[endsect]


[section Virtual function `move_state()`]

       virtual void move_state(base_transaction_object * rhs) = 0;

The move_state() method is internally called at deferred updating commit time and at direct updating abort time and invokes the user-defined derived transaction class's move assignment (e.g. operator=(type &&)).

[endsect]

[section Static function `retrieve_mem()`]

        static void* retrieve_mem(size_t size);

Static interface into __Boost_STM_s__ memory management system for retrieving memory. The supplied parameter is the requested block size, the return parameter is a void* to the allocated block. Usually access to this interface is done by overloading operator new in the derived base_transaction_object class. Void pointers are the natural and preferred manner to handle memory allocations and deallocations and are therefore safe in this context.

[endsect]


[section Static function `return_mem()`]

        static void return_mem(void *mem, size_t size);

Static interface into __Boost_STM_s__ memory management system for returning memory. The first parameter points to the memory block being returned, the second parameter specifies its size. Usually access to this interface is done by overloading operator delete in the derived transaction object class. Void pointers are the natural and preferred manner to handle memory allocations and deallocations and are therefore safe in this context.

[endsect]

[section Static function `alloc_size()`]

        static void alloc_size(size_t size);

Static interface into __Boost_STM_s__ memory management system which allows the user to specify the allocation chunk size for the memory manager. The input parameter specifies the number of transactional objects that should be allocated at startup and with each subsequent buffer increase. If no size is specified, the allocation chunk size uses __Boost_STM_s__ default value, currently 8192. The alloc_size() interface can be reconfigured at runtime and is used upon the next buffer increase.

[endsect]

[section Virtual function `cache_deallocate()`]

        virtual void cache_deallocate()=0;

[endsect]


[endsect]

[section Template Function `cache_clone<>()`]

    template <class T>
    T* cache_clone(const T& val);

Makes a new copy of the parameter. Allocates an object of type T using the `cache_allocate` function and copy from the given parameter `val` using the free function `cache_copy`.

The user can overload this function, as __Boost_STM__ uses ADL to access it.

When `BOOST_STM_NO_PARTIAL_SPECIALIZATION` is defined, i.e. on compilers not supporting partial template specialization, the function calls to `partial_specialization_workaround::cache_clone<T>::apply(val)`. So the user will need to overload the class `partial_specialization_workaround::cache_clone<T>` defining the function

    static T* apply(const T& val);

[endsect]


[section Template Function `cache_copy<>()`]

    template <class T>
    void cache_copy(const T* const source, T* target);

Copy from souce to target using memcpy by default.

The user can overload this function, as __Boost_STM__ uses ADL to access it.

When `BOOST_STM_NO_PARTIAL_SPECIALIZATION` is defined, i.e. on compilers not supporting partial template specialization, the function calls to `partial_specialization_workaround::cache_copy<T>::apply(source, target)`. So the user will need to overload the class `partial_specialization_workaround::cache_copy<T>` defining the function

    static T* apply(const T* const source, T* target);

[endsect]

[section Function `cache_release<>()`]

    void cache_release(base_transaction_object* ptr) {

Release the given base_transaction_object by calling to the virtual function `cache_dealocate`.

[endsect]


[section Template Function `cache_allocate<>()`]

    template <class T>
    T* cache_allocate();

Allocates an instance of calls T. Depending on whether BOOST_STM_CACHE_USE_MEMORY_MANAGER, BOOST_STM_CACHE_USE_MALLOC or BOOST_STM_CACHE_USE_TSS_MONOTONIC_MEMORY_MANAGER are defined this function will use the static pool of the class T, malloc or the thread specific monotonic allocator.

[endsect]

[section Template Function `cache_deallocate<>()`]

    template <class T>
    void cache_deallocate(T*ptr) {

Deallocates an instance of calls T. Depending on whether BOOST_STM_CACHE_USE_MEMORY_MANAGER, BOOST_STM_CACHE_USE_MALLOC or BOOST_STM_CACHE_USE_TSS_MONOTONIC_MEMORY_MANAGER are defined this function will use the static pool of the class T, free or the no-op.

[endsect]

[section Template Class `transaction_object<>`]

To further simplify the usage of __Boost_STM__, an intermediate template class was built which is meant to sit between the base_transaction_object and the user-defined transaction objects. The purpose of this intermediate class is to reduce the code overhead needed for user-defined transaction objects. To do this, the curiously recurring template pattern developed by James Coplien was used.

With the templatized transaction_object, client-side transaction objects need only to derive from it and pass their class type as its template parameter. At compile-time the transaction_object generates the necessary code to override copy_state() and implement operator new and operator delete using __Boost_STM_s__ memory manager for all user-defined types derived from it.

    template <class Derived>
    class transaction_object : public base_transaction_object {
    public:

        virtual base_transaction_object* clone() const;
        virtual void copy_state(base_transaction_object const * const rhs);
        virtual void move_state(base_transaction_object * rhs);
    };

[section Virtual function `clone()`]

        virtual base_transaction_object* clone() const;

The clone() method calls to the free function cache_new_copy which allocates enough memory for the new object and then do a memcpy by default.

[endsect]


[section Virtual function `copy_state()`]

       virtual void copy_state(base_transaction_object const * const rhs);

The copy_state() method call to the free function cache_copy which do a memcpy by default.

[endsect]

[section Virtual function `move_state()`]

       virtual void move_state(base_transaction_object * rhs);

The move_state() method call to the free function cache_copy which do a memcpy by default.

[endsect]

[section Virtual function `cache_deallocate()`]

        virtual void cache_deallocate();

The cache_deallocate() method call to the free function cache_deallocate which do a memcpy by default.

[endsect]
[endsect]


[section Template Class `native_trans<>`]

    template <typename T> class native_trans : public transaction_object< native_trans<T> > {
    public:
       native_trans(){}
       native_trans(T const &rhs);
       native_trans(native_trans const &rhs);
       native_trans(native_trans &&rhs);
       native_trans& operator=(native_trans &&rhs);

       native_trans& operator=(T const &rhs);

       native_trans& operator--();
       native_trans operator--(int);
       native_trans& operator++();
       native_trans operator++(int);
       native_trans& operator+=(T const &rhs);
       native_trans operator+(native_trans const &rhs);

       operator T() const;
       T& value();
       T const & value() const;
    };

[endsect]

[endsect]


[/==========================================================================================]
[section:transactional_object_hpp Header `<boost/stm/transactional_object.hpp>`]
[/==========================================================================================]

    namespace boost { namespace stm {
        template <class T> class transactional_object;

        template <typename T>
        static transactional_object<T>* tx_up_cast(T* ptr);

        template <typename T, typename U>
        static transactional_object<T>* tx_static_cast(transactional_object<U>* ptr);

        template <typename T, typename U>
        static transactional_object<T>* tx_dynamic_cast(transactional_object<U>* ptr);
    }}

[section Template Class `transactional_object<>`]

Transactional object wrapper. A `transactional_object<T>` is a base_transaction_object wrapping an instance of type T. Provides the definition of the virtual functions

* forward constructors to the wrapped type
* `copy_state`: relaying on the cache_copy<T> generic function
* `move_state` and
* `cache_deallocate`: relaying on the cache_copy<T> generic function

Defines in addition the functions `new` and `delete` when `BOOST_STM_USE_MEMORY_MANAGER` is defined

If a class D inherits from B we have that `transactional_object<D>` dont inherits from `transactional_object<B>`, but
we can static/dynamic cast them robustly.

Evidently the `std::static_cast`/`std::dynamic_cast` do not works. We need to define the specific cast

    transactional_object<D>* d=...;
    transactional_object<B>* b=tx_static_cast<B>(d);

    transactional_object<B>* b=...;
    transactional_object<D>* d=tx_dynamic_cast<B>(b);

Synopsis

    template <typename T>
    class transactional_object : public base_transaction_object {
    public:
        T value;

        transactional_object();
        transactional_object(const T*ptr);
        transactional_object(transactional_object<T> const & r);
        template <typename T1>
        transactional_object(T1 const &p1);

        template <typename T1, typename T2>
        transactional_object(T1 const &p1, T2 const &p2);

        transactional_object & operator=(transactional_object const & r);

        virtual void copy_state(base_transaction_object const * const rhs);

    #ifdef BOOST_STM_USE_UNASIGNED_COPY
        virtual void cache_deallocate();
    #endif

    #if BOST_STM_USE_MEMORY_MANAGER
       void* operator new(size_t size) throw ();
       void operator delete(void* mem);
    #endif

    };

[section Virtual function `copy_state()`]

       virtual void copy_state(base_transaction_object const * const rhs);

[endsect]

[section Virtual function `move_state()`]

       virtual void move_state(base_transaction_object * rhs);

[endsect]

[section Virtual function `cache_deallocate()`]

        virtual void cache_deallocate()=0;

[endsect]

[endsect]

[endsect]


