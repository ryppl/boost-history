[/
  (C) Copyright 2009 Justin E. Gottchlich.
  (C) Copyright 2009 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[/==========================================================================================]
[section:language_like_hpp Header `<boost/stm/language_like.hpp>`]
[/==========================================================================================]

[section Transaction related]

The complexity behind the `BOOST_STM_TRANSACTION`/`BOOST_STM_END_TRANSACTION` macros is needed to guarantee the following fundamental goals:

* First, transactions must start and end correctly.
* Second, transactions must change their retry behavior based on whether they are a nested or root transaction to ensure proper closed nesting, flattened transaction behavior is performed.
* `return`/`goto` statements can be used and must commit the transaction before leaving the transaction block
* `break`/`continue` statements can be used and are associated to a user loop and commit the transaction before leaving the transaction block.
* commit or abort on user exceptions before re-throwing.

The following pseudo code shows the general schema:

    1   >>> frame transaction_block =
    2       keyword<transaction> statement_sequence<BODY>
    3       [ keyword<retry> statement_sequence<RETRY> ]
    4   >>> var in_loop = ...
    5   >>> var exception_commits = ...
    6   >>> transaformation
    7   {
    8       control_flow __ctrl;
    9       for(boost::stm::transaction __txn_;;) {                                                                        \
    10          try{
    11              boost::stm::detail::commit_on_destruction __destr(__txn); \
    12              try{
    13                  do {
    14                      __ctrl=break_;
    15                      <BODY>
    16                      __ctrl=none;
    17                      break;
    18                  } while ((__ctrl=continue_),false);
    19              } catch (boost::stm::aborted_tx &) {
    20                  __destr.release();
    21                  throw;
    22              } catch(...) {
    23  >>> if exception_commits
    24                  if (__txn_.forced_to_abort()) {
    25                      __destr_.release();
    26                  } else {
    27                      __destr_.commit();
    28                  }
    29  >>> else                
    30                  __destr_.release();
    31  >>> endif
    32                  throw;
    33              }
    34              break;
    35          } catch (boost::stm::aborted_tx &) {
    36              if (__txn_.is_nested()) throw;
    37              do {
    38                  __ctrl=break_;
    39                  <RETRY>
    40                  __ctrl=none;
    41                  break;
    42              } while ((__ctrl=continue_),false);
    43          }
    44  >>> if in_loop
    45          if (__ctrl != none) break;              \
    46  >>> else
    47          BOOST_ASSERT(__ctrl == none);           \
    48  >>> endif
    49         __txn.restart();                                                               \
    50      }
    51  >>> if in_loop
    52      if (__ctrl==continue_) continue;
    53      else if (__ctrl==break_) break;
    54  >>> endif
    55  }
    56  >>> end_frame


The `BOOST_STM_TRANSACTION`/`BOOST_STM_END_TRANSACTION` preprocessor behaves as follows. When the transactional for loop is entered, a transaction automatic object is constructed which initializes the transaction and puts it in-flight. The for loop conditional ensures the following conditions:

# the transaction is uncommitted,
# the transaction has the opportunity to throw an exception if necessary, and
# the transaction is in-flight.

On a inner block a commit on destruction variable is created, which will commit the transaction if not released.
Once a transaction commits, the transaction is not executed again. If the transaction has been aborted but is a nested transaction, the transaction must be restarted at the parent level. This is done by throwing an exception upward so the entire transaction can be restarted from the parent. This behavior allows transactions to be used at any nesting level while dynamically ensuring the correct retry behavior. Finally, the call to `restart` ensures the transaction is correctly restarted after each subsequent abort.

Once all of the transactional operations within the for loop are executed, the commit on destruction destructor is called which commit the transaction. This terminates the transaction by either committing or aborting it.

[section Macro `BOOST_STM_TRANSACTION`]

Use `BOOST_STM_TRANSACTION` for optimistic critical section. Supports single-depth and multiple-depth (nested) transactions. Performs automatic retry for root transaction, throws exception when T is a child transaction. This automatic switch enables correctly behaved nested and non-nested transactions

    #define BOOST_STM_TRANSACTION(T) ...

Usage

        BOOST_STM_TRANSACTION
            <sentence sequence excluding break/continue>
        BOOST_STM_END_TRANSACTION
    |
        BOOST_STM_TRANSACTION
            <sentence sequence excluding break/continue>
        BOOST_STM_RETRY
            <sentence sequence>
        BOOST_STM_END_RETRY


[endsect]

[section Macro `BOOST_STM_RETRY`]

    #define BOOST_STM_RETRY ...

Opens a retry block.

Usage

    BOOST_STM_TRANSACTION
        <sentence sequence>
    BOOST_STM_RETRY
        <sentence sequence>
    BOOST_STM_END_RETRY

[endsect]
[section Macro `BOOST_STM_END_RETRY`]

    #define BOOST_STM_END_RETRY catch (aborted_tx &)

Usage

    BOOST_STM_TRANSACTION
        <sentence sequence>
    BOOST_STM_RETRY
        <sentence sequence>
    BOOST_STM_END_RETRY

[endsect]
[section Macro `BOOST_STM_END_TRANSACTION`]

    #define BOOST_STM_END_TRANSACTION ...

Equivalent to

    BOOST_STM_RETRY {}
    BOOST_STM_END_RETRY

Usage

    BOOST_STM_TRANSACTION
        <sentence sequence>
    BOOST_STM_END_TRANSACTION

[endsect]

[section Macro `BOOST_STM_TRANSACTION_IN_LOOP`]

Use `BOOST_STM_TRANSACTION_IN_LOOP` for optimistic critical section. Works as `BOOST_STM_TRANSACTION` and in addition supporte `break`/`continue` statements.

    #define BOOST_STM_TRANSACTION_IN_LOOP(T) ...

Currently equivalent to

    BOOST_STM_TRANSACTION

Usage
        user loop {
            BOOST_STM_TRANSACTION_IN_LOOP
                <sentence sequence including break/continue>
            BOOST_STM_END_TRANSACTION_IN_LOOP
        }
    |
        BOOST_STM_TRANSACTION_IN_LOOP
            <sentence sequence>
        BOOST_STM_RETRY
            <sentence sequence>
        BOOST_STM_END_RETRY_IN_LOOP


[endsect]

[section Macro `BOOST_STM_END_RETRY_IN_LOOP`]

    #define BOOST_STM_END_RETRY_IN_LOOP ...

Usage

    BOOST_STM_TRANSACTION_IN_LOOP
        <sentence sequence>
    BOOST_STM_RETRY
        <sentence sequence>
    BOOST_STM_END_RETRY_IN_LOOP

[endsect]
[section Macro `BOOST_STM_END_TRANSACTION_IN_LOOP`]

    #define BOOST_STM_END_TRANSACTION_IN_LOOP ...

Equivalent to

    BOOST_STM_RETRY {}
    BOOST_STM_END_RETRY_IN_LOOP


Usage

    BOOST_STM_TRANSACTION_IN_LOOP
        <sentence sequence>
    BOOST_STM_END_TRANSACTION_IN_LOOP

[endsect]

[section Macro `BOOST_STM_CURRENT`]

    #define BOOST_STM_CURRENT ...

Reference to the current transaction on a `BOOST_STM_TRANSACTION`/`BOOST_STM_END_TRANSACTION` or `BOOST_STM_RETRY`/`BOOST_STM_END_RETRY` block

Usage

    BOOST_STM_TRANSACTION
        BOOST_STM_CURRENT.
    BOOST_STM_END_TRANSACTION

[endsect]

[section Macro `BOOST_STM_COMMIT`]

    #define BOOST_STM_COMMIT ...

Abort the current transaction on a `BOOST_STM_TRANSACTION`/`BOOST_STM_END_TRANSACTION` block

Usage

    BOOST_STM_TRANSACTION
        BOOST_STM_COMMIT();
    BOOST_STM_END_TRANSACTION

[endsect]

[section Macro `BOOST_STM_ABORT`]

    #define BOOST_STM_ABORT ...

Abort the current transaction on a `BOOST_STM_TRANSACTION`/`BOOST_STM_END_TRANSACTION` block

Usage

    BOOST_STM_TRANSACTION
        BOOST_STM_ABORT();
    BOOST_STM_END_TRANSACTION

[endsect]
[endsect]

[section Memory management related]

[section Macro `BOOST_STM_NEW_PTR`]

    #define BOOST_STM_NEW_PTR(T_ARGS) ...

Creates a new instance using the `new` operator and notifies the STM system of this new creation. 

Usage

    BOOST_STM_TRANSACTION
        ...
        prev->next_=BOOST_STM_NEW(list_node<T>(val, curr));
        ...
    BOOST_STM_END_TRANSACTION

[endsect]

[section Macro `BOOST_STM_DELETE_PTR`]

    #define BOOST_STM_DELETE_PTR(PTR) ...

Deletes the instance using the `delete` operator and nnotifies the STM system of this deletion. 

Usage

    BOOST_STM_TRANSACTION
        ...
        prev->next_=BOOST_STM_NEW(list_node<T>(val, curr));
        ...
    BOOST_STM_END_TRANSACTION

[endsect]

[section Macro `BOOST_STM_NEW_ARRAY`]

    #define BOOST_STM_NEW_ARRAY(SIZE, T) ...

Creates a new array using the `new []` operator and notifies the STM system of this new allocation. 

Usage

    BOOST_STM_TRANSACTION
        ...
        prev->next_=BOOST_STM_NEW(size, list_node<T>(val, curr));
        ...
    BOOST_STM_END_TRANSACTION

[endsect]

[section Macro `BOOST_STM_DELETE_ARRAY`]

    #define BOOST_STM_DELETE_ARRAY(PTR, SIZE) ...

Deletes the array instance using the `delete[]` operator and nnotifies the STM system of this deletion. 

Usage

    BOOST_STM_TRANSACTION
        ...
        prev->next_=BOOST_STM_NEW(list_node<T>(val, curr));
        ...
    BOOST_STM_END_TRANSACTION

[endsect]

[endsect]

[endsect]


