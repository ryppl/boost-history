[/
  (C) Copyright 2009 Justin E. Gottchlich.
  (C) Copyright 2009 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]



[section:tutorial Tutorial]

A number of example transactions are presented in this section using the __Boost_STM__ library. The first example illustrates how to write a transactional linked list insert operation. The second example demonstrates composition, combining a transactional insert operation with a transactional remove operation which compose into a larger, single move transaction. Next, a minor but important detail regarding memory addresses within the transactional workspace is given. Finally, an example of how to handle priority inversion for validating and invalidating consistency schemes using __Boost_STM_s__ extensible contention manager and compositional framework is provided. The final example demonstrates a number of important aspects of __Boost_STM_s__ implementation, such as, differing priority inversion mechanics for different consistency models, transactional attribute enrichment via composition and threaded memory sharing amongst transactions.

While most of the examples are intuitive and a complete understanding of the __Boost_STM__ API is not needed for a high-level understanding of its functionality, a complete description of all interfaces used below can found in  referenced section.



[section A Simple Transaction]

In this example, we build a linked list insert transactional operation using __Boost_STM__. The example is shown in three segments: the client code which inserts 100 items into the list, the insert operation which client code calls, the internal insert operation which the exposed insert operation calls.

[heading Client Invoked Inserts]

    tx_ptr<linked_list<int> > llist;
    ...
    atomic(_) {
        for (int i = 0; i < 100; ++i)     {
            llist->insert(i);
        }
    }

After inspecting the above client invoked insert code it is apparent that the code itself shows no deep signs of being transactional. The two exceptions are the declaration of the list using a tx_ptr smart pointer and the fact that the insertion of te 100 elements is atomic. This is our desired behavior. As far as the client side programmer is concerned, there is no additional code needed to perform a transactional linked list insert over a non-transactional linked list insert. Obviously, this simplistic behavior eases the introduction of TM solutions into algorithms of new and legacy systems.

[heading Linked list declaration]

[heading Insert retry transaction]

    void insert(T const &val) {
        for (boost::stm::transaction _; !_.committed() && _.restart(); _.no_throw_end())
            try {
                // ... see below
            } catch (aborted_transaction_exception&) {}
    }

The exposed insert code performs two key operations: (1) it retries the transaction until it succeeds (commits) and (2) it catches aborted transaction exceptions. The retry code is perhaps the largest visible section of code overhead for the transactional linked list insert operation. While there are other C++ mechanisms to retry transactions, like gotos or macro-based approaches, we believe a simple loop is currently the best solution for TM retry behavior in C++. Others before us have implemented differing solutions that have smaller code footprints, but violate large-scale design concerns, break compositionality potential and hide or impose large language penalties. As such, we currently accept the loop overhead as a small inconvenience and avoid breaking language semantics.

The aborted_transaction_exception allows __Boost_STM__ to be exception neutral while also gaining performance benefits of early notification of doomed transactions. The above example demonstrates this behavior in practice with its absorption of aborted transactions and only aborted transactions.

[heading Insert specific]

            upgrd_ptr<list_node<T> > prev(_, head_);
            upgrd_ptr<list_node<T> > curr(_, head_->next_);
            while (curr) {
                if (curr->value_ == val) return;
                else if (curr->value_ > val) break;
                prev = curr;
                curr = curr->next_;
            }
            if (!curr || (curr->value_ > val)) {
                make_wr_ptr(_, prev)->next_ =
                    BOOST_STM_NEW(_,transactional_object<list_node<T> >(val, curr));
            }

The above example illustrates the simplicity of __Boost_STM__ transactions and their interfaces. The transactional implementation is nearly identical to a non-transactional implementation with the exception of some annotations. The templatized functions within the transaction class ensure type-safety is maintained without any necessary type-casts. Due to exact type correctness, as demonstrated in the calls to make_wr_ptr(), daisy-chained method invocation can be performed allowing streamlined usage. These aspects help make __Boost_STM__ transactions small and easy to understand.

One minor, but vital, detail is in way new objects are created on a transactional context. Rather than hide this difference, it is intentionally exposed here to draw out the memory access differences required for writes to new and existing memory. We explain this difference in detail later in this section.

In order to simplify the retry mechanism a macro is provided so the user can just write

    void insert(T const &val) {
        atomic(_) {
            upgrd_ptr<list_node<T> > prev(_, head_);
            upgrd_ptr<list_node<T> > curr(_, head_->next_);
            while (curr) {
                if (curr->value_ == val) return;
                else if (curr->value_ > val) break;
                prev = curr;
                curr = curr->next_;
            }
            if (!curr || (curr->value_ > val)) {
                make_wr_ptr(_, prev)->next_ =
                    BOOST_STM_NEW(_,transactional_object<list_node<T> >(val, curr));
            }
        }
    }


[endsect]

[section A Composable Transaction]

The below example builds upon the previous example by adding
a remove operation. We combine the insert and remove operations
and build a transactional move operation that compose into a single
transaction. Composition is a key aspect for TM systems. __Boost_STM_s__
ability to compose transactions from pre-existing transactions
is fundamental to its design.

In the following example, the first section shows client code
invoking the move operation. Next, the internal remove operation
is shown, demonstrating its transactional independence. Last, the
external move operation is explained, combining the internal insert
and remove linked list operations resulting in a composed, single
transaction.

Client Invoked Inserts / Moves.

    tx_ptr<linked_list<int> > llist;
    ...
    atomic(_) {
        for (int i = 0; i < 100; ++i) {
            llist->insert(i);
        }
        for (int j = 0; j < 100; ++j) {
            llist->move(j, -j);
        }
    }

The client invoked inserts and moves are fairly straight forward.
The insert operations are performed first then the original items are
moved to a new location by inverting their value. Again, from a
client programming perspective, there is no hint that this code is
transactional, which is our intended goal.

Remove

    void remove(const T& val) {
        use_atomic(_) {
            // find the node whose val matches the request
            upgrd_ptr<list_node<T> > prev(_,head_);
            upgrd_ptr<list_node<T> > curr(_,prev->next_);
            while (curr) {
                // if we find the node, disconnect it and end the search
                if (curr->value_ == val) {
                    make_wr_ptr(_, prev)->next_=curr->next_;
                    delete_ptr(_,curr);
                    break;
                } else if (curr->value_ > val) {
                    // this means the search failed
                    break;
                }
                prev = curr;
                curr = prev->next_;
            }
        }
    }

As was the case with the insert(), the above
remove() method is almost identical to how a normal
linked list remove operation would be implemented, with the
exception of the atomic guard and a few __Boost_STM__ API calls.
Again, this is ideal, as it leads to intuitive transactional programming,
requiring only a minor learning curve for the algorithms
developer.

Composed External Move

    void move(T const &v1, T const &v2) {
        use_atomic {
            remove(v1);
            insert(v2);
        }
    }

The move() implementation do not requires any overhead
required in non-transactional implementations, other than using the atomic guard.
The remainder of the code

[endsect]


[section A Dynamically Prioritized, Composed Transaction]

The following subsection discusses how priority inversion is handled
within __Boost_STM__ using dynamic priority assignment. Two solutions
are presented for the different consistency models, one for
validation and one for invalidation. Following the two examples
which detail how to override contention management interfaces,
a dynamically prioritized transaction is presented, demonstrating
how transactions interact with the prior implementations.
Priority inversion in transactional memory occurs when a lower
priority transaction causes a higher priority transaction to abort.
With STM lock-based (and non-blocking) systems, priority inversion
does not happen on the same scale as that of direct lock-based
solutions. The different cases of priority inversion between direct
locking solutions and TM solutions are due to TM's natural avoidance
of critical sections. However, priority inversion in TM can easily
occur if, for example, a long running transaction is continually
preempted by shorter running transactions which always commit
before the longer transaction.


In order to prevent such priority inversion scenarios, two extensible
contention manager (CM) virtual methods are provided
to allow client-side implementations a way to handle different
scenarios based on the consistency model currently in use. The
first interface, abort_before_commit(), allows a user-defined
contention manager mechanism to abort a transaction before it
commits. Although __Boost_STM__ does not yet implement validation,
once it becomes available, client-side validating algorithms
which want to avoid priority inversion will need to override
abort_before_commit() to iterate over in-flight transactions and
abort the current in-process transaction if another in-flight transaction
exists of higher priority. All in-flight transactions can be accessed
by a call to in_flight_transactions() which returns
the set of active transactions. As such, one could build an overridden
abort_before_commit() which always caused lower priority
committing transactions to abort in the event a higher priority
transaction is currently in-flight. One possible implementation is
shown below. For code simplicity, the following code has removed
some static class accessors and namespaces.


Priority Inversion for Validating Consistency.

    class priority_cm :
    public core::base_contention_manager {
    public:
        // method invoked prior tx commit
        bool abort_before_commit(transaction const &t) {
            in_flight_transaction_container::const_iterator i = in_flight_transactions().begin();
            for (; in_flight_transactions().end() != i; ++i) {
                if (t.priority() < (*i)->priority()){
                    return true;
                }
            }
            return false;
        }
    };

While the above approach is necessary for a validating system,
it is largely a poor way to perform priority inversion checking.
Firstly, it has the side-effect of causing unnecessary aborts for
transactions which do not necessarily conflict, but simply have
differing priority levels. Secondly, it is slow in that all transactions
must be walked through each time a transaction commits.
However, as an ad hoc solution for a validating system, the
above priority inversion mechanism may be as close to correct
as is possible. This solution is useful for validation, but should
never be used for invalidation. Instead a second and more natural
approach for invalidating systems to prevent priority inversion
is to override the permission_to_abort() interface. The
permission_to_abort() interface can only be used when __Boost_STM__
is performing invalidation.

The permission_to_abort() interface is called from __Boost_STM_s__
end_transaction() method when a committing transaction
has found a second transaction it needs to abort for consistency.
As such, the method takes two parameters, an lhs (lefthand
side), the committing transaction, and an rhs (right-hand side),
the transaction requested to be aborted. If permission is granted to
abort the second transaction, the method returns true and the second
transaction is aborted. If permission is not granted to abort the
second transaction, the method returns false and upon returning the
committing transaction aborts itself. All consistency checking for


deferred updating is performed prior to any updating operation and
thus memory is still in a completely legal uncommitted state until
all consistency is performed. For direct updating aborts, the system
simply follows its normal semantics of aborting the transaction by
restoring global memory to its original state. Similar to the prior
example, overriding the permission_to_abort() method can be
done in such a manner which prevents lower priority transaction
from aborting a higher priority transaction as shown below:

Priority Inversion for Invalidating Consistency.

    class priority_cm :
    public core::base_contention_manager {
    public:
        // method invoked before lhs transaction
        // aborts rhs transaction
        bool permission_to_abort(transaction const &lhs,
                transaction const &rhs) {
            return lhs.priority() >= rhs.priority();
        }
    };
    
With priority inversion preventable for both validating and invalidating
consistency modes, transactions now need some mechanism
to control their priority. __Boost_STM__ allows for such control
through the raise_priority() interface. By iteratively calling
raise_priority(), preempted transactions can raise their
priority at each preemption ensuring their eventual commit. The
raise_priority() interface is implemented using a size_t
type. Additionally, __Boost_STM__ supplies a set_priority() interface
taking a size_t parameter allowing client code to set the
priority directly.

In order for raise_priority() to function correctly, the affected
transaction must not be destroyed upon transactional abort.
If the prioritized transaction is destroyed at each transactional abort,
raise_priority() will only raise the transaction's priority by
one each time. In order to demonstrate how raise_priority()
can be used in practice, we use a wrapper transaction around
the internal_insert()'s transaction. However, in this case the
wrapper transaction is not destroyed upon successive iterations.
The restart_transaction() interface must be called for
transactions that are not destroyed after being aborted. This necessary
step clears the state from the previously failed transactional
run. As shown in the below code, the restart_transaction()
is only called when an aborted exception is caught. This is because
end_transaction() throws an exception when the transaction
is aborted. Following this implementation paradigm, handling
aborted transactions is relatively straightforward as all aborted
transactions follow the same exception-based path.

The below example combines all of these aspects together into
a dynamically prioritized composed transaction. The composition
is slightly different than what has been shown previously - instead
of using composition for wrapping two methods into a larger transaction,
we use composition to override the internal transaction's
implementation to improve the richness of its behavior, a relatively
novel concept for composition.

Dynamically Prioritized Composed Transaction.

    bool insert(list_node<T> const &node) {
        bool success = true;
        transaction_state s = e_no_state;
        transaction t;
        for (; s != e_committed; t.raise_priority()) {
            try {
                internal_insert(node, success);
                s = t.end_transaction();
            } catch (aborted_transaction_exception&) { 
                t.restart_transaction(); 
            }
            if (!success) return false; // on list
        }
        return true;
    }

The above example demonstrates a number of important concepts
with __Boost_STM_s__ extensible contention manager and its implementation
of composition. First, it shows how to avoid priority
inversion, using dynamically prioritize transactions, in conjunction
with a prioritized overridden contention manager for both validation
and invalidation consistency schemes. Second, it demonstrates
how transactions which are aborted but not destroyed can be
restarted with the aborted transaction catch clause. Third, the example
explains how ordinary transactions can be enriched by layering
composed transactions on top of them without changing the underlying
original code. Lastly, it reveals some of __Boost_STM_s__ internal
priority processing which requires a additional amount of explanation,
as follows.

__Boost_STM_s__ Internal Write-Write Abort Process. 

As the above priority assigned transaction demonstrates, the outer transaction
has increasing priority while the inner transaction, the one
within internal_insert(), does not. Yet, the inner transaction
is not aborted due to the outer transaction's priority. This is handled
internally via __Boost_STM_s__ abort process by two fundamental
ideas. 

# As previously explained, all transactions of the same
thread share transactional memory, this allows the outer transaction
to be seen as using the same memory as the inner transaction.
Thus, when the inner transaction is flagged to be aborted, the outer
transaction must also be flagged to be aborted as well, since it
would have the same memory conflicts. However, when checking
the outer transaction's priority, the contention manager's priority
method would see the outer transaction as having higher priority
than the committing transaction if it had already been aborted
once and the committing transaction had not. The priority analysis
of the outer transaction compared to the committing transaction
would thereby force the committing transaction to abort instead of
the outer transaction. 

# __Boost_STM_s__ abort mechanism does not
abort any transactions until it has walked all transactions, passing
all the permission_to_abort() checks. Therefore, even if the
inner transaction is flagged to be aborted, since all transactions
must be successfully walked in order to abort any transaction, the
outer transaction's priority will cause the committing transaction
to abort, thereby saving the inner transaction from being affected.
An example of this, taken directly from __Boost_STM_s__ implementation,
is shown below (some code has been removed or shorted to
simplify the example):

    void abort_conflicting_writes_on_write_set() {
        trans_list aborted;
        // iterate through all tx's written memory
        for (write_set::iterator i = writes().begin(); writes().end() != i; ++i) {
            // iterate through inflight transactions
            for (trans::iterator j = inflight_.begin(); inflight_.end() != j; ++j) {
                transaction *t = (transaction*)*j;
                // if writing to this write_set, store it
                if (t->writes().end() != t->writes().find(i->first)) {
                    if (cm_->permission_to_abort(*this, *t))
                        aborted.push_front(t);
                    else
                        throw aborted_transaction_exception("");
                }
            }
        }
        // ok, forced to aborts are allowed, do them
        for (trans_list::iterator k = aborted.begin(); aborted.end() != k; ++k) {
            (*k)->forced_to_abort() = true;
        }
    }
    
Priority Inversion Allowed. 

From the above code examples,
one may question why the default behavior implemented within
__Boost_STM__ does not automatically integrate priority into transactions,
as it could be integrated within restart_transaction().
First, each problem is different and integrating priority only into
restart_transaction() would not cover all cases (e.g., when
the outer transaction was terminated). Second, building an automatic
priority inversion handling scheme would eliminate some of
the natural optimizations granted from different updating policies.
For example, deferred updating allows multiple writers of the same
memory to execute simultaneously. This behavior enables deferred
updating the ability to process the fastest completing transactions
first. If a priority system was integrated directly into __Boost_STM__,
this optimization would be lost. In addition, direct updating optimizes
writes by writing directly to global memory. As such, direct
updating suffers greater penalties for aborted transactions due to
required restoration of global memory. In this case, more transactional
aborts would occur if __Boost_STM__ built-in a default priority
inversion handler. Considering these factors, as well as many others,
__Boost_STM__ does not build transactional priority into its system.
Instead, we leave this implementation up to client-side implementors,
as they will have a better understanding of their problem domain
and be able to more correctly implement the right contention
manager for their specific needs.

The Future of Parallel Programming. 

An important distinction
regarding priority within transactions versus priority within
more classical synchronization mechanisms, like locks, is that
same functional units can be executed simultaneously by different
threads yielding different priorities. For example, two threads
can be executing the above insert transaction, one thread which
has just begun its first run will have a priority of 0, while a second
transaction which has attempted to run the insert operation 99 times
previously, would have a priority of 99. The important distinction
here is that classical critical section synchronization mechanisms
can have only a single priority per functional unit (e.g., insert,
remove, lookup operation) due to the innate limitations of single
thread critical section execution. With transactions, this limitation
is removed and new concepts of priority begin to emerge. Priority
inversion can then extend beyond its traditional meaning and
extend into a new category which incorporates differing priority
within the same functional unit. These new concepts may reshape
the way classical parallel problems are thought of in the future,
especially in relation to transactional memory.

[endsect]

[endsect]
