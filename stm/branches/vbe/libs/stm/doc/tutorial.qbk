[/
  (C) Copyright 2009 Justin E. Gottchlich.
  (C) Copyright 2009 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]



[section:tutorial Tutorial]

A number of example transactions are presented in this section using the __Boost_STM__ library. The first example illustrates how to write a transactional linked list insert operation. The second example demonstrates composition, combining a transactional insert operation with a transactional remove operation which compose into a larger, single move transaction. Next, a minor but important detail regarding memory addresses within the transactional workspace is given. Finally, an example of how to handle priority inversion for validating and invalidating consistency schemes using __Boost_STM_s__ extensible contention manager and compositional framework is provided. The final example demonstrates a number of important aspects of __Boost_STM_s__ implementation, such as, differing priority inversion mechanics for different consistency models, transactional attribute enrichment via composition and threaded memory sharing amongst transactions.

While most of the examples are intuitive and a complete understanding of the __Boost_STM__ API is not needed for a high-level understanding of its functionality, a complete description of all interfaces used below can be found in the referenced section.



[section A Simple Transaction]

In this example, we build a linked list insert transactional operation using __Boost_STM__. The example is shown in three segments: the client code which inserts 100 items into the list, the insert operation which client code calls, the internal insert operation which the exposed insert operation calls.

[heading Client Invoked Inserts]

    tx_ptr<linked_list<int> > llist;
    ...
    for (int i = 0; i < 100; ++i) {
        use_atomic(_) {
            llist->insert(i);
        }
    }

After inspecting the above client invoked insert code it is apparent that the code itself shows no deep signs of being transactional. The two exceptions are the declaration of the list using a tx_ptr smart pointer and the fact that the insertion of the 100 elements is atomic. This is our desired behavior. As far as the client side programmer is concerned, there is no additional code needed to perform a transactional linked list insert over a non-transactional linked list insert. Obviously, this simplistic behavior eases the introduction of TM solutions into algorithms of new and legacy systems.

[heading Linked list declaration]

A clasical linked list use a list node chained following the memer next_. On a transactional context we nedd to state that the pointer to the next node is a transactional one. This is reached using the smart pointer tx_ptr<>

    template <typename T>
    struct list_node {
        tx_ptr<list_node<T> > next_;
    }

    template <typename T>
    class linked_list {
    // ...
    private:
        tx_ptr<list_node<T> > head_;
    };

[heading Insert retry transaction]

    void insert(T const &val) {
        for (boost::stm::transaction _; !_.committed() && _.restart(); _.no_throw_end())
            try {
                // ... see below
            } catch (aborted_transaction_exception&) {}
    }

The exposed insert code performs two key operations: (1) it retries the transaction until it succeeds (commits) and (2) it catches aborted transaction exceptions. The retry code is perhaps the largest visible section of code overhead for the transactional linked list insert operation. While there are other C++ mechanisms to retry transactions, like gotos or macro-based approaches, we believe a simple loop is currently the best solution for TM retry behavior in C++. Others before us have implemented differing solutions that have smaller code footprints, but violate large-scale design concerns, break compositionality potential and hide or impose large language penalties. As such, we currently accept the loop overhead as a small inconvenience and avoid breaking language semantics.

The aborted_transaction_exception allows __Boost_STM__ to be exception neutral while also gaining performance benefits of early notification of doomed transactions. The above example demonstrates this behavior in practice with its absorption of aborted transactions and only aborted transactions.

[heading Insert specific]

            upgrd_ptr<list_node<T> > prev(_, head_);
            upgrd_ptr<list_node<T> > curr(_, head_->next_);
            while (curr) {
                if (curr->value_ == val) return;
                else if (curr->value_ > val) break;
                prev = curr;
                curr = curr->next_;
            }
            if (!curr || (curr->value_ > val)) {
                make_wr_ptr(_, prev)->next_ =
                    BOOST_STM_NEW(_,transactional_object<list_node<T> >(val, curr));
            }

The above example illustrates the simplicity of __Boost_STM__ transactions and their interfaces. The transactional implementation is nearly identical to a non-transactional implementation with the exception of some annotations. The templatized functions within the transaction class ensure type-safety is maintained without any necessary type-casts. Due to exact type correctness, as demonstrated in the calls to make_wr_ptr(), daisy-chained method invocation can be performed allowing streamlined usage. These aspects help make __Boost_STM__ transactions small and easy to understand.

upgrd_ptr is a read only smart pointer that can be upgraded to a read/write smart pointer.
Once the smart pointer is constructed (associating it to the current transaction), the user can access any member as if it was non transactional.

make_wr_ptr is a read/write smart pointer factory. The returned wr_ptr<> allows to modify the pointee object.

One minor, but vital, detail is in the way new objects are created on a transactional context. Rather than hide this difference, it is intentionally exposed here to draw out the memory access differences required for writes to new and existing memory. We explain this difference in detail later in this section.

In order to simplify the retry mechanism the macro __use_atomic__ is provided so the user can just write

    void insert(T const &val) {
        use_atomic(_) {
            upgrd_ptr<list_node<T> > prev(_, head_);
            upgrd_ptr<list_node<T> > curr(_, head_->next_);
            while (curr) {
                if (curr->value_ == val) return;
                else if (curr->value_ > val) break;
                prev = curr;
                curr = curr->next_;
            }
            if (!curr || (curr->value_ > val)) {
                make_wr_ptr(_, prev)->next_ =
                    BOOST_STM_NEW(_,transactional_object<list_node<T> >(val, curr));
            }
        }
    }

We could also write the following, but this is less efficient as tx_ptr is a smart pointer that associated the pointer to the current transaction for writting. The use of the smart pointer upgrd_ptr and the smart pointer factory function make_wr_ptr allows to make the difference kind of access.

    void insert(T const &val) {
        use_atomic(_) {
            tx_ptr<list_node<T> > prev(head_);
            tx_ptr<list_node<T> > curr(head_->next_);
            while (curr) {
                if (curr->value_ == val) return;
                else if (curr->value_ > val) break;
                prev = curr;
                curr = curr->next_;
            }
            if (!curr || (curr->value_ > val)) {
                prev->next_ =
                    BOOST_STM_NEW(_,transactional_object<list_node<T> >(val, curr));
            }
        }
    }

[endsect]

[section A Composable Transaction]

The below example builds upon the previous example by adding a remove operation. We combine the insert and remove operations and build a transactional move operation that compose into a single transaction. Composition is a key aspect for TM systems. __Boost_STM_s__ ability to compose transactions from pre-existing transactions is fundamental to its design.

In the following example, the first section shows client code invoking the move operation. Next, the internal remove operation is shown, demonstrating its transactional independence. Last, the external move operation is explained, combining the internal insert and remove linked list operations resulting in a composed, single transaction.

Client Invoked Inserts / Moves.

    tx_ptr<linked_list<int> > llist;
    ...
    atomic(_) {
        for (int i = 0; i < 100; ++i) {
            llist->insert(i);
        }
        for (int j = 0; j < 100; ++j) {
            llist->move(j, -j);
        }
    }

The client invoked inserts and moves are fairly straight forward. The insert operations are performed first then the original items are moved to a new location by inverting their value. Again, from a client programming perspective, there is no hint that this code is transactional, which is our intended goal.

Remove

    void remove(const T& val) {
        use_atomic(_) {
            // find the node whose val matches the request
            upgrd_ptr<list_node<T> > prev(_,head_);
            upgrd_ptr<list_node<T> > curr(_,prev->next_);
            while (curr) {
                // if we find the node, disconnect it and end the search
                if (curr->value_ == val) {
                    make_wr_ptr(_, prev)->next_=curr->next_;
                    delete_ptr(_,curr);
                    break;
                } else if (curr->value_ > val) {
                    // this means the search failed
                    break;
                }
                prev = curr;
                curr = prev->next_;
            }
        }
    }

As was the case with the insert(), the above remove() method is almost identical to how a normal linked list remove operation would be implemented, with the exception of the atomic guard and a few __Boost_STM__ API calls. Again, this is ideal, as it leads to intuitive transactional programming, requiring only a minor learning curve for the algorithms developer.

Composed External Move

    void move(T const &v1, T const &v2) {
        use_atomic {
            remove(v1);
            insert(v2);
        }
    }

The move() implementation do not requires any overhead required in non-transactional implementations, other than using the atomic guard. The remainder of the code is preserved.

[endsect]


[section A Dynamically Prioritized, Composed Transaction]

The following subsection discusses how priority inversion is handled within __Boost_STM__ using dynamic priority assignment. Two solutions are presented for the different consistency models, one for validation and one for invalidation. Following the two examples which detail how to override contention management interfaces, a dynamically prioritized transaction is presented, demonstrating how transactions interact with the prior implementations. Priority inversion in transactional memory occurs when a lower priority transaction causes a higher priority transaction to abort. With STM lock-based (and non-blocking) systems, priority inversion does not happen on the same scale as that of direct lock-based solutions. The different cases of priority inversion between direct locking solutions and TM solutions are due to TM's natural avoidance of critical sections. However, priority inversion in TM can easily occur if, for example, a long running transaction is continually preempted by shorter running transactions which always commit before the longer transaction.


In order to prevent such priority inversion scenarios, two extensible contention manager (CM) virtual methods are provided to allow client-side implementations a way to handle different scenarios based on the consistency model currently in use. The first interface, abort_before_commit(), allows a user-defined contention manager mechanism to abort a transaction before it commits. Although __Boost_STM__ does not yet implement validation, once it becomes available, client-side validating algorithms which want to avoid priority inversion will need to override abort_before_commit() to iterate over in-flight transactions and abort the current in-process transaction if another in-flight transaction exists of higher priority. All in-flight transactions can be accessed by a call to in_flight_transactions() which returns the set of active transactions. As such, one could build an overridden abort_before_commit() which always caused lower priority committing transactions to abort in the event a higher priority transaction is currently in-flight. One possible implementation is shown below. For code simplicity, the following code has removed some static class accessors and namespaces.


Priority Inversion for Validating Consistency.

    class priority_cm :
    public core::base_contention_manager {
    public:
        // method invoked prior tx commit
        bool abort_before_commit(transaction const &t) {
            in_flight_transaction_container::const_iterator i = in_flight_transactions().begin();
            for (; in_flight_transactions().end() != i; ++i) {
                if (t.priority() < (*i)->priority()){
                    return true;
                }
            }
            return false;
        }
    };

While the above approach is necessary for a validating system, it is largely a poor way to perform priority inversion checking. Firstly, it has the side-effect of causing unnecessary aborts for transactions which do not necessarily conflict, but simply have differing priority levels. Secondly, it is slow in that all transactions must be walked through each time a transaction commits. However, as an ad hoc solution for a validating system, the above priority inversion mechanism may be as close to correct as is possible. This solution is useful for validation, but should never be used for invalidation. Instead a second and more natural approach for invalidating systems to prevent priority inversion is to override the permission_to_abort() interface. The permission_to_abort() interface can only be used when __Boost_STM__ is performing invalidation.

The permission_to_abort() interface is called from __Boost_STM_s__ end_transaction() method when a committing transaction has found a second transaction it needs to abort for consistency. As such, the method takes two parameters, an lhs (lefthand side), the committing transaction, and an rhs (right-hand side), the transaction requested to be aborted. If permission is granted to abort the second transaction, the method returns true and the second transaction is aborted. If permission is not granted to abort the second transaction, the method returns false and upon returning the committing transaction aborts itself. All consistency checking for deferred updating is performed prior to any updating operation and thus memory is still in a completely legal uncommitted state until all consistency is performed. For direct updating aborts, the system simply follows its normal semantics of aborting the transaction by restoring global memory to its original state. Similar to the prior example, overriding the permission_to_abort() method can be done in such a manner which prevents lower priority transaction from aborting a higher priority transaction as shown below:

Priority Inversion for Invalidating Consistency.

    class priority_cm :
    public core::base_contention_manager {
    public:
        // method invoked before lhs transaction
        // aborts rhs transaction
        bool permission_to_abort(transaction const &lhs,
                transaction const &rhs) {
            return lhs.priority() >= rhs.priority();
        }
    };

With priority inversion preventable for both validating and invalidating consistency modes, transactions now need some mechanism to control their priority. __Boost_STM__ allows for such control through the raise_priority() interface. By iteratively calling raise_priority(), preempted transactions can raise their priority at each preemption ensuring their eventual commit. The raise_priority() interface is implemented using a size_t type. Additionally, __Boost_STM__ supplies a set_priority() interface taking a size_t parameter allowing client code to set the priority directly.

In order for raise_priority() to function correctly, the affected transaction must not be destroyed upon transactional abort. If the prioritized transaction is destroyed at each transactional abort, raise_priority() will only raise the transaction's priority by one each time. In order to demonstrate how raise_priority() can be used in practice, we use a wrapper transaction around the internal_insert()'s transaction. However, in this case the wrapper transaction is not destroyed upon successive iterations. The restart_transaction() interface must be called for transactions that are not destroyed after being aborted. This necessary step clears the state from the previously failed transactional run. As shown in the below code, the restart_transaction() is only called when an aborted exception is caught. This is because end_transaction() throws an exception when the transaction is aborted. Following this implementation paradigm, handling aborted transactions is relatively straightforward as all aborted transactions follow the same exception-based path.

The below example combines all of these aspects together into a dynamically prioritized composed transaction. The composition is slightly different than what has been shown previously - instead of using composition for wrapping two methods into a larger transaction, we use composition to override the internal transaction's implementation to improve the richness of its behavior, a relatively novel concept for composition.

Dynamically Prioritized Composed Transaction.

    bool insert(list_node<T> const &node) {
        bool success = true;
        transaction_state s = e_no_state;
        transaction t;
        for (; s != e_committed; t.raise_priority()) {
            try {
                internal_insert(node, success);
                s = t.end_transaction();
            } catch (aborted_transaction_exception&) {
                t.restart_transaction();
            }
            if (!success) return false; // on list
        }
        return true;
    }

The above example demonstrates a number of important concepts with __Boost_STM_s__ extensible contention manager and its implementation of composition. First, it shows how to avoid priority inversion, using dynamically prioritize transactions, in conjunction with a prioritized overridden contention manager for both validation and invalidation consistency schemes. Second, it demonstrates how transactions which are aborted but not destroyed can be restarted with the aborted transaction catch clause. Third, the example explains how ordinary transactions can be enriched by layering composed transactions on top of them without changing the underlying original code. Lastly, it reveals some of __Boost_STM_s__ internal priority processing which requires a additional amount of explanation, as follows.

__Boost_STM_s__ Internal Write-Write Abort Process.

As the above priority assigned transaction demonstrates, the outer transaction has increasing priority while the inner transaction, the one within internal_insert(), does not. Yet, the inner transaction is not aborted due to the outer transaction's priority. This is handled internally via __Boost_STM_s__ abort process by two fundamental ideas.

# As previously explained, all transactions of the same thread share transactional memory, this allows the outer transaction to be seen as using the same memory as the inner transaction. Thus, when the inner transaction is flagged to be aborted, the outer transaction must also be flagged to be aborted as well, since it would have the same memory conflicts. However, when checking the outer transaction's priority, the contention manager's priority method would see the outer transaction as having higher priority than the committing transaction if it had already been aborted once and the committing transaction had not. The priority analysis of the outer transaction compared to the committing transaction would thereby force the committing transaction to abort instead of the outer transaction.

# __Boost_STM_s__ abort mechanism does not abort any transactions until it has walked all transactions, passing all the permission_to_abort() checks. Therefore, even if the inner transaction is flagged to be aborted, since all transactions must be successfully walked in order to abort any transaction, the outer transaction's priority will cause the committing transaction to abort, thereby saving the inner transaction from being affected. An example of this, taken directly from __Boost_STM_s__ implementation, is shown below (some code has been removed or shorted to simplify the example):

    void abort_conflicting_writes_on_write_set() {
        trans_list aborted;
        // iterate through all tx's written memory
        for (write_set::iterator i = writes().begin(); writes().end() != i; ++i) {
            // iterate through inflight transactions
            for (trans::iterator j = inflight_.begin(); inflight_.end() != j; ++j) {
                transaction *t = (transaction*)*j;
                // if writing to this write_set, store it
                if (t->writes().end() != t->writes().find(i->first)) {
                    if (cm_->permission_to_abort(*this, *t))
                        aborted.push_front(t);
                    else
                        throw aborted_transaction_exception("");
                }
            }
        }
        // ok, forced to aborts are allowed, do them
        for (trans_list::iterator k = aborted.begin(); aborted.end() != k; ++k) {
            (*k)->forced_to_abort() = true;
        }
    }

[heading Priority Inversion Allowed]

From the above code examples, one may question why the default behavior implemented within __Boost_STM__ does not automatically integrate priority into transactions, as it could be integrated within restart_transaction(). First, each problem is different and integrating priority only into restart_transaction() would not cover all cases (e.g., when the outer transaction was terminated). Second, building an automatic priority inversion handling scheme would eliminate some of the natural optimizations granted from different updating policies. For example, deferred updating allows multiple writers of the same memory to execute simultaneously. This behavior enables deferred updating the ability to process the fastest completing transactions first. If a priority system was integrated directly into __Boost_STM__, this optimization would be lost. In addition, direct updating optimizes writes by writing directly to global memory. As such, direct updating suffers greater penalties for aborted transactions due to required restoration of global memory. In this case, more transactional aborts would occur if __Boost_STM__ built-in a default priority inversion handler. Considering these factors, as well as many others, __Boost_STM__ does not build transactional priority into its system. Instead, we leave this implementation up to client-side implementors, as they will have a better understanding of their problem domain and be able to more correctly implement the right contention manager for their specific needs.

[heading The Future of Parallel Programming]

An important distinction regarding priority within transactions versus priority within more classical synchronization mechanisms, like locks, is that same functional units can be executed simultaneously by different threads yielding different priorities. For example, two threads can be executing the above insert transaction, one thread which has just begun its first run will have a priority of 0, while a second transaction which has attempted to run the insert operation 99 times previously, would have a priority of 99. The important distinction here is that classical critical section synchronization mechanisms can have only a single priority per functional unit (e.g., insert, remove, lookup operation) due to the innate limitations of single thread critical section execution. With transactions, this limitation is removed and new concepts of priority begin to emerge. Priority inversion can then extend beyond its traditional meaning and extend into a new category which incorporates differing priority within the same functional unit. These new concepts may reshape the way classical parallel problems are thought of in the future, especially in relation to transactional memory.

[endsect]

[section Can a transactional object embeed another transactional object?]

Let me show what happens when we emmend transactional objects:
    class C : public transaction_object<C> {...};

    class E : public transaction_object<E> {
        C c;
        int i;
    };

E e;

When a thread T1 modifies e (and possibly the b part) on a transaction another thread T2 can modify e.c on another transaction. When the two transactional objects overlap the STM system is unable to detect this efficiently, having as consequence an inconsistency.

The following pseudo-code shows the

        T1                  T2
    1   atomic {            atomic {
    2       e.i=0;              e.c=A;
    3                       }
    4   }


When T2 commits on (3) e.c will be modified, but T1 will modify the complete E independent of the e.c modification doen by T2, overwriting the e.c with its old value. T1 will be coherent, but not T2. If we want to allow such a scheme, we have several possibilities

* implicit: take care of overlaping transactional objects, so we can detect when T1 commits that an overlaping TO e.c has been modified, so the transaction on T1 is aborted and retried.
* explicit: the developper of T1 must notify the STM system that the transactional object e constains a transactional object e.c
* declarative: the developper of E would declare that it contains an emmbeed transactional object C at E::c, so the STM system will use this explicit information when an E is accesses using the STM interface.

The implicit approach is the more transparent for the user but it is also the less efficient. It need to add a virtual function quering the size of the class, and to modify the conflic detection algorithm (maybe the write_list must be a write_set, ordered by the address)

The explit approach let the user with a lot of burden and risk of error when access to an E is done on a transaction. This needs to add the size and the algorithm which adds transactional object on the write_list (maybe the write_list must be a write_interval_set, ordered by the address).

The declarative concentrate on a single place, so the user will be not too concerned, and this open possible optimizations.


Supose now that we are able to embeed transactional objects. and that the T1 not only opens for writing e, but also e.c either on the same block on on a block (or nested transaction). The STM will see both address to be written, and even if there should be no risk of incoherence the object e.c will be copied twice.

[endsect]

[section Returning values from a fucntion]

[heading Returning from outside the transaction context]

The simgle way consists is using a local variable declared outside the transaction context.

    int inc_c() {
        int res;
        atomic(_) {
            res = *(_.read(c))+i;
        } end_atom;
        return res;
    }

[heading Returning from inside]

The following attempt does not work as the transaction will not be commited.

    int inc_c(int i) {
        atomic(_) {
            write_ptr<tx_int> tx_c(_,c);
            return *(tx_c)+=i;
        } end_atom;
    }

We need to commit before returning. SO we will need any way a local variable storing the result before commiting.

    int inc_c(int i) {
        atomic(_) {
            write_ptr<tx_int> tx_c(_,c);
            int res = *(tx_c)+=i;
            _.commit();
            return res;
        } end_atom;
    }

[endsect]

[section Pointer to transactional objects]

Access to a pointer to a transaction object works, but this do not take care of modifications of the pointer itself.

[heading Using the mixin transaction_object<>]

Let B the TO made using the mixin transaction_object.

    class B : public transaction_object<B> {
    public:
        void virtaul fct();
    };

How a variable pointing to B must be declared. The fact that B is a transactional object do not means that a pointer to it is one. We need a class that wraps the pointer

    template <typename TO>
    class transaction_object_ptr : public transaction_object<transaction_object_ptr<TO> > {
    public:
        TO* ptr_;
        typedef transaction_object_ptr<TO> this_type;
        typedef transaction_object<transaction_object_ptr<TO> > base_type;
        transaction_object_ptr() :  base_type(), ptr_(0) {
        }
        transaction_object_ptr(const transaction_object_ptr & rhs) :  base_type(rhs),  ptr_(rhs.ptr_) {
        }
        transaction_object_ptr(transaction_object_ptr & rhs) :  base_type(rhs), ptr_(rhs.rhs) {
        }
        transaction_object_ptr(TO* ptr) :  base_type(), ptr_(ptr) {
        }
        ~transaction_object_ptr() {
        }
        this_type& operator=(TO* rhs) {
            ptr_=rhs;
            return *this;
        }

        TO* get() const {
            std::cout << "get" << std::endl;
            return ptr_;
        }

        inline TO& operator*() const { return *get(); }
        inline TO* operator->() const { return get(); }
    };

Let declare a pointer to B

    transaction_object_ptr<B> ptr_b;


    atomic(_) {
        write_ptr< pointer<B> > tx_ptr_b_ptr(_, ptr_b);
        *tx_ptr_b_ptr=BOOST_STM_NEW(_, B());
    }


[endsect]

[section Polymorphic]

How the user can defien a transactional class D inheriting from a transactional class B

[heading:mixin Using the mixin transaction_object<>]

Let B the base class

    class B : public transaction_object<B> {
    public:
        void virtaul fct();
    };

The derived class must declare D as follows:

    class D : public transaction_object<D,B> {
        ...
    };

How a variable pointing to B must be declared. The fact that B is a transactional object do not means that a pointer to it is one.

    pointer<B> ptr_b = 0

How can we assign a pointer to D?

    write_ptr<B*> tx_ptr_b_ptr(_,ptr_b);
    *ptr_b = BOOST_STM_NEW(_, D())

[heading::wrapper Using the wrapper transactional_object<>]

[endsect]

[section Can non transactional objets participate in a transaction?]

Non transactional objects are the objects that do not inherit from base_transaction_object.

[endsect]

[section Lock aware]

[endsect]

[endsect]
